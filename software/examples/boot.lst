Sections:
00: "CODE" (0-929C)
01: "DATA" (0-700)


Source: "boot.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022-2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;-------------------------------------------------------------------------------
                            	    37: ;
                            	    38: ; system memory map
                            	    39: ;
                            	    40: ;
                            	    41: ; 00000000 +----------------+      <+
                            	    42: ;          | startup sp,pc  | 8 B   |
                            	    43: ; 00000008 +----------------+       |
                            	    44: ;					 |    vectors     | pair shared+
                            	    45: ; 00000400 +----------------+       |
                            	    46: ;					 |   bios mem     |       |
                            	    47: ; 00001000 +----------------+       |
                            	    48: ;					 |   bios code    |       |
                            	    49: ; 00020000 +----------------+      <+
                            	    50: ;					 |    unused      |
                            	    51: ; 00040000 +----------------+
                            	    52: ;					 |   local ram    |
                            	    53: ; 00048000 +----------------+
                            	    54: ;					 |    unused      |
                            	    55: ; 00100000 +----------------+
                            	    56: ;					 |   global ram   |
                            	    57: ; 00101000 +----------------+
                            	    58: ;					 | serial rcvbuf  |
                            	    59: ; 00102000 +----------------+
                            	    60: ;          | serial xmitbuf |
                            	    61: ; 00103000 +----------------+
                            	    62: ;					 |    unused      |
                            	    63: ; 40000000 +----------------+
                            	    64: ;          |                |
                            	    65: ;          |                |
                            	    66: ;          |                |
                            	    67: ;          :  dram memory   : 1GB MB
                            	    68: ;          |                |
                            	    69: ;          |                |
                            	    70: ;          |                |
                            	    71: ; 80000000 +----------------+
                            	    72: ;          |                |
                            	    73: ;          :     unused     :
                            	    74: ;          |                |
                            	    75: ; FD000000 +----------------+
                            	    76: ;          |                |
                            	    77: ;          :    I/O area    : 1.0 M
                            	    78: ;          |                |
                            	    79: ; FFE00000 +----------------+
                            	    80: ;          |                |
                            	    81: ;          :     unused     :
                            	    82: ;          |                |
                            	    83: ; FFFFFFFF +----------------+
                            	    84: ;
                            	    85: ;-------------------------------------------------------------------------------
                            	    86: ;
                            	    87: HAS_MMU equ 0
                            	    88: NCORES equ 4
                            	    89: 
                            	    90: CTRLC	EQU		$03
                            	    91: CTRLH	EQU		$08
                            	    92: CTRLS	EQU		$13
                            	    93: CTRLX	EQU		$18
                            	    94: CTRLZ	EQU		$1A
                            	    95: LF		EQU		$0A
                            	    96: CR		EQU		$0D
                            	    97: XON		EQU		$11
                            	    98: XOFF	EQU		$13
                            	    99: EOT		EQU		$04
                            	   100: BLANK EQU		$20
                            	   101: 
                            	   102: SC_F12  EQU    $07
                            	   103: SC_C    EQU    $21
                            	   104: SC_T    EQU    $2C
                            	   105: SC_Z    EQU    $1A
                            	   106: SC_KEYUP	EQU		$F0
                            	   107: SC_EXTEND   EQU		$E0
                            	   108: SC_CTRL		EQU		$14
                            	   109: SC_RSHIFT	EQU		$59
                            	   110: SC_NUMLOCK	EQU		$77
                            	   111: SC_SCROLLLOCK	EQU	$7E
                            	   112: SC_CAPSLOCK		EQU	$58
                            	   113: SC_ALT		EQU		$11
                            	   114: SC_LSHIFT	EQU		$12
                            	   115: SC_DEL		EQU		$71		; extend
                            	   116: SC_LCTRL	EQU		$58
                            	   117: SC_TAB      EQU		$0D
                            	   118: 
                            	   119: 	include "..\Femtiki\device.x68"

Source: "..\Femtiki\device.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: DEV_INIT equ 0
                            	    38: DEV_STAT equ 1
                            	    39: DEV_PUTCHAR equ 2
                            	    40: DEV_PUTBUF equ 3
                            	    41: DEV_GETCHAR equ 4
                            	    42: DEV_GETBUF equ 5
                            	    43: DEV_SETINPOS equ 6
                            	    44: DEV_SETOUTPOS equ 7
                            	    45: DEV_GETCHAR_DIRECT equ 8
                            	    46: DEV_PEEKCHAR equ 9
                            	    47: DEV_PEEKCHAR_DIRECT equ 10
                            	    48: DEV_PUTCHAR_DIRECT equ 11
                            	    49: 
                            	    50: DCB_MAGIC equ	0			; 'DCB'
                            	    51: DCB_NAME	equ 4			; 15 chars+NULL
                            	    52: DCB_CMDPROC	equ 24	; 8 byte pointer to command processor
                            	    53: DCB_OUTPOS equ 32
                            	    54: DCB_INPOS equ 36
                            	    55: DCB_INBUFPTR equ 40
                            	    56: DCB_OUTBUFPTR equ 44
                            	    57: DCB_INBUFSIZE equ 48
                            	    58: DCB_OUTBUFSIZE equ 52
                            	    59: DCB_INROWS equ 56
                            	    60: DCB_INCOLS equ 57
                            	    61: DCB_OUTROWS equ 58
                            	    62: DCB_OUTCOLS equ 59
                            	    63: DCB_LASTERC equ 60
                            	    64: DCB_SIZE equ 64
                            	    65: 
                            	    66: ;Standard Devices are:
                            	    67: 
                            	    68: ;#		Device					Standard name
                            	    69: 
                            	    70: ;0		NULL device 			NUL		(OS built-in)
                            	    71: ;1		Keyboard (sequential)	KBD		(OS built-in, ReadOnly)
                            	    72: ;2		Video (sequential)		VID		(OS built-in, WriteOnly)
                            	    73: ;3		Printer (parallel 1)	LPT		(OS built-in)
                            	    74: ;4		Printer (parallel 2)	LPT2	(OS built-in)
                            	    75: ;5		RS-232 1				COM1	(OS built-in)
                            	    76: ;6		RS-232 2				COM2	(OS built-in)
                            	    77: ;7		RS-232 3				COM3	(OS built-in)
                            	    78: ;8		RS-232 4				COM4	(OS built-in)
                            	    79: ;9
                            	    80: ;10		Floppy					FD0 	(OS built-in)
                            	    81: ;11		Floppy					FD1 	(OS built-in)
                            	    82: ;12		Hard disk				HD0 	(OS built-in)
                            	    83: ;13		Hard disk				HD1 	(OS built-in)
                            	    84: ;14
                            	    85: ;15
                            	    86: ;16
                            	    87: ;17
                            	    88: ;18
                            	    89: ;19
                            	    90: ;20
                            	    91: ;21
                            	    92: ;22
                            	    93: ;23
                            	    94: 

Source: "boot.x68"
                            	   120: 	include "..\Femtiki\FemtikiTop.x68"

Source: "..\Femtiki\FemtikiTop.x68"
                            	     1: 	include "..\Femtiki\const.x68"

Source: "..\Femtiki\const.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2020-2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: TS_NONE			EQU		0
                            	    38: TS_READY		EQU		1
                            	    39: TS_DEAD			EQU		2
                            	    40: TS_MSGRDY		EQU		4
                            	    41: TS_WAITMSG	EQU		8
                            	    42: TS_TIMEOUT	EQU		16
                            	    43: TS_PREEMPT	EQU		32
                            	    44: TS_RUNNING	EQU		128
                            	    45: 
                            	    46: ; error codes
                            	    47: E_Ok		EQU		$00
                            	    48: E_Arg		EQU		$01
                            	    49: E_Func  EQU    $02
                            	    50: E_BadMbx	EQU		$04
                            	    51: E_QueFull	EQU		$05
                            	    52: E_NoThread	EQU		$06
                            	    53: E_NotAlloc	EQU		$09
                            	    54: E_NotSupported EQU $0A
                            	    55: E_NoMsg		EQU		$0b
                            	    56: E_Timeout	EQU		$10
                            	    57: E_BadAlarm	EQU		$11
                            	    58: E_NotOwner	EQU		$12
                            	    59: E_QueStrategy EQU		$13
                            	    60: E_DCBInUse	EQU		$19
                            	    61: ; Device driver errors
                            	    62: E_BadDevNum	EQU		$20
                            	    63: E_NoDev		EQU		$21
                            	    64: E_BadDevOp	EQU		$22
                            	    65: E_ReadError	EQU		$23
                            	    66: E_WriteError EQU		$24
                            	    67: E_BadBlockNum	EQU	$25
                            	    68: E_TooManyBlocks	EQU	$26
                            	    69: 
                            	    70: ; resource errors
                            	    71: E_NoMoreMbx	EQU		$40
                            	    72: E_NoMoreMsgBlks	EQU	$41
                            	    73: E_NoMoreAlarmBlks	EQU $44
                            	    74: E_NoMoreTCBs	EQU	$45
                            	    75: E_NoMem		EQU 12
                            	    76: 
                            	    77: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     2: 	include "..\Femtiki\config.x68"

Source: "..\Femtiki\config.x68"
                            	     1: MAX_TID		EQU		4095
                            	     2: NR_TCB		EQU		4096
                            	     3: NTASK     EQU   4096    ; number of threads allowed
                            	     4: LOG_TCBSZ	EQU		8
                            	     5: LOG_PGSZ	EQU		10
                            	     6: LOG_ACBSZ EQU   12
                            	     7: OSPAGES		EQU		16			; pages of memory dedicated to OS
                            	     8: PAGESZ    EQU   16384  	; size of a page of memory
                            	     9: MEMSZ     EQU   32768   ; pages
                            	    10: MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                            	    11: NR_MSG		EQU		21842		; number of messages available
                            	    12: NR_MBX		EQU		9792
                            	    13: 
                            	    14: 
                            	    15: 
                            	    16: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     3: 	include "..\Femtiki\types.x68"

Source: "..\Femtiki\types.x68"
                            	     1: ; Thread Control Block
                            	     2: TCBMagic    EQU		$0000
                            	     3: TCBRegs  		EQU   $0004		; register set storage area
                            	     4: TCBUSP			EQU		$0044
                            	     5: TCBSSP			EQU		$0048
                            	     6: TCBSR				EQU		$004C
                            	     7: TCBPC				EQU		$0050
                            	     8: TCBStatus		EQU		$0054
                            	     9: TCBPriority	EQU		$0055
                            	    10: TCBWaitMbx	EQU		$0056
                            	    11: TCBHasFocus EQU   $005A
                            	    12: TCBStackBot	EQU		$005C
                            	    13: TCBMsgD1		EQU		$0060
                            	    14: TCBMsgD2		EQU		$0064
                            	    15: TCBMsgD3		EQU		$0068
                            	    16: TCBStartTick	EQU	$006C
                            	    17: TCBEndTick	EQU		$0070
                            	    18: TCBTicks		EQU		$0074
                            	    19: TCBException	EQU	$0078
                            	    20: TCBNext			EQU		$007C
                            	    21: TCBPrev			EQU		$0080
                            	    22: TCBAffinityBase	EQU	$0082
                            	    23: TCBAffinity	EQU		$0084
                            	    24: TCBTimeout	EQU		$0088
                            	    25: TCBtid      EQU   $008C
                            	    26: TCBmid      EQU   $0090
                            	    27: TCBappid    EQU   $0094
                            	    28: TCBOpMode   EQU   $0098
                            	    29: TCBMbxNext  EQU   $009C
                            	    30: TCBMbxPrev  EQU   $00A0
                            	    31: TCBThreadNum  EQU   $00A4
                            	    32: TCBAcbNext	EQU		$00A8
                            	    33: TCBAcbPrev	EQU		$00AC
                            	    34: TCBhMailboxes	EQU		$00B0
                            	    35: TCBName			EQU		$00C0
                            	    36: TCB_SIZE		EQU		$0100
                            	    37: 
                            	    38: MBX_MAGIC		equ		0
                            	    39: MBX_OWNER		equ		4		; tid of owning task
                            	    40: MBX_LINK    equ   8
                            	    41: MBX_TQHEAD  equ   12   ; link field for free list shared with task queue head
                            	    42: MBX_TQTAIL  equ   16
                            	    43: MBX_MQHEAD	equ		20
                            	    44: MBX_MQTAIL	equ		24
                            	    45: MBX_SIZE		equ		32
                            	    46: 
                            	    47: MSG_MAGIC   equ   0
                            	    48: MSG_LINK	  equ		4
                            	    49: MSG_RETADR  equ   8
                            	    50: MSG_TGTADR  equ   12
                            	    51: MSG_TYPE    equ   16
                            	    52: MSG_D1		  equ		20
                            	    53: MSG_D2		  equ		24
                            	    54: MSG_D3		  equ		28
                            	    55: MSG_SIZE	  equ		32
                            	    56: 
                            	    57: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     4: 
                            	     5: 	include "..\Femtiki\source\kernel\Femtiki_vars.x68"

Source: "..\Femtiki\source\kernel\Femtiki_vars.x68"
                            	     1: 
                            	     2: PAMShareCounts	EQU	$20000000	; one byte for each physical page of memory
                            	     3: tcbs						EQU	$20010000	; 4095*256 = 1MB
                            	     4: tcbs_end				EQU	$20020000
                            	     5: messages				EQU	$20020000	; 32*8192 (680*16=21760 messages)
                            	     6: messages_end		EQU	$20060000
                            	     7: mailboxes				EQU	$20060000
                            	     8: mailboxes_end		EQU	$20078000	;	12*8192 (816*12=9792 mailboxes)
                            	     9: acbs						EQU	$20080000	; 32*2*8192 =512kB
                            	    10: acbs_end				EQU	$20100000
                            	    11: 
                            	    12: 
                            	    13: sys_stacks			EQU	$DF0000
                            	    14: 
                            	    15: FemtikiVars			EQU	$00100200
                            	    16: PAMLastAllocate2	EQU		$00100218
                            	    17: RunningAID		EQU		$00100220
                            	    18: RunningTCB			EQU		$00100224
                            	    19: ACBPtrs				EQU		$00100228
                            	    20: MidStackBottoms	EQU		$00100264
                            	    21: FemtikiInited	EQU		$00100284
                            	    22: missed_ticks	EQU		$00100288
                            	    23: IOFocusList		EQU		$0010028C
                            	    24: IOFocusID			EQU		$001002AC
                            	    25: iof_switch		EQU		$001002AD
                            	    26: nMessage			EQU		$001002AE
                            	    27: nMailbox			EQU		$001002B0
                            	    28: hKeybdMbx			EQU		$001002BA
                            	    29: hFocusSwitchMbx		EQU		$001002BC
                            	    30: BIOS_RespMbx	EQU		$001002BE
                            	    31: hasUltraHighPriorityTasks	EQU		$001002C0
                            	    32: im_save				EQU		$001002C2
                            	    33: sp_tmp				EQU		$001002C4
                            	    34: startQNdx			EQU		$001002C6
                            	    35: NPAGES				EQU		$001002D8
                            	    36: syspages			EQU		$001002DA
                            	    37: mmu_FreeMaps	EQU		$001002E0
                            	    38: mmu_entries		EQU		$00100300
                            	    39: freelist			EQU		$00100302
                            	    40: hSearchMap		EQU		$00100304
                            	    41: OSActive			EQU		$00100305
                            	    42: FreeACB				EQU		$00100308
                            	    43: FreeTCB				EQU		$0010030C
                            	    44: FreeMSG				EQU		$00100310
                            	    45: FreeMBX				EQU		$00100314
                            	    46: TimeoutList		EQU		$00100318
                            	    47: QueueCycle    EQU   $0010031C
                            	    48: readyQ				EQU		$00100320		; 32 bytes per queue per core, 2 cores for now
                            	    49: readyQEnd			EQU		$00100360
                            	    50: FemtikiVars_end	EQU	$00100400
                            	    51: 
                            	    52: ;gc_stack		rmb		512
                            	    53: ;gc_pc				fcdw		0
                            	    54: ;gc_omapno		fcw			0
                            	    55: ;gc_mapno		fcw			0
                            	    56: ;gc_dl				fcw			0
                            	    57: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     6: 	code
                            	     7: 	even
                            	     8: 	include "..\Femtiki\source\kernel\tcb.x68"

Source: "..\Femtiki\source\kernel\tcb.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;------------------------------------------------------------------------------
                            	    38: ; Initialize variables related to TCBs.
                            	    39: ;------------------------------------------------------------------------------
                            	    40: 
                            	    41: TCBInit:
00:00000000 41F920010000    	    42: 	lea tcbs,a0
00:00000006 4E7B8013        	    43: 	movec a0,tcba
00:0000000A 700F            	    44: 	moveq #2*8-1,d0		; 2 cores, 32 bytes (8 lwords) per queue
00:0000000C 72FF            	    45: 	moveq #-1,d1			; value to set
00:0000000E 41F900100320    	    46: 	lea readyQ,a0			; clear out ready queue
                            	    47: .0001
00:00000014 20C1            	    48: 	move.l d1,(a0)+
00:00000016 51C8FFFC        	    49: 	dbra d0,.0001
00:0000001A 203C0003FFFF    	    50: 	move.l #TCB_SIZE*NR_TCB/4-1,d0
                            	    51: .clearTCBs
00:00000020 4298            	    52: 	clr.l (a0)+
00:00000022 51C8FFFC        	    53: 	dbra d0,.clearTCBs
00:00000026 4E75            	    54: 	rts
                            	    55: 
                            	    56: ;------------------------------------------------------------------------------
                            	    57: ; Convert a TCB handle into a pointer.
                            	    58: ;
                            	    59: ; Parameters:
                            	    60: ;		d0 = TCB handle
                            	    61: ; Returns:
                            	    62: ;		a0 = pointer to TCB
                            	    63: ;------------------------------------------------------------------------------
                            	    64: 
                            	    65: TCBHandleToPointer:
00:00000028 2F01            	    66: 	move.l d1,-(a7)
00:0000002A 028000000FFF    	    67: 	andi.l #MAX_TID,d0		; limit to # threads
00:00000030 4E7A1013        	    68: 	movec tcba,d1
00:00000034 E188            	    69: 	lsl.l #8,d0
00:00000036 D280            	    70: 	add.l d0,d1
00:00000038 2041            	    71: 	move.l d1,a0
00:0000003A E088            	    72: 	lsr.l #8,d0						; restore d0
00:0000003C 221F            	    73: 	move.l (a7)+,d1
00:0000003E 4E75            	    74: 	rts
                            	    75: 
                            	    76: ;------------------------------------------------------------------------------
                            	    77: ; Convert a TCB pointer into a handle.
                            	    78: ;
                            	    79: ; Parameters:
                            	    80: ;		a0 = TCB pointer
                            	    81: ; Returns:
                            	    82: ;		d0 = TCB handle
                            	    83: ;------------------------------------------------------------------------------
                            	    84: 
                            	    85: TCBPointerToHandle:
00:00000040 2F01            	    86: 	move.l d1,-(a7)				; save d1
00:00000042 4E7A1013        	    87: 	movec tcba,d1
00:00000046 91C1            	    88: 	sub.l d1,a0
00:00000048 2008            	    89: 	move.l a0,d0
00:0000004A E088            	    90: 	lsr.l #8,d0
00:0000004C 221F            	    91: 	move.l (a7)+,d1				; restore d1
00:0000004E 4E75            	    92: 	rts
                            	    93: 
                            	    94: ;------------------------------------------------------------------------------
                            	    95: ; Internal TCB allocation function.
                            	    96: ;
                            	    97: ; Parameters:
                            	    98: ;		none
                            	    99: ; Returns:
                            	   100: ;		d0 = handle for allocated TCB, NULL if none available
                            	   101: ;------------------------------------------------------------------------------
                            	   102: 
                            	   103: TCBIAlloc:
00:00000050 30390010030C    	   104: 	move.w FreeTCB,d0				; d1 = Free handle
00:00000056 6714            	   105: 	beq .0001
00:00000058 2F08            	   106: 	move.l a0,-(sp)
00:0000005A 61CC            	   107: 	bsr TCBHandleToPointer	; convert to pointer
00:0000005C 3228007C        	   108: 	move.w TCBNext(a0),d1		; d1 = next on free list
00:00000060 33C10010030C    	   109: 	move.w d1,FreeTCB				; update head of free list
00:00000066 61D8            	   110: 	bsr TCBPointerToHandle	; convert pointer to handle
00:00000068 205F            	   111: 	move.l (sp)+,a0
00:0000006A 4E75            	   112: 	rts
                            	   113: 	; Here there was no free TCB available. Return a NULL
                            	   114: .0001
00:0000006C 4E75            	   115: 	rts
                            	   116: 	
                            	   117: ;------------------------------------------------------------------------------
                            	   118: ; TCB allocation function. Locks the system semaphore during allocation.
                            	   119: ;
                            	   120: ; Parameters:
                            	   121: ;		none
                            	   122: ; Returns:
                            	   123: ;		d0 = handle for allocated TCB, NULL if none available
                            	   124: ;		d1 = E_Ok
                            	   125: ;------------------------------------------------------------------------------
                            	   126: 
                            	   127: TCBAlloc:
00:0000006E 61000326        	   128: 	bsr LockSysSemaphore
00:00000072 61DC            	   129: 	bsr	TCBIAlloc
00:00000074 61000330        	   130: 	bsr UnlockSysSemaphore
00:00000078 7200            	   131: 	moveq #E_Ok,d1
00:0000007A 4E75            	   132: 	rts
                            	   133: 	
                            	   134: ;------------------------------------------------------------------------------
                            	   135: ; Internal TCB free function.
                            	   136: ;
                            	   137: ; Modifies:
                            	   138: ;		none
                            	   139: ; Parameters:
                            	   140: ;		d0 = handle to TCB
                            	   141: ; Returns:
                            	   142: ;		d0 = handle to TCB
                            	   143: ;------------------------------------------------------------------------------
                            	   144: 
                            	   145: TCBIFree:
00:0000007C 2F08            	   146: 	move.l a0,-(sp)
00:0000007E 61A8            	   147: 	bsr TCBHandleToPointer
00:00000080 31790010030C007C	   148: 	move.w FreeTCB,TCBNext(a0)
00:00000088 33C00010030C    	   149: 	move.w d0,FreeTCB
00:0000008E 205F            	   150: 	move.l (sp)+,a0
00:00000090 4E75            	   151: 	rts
                            	   152: 
                            	   153: ;------------------------------------------------------------------------------
                            	   154: ; TCB free function. Locks the system sempaphore while freeing.
                            	   155: ;
                            	   156: ; Modifies:
                            	   157: ;		none
                            	   158: ; Parameters:
                            	   159: ;		d0 = handle to TCB
                            	   160: ; Returns:
                            	   161: ;		d0 = handle to TCB
                            	   162: ;		d1 = E_Ok
                            	   163: ;------------------------------------------------------------------------------
                            	   164: 
                            	   165: TCBFree:
00:00000092 61000302        	   166: 	bsr LockSysSemaphore
00:00000096 61E4            	   167: 	bsr TCBIFree
00:00000098 6100030C        	   168: 	bsr UnlockSysSemaphore
00:0000009C 7200            	   169: 	moveq #E_Ok,d1
00:0000009E 4E75            	   170: 	rts
                            	   171: 
                            	   172: ;------------------------------------------------------------------------------
                            	   173: ; Given an affinity, chose the core number to run on.
                            	   174: ;
                            	   175: ; Parameters:
                            	   176: ;		a0 = pointer to TCB
                            	   177: ;	Returns:
                            	   178: ;		d0 = core number to run on
                            	   179: ;------------------------------------------------------------------------------
                            	   180: 
                            	   181: TCBAffineChose:
00:000000A0 48E75000        	   182: 	movem.l d1/d3,-(sp)
00:000000A4 363C001F        	   183: 	move.w #31,d3										; limit number of bit selects to 32
00:000000A8 12280082        	   184: 	move.b TCBAffinityBase(a0),d1		; d1 = starting bit
00:000000AC 20280084        	   185: 	move.l TCBAffinity(a0),d0				; d0 = affinity mask
                            	   186: .0002
00:000000B0 0300            	   187: 	btst.l d1,d0										; is bit d1 set?
00:000000B2 6610            	   188: 	bne .0001												; if set, exit loop
00:000000B4 5241            	   189: 	addq #1,d1
00:000000B6 51CBFFF8        	   190: 	dbra d3,.0002
                            	   191: 	; no bits set? How?
00:000000BA 117C00020082    	   192: 	move.b #2,TCBAffinityBase(a0)
00:000000C0 7000            	   193: 	moveq #0,d0											; just return core #2 (0)
00:000000C2 4E75            	   194: 	rts
                            	   195: .0001
00:000000C4 1001            	   196: 	move.b d1,d0
00:000000C6 5500            	   197: 	subi.b #2,d0										; cores start at #2
00:000000C8 4880            	   198: 	ext.w d0
00:000000CA 48C0            	   199: 	ext.l d0
00:000000CC 5241            	   200: 	addq #1,d1											; increment bit selection for next time
00:000000CE 11410082        	   201: 	move.b d1,TCBAffinityBase(a0)		; and store in TCB
00:000000D2 4CDF000A        	   202: 	movem.l (sp)+,d1/d3
00:000000D6 4E75            	   203: 	rts
                            	   204: 
                            	   205: ;------------------------------------------------------------------------------
                            	   206: ; Insert thread into ready queue. The thread is added at the tail of the 
                            	   207: ; queue. The queue is a doubly linked list.
                            	   208: ;
                            	   209: ; Stack Space:
                            	   210: ;		8 lwords
                            	   211: ; Modifies:
                            	   212: ;		none
                            	   213: ; Parameters:
                            	   214: ;		d0 = thread id to insert
                            	   215: ; Returns:
                            	   216: ;		d0 = TCB handle
                            	   217: ; ----------------------------------------------------------------------------
                            	   218: 
                            	   219: TCBInsertIntoReadyQueue:
00:000000D8 48E770F0        	   220: 	movem.l d1-d3/a0-a3,-(sp)
00:000000DC 2400            	   221: 	move.l d0,d2											; d2 = thread to insert
00:000000DE 6100FF48        	   222: 	bsr TCBHandleToPointer
00:000000E2 2648            	   223: 	move.l a0,a3											; a3 = TCB pointer of thread to insert
00:000000E4 610002B0        	   224: 	bsr LockSysSemaphore
00:000000E8 002800800054    	   225: 	ori.b #TS_RUNNING,TCBStatus(a0)
00:000000EE 61B0            	   226: 	bsr TCBAffineChose								; Chose which cores queue to use
00:000000F0 EB88            	   227: 	lsl.l #5,d0												; 32 bytes per readyQ head/tail per core
00:000000F2 7200            	   228: 	clr.l d1
00:000000F4 12280055        	   229: 	move.b TCBPriority(a0),d1					; d1 = priority
00:000000F8 028100000007    	   230: 	andi.l #7,d1
00:000000FE E589            	   231: 	lsl.l #2,d1												; 4 bytes per priority level
00:00000100 D280            	   232: 	add.l d0,d1												; add in base queue
00:00000102 D2BC00100320    	   233: 	add.l #readyQ,d1									; add in start of ready queues
00:00000108 2241            	   234: 	move.l d1,a1
00:0000010A 30290004        	   235: 	move.w 4(a1),d0										; d0 = tail entry
00:0000010E 3600            	   236: 	move.w d0,d3											; d3 = tail entry
00:00000110 4A40            	   237: 	tst.w d0
00:00000112 6D20            	   238: 	blt .qempty
00:00000114 6100FF12        	   239: 	bsr TCBHandleToPointer						; a0 = pointer to tail
00:00000118 2448            	   240: 	move.l a0,a2
00:0000011A 2038007C        	   241: 	move.l TCBNext,d0
00:0000011E 6100FF08        	   242: 	bsr TCBHandleToPointer						; a0 = tail->next
00:00000122 21420080        	   243: 	move.l d2,TCBPrev(a0)							; tail->next->prev = new entry
00:00000126 2542007C        	   244: 	move.l d2,TCBNext(a2)							; tail->next = new entry
00:0000012A 2740007C        	   245: 	move.l d0,TCBNext(a3)							; new entry->next = tail->next
00:0000012E 27430080        	   246: 	move.l d3,TCBPrev(a3)							; new entry->prev = tail
00:00000132 6012            	   247: 	bra .0002
                            	   248: .qempty
00:00000134 4A51            	   249: 	tst.w (a1)												; check if there is a list head
00:00000136 6C0E            	   250: 	bge .0002													; head with no tail -> list corrupt
00:00000138 33420004        	   251: 	move.w d2,4(a1)										; head and tail equal new entry
00:0000013C 3282            	   252: 	move.w d2,(a1)
00:0000013E 3742007C        	   253: 	move.w d2,TCBNext(a3)							; next and prev of new entry point to self
00:00000142 37420080        	   254: 	move.w d2,TCBPrev(a3)
                            	   255: 	; Head but no tail, list corrupt?
                            	   256: .0002
00:00000146 6100025E        	   257: 	bsr UnlockSysSemaphore
00:0000014A 4CDF0F0E        	   258: 	movem.l (sp)+,d1-d3/a0-a3
00:0000014E 4E75            	   259: 	rts
                            	   260: 
                            	   261: ;------------------------------------------------------------------------------
                            	   262: ; Remove a thread from the ready queue. Actual removal is not done here, it
                            	   263: ; is done the next time the thread is selected to run. Just mark the thread as
                            	   264: ; not running.
                            	   265: ;
                            	   266: ; Parameters:
                            	   267: ;		d0 = thread id to remove
                            	   268: ; Returns:
                            	   269: ;		none
                            	   270: ; -----------------------------------------------------------------------------
                            	   271: 
                            	   272: TCBRemoveFromReadyQueue:
00:00000150 4A40            	   273: 	cmpi.w #0,d0
00:00000152 6D1C            	   274: 	blt .0001
00:00000154 028000000FFF    	   275: 	andi.l #MAX_TID,d0									; limit to # of threads
00:0000015A 2F08            	   276: 	move.l a0,-(sp)
00:0000015C 6100FECA        	   277: 	bsr	TCBHandleToPointer
00:00000160 61000234        	   278: 	bsr LockSysSemaphore
00:00000164 0228007F0054    	   279: 	andi.b #TS_RUNNING^$FF,TCBStatus(a0)
00:0000016A 6100023A        	   280: 	bsr UnlockSysSemaphore
00:0000016E 205F            	   281: 	move.l (sp)+,a0
                            	   282: .0001
00:00000170 4E75            	   283: 	rts
                            	   284: 	
                            	   285: ; ----------------------------------------------------------------------------
                            	   286: ; Register Usage
                            	   287: ;		d0 = temporary
                            	   288: ;		d1 = index into list of queues
                            	   289: ;		d2 = index to queue set
                            	   290: ;		d4 = queue counter, goes from 7 down to 0
                            	   291: ;		d5 = temporary
                            	   292: ;		d6 = next on list
                            	   293: ;		a0 = temporary pointer to TCB
                            	   294: ;		a1 = pointer to queue
                            	   295: ;		a2 = pointer to old head of list
                            	   296: ;		a3 = pointer to TCB at head of queue
                            	   297: ; Modifies:
                            	   298: ;		none
                            	   299: ; Parameters:
                            	   300: ;		none
                            	   301: ; Returns:
                            	   302: ;		a0 = pointer to TCB, NULL if none on list
                            	   303: ;		d0 = TCB handle
                            	   304: ; ----------------------------------------------------------------------------
                            	   305: 
                            	   306: StartQ
00:00000172 01              	   307: 	dc.b 1,2,3,4,1,5,6,7
00:00000173 02
00:00000174 03
00:00000175 04
00:00000176 01
00:00000177 05
00:00000178 06
00:00000179 07
                            	   308: 
                            	   309: 	even
                            	   310: TCBPopReadyQueue:
00:0000017A 48E77E70        	   311: 	movem.l	d1-d6/a1-a3,-(a7)
00:0000017E 4E7A2FE0        	   312: 	movec coreno,d2					; select the queue set based on the core number
00:00000182 5502            	   313: 	subi.b #2,d2						; cores start at #2
00:00000184 EB8A            	   314: 	lsl.l #5,d2							; d2 = index to queue set, 32 bytes per queue set
00:00000186 7807            	   315: 	moveq #7,d4							; d4 = queue count
00:00000188 6100020C        	   316: 	bsr LockSysSemaphore
                            	   317: 	; One in four tries pick a different priority to start searching from. 
00:0000018C 12390010031C    	   318: 	move.b QueueCycle,d1		; increment Queue cycle counter
00:00000192 5201            	   319: 	addi.b #1,d1
00:00000194 02010007        	   320: 	andi.b #7,d1
00:00000198 13C10010031C    	   321: 	move.b d1,QueueCycle
00:0000019E 6612            	   322: 	bne	.0001
00:000001A0 43FAFFD0        	   323: 	lea StartQ,a1
00:000001A4 4881            	   324: 	ext.w d1
00:000001A6 12311000        	   325: 	move.b (a1,d1.w),d1
00:000001AA 02410007        	   326: 	andi.w #7,d1						; limit to number of queues
00:000001AE E549            	   327: 	lsl.w #2,d1							; make into lword index
00:000001B0 6002            	   328: 	bra .0002
                            	   329: .0001
00:000001B2 7200            	   330: 	moveq #0,d1							; start at Queue #0
                            	   331: .0002
00:000001B4 43F900100320    	   332: 	lea readyQ,a1						; a1 = pointer to list of ready queues
00:000001BA D3C2            	   333: 	add.l d2,a1							; a1 = pointer to queue set
00:000001BC 36311000        	   334: 	move.w (a1,d1.w),d3			; d3 = old head of list
00:000001C0 6D4E            	   335: 	blt .nextQ							; anything on list?, if not go next queue
00:000001C2 3003            	   336: 	move.w d3,d0						; d0 = old head of list
00:000001C4 6100FE62        	   337: 	bsr TCBHandleToPointer
00:000001C8 2448            	   338: 	move.l a0,a2						; a2 = pointer to old head of list
00:000001CA 3A2A007C        	   339: 	move.w TCBNext(a2),d5		; remove head of list from list
00:000001CE BA80            	   340: 	cmp.l d0,d5							; removing last TCB?
00:000001D0 6736            	   341: 	beq .removeLast
00:000001D2 3C05            	   342: 	move.w d5,d6						; d6 = next on list
00:000001D4 3005            	   343: 	move.w d5,d0						; d0 = next on list
00:000001D6 6100FE50        	   344: 	bsr TCBHandleToPointer	; a0 = pointer to next TCB on list
00:000001DA 3A2A0080        	   345: 	move.w TCBPrev(a2),d5		; d5 = previous TCB from head
00:000001DE 31450080        	   346: 	move.w d5,TCBPrev(a0)		; next->prev = head->prev
00:000001E2 3005            	   347: 	move.w d5,d0
00:000001E4 6100FE42        	   348: 	bsr TCBHandleToPointer	; a0 = pointer to previous TCB from head
00:000001E8 3146007C        	   349: 	move.w d6,TCBNext(a0)		; head->prev->next = next
                            	   350: .0003
00:000001EC 33861000        	   351: 	move.w d6,(a1,d1.w)			; reset head of list to next
00:000001F0 3543007C        	   352: 	move.w d3,TCBNext(a2)		; point links back to self
00:000001F4 35430080        	   353: 	move.w d3,TCBPrev(a2)
00:000001F8 3003            	   354: 	move.w d3,d0						; return handle in d0
00:000001FA 48C0            	   355: 	ext.l d0
00:000001FC 204A            	   356: 	move.l a2,a0						; return pointer in a0
                            	   357: .0004
00:000001FE 610001A6        	   358: 	bsr UnlockSysSemaphore
00:00000202 4CDF0E7E        	   359: 	movem.l	(a7)+,d1-d6/a1-a3
00:00000206 4E75            	   360: 	rts
                            	   361: .removeLast
00:00000208 7CFF            	   362: 	moveq #-1,d6						; set head to negative when removing last
00:0000020A 33861002        	   363: 	move.w d6,2(a1,d1.w)		; tail = negative
00:0000020E 60DC            	   364: 	bra .0003
                            	   365: .nextQ
00:00000210 5841            	   366: 	addi.w #4,d1						; increment queue number by lword
00:00000212 0241001C        	   367: 	andi.w #$1C,d1					; limit to number of queues
00:00000216 51CCFF9C        	   368: 	dbra d4,.0002						; go back and check the next queue
00:0000021A 70FF            	   369: 	moveq #-1,d0						; return handle < 0 if nothing in any queue
00:0000021C 91C8            	   370: 	suba.l a0,a0						; and NULL pointer
00:0000021E 60DE            	   371: 	bra	.0004								; return NULL pointer if nothing in any queue
                            	   372: 
                            	   373: ;------------------------------------------------------------------------------
                            	   374: ; Remove a thread from the timeout list.
                            	   375: ; Called when a mailbox is freed and a thread is waiting at the
                            	   376: ; mailbox.
                            	   377: ;
                            	   378: ; Parameters:
                            	   379: ;		B = task id to remove
                            	   380: ; Modifies:
                            	   381: ;		none
                            	   382: ; Returns:
                            	   383: ;		none
                            	   384: ;------------------------------------------------------------------------------
                            	   385: 	if 0
                            	   386: RemoveFromTimeoutList:
                            	   387: 	pshs	d,w,x,y,u
                            	   388: 	cmpb	TimeoutList			; head of list?
                            	   389: 	beq		0001f
                            	   390: 	lbsr	TCBHandleToPointer
                            	   391: 	tfr		d,x
                            	   392: 	ldb		TCBNext,x
                            	   393: 	clra
                            	   394: 	tfr		d,u
                            	   395: 	ldf		TCBPrev,x
                            	   396: 	lbsr	TCBHandleToPointer
                            	   397: 	tfr		d,y
                            	   398: 	stf		TCBPrev,y
                            	   399: 	tfr		f,b
                            	   400: 	clra
                            	   401: 	lbsr	TCBHandleToPointer
                            	   402: 	tfr		d,y
                            	   403: 	tfr		u,d
                            	   404: 	stb		TCBNext,y
                            	   405: 	bra		0002f
                            	   406: 	; Removing from head of timeout list
                            	   407: 0001:
                            	   408: 	lbsr	TCBHandleToPointer
                            	   409: 	tfr		d,x
                            	   410: 	ldb		TCBNext,x
                            	   411: 	stb		TimeoutList		; set new head of list
                            	   412: 	clra
                            	   413: 	lbsr	TCBHandleToPointer
                            	   414: 	tfr		d,y
                            	   415: 	clrb
                            	   416: 	stb		TCBPrev,y			; next->prev = NULL
                            	   417: 0002:
                            	   418: 	clrd
                            	   419: 	std		TCBNext,x			; next = NULL
                            	   420: 	std		TCBPrev,x			; prev = NULL
                            	   421: 	puls	d,w,x,y,u,pc
                            	   422: 	
                            	   423: ;// ----------------------------------------------------------------------------
                            	   424: ;// Pop the top entry from the timeout list.
                            	   425: ;// ----------------------------------------------------------------------------
                            	   426: ;
                            	   427: ;hTCB PopTimeoutList()
                            	   428: ;{
                            	   429: ;    TCB *p;
                            	   430: ;    hTCB h;
                            	   431: ;
                            	   432: ;    h = TimeoutList;
                            	   433: ;    if (TimeoutList > 0 && TimeoutList < NR_TCB) {
                            	   434: ;        TimeoutList = tcbs[TimeoutList].next;
                            	   435: ;        if (TimeoutList >= 0 && TimeoutList < NR_TCB) {
                            	   436: ;            tcbs[TimeoutList].prev = h->prev;
                            	   437: ;            h->prev->next = TimeoutList;
                            	   438: ;        }
                            	   439: ;    }
                            	   440: ;    return h;
                            	   441: ;}
                            	   442: ;
                            	   443: ; Returns:
                            	   444: ;		B = task at top of list
                            	   445: ;
                            	   446: 
                            	   447: PopTimeoutList:
                            	   448: 	pshs	w,x,y
                            	   449: 	ldb		TimeoutList
                            	   450: 	pshs	b
                            	   451: 	beq		0001f
                            	   452: 	cmpb	#NR_TCB
                            	   453: 	bhs		0001f
                            	   454: 	bsr		TCBHandleToPointer
                            	   455: 	tfr		d,x
                            	   456: 	ldb		TCBNext,x
                            	   457: 	tfr		b,f
                            	   458: 	lde		TCBPrev,x
                            	   459: 	stb		TimeoutList
                            	   460: 	beq		0001f
                            	   461: 	cmpb	#NR_TCB
                            	   462: 	bhs		0001f
                            	   463: 	bsr		TCBHandleToPointer
                            	   464: 	tfr		d,y
                            	   465: 	ste		TCBPrev,y
                            	   466: 	tfr		e,b
                            	   467: 	bsr		TCBHandleToPointer
                            	   468: 	tfr		d,y
                            	   469: 	stf		TCBNext,y
                            	   470: 	clr		TCBPrev,x
                            	   471: 	clr		TCBNext,x
                            	   472: 0001:
                            	   473: 	puls	b
                            	   474: 	puls	x,y,w,pc
                            	   475: 
                            	   476: ; ----------------------------------------------------------------------------
                            	   477: ; ----------------------------------------------------------------------------
                            	   478: DispTwoSpace:
                            	   479: 	bsr	DispSpace
                            	   480: DispSpace:
                            	   481: 	ldb		#' '
                            	   482: 	swi
                            	   483: 	fcb		MF_OUTCH
                            	   484: 	rts
                            	   485: 
                            	   486: DumpTCBs:
                            	   487: 	swi
                            	   488: 	fcb		MF_CRLF
                            	   489: 	ldb		#1
                            	   490: 0002:
                            	   491: 	lbsr	TCBHandleToPointer
                            	   492: 	tfr		d,x
                            	   493: 	ldb		TCBtid,x
                            	   494: 	swi
                            	   495: 	fcb		MF_DisplayByteAsHex
                            	   496: 	bsr		DispSpace
                            	   497: 	ldb		TCBStatus,x
                            	   498: 	swi
                            	   499: 	fcb		MF_DisplayByteAsHex
                            	   500: 	bsr		DispTwoSpace
                            	   501: 	swi
                            	   502: 	fcb		MF_CRLF
                            	   503: 	ldb		TCBNext,x
                            	   504: 	beq		0001f
                            	   505: 	bra		0002b
                            	   506: 0001:
                            	   507: 	rts
                            	   508: 	
                            	   509: fcb	"TID Stat"
                            	   510: 	endif
                            	   511: 
                            	   512: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     9: 	include "..\Femtiki\source\kernel\Femtiki.x68"

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     1: 	code
                            	     2: 	even
                            	     3: ;------------------------------------------------------------------------------
                            	     4: ; Initialize the Femtiki OS.
                            	     5: ;------------------------------------------------------------------------------
                            	     6: 
                            	     7: FemtikiInit:
00:00000220 7000            	     8: 	moveq #0,d0
00:00000222 4E7B0012        	     9: 	movec d0,tr
00:00000226 6100FDD8        	    10: 	bsr TCBInit
00:0000022A 42390010031C    	    11: 	clr.b QueueCycle
                            	    12: FemtikiInitIRQ:
00:00000230 43FA00DC        	    13: 	lea FemtikiTimerIRQ,a1						; Set timer IRQ vector to Femtiki
00:00000234 4E7A8801        	    14: 	movec vbr,a0
00:00000238 21490078        	    15: 	move.l a1,30*4(a0)								; vector #30
00:0000023C 4E75            	    16: 	rts
                            	    17: 
                            	    18: ;------------------------------------------------------------------------------
                            	    19: ; Operating system call dispatcher.
                            	    20: ; On entry, the task state has been saved including the system stack pointer,
                            	    21: ; in the task control block.
                            	    22: ;------------------------------------------------------------------------------
                            	    23: 
                            	    24: OSCallTable
00:0000023E 0000            	    25: 	dc.w		0
                            	    26: 
                            	    27: 	even
                            	    28: CallOS:
00:00000240 2F08            	    29: 	move.l	a0,-(a7)
00:00000242 207900100224    	    30: 	move.l	RunningTCB,a0
00:00000248 48E8FFFF0004    	    31: 	movem.l d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,TCBRegs(a0)
00:0000024E 225F            	    32: 	move.l	(a7)+,a1
00:00000250 21490020        	    33: 	move.l	a1,32(a0)
00:00000254 4E7A9800        	    34: 	movec		usp,a1
00:00000258 21490044        	    35: 	move.l	a1,TCBUSP(a0)
00:0000025C 301F            	    36: 	move.w	(a7)+,d0					; pop the status register
00:0000025E 3140004C        	    37: 	move.w	d0,TCBSR(a0)			; save in TCB
00:00000262 225F            	    38: 	move.l	(a7)+,a1					; pop the program counter
00:00000264 5489            	    39: 	lea	2(a1),a1							; increment past inline callno argument
00:00000266 21490050        	    40: 	move.l	a1,TCBPC(a0)			; save PC in TCB
00:0000026A 214F0048        	    41: 	move.l	a7,TCBSSP(a0)			; finally save SSP
00:0000026E 3029FFFE        	    42: 	move.w	-2(a1),d0					; d0 = call number
00:00000272 E548            	    43: 	lsl.w		#2,d0							; make into table index
00:00000274 43FAFFC8        	    44: 	lea			OSCallTable,a1
00:00000278 22710000        	    45: 	move.l	(a1,d0.w),a1
00:0000027C 4E91            	    46: 	jsr			(a1)							; call the OS function
                            	    47: 	; Restore the thread context and return
00:0000027E 207900100224    	    48: 	move.l	RunningTCB,a0
00:00000284 2E780048        	    49: 	move.l	TCBSSP,a7
00:00000288 2F280050        	    50: 	move.l	TCBPC(a0),-(a7)		; setup the PC and the SR on the stack
00:0000028C 3F28004C        	    51: 	move.w	TCBSR(a0),-(a7)		; prep for RTE
00:00000290 20380044        	    52: 	move.l	TCBUSP,d0					; restore user stack pointer
00:00000294 4E7B0800        	    53: 	movec		d0,usp
00:00000298 4CE800FF0004    	    54: 	movem.l	TCBRegs(a0),d0/d1/d2/d3/d4/d5/d6/d7
00:0000029E 4CE87E00002C    	    55: 	movem.l TCBRegs+40(a0),a1/a2/a3/a4/a5/a6
00:000002A4 20680024        	    56: 	move.l	TCBRegs+32(a0),a0
00:000002A8 4E73            	    57: 	rte
                            	    58: 
                            	    59: ;------------------------------------------------------------------------------
                            	    60: ; Get a pointer to the currently running TCB.
                            	    61: ;
                            	    62: ; Returns:
                            	    63: ;		a0 = pointer to running TCB
                            	    64: ;------------------------------------------------------------------------------
                            	    65: 
                            	    66: GetRunningTCBPointer:
00:000002AA 48E7C000        	    67: 	movem.l d0/d1,-(a7)
00:000002AE 4E7A0012        	    68: 	movec tr,d0
00:000002B2 6100FD74        	    69: 	bsr TCBHandleToPointer
00:000002B6 028000000FFF    	    70: 	andi.l #MAX_TID,d0		; limit to # threads
00:000002BC 4CDF0003        	    71: 	movem.l (a7)+,d0/d1
00:000002C0 4E75            	    72: 	rts
                            	    73: 
                            	    74: ; ----------------------------------------------------------------------------
                            	    75: ; Select a thread to run. Relatively easy. All that needs to be done is to
                            	    76: ; keep popping the queue until a valid running task is found. There should
                            	    77: ; always be at least one thread in the queue.
                            	    78: ;
                            	    79: ; Modifies:
                            	    80: ;		none
                            	    81: ; Returns:
                            	    82: ;		d0 = handle of the next thread to run
                            	    83: ; ----------------------------------------------------------------------------
                            	    84: 
                            	    85: SelectThreadToRun:
                            	    86: .0001										; keep popping tasks from the readyQ until a valid one
00:000002C2 6100FEB6        	    87: 	bsr	TCBPopReadyQueue	; is found.
00:000002C6 4A40            	    88: 	tst.w d0
00:000002C8 6B0C            	    89: 	bmi	.0002
00:000002CA 0C2800800054    	    90: 	cmpi.b #TS_RUNNING,TCBStatus(a0)	; ensure the thread is to be running
00:000002D0 66F0            	    91: 	bne	.0001													; if not, go get the next thread
00:000002D2 6000FE04        	    92: 	bra	TCBInsertIntoReadyQueue				; insert thread back into queue
                            	    93: 	; Nothing in queues? There is supposed to be. Add the OS task to the queue.
                            	    94: .0002
00:000002D6 4E7A8013        	    95: 	movec tcba,a0
00:000002DA 117C00800054    	    96: 	move.b #TS_RUNNING,TCBStatus(a0)	; flag as RUNNING
00:000002E0 117C00040055    	    97: 	move.b #4,TCBPriority(a0)					; OS has normal priority
00:000002E6 7000            	    98: 	moveq #0,d0												; fast pointer to handle
00:000002E8 6000FDEE        	    99: 	bra TCBInsertIntoReadyQueue
                            	   100: 
                            	   101: ; ----------------------------------------------------------------------------
                            	   102: ; Update the IRQ live indicator on screen.
                            	   103: ; ----------------------------------------------------------------------------
                            	   104: 
                            	   105: UpdateIRQLive:
00:000002EC 227900040004    	   106: 	move.l TextScr,a1					; a1 = screen address
00:000002F2 2411            	   107: 	move.l (a1),d2
00:000002F4 E15A            	   108: 	rol.w	#8,d2								; reverse byte order of d2
00:000002F6 4842            	   109: 	swap d2
00:000002F8 E15A            	   110: 	rol.w	#8,d2
00:000002FA 06010030        	   111: 	addi.b #'0',d1						; binary to ascii core number
00:000002FE D202            	   112: 	add.b	d2,d1
00:00000300 E159            	   113: 	rol.w	#8,d1								; put bytes back in order
00:00000302 4841            	   114: 	swap d1
00:00000304 E159            	   115: 	rol.w	#8,d1
00:00000306 23410004        	   116: 	move.l d1,4(a1)						; update onscreen IRQ flag
00:0000030A 5291            	   117: 	addi.l #1,(a1)						; flashy colors
00:0000030C 4E75            	   118: 	rts
                            	   119: 
                            	   120: ; ----------------------------------------------------------------------------
                            	   121: ; Femtiki IRQ service routine. This is where a thread switch can occur so,
                            	   122: ; the thread context is saved and restored.
                            	   123: ; ----------------------------------------------------------------------------
                            	   124: 
                            	   125: FemtikiTimerIRQ:
00:0000030E 46FC2600        	   126: 	move.w #$2600,sr							; disable lower level IRQs
00:00000312 2F00            	   127: 	move.l d0,-(a7)
00:00000314 2F08            	   128: 	move.l a0,-(a7)
00:00000316 6192            	   129: 	bsr GetRunningTCBPointer			; a0 = pointer to running TCB
00:00000318 48E8FFFF0004    	   130: 	movem.l #$FFFF,TCBRegs(a0)		; save all registers
00:0000031E 201F            	   131: 	move.l (a7)+,d0
00:00000320 21400020        	   132: 	move.l d0,32(a0)							; save original a0 value
00:00000324 201F            	   133: 	move.l (a7)+,d0
00:00000326 2080            	   134: 	move.l d0,(a0)								; save original d0 value
00:00000328 4E7A0800        	   135: 	movec usp,d0									; save user stack pointer
00:0000032C 21400044        	   136: 	move.l d0,TCBUSP(a0)
00:00000330 2E7C00040BFC    	   137: 	move.l #TimerStack,a7					; reset stack pointer
00:00000336 4E7A1FE0        	   138: 	movec	coreno,d1								; d1 = core number
00:0000033A 0C010002        	   139: 	cmpi.b #2,d1
00:0000033E 6612            	   140: 	bne.s	.0002
00:00000340 23FC1D000000FD09	   141: 	move.l #$1D000000,PLIC+$14		; reset edge sense circuit
00:00000348 0014
00:0000034A 13FC0001000400A0	   142: 	move.b #1,IRQFlag							; set IRQ flag for TinyBasic shell
                            	   143: .0002
00:00000352 6198            	   144: 	bsr UpdateIRQLive							; Update IRQ live indicator
                            	   145: ;	bsr ReceiveMsg								; Check for RPC
00:00000354 4E7A0FF0        	   146: 	movec tick,d0									; Update time accounting
00:00000358 21400070        	   147: 	move.l d0,TCBEndTick(a0)			; compute number of ticks thread was running
00:0000035C 90A8006C        	   148: 	sub.l	TCBStartTick(a0),d0
00:00000360 D1A80074        	   149: 	add.l	d0,TCBTicks(a0)					; add to cumulative ticks
00:00000364 117C00200054    	   150: 	move.b #TS_PREEMPT,TCBStatus(a0)	; set thread status to PREEMPT
00:0000036A 6100FF56        	   151: 	bsr	SelectThreadToRun					; d0 = TCB handle
00:0000036E 4E7B0012        	   152: 	movec d0,tr										; set running thread number in tr
00:00000372 6100FF36        	   153: 	bsr GetRunningTCBPointer			; a0 = pointer to TCB
00:00000376 117C00800054    	   154: 	move.b #TS_RUNNING,TCBStatus(a0)	; set thread status to RUNNING
00:0000037C 4E7A0FF0        	   155: 	movec	tick,d0
00:00000380 2140006C        	   156: 	move.l d0,TCBStartTick(a0)		; record starting tick
00:00000384 20280044        	   157: 	move.l TCBUSP(a0),d0					; restore user stack pointer
00:00000388 4E7B0800        	   158: 	movec d0,usp
00:0000038C 4CE8FFFF0004    	   159: 	movem.l TCBRegs(a0),#$FFFF		; restore all registers
00:00000392 504F            	   160: 	addq #8,sp										; "pop" d0/a0, saved stack pointer is off by 8
00:00000394 4E73            	   161: 	rte														; and return
                            	   162: 
                            	   163: 	include "..\Femtiki\source\kernel\Semaphore.x68"

Source: "..\Femtiki\source\kernel\Semaphore.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;-------------------------------------------------------------------------------
                            	    38: ; Lock the system semaphore. Call the BIOS.
                            	    39: ;
                            	    40: ; Parameters:
                            	    41: ;		none
                            	    42: ; Returns:
                            	    43: ;		none
                            	    44: ;-------------------------------------------------------------------------------
                            	    45: 
                            	    46: LockSysSemaphore:
00:00000396 48E7C000        	    47: 	movem.l d0/d1,-(sp)
00:0000039A 7025            	    48: 	moveq #37,d0				; lock semaphore
00:0000039C 7208            	    49: 	moveq #FMTK_SEMA,d1
00:0000039E 4E4F            	    50: 	trap #15
00:000003A0 4CDF0003        	    51: 	movem.l (sp)+,d0/d1
00:000003A4 4E75            	    52: 	rts
                            	    53: 
                            	    54: 
                            	    55: ;-------------------------------------------------------------------------------
                            	    56: ; Unlock the system semaphore.
                            	    57: ;
                            	    58: ; Parameters:
                            	    59: ;		none
                            	    60: ; Returns:
                            	    61: ;		none
                            	    62: ;-------------------------------------------------------------------------------
                            	    63: 
                            	    64: UnlockSysSemaphore:
00:000003A6 48E7C000        	    65: 	movem.l d0/d1,-(sp)
00:000003AA 7026            	    66: 	moveq #38,d0				; unlock semaphore
00:000003AC 7208            	    67: 	moveq #FMTK_SEMA,d1
00:000003AE 4E4F            	    68: 	trap #15
00:000003B0 4CDF0003        	    69: 	movem.l (sp)+,d0/d1
00:000003B4 4E75            	    70: 	rts
                            	    71: 
                            	    72: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	   164: 
                            	   165: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	    10: 

Source: "boot.x68"
                            	   121: 
                            	   122: DDATA EQU $FFFFFFF0     ; DS.L    3
                            	   123: HISPC EQU $FFFFFFFC     ; DS.L    1
                            	   124: SCREEN_FORMAT = 1
                            	   125: 
                            	   126: 	if HAS_MMU
                            	   127: TEXTREG		EQU	$1E3FF00	; virtual addresses
                            	   128: txtscreen	EQU	$1E00000
                            	   129: semamem		EQU	$1E50000
                            	   130: ACIA			EQU	$1E60000
                            	   131: ACIA_RX		EQU	0
                            	   132: ACIA_TX		EQU	0
                            	   133: ACIA_STAT	EQU	4
                            	   134: ACIA_CMD	EQU	8
                            	   135: ACIA_CTRL	EQU	12
                            	   136: I2C2 			equ $01E69000
                            	   137: I2C_PREL 	equ 0
                            	   138: I2C_PREH 	equ 1
                            	   139: I2C_CTRL 	equ 2
                            	   140: I2C_RXR 	equ 3
                            	   141: I2C_TXR 	equ 3
                            	   142: I2C_CMD 	equ 4
                            	   143: I2C_STAT 	equ 4
                            	   144: PLIC			EQU	$1E90000
                            	   145: MMU				EQU $FDC00000	; physical address
                            	   146: leds			EQU	$1EFFF00	; virtual addresses
                            	   147: keybd			EQU	$1EFFE00
                            	   148: KEYBD			EQU	$1EFFE00
                            	   149: RAND			EQU	$1EFFD00
                            	   150: RAND_NUM	EQU	$1EFFD00
                            	   151: RAND_STRM	EQU	$1EFFD04
                            	   152: RAND_MZ		EQU $1EFFD08
                            	   153: RAND_MW		EQU	$1EFFD0C
                            	   154: RST_REG		EQU	$1EFFC00
                            	   155: IO_BITMAP	EQU $1F00000
                            	   156: 	else
                            	   157: TEXTREG		EQU	$FD080000
                            	   158: txtscreen	EQU	$FD000000
                            	   159: semamem		EQU	$FD050000
                            	   160: ACIA			EQU	$FD060000
                            	   161: ACIA_RX		EQU	0
                            	   162: ACIA_TX		EQU	0
                            	   163: ACIA_STAT	EQU	4
                            	   164: ACIA_CMD	EQU	8
                            	   165: ACIA_CTRL	EQU	12
                            	   166: I2C2 			equ $FD069000
                            	   167: I2C_PREL 	equ 0
                            	   168: I2C_PREH 	equ 1
                            	   169: I2C_CTRL 	equ 2
                            	   170: I2C_RXR 	equ 3
                            	   171: I2C_TXR 	equ 3
                            	   172: I2C_CMD 	equ 4
                            	   173: I2C_STAT 	equ 4
                            	   174: PLIC			EQU	$FD090000
                            	   175: MMU				EQU $FDC00000	; physical address
                            	   176: leds			EQU	$FD0FFF00	; virtual addresses
                            	   177: keybd			EQU	$FD0FFE00
                            	   178: KEYBD			EQU	$FD0FFE00
                            	   179: RAND			EQU	$FD0FFD00
                            	   180: RAND_NUM	EQU	$FD0FFD00
                            	   181: RAND_STRM	EQU	$FD0FFD04
                            	   182: RAND_MZ		EQU $FD0FFD08
                            	   183: RAND_MW		EQU	$FD0FFD0C
                            	   184: RST_REG		EQU	$FD0FFC00
                            	   185: IO_BITMAP	EQU $FD100000
                            	   186: FRAMEBUF	EQU	$FD200000
                            	   187: 	endif
                            	   188: 
                            	   189: SERIAL_SEMA	EQU	2
                            	   190: KEYBD_SEMA	EQU	3
                            	   191: RAND_SEMA		EQU	4
                            	   192: SCREEN_SEMA	EQU	5
                            	   193: MEMORY_SEMA EQU 6
                            	   194: TCB_SEMA 		EQU	7
                            	   195: FMTK_SEMA		EQU	8
                            	   196: 
                            	   197: macIRQ_proc	macro arg1
                            	   198: 	dc.l IRQ_proc\1
                            	   199: endm
                            	   200: 
                            	   201: macIRQ_proc_label	macro arg1
                            	   202: IRQ_proc\1:
                            	   203: endm
                            	   204: 
                            	   205: 	data
                            	   206: 	; 0
01:00000000 00040FFC        	   207: 	dc.l		$00040FFC
01:00000004 000003B8        	   208: 	dc.l		start
01:00000008 00008008        	   209: 	dc.l		bus_err
01:0000000C 000083FA        	   210: 	dc.l		addr_err
01:00000010 00008448        	   211: 	dc.l		illegal_trap		* ILLEGAL instruction
01:00000014 00000000        	   212: 	dc.l		0
01:00000018 000007CE        	   213: 	dc.l		chk_exception		; CHK
01:0000001C 00000912        	   214: 	dc.l		EXCEPTION_7			* TRAPV
01:00000020 00000000        	   215: 	dc.l		0
01:00000024 00000000        	   216: 	dc.l		0
                            	   217: 	
                            	   218: 	; 10
01:00000028 00000000        	   219: 	dc.l		0
01:0000002C 00000000        	   220: 	dc.l		0
01:00000030 00000000        	   221: 	dc.l		0
01:00000034 00000000        	   222: 	dc.l		0
01:00000038 00000000        	   223: 	dc.l		0
01:0000003C 00000000        	   224: 	dc.l		0
01:00000040 00000000        	   225: 	dc.l		0
01:00000044 00000000        	   226: 	dc.l		0
01:00000048 00000000        	   227: 	dc.l		0
01:0000004C 00000000        	   228: 	dc.l		0
                            	   229: 	
                            	   230: 	; 20
01:00000050 00000000        	   231: 	dc.l		0
01:00000054 00000000        	   232: 	dc.l		0
01:00000058 00000000        	   233: 	dc.l		0
01:0000005C 00000000        	   234: 	dc.l		0
01:00000060 000083E6        	   235: 	dc.l		SpuriousIRQ
01:00000064 00000000        	   236: 	dc.l		0
01:00000068 00000000        	   237: 	dc.l		0
01:0000006C 000083B4        	   238: 	dc.l		irq3_rout
01:00000070 00000000        	   239: 	dc.l		0
01:00000074 00000000        	   240: 	dc.l		0
                            	   241: 	
                            	   242: 	; 30
01:00000078 00008378        	   243: 	dc.l		TickIRQ						; IRQ 30 - timer / keyboard
01:0000007C 000083E8        	   244: 	dc.l		nmi_rout
01:00000080 000082C2        	   245: 	dc.l		io_trap						; TRAP zero
01:00000084 00000000        	   246: 	dc.l		0
01:00000088 00000000        	   247: 	dc.l		0
01:0000008C 00008022        	   248: 	dc.l		trap3							; breakpoint
01:00000090 00000000        	   249: 	dc.l		0
01:00000094 00000000        	   250: 	dc.l		0
01:00000098 00000000        	   251: 	dc.l		0
01:0000009C 00000000        	   252: 	dc.l		0
                            	   253: 
                            	   254: 	; 40
01:000000A0 00000000        	   255: 	dc.l		0
01:000000A4 00000000        	   256: 	dc.l		0
01:000000A8 00000000        	   257: 	dc.l		0
01:000000AC 00000000        	   258: 	dc.l		0
01:000000B0 00000000        	   259: 	dc.l		0
01:000000B4 00000000        	   260: 	dc.l		0
01:000000B8 00000000        	   261: 	dc.l		0
01:000000BC 00005D40        	   262: 	dc.l		TRAP15
01:000000C0 00000000        	   263: 	dc.l		0
01:000000C4 00000000        	   264: 	dc.l		0
                            	   265: 
                            	   266: 	; 50	
01:000000C8 00000000        	   267: 	dc.l		0
01:000000CC 00000000        	   268: 	dc.l		0
01:000000D0 00000000        	   269: 	dc.l		0
01:000000D4 00000000        	   270: 	dc.l		0
01:000000D8 00000000        	   271: 	dc.l		0
01:000000DC 00000000        	   272: 	dc.l		0
01:000000E0 00000000        	   273: 	dc.l		0
01:000000E4 00000000        	   274: 	dc.l		0
01:000000E8 00000000        	   275: 	dc.l		0
01:000000EC 0000845E        	   276: 	dc.l		io_irq
                            	   277: 
                            	   278: 	; 60
01:000000F0 000064B4        	   279: 	dc.l		KeybdIRQ
01:000000F4 00007DAC        	   280: 	dc.l		SerialIRQ
01:000000F8 00000000        	   281: 	dc.l		0
01:000000FC 00008410        	   282: 	dc.l		brdisp_trap
                            	   283: 	
                            	   284: 	; 64
                            	   285: 
                            	   286: IRQ_trampolines:
                            	   287: ;	rept 192
                            	   288: ;	macIRQ_proc REPTN
                            	   289: ;	endr
                            	   290: 
                            	   291: 	org			$400
                            	   292: 
                            	   293: irq_list_tbl:
                            	   294: 	rept 192
                            	   295: 	dc.l 0
                            	   296: 	dc.l 0
                            	   297: 	endr
01:00000400 00000000        	     1R 	dc.l 0
01:00000404 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000408 00000000        	     1R 	dc.l 0
01:0000040C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000410 00000000        	     1R 	dc.l 0
01:00000414 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000418 00000000        	     1R 	dc.l 0
01:0000041C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000420 00000000        	     1R 	dc.l 0
01:00000424 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000428 00000000        	     1R 	dc.l 0
01:0000042C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000430 00000000        	     1R 	dc.l 0
01:00000434 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000438 00000000        	     1R 	dc.l 0
01:0000043C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000440 00000000        	     1R 	dc.l 0
01:00000444 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000448 00000000        	     1R 	dc.l 0
01:0000044C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000450 00000000        	     1R 	dc.l 0
01:00000454 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000458 00000000        	     1R 	dc.l 0
01:0000045C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000460 00000000        	     1R 	dc.l 0
01:00000464 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000468 00000000        	     1R 	dc.l 0
01:0000046C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000470 00000000        	     1R 	dc.l 0
01:00000474 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000478 00000000        	     1R 	dc.l 0
01:0000047C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000480 00000000        	     1R 	dc.l 0
01:00000484 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000488 00000000        	     1R 	dc.l 0
01:0000048C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000490 00000000        	     1R 	dc.l 0
01:00000494 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000498 00000000        	     1R 	dc.l 0
01:0000049C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004A0 00000000        	     1R 	dc.l 0
01:000004A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004A8 00000000        	     1R 	dc.l 0
01:000004AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004B0 00000000        	     1R 	dc.l 0
01:000004B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004B8 00000000        	     1R 	dc.l 0
01:000004BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004C0 00000000        	     1R 	dc.l 0
01:000004C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004C8 00000000        	     1R 	dc.l 0
01:000004CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004D0 00000000        	     1R 	dc.l 0
01:000004D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004D8 00000000        	     1R 	dc.l 0
01:000004DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004E0 00000000        	     1R 	dc.l 0
01:000004E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004E8 00000000        	     1R 	dc.l 0
01:000004EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004F0 00000000        	     1R 	dc.l 0
01:000004F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004F8 00000000        	     1R 	dc.l 0
01:000004FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000500 00000000        	     1R 	dc.l 0
01:00000504 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000508 00000000        	     1R 	dc.l 0
01:0000050C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000510 00000000        	     1R 	dc.l 0
01:00000514 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000518 00000000        	     1R 	dc.l 0
01:0000051C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000520 00000000        	     1R 	dc.l 0
01:00000524 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000528 00000000        	     1R 	dc.l 0
01:0000052C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000530 00000000        	     1R 	dc.l 0
01:00000534 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000538 00000000        	     1R 	dc.l 0
01:0000053C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000540 00000000        	     1R 	dc.l 0
01:00000544 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000548 00000000        	     1R 	dc.l 0
01:0000054C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000550 00000000        	     1R 	dc.l 0
01:00000554 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000558 00000000        	     1R 	dc.l 0
01:0000055C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000560 00000000        	     1R 	dc.l 0
01:00000564 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000568 00000000        	     1R 	dc.l 0
01:0000056C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000570 00000000        	     1R 	dc.l 0
01:00000574 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000578 00000000        	     1R 	dc.l 0
01:0000057C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000580 00000000        	     1R 	dc.l 0
01:00000584 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000588 00000000        	     1R 	dc.l 0
01:0000058C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000590 00000000        	     1R 	dc.l 0
01:00000594 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000598 00000000        	     1R 	dc.l 0
01:0000059C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005A0 00000000        	     1R 	dc.l 0
01:000005A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005A8 00000000        	     1R 	dc.l 0
01:000005AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005B0 00000000        	     1R 	dc.l 0
01:000005B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005B8 00000000        	     1R 	dc.l 0
01:000005BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005C0 00000000        	     1R 	dc.l 0
01:000005C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005C8 00000000        	     1R 	dc.l 0
01:000005CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005D0 00000000        	     1R 	dc.l 0
01:000005D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005D8 00000000        	     1R 	dc.l 0
01:000005DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005E0 00000000        	     1R 	dc.l 0
01:000005E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005E8 00000000        	     1R 	dc.l 0
01:000005EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005F0 00000000        	     1R 	dc.l 0
01:000005F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005F8 00000000        	     1R 	dc.l 0
01:000005FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000600 00000000        	     1R 	dc.l 0
01:00000604 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000608 00000000        	     1R 	dc.l 0
01:0000060C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000610 00000000        	     1R 	dc.l 0
01:00000614 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000618 00000000        	     1R 	dc.l 0
01:0000061C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000620 00000000        	     1R 	dc.l 0
01:00000624 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000628 00000000        	     1R 	dc.l 0
01:0000062C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000630 00000000        	     1R 	dc.l 0
01:00000634 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000638 00000000        	     1R 	dc.l 0
01:0000063C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000640 00000000        	     1R 	dc.l 0
01:00000644 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000648 00000000        	     1R 	dc.l 0
01:0000064C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000650 00000000        	     1R 	dc.l 0
01:00000654 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000658 00000000        	     1R 	dc.l 0
01:0000065C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000660 00000000        	     1R 	dc.l 0
01:00000664 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000668 00000000        	     1R 	dc.l 0
01:0000066C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000670 00000000        	     1R 	dc.l 0
01:00000674 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000678 00000000        	     1R 	dc.l 0
01:0000067C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000680 00000000        	     1R 	dc.l 0
01:00000684 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000688 00000000        	     1R 	dc.l 0
01:0000068C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000690 00000000        	     1R 	dc.l 0
01:00000694 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000698 00000000        	     1R 	dc.l 0
01:0000069C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006A0 00000000        	     1R 	dc.l 0
01:000006A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006A8 00000000        	     1R 	dc.l 0
01:000006AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006B0 00000000        	     1R 	dc.l 0
01:000006B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006B8 00000000        	     1R 	dc.l 0
01:000006BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006C0 00000000        	     1R 	dc.l 0
01:000006C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006C8 00000000        	     1R 	dc.l 0
01:000006CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006D0 00000000        	     1R 	dc.l 0
01:000006D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006D8 00000000        	     1R 	dc.l 0
01:000006DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006E0 00000000        	     1R 	dc.l 0
01:000006E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006E8 00000000        	     1R 	dc.l 0
01:000006EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006F0 00000000        	     1R 	dc.l 0
01:000006F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006F8 00000000        	     1R 	dc.l 0
01:000006FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000700 00000000        	     1R 	dc.l 0
01:00000704 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000708 00000000        	     1R 	dc.l 0
01:0000070C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000710 00000000        	     1R 	dc.l 0
01:00000714 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000718 00000000        	     1R 	dc.l 0
01:0000071C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000720 00000000        	     1R 	dc.l 0
01:00000724 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000728 00000000        	     1R 	dc.l 0
01:0000072C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000730 00000000        	     1R 	dc.l 0
01:00000734 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000738 00000000        	     1R 	dc.l 0
01:0000073C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000740 00000000        	     1R 	dc.l 0
01:00000744 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000748 00000000        	     1R 	dc.l 0
01:0000074C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000750 00000000        	     1R 	dc.l 0
01:00000754 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000758 00000000        	     1R 	dc.l 0
01:0000075C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000760 00000000        	     1R 	dc.l 0
01:00000764 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000768 00000000        	     1R 	dc.l 0
01:0000076C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000770 00000000        	     1R 	dc.l 0
01:00000774 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000778 00000000        	     1R 	dc.l 0
01:0000077C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000780 00000000        	     1R 	dc.l 0
01:00000784 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000788 00000000        	     1R 	dc.l 0
01:0000078C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000790 00000000        	     1R 	dc.l 0
01:00000794 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000798 00000000        	     1R 	dc.l 0
01:0000079C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007A0 00000000        	     1R 	dc.l 0
01:000007A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007A8 00000000        	     1R 	dc.l 0
01:000007AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007B0 00000000        	     1R 	dc.l 0
01:000007B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007B8 00000000        	     1R 	dc.l 0
01:000007BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007C0 00000000        	     1R 	dc.l 0
01:000007C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007C8 00000000        	     1R 	dc.l 0
01:000007CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007D0 00000000        	     1R 	dc.l 0
01:000007D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007D8 00000000        	     1R 	dc.l 0
01:000007DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007E0 00000000        	     1R 	dc.l 0
01:000007E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007E8 00000000        	     1R 	dc.l 0
01:000007EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007F0 00000000        	     1R 	dc.l 0
01:000007F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007F8 00000000        	     1R 	dc.l 0
01:000007FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000800 00000000        	     1R 	dc.l 0
01:00000804 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000808 00000000        	     1R 	dc.l 0
01:0000080C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000810 00000000        	     1R 	dc.l 0
01:00000814 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000818 00000000        	     1R 	dc.l 0
01:0000081C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000820 00000000        	     1R 	dc.l 0
01:00000824 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000828 00000000        	     1R 	dc.l 0
01:0000082C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000830 00000000        	     1R 	dc.l 0
01:00000834 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000838 00000000        	     1R 	dc.l 0
01:0000083C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000840 00000000        	     1R 	dc.l 0
01:00000844 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000848 00000000        	     1R 	dc.l 0
01:0000084C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000850 00000000        	     1R 	dc.l 0
01:00000854 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000858 00000000        	     1R 	dc.l 0
01:0000085C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000860 00000000        	     1R 	dc.l 0
01:00000864 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000868 00000000        	     1R 	dc.l 0
01:0000086C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000870 00000000        	     1R 	dc.l 0
01:00000874 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000878 00000000        	     1R 	dc.l 0
01:0000087C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000880 00000000        	     1R 	dc.l 0
01:00000884 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000888 00000000        	     1R 	dc.l 0
01:0000088C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000890 00000000        	     1R 	dc.l 0
01:00000894 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000898 00000000        	     1R 	dc.l 0
01:0000089C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008A0 00000000        	     1R 	dc.l 0
01:000008A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008A8 00000000        	     1R 	dc.l 0
01:000008AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008B0 00000000        	     1R 	dc.l 0
01:000008B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008B8 00000000        	     1R 	dc.l 0
01:000008BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008C0 00000000        	     1R 	dc.l 0
01:000008C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008C8 00000000        	     1R 	dc.l 0
01:000008CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008D0 00000000        	     1R 	dc.l 0
01:000008D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008D8 00000000        	     1R 	dc.l 0
01:000008DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008E0 00000000        	     1R 	dc.l 0
01:000008E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008E8 00000000        	     1R 	dc.l 0
01:000008EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008F0 00000000        	     1R 	dc.l 0
01:000008F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008F8 00000000        	     1R 	dc.l 0
01:000008FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000900 00000000        	     1R 	dc.l 0
01:00000904 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000908 00000000        	     1R 	dc.l 0
01:0000090C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000910 00000000        	     1R 	dc.l 0
01:00000914 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000918 00000000        	     1R 	dc.l 0
01:0000091C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000920 00000000        	     1R 	dc.l 0
01:00000924 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000928 00000000        	     1R 	dc.l 0
01:0000092C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000930 00000000        	     1R 	dc.l 0
01:00000934 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000938 00000000        	     1R 	dc.l 0
01:0000093C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000940 00000000        	     1R 	dc.l 0
01:00000944 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000948 00000000        	     1R 	dc.l 0
01:0000094C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000950 00000000        	     1R 	dc.l 0
01:00000954 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000958 00000000        	     1R 	dc.l 0
01:0000095C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000960 00000000        	     1R 	dc.l 0
01:00000964 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000968 00000000        	     1R 	dc.l 0
01:0000096C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000970 00000000        	     1R 	dc.l 0
01:00000974 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000978 00000000        	     1R 	dc.l 0
01:0000097C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000980 00000000        	     1R 	dc.l 0
01:00000984 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000988 00000000        	     1R 	dc.l 0
01:0000098C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000990 00000000        	     1R 	dc.l 0
01:00000994 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000998 00000000        	     1R 	dc.l 0
01:0000099C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009A0 00000000        	     1R 	dc.l 0
01:000009A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009A8 00000000        	     1R 	dc.l 0
01:000009AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009B0 00000000        	     1R 	dc.l 0
01:000009B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009B8 00000000        	     1R 	dc.l 0
01:000009BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009C0 00000000        	     1R 	dc.l 0
01:000009C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009C8 00000000        	     1R 	dc.l 0
01:000009CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009D0 00000000        	     1R 	dc.l 0
01:000009D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009D8 00000000        	     1R 	dc.l 0
01:000009DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009E0 00000000        	     1R 	dc.l 0
01:000009E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009E8 00000000        	     1R 	dc.l 0
01:000009EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009F0 00000000        	     1R 	dc.l 0
01:000009F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009F8 00000000        	     1R 	dc.l 0
01:000009FC 00000000        	     2R 	dc.l 0
                            	     3R 	
                            	   298: 
                            	   299: 	org			$A00
                            	   300: 
                            	   301: ;-------------------------------------------------------------------------------
                            	   302: ;-------------------------------------------------------------------------------
                            	   303: 
                            	   304: ; BIOS variables which must be local (not shared) to each core
                            	   305: 
                            	   306: CursorRow	equ		$40000
                            	   307: CursorCol	equ		$40001
                            	   308: TextPos		equ		$40002
                            	   309: TextCurpos	equ	$40002
                            	   310: TextScr			equ	$40004
                            	   311: S19StartAddress	equ	$40008
                            	   312: KeybdEcho		equ	$4000C
                            	   313: KeybdWaitFlag	equ	$4000D
                            	   314: CmdBuf			equ $40040
                            	   315: CmdBufEnd		equ	$40080
                            	   316: fgColor			equ	$40084
                            	   317: bkColor			equ	$40088
                            	   318: TextRows		equ	$4008C
                            	   319: TextCols		equ	$4008D
                            	   320: _fpTextIncr	equ $40094
                            	   321: _canary			equ $40098
                            	   322: IRQFlag			equ $400A0
                            	   323: InputDevice	equ $400A4
                            	   324: OutputDevice	equ $400A8
                            	   325: Regsave			equ	$40100
                            	   326: numBreakpoints	equ		8
                            	   327: BreakpointFlag	equ		$40200
                            	   328: NumSetBreakpoints	equ	$40202	; to $40203
                            	   329: Breakpoints			equ		$40220	; to $40240
                            	   330: BreakpointWords	equ		$40280	; to $402A0
                            	   331: fpBuf       equ $402C0
                            	   332: ;RunningTCB  equ $40300
                            	   333: _exp equ $40500
                            	   334: _digit equ $40504
                            	   335: _width equ $40508
                            	   336: _E equ $4050C
                            	   337: _digits_before_decpt equ $40510
                            	   338: _precision equ $40514
                            	   339: _fpBuf equ $40520	; to $40560
                            	   340: _fpWork equ $40600
                            	   341: _dasmbuf	equ	$40800
                            	   342: OFFSET equ $40880
                            	   343: 
                            	   344: null_dcb equ $0040A00		; 0
                            	   345: keybd_dcb equ $0040A40	; 1
                            	   346: con_dcb equ $0040A80		; 2
                            	   347: err_dcb equ $0040AC0		; 3
                            	   348: serial_dcb equ $0040B40	; 5
                            	   349: 
                            	   350: TimerStack	equ	$40BFC
                            	   351: 
                            	   352: ; Keyboard buffer is in shared memory
                            	   353: IOFocus			EQU	$00100000
                            	   354: memend			equ $00100004
                            	   355: KeybdLEDs		equ	$0010000E
                            	   356: _KeyState1	equ	$0010000F
                            	   357: _KeyState2	equ	$00100010
                            	   358: _KeybdHead	equ	$00100011
                            	   359: _KeybdTail	equ	$00100012
                            	   360: _KeybdCnt		equ	$00100013
                            	   361: KeybdID			equ	$00100018
                            	   362: _Keybd_tick	equ $0001001C
                            	   363: _KeybdBuf		equ	$00100020
                            	   364: _KeybdOBuf	equ	$00100080
                            	   365: S19Checksum	equ	$00100150
                            	   366: SerTailRcv	equ	$00100160
                            	   367: SerHeadRcv	equ	$00100162
                            	   368: SerRcvXon		equ	$00100164
                            	   369: SerRcvXoff	equ	$00100165
                            	   370: SerTailXmit	equ	$00100166
                            	   371: SerHeadXmit	equ	$00100168
                            	   372: SerXmitXoff	equ	$0010016A
                            	   373: SerRcvBuf		equ	$00101000
                            	   374: SerXmitBuf	equ	$00102000
                            	   375: RTCBuf			equ $00100200	; to $0010023F
                            	   376: 
                            	   377: 	code
                            	   378: 	align		2
                            	   379: start:
                            	   380: ;	fadd (a0)+,fp2
00:000003B8 46FC2700        	   381: 	move.w #$2700,sr					; enable level 6 and higher interrupts
00:000003BC 7000            	   382: 	moveq #0,d0								; set address space zero
00:000003BE 4E7B0003        	   383: 	movec d0,asid
                            	   384: 	; Setup circuit select signals
00:000003C2 203CFDC00000    	   385: 	move.l #MMU,d0
00:000003C8 4E7B0014        	   386: 	movec d0,mmus
                            	   387: 	if HAS_MMU
                            	   388: 		move.l #$01F00000,d0			; set virtual address for iop bitmap
                            	   389: 		movec d0,iops
                            	   390: 		move.l #$01E00000,d0			; set virtual address for io block
                            	   391: 		movec d0,ios
                            	   392: 	else
00:000003CC 203CFD100000    	   393: 		move.l #$FD100000,d0			; set virtual address for iop bitmap
00:000003D2 4E7B0016        	   394: 		movec d0,iops
00:000003D6 203CFD000000    	   395: 		move.l #$FD000000,d0			; set virtual address for io block
00:000003DC 4E7B0015        	   396: 		movec d0,ios
                            	   397: 	endif
                            	   398: ;	move.l $4000000C,d0
00:000003E0 4E7A0FE0        	   399: 	movec coreno,d0							; set initial value of thread register
00:000003E4 4840            	   400: 	swap d0											; coreno in high eight bits
00:000003E6 E188            	   401: 	lsl.l #8,d0
00:000003E8 4E7B0012        	   402: 	movec d0,tr
                            	   403: 	; Prepare local variable storage
00:000003EC 303C03FF        	   404: 	move.w #1023,d0						; 1024 longs to clear
00:000003F0 41F900040000    	   405: 	lea	$40000,a0							; non shared local memory address
                            	   406: .0111:
00:000003F6 4298            	   407: 	clr.l	(a0)+								; clear the memory area
00:000003F8 51C8FFFC        	   408: 	dbra d0,.0111
00:000003FC 610000FC        	   409: 	bsr setup_null
00:00000400 61005AB8        	   410: 	bsr setup_keybd
00:00000404 61000124        	   411: 	bsr setup_console
00:00000408 61007712        	   412: 	bsr setup_serial
00:0000040C 13FC0002000400A8	   413: 	move.b #2,OutputDevice		; select text screen output
                            	   414: 	if (SCREEN_FORMAT==1)
00:00000414 23FC000000FF0004	   415: 		move.l #$0000ff,fgColor		; set foreground / background color (white)
00:0000041C 0084
00:0000041E 23FC000000020004	   416: 		move.l #$000002,bkColor		; medium blue
00:00000426 0088
                            	   417: 	else
                            	   418: 		move.l #$1fffff,fgColor		; set foreground / background color (white)
                            	   419: 		move.l #$00003f,bkColor		; medium blue
                            	   420: 	endif
00:00000428 4E7A0FE0        	   421: 	movec.l	coreno,d0					; get core number (2 to 9)
00:0000042C 5500            	   422: 	subi.b #2,d0							; adjust (0 to 7)
                            	   423: 	if (SCREEN_FORMAT==1)
00:0000042E C0FC2000        	   424: 		mulu #8192,d0						; compute screen location
                            	   425: 	else
                            	   426: 		mulu #16384,d0						; compute screen location
                            	   427: 	endif
                            	   428: 	if HAS_MMU
                            	   429: 		addi.l #$01E00000,d0
                            	   430: 	else
00:00000432 0680FD000000    	   431: 		addi.l #$FD000000,d0
                            	   432: 	endif
00:00000438 23C000040004    	   433: 	move.l d0,TextScr
00:0000043E 13FC00400004008D	   434: 	move.b #64,TextCols				; set rows and columns
00:00000446 13FC00200004008C	   435: 	move.b #32,TextRows
00:0000044E 4E7A0FE0        	   436: 	movec.l	coreno,d0					; get core number
00:00000452 0C000002        	   437: 	cmpi.b #2,d0
00:00000456 667C            	   438: 	bne	start_other
00:00000458 610001AC        	   439: 	bsr init_framebuf
00:0000045C 13C000100000    	   440: 	move.b d0,IOFocus					; Set the IO focus in global memory
                            	   441: 	if HAS_MMU
                            	   442: 		bsr InitMMU							; Can't access anything till this is done'
                            	   443: 	endif
00:00000462 610001CC        	   444: 	bsr	InitIOPBitmap					; not going to get far without this
00:00000466 610002BE        	   445: 	bsr	InitSemaphores
00:0000046A 61000214        	   446: 	bsr	InitRand
00:0000046E 61000250        	   447: 	bsr RandGetNum
00:00000472 0281FFFFFF00    	   448: 	andi.l #$FFFFFF00,d1
00:00000478 23C100040098    	   449: 	move.l d1,_canary
00:0000047E 4E7B1020        	   450: 	movec d1,canary
00:00000482 6100035E        	   451: 	bsr	Delay3s						; give devices time to reset
00:00000486 61005542        	   452: 	bsr	clear_screen
                            	   453: 
00:0000048A 61005B68        	   454: 	bsr	_KeybdInit
                            	   455: ;	bsr	InitIRQ
00:0000048E 61007768        	   456: 	bsr	SerialInit
                            	   457: ;	bsr init_i2c
                            	   458: ;	bsr rtc_read
                            	   459: 
                            	   460: 	; Write startup message to screen
                            	   461: 
00:00000492 43FA7FDE        	   462: 	lea	msg_start,a1
00:00000496 61005820        	   463: 	bsr	DisplayString
                            	   464: ;	bsr	FemtikiInit
00:0000049A 4E7A0FE0        	   465: 	movec	coreno,d0
00:0000049E 4840            	   466: 	swap d0
00:000004A0 7201            	   467: 	moveq	#1,d1
00:000004A2 610002E4        	   468: 	bsr	UnlockSemaphore	; allow another cpu access
00:000004A6 7200            	   469: 	moveq	#0,d1
00:000004A8 610002DE        	   470: 	bsr	UnlockSemaphore	; allow other cpus to proceed
00:000004AC 33FCA4A4FD0FFF00	   471: 	move.w #$A4A4,leds			; diagnostics
00:000004B4 610059CE        	   472: 	bsr	init_plic				; initialize platform level interrupt controller
00:000004B8 6000645C        	   473: 	bra	StartMon
00:000004BC 61000364        	   474: 	bsr	cpu_test
                            	   475: ;	lea	brdisp_trap,a0	; set brdisp trap vector
                            	   476: ;	move.l	a0,64*4
                            	   477: 
                            	   478: loop2:
00:000004C0 70FF            	   479: 	move.l	#-1,d0
                            	   480: loop1:
00:000004C2 2200            	   481: 	move.l	d0,d1
00:000004C4 E089            	   482: 	lsr.l		#8,d1
00:000004C6 E089            	   483: 	lsr.l		#8,d1
00:000004C8 13C1FD0FFF00    	   484: 	move.b	d1,leds
00:000004CE 51C8FFF2        	   485: 	dbra		d0,loop1
00:000004D2 60EC            	   486: 	bra			loop2
                            	   487: 
                            	   488: start_other:
00:000004D4 61000330        	   489: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
00:000004D8 6100032C        	   490: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
00:000004DC 61000328        	   491: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
00:000004E0 610054E8        	   492: 	bsr			clear_screen
00:000004E4 4E7A1FE0        	   493: 	movec		coreno,d1
00:000004E8 610072E6        	   494: 	bsr			DisplayByte
00:000004EC 43FA7FAB        	   495: 	lea			msg_core_start,a1
00:000004F0 610057C6        	   496: 	bsr			DisplayString
                            	   497: ;	bsr			FemtikiInitIRQ
                            	   498: do_nothing:	
00:000004F4 60006420        	   499: 	bra			StartMon
00:000004F8 60FA            	   500: 	bra			do_nothing
                            	   501: 
                            	   502: ;------------------------------------------------------------------------------
                            	   503: ; Initialize the MMU to allow thread #0 access to IO
                            	   504: ;------------------------------------------------------------------------------
                            	   505: 	if HAS_MMU
                            	   506: 	align 2
                            	   507: mmu_adrtbl:	; virtual address[24:16], physical address[31:16] bytes reversed!
                            	   508: 	dc.l	$0010,$10000300	; global scratch pad
                            	   509: 	dc.l	$01E0,$00FD0300	
                            	   510: 	dc.l	$01E1,$01FD0300
                            	   511: 	dc.l	$01E2,$02FD0300
                            	   512: 	dc.l  $01E3,$03FD0300
                            	   513: 	dc.l	$01E5,$05FD0300
                            	   514: 	dc.l	$01E6,$06FD0300
                            	   515: 	dc.l	$01E9,$09FD0300
                            	   516: 	dc.l	$01EF,$0FFD0300
                            	   517: 	dc.l	$01F0,$10FD0300
                            	   518: 	dc.l  $01FF,$FFFF0300	; all ones output for IRQ ack needed
                            	   519: 
                            	   520: 	even
                            	   521: InitMMU:
                            	   522: 	lea MMU+8,a0				; first 128kB is local RAM
                            	   523: 	move.l #$32000,d2		; map all pages to DRAM
                            	   524: 	move.l #510,d0			; then override for IO later
                            	   525: .0002
                            	   526: 	move.l d2,d1
                            	   527: 	bsr rbo
                            	   528: 	move.l d1,(a0)+
                            	   529: 	addi.w #1,d2				; increment DRAM page number
                            	   530: 	dbra d0,.0002
                            	   531: 	lea MMU,a0					; now program IO access
                            	   532: 	lea mmu_adrtbl,a1
                            	   533: 	moveq #10,d0
                            	   534: .0001
                            	   535: 	move.l (a1)+,d2
                            	   536: 	lsl.l #2,d2
                            	   537: 	move.l (a1)+,(a0,d2.w)
                            	   538: 	dbra d0,.0001
                            	   539: 	rts	
                            	   540: 	endif
                            	   541: 
                            	   542: ;------------------------------------------------------------------------------
                            	   543: ; Setup the NULL device
                            	   544: ;------------------------------------------------------------------------------
                            	   545: 
                            	   546: null_init:
                            	   547: setup_null:
00:000004FA 701F            	   548: 	moveq #31,d0
00:000004FC 41F900040A00    	   549: 	lea.l null_dcb,a0
                            	   550: .0001:
00:00000502 4298            	   551: 	clr.l (a0)+
00:00000504 51C8FFFC        	   552: 	dbra d0,.0001
00:00000508 23FC204243440004	   553: 	move.l #$20424344,null_dcb+DCB_MAGIC				; 'DCB'
00:00000510 0A00
00:00000512 23FC4C4C554E0004	   554: 	move.l #$4C4C554E,null_dcb+DCB_NAME					; 'NULL'
00:0000051A 0A04
00:0000051C 23FC000005280004	   555: 	move.l #null_cmdproc,null_dcb+DCB_CMDPROC
00:00000524 0A18
                            	   556: null_ret:
00:00000526 4E75            	   557: 	rts
                            	   558: 
                            	   559: null_cmdproc:
00:00000528 4E75            	   560: 	rts
                            	   561: 
                            	   562: ;------------------------------------------------------------------------------
                            	   563: ; Setup the console device
                            	   564: ; stdout = text screen controller
                            	   565: ;------------------------------------------------------------------------------
                            	   566: 
                            	   567: console_init:
                            	   568: setup_console:
00:0000052A 701F            	   569: 	moveq #31,d0
00:0000052C 41F900040A80    	   570: 	lea.l con_dcb,a0
                            	   571: .0001:
00:00000532 4298            	   572: 	clr.l (a0)+
00:00000534 51C8FFFC        	   573: 	dbra d0,.0001
00:00000538 23FC204243440004	   574: 	move.l #$20424344,con_dcb+DCB_MAGIC				; 'DCB'
00:00000540 0A80
00:00000542 23FC204E4F430004	   575: 	move.l #$204E4F43,con_dcb+DCB_NAME				; 'CON'
00:0000054A 0A84
00:0000054C 23FC000005C80004	   576: 	move.l #console_cmdproc,con_dcb+DCB_CMDPROC
00:00000554 0A98
00:00000556 4E7A0FE0        	   577: 	movec.l	coreno,d0					; get core number (2 to 9)
00:0000055A 5500            	   578: 	subi.b #2,d0							; adjust (0 to 7)
00:0000055C C0FC4000        	   579: 	mulu #16384,d0						; compute screen location
                            	   580: 	if HAS_MMU
                            	   581: 		addi.l #$01E00000,d0
                            	   582: 	else
00:00000560 0680FD000000    	   583: 		addi.l #$FD000000,d0
                            	   584: 	endif
00:00000566 23C000040AA8    	   585: 	move.l d0,con_dcb+DCB_INBUFPTR
00:0000056C 23C000040AAC    	   586: 	move.l d0,con_dcb+DCB_OUTBUFPTR
00:00000572 23FC000040000004	   587: 	move.l #16384,con_dcb+DCB_INBUFSIZE
00:0000057A 0AB0
00:0000057C 23FC000040000004	   588: 	move.l #16384,con_dcb+DCB_OUTBUFSIZE
00:00000584 0AB4
00:00000586 13FC004000040ABB	   589: 	move.b #64,con_dcb+DCB_OUTCOLS	; set rows and columns
00:0000058E 13FC002000040ABA	   590: 	move.b #32,con_dcb+DCB_OUTROWS
00:00000596 13FC004000040AB9	   591: 	move.b #64,con_dcb+DCB_INCOLS		; set rows and columns
00:0000059E 13FC002000040AB8	   592: 	move.b #32,con_dcb+DCB_INROWS
00:000005A6 4E75            	   593: 	rts
                            	   594: 
                            	   595: 	align 2
                            	   596: CON_CMDTBL:
00:000005A8 0000052A        	   597: 	dc.l console_init
00:000005AC 000005EE        	   598: 	dc.l console_stat
00:000005B0 000005F2        	   599: 	dc.l console_putchar
00:000005B4 00000602        	   600: 	dc.l console_putbuf
00:000005B8 000005FA        	   601: 	dc.l console_getchar
00:000005BC 00000602        	   602: 	dc.l console_getbuf
00:000005C0 00000602        	   603: 	dc.l console_set_inpos
00:000005C4 00000602        	   604: 	dc.l console_set_outpos
                            	   605: 
                            	   606: console_cmdproc:
00:000005C8 0C060008        	   607: 	cmpi.b #8,d6
00:000005CC 641C            	   608: 	bhs.s .0001
00:000005CE 4A06            	   609: 	tst.b d6
00:000005D0 6B18            	   610: 	bmi.s .0001
00:000005D2 48E70280        	   611: 	movem.l d6/a0,-(a7)
00:000005D6 E506            	   612: 	asl.b #2,d6
00:000005D8 4886            	   613: 	ext.w d6
00:000005DA 41FAFFCC        	   614: 	lea CON_CMDTBL,a0
00:000005DE 20706000        	   615: 	move.l (a0,d6.w),a0
00:000005E2 4E90            	   616: 	jsr (a0)
00:000005E4 4CDF0140        	   617: 	movem.l (a7)+,d6/a0
00:000005E8 4E75            	   618: 	rts
                            	   619: .0001:
00:000005EA 7002            	   620: 	moveq #E_Func,d0
00:000005EC 4E75            	   621: 	rts
                            	   622: 
                            	   623: console_stat:
00:000005EE 7000            	   624: 	moveq #E_Ok,d0
00:000005F0 4E75            	   625: 	rts
                            	   626: 
                            	   627: console_putchar:
00:000005F2 61005464        	   628: 	bsr DisplayChar
00:000005F6 7000            	   629: 	moveq #E_Ok,d0
00:000005F8 4E75            	   630: 	rts
                            	   631: 
                            	   632: console_getchar:
00:000005FA 61006310        	   633: 	bsr FromScreen
00:000005FE 7000            	   634: 	moveq #E_Ok,d0
00:00000600 4E75            	   635: 	rts
                            	   636: 
                            	   637: console_putbuf:
                            	   638: console_getbuf:
                            	   639: console_set_inpos:
                            	   640: console_set_outpos:
00:00000602 700A            	   641: 	moveq #E_NotSupported,d0
00:00000604 4E75            	   642: 	rts
                            	   643: 
                            	   644: ;------------------------------------------------------------------------------
                            	   645: ;------------------------------------------------------------------------------
                            	   646: 
                            	   647: init_framebuf:
00:00000606 4E75            	   648: 	rts
00:00000608 13FC0001FD200000	   649: 	move.b #1,FRAMEBUF+0		; turn on frame buffer
00:00000610 13FC0001FD200001	   650: 	move.b #1,FRAMEBUF+1		; color depth 16 BPP
00:00000618 13FC0011FD200002	   651: 	move.b #$11,FRAMEBUF+2	; hres 1:1 vres 1:1
00:00000620 4E75            	   652: 	rts
                            	   653: 
                            	   654: ;------------------------------------------------------------------------------
                            	   655: ;------------------------------------------------------------------------------
                            	   656: 
                            	   657: GlobalReadLong:
00:00000622 2210            	   658: 		move.l (a0),d1
00:00000624 4E75            	   659: 		rts
00:00000626 6004            	   660: 		bra nd1
                            	   661: GlobalWriteLong:
00:00000628 2081            	   662: 		move.l d1,(a0)
00:0000062A 4E75            	   663: 		rts
                            	   664: net_delay:
                            	   665: 		bra nd1
                            	   666: nd1	bra nd2
                            	   667: nd2 bra nd3
                            	   668: nd3 bra nd4
00:0000062C 4E71            	   669: nd4	nop
00:0000062E 4E75            	   670: 		rts
                            	   671: 	
                            	   672: 
                            	   673: ;------------------------------------------------------------------------------
                            	   674: ; The IO bitmap needs to be initialized to allow access to IO.
                            	   675: ;------------------------------------------------------------------------------
                            	   676: 
                            	   677: InitIOPBitmap:
00:00000630 7600            	   678: 	moveq #0,d3				; d3 = asid value
00:00000632 303C003F        	   679: 	move.w #63,d0			; 64 bitmaps to setup
00:00000636 4E7A8016        	   680: 	movec iops,a0			; a0 = IOP bitmap address
00:0000063A 2248            	   681: 	movea.l a0,a1			; a1 = table address
                            	   682: .0004
00:0000063C 4A03            	   683: 	tst.b d3
00:0000063E 57C1            	   684: 	seq d1						; set entire bitmap for asid 0, otherwise clear entire bitmap
00:00000640 4881            	   685: 	ext.w	d1					; make into a long value
00:00000642 48C1            	   686: 	ext.l d1
00:00000644 383C007F        	   687: 	move.w #127,d4
                            	   688: .0001
00:00000648 22C1            	   689: 	move.l d1,(a1)+		; set or clear entire table
00:0000064A 51CCFFFC        	   690: 	dbra d4,.0001
00:0000064E 72FF            	   691: 	moveq #-1,d1
00:00000650 214100A0        	   692: 	move.l d1,160(a0)	; all cores have access to semaphores
00:00000654 214100A4        	   693: 	move.l d1,164(a0)
00:00000658 214100A8        	   694: 	move.l d1,168(a0)
00:0000065C 214100AC        	   695: 	move.l d1,172(a0)
00:00000660 217C0000000201FC	   696: 	move.l #2,508(a0)	; all cores access random # generator
00:00000668 4840            	   697: 	swap d0
00:0000066A 303C001F        	   698: 	move.w #31,d0			; 32 long words for the screen area per bitmap
                            	   699: .0003
00:0000066E 20C1            	   700: 	move.l d1,(a0)+		; all cores have access to a screen
00:00000670 51C8FFFC        	   701: 	dbra d0,.0003
00:00000674 4840            	   702: 	swap d0
00:00000676 5203            	   703: 	addi.b #1,d3			; do next address space
00:00000678 2049            	   704: 	movea.l a1,a0			; a0 points to area for next address space
00:0000067A 51C8FFC0        	   705: 	dbra d0,.0004
00:0000067E 4E75            	   706: 	rts	
                            	   707: 	
                            	   708: ;------------------------------------------------------------------------------
                            	   709: ; RandInit
                            	   710: ; 	Initialize random number generator.
                            	   711: ;
                            	   712: ; Modifies:
                            	   713: ;		none
                            	   714: ; Parameters:
                            	   715: ;		none
                            	   716: ;	Returns:
                            	   717: ;		none
                            	   718: ;------------------------------------------------------------------------------
                            	   719: 
                            	   720: InitRand:
                            	   721: RandInit:
00:00000680 48E7C000        	   722: 	movem.l	d0/d1,-(a7)
00:00000684 7025            	   723: 	moveq #37,d0								; lock semaphore
00:00000686 7204            	   724: 	moveq	#RAND_SEMA,d1
00:00000688 4E4F            	   725: 	trap #15
00:0000068A 4E7A0FE0        	   726: 	movec coreno,d0							; d0 = core number
00:0000068E ED88            	   727: 	lsl.l	#6,d0									; allow 64 streams per core
00:00000690 23C0FD0FFD04    	   728: 	move.l d0,RAND_STRM					; select the stream
00:00000696 23FC12345678FD0F	   729: 	move.l #$12345678,RAND_MZ		; initialize to some value
00:0000069E FD08
00:000006A0 23FC98765432FD0F	   730: 	move.l #$98765432,RAND_MW
00:000006A8 FD0C
00:000006AA 23FC2E5BF271FD0F	   731: 	move.l #777777777,RAND_NUM	; generate first number
00:000006B2 FD00
00:000006B4 7026            	   732: 	moveq #38,d0								; unlock semaphore
00:000006B6 7204            	   733: 	moveq	#RAND_SEMA,d1
00:000006B8 4E4F            	   734: 	trap #15
00:000006BA 4CDF0003        	   735: 	movem.l	(a7)+,d0/d1
00:000006BE 4E75            	   736: 	rts
                            	   737: 
                            	   738: ;------------------------------------------------------------------------------
                            	   739: ; Returns
                            	   740: ;		d1 = random integer
                            	   741: ;------------------------------------------------------------------------------
                            	   742: 
                            	   743: RandGetNum:
00:000006C0 48E7A000        	   744: 	movem.l	d0/d2,-(a7)
00:000006C4 7204            	   745: 	moveq #RAND_SEMA,d1
00:000006C6 610000DC        	   746: 	bsr T15LockSemaphore
00:000006CA 4E7A0FE0        	   747: 	movec	coreno,d0
00:000006CE ED88            	   748: 	lsl.l	#6,d0
00:000006D0 23C0FD0FFD04    	   749: 	move.l d0,RAND_STRM					; select the stream
00:000006D6 2439FD0FFD00    	   750: 	move.l RAND_NUM,d2					; d2 = random number
00:000006DC 42B9FD0FFD00    	   751: 	clr.l	RAND_NUM							; generate next number
00:000006E2 610000C6        	   752: 	bsr T15UnlockSemaphore
00:000006E6 2202            	   753: 	move.l d2,d1
00:000006E8 4CDF0005        	   754: 	movem.l	(a7)+,d0/d2
00:000006EC 4E75            	   755: 	rts
                            	   756: 
                            	   757: ;------------------------------------------------------------------------------
                            	   758: ; Modifies:
                            	   759: ;		none
                            	   760: ; Returns
                            	   761: ;		fp0 = random float between 0 and 1.
                            	   762: ;------------------------------------------------------------------------------
                            	   763: 
                            	   764: _GetRand:
00:000006EE 2F01            	   765: 	move.l d1,-(sp)
00:000006F0 F2276880        	   766: 	fmove.x fp1,-(sp)
00:000006F4 61CA            	   767: 	bsr RandGetNum
00:000006F6 E289            	   768: 	lsr.l #1,d1									; make number between 0 and 2^31
00:000006F8 F2014000        	   769: 	fmove.l d1,fp0
00:000006FC F23C40807FFFFFFF	   770: 	fmove.l #$7FFFFFFF,fp1			; divide by 2^31
00:00000704 F2000420        	   771: 	fdiv fp1,fp0
00:00000708 F21F4880        	   772: 	fmove.x (sp)+,fp1
00:0000070C 221F            	   773: 	move.l (sp)+,d1
00:0000070E 4E75            	   774: 	rts
                            	   775: 
                            	   776: ;------------------------------------------------------------------------------
                            	   777: ; RandWait
                            	   778: ;    Wait some random number of clock cycles before returning.
                            	   779: ;------------------------------------------------------------------------------
                            	   780: 
                            	   781: RandWait:
00:00000710 48E7C000        	   782: 	movem.l	d0/d1,-(a7)
00:00000714 61AA            	   783: 	bsr			RandGetNum
00:00000716 0241000F        	   784: 	andi.w	#15,d1
                            	   785: .0001:
00:0000071A 4E71            	   786: 	nop
00:0000071C 51C9FFFC        	   787: 	dbra		d1,.0001
00:00000720 4CDF0003        	   788: 	movem.l	(a7)+,d0/d1
00:00000724 4E75            	   789: 	rts
                            	   790: 
                            	   791: ;------------------------------------------------------------------------------
                            	   792: ; Initialize semaphores
                            	   793: ; - all semaphores are set to unlocked except the first one, which is locked
                            	   794: ; for core #2.
                            	   795: ;
                            	   796: ; Parameters:
                            	   797: ;		<none>
                            	   798: ; Modifies:
                            	   799: ;		<none>
                            	   800: ; Returns:
                            	   801: ;		<none>
                            	   802: ;------------------------------------------------------------------------------
                            	   803: 
                            	   804: InitSemaphores:
00:00000726 48E74080        	   805: 	movem.l	d1/a0,-(a7)
00:0000072A 41F9FD050000    	   806: 	lea			semamem,a0
00:00000730 217C000200002000	   807: 	move.l	#$20000,$2000(a0)	; lock the first semaphore for core #2, thread #0
00:00000738 323C00FE        	   808: 	move.w	#254,d1
                            	   809: .0001:
00:0000073C 5888            	   810: 	lea			4(a0),a0
00:0000073E 42A82000        	   811: 	clr.l		$2000(a0)					; write zeros to unlock
00:00000742 51C9FFF8        	   812: 	dbra		d1,.0001
00:00000746 4CDF0102        	   813: 	movem.l	(a7)+,d1/a0
00:0000074A 4E75            	   814: 	rts
                            	   815: 
                            	   816: ; -----------------------------------------------------------------------------
                            	   817: ; Parameters:
                            	   818: ;		d1 semaphore number
                            	   819: ;
                            	   820: ; Side Effects:
                            	   821: ;		increments semaphore, saturates at 255
                            	   822: ;
                            	   823: ; Returns:	
                            	   824: ; 	z flag set if semaphore was zero
                            	   825: ; -----------------------------------------------------------------------------
                            	   826: 
                            	   827: ;IncrementSemaphore:
                            	   828: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   829: ;	lea			semamem,a0			; point to semaphore memory
                            	   830: ;	ext.w		d1							; make d1 word value
                            	   831: ;	asl.w		#4,d1						; align to memory
                            	   832: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   833: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   834: ;	rts
                            	   835: 	
                            	   836: ; -----------------------------------------------------------------------------
                            	   837: ; Parameters:
                            	   838: ;		d1 semaphore number
                            	   839: ;
                            	   840: ; Side Effects:
                            	   841: ;		decrements semaphore, saturates at zero
                            	   842: ;
                            	   843: ; Returns:	
                            	   844: ; 	z flag set if semaphore was zero
                            	   845: ; -----------------------------------------------------------------------------
                            	   846: 
                            	   847: ;DecrementSemaphore:
                            	   848: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   849: ;	lea			semamem,a0			; point to semaphore memory
                            	   850: ;	andi.w	#255,d1					; make d1 word value
                            	   851: ;	asl.w		#4,d1						; align to memory
                            	   852: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   853: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   854: ;	rts
                            	   855: 
                            	   856: ; -----------------------------------------------------------------------------
                            	   857: ; Lock a semaphore
                            	   858: ;
                            	   859: ; Parameters:
                            	   860: ;		d0 = key
                            	   861: ;		d1 = semaphore number
                            	   862: ; -----------------------------------------------------------------------------
                            	   863: 
                            	   864: LockSemaphore:
00:0000074C 4E75            	   865: 	rts
00:0000074E 48E74080        	   866: 	movem.l	d1/a0,-(a7)			; save registers
00:00000752 41F9FD050000    	   867: 	lea			semamem,a0			; point to semaphore memory lock area
00:00000758 024100FF        	   868: 	andi.w	#255,d1					; make d1 word value
00:0000075C E549            	   869: 	lsl.w		#2,d1						; align to memory
                            	   870: .0001
00:0000075E 21801000        	   871: 	move.l	d0,(a0,d1.w)		; try and write the semaphore
00:00000762 B0B01000        	   872: 	cmp.l		(a0,d1.w),d0		; did it lock?
00:00000766 66F6            	   873: 	bne.s		.0001						; no, try again
00:00000768 4CDF0102        	   874: 	movem.l	(a7)+,a0/d1			; restore regs
00:0000076C 4E75            	   875: 	rts
                            	   876: 	
                            	   877: ; -----------------------------------------------------------------------------
                            	   878: ; Unlocks a semaphore even if not the owner.
                            	   879: ;
                            	   880: ; Parameters:
                            	   881: ;		d1 semaphore number
                            	   882: ; -----------------------------------------------------------------------------
                            	   883: 
                            	   884: ForceUnlockSemaphore:
00:0000076E 48E74080        	   885: 	movem.l	d1/a0,-(a7)				; save registers
00:00000772 41F9FD053000    	   886: 	lea			semamem+$3000,a0	; point to semaphore memory read/write area
00:00000778 024100FF        	   887: 	andi.w	#255,d1						; make d1 word value
00:0000077C E549            	   888: 	lsl.w		#2,d1							; align to memory
00:0000077E 42B01000        	   889: 	clr.l		(a0,d1.w)					; write zero to unlock
00:00000782 4CDF0102        	   890: 	movem.l	(a7)+,a0/d1				; restore regs
00:00000786 4E75            	   891: 	rts
                            	   892: 
                            	   893: ; -----------------------------------------------------------------------------
                            	   894: ; Unlocks a semaphore. Must be the owner to have effect.
                            	   895: ; Three cases:
                            	   896: ;	1) the owner, the semaphore will be reset to zero
                            	   897: ;	2) not the owner, the write will be ignored
                            	   898: ; 3) already unlocked, the write will be ignored
                            	   899: ;
                            	   900: ; Parameters:
                            	   901: ;		d0 = key
                            	   902: ;		d1 = semaphore number
                            	   903: ; -----------------------------------------------------------------------------
                            	   904: 
                            	   905: UnlockSemaphore:
00:00000788 60E4            	   906: 	bra ForceUnlockSemaphore
00:0000078A 48E74080        	   907: 	movem.l	d1/a0,-(a7)				; save registers
00:0000078E 41F9FD051000    	   908: 	lea			semamem+$1000,a0	; point to semaphore memory unlock area
00:00000794 024100FF        	   909: 	andi.w	#255,d1						; make d1 word value
00:00000798 E549            	   910: 	lsl.w		#2,d1							; align to memory
00:0000079A 21801000        	   911: 	move.l	d0,(a0,d1.w)			; write matching value to unlock
00:0000079E 4CDF0102        	   912: 	movem.l	(a7)+,a0/d1				; restore regs
00:000007A2 4E75            	   913: 	rts
                            	   914: 
                            	   915: ; -----------------------------------------------------------------------------
                            	   916: ; Parameters:
                            	   917: ;		d1 = semaphore to lock / unlock
                            	   918: ; -----------------------------------------------------------------------------
                            	   919: 
                            	   920: T15LockSemaphore:	
00:000007A4 4E7A0012        	   921: 	movec tr,d0
00:000007A8 60A2            	   922: 	bra LockSemaphore
                            	   923: 
                            	   924: T15UnlockSemaphore:
00:000007AA 4E7A0012        	   925: 	movec tr,d0
00:000007AE 60D8            	   926: 	bra UnlockSemaphore
                            	   927: 
                            	   928: T15GetFloat:
00:000007B0 2049            	   929: 	move.l a1,a0
00:000007B2 2001            	   930: 	move.l d1,d0
00:000007B4 61006F42        	   931: 	bsr _GetFloat
00:000007B8 2248            	   932: 	move.l a0,a1
00:000007BA 2200            	   933: 	move.l d0,d1
00:000007BC 4E75            	   934: 	rts
                            	   935: 
                            	   936: T15Abort:
00:000007BE 61007010        	   937: 	bsr DisplayByte
00:000007C2 43FA7D50        	   938: 	lea msgStackCanary,a1
00:000007C6 61005506        	   939: 	bsr DisplayStringCRLF
00:000007CA 60006154        	   940: 	bra Monitor
                            	   941: 
                            	   942: chk_exception:
00:000007CE 222F0002        	   943: 	move.l 2(sp),d1
00:000007D2 61006FF0        	   944: 	bsr DisplayTetra
00:000007D6 43FA7D2E        	   945: 	lea msgChk,a1
00:000007DA 610054F2        	   946: 	bsr DisplayStringCRLF
00:000007DE 60006140        	   947: 	bra Monitor
                            	   948: 
                            	   949: ; -----------------------------------------------------------------------------
                            	   950: ; Delay for a few seconds to allow some I/O reset operations to take place.
                            	   951: ; -----------------------------------------------------------------------------
                            	   952: 
                            	   953: Delay3s:
00:000007E2 203C002DC6C0    	   954: 	move.l	#3000000,d0		; this should take a few seconds to loop
00:000007E8 41F9FD0FFF00    	   955: 	lea			leds,a0				; a0 = address of LED output register
00:000007EE 6002            	   956: 	bra			dly3s1				; branch to the loop
                            	   957: dly3s2:	
00:000007F0 4840            	   958: 	swap		d0						; loop is larger than 16-bits
                            	   959: dly3s1:
00:000007F2 2200            	   960: 	move.l	d0,d1					; the counter cycles fast, so use upper bits for display
00:000007F4 E199            	   961: 	rol.l		#8,d1					; could use swap here, but lets test rol
00:000007F6 E199            	   962: 	rol.l		#8,d1
00:000007F8 1081            	   963: 	move.b	d1,(a0)				; set the LEDs
00:000007FA 51C8FFF6        	   964: 	dbra		d0,dly3s1			; decrement and branch back
00:000007FE 4840            	   965: 	swap		d0
00:00000800 51C8FFEE        	   966: 	dbra		d0,dly3s2
00:00000804 4E75            	   967: 	rts
                            	   968: 
                            	   969: Delay3s2:
00:00000806 4E7A0FE0        	   970: 	movec		coreno,d0			; vary delay by core to stagger startup
00:0000080A E188            	   971: 	lsl.l		#8,d0
00:0000080C 0680002DC6C0    	   972: 	addi.l	#3000000,d0		; this should take a few seconds to loop
00:00000812 6002            	   973: 	bra			.0001					; branch to the loop
                            	   974: .0002	
00:00000814 4840            	   975: 	swap		d0						; loop is larger than 16-bits
                            	   976: .0001
00:00000816 51C8FFFE        	   977: 	dbra		d0,.0001			; decrement and branch back
00:0000081A 4840            	   978: 	swap		d0
00:0000081C 51C8FFF6        	   979: 	dbra		d0,.0002
00:00000820 4E75            	   980: 	rts
                            	   981: 
                            	   982: 	include "cputest.x68"

Source: "cputest.x68"
                            	     1: ;; @name cputest.s Tests 68000 cpu
                            	     2: ;
                            	     3: ; Based on https://github.com/MicroCoreLabs/Projects/blob/master/MCL68/MC68000_Test_Code/MC68000_test_all_opcodes.X68
                            	     4: ;
                            	     5: ; Converted into a CD-i system ROM image by CD-i Fan:
                            	     6: ; - comment lines must start in first column
                            	     7: ; - replaced org instructions by suitable rept
                            	     8: ; - copy vectors to low memory at startup
                            	     9: ; - replaced jsr/jmp by bsr/bra for position independence
                            	    10: ; - replaced move.l by moveq whenever possible
                            	    11: ; - converted branches to short form whenever possible (e.g. beq => beq.s)
                            	    12: ; - added immediate suffix to opcodes where required (e.g. and => andi)
                            	    13: ; The last three modifications are required to make the test work;
                            	    14: ; apparently the original assembler was somewhat smarter then
                            	    15: ; the Microware OS-9 assembler and did this automatically.
                            	    16: ;
                            	    17: ; In some cases the opcodes of the test are used as test data!
                            	    18: ;
                            	    19: ; Original file header follows.
                            	    20: ;
                            	    21: ;  File Name   :  MCL68 Opcode Tests
                            	    22: ;  Used on     :
                            	    23: ;  Author      :  Ted Fried, MicroCore Labs
                            	    24: ;  Creation    :  7/14/2020
                            	    25: ;
                            	    26: ;   Description:
                            	    27: ;   ============
                            	    28: ;
                            	    29: ;  Program to test all of the Motorola 68000's opcodes.
                            	    30: ;
                            	    31: ;  If failures are detected, the code will immediately loop on itself.
                            	    32: ;  All addressing modes, data sizes, and opcode combinations are tested.
                            	    33: ;
                            	    34: ;  This code was developed using the Easy68K simulator where all tests passed!
                            	    35: ;
                            	    36: ;------------------------------------------------------------------------
                            	    37: ;
                            	    38: ; Modification History:
                            	    39: ; =====================
                            	    40: ;
                            	    41: ; Revision 1 7/14/2020
                            	    42: ; Initial revision
                            	    43: ;
                            	    44: ;
                            	    45: ;------------------------------------------------------------------------
                            	    46: ;
                            	    47: ; Copyright (c) 2020 Ted Fried
                            	    48: ;
                            	    49: ; Permission is hereby granted, free of charge, to any person obtaining a copy
                            	    50: ; of this software and associated documentation files (the "Software"), to deal
                            	    51: ; in the Software without restriction, including without limitation the rights
                            	    52: ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                            	    53: ; copies of the Software, and to permit persons to whom the Software is
                            	    54: ; furnished to do so, subject to the following conditions:
                            	    55: ;
                            	    56: ; The above copyright notice and this permission notice shall be included in all
                            	    57: ; copies or substantial portions of the Software.
                            	    58: ;
                            	    59: ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            	    60: ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            	    61: ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            	    62: ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            	    63: ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                            	    64: ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                            	    65: ; SOFTWARE.
                            	    66: 
                            	    67: ; Modified for rf68000 project (c) 2022 Robert Finch
                            	    68: 
                            	    69: ;	data
                            	    70: ;	dc.l		$0001FFFC						; top of local ram area
                            	    71: ;	dc.l		start
                            	    72: 
                            	    73: ;    org $1000												; code starts at $400 in local ram
                            	    74: *start:
                            	    75: ;	move.l	$FFFFFFE0,d0		; get core number
                            	    76: ;	cmpi.b	#2,d0
                            	    77: ;	bne			do_nothing
                            	    78: 
                            	    79: ;	lea			EXCEPTION_6,a0	; check exception vector
                            	    80: ;	move.l	a0,6*4
                            	    81: ;	lea			EXCEPTION_7,a0	; TRAPV exception vector
                            	    82: ;	move.l	a0,7*4
                            	    83: 
                            	    84: cpu_test:
00:00000822 610000F6        	    85: 	bsr	op_ORI_TO_CCR
00:00000826 61000114        	    86: 	bsr	op_ORI_TO_SR
00:0000082A 61000132        	    87: 	bsr	op_EORI_TO_CCR
00:0000082E 61000154        	    88: 	bsr	op_EORI_TO_SR
00:00000832 61000176        	    89: 	bsr	op_ANDI_TO_CCR
00:00000836 61000198        	    90: 	bsr	op_ANDI_TO_SR
00:0000083A 610001BA        	    91: 	bsr	op_BTST
00:0000083E 61000560        	    92: 	bsr	op_BCHG
00:00000842 610008C4        	    93: 	bsr	op_BCLR
00:00000846 61000C0E        	    94: 	bsr	op_BSET
00:0000084A 61000F52        	    95: 	bsr op_MOVEP
00:0000084E 61000FDA        	    96: 	bsr op_BOOL_I
00:00000852 610011BE        	    97: 	bsr op_CMP_I
00:00000856 610013A2        	    98: 	bsr op_ADD_I
00:0000085A 61001524        	    99: 	bsr op_SUB_I
00:0000085E 610016A6        	   100: 	bsr op_MOVE
00:00000862 610018AE        	   101: 	bsr op_MOVE_xxx_FLAGS
00:00000866 61001A9E        	   102: 	bsr op_EXT
00:0000086A 61001AC6        	   103: 	bsr op_SWAP
00:0000086E 61001AD8        	   104: 	bsr op_LEAPEA
00:00000872 61001B80        	   105: 	bsr op_TAS
00:00000876 61001BA2        	   106: 	bsr op_TST
00:0000087A 61001BDC        	   107: 	bsr op_LINKS
00:0000087E 61001BF6        	   108: 	bsr op_MOVE_USP
00:00000882 61001C02        	   109: 	bsr op_CHK
00:00000886 61001C48        	   110: 	bsr op_NEGS
00:0000088A 61001FD2        	   111: 	bsr op_MOVEM
                            	   112: ;	bsr op_ABCD
                            	   113: ;	bsr op_SBCD
                            	   114: ;	bsr op_NBCD
00:0000088E 6100256E        	   115: 	bsr op_TRAPV
00:00000892 61002586        	   116: 	bsr op_RTR
00:00000896 61001144        	   117: 	bsr op_BSR
00:0000089A 610025A0        	   118: 	bsr op_BCC
00:0000089E 6100261C        	   119: 	bsr op_DBCC
00:000008A2 6100263E        	   120: 	bsr op_SCC
00:000008A6 6100266A        	   121: 	bsr op_ADDQ
00:000008AA 61002720        	   122: 	bsr op_SUBQ
00:000008AE 610027D6        	   123: 	bsr op_MOVEQ
                            	   124: ;	bsr op_DIVU
                            	   125: ;	bsr op_DIVS
00:000008B2 61002892        	   126: 	bsr op_OR
00:000008B6 61002978        	   127: 	bsr op_AND
00:000008BA 61002A5E        	   128: 	bsr op_EOR
00:000008BE 61002AD0        	   129: 	bsr op_CMP
00:000008C2 61002B42        	   130: 	bsr op_CMPA
00:000008C6 61002BA4        	   131: 	bsr op_CMPM
00:000008CA 61002C46        	   132: 	bsr op_ADD
00:000008CE 61002D2C        	   133: 	bsr op_SUB
00:000008D2 61002E12        	   134: 	bsr op_ADDA
00:000008D6 61002E5A        	   135: 	bsr op_SUBA
00:000008DA 61002EA2        	   136: 	bsr op_ADDX	
00:000008DE 61002FAE        	   137: 	bsr op_SUBX
00:000008E2 610030BA        	   138: 	bsr op_MULU
00:000008E6 61003102        	   139: 	bsr op_MULS
00:000008EA 6100314A        	   140: 	bsr op_EXG
00:000008EE 610031B4        	   141: 	bsr op_ROx
00:000008F2 610033E6        	   142: 	bsr op_ROXx
00:000008F6 61003618        	   143: 	bsr op_SHIFTS
00:000008FA 61003856        	   144: 	bsr op_SHIFTS2
                            	   145: 
00:000008FE 4E75            	   146: 	rts
                            	   147: 	bra ALL_DONE
                            	   148: 
                            	   149: * Loop here when all tests pass
                            	   150: *
                            	   151: 
00:00000900 60FE            	   152: ALL_DONE: bra.s ALL_DONE
                            	   153: 
00:00000902 263C33333333    	   154: BSR_FAR1:       move.l #$33333333,d3
00:00000908 4E75            	   155:                 rts
                            	   156: 
                            	   157: ;	moveq		#-1,d0
                            	   158: ;	move.l	d0,$FD0FFF00
                            	   159: ;do_nothing:
                            	   160: ;	bra			*		
                            	   161: 
                            	   162: 
                            	   163: ;' Exception Vector = 6   CHK Instruction
                            	   164: ;
                            	   165: ;	align	4
                            	   166: EXCEPTION_6:
00:0000090A 2C3CEEEE0006    	   167: 	move.l #$EEEE0006,d6      * Set d6 to the exception vector
00:00000910 4E73            	   168: 	rte
                            	   169: 
                            	   170: ; Exception Vector = 7   TRAPV Instruction
                            	   171: ;
                            	   172: ;	align	4
                            	   173: EXCEPTION_7:
00:00000912 203C12345678    	   174: 	move.l #$12345678,d0      * Set d6 to the exception vector
00:00000918 4E73            	   175: 	rte
                            	   176: 
                            	   177: ;-----------------------------------------------------------
                            	   178: ;-----------------------------------------------------------
                            	   179: ; OPCODE : ORI_TO_CCR
                            	   180: ;-----------------------------------------------------------
                            	   181: ;-----------------------------------------------------------
                            	   182: op_ORI_TO_CCR:
                            	   183: 
00:0000091A 003C00FF        	   184:     ori.b #$FF,CCR
00:0000091E 6AFE            	   185:     bpl.s *                   ; branch if Z clear
00:00000920 66FE            	   186:     bne.s *                   ; branch if N clear
00:00000922 68FE            	   187:     bvc.s *                   ; branch if V clear
00:00000924 64FE            	   188:     bcc.s *                   ; branch if C clear
                            	   189: 
00:00000926 44FC0000        	   190:     move #$00,CCR
00:0000092A 003C0000        	   191:     ori.b #$00,CCR
00:0000092E 67FE            	   192:     beq.s *                   ; branch if Z set
00:00000930 6BFE            	   193:     bmi.s *                   ; branch if N set
00:00000932 69FE            	   194:     bvs.s *                   ; branch if V set
00:00000934 65FE            	   195:     bcs.s *                   ; branch if C set
                            	   196: 
00:00000936 46FC2700        	   197:     move.w #$2700,SR          ; Put flags back to initial value
                            	   198: 
00:0000093A 4E75            	   199:     rts
                            	   200: 
                            	   201: ;-----------------------------------------------------------
                            	   202: ;-----------------------------------------------------------
                            	   203: ; OPCODE : ORI_TO_SR
                            	   204: ;-----------------------------------------------------------
                            	   205: ;-----------------------------------------------------------
                            	   206: 
                            	   207: op_ORI_TO_SR:
                            	   208: 
00:0000093C 007C2FFF        	   209:     ori.w #$2FFF,SR
00:00000940 6AFE            	   210:     bpl.s *                   * branch if Z clear
00:00000942 66FE            	   211:     bne.s *                   * branch if N clear
00:00000944 68FE            	   212:     bvc.s *                   * branch if V clear
00:00000946 64FE            	   213:     bcc.s *                   * branch if C clear
                            	   214: 
00:00000948 46FC2000        	   215:     move.w #$2000,SR
00:0000094C 007C0000        	   216:     ori.w #$0000,SR
00:00000950 67FE            	   217:     beq.s *                   * branch if Z set
00:00000952 6BFE            	   218:     bmi.s *                   * branch if N set
00:00000954 69FE            	   219:     bvs.s *                   * branch if V set
00:00000956 65FE            	   220:     bcs.s *                   * branch if C set
                            	   221: 
00:00000958 46FC2700        	   222:     move.w #$2700,sr         * Put flags back to initial value
                            	   223: 
00:0000095C 4E75            	   224:     rts
                            	   225: ; 
                            	   226: ;-----------------------------------------------------------
                            	   227: ;-----------------------------------------------------------
                            	   228: ; OPCODE : EORI_TO_CCR
                            	   229: ;-----------------------------------------------------------
                            	   230: ;-----------------------------------------------------------
                            	   231: op_EORI_TO_CCR:
                            	   232: 
00:0000095E 44FC0000        	   233:     move #$00,CCR
00:00000962 0A3C00FF        	   234:     eori.b #$FF,CCR
00:00000966 6AFE            	   235:     bpl.s *                   ; branch if Z clear
00:00000968 66FE            	   236:     bne.s *                   ; branch if N clear
00:0000096A 68FE            	   237:     bvc.s *                   ; branch if V clear
00:0000096C 64FE            	   238:     bcc.s *                   ; branch if C clear
                            	   239: 
00:0000096E 44FC0000        	   240:     move #$00,CCR
00:00000972 0A3C0000        	   241:     eori.b #$00,CCR
00:00000976 67FE            	   242:     beq.s *                   ; branch if Z set
00:00000978 6BFE            	   243:     bmi.s *                   ; branch if N set
00:0000097A 69FE            	   244:     bvs.s *                   ; branch if V set
00:0000097C 65FE            	   245:     bcs.s *                   ; branch if C set
                            	   246: 
00:0000097E 46FC2700        	   247:     move.w #$2700,sr           ; Put flags back to initial value
                            	   248: 
00:00000982 4E75            	   249:     rts
                            	   250: 
                            	   251: 
                            	   252: 
                            	   253: *-----------------------------------------------------------
                            	   254: *-----------------------------------------------------------
                            	   255: * OPCODE : EORI_TO_SR
                            	   256: *-----------------------------------------------------------
                            	   257: *-----------------------------------------------------------
                            	   258: op_EORI_TO_SR:
                            	   259: 
00:00000984 46FC2000        	   260:     move.w #$2000,SR
00:00000988 0A7C0FFF        	   261:     eori.w #$0FFF,SR
00:0000098C 6AFE            	   262:     bpl.s *                   * branch if Z clear
00:0000098E 66FE            	   263:     bne.s *                   * branch if N clear
00:00000990 68FE            	   264:     bvc.s *                   * branch if V clear
00:00000992 64FE            	   265:     bcc.s *                   * branch if C clear
                            	   266: 
00:00000994 46FC2000        	   267:     move.w #$2000,SR
00:00000998 0A7C0000        	   268:     eori.w #$0000,SR
00:0000099C 67FE            	   269:     beq.s *                   * branch if Z set
00:0000099E 6BFE            	   270:     bmi.s *                   * branch if N set
00:000009A0 69FE            	   271:     bvs.s *                   * branch if V set
00:000009A2 65FE            	   272:     bcs.s *                   * branch if C set
                            	   273: 
00:000009A4 46FC2700        	   274:     move.w #$2700,sr          * Put flags back to initial value
                            	   275: 
00:000009A8 4E75            	   276:     rts
                            	   277: 
                            	   278: 
                            	   279: 
                            	   280: *-----------------------------------------------------------
                            	   281: *-----------------------------------------------------------
                            	   282: * OPCODE : ANDI_TO_CCR
                            	   283: *-----------------------------------------------------------
                            	   284: *-----------------------------------------------------------
                            	   285: op_ANDI_TO_CCR:
                            	   286: 
00:000009AA 44FC00FF        	   287:     move #$FF,CCR
00:000009AE 023C00FF        	   288:     andi.b #$FF,CCR
00:000009B2 6AFE            	   289:     bpl.s *                   * branch if Z clear
00:000009B4 66FE            	   290:     bne.s *                   * branch if N clear
00:000009B6 68FE            	   291:     bvc.s *                   * branch if V clear
00:000009B8 64FE            	   292:     bcc.s *                   * branch if C clear
                            	   293: 
00:000009BA 44FC00FF        	   294:     move #$FF,CCR
00:000009BE 023C0000        	   295:     andi.b #$00,CCR
00:000009C2 67FE            	   296:     beq.s *                   * branch if Z set
00:000009C4 6BFE            	   297:     bmi.s *                   * branch if N set
00:000009C6 69FE            	   298:     bvs.s *                   * branch if V set
00:000009C8 65FE            	   299:     bcs.s *                   * branch if C set
                            	   300: 
00:000009CA 46FC2700        	   301:     move #$2700,SR           * Put flags back to initial value
                            	   302: 
00:000009CE 4E75            	   303:     rts
                            	   304: 
                            	   305: 
                            	   306: 
                            	   307: *-----------------------------------------------------------
                            	   308: *-----------------------------------------------------------
                            	   309: * OPCODE : ANDI_TO_SR
                            	   310: *-----------------------------------------------------------
                            	   311: *-----------------------------------------------------------
                            	   312: op_ANDI_TO_SR:
00:000009D0 46FC20FF        	   313:     move.w #$20FF,SR
00:000009D4 027CFFFF        	   314:     andi.w #$FFFF,SR
00:000009D8 6AFE            	   315:     bpl.s *                   * branch if Z clear
00:000009DA 66FE            	   316:     bne.s *                   * branch if N clear
00:000009DC 68FE            	   317:     bvc.s *                   * branch if V clear
00:000009DE 64FE            	   318:     bcc.s *                   * branch if C clear
                            	   319: 
00:000009E0 46FC20FF        	   320:     move.w #$20FF,SR
00:000009E4 027CFF00        	   321:     andi.w #$FF00,SR
00:000009E8 67FE            	   322:     beq.s *                   * branch if Z set
00:000009EA 6BFE            	   323:     bmi.s *                   * branch if N set
00:000009EC 69FE            	   324:     bvs.s *                   * branch if V set
00:000009EE 65FE            	   325:     bcs.s *                   * branch if C set
                            	   326: 
00:000009F0 46FC2700        	   327:     move.w #$2700,sr           * Put flags back to initial value
                            	   328: 
00:000009F4 4E75            	   329:     rts
                            	   330: 
                            	   331: 
                            	   332: *-----------------------------------------------------------
                            	   333: *-----------------------------------------------------------
                            	   334: * OPCODE : BTST
                            	   335: *-----------------------------------------------------------
                            	   336: *-----------------------------------------------------------
                            	   337: op_BTST:
                            	   338: 
                            	   339: *  Bit Number.s Static
                            	   340: 
                            	   341: *             EA = Dn  - LONG only
00:000009F6 203C80000001    	   342:             move.l #$80000001,d0      * populate test data
00:000009FC 08000000        	   343:             btst.l #0,d0
00:00000A00 67FE            	   344:             beq.s *               * branch if Z set
00:00000A02 08000001        	   345:             btst.l #1,d0              *
00:00000A06 66FE            	   346:             bne.s *               * branch if Z clear
00:00000A08 0800001F        	   347:             btst.l #31,d0             *
00:00000A0C 67FE            	   348:             beq.s *               * branch if Z set
                            	   349: 
                            	   350: 
                            	   351: *             EA = (An)  - BYTE only
00:00000A0E 307C0100        	   352:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000A12 10BC0081        	   353:             move.b #$81,(a0)          * populate test data
00:00000A16 1210            	   354:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00000A18 08100000        	   355:             btst.b #0,(a0)
00:00000A1C 67FE            	   356:             beq.s *               * branch if Z set
00:00000A1E 08100001        	   357:             btst.b #1,(a0)            *
00:00000A22 66FE            	   358:             bne.s *               * branch if Z clear
00:00000A24 08100007        	   359:             btst.b #7,(a0)            *
00:00000A28 67FE            	   360:             beq.s *               * branch if Z set
                            	   361: 
                            	   362: 
                            	   363: *             EA = (An)+  - BYTE only
00:00000A2A 307C0100        	   364:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000A2E 10FC0001        	   365:             move.b #$01,(a0)+         * populate test data
00:00000A32 10FC00FC        	   366:             move.b #$FC,(a0)+         * populate test data
00:00000A36 10FC0080        	   367:             move.b #$80,(a0)+         * populate test data
00:00000A3A 307C0100        	   368:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000A3E 08180000        	   369:             btst.b #0,(a0)+
00:00000A42 67FE            	   370:             beq.s *               * branch if Z set
00:00000A44 08180001        	   371:             btst.b #1,(a0)+           *
00:00000A48 66FE            	   372:             bne.s *               * branch if Z clear
00:00000A4A 08180007        	   373:             btst.b #7,(a0)+           *
00:00000A4E 67FE            	   374:             beq.s *               * branch if Z set
                            	   375: 
                            	   376: 
                            	   377: *             EA = -(An)  - BYTE only
00:00000A50 307C0100        	   378:             move.l #$00000100,a0      * point to memory to address
00:00000A54 10FC0080        	   379:             move.b #$80,(a0)+         * populate test data
00:00000A58 10FC00FC        	   380:             move.b #$FC,(a0)+         * populate test data
00:00000A5C 10FC0001        	   381:             move.b #$01,(a0)+         * populate test data
00:00000A60 307C0103        	   382:             move.l #$00000103,a0      * point to memory to address
00:00000A64 08200000        	   383:             btst.b #0,-(a0)
00:00000A68 67FE            	   384:             beq.s *               * branch if Z set
00:00000A6A 08200001        	   385:             btst.b #1,-(a0)           *
00:00000A6E 66FE            	   386:             bne.s *               * branch if Z clear
00:00000A70 08200007        	   387:             btst.b #7,-(a0)           *
00:00000A74 67FE            	   388:             beq.s *               * branch if Z set
                            	   389: 
                            	   390: 
                            	   391: *             EA = n(An)  - BYTE only
00:00000A76 307C0100        	   392:             move.l #$00000100,a0      * point to memory to address
00:00000A7A 10FC0001        	   393:             move.b #$01,(a0)+         * populate test data
00:00000A7E 10FC00FC        	   394:             move.b #$FC,(a0)+         * populate test data
00:00000A82 10FC0080        	   395:             move.b #$80,(a0)+         * populate test data
00:00000A86 307C0100        	   396:             move.l #$00000100,a0      * point to memory to address
00:00000A8A 08100000        	   397:             btst.b #0,0(a0)
00:00000A8E 67FE            	   398:             beq.s *               * branch if Z set
00:00000A90 082800010001    	   399:             btst.b #1,1(a0)           *
00:00000A96 66FE            	   400:             bne.s *               * branch if Z clear
00:00000A98 082800070002    	   401:             btst.b #7,2(a0)           *
00:00000A9E 67FE            	   402:             beq.s *               * branch if Z set
                            	   403: 
                            	   404: 
                            	   405: *             EA = n(An,R.W)  - BYTE only
00:00000AA0 307C0100        	   406:             move.l #$00000100,a0      * point to memory to address
00:00000AA4 93C9            	   407:             move.l #$00000000,a1      * point to memory to address
00:00000AA6 347C0001        	   408:             move.l #$00000001,a2      * point to memory to address
00:00000AAA 7000            	   409:             moveq  #$00000000,d0      * point to memory to address
00:00000AAC 7201            	   410:             moveq  #$00000001,d1      * point to memory to address
00:00000AAE 083000000000    	   411:             btst.b #0,0(a0,d0.w)
00:00000AB4 67FE            	   412:             beq.s *               * branch if Z set
00:00000AB6 083000011000    	   413:             btst.b #1,0(a0,d1.w)      *
00:00000ABC 66FE            	   414:             bne.s *               * branch if Z clear
00:00000ABE 083000071001    	   415:             btst.b #7,1(a0,d1.w)      *
00:00000AC4 67FE            	   416:             beq.s *               * branch if Z set
                            	   417: *             EA = n(An,R.L)  - BYTE only
00:00000AC6 083000000800    	   418:             btst.b #0,0(a0,d0.l)
00:00000ACC 67FE            	   419:             beq.s *               * branch if Z set
00:00000ACE 083000011800    	   420:             btst.b #1,0(a0,d1.l)      *
00:00000AD4 66FE            	   421:             bne.s *               * branch if Z clear
00:00000AD6 083000071801    	   422:             btst.b #7,1(a0,d1.l)      *
00:00000ADC 67FE            	   423:             beq.s *               * branch if Z set
                            	   424: *             EA = n(An,A.W)  - BYTE only
00:00000ADE 083000009000    	   425:             btst.b #0,0(a0,a1.w)
00:00000AE4 67FE            	   426:             beq.s *               * branch if Z set
00:00000AE6 08300001A000    	   427:             btst.b #1,0(a0,a2.w)      *
00:00000AEC 66FE            	   428:             bne.s *               * branch if Z clear
00:00000AEE 08300007A001    	   429:             btst.b #7,1(a0,a2.w)      *
00:00000AF4 67FE            	   430:             beq.s *               * branch if Z set
                            	   431: *             EA = n(An,A.L)  - BYTE only
00:00000AF6 083000009800    	   432:             btst.b #0,0(a0,a1.l)
00:00000AFC 67FE            	   433:             beq.s *               * branch if Z set
00:00000AFE 08300001A800    	   434:             btst.b #1,0(a0,a2.l)      *
00:00000B04 66FE            	   435:             bne.s *               * branch if Z clear
00:00000B06 08300007A801    	   436:             btst.b #7,1(a0,a2.l)      *
00:00000B0C 67FE            	   437:             beq.s *               * branch if Z set
                            	   438: 
                            	   439: 
                            	   440: *             EA = x.W  - BYTE only
00:00000B0E 083800000100    	   441:             btst.b #0,$0100
00:00000B14 67FE            	   442:             beq.s *               * branch if Z set
00:00000B16 083800010101    	   443:             btst.b #1,$0101           *
00:00000B1C 66FE            	   444:             bne.s *               * branch if Z clear
00:00000B1E 083800070102    	   445:             btst.b #7,$0102           *
00:00000B24 67FE            	   446:             beq.s *               * branch if Z set
                            	   447: 
                            	   448: 
                            	   449: *             EA = x.L  - BYTE only
00:00000B26 207C0000F100    	   450:             move.l #$F100,a0      * point to memory to address 0x100
00:00000B2C 10FC0001        	   451:             move.b #$01,(a0)+         * populate test data
00:00000B30 10FC00FC        	   452:             move.b #$FC,(a0)+         * populate test data
00:00000B34 10FC0080        	   453:             move.b #$80,(a0)+         * populate test data
00:00000B38 083900000000F100	   454:             btst.b #0,$F100
00:00000B40 67FE            	   455:             beq.s *               * branch if Z set
00:00000B42 083900010000F101	   456:             btst.b #1,$F101       *
00:00000B4A 66FE            	   457:             bne.s *               * branch if Z clear
00:00000B4C 083900070000F102	   458:             btst.b #7,$F102       *
00:00000B54 67FE            	   459:             beq.s *               * branch if Z set
                            	   460: 
                            	   461: 
                            	   462: *             EA = x(PC)  - BYTE only
00:00000B56 4BFAFE9E        	   463:             lea op_BTST(pc),a5
00:00000B5A 083A0000FE98    	   464:             btst.b #0,op_BTST(pc)
00:00000B60 66FE            	   465:             bne.s *               * branch if Z clear
00:00000B62 083A0003001A    	   466:             btst.b #3,op_BTST0(pc)     *
00:00000B68 67FE            	   467:             beq.s *               * branch if Z set
00:00000B6A 083A00060074    	   468:             btst.b #6,op_BTST12(pc)    *
00:00000B70 67FE            	   469:             beq.s *               * branch if Z set
                            	   470: 
                            	   471: 
                            	   472: *             EA = n(PC,R.W)  - BYTE only
00:00000B72 307C0100        	   473:             move.l #$00000100,a0      * point to memory to address
00:00000B76 93C9            	   474:             move.l #$00000000,a1      * point to memory to address
00:00000B78 347C0001        	   475:             move.l #$00000001,a2      * point to memory to address
00:00000B7C 7000            	   476:             moveq  #$00000000,d0      * point to memory to address
00:00000B7E 7201            	   477:             moveq  #$00000001,d1      * point to memory to address
                            	   478: 
00:00000B80 083B000000FC    	   479: op_BTST0:   btst.b #0,op_BTST0(pc,d0.w)
00:00000B86 66FE            	   480:             bne.s *               * branch if Z clear
                            	   481: 
00:00000B88 4BFB1002        	   482:             lea op_BTST1(pc,d1.w),a5
00:00000B8C 083B000110FC    	   483: op_BTST1:   btst.b #1,op_BTST1(pc,d1.w)      *
00:00000B92 67FE            	   484:             beq.s *               * branch if Z set
00:00000B94 083B000710FC    	   485: op_BTST2:   btst.b #7,op_BTST2(pc,d1.w)      *
00:00000B9A 66FE            	   486:             bne.s *               * branch if Z clear
                            	   487: *             EA = n(PC,R.L)  - BYTE only
00:00000B9C 083B000008FC    	   488: op_BTST3:   btst.b #0,op_BTST3(pc,d0.l)
00:00000BA2 66FE            	   489:             bne.s *               * branch if Z clear
00:00000BA4 083B000118FC    	   490: op_BTST4:   btst.b #1,op_BTST4(pc,d1.l)      *
00:00000BAA 67FE            	   491:             beq.s *               * branch if Z set
00:00000BAC 083B000718FC    	   492: op_BTST5:   btst.b #7,op_BTST5(pc,d1.l)      *
00:00000BB2 66FE            	   493:             bne.s *               * branch if Z clear
                            	   494: *             EA = n(PC,A.W)  - BYTE only
00:00000BB4 083B000090FC    	   495: op_BTST6    btst.b #0,op_BTST6(pc,a1.w)
00:00000BBA 66FE            	   496:             bne.s *               * branch if Z clear
00:00000BBC 083B0001A0FC    	   497: op_BTST7:   btst.b #1,op_BTST7(pc,a2.w)      *
00:00000BC2 67FE            	   498:             beq.s *               * branch if Z set
00:00000BC4 083B0007A0FC    	   499: op_BTST8:   btst.b #7,op_BTST8(pc,a2.w)      *
00:00000BCA 66FE            	   500:             bne.s *               * branch if Z clear
                            	   501: *             EA = n(PC,A.L)  - BYTE only
00:00000BCC 083B000098FC    	   502: op_BTST9:   btst.b #0,op_BTST9(pc,a1.l)
00:00000BD2 66FE            	   503:             bne.s *               * branch if Z clear
00:00000BD4 083B0001A8FC    	   504: op_BTST10:  btst.b #1,op_BTST10(pc,a2.l)      *
00:00000BDA 67FE            	   505:             beq.s *               * branch if Z set
00:00000BDC 083B0007A8FC    	   506: op_BTST11:  btst.b #7,op_BTST11(pc,a2.l)      *
00:00000BE2 66FE            	   507: op_BTST12:  bne.s *               * branch if Z clear
                            	   508: 
                            	   509: 
                            	   510: 
                            	   511: * Bit Number.s Dynamic
                            	   512: 
                            	   513: *             EA = Dn  - LONG only
00:00000BE4 203C80000001    	   514:             move.l #$80000001,d0      * populate test data
00:00000BEA 7A00            	   515:             move.l #0,d5              * populate bit.s number to test
00:00000BEC 7C01            	   516:             move.l #1,d6              * populate bit.s number to test
00:00000BEE 7E1F            	   517:             move.l #31,d7              * populate bit.s number to test
                            	   518: 
00:00000BF0 0B00            	   519:             btst.l d5,d0
00:00000BF2 67FE            	   520:             beq.s *               * branch if Z set
00:00000BF4 0D00            	   521:             btst.l d6,d0              *
00:00000BF6 66FE            	   522:             bne.s *               * branch if Z clear
00:00000BF8 0F00            	   523:             btst.l d7,d0             *
00:00000BFA 67FE            	   524:             beq.s *               * branch if Z set
                            	   525: 
                            	   526: 
                            	   527: *             EA = (An)  - BYTE only
00:00000BFC 7A00            	   528:             move.l #0,d5              * populate bit.s number to test
00:00000BFE 7C01            	   529:             move.l #1,d6              * populate bit.s number to test
00:00000C00 7E07            	   530:             move.l #7,d7              * populate bit.s number to test
00:00000C02 307C0100        	   531:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000C06 10BC0081        	   532:             move.b #$81,(a0)          * populate test data
00:00000C0A 1210            	   533:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00000C0C 0B10            	   534:             btst.b d5,(a0)
00:00000C0E 67FE            	   535:             beq.s *               * branch if Z set
00:00000C10 0D10            	   536:             btst.b d6,(a0)            *
00:00000C12 66FE            	   537:             bne.s *               * branch if Z clear
00:00000C14 0F10            	   538:             btst.b d7,(a0)            *
00:00000C16 67FE            	   539:             beq.s *               * branch if Z set
                            	   540: 
                            	   541: * ---
                            	   542: 
                            	   543: 
                            	   544: *             EA = (An)+  - BYTE only
00:00000C18 307C0100        	   545:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000C1C 10FC0001        	   546:             move.b #$01,(a0)+         * populate test data
00:00000C20 10FC00FC        	   547:             move.b #$FC,(a0)+         * populate test data
00:00000C24 10FC0080        	   548:             move.b #$80,(a0)+         * populate test data
00:00000C28 307C0100        	   549:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000C2C 0B18            	   550:             btst.b d5,(a0)+
00:00000C2E 67FE            	   551:             beq.s *               * branch if Z set
00:00000C30 0D18            	   552:             btst.b d6,(a0)+           *
00:00000C32 66FE            	   553:             bne.s *               * branch if Z clear
00:00000C34 0F18            	   554:             btst.b d7,(a0)+           *
00:00000C36 67FE            	   555:             beq.s *               * branch if Z set
                            	   556: 
                            	   557: 
                            	   558: *             EA = -(An)  - BYTE only
00:00000C38 307C0100        	   559:             move.l #$00000100,a0      * point to memory to address
00:00000C3C 10FC0080        	   560:             move.b #$80,(a0)+         * populate test data
00:00000C40 10FC00FC        	   561:             move.b #$FC,(a0)+         * populate test data
00:00000C44 10FC0001        	   562:             move.b #$01,(a0)+         * populate test data
00:00000C48 307C0103        	   563:             move.l #$00000103,a0      * point to memory to address
00:00000C4C 0B20            	   564:             btst.b d5,-(a0)
00:00000C4E 67FE            	   565:             beq.s *               * branch if Z set
00:00000C50 0D20            	   566:             btst.b d6,-(a0)           *
00:00000C52 66FE            	   567:             bne.s *               * branch if Z clear
00:00000C54 0F20            	   568:             btst.b d7,-(a0)           *
00:00000C56 67FE            	   569:             beq.s *               * branch if Z set
                            	   570: 
                            	   571: 
                            	   572: *             EA = n(An)  - BYTE only
00:00000C58 307C0100        	   573:             move.l #$00000100,a0      * point to memory to address
00:00000C5C 10FC0001        	   574:             move.b #$01,(a0)+         * populate test data
00:00000C60 10FC00FC        	   575:             move.b #$FC,(a0)+         * populate test data
00:00000C64 10FC0080        	   576:             move.b #$80,(a0)+         * populate test data
00:00000C68 307C0100        	   577:             move.l #$00000100,a0      * point to memory to address
00:00000C6C 0B10            	   578:             btst.b d5,0(a0)
00:00000C6E 67FE            	   579:             beq.s *               * branch if Z set
00:00000C70 0D280001        	   580:             btst.b d6,1(a0)           *
00:00000C74 66FE            	   581:             bne.s *               * branch if Z clear
00:00000C76 0F280002        	   582:             btst.b d7,2(a0)           *
00:00000C7A 67FE            	   583:             beq.s *               * branch if Z set
                            	   584: 
                            	   585: 
                            	   586: *             EA = n(An,R.W)  - BYTE only
00:00000C7C 307C0100        	   587:             move.l #$00000100,a0      * point to memory to address
00:00000C80 93C9            	   588:             move.l #$00000000,a1      * point to memory to address
00:00000C82 347C0001        	   589:             move.l #$00000001,a2      * point to memory to address
00:00000C86 7000            	   590:             moveq  #$00000000,d0      * point to memory to address
00:00000C88 7201            	   591:             moveq  #$00000001,d1      * point to memory to address
00:00000C8A 0B300000        	   592:             btst.b d5,0(a0,d0.w)
00:00000C8E 67FE            	   593:             beq.s *               * branch if Z set
00:00000C90 0D301000        	   594:             btst.b d6,0(a0,d1.w)      *
00:00000C94 66FE            	   595:             bne.s *               * branch if Z clear
00:00000C96 0F301001        	   596:             btst.b d7,1(a0,d1.w)      *
00:00000C9A 67FE            	   597:             beq.s *               * branch if Z set
                            	   598: *             EA = n(An,R.L)  - BYTE only
00:00000C9C 0B300800        	   599:             btst.b d5,0(a0,d0.l)
00:00000CA0 67FE            	   600:             beq.s *               * branch if Z set
00:00000CA2 0D301800        	   601:             btst.b d6,0(a0,d1.l)      *
00:00000CA6 66FE            	   602:             bne.s *               * branch if Z clear
00:00000CA8 0F301801        	   603:             btst.b d7,1(a0,d1.l)      *
00:00000CAC 67FE            	   604:             beq.s *               * branch if Z set
                            	   605: *             EA = n(An,A.W)  - BYTE only
00:00000CAE 0B309000        	   606:             btst.b d5,0(a0,a1.w)
00:00000CB2 67FE            	   607:             beq.s *               * branch if Z set
00:00000CB4 0D30A000        	   608:             btst.b d6,0(a0,a2.w)      *
00:00000CB8 66FE            	   609:             bne.s *               * branch if Z clear
00:00000CBA 0F30A001        	   610:             btst.b d7,1(a0,a2.w)      *
00:00000CBE 67FE            	   611:             beq.s *               * branch if Z set
                            	   612: *             EA = n(An,A.L)  - BYTE only
00:00000CC0 0B309800        	   613:             btst.b d5,0(a0,a1.l)
00:00000CC4 67FE            	   614:             beq.s *               * branch if Z set
00:00000CC6 0D30A800        	   615:             btst.b d6,0(a0,a2.l)      *
00:00000CCA 66FE            	   616:             bne.s *               * branch if Z clear
00:00000CCC 0F30A801        	   617:             btst.b d7,1(a0,a2.l)      *
00:00000CD0 67FE            	   618:             beq.s *               * branch if Z set
                            	   619: 
                            	   620: 
                            	   621: *             EA = x.W  - BYTE only
00:00000CD2 0B380100        	   622:             btst.b d5,$0100
00:00000CD6 67FE            	   623:             beq.s *               * branch if Z set
00:00000CD8 0D380101        	   624:             btst.b d6,$0101           *
00:00000CDC 66FE            	   625:             bne.s *               * branch if Z clear
00:00000CDE 0F380102        	   626:             btst.b d7,$0102           *
00:00000CE2 67FE            	   627:             beq.s *               * branch if Z set
                            	   628: 
                            	   629: 
                            	   630: *             EA = x.L  - BYTE only
00:00000CE4 207C0000F100    	   631:             move.l #$F100,a0      * point to memory to address 0x100
00:00000CEA 10FC0001        	   632:             move.b #$01,(a0)+         * populate test data
00:00000CEE 10FC00FC        	   633:             move.b #$FC,(a0)+         * populate test data
00:00000CF2 10FC0080        	   634:             move.b #$80,(a0)+         * populate test data
00:00000CF6 0B390000F100    	   635:             btst.b d5,$F100
00:00000CFC 67FE            	   636:             beq.s *               * branch if Z set
00:00000CFE 0D390000F101    	   637:             btst.b d6,$F101       *
00:00000D04 66FE            	   638:             bne.s *               * branch if Z clear
00:00000D06 0F390000F102    	   639:             btst.b d7,$F102       *
00:00000D0C 67FE            	   640:             beq.s *               * branch if Z set
                            	   641: 
                            	   642: 
                            	   643: *             EA = x(PC)  - BYTE only
00:00000D0E 7C03            	   644:             move.l #3,d6              * populate bit.s number to test
00:00000D10 7E06            	   645:             move.l #6,d7              * populate bit.s number to test
00:00000D12 4BFAFCE2        	   646:             lea op_BTST(pc),a5
00:00000D16 0B3AFCDE        	   647:             btst.b d5,op_BTST(pc)
00:00000D1A 66FE            	   648:             bne.s *               * branch if Z clear
00:00000D1C 0D3AFE62        	   649:             btst.b d6,op_BTST0(pc)     *
00:00000D20 67FE            	   650:             beq.s *               * branch if Z set
00:00000D22 0F3AFEBE        	   651:             btst.b d7,op_BTST12(pc)    *
00:00000D26 67FE            	   652:             beq.s *               * branch if Z set
                            	   653: 
                            	   654: 
                            	   655: *             EA = n(PC,R.W)  - BYTE only
00:00000D28 307C0100        	   656:             move.l #$00000100,a0      * point to memory to address
00:00000D2C 93C9            	   657:             move.l #$00000000,a1      * point to memory to address
00:00000D2E 347C0001        	   658:             move.l #$00000001,a2      * point to memory to address
00:00000D32 7000            	   659:             moveq  #$00000000,d0      * point to memory to address
00:00000D34 7201            	   660:             moveq  #$00000001,d1      * point to memory to address
00:00000D36 7C01            	   661:             move.l #1,d6              * populate bit.s number to test
00:00000D38 7E07            	   662:             move.l #7,d7              * populate bit.s number to test
                            	   663: 
00:00000D3A 0B3B00FE        	   664: op_BTST20:  btst.b d5,op_BTST20(pc,d0.w)
00:00000D3E 67FE            	   665:             beq.s *               * branch if Z set
00:00000D40 4BFB1002        	   666:             lea op_BTST21(pc,d1.w),a5
00:00000D44 0D3B10FE        	   667: op_BTST21:  btst.b d6,op_BTST21(pc,d1.w)      *
00:00000D48 67FE            	   668:             beq.s *               * branch if Z set
00:00000D4A 0F3B10FE        	   669: op_BTST22:  btst.b d7,op_BTST22(pc,d1.w)      *
00:00000D4E 66FE            	   670:             bne.s *               * branch if Z clear
                            	   671: *             EA = n(PC,R.L)  - BYTE only
00:00000D50 0B3B08FE        	   672: op_BTST23:  btst.b d5,op_BTST23(pc,d0.l)
00:00000D54 67FE            	   673:             beq.s *               * branch if Z set
00:00000D56 0D3B18FE        	   674: op_BTST24: btst.b d6,op_BTST24(pc,d1.l)      *
00:00000D5A 67FE            	   675:             beq.s *               * branch if Z set
00:00000D5C 0F3B18FE        	   676: op_BTST25  btst.b d7,op_BTST25(pc,d1.l)      *
00:00000D60 66FE            	   677:             bne.s *               * branch if Z clear
                            	   678: *             EA = n(PC,A.W)  - BYTE only
00:00000D62 0B3B90FE        	   679: op_BTST26   btst.b d5,op_BTST26(pc,a1.w)
00:00000D66 67FE            	   680:             beq.s *               * branch if Z set
00:00000D68 0D3BA0FE        	   681: op_BTST27:  btst.b d6,op_BTST27(pc,a2.w)      *
00:00000D6C 67FE            	   682:             beq.s *               * branch if Z set
00:00000D6E 0F3BA0FE        	   683: op_BTST28:  btst.b d7,op_BTST28(pc,a2.w)      *
00:00000D72 66FE            	   684:             bne.s *               * branch if Z clear
                            	   685: *             EA = n(PC,A.L)  - BYTE only
00:00000D74 0B3B98FE        	   686: op_BTST29:  btst.b d5,op_BTST29(pc,a1.l)
00:00000D78 67FE            	   687:             beq.s *               * branch if Z set
00:00000D7A 0D3BA8FE        	   688: op_BTST30:  btst.b d6,op_BTST30(pc,a2.l)      *
00:00000D7E 67FE            	   689:             beq.s *               * branch if Z set
00:00000D80 0F3BA8FE        	   690: op_BTST31:  btst.b d7,op_BTST31(pc,a2.l)      *
00:00000D84 66FE            	   691: op_BTST32:  bne.s *               * branch if Z clear
                            	   692: 
                            	   693: *             EA = #x  - BYTE only
                            	   694: 
00:00000D86 7A00            	   695:             move.l #0,d5              * populate bit.s number to test
00:00000D88 7C03            	   696:             move.l #3,d6              * populate bit.s number to test
00:00000D8A 7E07            	   697:             move.l #7,d7              * populate bit.s number to test
                            	   698: 
00:00000D8C 0B3C0088        	   699:             btst.b d5,#$88
00:00000D90 66FE            	   700:             bne.s *               * branch if Z clear
00:00000D92 0D3C0088        	   701:             btst.b d6,#$88
00:00000D96 67FE            	   702:             beq.s *               * branch if Z set
00:00000D98 0F3C0088        	   703:             btst.b d7,#$88
00:00000D9C 67FE            	   704:             beq.s *               * branch if Z set
                            	   705: 
                            	   706: 
00:00000D9E 4E75            	   707:     rts
                            	   708: 
                            	   709: *-----------------------------------------------------------
                            	   710: *-----------------------------------------------------------
                            	   711: * OPCODE : BCHG
                            	   712: *-----------------------------------------------------------
                            	   713: *-----------------------------------------------------------
                            	   714: op_BCHG:
                            	   715: 
                            	   716: 
                            	   717: *  Bit Number.s Static
                            	   718: 
                            	   719: *             EA = Dn  - LONG only
00:00000DA0 203C80000001    	   720:             move.l #$80000001,d0      * populate test data
00:00000DA6 08400000        	   721:             bchg.l #0,d0
00:00000DAA 67FE            	   722:             beq.s *               * branch if Z set
00:00000DAC 08400001        	   723:             bchg.l #1,d0              *
00:00000DB0 66FE            	   724:             bne.s *               * branch if Z clear
00:00000DB2 0840001F        	   725:             bchg.l #31,d0             *
00:00000DB6 67FE            	   726:             beq.s *               * branch if Z set
00:00000DB8 0C8000000002    	   727:             cmpi.l #$00000002,d0
00:00000DBE 66FE            	   728:             bne.s *               * branch if Z clear
                            	   729: 
                            	   730: 
                            	   731: *             EA = (An)  - BYTE only
00:00000DC0 307C0100        	   732:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000DC4 10BC0081        	   733:             move.b #$81,(a0)          * populate test data
00:00000DC8 1210            	   734:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00000DCA 08500000        	   735:             bchg.b #0,(a0)
00:00000DCE 67FE            	   736:             beq.s *               * branch if Z set
00:00000DD0 08500001        	   737:             bchg.b #1,(a0)            *
00:00000DD4 66FE            	   738:             bne.s *               * branch if Z clear
00:00000DD6 08500007        	   739:             bchg.b #7,(a0)            *
00:00000DDA 67FE            	   740:             beq.s *               * branch if Z set
00:00000DDC 0C100002        	   741:             cmpi.b #$02,(a0)
00:00000DE0 66FE            	   742:             bne.s *               * branch if Z clear
                            	   743: 
                            	   744: *             EA = (An)+  - BYTE only
00:00000DE2 307C0100        	   745:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000DE6 10FC0001        	   746:             move.b #$01,(a0)+         * populate test data
00:00000DEA 10FC00FC        	   747:             move.b #$FC,(a0)+         * populate test data
00:00000DEE 10FC0080        	   748:             move.b #$80,(a0)+         * populate test data
00:00000DF2 307C0100        	   749:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000DF6 08580000        	   750:             bchg.b #0,(a0)+
00:00000DFA 67FE            	   751:             beq.s *               * branch if Z set
00:00000DFC 08580001        	   752:             bchg.b #1,(a0)+           *
00:00000E00 66FE            	   753:             bne.s *               * branch if Z clear
00:00000E02 08580007        	   754:             bchg.b #7,(a0)+           *
00:00000E06 67FE            	   755:             beq.s *               * branch if Z set
00:00000E08 307C0100        	   756:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000E0C 4A18            	   757:             cmpi.b #$00,(a0)+
00:00000E0E 66FE            	   758:             bne.s *               * branch if Z clear
00:00000E10 0C1800FE        	   759:             cmpi.b #$FE,(a0)+
00:00000E14 66FE            	   760:             bne.s *               * branch if Z clear
00:00000E16 4A18            	   761:             cmpi.b #$00,(a0)+
00:00000E18 66FE            	   762:             bne.s *               * branch if Z clear
                            	   763: 
                            	   764: *             EA = -(An)  - BYTE only
00:00000E1A 307C0100        	   765:             move.l #$00000100,a0      * point to memory to address
00:00000E1E 10FC0080        	   766:             move.b #$80,(a0)+         * populate test data
00:00000E22 10FC00FC        	   767:             move.b #$FC,(a0)+         * populate test data
00:00000E26 10FC0001        	   768:             move.b #$01,(a0)+         * populate test data
00:00000E2A 307C0103        	   769:             move.l #$00000103,a0      * point to memory to address
00:00000E2E 08600000        	   770:             bchg.b #0,-(a0)
00:00000E32 67FE            	   771:             beq.s *               * branch if Z set
00:00000E34 08600001        	   772:             bchg.b #1,-(a0)           *
00:00000E38 66FE            	   773:             bne.s *               * branch if Z clear
00:00000E3A 08600007        	   774:             bchg.b #7,-(a0)           *
00:00000E3E 67FE            	   775:             beq.s *               * branch if Z set
00:00000E40 307C0103        	   776:             move.l #$00000103,a0      * point to memory to address 0x100
00:00000E44 4A20            	   777:             cmpi.b #$00,-(a0)
00:00000E46 66FE            	   778:             bne.s *               * branch if Z clear
00:00000E48 0C2000FE        	   779:             cmpi.b #$FE,-(a0)
00:00000E4C 66FE            	   780:             bne.s *               * branch if Z clear
00:00000E4E 4A20            	   781:             cmpi.b #$00,-(a0)
00:00000E50 66FE            	   782:             bne.s *               * branch if Z clear
                            	   783: 
                            	   784: 
                            	   785: *             EA = n(An)  - BYTE only
00:00000E52 307C0100        	   786:             move.l #$00000100,a0      * point to memory to address
00:00000E56 10FC0001        	   787:             move.b #$01,(a0)+         * populate test data
00:00000E5A 10FC00FC        	   788:             move.b #$FC,(a0)+         * populate test data
00:00000E5E 10FC0080        	   789:             move.b #$80,(a0)+         * populate test data
00:00000E62 307C0100        	   790:             move.l #$00000100,a0      * point to memory to address
00:00000E66 08500000        	   791:             bchg.b #0,0(a0)
00:00000E6A 67FE            	   792:             beq.s *               * branch if Z set
00:00000E6C 086800010001    	   793:             bchg.b #1,1(a0)           *
00:00000E72 66FE            	   794:             bne.s *               * branch if Z clear
00:00000E74 086800070002    	   795:             bchg.b #7,2(a0)           *
00:00000E7A 67FE            	   796:             beq.s *               * branch if Z set
00:00000E7C 307C0100        	   797:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000E80 4A18            	   798:             cmpi.b #$00,(a0)+
00:00000E82 66FE            	   799:             bne.s *               * branch if Z clear
00:00000E84 0C1800FE        	   800:             cmpi.b #$FE,(a0)+
00:00000E88 66FE            	   801:             bne.s *               * branch if Z clear
00:00000E8A 4A18            	   802:             cmpi.b #$00,(a0)+
00:00000E8C 66FE            	   803:             bne.s *               * branch if Z clear
                            	   804: 
                            	   805: 
                            	   806: *             EA = n(An,D.W)  - BYTE only
00:00000E8E 307C0100        	   807:             move.l #$00000100,a0      * point to memory to address
00:00000E92 93C9            	   808:             move.l #$00000000,a1      * point to memory to address
00:00000E94 347C0001        	   809:             move.l #$00000001,a2      * point to memory to address
00:00000E98 7000            	   810:             moveq  #$00000000,d0      * point to memory to address
00:00000E9A 7201            	   811:             moveq  #$00000001,d1      * point to memory to address
00:00000E9C 087000000000    	   812:             bchg.b #0,0(a0,d0.w)
00:00000EA2 66FE            	   813:             bne.s *               * branch if Z clear
00:00000EA4 087000011000    	   814:             bchg.b #1,0(a0,d1.w)      *
00:00000EAA 67FE            	   815:             beq.s *               * branch if Z set
00:00000EAC 087000071001    	   816:             bchg.b #7,1(a0,d1.w)      *
00:00000EB2 66FE            	   817:             bne.s *               * branch if Z clear
                            	   818: *             EA = n(An,D.L)  - BYTE only
00:00000EB4 087000000800    	   819:             bchg.b #0,0(a0,d0.l)
00:00000EBA 67FE            	   820:             beq.s *               * branch if Z set
00:00000EBC 087000011800    	   821:             bchg.b #1,0(a0,d1.l)      *
00:00000EC2 66FE            	   822:             bne.s *               * branch if Z clear
00:00000EC4 087000071801    	   823:             bchg.b #7,1(a0,d1.l)      *
00:00000ECA 67FE            	   824:             beq.s *               * branch if Z set
                            	   825: *             EA = n(An,A.W)  - BYTE only
00:00000ECC 087000009000    	   826:             bchg.b #0,0(a0,a1.w)
00:00000ED2 66FE            	   827:             bne.s *               * branch if Z clear
00:00000ED4 08700001A000    	   828:             bchg.b #1,0(a0,a2.w)      *
00:00000EDA 67FE            	   829:             beq.s *               * branch if Z set
00:00000EDC 08700007A001    	   830:             bchg.b #7,1(a0,a2.w)      *
00:00000EE2 66FE            	   831:             bne.s *               * branch if Z clear
                            	   832: *             EA = n(An,A.L)  - BYTE only
00:00000EE4 087000009800    	   833:             bchg.b #0,0(a0,a1.l)
00:00000EEA 67FE            	   834:             beq.s *               * branch if Z set
00:00000EEC 08700001A800    	   835:             bchg.b #1,0(a0,a2.l)      *
00:00000EF2 66FE            	   836:             bne.s *               * branch if Z clear
00:00000EF4 08700007A801    	   837:             bchg.b #7,1(a0,a2.l)      *
00:00000EFA 67FE            	   838:             beq.s *               * branch if Z set
00:00000EFC 307C0100        	   839:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000F00 4A18            	   840:             cmpi.b #$00,(a0)+
00:00000F02 66FE            	   841:             bne.s *               * branch if Z clear
00:00000F04 0C1800FE        	   842:             cmpi.b #$FE,(a0)+
00:00000F08 66FE            	   843:             bne.s *               * branch if Z clear
00:00000F0A 4A18            	   844:             cmpi.b #$00,(a0)+
00:00000F0C 66FE            	   845:             bne.s *               * branch if Z clear
                            	   846: 
                            	   847: 
                            	   848: *             EA = x.W  - BYTE only
00:00000F0E 087800000100    	   849:             bchg.b #0,$0100
00:00000F14 66FE            	   850:             bne.s *               * branch if Z clear
00:00000F16 087800010101    	   851:             bchg.b #1,$0101           *
00:00000F1C 67FE            	   852:             beq.s *               * branch if Z set
00:00000F1E 087800070102    	   853:             bchg.b #7,$0102           *
00:00000F24 66FE            	   854:             bne.s *               * branch if Z clear
00:00000F26 307C0100        	   855:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000F2A 0C180001        	   856:             cmpi.b #$01,(a0)+
00:00000F2E 66FE            	   857:             bne.s *               * branch if Z clear
00:00000F30 0C1800FC        	   858:             cmpi.b #$FC,(a0)+
00:00000F34 66FE            	   859:             bne.s *               * branch if Z clear
00:00000F36 0C180080        	   860:             cmpi.b #$80,(a0)+
00:00000F3A 66FE            	   861:             bne.s *               * branch if Z clear
                            	   862: 
                            	   863: *             EA = x.L  - BYTE only
00:00000F3C 207C0000F100    	   864:             move.l #$F100,a0      * point to memory to address 0x100
00:00000F42 10FC0001        	   865:             move.b #$01,(a0)+         * populate test data
00:00000F46 10FC00FC        	   866:             move.b #$FC,(a0)+         * populate test data
00:00000F4A 10FC0080        	   867:             move.b #$80,(a0)+         * populate test data
00:00000F4E 087900000000F100	   868:             bchg.b #0,$F100
00:00000F56 67FE            	   869:             beq.s *               * branch if Z set
00:00000F58 087900010000F101	   870:             bchg.b #1,$F101       *
00:00000F60 66FE            	   871:             bne.s *               * branch if Z clear
00:00000F62 087900070000F102	   872:             bchg.b #7,$F102       *
00:00000F6A 67FE            	   873:             beq.s *               * branch if Z set
00:00000F6C 307C0100        	   874:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000F70 0C180001        	   875:             cmpi.b #$01,(a0)+
00:00000F74 66FE            	   876:             bne.s *               * branch if Z clear
00:00000F76 0C1800FC        	   877:             cmpi.b #$FC,(a0)+
00:00000F7A 66FE            	   878:             bne.s *               * branch if Z clear
00:00000F7C 0C180080        	   879:             cmpi.b #$80,(a0)+
00:00000F80 66FE            	   880:             bne.s *               * branch if Z clear
                            	   881: 
                            	   882: 
                            	   883: * Bit Number.s Dynamic
                            	   884: 
                            	   885: *             EA = Dn  - LONG only
00:00000F82 203C80000001    	   886:             move.l #$80000001,d0      * populate test data
00:00000F88 7A00            	   887:             move.l #0,d5              * populate bit.s number to test
00:00000F8A 7C01            	   888:             move.l #1,d6              * populate bit.s number to test
00:00000F8C 7E1F            	   889:             move.l #31,d7              * populate bit.s number to test
                            	   890: 
00:00000F8E 0B40            	   891:             bchg.l d5,d0
00:00000F90 67FE            	   892:             beq.s *               * branch if Z set
00:00000F92 0D40            	   893:             bchg.l d6,d0              *
00:00000F94 66FE            	   894:             bne.s *               * branch if Z clear
00:00000F96 0F40            	   895:             bchg.l d7,d0             *
00:00000F98 67FE            	   896:             beq.s *               * branch if Z set
00:00000F9A 0C8000000002    	   897:             cmpi.l #$00000002,d0
00:00000FA0 66FE            	   898:             bne.s *               * branch if Z clear
                            	   899: 
                            	   900: 
                            	   901: *             EA = (An)  - BYTE only
00:00000FA2 7A00            	   902:             move.l #0,d5              * populate bit.s number to test
00:00000FA4 7C01            	   903:             move.l #1,d6              * populate bit.s number to test
00:00000FA6 7E07            	   904:             move.l #7,d7              * populate bit.s number to test
00:00000FA8 307C0100        	   905:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000FAC 10BC0081        	   906:             move.b #$81,(a0)          * populate test data
00:00000FB0 1210            	   907:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00000FB2 0B50            	   908:             bchg.b d5,(a0)
00:00000FB4 67FE            	   909:             beq.s *               * branch if Z set
00:00000FB6 0D50            	   910:             bchg.b d6,(a0)            *
00:00000FB8 66FE            	   911:             bne.s *               * branch if Z clear
00:00000FBA 0F50            	   912:             bchg.b d7,(a0)            *
00:00000FBC 67FE            	   913:             beq.s *               * branch if Z set
00:00000FBE 0C100002        	   914:             cmpi.b #$02,(a0)
00:00000FC2 66FE            	   915:             bne.s *               * branch if Z clear
                            	   916: 
                            	   917: 
                            	   918: *             EA = (An)+  - BYTE only
00:00000FC4 307C0100        	   919:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000FC8 10FC0001        	   920:             move.b #$01,(a0)+         * populate test data
00:00000FCC 10FC00FC        	   921:             move.b #$FC,(a0)+         * populate test data
00:00000FD0 10FC0080        	   922:             move.b #$80,(a0)+         * populate test data
00:00000FD4 307C0100        	   923:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000FD8 0B58            	   924:             bchg.b d5,(a0)+
00:00000FDA 67FE            	   925:             beq.s *               * branch if Z set
00:00000FDC 0D58            	   926:             bchg.b d6,(a0)+           *
00:00000FDE 66FE            	   927:             bne.s *               * branch if Z clear
00:00000FE0 0F58            	   928:             bchg.b d7,(a0)+           *
00:00000FE2 67FE            	   929:             beq.s *               * branch if Z set
00:00000FE4 307C0100        	   930:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000FE8 4A18            	   931:             cmpi.b #$00,(a0)+
00:00000FEA 66FE            	   932:             bne.s *               * branch if Z clear
00:00000FEC 0C1800FE        	   933:             cmpi.b #$FE,(a0)+
00:00000FF0 66FE            	   934:             bne.s *               * branch if Z clear
00:00000FF2 4A18            	   935:             cmpi.b #$00,(a0)+
00:00000FF4 66FE            	   936:             bne.s *               * branch if Z clear
                            	   937: 
                            	   938: *             EA = -(An)  - BYTE only
00:00000FF6 307C0100        	   939:             move.l #$00000100,a0      * point to memory to address
00:00000FFA 10FC0080        	   940:             move.b #$80,(a0)+         * populate test data
00:00000FFE 10FC00FC        	   941:             move.b #$FC,(a0)+         * populate test data
00:00001002 10FC0001        	   942:             move.b #$01,(a0)+         * populate test data
00:00001006 307C0103        	   943:             move.l #$00000103,a0      * point to memory to address
00:0000100A 0B60            	   944:             bchg.b d5,-(a0)
00:0000100C 67FE            	   945:             beq.s *               * branch if Z set
00:0000100E 0D60            	   946:             bchg.b d6,-(a0)           *
00:00001010 66FE            	   947:             bne.s *               * branch if Z clear
00:00001012 0F60            	   948:             bchg.b d7,-(a0)           *
00:00001014 67FE            	   949:             beq.s *               * branch if Z set
00:00001016 307C0103        	   950:             move.l #$00000103,a0      * point to memory to address 0x100
00:0000101A 4A20            	   951:             cmpi.b #$00,-(a0)
00:0000101C 66FE            	   952:             bne.s *               * branch if Z clear
00:0000101E 0C2000FE        	   953:             cmpi.b #$FE,-(a0)
00:00001022 66FE            	   954:             bne.s *               * branch if Z clear
00:00001024 4A20            	   955:             cmpi.b #$00,-(a0)
00:00001026 66FE            	   956:             bne.s *               * branch if Z clear
                            	   957: 
                            	   958: *             EA = n(An)  - BYTE only
00:00001028 307C0100        	   959:             move.l #$00000100,a0      * point to memory to address
00:0000102C 10FC0001        	   960:             move.b #$01,(a0)+         * populate test data
00:00001030 10FC00FC        	   961:             move.b #$FC,(a0)+         * populate test data
00:00001034 10FC0080        	   962:             move.b #$80,(a0)+         * populate test data
00:00001038 307C0100        	   963:             move.l #$00000100,a0      * point to memory to address
00:0000103C 0B50            	   964:             bchg.b d5,0(a0)
00:0000103E 67FE            	   965:             beq.s *               * branch if Z set
00:00001040 0D680001        	   966:             bchg.b d6,1(a0)           *
00:00001044 66FE            	   967:             bne.s *               * branch if Z clear
00:00001046 0F680002        	   968:             bchg.b d7,2(a0)           *
00:0000104A 67FE            	   969:             beq.s *               * branch if Z set
00:0000104C 307C0100        	   970:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001050 4A18            	   971:             cmpi.b #$00,(a0)+
00:00001052 66FE            	   972:             bne.s *               * branch if Z clear
00:00001054 0C1800FE        	   973:             cmpi.b #$FE,(a0)+
00:00001058 66FE            	   974:             bne.s *               * branch if Z clear
00:0000105A 4A18            	   975:             cmpi.b #$00,(a0)+
00:0000105C 66FE            	   976:             bne.s *               * branch if Z clear
                            	   977: 
                            	   978: *             EA = n(An,R.W)  - BYTE only
00:0000105E 307C0100        	   979:             move.l #$00000100,a0      * point to memory to address
00:00001062 93C9            	   980:             move.l #$00000000,a1      * point to memory to address
00:00001064 347C0001        	   981:             move.l #$00000001,a2      * point to memory to address
00:00001068 7000            	   982:             moveq  #$00000000,d0      * point to memory to address
00:0000106A 7201            	   983:             moveq  #$00000001,d1      * point to memory to address
00:0000106C 0B700000        	   984:             bchg.b d5,0(a0,d0.w)
00:00001070 66FE            	   985:             bne.s *               * branch if Z clear
00:00001072 0D701000        	   986:             bchg.b d6,0(a0,d1.w)      *
00:00001076 67FE            	   987:             beq.s *               * branch if Z set
00:00001078 0F701001        	   988:             bchg.b d7,1(a0,d1.w)      *
00:0000107C 66FE            	   989:             bne.s *               * branch if Z clear
                            	   990: *             EA = n(An,R.L)  - BYTE only
00:0000107E 0B700800        	   991:             bchg.b d5,0(a0,d0.l)
00:00001082 67FE            	   992:             beq.s *               * branch if Z set
00:00001084 0D701800        	   993:             bchg.b d6,0(a0,d1.l)      *
00:00001088 66FE            	   994:             bne.s *               * branch if Z clear
00:0000108A 0F701801        	   995:             bchg.b d7,1(a0,d1.l)      *
00:0000108E 67FE            	   996:             beq.s *               * branch if Z set
                            	   997: *             EA = n(An,A.W)  - BYTE only
00:00001090 0B709000        	   998:             bchg.b d5,0(a0,a1.w)
00:00001094 66FE            	   999:             bne.s *               * branch if Z clear
00:00001096 0D70A000        	  1000:             bchg.b d6,0(a0,a2.w)      *
00:0000109A 67FE            	  1001:             beq.s *               * branch if Z set
00:0000109C 0F70A001        	  1002:             bchg.b d7,1(a0,a2.w)      *
00:000010A0 66FE            	  1003:             bne.s *               * branch if Z clear
                            	  1004: *             EA = n(An,A.L)  - BYTE only
00:000010A2 0B709800        	  1005:             bchg.b d5,0(a0,a1.l)
00:000010A6 67FE            	  1006:             beq.s *               * branch if Z set
00:000010A8 0D70A800        	  1007:             bchg.b d6,0(a0,a2.l)      *
00:000010AC 66FE            	  1008:             bne.s *               * branch if Z clear
00:000010AE 0F70A801        	  1009:             bchg.b d7,1(a0,a2.l)      *
00:000010B2 67FE            	  1010:             beq.s *               * branch if Z set
00:000010B4 4A18            	  1011:             cmpi.b #$00,(a0)+
00:000010B6 66FE            	  1012:             bne.s *               * branch if Z clear
                            	  1013: 
                            	  1014: *             EA = x.W  - BYTE only
00:000010B8 0B780100        	  1015:             bchg.b d5,$0100
00:000010BC 66FE            	  1016:             bne.s *               * branch if Z clear
00:000010BE 0D780101        	  1017:             bchg.b d6,$0101           *
00:000010C2 67FE            	  1018:             beq.s *               * branch if Z set
00:000010C4 0F780102        	  1019:             bchg.b d7,$0102           *
00:000010C8 66FE            	  1020:             bne.s *               * branch if Z clear
00:000010CA 0C1800FC        	  1021:             cmpi.b #$FC,(a0)+
00:000010CE 66FE            	  1022:             bne.s *               * branch if Z clear
                            	  1023: 
                            	  1024: *             EA = x.L  - BYTE only
00:000010D0 207C0000F100    	  1025:             move.l #$F100,a0      * point to memory to address 0x100
00:000010D6 10FC0001        	  1026:             move.b #$01,(a0)+         * populate test data
00:000010DA 10FC00FC        	  1027:             move.b #$FC,(a0)+         * populate test data
00:000010DE 10FC0080        	  1028:             move.b #$80,(a0)+         * populate test data
00:000010E2 0B790000F100    	  1029:             bchg.b d5,$F100
00:000010E8 67FE            	  1030:             beq.s *               * branch if Z set
00:000010EA 0D790000F101    	  1031:             bchg.b d6,$F101       *
00:000010F0 66FE            	  1032:             bne.s *               * branch if Z clear
00:000010F2 0F790000F102    	  1033:             bchg.b d7,$F102       *
00:000010F8 67FE            	  1034:             beq.s *               * branch if Z set
00:000010FA 207C0000F101    	  1035:             move.l #$F101,a0      * point to memory to address 0x100
00:00001100 0C1000FE        	  1036:             cmpi.b #$FE,(a0)
00:00001104 66FE            	  1037:             bne.s *               * branch if Z clear
                            	  1038: 
                            	  1039: 
00:00001106 4E75            	  1040:     rts
                            	  1041: 
                            	  1042: *-----------------------------------------------------------
                            	  1043: *-----------------------------------------------------------
                            	  1044: * OPCODE : BCLR
                            	  1045: *-----------------------------------------------------------
                            	  1046: *-----------------------------------------------------------
                            	  1047: op_BCLR:
                            	  1048: 
                            	  1049: 
                            	  1050: *  Bit Number.s Static
                            	  1051: 
                            	  1052: *             EA = Dn  - LONG only
00:00001108 203CFF0000FF    	  1053:             move.l #$FF0000FF,d0      * populate test data
00:0000110E 08800000        	  1054:             bclr.l #0,d0
00:00001112 67FE            	  1055:             beq.s *               * branch if Z set
00:00001114 08800001        	  1056:             bclr.l #1,d0              *
00:00001118 67FE            	  1057:             beq.s *               * branch if Z set
00:0000111A 0880000F        	  1058:             bclr.l #15,d0             *
00:0000111E 66FE            	  1059:             bne.s *               * branch if Z clear
00:00001120 0880001F        	  1060:             bclr.l #31,d0             *
00:00001124 67FE            	  1061:             beq.s *               * branch if Z set
00:00001126 0C807F0000FC    	  1062:             cmpi.l #$7F0000FC,d0
00:0000112C 66FE            	  1063:             bne.s *               * branch if Z clear
                            	  1064: 
                            	  1065: 
                            	  1066: *             EA = (An)  - BYTE only
00:0000112E 307C0100        	  1067:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001132 10BC000F        	  1068:             move.b #$0F,(a0)          * populate test data
00:00001136 08900000        	  1069:             bclr.b #0,(a0)
00:0000113A 67FE            	  1070:             beq.s *               * branch if Z set
00:0000113C 08900007        	  1071:             bclr.b #7,(a0)            *
00:00001140 66FE            	  1072:             bne.s *               * branch if Z clear
00:00001142 0C10000E        	  1073:             cmpi.b #$0E,(a0)
00:00001146 66FE            	  1074:             bne.s *               * branch if Z clear
                            	  1075: 
                            	  1076: *             EA = (An)+  - BYTE only
00:00001148 307C0100        	  1077:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000114C 10FC0001        	  1078:             move.b #$01,(a0)+         * populate test data
00:00001150 4218            	  1079:             move.b #$00,(a0)+         * populate test data
00:00001152 307C0100        	  1080:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001156 08980000        	  1081:             bclr.b #0,(a0)+
00:0000115A 67FE            	  1082:             beq.s *               * branch if Z set
00:0000115C 08980001        	  1083:             bclr.b #1,(a0)+           *
00:00001160 66FE            	  1084:             bne.s *               * branch if Z clear
00:00001162 307C0100        	  1085:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001166 4A18            	  1086:             cmpi.b #$00,(a0)+
00:00001168 66FE            	  1087:             bne.s *               * branch if Z clear
00:0000116A 4A18            	  1088:             cmpi.b #$00,(a0)+
00:0000116C 66FE            	  1089:             bne.s *               * branch if Z clear
                            	  1090: 
                            	  1091: 
                            	  1092: *             EA = -(An)  - BYTE only
00:0000116E 307C0100        	  1093:             move.l #$00000100,a0      * point to memory to address
00:00001172 10FC0001        	  1094:             move.b #$01,(a0)+         * populate test data
00:00001176 10FC0080        	  1095:             move.b #$80,(a0)+         * populate test data
00:0000117A 08A00007        	  1096:             bclr.b #7,-(a0)
00:0000117E 67FE            	  1097:             beq.s *               * branch if Z set
00:00001180 08A00000        	  1098:             bclr.b #0,-(a0)           *
00:00001184 67FE            	  1099:             beq.s *               * branch if Z set
00:00001186 307C0102        	  1100:             move.l #$00000102,a0      * point to memory to address 0x100
00:0000118A 4A20            	  1101:             cmpi.b #$00,-(a0)
00:0000118C 66FE            	  1102:             bne.s *               * branch if Z clear
00:0000118E 4A20            	  1103:             cmpi.b #$00,-(a0)
00:00001190 66FE            	  1104:             bne.s *               * branch if Z clear
                            	  1105: 
                            	  1106: 
                            	  1107: *             EA = n(An)  - BYTE only
00:00001192 307C0100        	  1108:             move.l #$00000100,a0      * point to memory to address
00:00001196 10FC00FF        	  1109:             move.b #$FF,(a0)+         * populate test data
00:0000119A 10FC00FF        	  1110:             move.b #$FF,(a0)+         * populate test data
00:0000119E 307C0100        	  1111:             move.l #$00000100,a0      * point to memory to address
00:000011A2 08900000        	  1112:             bclr.b #0,0(a0)
00:000011A6 67FE            	  1113:             beq.s *               * branch if Z set
00:000011A8 08A800040001    	  1114:             bclr.b #4,1(a0)           *
00:000011AE 67FE            	  1115:             beq.s *               * branch if Z set
00:000011B0 307C0100        	  1116:             move.l #$00000100,a0      * point to memory to address 0x100
00:000011B4 0C1800FE        	  1117:             cmpi.b #$FE,(a0)+
00:000011B8 66FE            	  1118:             bne.s *               * branch if Z clear
00:000011BA 0C1800EF        	  1119:             cmpi.b #$EF,(a0)+
00:000011BE 66FE            	  1120:             bne.s *               * branch if Z clear
                            	  1121: 
                            	  1122: 
                            	  1123: *             EA = n(An,D.W)  - BYTE only
00:000011C0 307C0100        	  1124:             move.l #$00000100,a0      * point to memory to address
00:000011C4 93C9            	  1125:             move.l #$00000000,a1      * point to memory to address
00:000011C6 347C0001        	  1126:             move.l #$00000001,a2      * point to memory to address
00:000011CA 7000            	  1127:             moveq  #$00000000,d0      * point to memory to address
00:000011CC 7201            	  1128:             moveq  #$00000001,d1      * point to memory to address
00:000011CE 10FC00FF        	  1129:             move.b #$FF,(a0)+         * populate test data
00:000011D2 10FC00FF        	  1130:             move.b #$FF,(a0)+         * populate test data
00:000011D6 307C0100        	  1131:             move.l #$00000100,a0      * point to memory to address
00:000011DA 08B000000000    	  1132:             bclr.b #0,0(a0,d0.w)
00:000011E0 67FE            	  1133:             beq.s *               * branch if Z set
00:000011E2 08B000011000    	  1134:             bclr.b #1,0(a0,d1.w)      *
00:000011E8 67FE            	  1135:             beq.s *               * branch if Z set
00:000011EA 08B000021001    	  1136:             bclr.b #2,1(a0,d1.w)      *
00:000011F0 66FE            	  1137:             bne.s *               * branch if Z clear
                            	  1138: *             EA = n(An,D.L)  - BYTE only
00:000011F2 08B000030800    	  1139:             bclr.b #3,0(a0,d0.l)
00:000011F8 67FE            	  1140:             beq.s *               * branch if Z set
00:000011FA 08B000041800    	  1141:             bclr.b #4,0(a0,d1.l)      *
00:00001200 67FE            	  1142:             beq.s *               * branch if Z set
00:00001202 08B000051801    	  1143:             bclr.b #5,1(a0,d1.l)      *
00:00001208 66FE            	  1144:             bne.s *               * branch if Z clear
                            	  1145: *             EA = n(An,A.W)  - BYTE only
00:0000120A 08B000069000    	  1146:             bclr.b #6,0(a0,a1.w)
00:00001210 67FE            	  1147:             beq.s *               * branch if Z set
00:00001212 08B00001A000    	  1148:             bclr.b #1,0(a0,a2.w)      *
00:00001218 66FE            	  1149:             bne.s *               * branch if Z clear
00:0000121A 08B00007A001    	  1150:             bclr.b #7,1(a0,a2.w)      *
00:00001220 67FE            	  1151:             beq.s *               * branch if Z set
                            	  1152: *             EA = n(An,A.L)  - BYTE only
00:00001222 08B000009800    	  1153:             bclr.b #0,0(a0,a1.l)
00:00001228 66FE            	  1154:             bne.s *               * branch if Z clear
00:0000122A 08B00000A800    	  1155:             bclr.b #0,0(a0,a2.l)      *
00:00001230 67FE            	  1156:             beq.s *               * branch if Z set
00:00001232 08B00001A801    	  1157:             bclr.b #1,1(a0,a2.l)      *
00:00001238 66FE            	  1158:             bne.s *               * branch if Z clear
00:0000123A 307C0100        	  1159:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000123E 0C1800B6        	  1160:             cmpi.b #$B6,(a0)+
00:00001242 66FE            	  1161:             bne.s *               * branch if Z clear
00:00001244 0C1800EC        	  1162:             cmpi.b #$EC,(a0)+
00:00001248 66FE            	  1163:             bne.s *               * branch if Z clear
00:0000124A 0C180059        	  1164:             cmpi.b #$59,(a0)+
00:0000124E 67FE            	  1165:             beq.s *               * branch if Z set
                            	  1166: 
                            	  1167: 
                            	  1168: *             EA = x.W  - BYTE only
00:00001250 307C0100        	  1169:             move.l #$00000100,a0      * point to memory to address
00:00001254 10FC00FF        	  1170:             move.b #$FF,(a0)+         * populate test data
00:00001258 08B800000100    	  1171:             bclr.b #0,$0100
00:0000125E 67FE            	  1172:             beq.s *               * branch if Z set
00:00001260 08B800010100    	  1173:             bclr.b #1,$0100           *
00:00001266 67FE            	  1174:             beq.s *               * branch if Z set
00:00001268 307C0100        	  1175:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000126C 0C1800FC        	  1176:             cmpi.b #$FC,(a0)+
00:00001270 66FE            	  1177:             bne.s *               * branch if Z clear
                            	  1178: 
                            	  1179: 
                            	  1180: *             EA = x.L  - BYTE only
00:00001272 207C0000F100    	  1181:             move.l #$F100,a0      * point to memory to address 0x100
00:00001278 10BC00FF        	  1182:             move.b #$FF,(a0)          * populate test data
00:0000127C 08B900000000F100	  1183:             bclr.b #0,$F100
00:00001284 67FE            	  1184:             beq.s *               * branch if Z set
00:00001286 08B900010000F100	  1185:             bclr.b #1,$F100       *
00:0000128E 67FE            	  1186:             beq.s *               * branch if Z set
00:00001290 08B900020000F100	  1187:             bclr.b #2,$F100       *
00:00001298 67FE            	  1188:             beq.s *               * branch if Z set
00:0000129A 207C0000F100    	  1189:             move.l #$F100,a0      * point to memory to address 0x100
00:000012A0 0C1800F8        	  1190:             cmpi.b #$F8,(a0)+
00:000012A4 66FE            	  1191:             bne.s *               * branch if Z clear
                            	  1192: 
                            	  1193: 
                            	  1194: * Bit Number.s Dynamic
                            	  1195: 
                            	  1196: *             EA = Dn  - LONG only
00:000012A6 203CFF00FF00    	  1197:             move.l #$FF00FF00,d0      * populate test data
00:000012AC 7A00            	  1198:             move.l #0,d5              * populate bit.s number to test
00:000012AE 7C01            	  1199:             move.l #1,d6              * populate bit.s number to test
00:000012B0 7E1F            	  1200:             move.l #31,d7              * populate bit.s number to test
                            	  1201: 
00:000012B2 0B80            	  1202:             bclr.l d5,d0
00:000012B4 66FE            	  1203:             bne.s *               * branch if Z clear
00:000012B6 0D80            	  1204:             bclr.l d6,d0              *
00:000012B8 66FE            	  1205:             bne.s *               * branch if Z clear
00:000012BA 0F80            	  1206:             bclr.l d7,d0             *
00:000012BC 67FE            	  1207:             beq.s *               * branch if Z set
00:000012BE 0C807F00FF00    	  1208:             cmpi.l #$7F00FF00,d0
00:000012C4 66FE            	  1209:             bne.s *               * branch if Z clear
                            	  1210: 
                            	  1211: 
                            	  1212: *             EA = (An)  - BYTE only
00:000012C6 7A00            	  1213:             move.l #0,d5              * populate bit.s number to test
00:000012C8 7C01            	  1214:             move.l #1,d6              * populate bit.s number to test
00:000012CA 7E07            	  1215:             move.l #7,d7              * populate bit.s number to test
00:000012CC 307C0100        	  1216:             move.l #$00000100,a0      * point to memory to address 0x100
00:000012D0 10BC0081        	  1217:             move.b #$81,(a0)          * populate test data
00:000012D4 0B90            	  1218:             bclr.b d5,(a0)
00:000012D6 67FE            	  1219:             beq.s *               * branch if Z set
00:000012D8 0D90            	  1220:             bclr.b d6,(a0)            *
00:000012DA 66FE            	  1221:             bne.s *               * branch if Z clear
00:000012DC 0F90            	  1222:             bclr.b d7,(a0)            *
00:000012DE 67FE            	  1223:             beq.s *               * branch if Z set
00:000012E0 4A10            	  1224:             cmpi.b #$00,(a0)
00:000012E2 66FE            	  1225:             bne.s *               * branch if Z clear
                            	  1226: 
                            	  1227: 
                            	  1228: *             EA = (An)+  - BYTE only
00:000012E4 307C0100        	  1229:             move.l #$00000100,a0      * point to memory to address 0x100
00:000012E8 10FC0001        	  1230:             move.b #$01,(a0)+         * populate test data
00:000012EC 10FC00FC        	  1231:             move.b #$FC,(a0)+         * populate test data
00:000012F0 10FC0080        	  1232:             move.b #$80,(a0)+         * populate test data
00:000012F4 307C0100        	  1233:             move.l #$00000100,a0      * point to memory to address 0x100
00:000012F8 0B98            	  1234:             bclr.b d5,(a0)+
00:000012FA 67FE            	  1235:             beq.s *               * branch if Z set
00:000012FC 0D98            	  1236:             bclr.b d6,(a0)+           *
00:000012FE 66FE            	  1237:             bne.s *               * branch if Z clear
00:00001300 0F98            	  1238:             bclr.b d7,(a0)+           *
00:00001302 67FE            	  1239:             beq.s *               * branch if Z set
00:00001304 307C0100        	  1240:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001308 4A18            	  1241:             cmpi.b #$00,(a0)+
00:0000130A 66FE            	  1242:             bne.s *               * branch if Z clear
00:0000130C 0C1800FC        	  1243:             cmpi.b #$FC,(a0)+
00:00001310 66FE            	  1244:             bne.s *               * branch if Z clear
00:00001312 4A18            	  1245:             cmpi.b #$00,(a0)+
00:00001314 66FE            	  1246:             bne.s *               * branch if Z clear
                            	  1247: 
                            	  1248: *             EA = -(An)  - BYTE only
00:00001316 307C0100        	  1249:             move.l #$00000100,a0      * point to memory to address
00:0000131A 10FC0080        	  1250:             move.b #$80,(a0)+         * populate test data
00:0000131E 10FC00FC        	  1251:             move.b #$FC,(a0)+         * populate test data
00:00001322 10FC0001        	  1252:             move.b #$01,(a0)+         * populate test data
00:00001326 307C0103        	  1253:             move.l #$00000103,a0      * point to memory to address
00:0000132A 0BA0            	  1254:             bclr.b d5,-(a0)
00:0000132C 67FE            	  1255:             beq.s *               * branch if Z set
00:0000132E 0DA0            	  1256:             bclr.b d6,-(a0)           *
00:00001330 66FE            	  1257:             bne.s *               * branch if Z clear
00:00001332 0FA0            	  1258:             bclr.b d7,-(a0)           *
00:00001334 67FE            	  1259:             beq.s *               * branch if Z set
00:00001336 307C0103        	  1260:             move.l #$00000103,a0      * point to memory to address 0x100
00:0000133A 4A20            	  1261:             cmpi.b #$00,-(a0)
00:0000133C 66FE            	  1262:             bne.s *               * branch if Z clear
00:0000133E 0C2000FC        	  1263:             cmpi.b #$FC,-(a0)
00:00001342 66FE            	  1264:             bne.s *               * branch if Z clear
00:00001344 4A20            	  1265:             cmpi.b #$00,-(a0)
00:00001346 66FE            	  1266:             bne.s *               * branch if Z clear
                            	  1267: 
                            	  1268: *             EA = n(An)  - BYTE only
00:00001348 307C0100        	  1269:             move.l #$00000100,a0      * point to memory to address
00:0000134C 10FC0001        	  1270:             move.b #$01,(a0)+         * populate test data
00:00001350 10FC00FC        	  1271:             move.b #$FC,(a0)+         * populate test data
00:00001354 10FC0080        	  1272:             move.b #$80,(a0)+         * populate test data
00:00001358 307C0100        	  1273:             move.l #$00000100,a0      * point to memory to address
00:0000135C 0B90            	  1274:             bclr.b d5,0(a0)
00:0000135E 67FE            	  1275:             beq.s *               * branch if Z set
00:00001360 0DA80001        	  1276:             bclr.b d6,1(a0)           *
00:00001364 66FE            	  1277:             bne.s *               * branch if Z clear
00:00001366 0FA80002        	  1278:             bclr.b d7,2(a0)           *
00:0000136A 67FE            	  1279:             beq.s *               * branch if Z set
00:0000136C 307C0100        	  1280:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001370 4A18            	  1281:             cmpi.b #$00,(a0)+
00:00001372 66FE            	  1282:             bne.s *               * branch if Z clear
00:00001374 0C1800FC        	  1283:             cmpi.b #$FC,(a0)+
00:00001378 66FE            	  1284:             bne.s *               * branch if Z clear
00:0000137A 4A18            	  1285:             cmpi.b #$00,(a0)+
00:0000137C 66FE            	  1286:             bne.s *               * branch if Z clear
                            	  1287: 
                            	  1288: *             EA = n(An,R.W)  - BYTE only
00:0000137E 307C0100        	  1289:             move.l #$00000100,a0      * point to memory to address
00:00001382 10FC00FF        	  1290:             move.b #$FF,(a0)+         * populate test data
00:00001386 10FC00FF        	  1291:             move.b #$FF,(a0)+         * populate test data
00:0000138A 10FC00FF        	  1292:             move.b #$FF,(a0)+         * populate test data
00:0000138E 307C0103        	  1293:             move.l #$00000103,a0      * point to memory to address
00:00001392 307C0100        	  1294:             move.l #$00000100,a0      * point to memory to address
00:00001396 93C9            	  1295:             move.l #$00000000,a1      * point to memory to address
00:00001398 347C0001        	  1296:             move.l #$00000001,a2      * point to memory to address
00:0000139C 7000            	  1297:             moveq  #$00000000,d0      * point to memory to address
00:0000139E 7201            	  1298:             moveq  #$00000001,d1      * point to memory to address
00:000013A0 0BB00000        	  1299:             bclr.b d5,0(a0,d0.w)
00:000013A4 67FE            	  1300:             beq.s *               * branch if Z set
00:000013A6 0DB01000        	  1301:             bclr.b d6,0(a0,d1.w)      *
00:000013AA 67FE            	  1302:             beq.s *               * branch if Z set
00:000013AC 0FB01001        	  1303:             bclr.b d7,1(a0,d1.w)      *
00:000013B0 67FE            	  1304:             beq.s *               * branch if Z set
                            	  1305: *             EA = n(An,R.L)  - BYTE only
00:000013B2 0BB00800        	  1306:             bclr.b d5,0(a0,d0.l)
00:000013B6 66FE            	  1307:             bne.s *               * branch if Z clear
00:000013B8 0DB01800        	  1308:             bclr.b d6,0(a0,d1.l)      *
00:000013BC 66FE            	  1309:             bne.s *               * branch if Z clear
00:000013BE 0FB01801        	  1310:             bclr.b d7,1(a0,d1.l)      *
00:000013C2 66FE            	  1311:             bne.s *               * branch if Z clear
                            	  1312: *             EA = n(An,A.W)  - BYTE only
00:000013C4 0BB09000        	  1313:             bclr.b d5,0(a0,a1.w)
00:000013C8 66FE            	  1314:             bne.s *               * branch if Z clear
00:000013CA 0DB0A000        	  1315:             bclr.b d6,0(a0,a2.w)      *
00:000013CE 66FE            	  1316:             bne.s *               * branch if Z clear
00:000013D0 0FB0A001        	  1317:             bclr.b d7,1(a0,a2.w)      *
00:000013D4 66FE            	  1318:             bne.s *               * branch if Z clear
                            	  1319: *             EA = n(An,A.L)  - BYTE only
00:000013D6 0BB09800        	  1320:             bclr.b d5,0(a0,a1.l)
00:000013DA 66FE            	  1321:             bne.s *               * branch if Z clear
00:000013DC 0DB0A800        	  1322:             bclr.b d6,0(a0,a2.l)      *
00:000013E0 66FE            	  1323:             bne.s *               * branch if Z clear
00:000013E2 0FB0A801        	  1324:             bclr.b d7,1(a0,a2.l)      *
00:000013E6 66FE            	  1325:             bne.s *               * branch if Z clear
00:000013E8 307C0100        	  1326:             move.l #$00000100,a0      * point to memory to address
00:000013EC 0C1000FE        	  1327:             cmpi.b #$FE,(a0)
00:000013F0 66FE            	  1328:             bne.s *               * branch if Z clear
                            	  1329: 
                            	  1330: *             EA = x.W  - BYTE only
00:000013F2 307C0100        	  1331:             move.l #$00000100,a0      * point to memory to address
00:000013F6 10FC00FF        	  1332:             move.b #$FF,(a0)+         * populate test data
00:000013FA 10FC00FF        	  1333:             move.b #$FF,(a0)+         * populate test data
00:000013FE 10FC00FF        	  1334:             move.b #$FF,(a0)+         * populate test data
00:00001402 0BB80100        	  1335:             bclr.b d5,$0100
00:00001406 67FE            	  1336:             beq.s *               * branch if Z set
00:00001408 0DB80101        	  1337:             bclr.b d6,$0101           *
00:0000140C 67FE            	  1338:             beq.s *               * branch if Z set
00:0000140E 0FB80102        	  1339:             bclr.b d7,$0102           *
00:00001412 67FE            	  1340:             beq.s *               * branch if Z set
00:00001414 307C0100        	  1341:             move.l #$00000100,a0      * point to memory to address
00:00001418 0C1800FE        	  1342:             cmpi.b #$FE,(a0)+
00:0000141C 66FE            	  1343:             bne.s *               * branch if Z clear
                            	  1344: 
                            	  1345: *             EA = x.L  - BYTE only
00:0000141E 207C0000F100    	  1346:             move.l #$F100,a0      * point to memory to address 0x100
00:00001424 10FC0001        	  1347:             move.b #$01,(a0)+         * populate test data
00:00001428 10FC00FC        	  1348:             move.b #$FC,(a0)+         * populate test data
00:0000142C 10FC0080        	  1349:             move.b #$80,(a0)+         * populate test data
00:00001430 0BB90000F100    	  1350:             bclr.b d5,$F100
00:00001436 67FE            	  1351:             beq.s *               * branch if Z set
00:00001438 0DB90000F101    	  1352:             bclr.b d6,$F101       *
00:0000143E 66FE            	  1353:             bne.s *               * branch if Z clear
00:00001440 0FB90000F102    	  1354:             bclr.b d7,$F102       *
00:00001446 67FE            	  1355:             beq.s *               * branch if Z set
00:00001448 207C0000F101    	  1356:             move.l #$F101,a0      * point to memory to address 0x100
00:0000144E 0C1000FC        	  1357:             cmpi.b #$FC,(a0)
00:00001452 66FE            	  1358:             bne.s *               * branch if Z clear
                            	  1359: 
                            	  1360: 
                            	  1361: 
00:00001454 4E75            	  1362:     rts
                            	  1363: 
                            	  1364: *-----------------------------------------------------------
                            	  1365: *-----------------------------------------------------------
                            	  1366: * OPCODE : BSET
                            	  1367: *-----------------------------------------------------------
                            	  1368: *-----------------------------------------------------------
                            	  1369: op_BSET:
                            	  1370: 
                            	  1371: 
                            	  1372: *  Bit Number.s Static
                            	  1373: 
                            	  1374: *             EA = Dn  - LONG only
00:00001456 7000            	  1375:             moveq  #$00000000,d0      * populate test data
00:00001458 08C00000        	  1376:             bset.l #0,d0
00:0000145C 66FE            	  1377:             bne.s *               * branch if Z clear
00:0000145E 08C00001        	  1378:             bset.l #1,d0              *
00:00001462 66FE            	  1379:             bne.s *               * branch if Z clear
00:00001464 08C0000F        	  1380:             bset.l #15,d0             *
00:00001468 66FE            	  1381:             bne.s *               * branch if Z clear
00:0000146A 08C0001F        	  1382:             bset.l #31,d0             *
00:0000146E 66FE            	  1383:             bne.s *               * branch if Z clear
00:00001470 0C8080008003    	  1384:             cmpi.l #$80008003,d0
00:00001476 66FE            	  1385:             bne.s *               * branch if Z clear
                            	  1386: 
                            	  1387: 
                            	  1388: *             EA = (An)  - BYTE only
00:00001478 307C0100        	  1389:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000147C 4210            	  1390:             move.b #$00,(a0)          * populate test data
00:0000147E 08D00000        	  1391:             bset.b #0,(a0)
00:00001482 66FE            	  1392:             bne.s *               * branch if Z clear
00:00001484 08D00007        	  1393:             bset.b #7,(a0)            *
00:00001488 66FE            	  1394:             bne.s *               * branch if Z clear
00:0000148A 0C100081        	  1395:             cmpi.b #$81,(a0)
00:0000148E 66FE            	  1396:             bne.s *               * branch if Z clear
                            	  1397: 
                            	  1398: *             EA = (An)+  - BYTE only
00:00001490 307C0100        	  1399:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001494 4218            	  1400:             move.b #$00,(a0)+         * populate test data
00:00001496 4218            	  1401:             move.b #$00,(a0)+         * populate test data
00:00001498 307C0100        	  1402:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000149C 08D80000        	  1403:             bset.b #0,(a0)+
00:000014A0 66FE            	  1404:             bne.s *               * branch if Z clear
00:000014A2 08D80001        	  1405:             bset.b #1,(a0)+           *
00:000014A6 66FE            	  1406:             bne.s *               * branch if Z clear
00:000014A8 307C0100        	  1407:             move.l #$00000100,a0      * point to memory to address 0x100
00:000014AC 0C180001        	  1408:             cmpi.b #$01,(a0)+
00:000014B0 66FE            	  1409:             bne.s *               * branch if Z clear
00:000014B2 0C180002        	  1410:             cmpi.b #$02,(a0)+
00:000014B6 66FE            	  1411:             bne.s *               * branch if Z clear
                            	  1412: 
                            	  1413: 
                            	  1414: *             EA = -(An)  - BYTE only
00:000014B8 307C0100        	  1415:             move.l #$00000100,a0      * point to memory to address
00:000014BC 4218            	  1416:             move.b #$00,(a0)+         * populate test data
00:000014BE 4218            	  1417:             move.b #$00,(a0)+         * populate test data
00:000014C0 08E00007        	  1418:             bset.b #7,-(a0)
00:000014C4 66FE            	  1419:             bne.s *               * branch if Z clear
00:000014C6 08E00000        	  1420:             bset.b #0,-(a0)           *
00:000014CA 66FE            	  1421:             bne.s *               * branch if Z clear
00:000014CC 307C0102        	  1422:             move.l #$00000102,a0      * point to memory to address 0x100
00:000014D0 0C200080        	  1423:             cmpi.b #$80,-(a0)
00:000014D4 66FE            	  1424:             bne.s *               * branch if Z clear
00:000014D6 0C200001        	  1425:             cmpi.b #$01,-(a0)
00:000014DA 66FE            	  1426:             bne.s *               * branch if Z clear
                            	  1427: 
                            	  1428: 
                            	  1429: *             EA = n(An)  - BYTE only
00:000014DC 307C0100        	  1430:             move.l #$00000100,a0      * point to memory to address
00:000014E0 4218            	  1431:             move.b #$00,(a0)+         * populate test data
00:000014E2 4218            	  1432:             move.b #$00,(a0)+         * populate test data
00:000014E4 307C0100        	  1433:             move.l #$00000100,a0      * point to memory to address
00:000014E8 08D00000        	  1434:             bset.b #0,0(a0)
00:000014EC 66FE            	  1435:             bne.s *               * branch if Z clear
00:000014EE 08E800040001    	  1436:             bset.b #4,1(a0)           *
00:000014F4 66FE            	  1437:             bne.s *               * branch if Z clear
00:000014F6 307C0100        	  1438:             move.l #$00000100,a0      * point to memory to address 0x100
00:000014FA 0C180001        	  1439:             cmpi.b #$01,(a0)+
00:000014FE 66FE            	  1440:             bne.s *               * branch if Z clear
00:00001500 0C180010        	  1441:             cmpi.b #$10,(a0)+
00:00001504 66FE            	  1442:             bne.s *               * branch if Z clear
                            	  1443: 
                            	  1444: 
                            	  1445: *             EA = n(An,D.W)  - BYTE only
00:00001506 307C0100        	  1446:             move.l #$00000100,a0      * point to memory to address
00:0000150A 93C9            	  1447:             move.l #$00000000,a1      * point to memory to address
00:0000150C 347C0004        	  1448:             move.l #$00000004,a2      * point to memory to address
00:00001510 7000            	  1449:             moveq  #$00000000,d0      * point to memory to address
00:00001512 7201            	  1450:             moveq  #$00000001,d1      * point to memory to address
00:00001514 4218            	  1451:             move.b #$00,(a0)+         * populate test data
00:00001516 4218            	  1452:             move.b #$00,(a0)+         * populate test data
00:00001518 4218            	  1453:             move.b #$00,(a0)+         * populate test data
00:0000151A 4218            	  1454:             move.b #$00,(a0)+         * populate test data
00:0000151C 4218            	  1455:             move.b #$00,(a0)+         * populate test data
00:0000151E 4218            	  1456:             move.b #$00,(a0)+         * populate test data
00:00001520 4218            	  1457:             move.b #$00,(a0)+         * populate test data
00:00001522 4218            	  1458:             move.b #$00,(a0)+         * populate test data
00:00001524 4218            	  1459:             move.b #$00,(a0)+         * populate test data
00:00001526 4218            	  1460:             move.b #$00,(a0)+         * populate test data
00:00001528 307C0100        	  1461:             move.l #$00000100,a0      * point to memory to address
00:0000152C 08F000000000    	  1462:             bset.b #0,0(a0,d0.w)
00:00001532 66FE            	  1463:             bne.s *               * branch if Z clear
00:00001534 08F000011000    	  1464:             bset.b #1,0(a0,d1.w)      *
00:0000153A 66FE            	  1465:             bne.s *               * branch if Z clear
00:0000153C 08F000021001    	  1466:             bset.b #2,1(a0,d1.w)      *
00:00001542 66FE            	  1467:             bne.s *               * branch if Z clear
                            	  1468: *             EA = n(An,D.L)  - BYTE only
00:00001544 08F000030802    	  1469:             bset.b #3,2(a0,d0.l)
00:0000154A 66FE            	  1470:             bne.s *               * branch if Z clear
00:0000154C 08F000041800    	  1471:             bset.b #4,0(a0,d1.l)      *
00:00001552 66FE            	  1472:             bne.s *               * branch if Z clear
00:00001554 08F000051801    	  1473:             bset.b #5,1(a0,d1.l)      *
00:0000155A 66FE            	  1474:             bne.s *               * branch if Z clear
                            	  1475: *             EA = n(An,A.W)  - BYTE only
00:0000155C 08F000069000    	  1476:             bset.b #6,0(a0,a1.w)
00:00001562 66FE            	  1477:             bne.s *               * branch if Z clear
00:00001564 08F00001A000    	  1478:             bset.b #1,0(a0,a2.w)      *
00:0000156A 66FE            	  1479:             bne.s *               * branch if Z clear
00:0000156C 08F00007A001    	  1480:             bset.b #7,1(a0,a2.w)      *
00:00001572 66FE            	  1481:             bne.s *               * branch if Z clear
                            	  1482: *             EA = n(An,A.L)  - BYTE only
00:00001574 08F00000A802    	  1483:             bset.b #0,2(a0,a2.l)
00:0000157A 66FE            	  1484:             bne.s *               * branch if Z clear
00:0000157C 08F00000A803    	  1485:             bset.b #0,3(a0,a2.l)      *
00:00001582 66FE            	  1486:             bne.s *               * branch if Z clear
00:00001584 08F00001A804    	  1487:             bset.b #1,4(a0,a2.l)      *
00:0000158A 66FE            	  1488:             bne.s *               * branch if Z clear
00:0000158C 307C0100        	  1489:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001590 0C9841122C00    	  1490:             cmpi.l #$41122C00,(a0)+
00:00001596 66FE            	  1491:             bne.s *               * branch if Z clear
00:00001598 0C9802800101    	  1492:             cmpi.l #$02800101,(a0)+
00:0000159E 66FE            	  1493:             bne.s *
                            	  1494: 
                            	  1495: 
                            	  1496: 
                            	  1497: *             EA = x.W  - BYTE only
00:000015A0 307C0100        	  1498:             move.l #$00000100,a0      * point to memory to address
00:000015A4 4218            	  1499:             move.b #$00,(a0)+         * populate test data
00:000015A6 08F800000100    	  1500:             bset.b #0,$0100
00:000015AC 66FE            	  1501:             bne.s *               * branch if Z clear
00:000015AE 08F800010100    	  1502:             bset.b #1,$0100           *
00:000015B4 66FE            	  1503:             bne.s *               * branch if Z clear
00:000015B6 307C0100        	  1504:             move.l #$00000100,a0      * point to memory to address 0x100
00:000015BA 0C180003        	  1505:             cmpi.b #$03,(a0)+
00:000015BE 66FE            	  1506:             bne.s *
                            	  1507: 
                            	  1508: 
                            	  1509: *             EA = x.L  - BYTE only
00:000015C0 207C0000F100    	  1510:             move.l #$F100,a0      * point to memory to address 0x100
00:000015C6 4210            	  1511:             move.b #$00,(a0)          * populate test data
00:000015C8 08F900000000F100	  1512:             bset.b #0,$F100
00:000015D0 66FE            	  1513:             bne.s *               * branch if Z clear
00:000015D2 08F900010000F100	  1514:             bset.b #1,$F100       *
00:000015DA 66FE            	  1515:             bne.s *               * branch if Z clear
00:000015DC 08F900020000F100	  1516:             bset.b #2,$F100       *
00:000015E4 66FE            	  1517:             bne.s *               * branch if Z clear
00:000015E6 207C0000F100    	  1518:             move.l #$F100,a0      * point to memory to address 0x100
00:000015EC 0C180007        	  1519:             cmpi.b #$07,(a0)+
00:000015F0 66FE            	  1520:             bne.s *
                            	  1521: 
                            	  1522: 
                            	  1523: * Bit Number.s Dynamic
                            	  1524: 
                            	  1525: *             EA = Dn  - LONG only
00:000015F2 7000            	  1526:             moveq  #$00000000,d0      * populate test data
00:000015F4 7A00            	  1527:             move.l #0,d5              * populate bit.s number to test
00:000015F6 7C01            	  1528:             move.l #1,d6              * populate bit.s number to test
00:000015F8 7E1F            	  1529:             move.l #31,d7              * populate bit.s number to test
                            	  1530: 
00:000015FA 0BC0            	  1531:             bset.l d5,d0
00:000015FC 66FE            	  1532:             bne.s *               * branch if Z clear
00:000015FE 0DC0            	  1533:             bset.l d6,d0              *
00:00001600 66FE            	  1534:             bne.s *               * branch if Z clear
00:00001602 0FC0            	  1535:             bset.l d7,d0             *
00:00001604 66FE            	  1536:             bne.s *               * branch if Z clear
00:00001606 0C8080000003    	  1537:             cmpi.l #$80000003,d0
00:0000160C 66FE            	  1538:             bne.s *               * branch if Z clear
                            	  1539: 
                            	  1540: 
                            	  1541: *             EA = (An)  - BYTE only
00:0000160E 7A00            	  1542:             move.l #0,d5              * populate bit.s number to test
00:00001610 7C01            	  1543:             move.l #1,d6              * populate bit.s number to test
00:00001612 7E07            	  1544:             move.l #7,d7              * populate bit.s number to test
00:00001614 307C0100        	  1545:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001618 4210            	  1546:             move.b #$00,(a0)          * populate test data
00:0000161A 0BD0            	  1547:             bset.b d5,(a0)
00:0000161C 66FE            	  1548:             bne.s *               * branch if Z clear
00:0000161E 0DD0            	  1549:             bset.b d6,(a0)            *
00:00001620 66FE            	  1550:             bne.s *               * branch if Z clear
00:00001622 0FD0            	  1551:             bset.b d7,(a0)            *
00:00001624 66FE            	  1552:             bne.s *               * branch if Z clear
00:00001626 0C100083        	  1553:             cmpi.b #$83,(a0)
00:0000162A 66FE            	  1554:             bne.s *               * branch if Z clear
                            	  1555: 
                            	  1556: 
                            	  1557: *             EA = (An)+  - BYTE only
00:0000162C 307C0100        	  1558:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001630 4218            	  1559:             move.b #$00,(a0)+         * populate test data
00:00001632 4218            	  1560:             move.b #$00,(a0)+         * populate test data
00:00001634 4218            	  1561:             move.b #$00,(a0)+         * populate test data
00:00001636 307C0100        	  1562:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000163A 0BD8            	  1563:             bset.b d5,(a0)+
00:0000163C 66FE            	  1564:             bne.s *               * branch if Z clear
00:0000163E 0DD8            	  1565:             bset.b d6,(a0)+           *
00:00001640 66FE            	  1566:             bne.s *               * branch if Z clear
00:00001642 0FD8            	  1567:             bset.b d7,(a0)+           *
00:00001644 66FE            	  1568:             bne.s *               * branch if Z clear
00:00001646 307C0100        	  1569:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000164A 0C180001        	  1570:             cmpi.b #$01,(a0)+
00:0000164E 66FE            	  1571:             bne.s *               * branch if Z clear
00:00001650 0C180002        	  1572:             cmpi.b #$02,(a0)+
00:00001654 66FE            	  1573:             bne.s *               * branch if Z clear
00:00001656 0C180080        	  1574:             cmpi.b #$80,(a0)+
00:0000165A 66FE            	  1575:             bne.s *               * branch if Z clear
                            	  1576: 
                            	  1577: *             EA = -(An)  - BYTE only
00:0000165C 307C0100        	  1578:             move.l #$00000100,a0      * point to memory to address
00:00001660 4218            	  1579:             move.b #$00,(a0)+         * populate test data
00:00001662 4218            	  1580:             move.b #$00,(a0)+         * populate test data
00:00001664 4218            	  1581:             move.b #$00,(a0)+         * populate test data
00:00001666 307C0103        	  1582:             move.l #$00000103,a0      * point to memory to address
00:0000166A 0BE0            	  1583:             bset.b d5,-(a0)
00:0000166C 66FE            	  1584:             bne.s *               * branch if Z clear
00:0000166E 0DE0            	  1585:             bset.b d6,-(a0)           *
00:00001670 66FE            	  1586:             bne.s *               * branch if Z clear
00:00001672 0FE0            	  1587:             bset.b d7,-(a0)           *
00:00001674 66FE            	  1588:             bne.s *               * branch if Z clear
00:00001676 307C0103        	  1589:             move.l #$00000103,a0      * point to memory to address 0x100
00:0000167A 0C200001        	  1590:             cmpi.b #$01,-(a0)
00:0000167E 66FE            	  1591:             bne.s *               * branch if Z clear
00:00001680 0C200002        	  1592:             cmpi.b #$02,-(a0)
00:00001684 66FE            	  1593:             bne.s *               * branch if Z clear
00:00001686 0C200080        	  1594:             cmpi.b #$80,-(a0)
00:0000168A 66FE            	  1595:             bne.s *               * branch if Z clear
                            	  1596: 
                            	  1597: *             EA = n(An)  - BYTE only
00:0000168C 307C0100        	  1598:             move.l #$00000100,a0      * point to memory to address
00:00001690 4218            	  1599:             move.b #$00,(a0)+         * populate test data
00:00001692 4218            	  1600:             move.b #$00,(a0)+         * populate test data
00:00001694 4218            	  1601:             move.b #$00,(a0)+         * populate test data
00:00001696 307C0100        	  1602:             move.l #$00000100,a0      * point to memory to address
00:0000169A 0BD0            	  1603:             bset.b d5,0(a0)
00:0000169C 66FE            	  1604:             bne.s *               * branch if Z clear
00:0000169E 0DE80001        	  1605:             bset.b d6,1(a0)           *
00:000016A2 66FE            	  1606:             bne.s *               * branch if Z clear
00:000016A4 0FE80002        	  1607:             bset.b d7,2(a0)           *
00:000016A8 66FE            	  1608:             bne.s *               * branch if Z clear
00:000016AA 307C0100        	  1609:             move.l #$00000100,a0      * point to memory to address 0x100
00:000016AE 0C180001        	  1610:             cmpi.b #$01,(a0)+
00:000016B2 66FE            	  1611:             bne.s *               * branch if Z clear
00:000016B4 0C180002        	  1612:             cmpi.b #$02,(a0)+
00:000016B8 66FE            	  1613:             bne.s *               * branch if Z clear
00:000016BA 0C180080        	  1614:             cmpi.b #$80,(a0)+
00:000016BE 66FE            	  1615:             bne.s *               * branch if Z clear
                            	  1616: 
                            	  1617: *             EA = n(An,R.W)  - BYTE only
00:000016C0 307C0100        	  1618:             move.l #$00000100,a0      * point to memory to address
00:000016C4 4218            	  1619:             move.b #$00,(a0)+         * populate test data
00:000016C6 4218            	  1620:             move.b #$00,(a0)+         * populate test data
00:000016C8 4218            	  1621:             move.b #$00,(a0)+         * populate test data
00:000016CA 4218            	  1622:             move.b #$00,(a0)+         * populate test data
00:000016CC 4218            	  1623:             move.b #$00,(a0)+         * populate test data
00:000016CE 4218            	  1624:             move.b #$00,(a0)+         * populate test data
00:000016D0 4218            	  1625:             move.b #$00,(a0)+         * populate test data
00:000016D2 4218            	  1626:             move.b #$00,(a0)+         * populate test data
00:000016D4 4218            	  1627:             move.b #$00,(a0)+         * populate test data
00:000016D6 4218            	  1628:             move.b #$00,(a0)+         * populate test data
00:000016D8 4218            	  1629:             move.b #$00,(a0)+         * populate test data
00:000016DA 4218            	  1630:             move.b #$00,(a0)+         * populate test data
00:000016DC 307C0100        	  1631:             move.l #$00000100,a0      * point to memory to address
00:000016E0 93C9            	  1632:             move.l #$00000000,a1      * point to memory to address
00:000016E2 347C0001        	  1633:             move.l #$00000001,a2      * point to memory to address
00:000016E6 7000            	  1634:             moveq  #$00000000,d0      * point to memory to address
00:000016E8 7201            	  1635:             moveq  #$00000001,d1      * point to memory to address
00:000016EA 0BF00000        	  1636:             bset.b d5,0(a0,d0.w)
00:000016EE 66FE            	  1637:             bne.s *               * branch if Z clear
00:000016F0 0DF01000        	  1638:             bset.b d6,0(a0,d1.w)      *
00:000016F4 66FE            	  1639:             bne.s *               * branch if Z clear
00:000016F6 0FF01001        	  1640:             bset.b d7,1(a0,d1.w)      *
00:000016FA 66FE            	  1641:             bne.s *               * branch if Z clear
                            	  1642: *             EA = n(An,R.L)  - BYTE only
00:000016FC 0BF00802        	  1643:             bset.b d5,2(a0,d0.l)
00:00001700 66FE            	  1644:             bne.s *               * branch if Z clear
00:00001702 0DF01803        	  1645:             bset.b d6,3(a0,d1.l)      *
00:00001706 66FE            	  1646:             bne.s *               * branch if Z clear
00:00001708 0FF01804        	  1647:             bset.b d7,4(a0,d1.l)      *
00:0000170C 66FE            	  1648:             bne.s *               * branch if Z clear
                            	  1649: *             EA = n(An,A.W)  - BYTE only
00:0000170E 0BF09005        	  1650:             bset.b d5,5(a0,a1.w)
00:00001712 66FE            	  1651:             bne.s *               * branch if Z clear
00:00001714 0DF0A006        	  1652:             bset.b d6,6(a0,a2.w)      *
00:00001718 66FE            	  1653:             bne.s *               * branch if Z clear
00:0000171A 0FF0A007        	  1654:             bset.b d7,7(a0,a2.w)      *
00:0000171E 66FE            	  1655:             bne.s *               * branch if Z clear
                            	  1656: *             EA = n(An,A.L)  - BYTE only
00:00001720 0BF09808        	  1657:             bset.b d5,8(a0,a1.l)
00:00001724 66FE            	  1658:             bne.s *               * branch if Z clear
00:00001726 0DF0A809        	  1659:             bset.b d6,9(a0,a2.l)      *
00:0000172A 66FE            	  1660:             bne.s *               * branch if Z clear
00:0000172C 0FF0A80A        	  1661:             bset.b d7,10(a0,a2.l)      *
00:00001730 66FE            	  1662:             bne.s *               * branch if Z clear
00:00001732 307C0100        	  1663:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001736 0C9801028100    	  1664:             cmpi.l #$01028100,(a0)+
00:0000173C 66FE            	  1665:             bne.s *               * branch if Z clear
00:0000173E 0C9802810002    	  1666:             cmpi.l #$02810002,(a0)+
00:00001744 66FE            	  1667:             bne.s *
                            	  1668: 
                            	  1669: 
                            	  1670: *             EA = x.W  - BYTE only
00:00001746 307C0100        	  1671:             move.l #$00000100,a0      * point to memory to address
00:0000174A 4218            	  1672:             move.b #$00,(a0)+         * populate test data
00:0000174C 4218            	  1673:             move.b #$00,(a0)+         * populate test data
00:0000174E 4218            	  1674:             move.b #$00,(a0)+         * populate test data
00:00001750 0BF80100        	  1675:             bset.b d5,$0100
00:00001754 66FE            	  1676:             bne.s *               * branch if Z clear
00:00001756 0DF80100        	  1677:             bset.b d6,$0100           *
00:0000175A 66FE            	  1678:             bne.s *               * branch if Z clear
00:0000175C 0FF80100        	  1679:             bset.b d7,$0100           *
00:00001760 66FE            	  1680:             bne.s *               * branch if Z clear
00:00001762 307C0100        	  1681:             move.l #$00000100,a0      * point to memory to address
00:00001766 0C180083        	  1682:             cmpi.b #$83,(a0)+
00:0000176A 66FE            	  1683:             bne.s *               * branch if Z clear
                            	  1684: 
                            	  1685: *             EA = x.L  - BYTE only
00:0000176C 207C0000F100    	  1686:             move.l #$F100,a0      * point to memory to address 0x100
00:00001772 4218            	  1687:             move.b #$00,(a0)+         * populate test data
00:00001774 4218            	  1688:             move.b #$00,(a0)+         * populate test data
00:00001776 4218            	  1689:             move.b #$00,(a0)+         * populate test data
00:00001778 0BF90000F100    	  1690:             bset.b d5,$F100
00:0000177E 66FE            	  1691:             bne.s *               * branch if Z clear
00:00001780 0DF90000F100    	  1692:             bset.b d6,$F100       *
00:00001786 66FE            	  1693:             bne.s *               * branch if Z clear
00:00001788 0FF90000F100    	  1694:             bset.b d7,$F100       *
00:0000178E 66FE            	  1695:             bne.s *               * branch if Z clear
00:00001790 207C0000F100    	  1696:             move.l #$F100,a0      * point to memory to address 0x100
00:00001796 0C100083        	  1697:             cmpi.b #$83,(a0)
00:0000179A 66FE            	  1698:             bne.s *               * branch if Z clear
                            	  1699: 
                            	  1700: 
00:0000179C 4E75            	  1701:     rts
                            	  1702: 
                            	  1703: *-----------------------------------------------------------
                            	  1704: *-----------------------------------------------------------
                            	  1705: * OPCODE : MOVEP
                            	  1706: *-----------------------------------------------------------
                            	  1707: *-----------------------------------------------------------
                            	  1708: op_MOVEP:
                            	  1709: 
                            	  1710: * Dn --> x(An)
00:0000179E 307C0100        	  1711:             move.l #$00000100,a0
00:000017A2 203C12345678    	  1712:             move.l #$12345678,d0
00:000017A8 223CAABBCCDD    	  1713:             move.l #$AABBCCDD,d1
00:000017AE 4290            	  1714:             move.l #0,(a0)
00:000017B0 42A80004        	  1715:             move.l #0,4(a0)
                            	  1716: 
00:000017B4 01880000        	  1717:             movep.w d0,0(a0)      * even offset
00:000017B8 03880001        	  1718:             movep.w d1,1(a0)      * odd offset
                            	  1719: 
00:000017BC 01C80004        	  1720:             movep.l d0,4(a0)      * even offset
00:000017C0 03C80005        	  1721:             movep.l d1,5(a0)      * odd offset
                            	  1722: 
00:000017C4 0C9056CC78DD    	  1723:             cmpi.l #$56CC78DD,(a0)
00:000017CA 66FE            	  1724:             bne.s *
00:000017CC 0CA812AA34BB0004	  1725:             cmpi.l #$12AA34BB,4(a0)
00:000017D4 66FE            	  1726:             bne.s *
00:000017D6 0CA856CC78DD0008	  1727:             cmpi.l #$56CC78DD,8(a0)
00:000017DE 66FE            	  1728:             bne.s *
                            	  1729: 
                            	  1730: 
                            	  1731: * x(An)--> Dn
00:000017E0 203C5A5A5A5A    	  1732:             move.l #$5a5a5a5a,d0
00:000017E6 223C5A5A5A5A    	  1733:             move.l #$5a5a5a5a,d1
00:000017EC 243C5A5A5A5A    	  1734:             move.l #$5a5a5a5a,d2
00:000017F2 263C5A5A5A5A    	  1735:             move.l #$5a5a5a5a,d3
                            	  1736: 
00:000017F8 01080000        	  1737:             movep.w 0(a0),d0      * even offset
00:000017FC 03080001        	  1738:             movep.w 1(a0),d1      * odd offset
                            	  1739: 
00:00001800 05480004        	  1740:             movep.l 4(a0),d2      * even offset
00:00001804 07480005        	  1741:             movep.l 5(a0),d3      * odd offset
                            	  1742: 
00:00001808 0C805A5A5678    	  1743:             cmpi.l #$5a5a5678,d0
00:0000180E 66FE            	  1744:             bne.s *
00:00001810 0C815A5ACCDD    	  1745:             cmpi.l #$5a5aCCDD,d1
00:00001816 66FE            	  1746:             bne.s *
00:00001818 0C8212345678    	  1747:             cmpi.l #$12345678,d2
00:0000181E 66FE            	  1748:             bne.s *
00:00001820 0C83AABBCCDD    	  1749:             cmpi.l #$AABBCCDD,d3
00:00001826 66FE            	  1750:             bne.s *
                            	  1751: 
00:00001828 4E75            	  1752:             rts
                            	  1753: 
                            	  1754: 
                            	  1755: 
                            	  1756: *-----------------------------------------------------------
                            	  1757: *-----------------------------------------------------------
                            	  1758: * OPCODE : BOOL_I
                            	  1759: *-----------------------------------------------------------
                            	  1760: *-----------------------------------------------------------
                            	  1761: op_BOOL_I:
                            	  1762: 
                            	  1763: *     Dn -- BYTE
00:0000182A 203C12345678    	  1764:             move.l #$12345678,d0
00:00001830 44FC000F        	  1765:             move.w #$000F,CCR          * pre-set Flags
00:00001834 000000FF        	  1766:             ori.b  #$FF,d0
00:00001838 0A00005A        	  1767:             eori.b #$5A,d0
00:0000183C 020000F0        	  1768:             andi.b #$F0,d0
00:00001840 69FE            	  1769:             bvs.s *                       * Check V,C are cleared
00:00001842 65FE            	  1770:             bcs.s *
00:00001844 6AFE            	  1771:             bpl.s *                       * Verify if N flag is set
00:00001846 4200            	  1772:             andi.b #$00,d0
00:00001848 6BFE            	  1773:             bmi.s *                       * Verify if N flag is cleared
00:0000184A 66FE            	  1774:             bne.s *                       * Verify if Z flag is set
                            	  1775: 
                            	  1776: *     Dn -- WORD
00:0000184C 223C12345678    	  1777:             move.l #$12345678,d1
00:00001852 44FC000F        	  1778:             move.w #$000F,CCR          * pre-set Flags
00:00001856 0041FFFF        	  1779:             ori.w  #$FFFF,d1
00:0000185A 0A415A5A        	  1780:             eori.w #$5A5A,d1
00:0000185E 0241F0F0        	  1781:             andi.w #$F0F0,d1
00:00001862 69FE            	  1782:             bvs.s *                       * Check V,C are cleared
00:00001864 65FE            	  1783:             bcs.s *
00:00001866 6AFE            	  1784:             bpl.s *                       * Verify if N flag is set
00:00001868 4241            	  1785:             andi.w #$0000,d1
00:0000186A 6BFE            	  1786:             bmi.s *                       * Verify if N flag is cleared
00:0000186C 66FE            	  1787:             bne.s *                       * Verify if Z flag is set
                            	  1788: 
                            	  1789: *     Dn -- LONG
00:0000186E 243C12345678    	  1790:             move.l #$12345678,d2
00:00001874 44FC000F        	  1791:             move.w #$000F,CCR          * pre-set Flags
00:00001878 0082FFFFFFFF    	  1792:             ori.l  #$FFFFFFFF,d2
00:0000187E 0A825A5A5A5A    	  1793:             eori.l #$5A5A5A5A,d2
00:00001884 0282F0F0F0F0    	  1794:             andi.l #$F0F0F0F0,d2
00:0000188A 69FE            	  1795:             bvs.s *                       * Check V,C are cleared
00:0000188C 65FE            	  1796:             bcs.s *
00:0000188E 6AFE            	  1797:             bpl.s *                       * Verify if N flag is set
00:00001890 4282            	  1798:             andi.l #$00000000,d2
00:00001892 6BFE            	  1799:             bmi.s *                       * Verify if N flag is cleared
00:00001894 66FE            	  1800:             bne.s *                       * Verify if Z flag is set
                            	  1801: 
                            	  1802: 
                            	  1803: *     (An) -- BYTE
00:00001896 307C0100        	  1804:             move.l #$00000100,a0
00:0000189A 20BC12345678    	  1805:             move.l #$12345678,(a0)
00:000018A0 44FC000F        	  1806:             move.w #$000F,CCR          * pre-set Flags
00:000018A4 001000FF        	  1807:             ori.b  #$FF,(a0)
00:000018A8 0A10005A        	  1808:             eori.b #$5A,(a0)
00:000018AC 021000F0        	  1809:             andi.b #$F0,(a0)
00:000018B0 69FE            	  1810:             bvs.s *                       * Check V,C are cleared
00:000018B2 65FE            	  1811:             bcs.s *
00:000018B4 6AFE            	  1812:             bpl.s *                       * Verify if N flag is set
00:000018B6 4210            	  1813:             andi.b #$00,(a0)
00:000018B8 6BFE            	  1814:             bmi.s *                       * Verify if N flag is cleared
00:000018BA 66FE            	  1815:             bne.s *                       * Verify if Z flag is set
00:000018BC 4A10            	  1816:             cmpi.b #$00,(a0)
00:000018BE 66FE            	  1817:             bne.s *                       * Verify if Z flag is set
                            	  1818: 
                            	  1819: *     (An) -- WORD
00:000018C0 20BC12345678    	  1820:             move.l #$12345678,(a0)
00:000018C6 44FC000F        	  1821:             move.w #$000F,CCR          * pre-set Flags
00:000018CA 0050FFFF        	  1822:             ori.w  #$FFFF,(a0)
00:000018CE 0A505A5A        	  1823:             eori.w #$5A5A,(a0)
00:000018D2 0250F0F0        	  1824:             andi.w #$F0F0,(a0)
00:000018D6 69FE            	  1825:             bvs.s *                       * Check V,C are cleared
00:000018D8 65FE            	  1826:             bcs.s *
00:000018DA 6AFE            	  1827:             bpl.s *                       * Verify if N flag is set
00:000018DC 4250            	  1828:             andi.w #$0000,(a0)
00:000018DE 6BFE            	  1829:             bmi.s *                       * Verify if N flag is cleared
00:000018E0 66FE            	  1830:             bne.s *                       * Verify if Z flag is set
00:000018E2 4A50            	  1831:             cmpi.w #$00,(a0)
00:000018E4 66FE            	  1832:             bne.s *                       * Verify if Z flag is set
                            	  1833: 
                            	  1834: *     (An) -- LONG
00:000018E6 20BC12345678    	  1835:             move.l #$12345678,(a0)
00:000018EC 44FC000F        	  1836:             move.w #$000F,CCR          * pre-set Flags
00:000018F0 0090FFFFFFFF    	  1837:             ori.l  #$FFFFFFFF,(a0)
00:000018F6 0A905A5A5A5A    	  1838:             eori.l #$5A5A5A5A,(a0)
00:000018FC 0290F0F0F0F0    	  1839:             andi.l #$F0F0F0F0,(a0)
00:00001902 69FE            	  1840:             bvs.s *                       * Check V,C are cleared
00:00001904 65FE            	  1841:             bcs.s *
00:00001906 6AFE            	  1842:             bpl.s *                       * Verify if N flag is set
00:00001908 4290            	  1843:             andi.l #$00000000,(a0)
00:0000190A 6BFE            	  1844:             bmi.s *                       * Verify if N flag is cleared
00:0000190C 66FE            	  1845:             bne.s *                       * Verify if Z flag is set
00:0000190E 4A90            	  1846:             cmpi.l #$00,(a0)
00:00001910 66FE            	  1847:             bne.s *                       * Verify if Z flag is set
                            	  1848: 
                            	  1849: 
                            	  1850: 
                            	  1851: *     (An)+ -- BYTE
00:00001912 307C0100        	  1852:             move.l #$00000100,a0
00:00001916 20BC00A5FF88    	  1853:             move.l #$00A5FF88,(a0)
00:0000191C 44FC000F        	  1854:             move.w #$000F,CCR          * pre-set Flags
                            	  1855: 
00:00001920 001800F5        	  1856:             ori.b  #$F5,(a0)+
00:00001924 6AFE            	  1857:             bpl.s *                       * Verify if N flag is set
00:00001926 67FE            	  1858:             beq.s *                       * Verify if Z flag is cleared
                            	  1859: 
00:00001928 4618            	  1860:             eori.b #$FF,(a0)+
00:0000192A 6BFE            	  1861:             bmi.s *                       * Verify if N flag is cleared
00:0000192C 67FE            	  1862:             beq.s *                       * Verify if Z flag is cleared
                            	  1863: 
00:0000192E 021800AA        	  1864:             andi.b #$AA,(a0)+
00:00001932 6AFE            	  1865:             bpl.s *                       * Verify if N flag is set
00:00001934 67FE            	  1866:             beq.s *                       * Verify if Z flag is cleared
                            	  1867: 
00:00001936 307C0100        	  1868:             move.l #$00000100,a0
00:0000193A 0C90F55AAA88    	  1869:             cmpi.l #$F55AAA88,(a0)
00:00001940 66FE            	  1870:             bne.s *                       * Verify if Z flag is set
                            	  1871: 
                            	  1872: 
                            	  1873: *     (An)+ -- WORD
00:00001942 307C0100        	  1874:             move.l #$00000100,a0
00:00001946 327C0104        	  1875:             move.l #$00000104,a1
00:0000194A 20BC00005A5A    	  1876:             move.l #$00005a5a,(a0)
00:00001950 22BC12345678    	  1877:             move.l #$12345678,(a1)
00:00001956 44FC000F        	  1878:             move.w #$000F,CCR          * pre-set Flags
                            	  1879: 
00:0000195A 00585678        	  1880:             ori.w  #$5678,(a0)+
00:0000195E 6BFE            	  1881:             bmi.s *                       * Verify if N flag is cleared
00:00001960 67FE            	  1882:             beq.s *                       * Verify if Z flag is cleared
                            	  1883: 
00:00001962 4658            	  1884:             eori.w #$FFFF,(a0)+
00:00001964 6AFE            	  1885:             bpl.s *                       * Verify if N flag is set
00:00001966 67FE            	  1886:             beq.s *                       * Verify if Z flag is cleared
                            	  1887: 
00:00001968 0258A55A        	  1888:             andi.w #$A55A,(a0)+
00:0000196C 6BFE            	  1889:             bmi.s *                       * Verify if N flag is cleared
00:0000196E 67FE            	  1890:             beq.s *                       * Verify if Z flag is cleared
                            	  1891: 
00:00001970 307C0100        	  1892:             move.l #$00000100,a0
00:00001974 0C905678A5A5    	  1893:             cmpi.l #$5678a5a5,(a0)
00:0000197A 307C0104        	  1894:             move.l #$00000104,a0
00:0000197E 0C9000105678    	  1895:             cmpi.l #$00105678,(a0)
00:00001984 66FE            	  1896:             bne.s *                       * Verify if Z flag is set
                            	  1897: 
                            	  1898: *     (An)+ -- LONG
00:00001986 307C0100        	  1899:             move.l #$00000100,a0
00:0000198A 4298            	  1900:             move.l #$00000000,(a0)+
00:0000198C 20FC5A5A5A5A    	  1901:             move.l #$5a5a5a5a,(a0)+
00:00001992 20FCFFFFFFFF    	  1902:             move.l #$FFFFFFFF,(a0)+
00:00001998 307C0100        	  1903:             move.l #$00000100,a0
00:0000199C 44FC000F        	  1904:             move.w #$000F,CCR          * pre-set Flags
                            	  1905: 
00:000019A0 009812345678    	  1906:             ori.l  #$12345678,(a0)+
00:000019A6 6BFE            	  1907:             bmi.s *                       * Verify if N flag is cleared
00:000019A8 67FE            	  1908:             beq.s *                       * Verify if Z flag is cleared
                            	  1909: 
00:000019AA 4698            	  1910:             eori.l #$FFFFFFFF,(a0)+
00:000019AC 6AFE            	  1911:             bpl.s *                       * Verify if N flag is set
00:000019AE 67FE            	  1912:             beq.s *                       * Verify if Z flag is cleared
                            	  1913: 
00:000019B0 0298A5A5A55A    	  1914:             andi.l #$A5A5A55A,(a0)+
00:000019B6 6AFE            	  1915:             bpl.s *                       * Verify if N flag is set
00:000019B8 67FE            	  1916:             beq.s *                       * Verify if Z flag is cleared
                            	  1917: 
00:000019BA 307C0100        	  1918:             move.l #$00000100,a0
00:000019BE 0C9812345678    	  1919:             cmpi.l #$12345678,(a0)+
00:000019C4 0C98A5A5A5A5    	  1920:             cmpi.l #$a5a5a5a5,(a0)+
00:000019CA 0C98A5A5A55A    	  1921:             cmpi.l #$a5a5a55a,(a0)+
00:000019D0 66FE            	  1922:             bne.s *                       * Verify if Z flag is set
                            	  1923: 
00:000019D2 4E75            	  1924:             rts
                            	  1925: 
                            	  1926: 
                            	  1927: *-----------------------------------------------------------
                            	  1928: *-----------------------------------------------------------
                            	  1929: * OPCODE : BSR
                            	  1930: *-----------------------------------------------------------
                            	  1931: *-----------------------------------------------------------
                            	  1932: 
                            	  1933: 
00:000019D4 223C11111111    	  1934: BSR_CLOSE1:     move.l #$11111111,d1
00:000019DA 4E75            	  1935:                 rts
                            	  1936: 
                            	  1937: 
                            	  1938: 
00:000019DC 61F6            	  1939: op_BSR:         bsr BSR_CLOSE1        * Negative 8-bit.s displacement
00:000019DE 612A            	  1940:                 bsr BSR_CLOSE2        * Positive 8-bit.s displacement
00:000019E0 6100EF20        	  1941:                 bsr.w BSR_FAR1          * Negative 16-bit.s displacement
00:000019E4 6100144E        	  1942:                 bsr.w BSR_FAR2          * Positive 16-bit.s displacement
                            	  1943: 
00:000019E8 0C8111111111    	  1944:                 cmpi.l #$11111111,d1
00:000019EE 66FE            	  1945:                 bne.s *
00:000019F0 0C8222222222    	  1946:                 cmpi.l #$22222222,d2
00:000019F6 66FE            	  1947:                 bne.s *
00:000019F8 0C8333333333    	  1948:                 cmpi.l #$33333333,d3
00:000019FE 66FE            	  1949:                 bne.s *
00:00001A00 0C8444444444    	  1950:                 cmpi.l #$44444444,d4
00:00001A06 66FE            	  1951:                 bne.s *
                            	  1952: 
00:00001A08 4E75            	  1953:                 rts
                            	  1954: 
                            	  1955: 
00:00001A0A 243C22222222    	  1956: BSR_CLOSE2:     move.l #$22222222,d2
00:00001A10 4E75            	  1957:                 rts
                            	  1958: 
                            	  1959: *-----------------------------------------------------------
                            	  1960: *-----------------------------------------------------------
                            	  1961: * OPCODE : op_CMP_I
                            	  1962: *-----------------------------------------------------------
                            	  1963: *-----------------------------------------------------------
                            	  1964: op_CMP_I:
                            	  1965: 
00:00001A12 307C0100        	  1966:             move.l #$00000100,a0
00:00001A16 20BC00000100    	  1967:             move.l #$00000100,(a0)
                            	  1968: 
                            	  1969: *     REGISTER - BYTE
00:00001A1C 7080            	  1970:             move.l #$FFFFFF80,d0
00:00001A1E 0C000080        	  1971:             cmpi.b #$80,d0
00:00001A22 66FE            	  1972:             bne.s *                       * Check Z Flag  beq/bne
00:00001A24 6BFE            	  1973:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001A26 65FE            	  1974:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001A28 69FE            	  1975:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1976: 
00:00001A2A 223CFFFFF000    	  1977:             move.l #$FFFFF000,d1
00:00001A30 4A01            	  1978:             cmpi.b #$00,d1
00:00001A32 66FE            	  1979:             bne.s *                       * Check Z Flag  beq/bne
00:00001A34 6BFE            	  1980:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001A36 65FE            	  1981:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001A38 69FE            	  1982:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1983: 
00:00001A3A 7481D442        	  1984:             move.l #$FFFFFF02,d2
00:00001A3E 0C0200FF        	  1985:             cmpi.b #$FF,d2
00:00001A42 67FE            	  1986:             beq.s *                       * Check Z Flag  beq/bne
00:00001A44 6BFE            	  1987:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001A46 64FE            	  1988:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001A48 69FE            	  1989:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1990: 
00:00001A4A 263CFFFFFF7F    	  1991:             move.l #$FFFFFF7F,d3
00:00001A50 0C0300FF        	  1992:             cmpi.b #$FF,d3
00:00001A54 67FE            	  1993:             beq.s *                       * Check Z Flag  beq/bne
00:00001A56 6AFE            	  1994:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001A58 64FE            	  1995:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001A5A 68FE            	  1996:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  1997: 
                            	  1998: 
                            	  1999: *     REGISTER - WORD
00:00001A5C 203CFFFF8000    	  2000:             move.l #$FFFF8000,d0
00:00001A62 0C408000        	  2001:             cmpi.w #$8000,d0
00:00001A66 66FE            	  2002:             bne.s *                       * Check Z Flag  beq/bne
00:00001A68 6BFE            	  2003:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001A6A 65FE            	  2004:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001A6C 69FE            	  2005:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2006: 
00:00001A6E 223CFFF00000    	  2007:             move.l #$FFF00000,d1
00:00001A74 4A41            	  2008:             cmpi.w #$0000,d1
00:00001A76 66FE            	  2009:             bne.s *                       * Check Z Flag  beq/bne
00:00001A78 6BFE            	  2010:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001A7A 65FE            	  2011:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001A7C 69FE            	  2012:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2013: 
00:00001A7E 243CFFFF0002    	  2014:             move.l #$FFFF0002,d2
00:00001A84 0C42FFFF        	  2015:             cmpi.w #$FFFF,d2
00:00001A88 67FE            	  2016:             beq.s *                       * Check Z Flag  beq/bne
00:00001A8A 6BFE            	  2017:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001A8C 64FE            	  2018:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001A8E 69FE            	  2019:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2020: 
00:00001A90 263CFFFF7FFF    	  2021:             move.l #$FFFF7FFF,d3
00:00001A96 0C43FFFF        	  2022:             cmpi.w #$FFFF,d3
00:00001A9A 67FE            	  2023:             beq.s *                       * Check Z Flag  beq/bne
00:00001A9C 6AFE            	  2024:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001A9E 64FE            	  2025:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001AA0 68FE            	  2026:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2027: 
                            	  2028: *     REGISTER - LONG
00:00001AA2 203C80000000    	  2029:             move.l #$80000000,d0
00:00001AA8 0C8080000000    	  2030:             cmpi.l #$80000000,d0
00:00001AAE 66FE            	  2031:             bne.s *                       * Check Z Flag  beq/bne
00:00001AB0 6BFE            	  2032:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001AB2 65FE            	  2033:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001AB4 69FE            	  2034:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2035: 
00:00001AB6 7200            	  2036:             moveq  #$00000000,d1
00:00001AB8 4A81            	  2037:             cmpi.l #$00000000,d1
00:00001ABA 66FE            	  2038:             bne.s *                       * Check Z Flag  beq/bne
00:00001ABC 6BFE            	  2039:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001ABE 65FE            	  2040:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001AC0 69FE            	  2041:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2042: 
00:00001AC2 7402            	  2043:             moveq  #$00000002,d2
00:00001AC4 0C82FFFFFFFF    	  2044:             cmpi.l #$FFFFFFFF,d2
00:00001ACA 67FE            	  2045:             beq.s *                       * Check Z Flag  beq/bne
00:00001ACC 6BFE            	  2046:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001ACE 64FE            	  2047:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001AD0 69FE            	  2048:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2049: 
00:00001AD2 263C7FFFFFFF    	  2050:             move.l #$7FFFFFFF,d3
00:00001AD8 0C83FFFFFFFF    	  2051:             cmpi.l #$FFFFFFFF,d3
00:00001ADE 67FE            	  2052:             beq.s *                       * Check Z Flag  beq/bne
00:00001AE0 6AFE            	  2053:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001AE2 64FE            	  2054:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001AE4 68FE            	  2055:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2056: 
                            	  2057: 
                            	  2058: 
                            	  2059: 
                            	  2060: *     EA=x(An,Dn) - BYTE
00:00001AE6 307C0100        	  2061:             move.l #$00000100,a0
00:00001AEA 7E04            	  2062:             moveq  #$00000004,d7
                            	  2063: 
00:00001AEC 21BCFFFFFF80700C	  2064:             move.l #$FFFFFF80,12(a0,d7)
00:00001AF4 21BCFFFFFF80700C	  2065:             move.l #$FFFFFF80,12(a0,d7)
00:00001AFC 0C300080700F    	  2066:             cmpi.b #$80,15(a0,d7)
00:00001B02 66FE            	  2067:             bne.s *                       * Check Z Flag  beq/bne
00:00001B04 6BFE            	  2068:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001B06 65FE            	  2069:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001B08 69FE            	  2070:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2071: 
00:00001B0A 21BCFFFFF000700C	  2072:             move.l #$FFFFF000,12(a0,d7)
00:00001B12 4A30700F        	  2073:             cmpi.b #$00,15(a0,d7)
00:00001B16 66FE            	  2074:             bne.s *                       * Check Z Flag  beq/bne
00:00001B18 6BFE            	  2075:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001B1A 65FE            	  2076:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001B1C 69FE            	  2077:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2078: 
00:00001B1E 21BCFFFFFF02700C	  2079:             move.l #$FFFFFF02,12(a0,d7)
00:00001B26 0C3000FF700F    	  2080:             cmpi.b #$FF,15(a0,d7)
00:00001B2C 67FE            	  2081:             beq.s *                       * Check Z Flag  beq/bne
00:00001B2E 6BFE            	  2082:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001B30 64FE            	  2083:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001B32 69FE            	  2084:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2085: 
00:00001B34 21BCFFFFFF7F700C	  2086:             move.l #$FFFFFF7F,12(a0,d7)
00:00001B3C 0C3000FF700F    	  2087:             cmpi.b #$FF,15(a0,d7)
00:00001B42 67FE            	  2088:             beq.s *                       * Check Z Flag  beq/bne
00:00001B44 6AFE            	  2089:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001B46 64FE            	  2090:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001B48 68FE            	  2091:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2092: 
                            	  2093: 
                            	  2094: *     EA=x(An,Dn) - WORD
00:00001B4A 21BCFFFF8000700C	  2095:             move.l #$FFFF8000,12(a0,d7)
00:00001B52 0C708000700E    	  2096:             cmpi.w #$8000,14(a0,d7)
00:00001B58 66FE            	  2097:             bne.s *                       * Check Z Flag  beq/bne
00:00001B5A 6BFE            	  2098:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001B5C 65FE            	  2099:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001B5E 69FE            	  2100:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2101: 
00:00001B60 21BCFFF00000700C	  2102:             move.l #$FFF00000,12(a0,d7)
00:00001B68 4A70700E        	  2103:             cmpi.w #$0000,14(a0,d7)
00:00001B6C 66FE            	  2104:             bne.s *                       * Check Z Flag  beq/bne
00:00001B6E 6BFE            	  2105:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001B70 65FE            	  2106:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001B72 69FE            	  2107:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2108: 
00:00001B74 21BCFFFF0002700C	  2109:             move.l #$FFFF0002,12(a0,d7)
00:00001B7C 0C70FFFF700E    	  2110:             cmpi.w #$FFFF,14(a0,d7)
00:00001B82 67FE            	  2111:             beq.s *                       * Check Z Flag  beq/bne
00:00001B84 6BFE            	  2112:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001B86 64FE            	  2113:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001B88 69FE            	  2114:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2115: 
00:00001B8A 21BCFFFF7FFF700C	  2116:             move.l #$FFFF7FFF,12(a0,d7)
00:00001B92 0C70FFFF700E    	  2117:             cmpi.w #$FFFF,14(a0,d7)
00:00001B98 67FE            	  2118:             beq.s *                       * Check Z Flag  beq/bne
00:00001B9A 6AFE            	  2119:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001B9C 64FE            	  2120:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001B9E 68FE            	  2121:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2122: 
                            	  2123: *     EA=x(An,Dn) - LONG
00:00001BA0 21BC80000000700C	  2124:             move.l #$80000000,12(a0,d7)
00:00001BA8 0CB080000000700C	  2125:             cmpi.l #$80000000,12(a0,d7)
00:00001BB0 66FE            	  2126:             bne.s *                       * Check Z Flag  beq/bne
00:00001BB2 6BFE            	  2127:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001BB4 65FE            	  2128:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001BB6 69FE            	  2129:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2130: 
00:00001BB8 42B0700C        	  2131:             move.l #$00000000,12(a0,d7)
00:00001BBC 4AB0700C        	  2132:             cmpi.l #$00000000,12(a0,d7)
00:00001BC0 66FE            	  2133:             bne.s *                       * Check Z Flag  beq/bne
00:00001BC2 6BFE            	  2134:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001BC4 65FE            	  2135:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001BC6 69FE            	  2136:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2137: 
00:00001BC8 21BC00000002700C	  2138:             move.l #$00000002,12(a0,d7)
00:00001BD0 0CB0FFFFFFFF700C	  2139:             cmpi.l #$FFFFFFFF,12(a0,d7)
00:00001BD8 67FE            	  2140:             beq.s *                       * Check Z Flag  beq/bne
00:00001BDA 6BFE            	  2141:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001BDC 64FE            	  2142:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001BDE 69FE            	  2143:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2144: 
00:00001BE0 21BC7FFFFFFF700C	  2145:             move.l #$7FFFFFFF,12(a0,d7)
00:00001BE8 0CB0FFFFFFFF700C	  2146:             cmpi.l #$FFFFFFFF,12(a0,d7)
00:00001BF0 67FE            	  2147:             beq.s *                       * Check Z Flag  beq/bne
00:00001BF2 6AFE            	  2148:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001BF4 64FE            	  2149:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001BF6 68FE            	  2150:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2151: 
                            	  2152: 
                            	  2153: 
                            	  2154: 
00:00001BF8 4E75            	  2155:             rts
                            	  2156: 
                            	  2157: 
                            	  2158: 
                            	  2159: *-----------------------------------------------------------
                            	  2160: *-----------------------------------------------------------
                            	  2161: * OPCODE : ADD_I
                            	  2162: *-----------------------------------------------------------
                            	  2163: *-----------------------------------------------------------
                            	  2164: op_ADD_I:
                            	  2165: 
                            	  2166: *     EA = Dn  - Byte
00:00001BFA 203C12345678    	  2167:             move.l #$12345678,d0      * populate test data
00:00001C00 06000000        	  2168:             addi.b #0,d0
00:00001C04 67FE            	  2169:             beq.s *                       * Check Z Flag  beq/bne
00:00001C06 6BFE            	  2170:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001C08 65FE            	  2171:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001C0A 69FE            	  2172:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001C0C 06000010        	  2173:             addi.b #$10,d0
00:00001C10 67FE            	  2174:             beq.s *                       * Check Z Flag  beq/bne
00:00001C12 6AFE            	  2175:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001C14 65FE            	  2176:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001C16 68FE            	  2177:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001C18 060000A5        	  2178:             addi.b #$A5,d0
00:00001C1C 67FE            	  2179:             beq.s *                       * Check Z Flag  beq/bne
00:00001C1E 6BFE            	  2180:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001C20 64FE            	  2181:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001C22 68FE            	  2182:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001C24 0C00002D        	  2183:             cmpi.b #$2D,d0
00:00001C28 66FE            	  2184:             bne.s *                       * Check Z Flag  beq/bne
                            	  2185: 
                            	  2186: *     EA = Dn  - WORD
00:00001C2A 203C12345678    	  2187:             move.l #$12345678,d0      * populate test data
00:00001C30 06400000        	  2188:             addi.w #0,d0
00:00001C34 67FE            	  2189:             beq.s *                       * Check Z Flag  beq/bne
00:00001C36 6BFE            	  2190:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001C38 65FE            	  2191:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001C3A 69FE            	  2192:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001C3C 06407000        	  2193:             addi.w #$7000,d0
00:00001C40 67FE            	  2194:             beq.s *                       * Check Z Flag  beq/bne
00:00001C42 6AFE            	  2195:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001C44 65FE            	  2196:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001C46 68FE            	  2197:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001C48 0640A55A        	  2198:             addi.w #$A55A,d0
00:00001C4C 67FE            	  2199:             beq.s *                       * Check Z Flag  beq/bne
00:00001C4E 6BFE            	  2200:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001C50 64FE            	  2201:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001C52 68FE            	  2202:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001C54 0C406BD2        	  2203:             cmpi.w #$6BD2,d0
00:00001C58 66FE            	  2204:             bne.s *                       * Check Z Flag  beq/bne
                            	  2205: 
                            	  2206: *     EA = Dn  - LONG
00:00001C5A 203C12345678    	  2207:             move.l #$12345678,d0      * populate test data
00:00001C60 068000000000    	  2208:             addi.l #0,d0
00:00001C66 67FE            	  2209:             beq.s *                       * Check Z Flag  beq/bne
00:00001C68 6BFE            	  2210:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001C6A 65FE            	  2211:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001C6C 69FE            	  2212:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001C6E 0680F0000000    	  2213:             addi.l #$F0000000,d0
00:00001C74 67FE            	  2214:             beq.s *                       * Check Z Flag  beq/bne
00:00001C76 6BFE            	  2215:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001C78 64FE            	  2216:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001C7A 69FE            	  2217:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001C7C 0680855AA55A    	  2218:             addi.l #$855AA55A,d0
00:00001C82 67FE            	  2219:             beq.s *                       * Check Z Flag  beq/bne
00:00001C84 6AFE            	  2220:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001C86 65FE            	  2221:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001C88 69FE            	  2222:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001C8A 0680A0000000    	  2223:             addi.l #$A0000000,d0
00:00001C90 68FE            	  2224:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001C92 0C80278EFBD2    	  2225:             cmpi.l #$278EFBD2,d0
00:00001C98 66FE            	  2226:             bne.s *                       * Check Z Flag  beq/bne
                            	  2227: 
                            	  2228: 
                            	  2229: 
                            	  2230: *     EA = x.L  - Byte
00:00001C9A 207C0000F100    	  2231:             move.l #$F100,a0      * populate test data
00:00001CA0 20BC12345678    	  2232:             move.l #$12345678,(a0)     * populate test data
00:00001CA6 063900000000F103	  2233:             addi.b #0,$F103
00:00001CAE 67FE            	  2234:             beq.s *                       * Check Z Flag  beq/bne
00:00001CB0 6BFE            	  2235:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001CB2 65FE            	  2236:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001CB4 69FE            	  2237:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001CB6 063900100000F103	  2238:             addi.b #$10,$F103
00:00001CBE 67FE            	  2239:             beq.s *                       * Check Z Flag  beq/bne
00:00001CC0 6AFE            	  2240:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001CC2 65FE            	  2241:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001CC4 68FE            	  2242:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001CC6 063900A50000F103	  2243:             addi.b #$A5,$F103
00:00001CCE 67FE            	  2244:             beq.s *                       * Check Z Flag  beq/bne
00:00001CD0 6BFE            	  2245:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001CD2 64FE            	  2246:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001CD4 68FE            	  2247:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001CD6 0C39002D0000F103	  2248:             cmpi.b #$2D,$F103
00:00001CDE 66FE            	  2249:             bne.s *                       * Check Z Flag  beq/bne
                            	  2250: 
                            	  2251: *     EA = x.L- WORD
00:00001CE0 207C0000F100    	  2252:             move.l #$F100,a0      * populate test data
00:00001CE6 20BC12345678    	  2253:             move.l #$12345678,(a0)     * populate test data
00:00001CEC 067900000000F100	  2254:             addi.w #0,$F100
00:00001CF4 67FE            	  2255:             beq.s *                       * Check Z Flag  beq/bne
00:00001CF6 6BFE            	  2256:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001CF8 65FE            	  2257:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001CFA 69FE            	  2258:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001CFC 067970000000F100	  2259:             addi.w #$7000,$F100
00:00001D04 67FE            	  2260:             beq.s *                       * Check Z Flag  beq/bne
00:00001D06 6AFE            	  2261:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001D08 65FE            	  2262:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001D0A 68FE            	  2263:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001D0C 0679A55A0000F100	  2264:             addi.w #$A55A,$F100
00:00001D14 67FE            	  2265:             beq.s *                       * Check Z Flag  beq/bne
00:00001D16 6BFE            	  2266:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001D18 64FE            	  2267:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001D1A 68FE            	  2268:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001D1C 0C79278E0000F100	  2269:             cmpi.w #$278E,$F100
00:00001D24 66FE            	  2270:             bne.s *                       * Check Z Flag  beq/bne
                            	  2271: 
                            	  2272: *     EA = x.L- LONG
00:00001D26 23FC123456780000	  2273:             move.l #$12345678,$F100  * populate test data
00:00001D2E F100
00:00001D30 06B9000000000000	  2274:             addi.l #0,$F100
00:00001D38 F100
00:00001D3A 67FE            	  2275:             beq.s *                       * Check Z Flag  beq/bne
00:00001D3C 6BFE            	  2276:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001D3E 65FE            	  2277:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001D40 69FE            	  2278:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001D42 06B9F00000000000	  2279:             addi.l #$F0000000,$F100
00:00001D4A F100
00:00001D4C 67FE            	  2280:             beq.s *                       * Check Z Flag  beq/bne
00:00001D4E 6BFE            	  2281:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001D50 64FE            	  2282:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001D52 69FE            	  2283:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001D54 06B9855AA55A0000	  2284:             addi.l #$855AA55A,$F100
00:00001D5C F100
00:00001D5E 67FE            	  2285:             beq.s *                       * Check Z Flag  beq/bne
00:00001D60 6AFE            	  2286:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001D62 65FE            	  2287:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001D64 69FE            	  2288:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001D66 06B9A00000000000	  2289:             addi.l #$A0000000,$F100
00:00001D6E F100
00:00001D70 68FE            	  2290:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001D72 0CB9278EFBD20000	  2291:             cmpi.l #$278EFBD2,$F100
00:00001D7A F100
00:00001D7C 66FE            	  2292:             bne.s *                       * Check Z Flag  beq/bne
                            	  2293: 
00:00001D7E 4E75            	  2294:             rts
                            	  2295: 
                            	  2296: 
                            	  2297: *-----------------------------------------------------------
                            	  2298: *-----------------------------------------------------------
                            	  2299: * OPCODE : SUB_I
                            	  2300: *-----------------------------------------------------------
                            	  2301: *-----------------------------------------------------------
                            	  2302: op_SUB_I:
                            	  2303: 
                            	  2304: *     EA = Dn  - Byte
00:00001D80 203C12345678    	  2305:             move.l #$12345678,d0      * populate test data
00:00001D86 04000000        	  2306:             subi.b #0,d0
00:00001D8A 67FE            	  2307:             beq.s *                       * Check Z Flag  beq/bne
00:00001D8C 6BFE            	  2308:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001D8E 65FE            	  2309:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001D90 69FE            	  2310:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001D92 04000010        	  2311:             subi.b #$10,d0
00:00001D96 67FE            	  2312:             beq.s *                       * Check Z Flag  beq/bne
00:00001D98 6BFE            	  2313:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001D9A 65FE            	  2314:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001D9C 69FE            	  2315:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001D9E 040000A5        	  2316:             subi.b #$A5,d0
00:00001DA2 67FE            	  2317:             beq.s *                       * Check Z Flag  beq/bne
00:00001DA4 6AFE            	  2318:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001DA6 64FE            	  2319:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001DA8 68FE            	  2320:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001DAA 0C0000C3        	  2321:             cmpi.b #$C3,d0
00:00001DAE 66FE            	  2322:             bne.s *                       * Check Z Flag  beq/bne
                            	  2323: 
                            	  2324: *     EA = Dn  - WORD
00:00001DB0 203C12345678    	  2325:             move.l #$12345678,d0      * populate test data
00:00001DB6 04400000        	  2326:             subi.w #0,d0
00:00001DBA 67FE            	  2327:             beq.s *                       * Check Z Flag  beq/bne
00:00001DBC 6BFE            	  2328:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001DBE 65FE            	  2329:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001DC0 69FE            	  2330:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001DC2 04407000        	  2331:             subi.w #$7000,d0
00:00001DC6 67FE            	  2332:             beq.s *                       * Check Z Flag  beq/bne
00:00001DC8 6AFE            	  2333:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001DCA 64FE            	  2334:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001DCC 69FE            	  2335:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001DCE 0440A55A        	  2336:             subi.w #$A55A,d0
00:00001DD2 67FE            	  2337:             beq.s *                       * Check Z Flag  beq/bne
00:00001DD4 6BFE            	  2338:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001DD6 65FE            	  2339:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001DD8 69FE            	  2340:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001DDA 0C40411E        	  2341:             cmpi.w #$411E,d0
00:00001DDE 66FE            	  2342:             bne.s *                       * Check Z Flag  beq/bne
                            	  2343: 
                            	  2344: *     EA = Dn  - LONG
00:00001DE0 203C12345678    	  2345:             move.l #$12345678,d0      * populate test data
00:00001DE6 048000000000    	  2346:             subi.l #0,d0
00:00001DEC 67FE            	  2347:             beq.s *                       * Check Z Flag  beq/bne
00:00001DEE 6BFE            	  2348:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001DF0 65FE            	  2349:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001DF2 69FE            	  2350:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001DF4 0480F0000000    	  2351:             subi.l #$F0000000,d0
00:00001DFA 67FE            	  2352:             beq.s *                       * Check Z Flag  beq/bne
00:00001DFC 6BFE            	  2353:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001DFE 64FE            	  2354:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001E00 69FE            	  2355:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001E02 0480855AA55A    	  2356:             subi.l #$855AA55A,d0
00:00001E08 67FE            	  2357:             beq.s *                       * Check Z Flag  beq/bne
00:00001E0A 6AFE            	  2358:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001E0C 64FE            	  2359:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001E0E 68FE            	  2360:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001E10 0480A0000000    	  2361:             subi.l #$A0000000,d0
00:00001E16 69FE            	  2362:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001E18 0C80FCD9B11E    	  2363:             cmpi.l #$FCD9B11E,d0
00:00001E1E 66FE            	  2364:             bne.s *                       * Check Z Flag  beq/bne
                            	  2365: 
                            	  2366: 
                            	  2367: 
                            	  2368: *     EA = x.L  - Byte
00:00001E20 207C0000F100    	  2369:             move.l #$F100,a0      * populate test data
00:00001E26 20BC12345678    	  2370:             move.l #$12345678,(a0)     * populate test data
00:00001E2C 043900000000F103	  2371:             subi.b #0,$F103
00:00001E34 67FE            	  2372:             beq.s *                       * Check Z Flag  beq/bne
00:00001E36 6BFE            	  2373:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001E38 65FE            	  2374:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001E3A 69FE            	  2375:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001E3C 043900100000F103	  2376:             subi.b #$10,$F103
00:00001E44 67FE            	  2377:             beq.s *                       * Check Z Flag  beq/bne
00:00001E46 6BFE            	  2378:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001E48 65FE            	  2379:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001E4A 69FE            	  2380:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001E4C 043900A50000F103	  2381:             subi.b #$A5,$F103
00:00001E54 67FE            	  2382:             beq.s *                       * Check Z Flag  beq/bne
00:00001E56 6AFE            	  2383:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001E58 64FE            	  2384:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001E5A 68FE            	  2385:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001E5C 0C3900C30000F103	  2386:             cmpi.b #$C3,$F103
00:00001E64 66FE            	  2387:             bne.s *                       * Check Z Flag  beq/bne
                            	  2388: 
                            	  2389: *     EA = x.L- WORD
00:00001E66 207C0000F100    	  2390:             move.l #$F100,a0      * populate test data
00:00001E6C 20BC12345678    	  2391:             move.l #$12345678,(a0)     * populate test data
00:00001E72 047900000000F100	  2392:             subi.w #0,$F100
00:00001E7A 67FE            	  2393:             beq.s *                       * Check Z Flag  beq/bne
00:00001E7C 6BFE            	  2394:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001E7E 65FE            	  2395:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001E80 69FE            	  2396:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001E82 047970000000F100	  2397:             subi.w #$7000,$F100
00:00001E8A 67FE            	  2398:             beq.s *                       * Check Z Flag  beq/bne
00:00001E8C 6AFE            	  2399:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001E8E 64FE            	  2400:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001E90 69FE            	  2401:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001E92 0479A55A0000F100	  2402:             subi.w #$A55A,$F100
00:00001E9A 67FE            	  2403:             beq.s *                       * Check Z Flag  beq/bne
00:00001E9C 6AFE            	  2404:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001E9E 64FE            	  2405:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001EA0 69FE            	  2406:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001EA2 0C79FCDA0000F100	  2407:             cmpi.w #$FCDA,$F100
00:00001EAA 66FE            	  2408:             bne.s *                       * Check Z Flag  beq/bne
                            	  2409: 
                            	  2410: *     EA = x.L- LONG
00:00001EAC 23FC123456780000	  2411:             move.l #$12345678,$F100  * populate test data
00:00001EB4 F100
00:00001EB6 04B9000000000000	  2412:             subi.l #0,$F100
00:00001EBE F100
00:00001EC0 67FE            	  2413:             beq.s *                       * Check Z Flag  beq/bne
00:00001EC2 6BFE            	  2414:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001EC4 65FE            	  2415:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001EC6 69FE            	  2416:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001EC8 04B9F00000000000	  2417:             subi.l #$F0000000,$F100
00:00001ED0 F100
00:00001ED2 67FE            	  2418:             beq.s *                       * Check Z Flag  beq/bne
00:00001ED4 6BFE            	  2419:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001ED6 64FE            	  2420:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001ED8 69FE            	  2421:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001EDA 04B9855AA55A0000	  2422:             subi.l #$855AA55A,$F100
00:00001EE2 F100
00:00001EE4 67FE            	  2423:             beq.s *                       * Check Z Flag  beq/bne
00:00001EE6 6AFE            	  2424:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001EE8 64FE            	  2425:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001EEA 68FE            	  2426:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001EEC 04B9A00000000000	  2427:             subi.l #$A0000000,$F100
00:00001EF4 F100
00:00001EF6 69FE            	  2428:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001EF8 0CB9FCD9B11E0000	  2429:             cmpi.l #$FCD9B11E,$F100
00:00001F00 F100
00:00001F02 66FE            	  2430:             bne.s *                       * Check Z Flag  beq/bne
                            	  2431: 
00:00001F04 4E75            	  2432:             rts
                            	  2433: 
                            	  2434: 
                            	  2435: 
                            	  2436: *-----------------------------------------------------------
                            	  2437: *-----------------------------------------------------------
                            	  2438: * OPCODE : MOVE
                            	  2439: *-----------------------------------------------------------
                            	  2440: *-----------------------------------------------------------
                            	  2441: op_MOVE:
00:00001F06 203C11223344    	  2442:             move.l #$11223344,d0
00:00001F0C 223C55667788    	  2443:             move.l #$55667788,d1
00:00001F12 243C8899AABB    	  2444:             move.l #$8899aabb,d2
00:00001F18 263CCCDDEEFF    	  2445:             move.l #$ccddeeff,d3
00:00001F1E 7800            	  2446:             moveq  #$00000000,d4
00:00001F20 7A00            	  2447:             moveq  #$00000000,d5
00:00001F22 7C00            	  2448:             moveq  #$00000000,d6
00:00001F24 7E00            	  2449:             moveq  #$00000000,d7
00:00001F26 207C44332211    	  2450:             move.l #$44332211,a0
00:00001F2C 227C88776655    	  2451:             move.l #$88776655,a1
00:00001F32 247CBBAA9988    	  2452:             move.l #$bbaa9988,a2
00:00001F38 267CFFEEDDCC    	  2453:             move.l #$ffeeddcc,a3
                            	  2454: 
00:00001F3E 1800            	  2455:             move.b d0,d4              * BYTE - DATA REGISTER
00:00001F40 67FE            	  2456:             beq.s *                       * Check Z Flag  beq/bne
00:00001F42 6BFE            	  2457:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001F44 0C8400000044    	  2458:             cmpi.l #$00000044,d4
00:00001F4A 66FE            	  2459:             bne.s *                       * Check Z Flag  beq/bne
                            	  2460: 
00:00001F4C 3A01            	  2461:             move.w d1,d5              * WORD - DATA REGISTER
00:00001F4E 67FE            	  2462:             beq.s *                       * Check Z Flag  beq/bne
00:00001F50 6BFE            	  2463:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001F52 0C8500007788    	  2464:             cmpi.l #$00007788,d5
00:00001F58 66FE            	  2465:             bne.s *                       * Check Z Flag  beq/bne
                            	  2466: 
00:00001F5A 2C02            	  2467:             move.l d2,d6              * LONG - DATA REGISTER
00:00001F5C 67FE            	  2468:             beq.s *                       * Check Z Flag  beq/bne
00:00001F5E 6AFE            	  2469:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001F60 0C868899AABB    	  2470:             cmpi.l #$8899aabb,d6
00:00001F66 66FE            	  2471:             bne.s *                       * Check Z Flag  beq/bne
                            	  2472: 
00:00001F68 3A09            	  2473:             move.w a1,d5              * WORD - ADDRESS REGISTER
00:00001F6A 67FE            	  2474:             beq.s *                       * Check Z Flag  beq/bne
00:00001F6C 6BFE            	  2475:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001F6E 0C8500006655    	  2476:             cmpi.l #$00006655,d5
00:00001F74 66FE            	  2477:             bne.s *                       * Check Z Flag  beq/bne
                            	  2478: 
00:00001F76 2C0A            	  2479:             move.l a2,d6              * LONG - ADDRESS REGISTER
00:00001F78 67FE            	  2480:             beq.s *                       * Check Z Flag  beq/bne
00:00001F7A 6AFE            	  2481:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001F7C 0C86BBAA9988    	  2482:             cmpi.l #$bbaa9988,d6
00:00001F82 66FE            	  2483:             bne.s *                       * Check Z Flag  beq/bne
                            	  2484: 
                            	  2485: 
00:00001F84 3842            	  2486:             movea.w d2,a4             * WORD - ADDRESS REGISTER as SOURCE ## MOVEA
00:00001F86 B9C2            	  2487:             cmpa.l d2,a4
00:00001F88 67FE            	  2488:             beq.s *                       * Check Z Flag  beq/bne ## comopare fails because A4 was sign extended
                            	  2489: 
00:00001F8A 2A41            	  2490:             movea.l d1,a5             * LONG - ADDRESS REGISTER as SOURCE ## MOVEA
00:00001F8C BBC1            	  2491:             cmpa.l d1,a5
00:00001F8E 66FE            	  2492:             bne.s *                       * Check Z Flag  beq/bne
                            	  2493: 
                            	  2494: 
                            	  2495: 
                            	  2496: *   Too mamy EA combinations to test,so we focus on a few of the more complicted EA's
                            	  2497: 
00:00001F90 203C11223344    	  2498:             move.l #$11223344,d0
00:00001F96 223C00010100    	  2499:             move.l #$00010100,d1
00:00001F9C 243C8899AABB    	  2500:             move.l #$8899aabb,d2
00:00001FA2 7601            	  2501:             moveq  #$00000001,d3
00:00001FA4 7800            	  2502:             moveq  #$00000000,d4
00:00001FA6 7A00            	  2503:             moveq  #$00000000,d5
00:00001FA8 7C00            	  2504:             moveq  #$00000000,d6
00:00001FAA 7E00            	  2505:             moveq  #$00000000,d7
00:00001FAC 91C8            	  2506:             move.l #$00000000,a0
00:00001FAE 227C00010100    	  2507:             move.l #$00010100,a1
                            	  2508: 
                            	  2509: *     x(An,AL) --> x.L
00:00001FB4 11BC005A9804    	  2510:             move.b #$5A,4(a0,a1.l)    * BYTE
00:00001FBA 47F09804        	  2511:             lea 4(a0,a1.l),a3
00:00001FBE 13F0980400010105	  2512:             move.b 4(a0,a1.l),$00010105
00:00001FC6 67FE            	  2513:             beq.s *                       * Check Z Flag  beq/bne
00:00001FC8 6BFE            	  2514:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001FCA 0C30005A9805    	  2515:             cmpi.b #$5A,5(a0,a1.l)
00:00001FD0 66FE            	  2516:             bne.s *                       * Check Z Flag  beq/bne
                            	  2517: 
                            	  2518: *     x.L --> n(An,Dw)
00:00001FD2 11B9000101051007	  2519: MOVE2:      move.b  $00010105,7(a0,d1.w)    * BYTE
00:00001FDA 67FE            	  2520:             beq.s *                       * Check Z Flag  beq/bne
00:00001FDC 6BFE            	  2521:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001FDE 0C30005A1007    	  2522:             cmpi.b #$5A,7(a0,d1.w)
00:00001FE4 66FE            	  2523:             bne.s *                       * Check Z Flag  beq/bne
                            	  2524: 
                            	  2525: *     x(PC,Ds) --> x.w
00:00001FE6 11FB30660100    	  2526:             move.b  MOVE1(pc,d3.w),$0100 * BYTE
00:00001FEC 67FE            	  2527:             beq.s *                       * Check Z Flag  beq/bne
00:00001FEE 6AFE            	  2528:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001FF0 0C3900B900001FD3	  2529:             cmpi.b #$B9,1+MOVE2
00:00001FF8 66FE            	  2530:             bne.s *                       * Check Z Flag  beq/bne
                            	  2531: 
                            	  2532: *     #x -->    n(An,AL)
00:00001FFA 11BC00781007    	  2533:             move.b  #$78,7(a0,d1.w)    * BYTE
00:00002000 67FE            	  2534:             beq.s *                       * Check Z Flag  beq/bne
00:00002002 6BFE            	  2535:             bmi.s *                       * Check N Flag  bmi/bpl
00:00002004 0C3000781007    	  2536:             cmpi.b #$78,7(a0,d1.w)
00:0000200A 66FE            	  2537:             bne.s *                       * Check Z Flag  beq/bne
                            	  2538: 
00:0000200C 203C11223344    	  2539:             move.l #$11223344,d0
00:00002012 223C00010100    	  2540:             move.l #$00010100,d1
00:00002018 243C8899AABB    	  2541:             move.l #$8899aabb,d2
00:0000201E 7602            	  2542:             moveq  #$00000002,d3
00:00002020 7800            	  2543:             moveq  #$00000000,d4
00:00002022 7A00            	  2544:             moveq  #$00000000,d5
00:00002024 7C00            	  2545:             moveq  #$00000000,d6
00:00002026 7E00            	  2546:             moveq  #$00000000,d7
00:00002028 91C8            	  2547:             move.l #$00000000,a0
00:0000202A 227C00010100    	  2548:             move.l #$00010100,a1
                            	  2549: 
                            	  2550: *     x(An,AL) --> x.L
00:00002030 31BC5A5A9804    	  2551:             move.w #$5A5A,4(a0,a1.l)    * WORD
00:00002036 49F09804        	  2552:             lea 4(a0,a1.l),a4
00:0000203A 33F0980400010104	  2553:             move.w 4(a0,a1.l),$00010104
00:00002042 67FE            	  2554:             beq.s *                       * Check Z Flag  beq/bne
00:00002044 6BFE            	  2555:             bmi.s *                       * Check N Flag  bmi/bpl
00:00002046 0C705A5A9804    	  2556:             cmpi.w #$5A5A,4(a0,a1.l)
00:0000204C 66FE            	  2557:             bne.s *                       * Check Z Flag  beq/bne
                            	  2558: 
                            	  2559: *     x.L --> n(An,Dw)
00:0000204E 31B9000101041006	  2560: MOVE1:      move.w  $00010104,6(a0,d1.w)    * WORD
00:00002056 67FE            	  2561:             beq.s *                       * Check Z Flag  beq/bne
00:00002058 6BFE            	  2562:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000205A 0C705A5A1006    	  2563:             cmpi.w #$5A5A,6(a0,d1.w)
00:00002060 66FE            	  2564:             bne.s *                       * Check Z Flag  beq/bne
                            	  2565: 
                            	  2566: *     x(PC,Ds) --> x.w
00:00002062 31FB30EA0100    	  2567:             move.w  MOVE1(pc,d3),$0100 * WORD
00:00002068 67FE            	  2568:             beq.s *                       * Check Z Flag  beq/bne
00:0000206A 6BFE            	  2569:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000206C 0C7967FE00002056	  2570:             cmpi.w #$67FE,8+MOVE1
00:00002074 66FE            	  2571:             bne.s *                       * Check Z Flag  beq/bne
                            	  2572: 
                            	  2573: *     #x -->    n(An,AL)
00:00002076 31BC78781006    	  2574:             move.w  #$7878,6(a0,d1.w)    * WORD
00:0000207C 67FE            	  2575:             beq.s *                       * Check Z Flag  beq/bne
00:0000207E 6BFE            	  2576:             bmi.s *                       * Check N Flag  bmi/bpl
00:00002080 0C7078781006    	  2577:             cmpi.w #$7878,6(a0,d1.w)
00:00002086 66FE            	  2578:             bne.s *                       * Check Z Flag  beq/bne
                            	  2579: 
                            	  2580: * ---
                            	  2581: 
00:00002088 203C11223344    	  2582:             move.l #$11223344,d0
00:0000208E 223C00010100    	  2583:             move.l #$00010100,d1
00:00002094 243C8899AABB    	  2584:             move.l #$8899aabb,d2
00:0000209A 7602            	  2585:             moveq  #$00000002,d3
00:0000209C 7800            	  2586:             moveq  #$00000000,d4
00:0000209E 7A00            	  2587:             moveq  #$00000000,d5
00:000020A0 7C00            	  2588:             moveq  #$00000000,d6
00:000020A2 7E00            	  2589:             moveq  #$00000000,d7
00:000020A4 91C8            	  2590:             move.l #$00000000,a0
00:000020A6 227C00010100    	  2591:             move.l #$00010100,a1
                            	  2592: 
                            	  2593: *     x(An,AL) --> x.L
00:000020AC 21BC5A5A12349804	  2594:             move.l #$5A5A1234,4(a0,a1.l)    * LONG
00:000020B4 49F09804        	  2595:             lea 4(a0,a1.l),a4
00:000020B8 23F0980400010104	  2596:             move.l 4(a0,a1.l),$00010104
00:000020C0 67FE            	  2597:             beq.s *                       * Check Z Flag  beq/bne
00:000020C2 6BFE            	  2598:             bmi.s *                       * Check N Flag  bmi/bpl
00:000020C4 0CB05A5A12349804	  2599:             cmpi.l #$5A5A1234,4(a0,a1.l)
00:000020CC 66FE            	  2600:             bne.s *                       * Check Z Flag  beq/bne
                            	  2601: 
                            	  2602: *     x.L --> n(An,Dw)
00:000020CE 21B9000101041006	  2603: MOVE3:      move.l  $00010104,6(a0,d1.w)    * LONG
00:000020D6 67FE            	  2604:             beq.s *                       * Check Z Flag  beq/bne
00:000020D8 6BFE            	  2605:             bmi.s *                       * Check N Flag  bmi/bpl
00:000020DA 0CB05A5A12341006	  2606:             cmpi.l #$5A5A1234,6(a0,d1.w)
00:000020E2 66FE            	  2607:             bne.s *                       * Check Z Flag  beq/bne
                            	  2608: 
                            	  2609: *     x(PC,Ds) --> x.w
00:000020E4 21FB30E80100    	  2610:             move.l  MOVE3(pc,d3),$0100 * LONG
00:000020EA 67FE            	  2611:             beq.s *                       * Check Z Flag  beq/bne
00:000020EC 6BFE            	  2612:             bmi.s *                       * Check N Flag  bmi/bpl
00:000020EE 0CB967FE6BFE0000	  2613:             cmpi.l #$67FE6BFE,8+MOVE3
00:000020F6 20D6
00:000020F8 66FE            	  2614:             bne.s *                       * Check Z Flag  beq/bne
                            	  2615: 
                            	  2616: *     #x -->    n(An,AL)
00:000020FA 21BC787823231006	  2617:             move.l  #$78782323,6(a0,d1.w)    * LONG
00:00002102 67FE            	  2618:             beq.s *                       * Check Z Flag  beq/bne
00:00002104 6BFE            	  2619:             bmi.s *                       * Check N Flag  bmi/bpl
00:00002106 0CB0787823231006	  2620:             cmpi.l #$78782323,6(a0,d1.w)
00:0000210E 66FE            	  2621:             bne.s *                       * Check Z Flag  beq/bne
                            	  2622: 
                            	  2623: 
00:00002110 4E75            	  2624:          rts
                            	  2625: 
                            	  2626: 
                            	  2627: *-----------------------------------------------------------
                            	  2628: *-----------------------------------------------------------
                            	  2629: * OPCODE : MOVE_xxx_FLAGS
                            	  2630: *-----------------------------------------------------------
                            	  2631: *-----------------------------------------------------------
                            	  2632: op_MOVE_xxx_FLAGS:
                            	  2633: 
                            	  2634: *     Move_To_SR
                            	  2635: 
                            	  2636: *     Dn
                            	  2637: 
00:00002112 303C2FFF        	  2638:             move.w #$2FFF,d0
00:00002116 46C0            	  2639:             move.w d0,SR
00:00002118 6AFE            	  2640:             bpl.s *           * branch if Z clear
00:0000211A 66FE            	  2641:             bne.s *           * branch if N clear
00:0000211C 68FE            	  2642:             bvc.s *           * branch if V clear
00:0000211E 64FE            	  2643:             bcc.s *           * branch if C clear
00:00002120 303C2F00        	  2644:             move.w #$2F00,d0
00:00002124 44C0            	  2645:             move d0,CCR
00:00002126 67FE            	  2646:             beq.s *           * branch if Z set
00:00002128 6BFE            	  2647:             bmi.s *           * branch if N set
00:0000212A 69FE            	  2648:             bvs.s *           * branch if V set
00:0000212C 65FE            	  2649:             bcs.s *           * branch if C set
                            	  2650: 
00:0000212E 303C2000        	  2651:             move.w #$2000,d0
00:00002132 46C0            	  2652:             move.w d0,SR
00:00002134 67FE            	  2653:             beq.s *           * branch if Z set
00:00002136 6BFE            	  2654:             bmi.s *           * branch if N set
00:00002138 69FE            	  2655:             bvs.s *           * branch if V set
00:0000213A 65FE            	  2656:             bcs.s *           * branch if C set
                            	  2657: 
                            	  2658: *     (An)
00:0000213C 307C0100        	  2659:             move.l #$00000100,a0
00:00002140 30BC2FFF        	  2660:             move.w #$2FFF,(a0)
00:00002144 46D0            	  2661:             move.w (a0),SR
00:00002146 6AFE            	  2662:             bpl.s *           * branch if Z clear
00:00002148 66FE            	  2663:             bne.s *           * branch if N clear
00:0000214A 68FE            	  2664:             bvc.s *           * branch if V clear
00:0000214C 64FE            	  2665:             bcc.s *           * branch if C clear
                            	  2666: 
00:0000214E 30BC2000        	  2667:             move.w #$2000,(a0)
00:00002152 46D0            	  2668:             move.w (a0),SR
00:00002154 67FE            	  2669:             beq.s *           * branch if Z set
00:00002156 6BFE            	  2670:             bmi.s *           * branch if N set
00:00002158 69FE            	  2671:             bvs.s *           * branch if V set
00:0000215A 65FE            	  2672:             bcs.s *           * branch if C set
                            	  2673: 
                            	  2674: *     (An)+
00:0000215C 307C0100        	  2675:             move.l #$00000100,a0
00:00002160 30BC2FFF        	  2676:             move.w #$2FFF,(a0)
00:00002164 46D8            	  2677:             move.w (a0)+,SR
00:00002166 6AFE            	  2678:             bpl.s *           * branch if Z clear
00:00002168 66FE            	  2679:             bne.s *           * branch if N clear
00:0000216A 68FE            	  2680:             bvc.s *           * branch if V clear
00:0000216C 64FE            	  2681:             bcc.s *           * branch if C clear
                            	  2682: 
00:0000216E 30BC2000        	  2683:             move.w #$2000,(a0)
00:00002172 46D8            	  2684:             move.w (a0)+,SR
00:00002174 67FE            	  2685:             beq.s *           * branch if Z set
00:00002176 6BFE            	  2686:             bmi.s *           * branch if N set
00:00002178 69FE            	  2687:             bvs.s *           * branch if V set
00:0000217A 65FE            	  2688:             bcs.s *           * branch if C set
                            	  2689: 
                            	  2690: *     -(An)
00:0000217C 307C0102        	  2691:             move.l #$00000102,a0
00:00002180 30BC2FFF        	  2692:             move.w #$2FFF,(a0)
00:00002184 46D8            	  2693:             move.w (a0)+,SR
00:00002186 6AFE            	  2694:             bpl.s *           * branch if Z clear
00:00002188 66FE            	  2695:             bne.s *           * branch if N clear
00:0000218A 68FE            	  2696:             bvc.s *           * branch if V clear
00:0000218C 64FE            	  2697:             bcc.s *           * branch if C clear
                            	  2698: 
00:0000218E 30BC2000        	  2699:             move.w #$2000,(a0)
00:00002192 46D8            	  2700:             move.w (a0)+,SR
00:00002194 67FE            	  2701:             beq.s *           * branch if Z set
00:00002196 6BFE            	  2702:             bmi.s *           * branch if N set
00:00002198 69FE            	  2703:             bvs.s *           * branch if V set
00:0000219A 65FE            	  2704:             bcs.s *           * branch if C set
                            	  2705: 
                            	  2706: *     n(An)
00:0000219C 307C0102        	  2707:             move.l #$00000102,a0
00:000021A0 317C2FFF0002    	  2708:             move.w #$2FFF,2(a0)
00:000021A6 46E80002        	  2709:             move.w 2(a0),SR
00:000021AA 6AFE            	  2710:             bpl.s *           * branch if Z clear
00:000021AC 66FE            	  2711:             bne.s *           * branch if N clear
00:000021AE 68FE            	  2712:             bvc.s *           * branch if V clear
00:000021B0 64FE            	  2713:             bcc.s *           * branch if C clear
                            	  2714: 
00:000021B2 317C20000002    	  2715:             move.w #$2000,2(a0)
00:000021B8 46E80002        	  2716:             move.w 2(a0),SR
00:000021BC 67FE            	  2717:             beq.s *           * branch if Z set
00:000021BE 6BFE            	  2718:             bmi.s *           * branch if N set
00:000021C0 69FE            	  2719:             bvs.s *           * branch if V set
00:000021C2 65FE            	  2720:             bcs.s *           * branch if C set
                            	  2721: 
                            	  2722: *     n(An,Rn.l)
00:000021C4 307C0100        	  2723:             move.l #$00000100,a0
00:000021C8 7002            	  2724:             moveq  #$00000002,d0
00:000021CA 31BC2FFF0802    	  2725:             move.w #$2FFF,2(a0,d0.l)
00:000021D0 46F00802        	  2726:             move.w 2(a0,d0.l),SR
00:000021D4 6AFE            	  2727:             bpl.s *           * branch if Z clear
00:000021D6 66FE            	  2728:             bne.s *           * branch if N clear
00:000021D8 68FE            	  2729:             bvc.s *           * branch if V clear
00:000021DA 64FE            	  2730:             bcc.s *           * branch if C clear
                            	  2731: 
00:000021DC 31BC20000802    	  2732:             move.w #$2000,2(a0,d0.l)
00:000021E2 46F00802        	  2733:             move.w 2(a0,d0.l),SR
00:000021E6 67FE            	  2734:             beq.s *           * branch if Z set
00:000021E8 6BFE            	  2735:             bmi.s *           * branch if N set
00:000021EA 69FE            	  2736:             bvs.s *           * branch if V set
00:000021EC 65FE            	  2737:             bcs.s *           * branch if C set
                            	  2738: 
                            	  2739: *     x.W
00:000021EE 31FC2FFF0100    	  2740:             move.w #$2FFF,$0100
00:000021F4 46F80100        	  2741:             move.w $0100,SR
00:000021F8 6AFE            	  2742:             bpl.s *           * branch if Z clear
00:000021FA 66FE            	  2743:             bne.s *           * branch if N clear
00:000021FC 68FE            	  2744:             bvc.s *           * branch if V clear
00:000021FE 64FE            	  2745:             bcc.s *           * branch if C clear
                            	  2746: 
00:00002200 31FC20000100    	  2747:             move.w #$2000,$0100
00:00002206 46F80100        	  2748:             move.w $0100,SR
00:0000220A 67FE            	  2749:             beq.s *           * branch if Z set
00:0000220C 6BFE            	  2750:             bmi.s *           * branch if N set
00:0000220E 69FE            	  2751:             bvs.s *           * branch if V set
00:00002210 65FE            	  2752:             bcs.s *           * branch if C set
                            	  2753: 
                            	  2754: *     x.L
00:00002212 33FC2FFF00010100	  2755:             move.w #$2FFF,$00010100
00:0000221A 46F900010100    	  2756:             move.w $00010100,SR
00:00002220 6AFE            	  2757:             bpl.s *           * branch if Z clear
00:00002222 66FE            	  2758:             bne.s *           * branch if N clear
00:00002224 68FE            	  2759:             bvc.s *           * branch if V clear
00:00002226 64FE            	  2760:             bcc.s *           * branch if C clear
                            	  2761: 
00:00002228 33FC200000010100	  2762: MOVE4:      move.w #$2000,$00010100
00:00002230 46F900010100    	  2763:             move.w $00010100,SR
00:00002236 67FE            	  2764:             beq.s *           * branch if Z set
00:00002238 6BFE            	  2765:             bmi.s *           * branch if N set
00:0000223A 69FE            	  2766:             bvs.s *           * branch if V set
00:0000223C 65FE            	  2767:             bcs.s *           * branch if C set
                            	  2768: 
                            	  2769: *     x(PC)
00:0000223E 46FAFFEA        	  2770:             move.w MOVE4+2(pc),SR
00:00002242 67FE            	  2771:             beq.s *           * branch if Z set
00:00002244 6BFE            	  2772:             bmi.s *           * branch if N set
00:00002246 69FE            	  2773:             bvs.s *           * branch if V set
00:00002248 65FE            	  2774:             bcs.s *           * branch if C set
                            	  2775: 
                            	  2776: *     x(PC,d0.l)
00:0000224A 7000            	  2777:             moveq  #$00000000,d0
00:0000224C 46FB08DC        	  2778:             move.w MOVE4+2(pc,d0.l),SR
00:00002250 67FE            	  2779:             beq.s *           * branch if Z set
00:00002252 6BFE            	  2780:             bmi.s *           * branch if N set
00:00002254 69FE            	  2781:             bvs.s *           * branch if V set
00:00002256 65FE            	  2782:             bcs.s *           * branch if C set
00:00002258 44FB08D0        	  2783:             move MOVE4+2(pc,d0.l),CCR
00:0000225C 67FE            	  2784:             beq.s *           * branch if Z set
00:0000225E 6BFE            	  2785:             bmi.s *           * branch if N set
00:00002260 69FE            	  2786:             bvs.s *           * branch if V set
00:00002262 65FE            	  2787:             bcs.s *           * branch if C set
                            	  2788: 
                            	  2789: *     #x
00:00002264 46FC2FFF        	  2790:             move.w #$2FFF,SR
00:00002268 66FE            	  2791:             bne.s *           * branch if Z clear
00:0000226A 6AFE            	  2792:             bpl.s *           * branch if N clear
00:0000226C 68FE            	  2793:             bvc.s *           * branch if V clear
00:0000226E 64FE            	  2794:             bcc.s *           * branch if C clear
                            	  2795: 
                            	  2796: 
                            	  2797: 
                            	  2798: *  MOVE_From_SR
                            	  2799: 
                            	  2800: 
                            	  2801: 
                            	  2802: *     Dn
00:00002270 46FC275A        	  2803:             move.w #$275A,SR          * Initial value
00:00002274 40C0            	  2804:             move.w SR,d0
00:00002276 0C40271A        	  2805:             cmpi.w #$271A,d0
                            	  2806: * The following fails because sr bits are implemented and non-zero so later code works.           
                            	  2807: *            bne.s *                   * branch if Z set
                            	  2808: 
                            	  2809: *     (An)
00:0000227A 307C0100        	  2810:             move.l #$00000100,a0
00:0000227E 46FC275A        	  2811:             move.w #$275A,SR          * Initial value
00:00002282 40D0            	  2812:             move.w SR,(a0)
00:00002284 0C50275A        	  2813:             cmpi.w #$275A,(a0)
00:00002288 66FE            	  2814:             bne.s *                   * branch if Z set
                            	  2815: 
                            	  2816: *     (An)+
00:0000228A 307C0100        	  2817:             move.l #$00000100,a0
00:0000228E 46FC257A        	  2818:             move.w #$257A,SR          * Initial value
00:00002292 40D8            	  2819:             move.w SR,(a0)+
00:00002294 307C0100        	  2820:             move.l #$00000100,a0
00:00002298 0C58257A        	  2821:             cmpi.w #$257A,(a0)+
00:0000229C 66FE            	  2822:             bne.s *                   * branch if Z set
                            	  2823: 
                            	  2824: *     -(An)
00:0000229E 307C0102        	  2825:             move.l #$00000102,a0
00:000022A2 46FC2766        	  2826:             move.w #$2766,SR          * Initial value
00:000022A6 40E0            	  2827:             move.w SR,-(a0)
00:000022A8 307C0100        	  2828:             move.l #$00000100,a0
00:000022AC 0C502766        	  2829:             cmpi.w #$2766,(a0)
00:000022B0 66FE            	  2830:             bne.s *                   * branch if Z set
                            	  2831: 
                            	  2832: *     x(An)
00:000022B2 307C0102        	  2833:             move.l #$00000102,a0
00:000022B6 46FC2733        	  2834:             move.w #$2733,SR          * Initial value
00:000022BA 40E80004        	  2835:             move.w SR,4(a0)
00:000022BE 0C6827330004    	  2836:             cmpi.w #$2733,4(a0)
00:000022C4 66FE            	  2837:             bne.s *                   * branch if Z set
                            	  2838: 
                            	  2839: *     x(An,rn)
00:000022C6 307C0102        	  2840:             move.l #$00000102,a0
00:000022CA 7004            	  2841:             moveq  #$00000004,d0
00:000022CC 46FC275A        	  2842:             move.w #$275a,SR          * Initial value
00:000022D0 40F00804        	  2843:             move.w SR,4(a0,d0.l)
00:000022D4 0C70275A0804    	  2844:             cmpi.w #$275a,4(a0,d0.l)
00:000022DA 66FE            	  2845:             bne.s *                   * branch if Z set
                            	  2846: 
                            	  2847: *     x.W
00:000022DC 46FC2777        	  2848:             move.w #$2777,SR          * Initial value
00:000022E0 40F80102        	  2849:             move.w SR,$0102
00:000022E4 0C7827770102    	  2850:             cmpi.w #$2777,$0102
00:000022EA 66FE            	  2851:             bne.s *                   * branch if Z set
                            	  2852: 
                            	  2853: *     x.L
00:000022EC 46FC2777        	  2854:             move.w #$2777,SR          * Initial value
00:000022F0 40F900010102    	  2855:             move.w SR,$10102
00:000022F6 0C79277700010102	  2856:             cmpi.w #$2777,$10102
00:000022FE 66FE            	  2857:             bne.s *                   * branch if Z set
                            	  2858: 
                            	  2859: 
                            	  2860: 
00:00002300 46FC2700        	  2861:             move.w #$2700,SR          * Put flags back to initial value
                            	  2862: 
00:00002304 4E75            	  2863:             rts
                            	  2864: 
                            	  2865: 
                            	  2866: *-----------------------------------------------------------
                            	  2867: *-----------------------------------------------------------
                            	  2868: * OPCODE : EXT
                            	  2869: *-----------------------------------------------------------
                            	  2870: *-----------------------------------------------------------
                            	  2871: op_EXT:
                            	  2872: 
00:00002306 707F            	  2873:             move.l #$0000007F,d0
00:00002308 223C00008FFF    	  2874:             move.l #$00008FFF,d1
00:0000230E 7400            	  2875:             moveq  #$00000000,d2
                            	  2876: 
00:00002310 4880            	  2877:             ext.w d0
00:00002312 6BFE            	  2878:             bmi.s *                   * Check N Flag  bmi/bpl
00:00002314 67FE            	  2879:             beq.s *                   * Check Z Flag  beq/bne
00:00002316 0C800000007F    	  2880:             cmpi.l #$0000007F,d0
00:0000231C 66FE            	  2881:             bne.s *                   * branch if Z set
                            	  2882: 
00:0000231E 48C1            	  2883:             ext.l d1
00:00002320 6AFE            	  2884:             bpl.s *                   * Check N Flag  bmi/bpl
00:00002322 67FE            	  2885:             beq.s *                   * Check Z Flag  beq/bne
00:00002324 0C81FFFF8FFF    	  2886:             cmpi.l #$FFFF8FFF,d1
00:0000232A 66FE            	  2887:             bne.s *                   * branch if Z set
                            	  2888: 
00:0000232C 48C2            	  2889:             ext.l d2
00:0000232E 66FE            	  2890:             bne.s *                   * Check Z Flag  beq/bne
                            	  2891: 
                            	  2892: 
                            	  2893: 
00:00002330 4E75            	  2894:             rts
                            	  2895: 
                            	  2896: 
                            	  2897: *-----------------------------------------------------------
                            	  2898: *-----------------------------------------------------------
                            	  2899: * OPCODE : SWAP
                            	  2900: *-----------------------------------------------------------
                            	  2901: *-----------------------------------------------------------
                            	  2902: op_SWAP:
                            	  2903: 
00:00002332 203C12345678    	  2904:             move.l #$12345678,d0
                            	  2905: 
00:00002338 4840            	  2906:             swap d0
00:0000233A 6BFE            	  2907:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000233C 67FE            	  2908:             beq.s *                   * Check Z Flag  beq/bne
00:0000233E 0C8056781234    	  2909:             cmpi.l #$56781234,d0
00:00002344 66FE            	  2910:             bne.s *                   * branch if Z set
                            	  2911: 
                            	  2912: 
                            	  2913: 
00:00002346 4E75            	  2914:             rts
                            	  2915: 
                            	  2916: 
                            	  2917: *-----------------------------------------------------------
                            	  2918: *-----------------------------------------------------------
                            	  2919: * OPCODE : LEA_PEA
                            	  2920: *-----------------------------------------------------------
                            	  2921: *-----------------------------------------------------------
                            	  2922: op_LEAPEA:
                            	  2923: 
00:00002348 207C00345678    	  2924:             move.l #$00345678,a0
00:0000234E 7800            	  2925:             moveq  #$00000000,d4
                            	  2926: 
                            	  2927: *     (An)
00:00002350 4DD0            	  2928:             lea (a0),a6
00:00002352 200E            	  2929:             move.l a6,d0
00:00002354 0C8000345678    	  2930:             cmpi.l #$00345678,d0
00:0000235A 66FE            	  2931:             bne.s *                   * branch if Z set
00:0000235C 4850            	  2932:             pea (a0)
00:0000235E 0C9700345678    	  2933:             cmpi.l #$00345678,(a7)
00:00002364 66FE            	  2934:             bne.s *                   * branch if Z set
                            	  2935:             * This was without a specifier which the assembler defaulted to .w
00:00002366 588F            	  2936:             addq.l #4,a7            * Restore Stack Pointer
                            	  2937: 
                            	  2938: *     x(An)
00:00002368 4DE80004        	  2939:             lea 4(a0),a6
00:0000236C 200E            	  2940:             move.l a6,d0
00:0000236E 0C800034567C    	  2941:             cmpi.l #$0034567C,d0
00:00002374 66FE            	  2942:             bne.s *                   * branch if Z set
00:00002376 48680004        	  2943:             pea 4(a0)
00:0000237A 0C970034567C    	  2944:             cmpi.l #$0034567C,(a7)
00:00002380 66FE            	  2945:             bne.s *                   * branch if Z set
                            	  2946:             * This was without a specifier which the assembler defaulted to .w
00:00002382 588F            	  2947:             addq.l #4,a7            * Restore Stack Pointer
                            	  2948: 
                            	  2949: *     x(An,Dn.l)
00:00002384 4DF04004        	  2950:             lea 4(a0,d4),a6
00:00002388 200E            	  2951:             move.l a6,d0
00:0000238A 0C800034567C    	  2952:             cmpi.l #$0034567C,d0
00:00002390 66FE            	  2953:             bne.s *                   * branch if Z set
00:00002392 48704804        	  2954:             pea 4(a0,d4.l)
00:00002396 0C970034567C    	  2955:             cmpi.l #$0034567C,(a7)
00:0000239C 66FE            	  2956:             bne.s *                   * branch if Z set
                            	  2957:             * This was without a specifier which the assembler defaulted to .w
00:0000239E 588F            	  2958:             addq.l #4,a7            * Restore Stack Pointer
                            	  2959: 
                            	  2960: *     x.W
00:000023A0 4DF81234        	  2961:             lea $1234,a6
00:000023A4 200E            	  2962:             move.l a6,d0
00:000023A6 0C401234        	  2963:             cmpi.w #$1234,d0
00:000023AA 66FE            	  2964:             bne.s *                   * branch if Z set
00:000023AC 48781234        	  2965:             pea $1234
00:000023B0 0C9700001234    	  2966:             cmpi.l #$00001234,(a7)
00:000023B6 66FE            	  2967:             bne.s *                   * branch if Z set
                            	  2968:             * This was without a specifier which the assembler defaulted to .w
00:000023B8 588F            	  2969:             addq.l #4,a7            * Restore Stack Pointer
                            	  2970: 
                            	  2971: *     x.L
00:000023BA 4DF900345678    	  2972:             lea $00345678,a6
00:000023C0 200E            	  2973:             move.l a6,d0
00:000023C2 B08E            	  2974:             cmp.l a6,d0
00:000023C4 66FE            	  2975:             bne.s *                   * branch if Z set
00:000023C6 487900345678    	  2976:             pea $00345678
00:000023CC 0C9700345678    	  2977:             cmpi.l #$00345678,(a7)
00:000023D2 66FE            	  2978:             bne.s *                   * branch if Z set
                            	  2979:             * This was without a specifier which the assembler defaulted to .w
00:000023D4 588F            	  2980:             addq.l #4,a7            * Restore Stack Pointer
                            	  2981: 
                            	  2982: *     x(PC)
00:000023D6 4DFA0008        	  2983:             lea LEA1(pc),a6
00:000023DA 200E            	  2984:             move.l a6,d0
00:000023DC B08E            	  2985:             cmp.l a6,d0
00:000023DE 66FE            	  2986:             bne.s *                   * branch if Z set
00:000023E0 487AFFFE        	  2987: LEA1:       pea LEA1(pc)
00:000023E4 0C970000241E    	  2988:             cmpi.l #$0000241E,(a7)
00:000023EA 67FE            	  2989:             beq.s *                   * branch if Z clear
                            	  2990:             * This was without a specifier which the assembler defaulted to .w
00:000023EC 588F            	  2991:             addq.l #4,a7              * Restore Stack Pointer
                            	  2992: 
                            	  2993: 
                            	  2994: 
                            	  2995: 
00:000023EE 46FC2700        	  2996:             move.w #$2700,sr          * Put flags back to initial value
                            	  2997: 
00:000023F2 4E75            	  2998:             rts
                            	  2999:  	
                            	  3000: 
                            	  3001: 
                            	  3002: *-----------------------------------------------------------
                            	  3003: *-----------------------------------------------------------
                            	  3004: * OPCODE : LEA_TAS
                            	  3005: *-----------------------------------------------------------
                            	  3006: *-----------------------------------------------------------
                            	  3007: op_TAS:
                            	  3008: 
                            	  3009: *     Test just one addressing mode
                            	  3010: 
00:000023F4 307C0100        	  3011:             move.l #$00000100,a0
                            	  3012: 
                            	  3013: *     (An)
00:000023F8 4210            	  3014:             move.b #$00,(a0)
00:000023FA 6BFE            	  3015:             bmi.s *                   * Check N Flag  bmi/bpl
00:000023FC 66FE            	  3016:             bne.s *                   * Check Z Flag  beq/bne
00:000023FE 4AD0            	  3017:             tas (a0)
00:00002400 0C100080        	  3018:             cmpi.b #$80,(a0)
00:00002404 66FE            	  3019:             bne.s *                   * branch if Z set
00:00002406 10BC00F5        	  3020:             move.b #$F5,(a0)
00:0000240A 4AD0            	  3021:             tas (a0)
00:0000240C 6AFE            	  3022:             bpl.s *                   * Check N Flag  bmi/bpl
00:0000240E 67FE            	  3023:             beq.s *                   * Check Z Flag  beq/bne
00:00002410 4AD0            	  3024:             tas (a0)
00:00002412 0C1000F5        	  3025:             cmpi.b #$F5,(a0)
00:00002416 66FE            	  3026:             bne.s *                   * branch if Z set
                            	  3027: 
00:00002418 4E75            	  3028:             rts
                            	  3029: 
                            	  3030: 
                            	  3031: *-----------------------------------------------------------
                            	  3032: *-----------------------------------------------------------
                            	  3033: * OPCODE : LEA_TST
                            	  3034: *-----------------------------------------------------------
                            	  3035: *-----------------------------------------------------------
                            	  3036: op_TST:
                            	  3037: 
                            	  3038: *     Test just one addressing mode
                            	  3039: 
00:0000241A 307C0100        	  3040:             move.l #$00000100,a0
                            	  3041: 
                            	  3042: *     (An) - BYTE
00:0000241E 4210            	  3043:             move.b #$00,(a0)
00:00002420 4A10            	  3044:             tst.b (a0)
00:00002422 6BFE            	  3045:             bmi.s *                   * Check N Flag  bmi/bpl
00:00002424 66FE            	  3046:             bne.s *                   * Check Z Flag  beq/bne
00:00002426 10BC00F5        	  3047:             move.b #$F5,(a0)
00:0000242A 4A10            	  3048:             tst.b (a0)
00:0000242C 6AFE            	  3049:             bpl.s *                   * Check N Flag  bmi/bpl
00:0000242E 67FE            	  3050:             beq.s *                   * Check Z Flag  beq/bne
                            	  3051: 
                            	  3052: *     (An) - WORD
00:00002430 4250            	  3053:             move.w #$0000,(a0)
00:00002432 4A50            	  3054:             tst.w (a0)
00:00002434 6BFE            	  3055:             bmi.s *                   * Check N Flag  bmi/bpl
00:00002436 66FE            	  3056:             bne.s *                   * Check Z Flag  beq/bne
00:00002438 30BCF567        	  3057:             move.w #$F567,(a0)
00:0000243C 4A50            	  3058:             tst.w (a0)
00:0000243E 6AFE            	  3059:             bpl.s *                   * Check N Flag  bmi/bpl
00:00002440 67FE            	  3060:             beq.s *                   * Check Z Flag  beq/bne
                            	  3061: 
                            	  3062: *     (An) - LONG
00:00002442 4290            	  3063:             move.l #$00000000,(a0)
00:00002444 4A90            	  3064:             tst.l (a0)
00:00002446 6BFE            	  3065:             bmi.s *                   * Check N Flag  bmi/bpl
00:00002448 66FE            	  3066:             bne.s *                   * Check Z Flag  beq/bne
00:0000244A 20BCF56789AB    	  3067:             move.l #$F56789ab,(a0)
00:00002450 4A90            	  3068:             tst.l (a0)
00:00002452 6AFE            	  3069:             bpl.s *                   * Check N Flag  bmi/bpl
00:00002454 67FE            	  3070:             beq.s *                   * Check Z Flag  beq/bne
                            	  3071: 
                            	  3072: 
00:00002456 4E75            	  3073:             rts
                            	  3074: 
                            	  3075: 
                            	  3076: *-----------------------------------------------------------
                            	  3077: *-----------------------------------------------------------
                            	  3078: * OPCODE : LINKS
                            	  3079: *-----------------------------------------------------------
                            	  3080: *-----------------------------------------------------------
                            	  3081: op_LINKS:
                            	  3082: 
00:00002458 207C11223344    	  3083:             move.l #$11223344,a0
00:0000245E 203C11223344    	  3084:             move.l #$11223344,d0
00:00002464 4E500000        	  3085:             link a0,#$0
00:00002468 0C9711223344    	  3086:             cmpi.l #$11223344,(a7)
                            	  3087: 
00:0000246E 4E58            	  3088:             unlk a0
00:00002470 B1C0            	  3089:             cmp.l d0,a0
00:00002472 66FE            	  3090:             bne.s *                   * branch if Z set
                            	  3091: 
00:00002474 4E75            	  3092:             rts
                            	  3093: 
                            	  3094: *-----------------------------------------------------------
                            	  3095: *-----------------------------------------------------------
                            	  3096: * OPCODE : MOVE_USP
                            	  3097: *-----------------------------------------------------------
                            	  3098: *-----------------------------------------------------------
                            	  3099: op_MOVE_USP:
                            	  3100: 
00:00002476 207C11223344    	  3101:             move.l #$11223344,a0
00:0000247C 4E60            	  3102:             move a0,USP
00:0000247E 4E69            	  3103:             move USP,a1
00:00002480 B3C8            	  3104:             cmp.l a0,a1
00:00002482 66FE            	  3105:             bne.s *                   * branch if Z set
                            	  3106: 
00:00002484 4E75            	  3107:             rts
                            	  3108: 
                            	  3109: 
                            	  3110: *-----------------------------------------------------------
                            	  3111: *-----------------------------------------------------------
                            	  3112: * OPCODE : CHK
                            	  3113: *-----------------------------------------------------------
                            	  3114: *-----------------------------------------------------------
                            	  3115: 
                            	  3116: op_CHK:
                            	  3117: 
00:00002486 20780018        	  3118: 	move.l 6*4,a0							; get check vector
00:0000248A 21FC0000090A0018	  3119: 	move.l #EXCEPTION_6,6*4		; set vector
00:00002492 303C1122        	  3120: 	move.w #$1122,d0
00:00002496 323C1122        	  3121: 	move.w #$1122,d1
00:0000249A 4380            	  3122: 	chk d0,d1
                            	  3123: 
00:0000249C 4E71            	  3124: 	nop
00:0000249E 4E71            	  3125: 	nop
                            	  3126: 
00:000024A0 323C1122        	  3127: 	move.w #$1122,d1
00:000024A4 43BC1122        	  3128: 	chk #$1122,d1
                            	  3129: 
00:000024A8 323C1122        	  3130: 	move.w #$1122,d1
00:000024AC 43BC007A        	  3131: 	chk #00122,d1
00:000024B0 BCBCEEEE0006    	  3132: 	cmp.l #$EEEE0006,d6
00:000024B6 66FE            	  3133: 	bne.s *                   ; branch if Z set
                            	  3134: 
00:000024B8 303C1122        	  3135: 	move.w #$1122,d0
00:000024BC 323C8000        	  3136: 	move.w #$8000,d1
00:000024C0 4380            	  3137: 	chk d0,d1
00:000024C2 BCBCEEEE0006    	  3138: 	cmp.l #$EEEE0006,d6
00:000024C8 66FE            	  3139: 	bne.s *                   ; branch if Z set
                            	  3140: 
00:000024CA 21C80018        	  3141: 	move.l a0,6*4							; restore old vector
00:000024CE 4E75            	  3142: 	rts
                            	  3143: 
                            	  3144: 
                            	  3145: *-----------------------------------------------------------
                            	  3146: *-----------------------------------------------------------
                            	  3147: * OPCODE : NEGS
                            	  3148: *-----------------------------------------------------------
                            	  3149: *-----------------------------------------------------------
                            	  3150: op_NEGS:
                            	  3151: 
                            	  3152: *     NOT - BYTE
00:000024D0 307C0100        	  3153:             move.l #$00000100,a0
00:000024D4 7000            	  3154:             moveq  #$00000000,d0
00:000024D6 4600            	  3155:             not.b d0
00:000024D8 6AFE            	  3156:             bpl.s *                   * Check N Flag  bmi/bpl
00:000024DA 67FE            	  3157:             beq.s *                   * Check Z Flag  beq/bne
00:000024DC 4600            	  3158:             not.b d0
00:000024DE 6BFE            	  3159:             bmi.s *                   * Check N Flag  bmi/bpl
00:000024E0 66FE            	  3160:             bne.s *                   * Check Z Flag  beq/bne
00:000024E2 4A00            	  3161:             cmpi.b #$00,d0
00:000024E4 66FE            	  3162:             bne.s *                   * Check Z Flag  beq/bne
00:000024E6 10BC0080        	  3163:             move.b #$80,(a0)
00:000024EA 4610            	  3164:             not.b (a0)
00:000024EC 6BFE            	  3165:             bmi.s *                   * Check N Flag  bmi/bpl
00:000024EE 67FE            	  3166:             beq.s *                   * Check Z Flag  beq/bne
00:000024F0 4610            	  3167:             not.b (a0)
00:000024F2 6AFE            	  3168:             bpl.s *                   * Check N Flag  bmi/bpl
00:000024F4 67FE            	  3169:             beq.s *                   * Check Z Flag  beq/bne
00:000024F6 0C100080        	  3170:             cmpi.b #$80,(a0)
00:000024FA 66FE            	  3171:             bne.s *                   * Check Z Flag  beq/bne
                            	  3172: 
                            	  3173: *     NOT - WORD
00:000024FC 307C0100        	  3174:             move.l #$00000100,a0
00:00002500 7000            	  3175:             moveq  #$00000000,d0
00:00002502 4640            	  3176:             not.w d0
00:00002504 6AFE            	  3177:             bpl.s *                   * Check N Flag  bmi/bpl
00:00002506 67FE            	  3178:             beq.s *                   * Check Z Flag  beq/bne
00:00002508 4640            	  3179:             not.w d0
00:0000250A 6BFE            	  3180:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000250C 66FE            	  3181:             bne.s *                   * Check Z Flag  beq/bne
00:0000250E 4A40            	  3182:             cmpi.w #$0000,d0
00:00002510 66FE            	  3183:             bne.s *                   * Check Z Flag  beq/bne
00:00002512 30BC5A5A        	  3184:             move.w #$5a5a,(a0)
00:00002516 4650            	  3185:             not.w (a0)
00:00002518 6AFE            	  3186:             bpl.s *                   * Check N Flag  bmi/bpl
00:0000251A 67FE            	  3187:             beq.s *                   * Check Z Flag  beq/bne
00:0000251C 4650            	  3188:             not.w (a0)
00:0000251E 6BFE            	  3189:             bmi.s *                   * Check N Flag  bmi/bpl
00:00002520 67FE            	  3190:             beq.s *                   * Check Z Flag  beq/bne
00:00002522 0C505A5A        	  3191:             cmpi.w #$5a5a,(a0)
00:00002526 66FE            	  3192:             bne.s *                   * Check Z Flag  beq/bne
                            	  3193: 
                            	  3194: *     NOT - LONG
00:00002528 307C0100        	  3195:             move.l #$00000100,a0
00:0000252C 7000            	  3196:             moveq  #$00000000,d0
00:0000252E 4680            	  3197:             not.l d0
00:00002530 6AFE            	  3198:             bpl.s *                   * Check N Flag  bmi/bpl
00:00002532 67FE            	  3199:             beq.s *                   * Check Z Flag  beq/bne
00:00002534 4680            	  3200:             not.l d0
00:00002536 6BFE            	  3201:             bmi.s *                   * Check N Flag  bmi/bpl
00:00002538 66FE            	  3202:             bne.s *                   * Check Z Flag  beq/bne
00:0000253A 4A80            	  3203:             cmpi.l #$00000000,d0
00:0000253C 66FE            	  3204:             bne.s *                   * Check Z Flag  beq/bne
00:0000253E 20BC5A5A1234    	  3205:             move.l #$5a5a1234,(a0)
00:00002544 4690            	  3206:             not.l (a0)
00:00002546 6AFE            	  3207:             bpl.s *                   * Check N Flag  bmi/bpl
00:00002548 67FE            	  3208:             beq.s *                   * Check Z Flag  beq/bne
00:0000254A 4690            	  3209:             not.l (a0)
00:0000254C 6BFE            	  3210:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000254E 67FE            	  3211:             beq.s *                   * Check Z Flag  beq/bne
00:00002550 0C905A5A1234    	  3212:             cmpi.l #$5a5a1234,(a0)
00:00002556 66FE            	  3213:             bne.s *                   * Check Z Flag  beq/bne
                            	  3214: 
                            	  3215: * -----
                            	  3216: 
                            	  3217: *     NEG - BYTE
00:00002558 307C0100        	  3218:             move.l #$00000100,a0
00:0000255C 7000            	  3219:             moveq  #$00000000,d0
00:0000255E 7240D241        	  3220:             move.l #$00000080,d1
00:00002562 4400            	  3221:             neg.b d0
00:00002564 6BFE            	  3222:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00002566 66FE            	  3223:             bne.s *                   * Check Z Flag  beq/bne 1
00:00002568 65FE            	  3224:             bcs.s *                   * Check C Flag  bcc/bcs 1
00:0000256A 69FE            	  3225:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000256C 4401            	  3226:             neg.b d1
00:0000256E 6AFE            	  3227:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00002570 67FE            	  3228:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002572 64FE            	  3229:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002574 68FE            	  3230:             bvc.s *                   * Check V Flag  bvc/bvs 0
00:00002576 0C010080        	  3231:             cmpi.b #$80,d1
00:0000257A 66FE            	  3232:             bne.s *                   * Check Z Flag  beq/bne
00:0000257C 10BC007F        	  3233:             move.b #$7F,(a0)
00:00002580 4410            	  3234:             neg.b (a0)
00:00002582 6AFE            	  3235:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00002584 67FE            	  3236:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002586 64FE            	  3237:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002588 69FE            	  3238:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000258A 10BC00F5        	  3239:             move.b #$F5,(a0)
00:0000258E 4410            	  3240:             neg.b (a0)
00:00002590 6BFE            	  3241:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00002592 67FE            	  3242:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002594 64FE            	  3243:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002596 69FE            	  3244:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002598 0C10000B        	  3245:             cmpi.b #$0B,(a0)
00:0000259C 66FE            	  3246:             bne.s *                   * Check Z Flag  beq/bne
                            	  3247: 
                            	  3248: * -----
                            	  3249: 
                            	  3250: *     NEG - WORD
00:0000259E 307C0100        	  3251:             move.l #$00000100,a0
00:000025A2 7000            	  3252:             moveq  #$00000000,d0
00:000025A4 223C00008000    	  3253:             move.l #$00008000,d1
00:000025AA 4440            	  3254:             neg.w d0
00:000025AC 6BFE            	  3255:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000025AE 66FE            	  3256:             bne.s *                   * Check Z Flag  beq/bne 1
00:000025B0 65FE            	  3257:             bcs.s *                   * Check C Flag  bcc/bcs 1
00:000025B2 69FE            	  3258:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000025B4 4441            	  3259:             neg.w d1
00:000025B6 6AFE            	  3260:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000025B8 67FE            	  3261:             beq.s *                   * Check Z Flag  beq/bne 0
00:000025BA 64FE            	  3262:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000025BC 68FE            	  3263:             bvc.s *                   * Check V Flag  bvc/bvs 0
00:000025BE 0C418000        	  3264:             cmpi.w #$8000,d1
00:000025C2 66FE            	  3265:             bne.s *                   * Check Z Flag  beq/bne
00:000025C4 30BC7FFF        	  3266:             move.w #$7FFF,(a0)
00:000025C8 4450            	  3267:             neg.w (a0)
00:000025CA 6AFE            	  3268:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000025CC 67FE            	  3269:             beq.s *                   * Check Z Flag  beq/bne 0
00:000025CE 64FE            	  3270:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000025D0 69FE            	  3271:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000025D2 30BCF578        	  3272:             move.w #$F578,(a0)
00:000025D6 4450            	  3273:             neg.w (a0)
00:000025D8 6BFE            	  3274:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000025DA 67FE            	  3275:             beq.s *                   * Check Z Flag  beq/bne 0
00:000025DC 64FE            	  3276:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000025DE 69FE            	  3277:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000025E0 0C500A88        	  3278:             cmpi.w #$0A88,(a0)
00:000025E4 66FE            	  3279:             bne.s *                   * Check Z Flag  beq/bne
                            	  3280: 
                            	  3281: * -----
                            	  3282: 
                            	  3283: *     NEG - LONG
00:000025E6 307C0100        	  3284:             move.l #$00000100,a0
00:000025EA 7000            	  3285:             moveq  #$00000000,d0
00:000025EC 223C80000000    	  3286:             move.l #$80000000,d1
00:000025F2 4480            	  3287:             neg.l d0
00:000025F4 6BFE            	  3288:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000025F6 66FE            	  3289:             bne.s *                   * Check Z Flag  beq/bne 1
00:000025F8 65FE            	  3290:             bcs.s *                   * Check C Flag  bcc/bcs 1
00:000025FA 69FE            	  3291:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000025FC 4481            	  3292:             neg.l d1
00:000025FE 6AFE            	  3293:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00002600 67FE            	  3294:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002602 64FE            	  3295:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002604 68FE            	  3296:             bvc.s *                   * Check V Flag  bvc/bvs 0
00:00002606 0C8180000000    	  3297:             cmpi.l #$80000000,d1
00:0000260C 66FE            	  3298:             bne.s *                   * Check Z Flag  beq/bne
00:0000260E 20BC7FFFFFFF    	  3299:             move.l #$7FFFFFFF,(a0)
00:00002614 4490            	  3300:             neg.l (a0)
00:00002616 6AFE            	  3301:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00002618 67FE            	  3302:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000261A 64FE            	  3303:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000261C 69FE            	  3304:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000261E 20BCF5781234    	  3305:             move.l #$F5781234,(a0)
00:00002624 4490            	  3306:             neg.l (a0)
00:00002626 6BFE            	  3307:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00002628 67FE            	  3308:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000262A 64FE            	  3309:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000262C 69FE            	  3310:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000262E 0C900A87EDCC    	  3311:             cmpi.l #$0A87EDCC,(a0)
00:00002634 66FE            	  3312:             bne.s *                   * Check Z Flag  beq/bne
                            	  3313: 
                            	  3314: 
                            	  3315: * -----
                            	  3316: 
                            	  3317: *     NEGX - BYTE
00:00002636 307C0100        	  3318:             move.l #$00000100,a0
00:0000263A 7000            	  3319:             moveq  #$00000000,d0
00:0000263C 7240D241        	  3320:             move.l #$00000080,d1
00:00002640 003C0010        	  3321:             ori.b #$10,CCR        * Set X Flag
00:00002644 4000            	  3322:             negx.b d0
00:00002646 6AFE            	  3323:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:00002648 67FE            	  3324:             beq.s *                   * Check Z Flag  beq/bne 1
00:0000264A 64FE            	  3325:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:0000264C 69FE            	  3326:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000264E 023C00EF        	  3327:             andi.b #$EF,CCR       * Clear X Flag
00:00002652 4000            	  3328:             negx.b d0
00:00002654 6BFE            	  3329:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00002656 67FE            	  3330:             beq.s *                   * Check Z Flag  beq/bne 1
00:00002658 64FE            	  3331:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:0000265A 69FE            	  3332:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000265C 003C0010        	  3333:             ori.b #$10,CCR        * Set X Flag
00:00002660 4001            	  3334:             negx.b d1
00:00002662 6BFE            	  3335:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:00002664 67FE            	  3336:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002666 64FE            	  3337:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002668 69FE            	  3338:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:0000266A 0C01007F        	  3339:             cmpi.b #$7F,d1
00:0000266E 66FE            	  3340:             bne.s *                   * Check Z Flag  beq/bne
00:00002670 023C00EF        	  3341:             andi.b #$EF,CCR       * Clear X Flag
00:00002674 4001            	  3342:             negx.b d1
00:00002676 6AFE            	  3343:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00002678 67FE            	  3344:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000267A 64FE            	  3345:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000267C 69FE            	  3346:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:0000267E 0C010081        	  3347:             cmpi.b #$81,d1
00:00002682 66FE            	  3348:             bne.s *                   * Check Z Flag  beq/bne
00:00002684 10BC007F        	  3349:             move.b #$7F,(a0)
00:00002688 003C0010        	  3350:             ori.b #$10,CCR        * Set X Flag
00:0000268C 4010            	  3351:             negx.b (a0)
00:0000268E 6AFE            	  3352:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00002690 67FE            	  3353:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002692 64FE            	  3354:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3355:             * I think overflow should happen here.
                            	  3356: *            bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002694 10BC007F        	  3357:             move.b #$7F,(a0)
00:00002698 023C00EF        	  3358:             andi.b #$EF,CCR       * Clear X Flag
00:0000269C 4010            	  3359:             negx.b (a0)
00:0000269E 6AFE            	  3360:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000026A0 67FE            	  3361:             beq.s *                   * Check Z Flag  beq/bne 0
00:000026A2 64FE            	  3362:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000026A4 69FE            	  3363:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000026A6 10BC00F5        	  3364:             move.b #$F5,(a0)
00:000026AA 003C0010        	  3365:             ori.b #$10,CCR        * Set X Flag
00:000026AE 4010            	  3366:             negx.b (a0)
00:000026B0 6BFE            	  3367:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000026B2 67FE            	  3368:             beq.s *                   * Check Z Flag  beq/bne 0
00:000026B4 64FE            	  3369:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000026B6 69FE            	  3370:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000026B8 0C10000A        	  3371:             cmpi.b #$0A,(a0)
00:000026BC 66FE            	  3372:             bne.s *                   * Check Z Flag  beq/bne
00:000026BE 023C00EF        	  3373:             andi.b #$EF,CCR       * Clear X Flag
00:000026C2 4010            	  3374:             negx.b (a0)
00:000026C4 6AFE            	  3375:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:000026C6 67FE            	  3376:             beq.s *                   * Check Z Flag  beq/bne 0
00:000026C8 64FE            	  3377:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000026CA 69FE            	  3378:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000026CC 0C1000F6        	  3379:             cmpi.b #$F6,(a0)
00:000026D0 66FE            	  3380:             bne.s *                   * Check Z Flag  beq/bne
                            	  3381: 
                            	  3382: 
                            	  3383: 
                            	  3384: * -----
                            	  3385: 
                            	  3386: *     NEGX - WORD
00:000026D2 307C0100        	  3387:             move.l #$00000100,a0
00:000026D6 7000            	  3388:             moveq  #$00000000,d0
00:000026D8 223C00008000    	  3389:             move.l #$00008000,d1
00:000026DE 003C0010        	  3390:             ori.b #$10,CCR        * Set X Flag
00:000026E2 4040            	  3391:             negx.w d0
00:000026E4 6AFE            	  3392:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:000026E6 67FE            	  3393:             beq.s *                   * Check Z Flag  beq/bne 1
00:000026E8 64FE            	  3394:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:000026EA 69FE            	  3395:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000026EC 023C00EF        	  3396:             andi.b #$EF,CCR       * Clear X Flag
00:000026F0 4040            	  3397:             negx.w d0
00:000026F2 6BFE            	  3398:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000026F4 67FE            	  3399:             beq.s *                   * Check Z Flag  beq/bne 1
00:000026F6 64FE            	  3400:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:000026F8 69FE            	  3401:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000026FA 003C0010        	  3402:             ori.b #$10,CCR        * Set X Flag
00:000026FE 4041            	  3403:             negx.w d1
00:00002700 6BFE            	  3404:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:00002702 67FE            	  3405:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002704 64FE            	  3406:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002706 69FE            	  3407:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:00002708 0C417FFF        	  3408:             cmpi.w #$7FFF,d1
00:0000270C 66FE            	  3409:             bne.s *                   * Check Z Flag  beq/bne
00:0000270E 023C00EF        	  3410:             andi.b #$EF,CCR       * Clear X Flag
00:00002712 4041            	  3411:             negx.w d1
00:00002714 6AFE            	  3412:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00002716 67FE            	  3413:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002718 64FE            	  3414:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000271A 69FE            	  3415:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:0000271C 0C418001        	  3416:             cmpi.w #$8001,d1
00:00002720 66FE            	  3417:             bne.s *                   * Check Z Flag  beq/bne
00:00002722 30BC7FFF        	  3418:             move.w #$7FFF,(a0)
00:00002726 003C0010        	  3419:             ori.b #$10,CCR        * Set X Flag
00:0000272A 4050            	  3420:             negx.w (a0)
00:0000272C 6AFE            	  3421:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:0000272E 67FE            	  3422:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002730 64FE            	  3423:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3424: ***            
                            	  3425: *            bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002732 30BCF567        	  3426:             move.w #$F567,(a0)
00:00002736 023C00EF        	  3427:             andi.b #$EF,CCR       * Clear X Flag
00:0000273A 4050            	  3428:             negx.w (a0)
00:0000273C 6BFE            	  3429:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:0000273E 67FE            	  3430:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002740 64FE            	  3431:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002742 69FE            	  3432:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002744 30BCF567        	  3433:             move.w #$F567,(a0)
00:00002748 003C0010        	  3434:             ori.b #$10,CCR        * Set X Flag
00:0000274C 4050            	  3435:             negx.w (a0)
00:0000274E 6BFE            	  3436:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00002750 67FE            	  3437:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002752 64FE            	  3438:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002754 69FE            	  3439:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002756 0C500A98        	  3440:             cmpi.w #$0A98,(a0)
00:0000275A 66FE            	  3441:             bne.s *                   * Check Z Flag  beq/bne
00:0000275C 023C00EF        	  3442:             andi.b #$EF,CCR       * Clear X Flag
00:00002760 4050            	  3443:             negx.w (a0)
00:00002762 6AFE            	  3444:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:00002764 67FE            	  3445:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002766 64FE            	  3446:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002768 69FE            	  3447:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000276A 0C50F568        	  3448:             cmpi.w #$F568,(a0)
00:0000276E 66FE            	  3449:             bne.s *                   * Check Z Flag  beq/bne
                            	  3450: 
                            	  3451: 
                            	  3452: * -----
                            	  3453: 
                            	  3454: *     NEGX - LONG
00:00002770 307C0100        	  3455:             move.l #$00000100,a0
00:00002774 7000            	  3456:             moveq  #$00000000,d0
00:00002776 223C80000000    	  3457:             move.l #$80000000,d1
00:0000277C 003C0010        	  3458:             ori.b #$10,CCR        * Set X Flag
00:00002780 4080            	  3459:             negx.l d0
00:00002782 6AFE            	  3460:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:00002784 67FE            	  3461:             beq.s *                   * Check Z Flag  beq/bne 1
00:00002786 64FE            	  3462:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:00002788 69FE            	  3463:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000278A 023C00EF        	  3464:             andi.b #$EF,CCR       * Clear X Flag
00:0000278E 4080            	  3465:             negx.l d0
00:00002790 6BFE            	  3466:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00002792 67FE            	  3467:             beq.s *                   * Check Z Flag  beq/bne 1
00:00002794 64FE            	  3468:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:00002796 69FE            	  3469:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002798 003C0010        	  3470:             ori.b #$10,CCR        * Set X Flag
00:0000279C 4081            	  3471:             negx.l d1
00:0000279E 6BFE            	  3472:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:000027A0 67FE            	  3473:             beq.s *                   * Check Z Flag  beq/bne 0
00:000027A2 64FE            	  3474:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000027A4 69FE            	  3475:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:000027A6 0C817FFFFFFF    	  3476:             cmpi.l #$7FFFFFFF,d1
00:000027AC 66FE            	  3477:             bne.s *                   * Check Z Flag  beq/bne
00:000027AE 023C00EF        	  3478:             andi.b #$EF,CCR       * Clear X Flag
00:000027B2 4081            	  3479:             negx.l d1
00:000027B4 6AFE            	  3480:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000027B6 67FE            	  3481:             beq.s *                   * Check Z Flag  beq/bne 0
00:000027B8 64FE            	  3482:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3483: ****            
                            	  3484: *            bvs.s *                   * Check V Flag  bvc/bvs 0
00:000027BA 0C8180000001    	  3485:             cmpi.l #$80000001,d1
00:000027C0 66FE            	  3486:             bne.s *                   * Check Z Flag  beq/bne
00:000027C2 20BC00007FFF    	  3487:             move.l #$7FFF,(a0)
00:000027C8 003C0010        	  3488:             ori.b #$10,CCR        * Set X Flag
00:000027CC 4090            	  3489:             negx.l (a0)
00:000027CE 6AFE            	  3490:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000027D0 67FE            	  3491:             beq.s *                   * Check Z Flag  beq/bne 0
00:000027D2 64FE            	  3492:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3493: ****            
                            	  3494: *            bvs.s *                   * Check V Flag  bvc/bvs 1
00:000027D4 20BCF5671234    	  3495:             move.l #$F5671234,(a0)
00:000027DA 023C00EF        	  3496:             andi.b #$EF,CCR       * Clear X Flag
00:000027DE 4090            	  3497:             negx.l (a0)
00:000027E0 6BFE            	  3498:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:000027E2 67FE            	  3499:             beq.s *                   * Check Z Flag  beq/bne 0
00:000027E4 64FE            	  3500:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000027E6 69FE            	  3501:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000027E8 20BCF5675678    	  3502:             move.l #$F5675678,(a0)
00:000027EE 003C0010        	  3503:             ori.b #$10,CCR        * Set X Flag
00:000027F2 4090            	  3504:             negx.l (a0)
00:000027F4 6BFE            	  3505:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000027F6 67FE            	  3506:             beq.s *                   * Check Z Flag  beq/bne 0
00:000027F8 64FE            	  3507:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000027FA 69FE            	  3508:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000027FC 0C900A98A987    	  3509:             cmpi.l #$0A98A987,(a0)
00:00002802 66FE            	  3510:             bne.s *                   * Check Z Flag  beq/bne
00:00002804 023C00EF        	  3511:             andi.b #$EF,CCR       * Clear X Flag
00:00002808 4090            	  3512:             negx.l (a0)
00:0000280A 6AFE            	  3513:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:0000280C 67FE            	  3514:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000280E 64FE            	  3515:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002810 69FE            	  3516:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002812 0C90F5675679    	  3517:             cmpi.l #$F5675679,(a0)
00:00002818 66FE            	  3518:             bne.s *                   * Check Z Flag  beq/bne
                            	  3519: 
                            	  3520: 
                            	  3521: * -----
                            	  3522: 
                            	  3523: *     CLR - BYTE
00:0000281A 307C0100        	  3524:             move.l #$00000100,a0
00:0000281E 203C12345678    	  3525:             move.l #$12345678,d0
00:00002824 223C12345678    	  3526:             move.l #$12345678,d1
00:0000282A 243C12345678    	  3527:             move.l #$12345678,d2
00:00002830 283C12345600    	  3528:             move.l #$12345600,d4
00:00002836 2A3C12340000    	  3529:             move.l #$12340000,d5
00:0000283C 7C00            	  3530:             moveq  #$00000000,d6
                            	  3531: 
00:0000283E 4200            	  3532:             clr.b d0
00:00002840 66FE            	  3533:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002842 6BFE            	  3534:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00002844 B880            	  3535:             cmp.l d0,d4
00:00002846 66FE            	  3536:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3537: 
00:00002848 4241            	  3538:             clr.w d1
00:0000284A 66FE            	  3539:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000284C 6BFE            	  3540:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:0000284E BA81            	  3541:             cmp.l d1,d5
00:00002850 66FE            	  3542:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3543: 
00:00002852 7400            	  3544:             clr.l d2
00:00002854 66FE            	  3545:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002856 6BFE            	  3546:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00002858 BC82            	  3547:             cmp.l d2,d6
00:0000285A 66FE            	  3548:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3549: 
00:0000285C 4E75            	  3550:             rts
                            	  3551: 
                            	  3552: 
                            	  3553: 
                            	  3554: *-----------------------------------------------------------
                            	  3555: *-----------------------------------------------------------
                            	  3556: * OPCODE : MOVEM
                            	  3557: *-----------------------------------------------------------
                            	  3558: *-----------------------------------------------------------
                            	  3559: op_MOVEM:
                            	  3560: 
                            	  3561: *     WORD  Registers --> Memory
00:0000285E 203C0000D0D0    	  3562:             move.l #$0000d0d0,d0
00:00002864 223C0000D1D1    	  3563:             move.l #$0000d1d1,d1
00:0000286A 243C0000D2D2    	  3564:             move.l #$0000d2d2,d2
00:00002870 263C0000D3D3    	  3565:             move.l #$0000d3d3,d3
00:00002876 283C0000D4D4    	  3566:             move.l #$0000d4d4,d4
00:0000287C 2A3C0000D5D5    	  3567:             move.l #$0000d5d5,d5
00:00002882 2C3C0000D6D6    	  3568:             move.l #$0000d6d6,d6
00:00002888 2E3C0000D7D7    	  3569:             move.l #$0000d7d7,d7
00:0000288E 307C0A0A        	  3570:             move.l #$00000a0a,a0
00:00002892 327C1A1A        	  3571:             move.l #$00001a1a,a1
00:00002896 347C2A2A        	  3572:             move.l #$00002a2a,a2
00:0000289A 367C3A3A        	  3573:             move.l #$00003a3a,a3
00:0000289E 387C4A4A        	  3574:             move.l #$00004a4a,a4
00:000028A2 3A7C5A5A        	  3575:             move.l #$00005a5a,a5
00:000028A6 3C7C6A6A        	  3576:             move.l #$00006a6a,a6
                            	  3577: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3578: 
00:000028AA 48B8FFFF0100    	  3579:             movem.w D0-D7/A0-A7,$00000100
                            	  3580: 
00:000028B0 307C0100        	  3581:             move.l #$00000100,a0
                            	  3582: 
00:000028B4 B058            	  3583:             cmp.w (a0)+,d0
00:000028B6 66FE            	  3584:             bne.s *                   * Check Z Flag  beq/bne 0
00:000028B8 B258            	  3585:             cmp.w (a0)+,d1
00:000028BA 66FE            	  3586:             bne.s *                   * Check Z Flag  beq/bne 0
00:000028BC B458            	  3587:             cmp.w (a0)+,d2
00:000028BE 66FE            	  3588:             bne.s *                   * Check Z Flag  beq/bne 0
00:000028C0 B658            	  3589:             cmp.w (a0)+,d3
00:000028C2 66FE            	  3590:             bne.s *                   * Check Z Flag  beq/bne 0
00:000028C4 B858            	  3591:             cmp.w (a0)+,d4
00:000028C6 66FE            	  3592:             bne.s *                   * Check Z Flag  beq/bne 0
00:000028C8 BA58            	  3593:             cmp.w (a0)+,d5
00:000028CA 66FE            	  3594:             bne.s *                   * Check Z Flag  beq/bne 0
00:000028CC BC58            	  3595:             cmp.w (a0)+,d6
00:000028CE 66FE            	  3596:             bne.s *                   * Check Z Flag  beq/bne 0
00:000028D0 BE58            	  3597:             cmp.w (a0)+,d7
00:000028D2 66FE            	  3598:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3599: 
00:000028D4 0C580A0A        	  3600:             cmpi.w #$0A0A,(a0)+    * Because we are using a0 as a pointer
00:000028D8 66FE            	  3601:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3602: 
00:000028DA B2D8            	  3603:             cmp.w (a0)+,a1
00:000028DC 66FE            	  3604:             bne.s *                   * Check Z Flag  beq/bne 0
00:000028DE B4D8            	  3605:             cmp.w (a0)+,a2
00:000028E0 66FE            	  3606:             bne.s *                   * Check Z Flag  beq/bne 0
00:000028E2 B6D8            	  3607:             cmp.w (a0)+,a3
00:000028E4 66FE            	  3608:             bne.s *                   * Check Z Flag  beq/bne 0
00:000028E6 B8D8            	  3609:             cmp.w (a0)+,a4
00:000028E8 66FE            	  3610:             bne.s *                   * Check Z Flag  beq/bne 0
00:000028EA BAD8            	  3611:             cmp.w (a0)+,a5
00:000028EC 66FE            	  3612:             bne.s *                   * Check Z Flag  beq/bne 0
00:000028EE BCD8            	  3613:             cmp.w (a0)+,a6
00:000028F0 66FE            	  3614:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3615: 
                            	  3616: 
                            	  3617: 
                            	  3618: 
                            	  3619: *     LONG  Registers --> Memory
00:000028F2 203CD0D0D0D0    	  3620:             move.l #$d0d0d0d0,d0
00:000028F8 223CD1D1D1D1    	  3621:             move.l #$d1d1d1d1,d1
00:000028FE 243CD2D2D2D2    	  3622:             move.l #$d2d2d2d2,d2
00:00002904 263CD3D3D3D3    	  3623:             move.l #$d3d3d3d3,d3
00:0000290A 283CD4D4D4D4    	  3624:             move.l #$d4d4d4d4,d4
00:00002910 2A3CD5D5D5D5    	  3625:             move.l #$d5d5d5d5,d5
00:00002916 2C3CD6D6D6D6    	  3626:             move.l #$d6d6d6d6,d6
00:0000291C 2E3CD7D7D7D7    	  3627:             move.l #$d7d7d7d7,d7
00:00002922 207C0A0A0A0A    	  3628:             move.l #$0a0a0a0a,a0
00:00002928 227C1A1A1A1A    	  3629:             move.l #$1a1a1a1a,a1
00:0000292E 247C2A2A2A2A    	  3630:             move.l #$2a2a2a2a,a2
00:00002934 267C3A3A3A3A    	  3631:             move.l #$3a3a3a3a,a3
00:0000293A 287C4A4A4A4A    	  3632:             move.l #$4a4a4a4a,a4
00:00002940 2A7C5A5A5A5A    	  3633:             move.l #$5a5a5a5a,a5
00:00002946 2C7C6A6A6A6A    	  3634:             move.l #$6a6a6a6a,a6
                            	  3635: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3636: 
                            	  3637: 
00:0000294C 48F8FFFF0120    	  3638:             movem.l D0-D7/A0-A7,$00000120
                            	  3639: 
00:00002952 307C0120        	  3640:             move.l #$00000120,a0
                            	  3641: 
00:00002956 B098            	  3642:             cmp.l (a0)+,d0
00:00002958 66FE            	  3643:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000295A B298            	  3644:             cmp.l (a0)+,d1
00:0000295C 66FE            	  3645:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000295E B498            	  3646:             cmp.l (a0)+,d2
00:00002960 66FE            	  3647:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002962 B698            	  3648:             cmp.l (a0)+,d3
00:00002964 66FE            	  3649:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002966 B898            	  3650:             cmp.l (a0)+,d4
00:00002968 66FE            	  3651:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000296A BA98            	  3652:             cmp.l (a0)+,d5
00:0000296C 66FE            	  3653:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000296E BC98            	  3654:             cmp.l (a0)+,d6
00:00002970 66FE            	  3655:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002972 BE98            	  3656:             cmp.l (a0)+,d7
00:00002974 66FE            	  3657:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3658: 
00:00002976 0C980A0A0A0A    	  3659:             cmpi.l #$0A0A0A0A,(a0)+    * Because we are using a0 as a pointer
00:0000297C 66FE            	  3660:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3661: 
00:0000297E B3D8            	  3662:             cmp.l (a0)+,a1
00:00002980 66FE            	  3663:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002982 B5D8            	  3664:             cmp.l (a0)+,a2
00:00002984 66FE            	  3665:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002986 B7D8            	  3666:             cmp.l (a0)+,a3
00:00002988 66FE            	  3667:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000298A B9D8            	  3668:             cmp.l (a0)+,a4
00:0000298C 66FE            	  3669:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000298E BBD8            	  3670:             cmp.l (a0)+,a5
00:00002990 66FE            	  3671:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002992 BDD8            	  3672:             cmp.l (a0)+,a6
00:00002994 66FE            	  3673:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3674: *      ----
                            	  3675: 
                            	  3676: 
                            	  3677: *     WORD  Registers --> Memory  -(An) EA Mode
00:00002996 203C0000D0D0    	  3678:             move.l #$0000d0d0,d0
00:0000299C 223C0000D1D1    	  3679:             move.l #$0000d1d1,d1
00:000029A2 243C0000D2D2    	  3680:             move.l #$0000d2d2,d2
00:000029A8 263C0000D3D3    	  3681:             move.l #$0000d3d3,d3
00:000029AE 283C0000D4D4    	  3682:             move.l #$0000d4d4,d4
00:000029B4 2A3C0000D5D5    	  3683:             move.l #$0000d5d5,d5
00:000029BA 2C3C0000D6D6    	  3684:             move.l #$0000d6d6,d6
00:000029C0 2E3C0000D7D7    	  3685:             move.l #$0000d7d7,d7
00:000029C6 307C0A0A        	  3686:             move.l #$00000a0a,a0
00:000029CA 327C1A1A        	  3687:             move.l #$00001a1a,a1
00:000029CE 347C2A2A        	  3688:             move.l #$00002a2a,a2
00:000029D2 367C3A3A        	  3689:             move.l #$00003a3a,a3
00:000029D6 387C4A4A        	  3690:             move.l #$00004a4a,a4
00:000029DA 3A7C5A5A        	  3691:             move.l #$00005a5a,a5
00:000029DE 3C7C6A6A        	  3692:             move.l #$00006a6a,a6
                            	  3693: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3694: 
00:000029E2 307C01A0        	  3695:             move.l #$000001A0,a0
00:000029E6 48A0FFFF        	  3696:             movem.w D0-D7/A0-A7,-(a0)
                            	  3697: 
00:000029EA 307C019E        	  3698:             move.l #$0000019E,a0
                            	  3699: 
00:000029EE BCE0            	  3700:             cmp.w -(a0),a6
00:000029F0 66FE            	  3701:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029F2 BAE0            	  3702:             cmp.w -(a0),a5
00:000029F4 66FE            	  3703:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029F6 B8E0            	  3704:             cmp.w -(a0),a4
00:000029F8 66FE            	  3705:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029FA B6E0            	  3706:             cmp.w -(a0),a3
00:000029FC 66FE            	  3707:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029FE B4E0            	  3708:             cmp.w -(a0),a2
00:00002A00 66FE            	  3709:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A02 B2E0            	  3710:             cmp.w -(a0),a1
00:00002A04 66FE            	  3711:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A06 B0E0            	  3712:             cmp.w -(a0),a0
                            	  3713: *            bne.s *                   * Check Z Flag  beq/bne 0
00:00002A08 BE60            	  3714:             cmp.w -(a0),d7
00:00002A0A 66FE            	  3715:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A0C BC60            	  3716:             cmp.w -(a0),d6
00:00002A0E 66FE            	  3717:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A10 BA60            	  3718:             cmp.w -(a0),d5
00:00002A12 66FE            	  3719:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A14 B860            	  3720:             cmp.w -(a0),d4
00:00002A16 66FE            	  3721:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A18 B660            	  3722:             cmp.w -(a0),d3
00:00002A1A 66FE            	  3723:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A1C B460            	  3724:             cmp.w -(a0),d2
00:00002A1E 66FE            	  3725:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A20 B260            	  3726:             cmp.w -(a0),d1
00:00002A22 66FE            	  3727:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A24 B060            	  3728:             cmp.w -(a0),d0
00:00002A26 66FE            	  3729:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3730: 
                            	  3731: 
                            	  3732: 
                            	  3733: 
                            	  3734: *     LONG  Registers --> Memory   -(An) EA Mode
00:00002A28 203CD0D0D0D0    	  3735:             move.l #$d0d0d0d0,d0
00:00002A2E 223CD1D1D1D1    	  3736:             move.l #$d1d1d1d1,d1
00:00002A34 243CD2D2D2D2    	  3737:             move.l #$d2d2d2d2,d2
00:00002A3A 263CD3D3D3D3    	  3738:             move.l #$d3d3d3d3,d3
00:00002A40 283CD4D4D4D4    	  3739:             move.l #$d4d4d4d4,d4
00:00002A46 2A3CD5D5D5D5    	  3740:             move.l #$d5d5d5d5,d5
00:00002A4C 2C3CD6D6D6D6    	  3741:             move.l #$d6d6d6d6,d6
00:00002A52 2E3CD7D7D7D7    	  3742:             move.l #$d7d7d7d7,d7
00:00002A58 207C0A0A0A0A    	  3743:             move.l #$0a0a0a0a,a0
00:00002A5E 227C1A1A1A1A    	  3744:             move.l #$1a1a1a1a,a1
00:00002A64 247C2A2A2A2A    	  3745:             move.l #$2a2a2a2a,a2
00:00002A6A 267C3A3A3A3A    	  3746:             move.l #$3a3a3a3a,a3
00:00002A70 287C4A4A4A4A    	  3747:             move.l #$4a4a4a4a,a4
00:00002A76 2A7C5A5A5A5A    	  3748:             move.l #$5a5a5a5a,a5
00:00002A7C 2C7C6A6A6A6A    	  3749:             move.l #$6a6a6a6a,a6
                            	  3750: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3751: 
                            	  3752: 
00:00002A82 307C01A0        	  3753:             move.l #$000001A0,a0
00:00002A86 48E0FFFF        	  3754:             movem.l D0-D7/A0-A7,-(a0)
                            	  3755: 
00:00002A8A 307C019C        	  3756:             move.l #$0000019C,a0
                            	  3757: 
00:00002A8E BDE0            	  3758:             cmp.l -(a0),a6
00:00002A90 66FE            	  3759:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A92 BBE0            	  3760:             cmp.l -(a0),a5
00:00002A94 66FE            	  3761:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A96 B9E0            	  3762:             cmp.l -(a0),a4
00:00002A98 66FE            	  3763:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A9A B7E0            	  3764:             cmp.l -(a0),a3
00:00002A9C 66FE            	  3765:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A9E B5E0            	  3766:             cmp.l -(a0),a2
00:00002AA0 66FE            	  3767:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002AA2 B3E0            	  3768:             cmp.l -(a0),a1
00:00002AA4 66FE            	  3769:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002AA6 B1E0            	  3770:             cmp.l -(a0),a0
                            	  3771: *            bne.s *                   * Check Z Flag  beq/bne 0
00:00002AA8 BEA0            	  3772:             cmp.l -(a0),d7
00:00002AAA 66FE            	  3773:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002AAC BCA0            	  3774:             cmp.l -(a0),d6
00:00002AAE 66FE            	  3775:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002AB0 BAA0            	  3776:             cmp.l -(a0),d5
00:00002AB2 66FE            	  3777:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002AB4 B8A0            	  3778:             cmp.l -(a0),d4
00:00002AB6 66FE            	  3779:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002AB8 B6A0            	  3780:             cmp.l -(a0),d3
00:00002ABA 66FE            	  3781:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002ABC B4A0            	  3782:             cmp.l -(a0),d2
00:00002ABE 66FE            	  3783:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002AC0 B2A0            	  3784:             cmp.l -(a0),d1
00:00002AC2 66FE            	  3785:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002AC4 B0A0            	  3786:             cmp.l -(a0),d0
00:00002AC6 66FE            	  3787:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3788: 
                            	  3789: 
                            	  3790: 
                            	  3791: *     ----
                            	  3792: 
                            	  3793: *     WORD - Memory --> Registers
00:00002AC8 7000            	  3794:             moveq  #$00000000,d0
00:00002ACA 7200            	  3795:             moveq  #$00000000,d1
00:00002ACC 7400            	  3796:             moveq  #$00000000,d2
00:00002ACE 7600            	  3797:             moveq  #$00000000,d3
00:00002AD0 7800            	  3798:             moveq  #$00000000,d4
00:00002AD2 7A00            	  3799:             moveq  #$00000000,d5
00:00002AD4 7C00            	  3800:             moveq  #$00000000,d6
00:00002AD6 7E00            	  3801:             moveq  #$00000000,d7
00:00002AD8 91C8            	  3802:             move.l #$00000000,a0
00:00002ADA 93C9            	  3803:             move.l #$00000000,a1
00:00002ADC 95CA            	  3804:             move.l #$00000000,a2
00:00002ADE 97CB            	  3805:             move.l #$00000000,a3
00:00002AE0 99CC            	  3806:             move.l #$00000000,a4
00:00002AE2 9BCD            	  3807:             move.l #$00000000,a5
00:00002AE4 9DCE            	  3808:             move.l #$00000000,a6
                            	  3809: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3810: 
00:00002AE6 4CB82A550100    	  3811:             movem.w $00000100,D0/D2/D4/D6/A1/A3/A5
                            	  3812: 
00:00002AEC B0BCFFFFD0D0    	  3813:             cmp.l #$FFFFD0D0,d0
00:00002AF2 66FE            	  3814:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002AF4 B4BCFFFFD1D1    	  3815:             cmp.l #$FFFFD1D1,d2
00:00002AFA 66FE            	  3816:             bne.s *                  * Check Z Flag  beq/bne 0
00:00002AFC B8BCFFFFD2D2    	  3817:             cmp.l #$FFFFD2D2,d4
00:00002B02 66FE            	  3818:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B04 BCBCFFFFD3D3    	  3819:             cmp.l #$FFFFD3D3,d6
00:00002B0A 66FE            	  3820:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B0C B2FCD4D4        	  3821:             cmp.l #$FFFFD4D4,a1
00:00002B10 66FE            	  3822:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B12 B6FCD5D5        	  3823:             cmp.l #$FFFFD5D5,a3
00:00002B16 66FE            	  3824:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B18 BAFCD6D6        	  3825:             cmp.l #$FFFFD6D6,a5
00:00002B1C 66FE            	  3826:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3827: 
                            	  3828: 
                            	  3829: *     LONG - Memory --> Registers
00:00002B1E 7000            	  3830:             moveq  #$00000000,d0
00:00002B20 7200            	  3831:             moveq  #$00000000,d1
00:00002B22 7400            	  3832:             moveq  #$00000000,d2
00:00002B24 7600            	  3833:             moveq  #$00000000,d3
00:00002B26 7800            	  3834:             moveq  #$00000000,d4
00:00002B28 7A00            	  3835:             moveq  #$00000000,d5
00:00002B2A 7C00            	  3836:             moveq  #$00000000,d6
00:00002B2C 7E00            	  3837:             moveq  #$00000000,d7
00:00002B2E 91C8            	  3838:             move.l #$00000000,a0
00:00002B30 93C9            	  3839:             move.l #$00000000,a1
00:00002B32 95CA            	  3840:             move.l #$00000000,a2
00:00002B34 97CB            	  3841:             move.l #$00000000,a3
00:00002B36 99CC            	  3842:             move.l #$00000000,a4
00:00002B38 9BCD            	  3843:             move.l #$00000000,a5
00:00002B3A 9DCE            	  3844:             move.l #$00000000,a6
                            	  3845: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3846: 
00:00002B3C 4CF82A550120    	  3847:             movem.l $00000120,D0/D2/D4/D6/A1/A3/A5
                            	  3848: 
00:00002B42 B0BCD0D0D0D0    	  3849:             cmp.l #$D0D0D0D0,d0
00:00002B48 66FE            	  3850:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B4A B4BCD1D1D1D1    	  3851:             cmp.l #$D1D1D1D1,d2
00:00002B50 66FE            	  3852:             bne.s *                  * Check Z Flag  beq/bne 0
00:00002B52 B8BCD2D2D2D2    	  3853:             cmp.l #$D2D2D2D2,d4
00:00002B58 66FE            	  3854:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B5A BCBCD3D3D3D3    	  3855:             cmp.l #$D3D3D3D3,d6
00:00002B60 66FE            	  3856:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B62 B3FCD4D4D4D4    	  3857:             cmp.l #$D4D4D4D4,a1
00:00002B68 66FE            	  3858:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B6A B7FCD5D5D5D5    	  3859:             cmp.l #$D5D5D5D5,a3
00:00002B70 66FE            	  3860:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B72 BBFCD6D6D6D6    	  3861:             cmp.l #$D6D6D6D6,a5
00:00002B78 66FE            	  3862:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3863: 
00:00002B7A 4E75            	  3864:             rts
                            	  3865: 
                            	  3866: 
                            	  3867: *-----------------------------------------------------------
                            	  3868: *-----------------------------------------------------------
                            	  3869: * OPCODE : ABCD
                            	  3870: *-----------------------------------------------------------
                            	  3871: *-----------------------------------------------------------
                            	  3872: op_ABCD:
                            	  3873: 
                            	  3874: *     Test with X Flag CLEARED
00:00002B7C 307C0110        	  3875:                 move.l #$00000110,a0 * Address pointer-X
00:00002B80 327C0120        	  3876:                 move.l #$00000120,a1 * Address pointer-Y
00:00002B84 7000            	  3877:                 moveq  #$00000000,d0 * BCD byte-X
00:00002B86 7200            	  3878:                 moveq  #$00000000,d1 * BCD byte-Y
00:00002B88 7400            	  3879:                 moveq  #$00000000,d2
00:00002B8A 7600            	  3880:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00002B8C 7800            	  3881:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00002B8E 7A00            	  3882:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:00002B90 2C3C00000099    	  3883:                 move.l #$00000099,d6 * Inner loop counter
00:00002B96 2E3C00000099    	  3884:                 move.l #$00000099,d7 * Outer loop counter
                            	  3885: 
00:00002B9C 2007            	  3886: ABCD_OUTER1:    move.l d7,d0
00:00002B9E 2206            	  3887: ABCD_INNER1:    move.l d6,d1
00:00002BA0 023C00EF        	  3888:                 andi.b #$EF,CCR     * Clear X Flag
00:00002BA4 307C0110        	  3889:                 move.l #$00000110,a0 * Address pointer-X
00:00002BA8 327C0120        	  3890:                 move.l #$00000120,a1 * Address pointer-Y
00:00002BAC 1140FFFF        	  3891:                 move.b d0,-1(a0)
00:00002BB0 1341FFFF        	  3892:                 move.b d1,-1(a1)
                            	  3893: 
00:00002BB4 C300            	  3894:                 abcd d0,d1
00:00002BB6 6402            	  3895:                 bcc.s ABCD_NO_C1          * Check C Flag  bcc/bcs 0
00:00002BB8 5284            	  3896:                 add.l #1,d4
00:00002BBA DA81            	  3897: ABCD_NO_C1:     add.l d1,d5
                            	  3898: 
00:00002BBC C308            	  3899:                 abcd -(a0),-(a1)
00:00002BBE 6402            	  3900:                 bcc.s ABCD_NO_C2          * Check C Flag  bcc/bcs 0
00:00002BC0 5284            	  3901:                 add.l #1,d4
00:00002BC2 D611            	  3902: ABCD_NO_C2:     add.b (a1),d3
                            	  3903: 
                            	  3904: 
00:00002BC4 51CEFFD8        	  3905:                 dbf d6,ABCD_INNER1
00:00002BC8 2C3C00000099    	  3906:                 move.l #$00000099,d6
00:00002BCE 51CFFFCC        	  3907:                 dbf d7,ABCD_OUTER1
00:00002BD2 0C8400005AFC    	  3908:                 cmpi.l #$00005AFC,d4  * Check the cumulative results
00:00002BD8 66FE            	  3909:                 bne.s *
00:00002BDA 0C85001C9A34    	  3910:                 cmpi.l #$001C9A34,d5
00:00002BE0 66FE            	  3911:                 bne.s *
00:00002BE2 0C8300000034    	  3912:                 cmpi.l #$00000034,d3
00:00002BE8 66FE            	  3913:                 bne.s *
                            	  3914: 
                            	  3915: *     Test with X Flag SET
00:00002BEA 307C0110        	  3916:                 move.l #$00000110,a0 * Address pointer-X
00:00002BEE 327C0120        	  3917:                 move.l #$00000120,a1 * Address pointer-Y
00:00002BF2 7000            	  3918:                 moveq  #$00000000,d0 * BCD byte-X
00:00002BF4 7200            	  3919:                 moveq  #$00000000,d1 * BCD byte-Y
00:00002BF6 7400            	  3920:                 moveq  #$00000000,d2
00:00002BF8 7600            	  3921:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00002BFA 7800            	  3922:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00002BFC 7A00            	  3923:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:00002BFE 2C3C00000099    	  3924:                 move.l #$00000099,d6 * Inner loop counter
00:00002C04 2E3C00000099    	  3925:                 move.l #$00000099,d7 * Outer loop counter
                            	  3926: 
00:00002C0A 2007            	  3927: ABCD_OUTER2:    move.l d7,d0
00:00002C0C 2206            	  3928: ABCD_INNER2:    move.l d6,d1
00:00002C0E 003C0010        	  3929:                 ori.b #$10,CCR      * Set X Flag
00:00002C12 307C0110        	  3930:                 move.l #$00000110,a0 * Address pointer-X
00:00002C16 327C0120        	  3931:                 move.l #$00000120,a1 * Address pointer-Y
00:00002C1A 1140FFFF        	  3932:                 move.b d0,-1(a0)
00:00002C1E 1341FFFF        	  3933:                 move.b d1,-1(a1)
                            	  3934: 
00:00002C22 C300            	  3935:                 abcd d0,d1
00:00002C24 6402            	  3936:                 bcc.s ABCD_NO_C3          * Check C Flag  bcc/bcs 0
00:00002C26 5284            	  3937:                 add.l #1,d4
00:00002C28 DA81            	  3938: ABCD_NO_C3:     add.l d1,d5
                            	  3939: 
00:00002C2A C308            	  3940:                 abcd -(a0),-(a1)
00:00002C2C 6402            	  3941:                 bcc.s ABCD_NO_C4          * Check C Flag  bcc/bcs 0
00:00002C2E 5284            	  3942:                 add.l #1,d4
00:00002C30 D611            	  3943: ABCD_NO_C4:     add.b (a1),d3
                            	  3944: 
                            	  3945: 
00:00002C32 51CEFFD8        	  3946:                 dbf d6,ABCD_INNER2
00:00002C36 2C3C00000099    	  3947:                 move.l #$00000099,d6
00:00002C3C 51CFFFCC        	  3948:                 dbf d7,ABCD_OUTER2
00:00002C40 0C8400005B60    	  3949:                 cmpi.l #$00005B60,d4  * Check the cumulative results
00:00002C46 66FE            	  3950:                 bne.s *
00:00002C48 0C85001CCFC8    	  3951:                 cmpi.l #$001CCFC8,d5
00:00002C4E 66FE            	  3952:                 bne.s *
00:00002C50 0C8300000034    	  3953:                 cmpi.l #$00000034,d3
00:00002C56 66FE            	  3954:                 bne.s *
                            	  3955: 
                            	  3956: *             Quick check of Z Flag
00:00002C58 4200            	  3957:                 move.b #$00,d0
00:00002C5A 4201            	  3958:                 move.b #$00,d1
00:00002C5C 44FC0000        	  3959:                 move #$00,CCR              * Set Z flag to 0
00:00002C60 C101            	  3960:                 abcd d1,d0                  * Should NOT set Z Flag to 1
00:00002C62 67FE            	  3961:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3962: 
00:00002C64 103C0001        	  3963:                 move.b #$01,d0
00:00002C68 4201            	  3964:                 move.b #$00,d1
00:00002C6A 44FC0004        	  3965:                 move #$04,CCR              * Set Z flag to 0
00:00002C6E C101            	  3966:                 abcd d1,d0                  * Should NOT set Z Flag to 1
00:00002C70 67FE            	  3967:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3968: 
00:00002C72 4E75            	  3969:                 rts
                            	  3970: 
                            	  3971: *-----------------------------------------------------------
                            	  3972: *-----------------------------------------------------------
                            	  3973: * OPCODE : SBCD
                            	  3974: *-----------------------------------------------------------
                            	  3975: *-----------------------------------------------------------
                            	  3976: op_SBCD:
                            	  3977: 
                            	  3978: *     Test with X Flag CLEARED
00:00002C74 307C0110        	  3979:                 move.l #$00000110,a0 * Address pointer-X
00:00002C78 327C0120        	  3980:                 move.l #$00000120,a1 * Address pointer-Y
00:00002C7C 7000            	  3981:                 moveq  #$00000000,d0 * BCD byte-X
00:00002C7E 7200            	  3982:                 moveq  #$00000000,d1 * BCD byte-Y
00:00002C80 7400            	  3983:                 moveq  #$00000000,d2
00:00002C82 7600            	  3984:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00002C84 7800            	  3985:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00002C86 7A00            	  3986:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:00002C88 2C3C00000099    	  3987:                 move.l #$00000099,d6 * Inner loop counter
00:00002C8E 2E3C00000099    	  3988:                 move.l #$00000099,d7 * Outer loop counter
                            	  3989: 
00:00002C94 2007            	  3990: SBCD_OUTER1:    move.l d7,d0
00:00002C96 2206            	  3991: SBCD_INNER1:    move.l d6,d1
00:00002C98 023C00EF        	  3992:                 andi.b #$EF,CCR     * Clear X Flag
00:00002C9C 307C0110        	  3993:                 move.l #$00000110,a0 * Address pointer-X
00:00002CA0 327C0120        	  3994:                 move.l #$00000120,a1 * Address pointer-Y
00:00002CA4 1140FFFF        	  3995:                 move.b d0,-1(a0)
00:00002CA8 1341FFFF        	  3996:                 move.b d1,-1(a1)
                            	  3997: 
00:00002CAC 8300            	  3998:                 sbcd d0,d1
00:00002CAE 6402            	  3999:                 bcc.s SBCD_NO_C1          * Check C Flag  bcc/bcs 0
00:00002CB0 5284            	  4000:                 add.l #1,d4
00:00002CB2 DA81            	  4001: SBCD_NO_C1:     add.l d1,d5
                            	  4002: 
00:00002CB4 8308            	  4003:                 sbcd -(a0),-(a1)
00:00002CB6 6402            	  4004:                 bcc.s SBCD_NO_C2          * Check C Flag  bcc/bcs 0
00:00002CB8 5284            	  4005:                 add.l #1,d4
00:00002CBA D611            	  4006: SBCD_NO_C2:     add.b (a1),d3
                            	  4007: 
                            	  4008: 
00:00002CBC 51CEFFD8        	  4009:                 dbf d6,SBCD_INNER1
00:00002CC0 2C3C00000099    	  4010:                 move.l #$00000099,d6
00:00002CC6 51CFFFCC        	  4011:                 dbf d7,SBCD_OUTER1
00:00002CCA 0C8400005C0A    	  4012:                 cmpi.l #$00005C0A,d4  * Check the cumulative results
00:00002CD0 66FE            	  4013:                 bne.s *
00:00002CD2 0C85001C459E    	  4014:                 cmpi.l #$001C459E,d5
00:00002CD8 66FE            	  4015:                 bne.s *
00:00002CDA 0C830000009E    	  4016:                 cmpi.l #$0000009E,d3
00:00002CE0 66FE            	  4017:                 bne.s *
                            	  4018: 
                            	  4019: *     Test with X Flag SET
00:00002CE2 307C0110        	  4020:                 move.l #$00000110,a0 * Address pointer-X
00:00002CE6 327C0120        	  4021:                 move.l #$00000120,a1 * Address pointer-Y
00:00002CEA 7000            	  4022:                 moveq  #$00000000,d0 * BCD byte-X
00:00002CEC 7200            	  4023:                 moveq  #$00000000,d1 * BCD byte-Y
00:00002CEE 7400            	  4024:                 moveq  #$00000000,d2
00:00002CF0 7600            	  4025:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00002CF2 7800            	  4026:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00002CF4 7A00            	  4027:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:00002CF6 2C3C00000099    	  4028:                 move.l #$00000099,d6 * Inner loop counter
00:00002CFC 2E3C00000099    	  4029:                 move.l #$00000099,d7 * Outer loop counter
                            	  4030: 
00:00002D02 2007            	  4031: SBCD_OUTER2:    move.l d7,d0
00:00002D04 2206            	  4032: SBCD_INNER2:    move.l d6,d1
00:00002D06 003C0010        	  4033:                 ori.b #$10,CCR      * Set X Flag
00:00002D0A 307C0110        	  4034:                 move.l #$00000110,a0 * Address pointer-X
00:00002D0E 327C0120        	  4035:                 move.l #$00000120,a1 * Address pointer-Y
00:00002D12 1140FFFF        	  4036:                 move.b d0,-1(a0)
00:00002D16 1341FFFF        	  4037:                 move.b d1,-1(a1)
                            	  4038: 
00:00002D1A 8300            	  4039:                 sbcd d0,d1
00:00002D1C 6402            	  4040:                 bcc.s SBCD_NO_C3          * Check C Flag  bcc/bcs 0
00:00002D1E 5284            	  4041:                 add.l #1,d4
00:00002D20 DA81            	  4042: SBCD_NO_C3:     add.l d1,d5
                            	  4043: 
00:00002D22 8308            	  4044:                 sbcd -(a0),-(a1)
00:00002D24 6402            	  4045:                 bcc.s SBCD_NO_C4          * Check C Flag  bcc/bcs 0
00:00002D26 5284            	  4046:                 add.l #1,d4
00:00002D28 D611            	  4047: SBCD_NO_C4:     add.b (a1),d3
                            	  4048: 
00:00002D2A 51CEFFD8        	  4049:                 dbf d6,SBCD_INNER2
00:00002D2E 2C3C00000099    	  4050:                 move.l #$00000099,d6
00:00002D34 51CFFFCC        	  4051:                 dbf d7,SBCD_OUTER2
00:00002D38 0C8400005CA4    	  4052:                 cmpi.l #$00005CA4,d4  * Check the cumulative results
00:00002D3E 66FE            	  4053:                 bne.s *
00:00002D40 0C85001C5C66    	  4054:                 cmpi.l #$001C5C66,d5
00:00002D46 66FE            	  4055:                 bne.s *
00:00002D48 0C830000009E    	  4056:                 cmpi.l #$0000009E,d3
00:00002D4E 66FE            	  4057:                 bne.s *
                            	  4058: 
                            	  4059: 
                            	  4060: *             Quick check of Z Flag
00:00002D50 4200            	  4061:                 move.b #$00,d0
00:00002D52 4201            	  4062:                 move.b #$00,d1
00:00002D54 44FC0000        	  4063:                 move #$00,CCR              * Set Z flag to 0
00:00002D58 8101            	  4064:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
00:00002D5A 67FE            	  4065:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4066: 
00:00002D5C 103C0001        	  4067:                 move.b #$01,d0
00:00002D60 4201            	  4068:                 move.b #$00,d1
00:00002D62 44FC0004        	  4069:                 move #$04,CCR              * Set Z flag to 0
00:00002D66 8101            	  4070:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
00:00002D68 67FE            	  4071:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4072: 
00:00002D6A 4E75            	  4073:                 rts
                            	  4074: 
                            	  4075: *-----------------------------------------------------------
                            	  4076: *-----------------------------------------------------------
                            	  4077: * OPCODE : NBCD
                            	  4078: *-----------------------------------------------------------
                            	  4079: *-----------------------------------------------------------
                            	  4080: op_NBCD:
                            	  4081: 
                            	  4082: *        NBCD to a  Register
                            	  4083: 
00:00002D6C 7000            	  4084:                 moveq  #$00000000,d0 * BCD byte
00:00002D6E 7200            	  4085:                 moveq  #$00000000,d1
00:00002D70 7400            	  4086:                 moveq  #$00000000,d2
00:00002D72 7600            	  4087:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
00:00002D74 7800            	  4088:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00002D76 7A00            	  4089:                 moveq  #$00000000,d5 * Cumulative BCD results
00:00002D78 2C3C00000099    	  4090:                 move.l #$00000099,d6
00:00002D7E 2E3C00000099    	  4091:                 move.l #$00000099,d7 * Loop counter
                            	  4092: 
00:00002D84 2007            	  4093: NBCD_LOOP:      move.l d7,d0
00:00002D86 44FC0004        	  4094:                 move #$04,CCR        * Set Z flag to 0
                            	  4095: 
00:00002D8A 4800            	  4096:                 nbcd d0
                            	  4097: 
00:00002D8C 6402            	  4098:                 bcc.s NBCD_NO_C         * Check C Flag
00:00002D8E 5284            	  4099:                 add.l #1,d4
00:00002D90 6602            	  4100: NBCD_NO_C:      bne.s NBCD_NO_Z         * Check Z Flag
00:00002D92 5283            	  4101:                 add.l #1,d3
00:00002D94 DA80            	  4102: NBCD_NO_Z:      add.l d0,d5         * Add results into d5
                            	  4103: 
00:00002D96 51CFFFEC        	  4104:                 dbf d7,NBCD_LOOP
                            	  4105: 
00:00002D9A 0C8300000001    	  4106:                 cmpi.l #$00000001,d3  * Check the cumulative results
00:00002DA0 66FE            	  4107:                 bne.s *
00:00002DA2 0C8400000099    	  4108:                 cmpi.l #$00000099,d4
00:00002DA8 66FE            	  4109:                 bne.s *
00:00002DAA 0C8500002E3B    	  4110:                 cmpi.l #$00002E3B,d5
00:00002DB0 66FE            	  4111:                 bne.s *
                            	  4112: 
                            	  4113: 
                            	  4114: *        NBCD to a memory location
                            	  4115: 
00:00002DB2 7000            	  4116:                 moveq  #$00000000,d0 * BCD byte
00:00002DB4 7200            	  4117:                 moveq  #$00000000,d1
00:00002DB6 7400            	  4118:                 moveq  #$00000000,d2
00:00002DB8 7600            	  4119:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
00:00002DBA 7800            	  4120:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00002DBC 7A00            	  4121:                 moveq  #$00000000,d5 * Cumulative BCD results
00:00002DBE 2C3C00000099    	  4122:                 move.l #$00000099,d6
00:00002DC4 2E3C00000099    	  4123:                 move.l #$00000099,d7 * Loop counter
                            	  4124: 
00:00002DCA 11C70100        	  4125: NBCD_LOOP1:     move.b d7,$00000100
00:00002DCE 44FC0004        	  4126:                 move #$04,CCR        * Set Z flag to 0
                            	  4127: 
00:00002DD2 48380100        	  4128:                 nbcd $00000100
00:00002DD6 10380100        	  4129:                 move.b $00000100,d0
                            	  4130: 
00:00002DDA 6402            	  4131:                 bcc.s NBCD_NO_C1        * Check C Flag
00:00002DDC 5284            	  4132:                 add.l #1,d4
00:00002DDE 6602            	  4133: NBCD_NO_C1:     bne.s NBCD_NO_Z1        * Check Z Flag
00:00002DE0 5283            	  4134:                 add.l #1,d3
00:00002DE2 DA80            	  4135: NBCD_NO_Z1:     add.l d0,d5         * Add results into d5
                            	  4136: 
00:00002DE4 51CFFFE4        	  4137:                 dbf d7,NBCD_LOOP1
                            	  4138: 
00:00002DE8 0C8300000001    	  4139:                 cmpi.l #$00000001,d3  * Check the cumulative results
00:00002DEE 66FE            	  4140:                 bne.s *
00:00002DF0 4A84            	  4141:                 cmpi.l #$00000000,d4
00:00002DF2 66FE            	  4142:                 bne.s *
00:00002DF4 0C8500002E3B    	  4143:                 cmpi.l #$00002E3B,d5
00:00002DFA 66FE            	  4144:                 bne.s *
                            	  4145: 
                            	  4146: 
00:00002DFC 4E75            	  4147:                 rts
                            	  4148: 
                            	  4149: 
                            	  4150: 
                            	  4151: *-----------------------------------------------------------
                            	  4152: *-----------------------------------------------------------
                            	  4153: * OPCODE : TRAPV
                            	  4154: *-----------------------------------------------------------
                            	  4155: *-----------------------------------------------------------
                            	  4156: op_TRAPV:
                            	  4157: 
                            	  4158: *     TRAPV will set d0 to 12345678 if V flag is set
                            	  4159: 
00:00002DFE 7000            	  4160:                 moveq  #$00000000,d0 * Clear d0
                            	  4161: 
00:00002E00 44FC0000        	  4162:                 move #$00,CCR        * Clear V flag
00:00002E04 4E76            	  4163:                 trapv
00:00002E06 4A80            	  4164:                 cmpi.l #$00000000,d0  * Check of d0 was updated (should not be_)
00:00002E08 66FE            	  4165:                 bne.s *
                            	  4166: 
00:00002E0A 44FC0002        	  4167:                 move #$02,CCR        * Set V flag
00:00002E0E 4E76            	  4168:                 trapv
00:00002E10 0C8012345678    	  4169:                 cmpi.l #$12345678,d0  * Check of d0 was updated (should not be_)
00:00002E16 66FE            	  4170:                 bne.s *
                            	  4171: 
                            	  4172: 
00:00002E18 4E75            	  4173:                 rts
                            	  4174: 
                            	  4175: 
                            	  4176: 
                            	  4177: *-----------------------------------------------------------
                            	  4178: *-----------------------------------------------------------
                            	  4179: * OPCODE : RTR
                            	  4180: *-----------------------------------------------------------
                            	  4181: *-----------------------------------------------------------
                            	  4182: 
                            	  4183: op_RTR:
                            	  4184: 
                            	  4185: *     Leventhal claims only 5 LSB's are popped from the stack to the CCR
                            	  4186: 
00:00002E1A 41FA000A        	  4187:                 lea 		RTR_DONE,a0
00:00002E1E 2F08            	  4188:                 move.l 	a0,-(a7)     * push destination PC to the stack
00:00002E20 3F3CFF15        	  4189:                 move.w 	#$FF15,-(a7)       * push flags=0xFFFF to the stack
00:00002E24 4E77            	  4190:                 rtr
                            	  4191: 
00:00002E26 40C0            	  4192: RTR_DONE:       move.w SR,d0
00:00002E28 0240001F        	  4193:                 andi.w #$1F,d0
00:00002E2C 0C400015        	  4194:                 cmpi.w #$15,d0
00:00002E30 66FE            	  4195:                 bne.s *
                            	  4196: 
00:00002E32 4E75            	  4197:                 rts
                            	  4198: 
                            	  4199: 
00:00002E34 283C44444444    	  4200: BSR_FAR2:       move.l #$44444444,d4
00:00002E3A 4E75            	  4201:                 rts
                            	  4202: 
                            	  4203: 
                            	  4204: *-----------------------------------------------------------
                            	  4205: *-----------------------------------------------------------
                            	  4206: * OPCODE : BCC
                            	  4207: *-----------------------------------------------------------
                            	  4208: *-----------------------------------------------------------
                            	  4209: 
00:00002E3C 44FC0000        	  4210: op_BCC:         move #$00,CCR
00:00002E40 6202            	  4211:                 bhi.s BCC1            * Higher Than         C=0 AND Z=0
00:00002E42 60FE            	  4212:                 bra.s *
                            	  4213: 
00:00002E44 44FC0001        	  4214: BCC1:           move #$01,CCR
00:00002E48 63000004        	  4215:                 bls.w BCC2            * Lower or Same       C=1 OR Z=1
00:00002E4C 60FE            	  4216:                 bra.s *
                            	  4217: 
00:00002E4E 44FC0000        	  4218: BCC2:           move #$00,CCR
00:00002E52 6402            	  4219:                 bcc.s BCC3            * Carry Clear         C=0
00:00002E54 60FE            	  4220:                 bra.s *
                            	  4221: 
00:00002E56 44FC0001        	  4222: BCC3:           move #$01,CCR
00:00002E5A 65000004        	  4223:                 bcs.w BCC4            * Carry Set           C=1
00:00002E5E 60FE            	  4224:                 bra.s *
                            	  4225: 
00:00002E60 44FC0000        	  4226: BCC4:           move #$00,CCR
00:00002E64 6602            	  4227:                 bne.s BCC5            * Not Equal           Z=0
00:00002E66 60FE            	  4228:                 bra.s *
                            	  4229: 
00:00002E68 44FC0004        	  4230: BCC5:           move #$04,CCR
00:00002E6C 67000004        	  4231:                 beq.w BCC6            * Equal               Z=1
00:00002E70 60FE            	  4232:                 bra.s *
                            	  4233: 
00:00002E72 44FC0000        	  4234: BCC6:           move #$00,CCR
00:00002E76 6802            	  4235:                 bvc.s BCC7            * V Clear             V=0
00:00002E78 60FE            	  4236:                 bra.s *
                            	  4237: 
00:00002E7A 44FC0002        	  4238: BCC7:           move #$02,CCR
00:00002E7E 69000004        	  4239:                 bvs.w BCC8            * V Set               V=1
00:00002E82 60FE            	  4240:                 bra.s *
                            	  4241: 
00:00002E84 44FC0000        	  4242: BCC8:           move #$00,CCR
00:00002E88 6A02            	  4243:                 bpl.s BCC9            * Plus                N=0
00:00002E8A 60FE            	  4244:                 bra.s *
                            	  4245: 
00:00002E8C 44FC0008        	  4246: BCC9:           move #$08,CCR
00:00002E90 6B000004        	  4247:                 bmi.w BCC10           * Minus               N=1
00:00002E94 60FE            	  4248:                 bra.s *
                            	  4249: 
00:00002E96 44FC0000        	  4250: BCC10:          move #$00,CCR
00:00002E9A 6C02            	  4251:                 bge.s BCC11           * Greater or Equal    N=V
00:00002E9C 60FE            	  4252:                 bra.s *
                            	  4253: 
00:00002E9E 44FC0002        	  4254: BCC11:          move #$02,CCR
00:00002EA2 6D000004        	  4255:                 blt.w BCC12           * Less Than           N!=V
00:00002EA6 60FE            	  4256:                 bra.s *
                            	  4257: 
00:00002EA8 44FC000A        	  4258: BCC12:          move #$0A,CCR
00:00002EAC 6E02            	  4259:                 bgt.s BCC13           * Greater Than        N=V  AND Z=0
00:00002EAE 60FE            	  4260:                 bra.s *
                            	  4261: 
00:00002EB0 44FC0006        	  4262: BCC13:          move #$06,CCR
00:00002EB4 6F000004        	  4263:                 ble.w BCC14           * Less Than or Equal  N!=V AND Z=1
00:00002EB8 60FE            	  4264:                 bra.s *
                            	  4265: 
                            	  4266: 
00:00002EBA 4E75            	  4267: BCC14:          rts
                            	  4268: 
                            	  4269: 
                            	  4270: *-----------------------------------------------------------
                            	  4271: *-----------------------------------------------------------
                            	  4272: * OPCODE : DBCC
                            	  4273: *-----------------------------------------------------------
                            	  4274: *-----------------------------------------------------------
                            	  4275: 
00:00002EBC 7003            	  4276: op_DBCC:        moveq  #$00000003,d0    * Loop counter
00:00002EBE 7200            	  4277:                 moveq  #$00000000,d1    * Accumulator
00:00002EC0 44FC0000        	  4278:                 move #$00,CCR
                            	  4279: 
00:00002EC4 5201            	  4280: DBCC_LOOP1:     addi.b #$1,d1
00:00002EC6 51C8FFFC        	  4281:                 dbf d0,DBCC_LOOP1
                            	  4282: 
00:00002ECA 0C8100000004    	  4283:                 cmpi.l #$00000004,d1  * Check Accumulator results
00:00002ED0 66FE            	  4284:                 bne.s *
                            	  4285: 
00:00002ED2 5201            	  4286: DBCC_LOOP2:     addi.b #$1,d1
00:00002ED4 54C8FFFC        	  4287:                 dbcc d0,DBCC_LOOP2    * Dont loop
                            	  4288: 
00:00002ED8 0C8100000005    	  4289:                 cmpi.l #$00000005,d1  * Check Accumulator results
00:00002EDE 66FE            	  4290:                 bne.s *
                            	  4291: 
00:00002EE0 4E75            	  4292:                 rts
                            	  4293: 
                            	  4294: 
                            	  4295: *-----------------------------------------------------------
                            	  4296: *-----------------------------------------------------------
                            	  4297: * OPCODE : SCC
                            	  4298: *-----------------------------------------------------------
                            	  4299: *-----------------------------------------------------------
                            	  4300: 
00:00002EE2 44FC0001        	  4301: op_SCC:         move #$01,CCR
00:00002EE6 54F900010000    	  4302:                 scc $00010000                   * Clear the EA byte
00:00002EEC 4A3900010000    	  4303:                 cmpi.b #$00,$00010000
00:00002EF2 66FE            	  4304:                 bne.s *
                            	  4305: 
00:00002EF4 44FC0000        	  4306:                 move #$00,CCR
00:00002EF8 54F900010000    	  4307:                 scc $00010000                   * Set the EA byte to 0xFF
00:00002EFE 0C3900FF00010000	  4308:                 cmpi.b #$FF,$00010000
00:00002F06 66FE            	  4309:                 bne.s *
                            	  4310: 
00:00002F08 54C0            	  4311: 								scc d0													* Test setting a data register
00:00002F0A 0C0000FF        	  4312: 								cmpi.b #$FF,d0
00:00002F0E 66FE            	  4313: 								bne.s *
00:00002F10 4E75            	  4314:                 rts
                            	  4315: 
                            	  4316: 
                            	  4317: 
                            	  4318: *-----------------------------------------------------------
                            	  4319: *-----------------------------------------------------------
                            	  4320: * OPCODE : ADDQ
                            	  4321: *-----------------------------------------------------------
                            	  4322: *-----------------------------------------------------------
                            	  4323: 
                            	  4324: op_ADDQ:
                            	  4325: 
                            	  4326: *     BYTE
00:00002F12 203C000000FF    	  4327:                 move.l #$000000FF,d0    * Loop counter
00:00002F18 7200            	  4328:                 moveq  #$00000000,d1    * Flag results accumulator
00:00002F1A 7400            	  4329:                 moveq  #$00000000,d2    * Data results accumulator
00:00002F1C 7600            	  4330:                 moveq  #$00000000,d3
00:00002F1E 7800            	  4331:                 moveq  #$00000000,d4
00:00002F20 7A00            	  4332:                 moveq  #$00000000,d5
00:00002F22 7C00            	  4333:                 moveq  #$00000000,d6
00:00002F24 7E00            	  4334:                 moveq  #$00000000,d7
                            	  4335: 
00:00002F26 5605            	  4336: ADDQ_LOOP1:     addq.b #3,d5
00:00002F28 40C6            	  4337:                 move.w SR,d6
00:00002F2A 02860000001F    	  4338:                 andi.l #$1F,d6        * Isolate flags
00:00002F30 D286            	  4339:                 add.l d6,d1           * Copy flag results into accumulator
00:00002F32 D485            	  4340:                 add.l d5,d2           * Copy data results into data accumulator
00:00002F34 51C8FFF0        	  4341:                 dbf d0,ADDQ_LOOP1
                            	  4342: 
00:00002F38 0C810000043D    	  4343:                 cmpi.l #$0000043D,d1
00:00002F3E 66FE            	  4344:                 bne.s *
00:00002F40 0C8200007F80    	  4345:                 cmpi.l #$00007F80,d2
00:00002F46 66FE            	  4346:                 bne.s *
                            	  4347: 
                            	  4348: 
                            	  4349: *     WORD
00:00002F48 203C000000FF    	  4350:                 move.l #$000000FF,d0    * Loop counter
00:00002F4E 7200            	  4351:                 moveq  #$00000000,d1    * Flag results accumulator
00:00002F50 7400            	  4352:                 moveq  #$00000000,d2    * Data results accumulator
00:00002F52 7600            	  4353:                 moveq  #$00000000,d3
00:00002F54 7800            	  4354:                 moveq  #$00000000,d4
00:00002F56 2A3C0000FFF0    	  4355:                 move.l #$0000FFF0,d5
00:00002F5C 7C00            	  4356:                 moveq  #$00000000,d6
00:00002F5E 7E00            	  4357:                 moveq  #$00000000,d7
00:00002F60 307C0100        	  4358:                 move.l #$00000100,a0
                            	  4359: 
00:00002F64 5A45            	  4360: ADDQ_LOOP2:     addq.w #5,d5
00:00002F66 40C6            	  4361:                 move.w SR,d6
00:00002F68 02860000001F    	  4362:                 andi.l #$1F,d6        * Isolate flags
00:00002F6E D286            	  4363:                 add.l d6,d1           * Copy flag results into accumulator
00:00002F70 D485            	  4364:                 add.l d5,d2           * Copy data results into data accumulator
00:00002F72 51C8FFF0        	  4365:                 dbf d0,ADDQ_LOOP2
                            	  4366: 
00:00002F76 0C8100000029    	  4367:                 cmpi.l #$00000029,d1
00:00002F7C 66FE            	  4368:                 bne.s *
00:00002F7E 0C8200057280    	  4369:                 cmpi.l #$00057280,d2
00:00002F84 66FE            	  4370:                 bne.s *
                            	  4371: 
                            	  4372: 
                            	  4373: *     LONG
00:00002F86 203C000000FF    	  4374:                 move.l #$000000FF,d0    * Loop counter
00:00002F8C 7200            	  4375:                 moveq  #$00000000,d1    * Flag results accumulator
00:00002F8E 7400            	  4376:                 moveq  #$00000000,d2    * Data results accumulator
00:00002F90 7600            	  4377:                 moveq  #$00000000,d3
00:00002F92 7800            	  4378:                 moveq  #$00000000,d4
00:00002F94 7AF0            	  4379:                 move.l #$FFFFFFF0,d5
00:00002F96 7C00            	  4380:                 moveq  #$00000000,d6
00:00002F98 7E00            	  4381:                 moveq  #$00000000,d7
                            	  4382: 
00:00002F9A 5285            	  4383: ADDQ_LOOP3:     addq.l #1,d5
00:00002F9C 40C6            	  4384:                 move.w SR,d6
00:00002F9E 02860000001F    	  4385:                 andi.l #$1F,d6        * Isolate flags
00:00002FA4 D286            	  4386:                 add.l d6,d1           * Copy flag results into accumulator
00:00002FA6 D485            	  4387:                 add.l d5,d2           * Copy data results into data accumulator
00:00002FA8 51C8FFF0        	  4388:                 dbf d0,ADDQ_LOOP3
                            	  4389: 
00:00002FAC 0C810000008D    	  4390:                 cmpi.l #$0000008D,d1
00:00002FB2 66FE            	  4391:                 bne.s *
00:00002FB4 0C8200007080    	  4392:                 cmpi.l #$00007080,d2
00:00002FBA 66FE            	  4393:                 bne.s *
                            	  4394: 
                            	  4395: *     Check that Flags are not updated for Address registers
00:00002FBC 207C0000FFFF    	  4396:                 move.l #$0000FFFF,a0
00:00002FC2 44FC0000        	  4397:                 move #$00,CCR         * Clear flags
00:00002FC6 5E48            	  4398:                 addq.w #$7,a0
00:00002FC8 65FE            	  4399:                 bcs.s *
                            	  4400: 
00:00002FCA 4E75            	  4401:                 rts
                            	  4402: 
                            	  4403: 
                            	  4404: 
                            	  4405: *-----------------------------------------------------------
                            	  4406: *-----------------------------------------------------------
                            	  4407: * OPCODE : SUBQ
                            	  4408: *-----------------------------------------------------------
                            	  4409: *-----------------------------------------------------------
                            	  4410: 
                            	  4411: op_SUBQ:
                            	  4412: 
                            	  4413: *     BYTE
00:00002FCC 203C000000FF    	  4414:                 move.l #$000000FF,d0    * Loop counter
00:00002FD2 7200            	  4415:                 moveq  #$00000000,d1    * Flag results accumulator
00:00002FD4 243C00001234    	  4416:                 move.l #$00001234,d2    * Data results accumulator
00:00002FDA 7600            	  4417:                 moveq  #$00000000,d3
00:00002FDC 7800            	  4418:                 moveq  #$00000000,d4
00:00002FDE 7A12            	  4419:                 moveq  #$00000012,d5
00:00002FE0 7C00            	  4420:                 moveq  #$00000000,d6
00:00002FE2 7E00            	  4421:                 moveq  #$00000000,d7
                            	  4422: 
00:00002FE4 5305            	  4423: SUBQ_LOOP1:     subq.b #1,d5
00:00002FE6 40C6            	  4424:                 move.w SR,d6
00:00002FE8 02860000001F    	  4425:                 andi.l #$1F,d6        * Isolate flags
00:00002FEE D286            	  4426:                 add.l d6,d1           * Copy flag results into accumulator
00:00002FF0 D485            	  4427:                 add.l d5,d2           * Copy data results into data accumulator
00:00002FF2 51C8FFF0        	  4428:                 dbf d0,SUBQ_LOOP1
                            	  4429: 
00:00002FF6 0C8100000417    	  4430:                 cmpi.l #$00000417,d1
00:00002FFC 66FE            	  4431:                 bne.s *
00:00002FFE 0C82000091B4    	  4432:                 cmpi.l #$000091B4,d2
00:00003004 66FE            	  4433:                 bne.s *
                            	  4434: 
                            	  4435: 
                            	  4436: *     WORD
00:00003006 203C000000FF    	  4437:                 move.l #$000000FF,d0    * Loop counter
00:0000300C 7200            	  4438:                 moveq  #$00000000,d1    * Flag results accumulator
00:0000300E 7400            	  4439:                 moveq  #$00000000,d2    * Data results accumulator
00:00003010 7600            	  4440:                 moveq  #$00000000,d3
00:00003012 7800            	  4441:                 moveq  #$00000000,d4
00:00003014 7A02            	  4442:                 moveq  #$00000002,d5
00:00003016 7C00            	  4443:                 moveq  #$00000000,d6
00:00003018 7E00            	  4444:                 moveq  #$00000000,d7
00:0000301A 307C0100        	  4445:                 move.l #$00000100,a0
                            	  4446: 
00:0000301E 5B45            	  4447: SUBQ_LOOP2:     subq.w #5,d5
00:00003020 40C6            	  4448:                 move.w SR,d6
00:00003022 02860000001F    	  4449:                 andi.l #$1F,d6        * Isolate flags
00:00003028 D286            	  4450:                 add.l d6,d1           * Copy flag results into accumulator
00:0000302A D485            	  4451:                 add.l d5,d2           * Copy data results into data accumulator
00:0000302C 51C8FFF0        	  4452:                 dbf d0,SUBQ_LOOP2
                            	  4453: 
00:00003030 0C8100000811    	  4454:                 cmpi.l #$00000811,d1
00:00003036 66FE            	  4455:                 bne.s *
00:00003038 0C8200FD7F80    	  4456:                 cmpi.l #$00FD7F80,d2
00:0000303E 66FE            	  4457:                 bne.s *
                            	  4458: 
                            	  4459: 
                            	  4460: *     LONG
00:00003040 203C000000FF    	  4461:                 move.l #$000000FF,d0    * Loop counter
00:00003046 7200            	  4462:                 moveq  #$00000000,d1    * Flag results accumulator
00:00003048 7400            	  4463:                 moveq  #$00000000,d2    * Data results accumulator
00:0000304A 7600            	  4464:                 moveq  #$00000000,d3
00:0000304C 7800            	  4465:                 moveq  #$00000000,d4
00:0000304E 7A07            	  4466:                 moveq  #$00000007,d5
00:00003050 7C00            	  4467:                 moveq  #$00000000,d6
00:00003052 7E00            	  4468:                 moveq  #$00000000,d7
                            	  4469: 
00:00003054 5385            	  4470: SUBQ_LOOP3:     subq.l #1,d5
00:00003056 40C6            	  4471:                 move.w SR,d6
00:00003058 02860000001F    	  4472:                 andi.l #$1F,d6        * Isolate flags
00:0000305E D286            	  4473:                 add.l d6,d1           * Copy flag results into accumulator
00:00003060 D485            	  4474:                 add.l d5,d2           * Copy data results into data accumulator
00:00003062 51C8FFF0        	  4475:                 dbf d0,SUBQ_LOOP3
                            	  4476: 
00:00003066 0C81000007DD    	  4477:                 cmpi.l #$000007DD,d1
00:0000306C 66FE            	  4478:                 bne.s *
00:0000306E 0C82FFFF8680    	  4479:                 cmpi.l #$FFFF8680,d2
00:00003074 66FE            	  4480:                 bne.s *
                            	  4481: 
                            	  4482: *     Check that Flags are not updated for Address registers
00:00003076 207C0001FFFF    	  4483:                 move.l #$0001FFFF,a0
00:0000307C 44FC0000        	  4484:                 move #$00,CCR         * Clear flags
00:00003080 5F48            	  4485:                 subq.w #$7,a0
00:00003082 65FE            	  4486:                 bcs.s *
                            	  4487: 
00:00003084 4E75            	  4488:                 rts
                            	  4489: 
                            	  4490: 
                            	  4491: 
                            	  4492: 
                            	  4493: *-----------------------------------------------------------
                            	  4494: *-----------------------------------------------------------
                            	  4495: * OPCODE : MOVEQ
                            	  4496: *-----------------------------------------------------------
                            	  4497: *-----------------------------------------------------------
                            	  4498: 
                            	  4499: op_MOVEQ:
00:00003086 7000            	  4500:                 moveq  #$00000000,d0
00:00003088 7000            	  4501:                 moveq #$0,d0
00:0000308A 66FE            	  4502:                 bne.s *
00:0000308C 4A80            	  4503:                 cmpi.l #$00000000,d0
00:0000308E 66FE            	  4504:                 bne.s *
                            	  4505: 
00:00003090 7000            	  4506:                 moveq  #$00000000,d0
00:00003092 7080            	  4507:                 moveq #-128,d0
00:00003094 67FE            	  4508:                 beq.s *
00:00003096 6AFE            	  4509:                 bpl.s *
00:00003098 0C80FFFFFF80    	  4510:                 cmpi.l #$FFFFFF80,d0
00:0000309E 66FE            	  4511:                 bne.s *
                            	  4512: 
                            	  4513: 
00:000030A0 4E75            	  4514:                 rts
                            	  4515: 
                            	  4516: 
                            	  4517: *-----------------------------------------------------------
                            	  4518: *-----------------------------------------------------------
                            	  4519: * OPCODE : DIVU
                            	  4520: *-----------------------------------------------------------
                            	  4521: *-----------------------------------------------------------
                            	  4522: 
                            	  4523: op_DIVU:
                            	  4524: 
00:000030A2 203CA5A5A5A5    	  4525:                 move.l #$a5a5a5a5,d0        * Initial Numerator
00:000030A8 223C00005A5A    	  4526:                 move.l #$00005a5a,d1        * Initial Divisor
00:000030AE 243CA5A5A5A5    	  4527:                 move.l #$a5a5a5a5,d2
00:000030B4 7600            	  4528:                 moveq  #$00000000,d3
00:000030B6 7800            	  4529:                 moveq  #$00000000,d4        * Cumulative data results
00:000030B8 7A00            	  4530:                 moveq  #$00000000,d5       * Cumulative flag results
00:000030BA 7C0E            	  4531:                 move.l #$0000000E,d6       * Inner loop counter
00:000030BC 7E1E            	  4532:                 move.l #$0000001E,d7       * Outer loop counter
                            	  4533: 
                            	  4534: 
00:000030BE 80C1            	  4535: DIVU_OUTER1:    divu d1,d0               * !! Easy68K C not always cleared
00:000030C0 40C3            	  4536:                 move.w SR,d3
00:000030C2 02830000000C    	  4537:                 andi.l #$0C,d3            * Isolate flags
00:000030C8 DA83            	  4538:                 add.l d3,d5               * Copy flag results into accumulator
00:000030CA D880            	  4539:                 add.l d0,d4               * Copy data results into data accumulator
00:000030CC E289            	  4540:                 lsr.l #$1,d1
                            	  4541: 
00:000030CE 51CEFFEE        	  4542:                 dbf d6,DIVU_OUTER1
00:000030D2 E28A            	  4543:                 lsr.l #$1,d2
00:000030D4 2002            	  4544:                 move.l d2,d0
00:000030D6 223C00005A5A    	  4545:                 move.l #$00005a5a,d1       * Initial Divisor
00:000030DC 7C0E            	  4546:                 move.l #$0000000E,d6       * Inner loop counter
00:000030DE 51CFFFDE        	  4547:                 dbf d7,DIVU_OUTER1
                            	  4548: 
00:000030E2 0C8492FEDB89    	  4549:                 cmpi.l #$92FEDB89,d4      * Check the data results
00:000030E8 66FE            	  4550:                 bne.s *
                            	  4551: 
00:000030EA 0C8500000110    	  4552:                 cmpi.l #$00000110,d5      * Check the Flag results
00:000030F0 66FE            	  4553:                 bne.s *
                            	  4554: 
                            	  4555: 
00:000030F2 4E75            	  4556:                 rts
                            	  4557: 
                            	  4558: 
                            	  4559: 
                            	  4560: *-----------------------------------------------------------
                            	  4561: *-----------------------------------------------------------
                            	  4562: * OPCODE : DIVS
                            	  4563: *-----------------------------------------------------------
                            	  4564: *-----------------------------------------------------------
                            	  4565: 
                            	  4566: op_DIVS:
                            	  4567: 
00:000030F4 203CA5A5A5A5    	  4568: 	move.l #$a5a5a5a5,d0        * Initial Numerator
00:000030FA 223C00005A5A    	  4569: 	move.l #$00005a5a,d1        * Initial Divisor
00:00003100 243CA5A5A5A5    	  4570: 	move.l #$a5a5a5a5,d2
00:00003106 7600            	  4571: 	moveq  #$00000000,d3
00:00003108 7800            	  4572: 	moveq  #$00000000,d4        * Cumulative data results
00:0000310A 7A00            	  4573: 	moveq  #$00000000,d5       * Cumulative flag results
00:0000310C 7C0E            	  4574: 	move.l #$0000000E,d6       * Inner loop counter
00:0000310E 7E1E            	  4575: 	move.l #$0000001E,d7       * Outer loop counter
                            	  4576: 
                            	  4577: DIVS_OUTER1:
00:00003110 81C1            	  4578: 	divs d1,d0               * !! Easy68K C not always cleared
00:00003112 40C3            	  4579: 	move.w SR,d3
00:00003114 02830000000C    	  4580: 	andi.l #$0C,d3            * Isolate flags
00:0000311A DA83            	  4581: 	add.l d3,d5               * Copy flag results into accumulator
00:0000311C D880            	  4582: 	add.l d0,d4               * Copy data results into data accumulator
00:0000311E E289            	  4583: 	lsr.l #$1,d1
                            	  4584: 
00:00003120 51CEFFEE        	  4585: 	dbf d6,DIVS_OUTER1
00:00003124 E28A            	  4586: 	lsr.l #$1,d2
00:00003126 2002            	  4587: 	move.l d2,d0
00:00003128 223C00005A5A    	  4588: 	move.l #$00005a5a,d1       * Initial Divisor
00:0000312E 7C0E            	  4589: 	move.l #$0000000E,d6       * Inner loop counter
00:00003130 51CFFFDE        	  4590: 	dbf d7,DIVS_OUTER1
                            	  4591: 
00:00003134 0C844EC5D057    	  4592: 	cmpi.l #$4EC5D057,d4      * Check the data results
00:0000313A 66FE            	  4593: 	bne.s *
                            	  4594: 
00:0000313C 0C8500000038    	  4595: 	cmpi.l #$00000038,d5      * Check the Flag results
00:00003142 66FE            	  4596: 	bne.s *
00:00003144 4E75            	  4597: 	rts
                            	  4598: 
                            	  4599: 
                            	  4600: *-----------------------------------------------------------
                            	  4601: *-----------------------------------------------------------
                            	  4602: * OPCODE : OR
                            	  4603: *-----------------------------------------------------------
                            	  4604: *-----------------------------------------------------------
                            	  4605: 
                            	  4606: op_OR:
                            	  4607: 
                            	  4608: *  * <EA> to Register
                            	  4609: 
00:00003146 203CA5A5A5A5    	  4610:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:0000314C 223C8167E123    	  4611:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00003152 243CA5A5A5A5    	  4612:                 move.l #$a5a5a5a5,d2
00:00003158 7600            	  4613:                 moveq  #$00000000,d3
00:0000315A 7800            	  4614:                 moveq  #$00000000,d4       * Cumulative data results
00:0000315C 7A00            	  4615:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000315E 7C1E            	  4616:                 move.l #$0000001E,d6       * Inner loop counter
00:00003160 7E1E            	  4617:                 move.l #$0000001E,d7       * Outer loop counter
00:00003162 307C0100        	  4618:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4619: 
                            	  4620: 
                            	  4621: OR_OUTER1:
                            	  4622: 
                            	  4623: *     BYTE
00:00003166 2081            	  4624:                 move.l d1,(a0)
00:00003168 8010            	  4625:                 or.b (a0),d0
00:0000316A 40C3            	  4626:                 move.w SR,d3
00:0000316C 02830000000C    	  4627:                 andi.l #$0C,d3            * Isolate flags
00:00003172 DA83            	  4628:                 add.l d3,d5               * Copy flag results into accumulator
00:00003174 D880            	  4629:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4630: 
                            	  4631: *     WORD
00:00003176 2081            	  4632:                 move.l d1,(a0)
00:00003178 8050            	  4633:                 or.w (a0),d0
00:0000317A 40C3            	  4634:                 move.w SR,d3
00:0000317C 02830000000C    	  4635:                 andi.l #$0C,d3            * Isolate flags
00:00003182 DA83            	  4636:                 add.l d3,d5               * Copy flag results into accumulator
00:00003184 D880            	  4637:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4638: 
                            	  4639: *     LONG
00:00003186 2081            	  4640:                 move.l d1,(a0)
00:00003188 8090            	  4641:                 or.l (a0),d0
00:0000318A 40C3            	  4642:                 move.w SR,d3
00:0000318C 02830000000F    	  4643:                 andi.l #$0F,d3            * Isolate flags
00:00003192 DA83            	  4644:                 add.l d3,d5               * Copy flag results into accumulator
00:00003194 D880            	  4645:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4646: 
                            	  4647: 
00:00003196 E289            	  4648:                 lsr.l #$1,d1
00:00003198 51CEFFCC        	  4649:                 dbf d6,OR_OUTER1
00:0000319C E28A            	  4650:                 lsr.l #$1,d2
00:0000319E 223C8167E123    	  4651:                 move.l #$8167E123,d1       * Initial Data-Y
00:000031A4 7C1E            	  4652:                 move.l #$0000001E,d6       * Inner loop counter
00:000031A6 51CFFFBE        	  4653:                 dbf d7,OR_OUTER1
                            	  4654: 
00:000031AA 0C8476EAC803    	  4655:                 cmpi.l #$76EAC803,d4      * Check the data results
00:000031B0 66FE            	  4656:                 bne.s *
00:000031B2 0C8500005A18    	  4657:                 cmpi.l #$00005A18,d5      * Check the Flag results
00:000031B8 66FE            	  4658:                 bne.s *
                            	  4659: 
                            	  4660: 
                            	  4661: *  * Register to <EA>
                            	  4662: 
00:000031BA 203C86738374    	  4663:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:000031C0 223CFC55F2FE    	  4664:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:000031C6 243C86738374    	  4665:                 move.l #$86738374,d2
00:000031CC 7600            	  4666:                 moveq  #$00000000,d3
00:000031CE 7800            	  4667:                 moveq  #$00000000,d4       * Cumulative data results
00:000031D0 7A00            	  4668:                 moveq  #$00000000,d5       * Cumulative flag results
00:000031D2 7C1E            	  4669:                 move.l #$0000001E,d6       * Inner loop counter
00:000031D4 7E1D            	  4670:                 move.l #$0000001D,d7       * Outer loop counter
00:000031D6 307C0100        	  4671:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4672: 
                            	  4673: 
                            	  4674: OR_OUTER2:
                            	  4675: 
                            	  4676: *     BYTE
00:000031DA 2080            	  4677:                 move.l d0,(a0)
00:000031DC 8310            	  4678:                 or.b d1,(a0)
00:000031DE 40C3            	  4679:                 move.w SR,d3
00:000031E0 02830000000C    	  4680:                 andi.l #$0C,d3            * Isolate flags
00:000031E6 DA83            	  4681:                 add.l d3,d5               * Copy flag results into accumulator
00:000031E8 D890            	  4682:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4683: 
                            	  4684: *     WORD
00:000031EA 2080            	  4685:                 move.l d0,(a0)
00:000031EC 8350            	  4686:                 or.w d1,(a0)
00:000031EE 40C3            	  4687:                 move.w SR,d3
00:000031F0 02830000000C    	  4688:                 andi.l #$0C,d3            * Isolate flags
00:000031F6 DA83            	  4689:                 add.l d3,d5               * Copy flag results into accumulator
00:000031F8 D890            	  4690:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4691: 
                            	  4692: *     LONG
00:000031FA 2080            	  4693:                 move.l d0,(a0)
00:000031FC 8390            	  4694:                 or.l d1,(a0)
00:000031FE 40C3            	  4695:                 move.w SR,d3
00:00003200 02830000000F    	  4696:                 andi.l #$0F,d3            * Isolate flags
00:00003206 DA83            	  4697:                 add.l d3,d5               * Copy flag results into accumulator
00:00003208 D890            	  4698:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4699: 
                            	  4700: 
00:0000320A E289            	  4701:                 lsr.l #$1,d1
00:0000320C 51CEFFCC        	  4702:                 dbf d6,OR_OUTER2
00:00003210 E28A            	  4703:                 lsr.l #$1,d2
00:00003212 223C8167E123    	  4704:                 move.l #$8167E123,d1       * Initial Data-Y
00:00003218 7C1E            	  4705:                 move.l #$0000001E,d6       * Inner loop counter
00:0000321A 51CFFFBE        	  4706:                 dbf d7,OR_OUTER2
                            	  4707: 
00:0000321E 0C84FA82B9E4    	  4708:                 cmpi.l #$FA82B9E4,d4      * Check the data results
00:00003224 66FE            	  4709:                 bne.s *
00:00003226 0C8500005730    	  4710:                 cmpi.l #$00005730,d5      * Check the Flag results
00:0000322C 66FE            	  4711:                 bne.s *
                            	  4712: 
                            	  4713: 
00:0000322E 4E75            	  4714:                 rts
                            	  4715: 
                            	  4716: 
                            	  4717: 
                            	  4718: *-----------------------------------------------------------
                            	  4719: *-----------------------------------------------------------
                            	  4720: * OPCODE : AND
                            	  4721: *-----------------------------------------------------------
                            	  4722: *-----------------------------------------------------------
                            	  4723: 
                            	  4724: op_AND:
                            	  4725: 
                            	  4726: *  * <EA> to Register
                            	  4727: 
00:00003230 203CA5A5A5A5    	  4728:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00003236 223C8167E123    	  4729:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:0000323C 243CA5A5A5A5    	  4730:                 move.l #$a5a5a5a5,d2
00:00003242 7600            	  4731:                 moveq  #$00000000,d3
00:00003244 7800            	  4732:                 moveq  #$00000000,d4       * Cumulative data results
00:00003246 7A00            	  4733:                 moveq  #$00000000,d5       * Cumulative flag results
00:00003248 7C1E            	  4734:                 move.l #$0000001E,d6       * Inner loop counter
00:0000324A 7E1E            	  4735:                 move.l #$0000001E,d7       * Outer loop counter
00:0000324C 307C0100        	  4736:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4737: 
                            	  4738: 
                            	  4739: AND_OUTER1:
                            	  4740: 
                            	  4741: *     BYTE
00:00003250 2081            	  4742:                 move.l d1,(a0)
00:00003252 C010            	  4743:                 and.b (a0),d0
00:00003254 40C3            	  4744:                 move.w sr,d3
00:00003256 02830000000C    	  4745:                 andi.l #$0C,d3            * Isolate flags
00:0000325C DA83            	  4746:                 add.l d3,d5               * Copy flag results into accumulator
00:0000325E D880            	  4747:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4748: 
                            	  4749: *     WORD
00:00003260 2081            	  4750:                 move.l d1,(a0)
00:00003262 C050            	  4751:                 and.w (a0),d0
00:00003264 40C3            	  4752:                 move.w sr,d3
00:00003266 02830000000C    	  4753:                 andi.l #$0C,d3            * Isolate flags
00:0000326C DA83            	  4754:                 add.l d3,d5               * Copy flag results into accumulator
00:0000326E D880            	  4755:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4756: 
                            	  4757: *     LONG
00:00003270 2081            	  4758:                 move.l d1,(a0)
00:00003272 C090            	  4759:                 and.l (a0),d0
00:00003274 40C3            	  4760:                 move.w sr,d3
00:00003276 02830000000F    	  4761:                 andi.l #$0F,d3            * Isolate flags
00:0000327C DA83            	  4762:                 add.l d3,d5               * Copy flag results into accumulator
00:0000327E D880            	  4763:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4764: 
                            	  4765: 
00:00003280 E289            	  4766:                 lsr.l #$1,d1
00:00003282 51CEFFCC        	  4767:                 dbf d6,AND_OUTER1
00:00003286 E28A            	  4768:                 lsr.l #$1,d2
00:00003288 223C8167E123    	  4769:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000328E 7C1E            	  4770:                 move.l #$0000001E,d6       * Inner loop counter
00:00003290 51CFFFBE        	  4771:                 dbf d7,AND_OUTER1
                            	  4772: 
00:00003294 0C84CF212883    	  4773:                 cmpi.l #$CF212883,d4      * Check the data results
00:0000329A 66FE            	  4774:                 bne.s *
00:0000329C 0C8500002D10    	  4775:                 cmpi.l #$00002D10,d5      * Check the Flag results
00:000032A2 66FE            	  4776:                 bne.s *
                            	  4777: 
                            	  4778: 
                            	  4779: *  * Register to <EA>
                            	  4780: 
00:000032A4 203C86738374    	  4781:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:000032AA 223CFC55F2FE    	  4782:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:000032B0 243C86738374    	  4783:                 move.l #$86738374,d2
00:000032B6 7600            	  4784:                 moveq  #$00000000,d3
00:000032B8 7800            	  4785:                 moveq  #$00000000,d4       * Cumulative data results
00:000032BA 7A00            	  4786:                 moveq  #$00000000,d5       * Cumulative flag results
00:000032BC 7C1E            	  4787:                 move.l #$0000001E,d6       * Inner loop counter
00:000032BE 7E1D            	  4788:                 move.l #$0000001D,d7       * Outer loop counter
00:000032C0 307C0100        	  4789:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4790: 
                            	  4791: 
                            	  4792: AND_OUTER2:
                            	  4793: 
                            	  4794: *     BYTE
00:000032C4 2080            	  4795:                 move.l d0,(a0)
00:000032C6 C310            	  4796:                 and.b d1,(a0)
00:000032C8 40C3            	  4797:                 move.w sr,d3
00:000032CA 02830000000C    	  4798:                 andi.l #$0C,d3            * Isolate flags
00:000032D0 DA83            	  4799:                 add.l d3,d5               * Copy flag results into accumulator
00:000032D2 D890            	  4800:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4801: 
                            	  4802: *     WORD
00:000032D4 2080            	  4803:                 move.l d0,(a0)
00:000032D6 C350            	  4804:                 and.w d1,(a0)
00:000032D8 40C3            	  4805:                 move.w sr,d3
00:000032DA 02830000000C    	  4806:                 andi.l #$0C,d3            * Isolate flags
00:000032E0 DA83            	  4807:                 add.l d3,d5               * Copy flag results into accumulator
00:000032E2 D890            	  4808:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4809: 
                            	  4810: *     LONG
00:000032E4 2080            	  4811:                 move.l d0,(a0)
00:000032E6 C390            	  4812:                 and.l d1,(a0)
00:000032E8 40C3            	  4813:                 move.w sr,d3
00:000032EA 02830000000F    	  4814:                 andi.l #$0F,d3            * Isolate flags
00:000032F0 DA83            	  4815:                 add.l d3,d5               * Copy flag results into accumulator
00:000032F2 D890            	  4816:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4817: 
                            	  4818: 
00:000032F4 E289            	  4819:                 lsr.l #$1,d1
00:000032F6 51CEFFCC        	  4820:                 dbf d6,AND_OUTER2
00:000032FA E28A            	  4821:                 lsr.l #$1,d2
00:000032FC 223C8167E123    	  4822:                 move.l #$8167E123,d1       * Initial Data-Y
00:00003302 7C1E            	  4823:                 move.l #$0000001E,d6       * Inner loop counter
00:00003304 51CFFFBE        	  4824:                 dbf d7,AND_OUTER2
                            	  4825: 
00:00003308 0C844A3DE544    	  4826:                 cmpi.l #$4A3DE544,d4      * Check the data results
00:0000330E 66FE            	  4827:                 bne.s *
00:00003310 0C85000018E8    	  4828:                 cmpi.l #$000018E8,d5      * Check the Flag results
00:00003316 66FE            	  4829:                 bne.s *
                            	  4830: 
                            	  4831: 
00:00003318 4E75            	  4832:                 rts
                            	  4833: 
                            	  4834: 
                            	  4835: 
                            	  4836: *-----------------------------------------------------------
                            	  4837: *-----------------------------------------------------------
                            	  4838: * OPCODE : EOR
                            	  4839: *-----------------------------------------------------------
                            	  4840: *-----------------------------------------------------------
                            	  4841: 
                            	  4842: op_EOR:
                            	  4843: 
                            	  4844: *  * Register to <EA>
                            	  4845: 
00:0000331A 203C86738374    	  4846:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:00003320 223CFC55F2FE    	  4847:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:00003326 243C86738374    	  4848:                 move.l #$86738374,d2
00:0000332C 7600            	  4849:                 moveq  #$00000000,d3
00:0000332E 7800            	  4850:                 moveq  #$00000000,d4       * Cumulative data results
00:00003330 7A00            	  4851:                 moveq  #$00000000,d5       * Cumulative flag results
00:00003332 7C1E            	  4852:                 move.l #$0000001E,d6       * Inner loop counter
00:00003334 7E1D            	  4853:                 move.l #$0000001D,d7       * Outer loop counter
00:00003336 307C0100        	  4854:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4855: 
                            	  4856: 
                            	  4857: EOR_OUTER2:
                            	  4858: 
                            	  4859: *     BYTE
00:0000333A 2080            	  4860:                 move.l d0,(a0)
00:0000333C B310            	  4861:                 eor.b d1,(a0)
00:0000333E 40C3            	  4862:                 move.w sr,d3
00:00003340 02830000000C    	  4863:                 andi.l #$0C,d3            * Isolate flags
00:00003346 DA83            	  4864:                 add.l d3,d5               * Copy flag results into accumulator
00:00003348 D890            	  4865:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4866: 
                            	  4867: *     WORD
00:0000334A 2080            	  4868:                 move.l d0,(a0)
00:0000334C B350            	  4869:                 eor.w d1,(a0)
00:0000334E 40C3            	  4870:                 move.w sr,d3
00:00003350 02830000000C    	  4871:                 andi.l #$0C,d3            * Isolate flags
00:00003356 DA83            	  4872:                 add.l d3,d5               * Copy flag results into accumulator
00:00003358 D890            	  4873:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4874: 
                            	  4875: *     LONG
00:0000335A 2080            	  4876:                 move.l d0,(a0)
00:0000335C B390            	  4877:                 eor.l d1,(a0)
00:0000335E 40C3            	  4878:                 move.w sr,d3
00:00003360 02830000000F    	  4879:                 andi.l #$0F,d3            * Isolate flags
00:00003366 DA83            	  4880:                 add.l d3,d5               * Copy flag results into accumulator
00:00003368 D890            	  4881:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4882: 
                            	  4883: 
00:0000336A E289            	  4884:                 lsr.l #$1,d1
00:0000336C 51CEFFCC        	  4885:                 dbf d6,EOR_OUTER2
00:00003370 E28A            	  4886:                 lsr.l #$1,d2
00:00003372 223C8167E123    	  4887:                 move.l #$8167E123,d1       * Initial Data-Y
00:00003378 7C1E            	  4888:                 move.l #$0000001E,d6       * Inner loop counter
00:0000337A 51CFFFBE        	  4889:                 dbf d7,EOR_OUTER2
                            	  4890: 
00:0000337E 0C8455C5EB70    	  4891:                 cmpi.l #$55C5EB70,d4      * Check the data results
00:00003384 66FE            	  4892:                 bne.s *
00:00003386 0C8500004430    	  4893:                 cmpi.l #$00004430,d5      * Check the Flag results
00:0000338C 66FE            	  4894:                 bne.s *
                            	  4895: 
                            	  4896: 
00:0000338E 4E75            	  4897:                 rts
                            	  4898: 
                            	  4899: 
                            	  4900: *-----------------------------------------------------------
                            	  4901: *-----------------------------------------------------------
                            	  4902: * OPCODE : CMP
                            	  4903: *-----------------------------------------------------------
                            	  4904: *-----------------------------------------------------------
                            	  4905: 
                            	  4906: op_CMP:
                            	  4907: 
                            	  4908: 
                            	  4909: *  * <EA> to Register
                            	  4910: 
00:00003390 203CA5A5A5A5    	  4911:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00003396 223C8167E123    	  4912:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:0000339C 243CA5A5A5A5    	  4913:                 move.l #$a5a5a5a5,d2
00:000033A2 7600            	  4914:                 moveq  #$00000000,d3
00:000033A4 7800            	  4915:                 moveq  #$00000000,d4       * Cumulative data results
00:000033A6 7A00            	  4916:                 moveq  #$00000000,d5       * Cumulative flag results
00:000033A8 7C1E            	  4917:                 move.l #$0000001E,d6       * Inner loop counter
00:000033AA 7E1E            	  4918:                 move.l #$0000001E,d7       * Outer loop counter
00:000033AC 307C0100        	  4919:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4920: 
                            	  4921: 
                            	  4922: CMP_OUTER1:
                            	  4923: 
                            	  4924: *     BYTE
00:000033B0 2081            	  4925:                 move.l d1,(a0)
00:000033B2 B010            	  4926:                 cmp.b (a0),d0
00:000033B4 40C3            	  4927:                 move.w sr,d3
00:000033B6 02830000000F    	  4928:                 andi.l #$0F,d3            * Isolate flags
00:000033BC DA83            	  4929:                 add.l d3,d5               * Copy flag results into accumulator
00:000033BE D880            	  4930:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4931: 
                            	  4932: *     WORD
00:000033C0 2081            	  4933:                 move.l d1,(a0)
00:000033C2 B050            	  4934:                 cmp.w (a0),d0
00:000033C4 40C3            	  4935:                 move.w sr,d3
00:000033C6 02830000000F    	  4936:                 andi.l #$0F,d3            * Isolate flags
00:000033CC DA83            	  4937:                 add.l d3,d5               * Copy flag results into accumulator
00:000033CE D880            	  4938:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4939: 
                            	  4940: *     LONG
00:000033D0 2081            	  4941:                 move.l d1,(a0)
00:000033D2 B090            	  4942:                 cmp.l (a0),d0
00:000033D4 40C3            	  4943:                 move.w sr,d3
00:000033D6 02830000000F    	  4944:                 andi.l #$0F,d3            * Isolate flags
00:000033DC DA83            	  4945:                 add.l d3,d5               * Copy flag results into accumulator
00:000033DE D880            	  4946:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4947: 
                            	  4948: 
00:000033E0 E289            	  4949:                 lsr.l #$1,d1
00:000033E2 51CEFFCC        	  4950:                 dbf d6,CMP_OUTER1
00:000033E6 E28A            	  4951:                 lsr.l #$1,d2
00:000033E8 223C8167E123    	  4952:                 move.l #$8167E123,d1       * Initial Data-Y
00:000033EE 7C1E            	  4953:                 move.l #$0000001E,d6       * Inner loop counter
00:000033F0 51CFFFBE        	  4954:                 dbf d7,CMP_OUTER1
                            	  4955: 
00:000033F4 0C847878712F    	  4956:                 cmpi.l #$7878712F,d4      * Check the data results
00:000033FA 66FE            	  4957:                 bne.s *
00:000033FC 0C8500005502    	  4958:                 cmpi.l #$00005502,d5      * Check the Flag results
00:00003402 66FE            	  4959:                 bne.s *
                            	  4960: 
                            	  4961: 
                            	  4962: 
00:00003404 4E75            	  4963:                 rts
                            	  4964: 
                            	  4965: 
                            	  4966: *-----------------------------------------------------------
                            	  4967: *-----------------------------------------------------------
                            	  4968: * OPCODE : CMPA
                            	  4969: *-----------------------------------------------------------
                            	  4970: *-----------------------------------------------------------
                            	  4971: 
                            	  4972: op_CMPA:
                            	  4973: 
                            	  4974: 
                            	  4975: *  * <EA> to Register
                            	  4976: 
00:00003406 207CA5A5A5A5    	  4977:                 move.l #$a5a5a5a5,a0       * Initial Data-X  Inner loop
00:0000340C 223C8167E123    	  4978:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00003412 243CA5A5A5A5    	  4979:                 move.l #$a5a5a5a5,d2
00:00003418 7600            	  4980:                 moveq  #$00000000,d3
00:0000341A 7800            	  4981:                 moveq  #$00000000,d4       * Cumulative data results
00:0000341C 7A00            	  4982:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000341E 7C1E            	  4983:                 move.l #$0000001E,d6       * Inner loop counter
00:00003420 7E1E            	  4984:                 move.l #$0000001E,d7       * Outer loop counter
00:00003422 327C0100        	  4985:                 move.l #$00000100,a1       * Address for memory EA operations
                            	  4986: 
                            	  4987: 
                            	  4988: CMPA_OUTER1:
                            	  4989: 
                            	  4990: 
                            	  4991: *     WORD
00:00003426 2281            	  4992:                 move.l d1,(a1)
00:00003428 B0D1            	  4993:                 cmpa.w (a1),a0
00:0000342A 40C3            	  4994:                 move.w sr,d3
00:0000342C 02830000000F    	  4995:                 andi.l #$0F,d3            * Isolate flags
00:00003432 DA83            	  4996:                 add.l d3,d5               * Copy flag results into accumulator
00:00003434 D888            	  4997:                 add.l a0,d4               * Copy data results into data accumulator
                            	  4998: 
                            	  4999: *     LONG
00:00003436 2281            	  5000:                 move.l d1,(a1)
00:00003438 B1D1            	  5001:                 cmpa.l (a1),a0
00:0000343A 40C3            	  5002:                 move.w sr,d3
00:0000343C 02830000000F    	  5003:                 andi.l #$0F,d3            * Isolate flags
00:00003442 DA83            	  5004:                 add.l d3,d5               * Copy flag results into accumulator
00:00003444 D888            	  5005:                 add.l a0,d4               * Copy data results into data accumulator
                            	  5006: 
                            	  5007: 
00:00003446 E289            	  5008:                 lsr.l #$1,d1
00:00003448 51CEFFDC        	  5009:                 dbf d6,CMPA_OUTER1
00:0000344C E28A            	  5010:                 lsr.l #$1,d2
00:0000344E 223C8167E123    	  5011:                 move.l #$8167E123,d1       * Initial Data-Y
00:00003454 7C1E            	  5012:                 move.l #$0000001E,d6       * Inner loop counter
00:00003456 51CFFFCE        	  5013:                 dbf d7,CMPA_OUTER1
                            	  5014: 
00:0000345A 0C84A5A5A0CA    	  5015:                 cmpi.l #$a5a5a0ca,d4      * Check the data results
00:00003460 66FE            	  5016:                 bne.s *
00:00003462 0C8500003A7D    	  5017:                 cmpi.l #$00003A7D,d5      * Check the Flag results
00:00003468 66FE            	  5018:                 bne.s *
                            	  5019: 
                            	  5020: 
00:0000346A 4E75            	  5021:                 rts
                            	  5022: 
                            	  5023: 
                            	  5024: 
                            	  5025: *-----------------------------------------------------------
                            	  5026: *-----------------------------------------------------------
                            	  5027: * OPCODE : CMPM
                            	  5028: *-----------------------------------------------------------
                            	  5029: *-----------------------------------------------------------
                            	  5030: 
                            	  5031: op_CMPM:
                            	  5032: 
00:0000346C 307C0100        	  5033:                 move.l #$00000100,a0       * Address for Data-X
00:00003470 327C0200        	  5034:                 move.l #$00000200,a1       * Address for Data-Y
00:00003474 7000            	  5035:                 moveq  #$00000000,d0
00:00003476 7200            	  5036:                 moveq  #$00000000,d1
00:00003478 7400            	  5037:                 moveq  #$00000000,d2
                            	  5038: 
00:0000347A 20FC11FF5580    	  5039:                 move.l #$11FF5580,(a0)+   * Populate test data
00:00003480 20FC1111FFFF    	  5040:                 move.l #$1111FFFF,(a0)+   * Populate test data
00:00003486 20FC33333333    	  5041:                 move.l #$33333333,(a0)+   * Populate test data
00:0000348C 20FC44444444    	  5042:                 move.l #$44444444,(a0)+   * Populate test data
                            	  5043: 
00:00003492 22FC80FF337F    	  5044:                 move.l #$80FF337F,(a1)+   * Populate test data
00:00003498 22FCFFFF1111    	  5045:                 move.l #$FFFF1111,(a1)+   * Populate test data
00:0000349E 22FC33333333    	  5046:                 move.l #$33333333,(a1)+   * Populate test data
00:000034A4 22FC44444444    	  5047:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5048: 
00:000034AA 307C0100        	  5049:                 move.l #$00000100,a0       * Address for Data-X
00:000034AE 327C0200        	  5050:                 move.l #$00000200,a1       * Address for Data-Y
00:000034B2 7C0F            	  5051:                 move.l #$0000000F,d6       * Loop counter
                            	  5052: 
00:000034B4 B308            	  5053: CMPM_LOOP1:     cmpm.b (a0)+,(a1)+
00:000034B6 40C3            	  5054:                 move.w sr,d3
00:000034B8 02830000000F    	  5055:                 andi.l #$0F,d3            * Isolate flags
00:000034BE D083            	  5056:                 add.l d3,d0               * Copy flag results into accumulator
00:000034C0 51CEFFF2        	  5057:                 dbf d6,CMPM_LOOP1
                            	  5058: 
                            	  5059: 
00:000034C4 307C0100        	  5060:                 move.l #$00000100,a0       * Address for Data-X
00:000034C8 327C0200        	  5061:                 move.l #$00000200,a1       * Address for Data-Y
00:000034CC 7C07            	  5062:                 moveq  #$00000007,d6       * Loop counter
                            	  5063: 
00:000034CE B348            	  5064: CMPM_LOOP2:     cmpm.w (a0)+,(a1)+
00:000034D0 40C3            	  5065:                 move.w sr,d3
00:000034D2 02830000000F    	  5066:                 andi.l #$0F,d3            * Isolate flags
00:000034D8 D283            	  5067:                 add.l d3,d1               * Copy flag results into accumulator
00:000034DA 51CEFFF2        	  5068:                 dbf d6,CMPM_LOOP2
                            	  5069: 
                            	  5070: 
00:000034DE 307C0100        	  5071:                 move.l #$00000100,a0       * Address for Data-X
00:000034E2 327C0200        	  5072:                 move.l #$00000200,a1       * Address for Data-Y
00:000034E6 7C03            	  5073:                 moveq  #$00000003,d6       * Loop counter
                            	  5074: 
00:000034E8 B388            	  5075: CMPM_LOOP3:     cmpm.l (a0)+,(a1)+
00:000034EA 40C3            	  5076:                 move.w sr,d3
00:000034EC 02830000000F    	  5077:                 andi.l #$0F,d3            * Isolate flags
00:000034F2 D483            	  5078:                 add.l d3,d2               * Copy flag results into accumulator
00:000034F4 51CEFFF2        	  5079:                 dbf d6,CMPM_LOOP3
                            	  5080: 
                            	  5081: 
00:000034F8 0C800000004C    	  5082:                 cmpi.l #$0000004C,d0      * Check the data results
00:000034FE 66FE            	  5083:                 bne.s *
00:00003500 0C8100000024    	  5084:                 cmpi.l #$00000024,d1
00:00003506 66FE            	  5085:                 bne.s *
00:00003508 0C8200000012    	  5086:                 cmpi.l #$00000012,d2
00:0000350E 66FE            	  5087:                 bne.s *
                            	  5088: 
00:00003510 4E75            	  5089:                 rts
                            	  5090: 
                            	  5091: 
                            	  5092: *-----------------------------------------------------------
                            	  5093: *-----------------------------------------------------------
                            	  5094: * OPCODE : ADD
                            	  5095: *-----------------------------------------------------------
                            	  5096: *-----------------------------------------------------------
                            	  5097: 
                            	  5098: op_ADD:
                            	  5099: 
                            	  5100: 
                            	  5101: *  * <EA> to Register
00:00003512 203CA5A5A5A5    	  5102:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00003518 223C8167E123    	  5103:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:0000351E 243CA5A5A5A5    	  5104:                 move.l #$a5a5a5a5,d2
00:00003524 7600            	  5105:                 moveq  #$00000000,d3
00:00003526 7800            	  5106:                 moveq  #$00000000,d4       * Cumulative data results
00:00003528 7A00            	  5107:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000352A 7C1E            	  5108:                 move.l #$0000001E,d6       * Inner loop counter
00:0000352C 7E1E            	  5109:                 move.l #$0000001E,d7       * Outer loop counter
00:0000352E 307C0100        	  5110:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5111: 
                            	  5112: 
                            	  5113: ADD_OUTER1:
                            	  5114: 
                            	  5115: *     BYTE
00:00003532 2081            	  5116:                 move.l d1,(a0)
00:00003534 D010            	  5117:                 add.b (a0),d0
00:00003536 40C3            	  5118:                 move.w sr,d3
00:00003538 02830000001F    	  5119:                 andi.l #$1F,d3            * Isolate flags
00:0000353E DA83            	  5120:                 add.l d3,d5               * Copy flag results into accumulator
00:00003540 D880            	  5121:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5122: 
                            	  5123: *     WORD
00:00003542 2081            	  5124:                 move.l d1,(a0)
00:00003544 D050            	  5125:                 add.w (a0),d0
00:00003546 40C3            	  5126:                 move.w sr,d3
00:00003548 02830000000C    	  5127:                 andi.l #$0C,d3            * Isolate flags
00:0000354E DA83            	  5128:                 add.l d3,d5               * Copy flag results into accumulator
00:00003550 D880            	  5129:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5130: 
                            	  5131: *     LONG
00:00003552 2081            	  5132:                 move.l d1,(a0)
00:00003554 D090            	  5133:                 add.l (a0),d0
00:00003556 40C3            	  5134:                 move.w sr,d3
00:00003558 02830000000F    	  5135:                 andi.l #$0F,d3            * Isolate flags
00:0000355E DA83            	  5136:                 add.l d3,d5               * Copy flag results into accumulator
00:00003560 D880            	  5137:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5138: 
                            	  5139: 
00:00003562 E299            	  5140:                 ror.l #$1,d1
00:00003564 51CEFFCC        	  5141:                 dbf d6,ADD_OUTER1
00:00003568 E29A            	  5142:                 ror.l #$1,d2
00:0000356A 223C8167E123    	  5143:                 move.l #$8167E123,d1       * Initial Data-Y
00:00003570 7C1E            	  5144:                 move.l #$0000001E,d6       * Inner loop counter
00:00003572 51CFFFBE        	  5145:                 dbf d7,ADD_OUTER1
                            	  5146: 
00:00003576 0C8423ED428F    	  5147:                 cmpi.l #$23ED428F,d4      * Check the data results
00:0000357C 66FE            	  5148:                 bne.s *
00:0000357E 0C8500004C96    	  5149:                 cmpi.l #$00004C96,d5      * Check the Flag results
00:00003584 66FE            	  5150:                 bne.s *
                            	  5151: 
                            	  5152: 
                            	  5153: *  * Register to <EA>
00:00003586 203C86738374    	  5154:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:0000358C 223CFC55F2FE    	  5155:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:00003592 243C86738374    	  5156:                 move.l #$86738374,d2
00:00003598 7600            	  5157:                 moveq  #$00000000,d3
00:0000359A 7800            	  5158:                 moveq  #$00000000,d4       * Cumulative data results
00:0000359C 7A00            	  5159:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000359E 7C1E            	  5160:                 move.l #$0000001E,d6       * Inner loop counter
00:000035A0 7E1D            	  5161:                 move.l #$0000001D,d7       * Outer loop counter
00:000035A2 307C0100        	  5162:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5163: 
                            	  5164: 
                            	  5165: ADD_OUTER2:
                            	  5166: 
                            	  5167: *     BYTE
00:000035A6 2080            	  5168:                 move.l d0,(a0)
00:000035A8 D310            	  5169:                 add.b d1,(a0)
00:000035AA 40C3            	  5170:                 move.w sr,d3
00:000035AC 02830000000C    	  5171:                 andi.l #$0C,d3            * Isolate flags
00:000035B2 DA83            	  5172:                 add.l d3,d5               * Copy flag results into accumulator
00:000035B4 D890            	  5173:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5174: 
                            	  5175: *     WORD
00:000035B6 2080            	  5176:                 move.l d0,(a0)
00:000035B8 D350            	  5177:                 add.w d1,(a0)
00:000035BA 40C3            	  5178:                 move.w sr,d3
00:000035BC 02830000001F    	  5179:                 andi.l #$1F,d3            * Isolate flags
00:000035C2 DA83            	  5180:                 add.l d3,d5               * Copy flag results into accumulator
00:000035C4 D890            	  5181:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5182: 
                            	  5183: *     LONG
00:000035C6 2080            	  5184:                 move.l d0,(a0)
00:000035C8 D390            	  5185:                 add.l d1,(a0)
00:000035CA 40C3            	  5186:                 move.w sr,d3
00:000035CC 02830000000F    	  5187:                 andi.l #$0F,d3            * Isolate flags
00:000035D2 DA83            	  5188:                 add.l d3,d5               * Copy flag results into accumulator
00:000035D4 D890            	  5189:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5190: 
                            	  5191: 
00:000035D6 E299            	  5192:                 ror.l #$1,d1
00:000035D8 51CEFFCC        	  5193:                 dbf d6,ADD_OUTER2
00:000035DC E29A            	  5194:                 ror.l #$1,d2
00:000035DE 223C8167E123    	  5195:                 move.l #$8167E123,d1       * Initial Data-Y
00:000035E4 7C1E            	  5196:                 move.l #$0000001E,d6       * Inner loop counter
00:000035E6 51CFFFBE        	  5197:                 dbf d7,ADD_OUTER2
                            	  5198: 
00:000035EA 0C846701B884    	  5199:                 cmpi.l #$6701B884,d4      * Check the data results
00:000035F0 66FE            	  5200:                 bne.s *
00:000035F2 0C8500005467    	  5201:                 cmpi.l #$00005467,d5      * Check the Flag results
00:000035F8 66FE            	  5202:                 bne.s *
                            	  5203: 
00:000035FA 4E75            	  5204:                 rts
                            	  5205: 
                            	  5206: *-----------------------------------------------------------
                            	  5207: *-----------------------------------------------------------
                            	  5208: * OPCODE : SUB
                            	  5209: *-----------------------------------------------------------
                            	  5210: *-----------------------------------------------------------
                            	  5211: 
                            	  5212: op_SUB:
                            	  5213: 
                            	  5214: *  * <EA> to Register
00:000035FC 203CA5A5A5A5    	  5215:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00003602 223C8167E123    	  5216:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00003608 243CA5A5A5A5    	  5217:                 move.l #$a5a5a5a5,d2
00:0000360E 7600            	  5218:                 moveq  #$00000000,d3
00:00003610 7800            	  5219:                 moveq  #$00000000,d4       * Cumulative data results
00:00003612 7A00            	  5220:                 moveq  #$00000000,d5       * Cumulative flag results
00:00003614 7C1E            	  5221:                 move.l #$0000001E,d6       * Inner loop counter
00:00003616 7E1E            	  5222:                 move.l #$0000001E,d7       * Outer loop counter
00:00003618 307C0100        	  5223:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5224: 
                            	  5225: 
                            	  5226: SUB_OUTER1:
                            	  5227: 
                            	  5228: *     BYTE
00:0000361C 2081            	  5229:                 move.l d1,(a0)
00:0000361E 9010            	  5230:                 sub.b (a0),d0
00:00003620 40C3            	  5231:                 move.w sr,d3
00:00003622 02830000001F    	  5232:                 andi.l #$1F,d3            * Isolate flags
00:00003628 DA83            	  5233:                 add.l d3,d5               * Copy flag results into accumulator
00:0000362A D880            	  5234:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5235: 
                            	  5236: *     WORD
00:0000362C 2081            	  5237:                 move.l d1,(a0)
00:0000362E 9050            	  5238:                 sub.w (a0),d0
00:00003630 40C3            	  5239:                 move.w sr,d3
00:00003632 02830000000C    	  5240:                 andi.l #$0C,d3            * Isolate flags
00:00003638 DA83            	  5241:                 add.l d3,d5               * Copy flag results into accumulator
00:0000363A D880            	  5242:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5243: 
                            	  5244: *     LONG
00:0000363C 2081            	  5245:                 move.l d1,(a0)
00:0000363E 9090            	  5246:                 sub.l (a0),d0
00:00003640 40C3            	  5247:                 move.w sr,d3
00:00003642 02830000000F    	  5248:                 andi.l #$0F,d3            * Isolate flags
00:00003648 DA83            	  5249:                 add.l d3,d5               * Copy flag results into accumulator
00:0000364A D880            	  5250:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5251: 
                            	  5252: 
00:0000364C E299            	  5253:                 ror.l #$1,d1
00:0000364E 51CEFFCC        	  5254:                 dbf d6,SUB_OUTER1
00:00003652 E29A            	  5255:                 ror.l #$1,d2
00:00003654 223C8167E123    	  5256:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000365A 7C1E            	  5257:                 move.l #$0000001E,d6       * Inner loop counter
00:0000365C 51CFFFBE        	  5258:                 dbf d7,SUB_OUTER1
                            	  5259: 
00:00003660 0C841A8D14CF    	  5260:                 cmpi.l #$1A8D14CF,d4      * Check the data results
00:00003666 66FE            	  5261:                 bne.s *
00:00003668 0C8500004FC4    	  5262:                 cmpi.l #$00004FC4,d5      * Check the Flag results
00:0000366E 66FE            	  5263:                 bne.s *
                            	  5264: 
                            	  5265: 
                            	  5266: *  * Register to <EA>
00:00003670 203C86738374    	  5267:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:00003676 223CFC55F2FE    	  5268:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:0000367C 243C86738374    	  5269:                 move.l #$86738374,d2
00:00003682 7600            	  5270:                 moveq  #$00000000,d3
00:00003684 7800            	  5271:                 moveq  #$00000000,d4       * Cumulative data results
00:00003686 7A00            	  5272:                 moveq  #$00000000,d5       * Cumulative flag results
00:00003688 7C1E            	  5273:                 move.l #$0000001E,d6       * Inner loop counter
00:0000368A 7E1D            	  5274:                 move.l #$0000001D,d7       * Outer loop counter
00:0000368C 307C0100        	  5275:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5276: 
                            	  5277: 
                            	  5278: SUB_OUTER2:
                            	  5279: 
                            	  5280: *     BYTE
00:00003690 2080            	  5281:                 move.l d0,(a0)
00:00003692 9310            	  5282:                 sub.b d1,(a0)
00:00003694 40C3            	  5283:                 move.w sr,d3
00:00003696 02830000000C    	  5284:                 andi.l #$0C,d3            * Isolate flags
00:0000369C DA83            	  5285:                 add.l d3,d5               * Copy flag results into accumulator
00:0000369E D890            	  5286:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5287: 
                            	  5288: *     WORD
00:000036A0 2080            	  5289:                 move.l d0,(a0)
00:000036A2 9350            	  5290:                 sub.w d1,(a0)
00:000036A4 40C3            	  5291:                 move.w sr,d3
00:000036A6 02830000001F    	  5292:                 andi.l #$1F,d3            * Isolate flags
00:000036AC DA83            	  5293:                 add.l d3,d5               * Copy flag results into accumulator
00:000036AE D890            	  5294:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5295: 
                            	  5296: *     LONG
00:000036B0 2080            	  5297:                 move.l d0,(a0)
00:000036B2 9390            	  5298:                 sub.l d1,(a0)
00:000036B4 40C3            	  5299:                 move.w sr,d3
00:000036B6 02830000000F    	  5300:                 andi.l #$0F,d3            * Isolate flags
00:000036BC DA83            	  5301:                 add.l d3,d5               * Copy flag results into accumulator
00:000036BE D890            	  5302:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5303: 
                            	  5304: 
00:000036C0 E299            	  5305:                 ror.l #$1,d1
00:000036C2 51CEFFCC        	  5306:                 dbf d6,SUB_OUTER2
00:000036C6 E29A            	  5307:                 ror.l #$1,d2
00:000036C8 223C8167E123    	  5308:                 move.l #$8167E123,d1       * Initial Data-Y
00:000036CE 7C1E            	  5309:                 move.l #$0000001E,d6       * Inner loop counter
00:000036D0 51CFFFBE        	  5310:                 dbf d7,SUB_OUTER2
                            	  5311: 
00:000036D4 0C8436D38BEC    	  5312:                 cmpi.l #$36D38BEC,d4      * Check the data results
00:000036DA 66FE            	  5313:                 bne.s *
00:000036DC 0C85000045A5    	  5314:                 cmpi.l #$000045A5,d5      * Check the Flag results
00:000036E2 66FE            	  5315:                 bne.s *
                            	  5316: 
                            	  5317: 
                            	  5318: 
                            	  5319: 
00:000036E4 4E75            	  5320:                 rts
                            	  5321: 
                            	  5322: 
                            	  5323: 
                            	  5324: *-----------------------------------------------------------
                            	  5325: *-----------------------------------------------------------
                            	  5326: * OPCODE : ADDA
                            	  5327: *-----------------------------------------------------------
                            	  5328: *-----------------------------------------------------------
                            	  5329: 
                            	  5330: op_ADDA:
                            	  5331: 
                            	  5332: *  * <EA> to Register
00:000036E6 203CA5A5A5A5    	  5333:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000036EC 223C8167E123    	  5334:                 move.l #$8167E123,d1
00:000036F2 243CA5A5A5A5    	  5335:                 move.l #$a5a5a5a5,d2
00:000036F8 7600            	  5336:                 moveq  #$00000000,d3
00:000036FA 7800            	  5337:                 moveq  #$00000000,d4       * Cumulative data results
00:000036FC 7A00            	  5338:                 moveq  #$00000000,d5       * Cumulative flag results
00:000036FE 7C1E            	  5339:                 move.l #$0000001E,d6       * Inner loop counter
00:00003700 7E1E            	  5340:                 move.l #$0000001E,d7       * Outer loop counter
00:00003702 307C0100        	  5341:                 move.l #$00000100,a0       * Address for memory EA operations
00:00003706 227C8167E123    	  5342:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5343: 
                            	  5344: ADDA_OUTER1:
                            	  5345: 
                            	  5346: *     WORD
                            	  5347: *                move.l d1,(a0)       * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5348: *                adda.w (a0),a1
                            	  5349: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5350: 
                            	  5351: *     LONG
00:0000370C 2081            	  5352:                 move.l d1,(a0)
00:0000370E D3D0            	  5353:                 adda.l (a0),a1
00:00003710 D889            	  5354:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5355: 
00:00003712 E299            	  5356:                 ror.l #$1,d1
00:00003714 51CEFFF6        	  5357:                 dbf d6,ADDA_OUTER1
00:00003718 E299            	  5358:                 ror.l #$1,d1
00:0000371A 2241            	  5359:                 move.l d1,a1
00:0000371C 223C8167E123    	  5360:                 move.l #$8167E123,d1       * Initial Data-Y
00:00003722 7C1E            	  5361:                 move.l #$0000001E,d6       * Inner loop counter
00:00003724 51CFFFE6        	  5362:                 dbf d7,ADDA_OUTER1
                            	  5363: 
00:00003728 0C84AC04DB4C    	  5364:                 cmpi.l #$AC04DB4C,d4      * Check the data results
00:0000372E 66FE            	  5365:                 bne.s *
                            	  5366: 
                            	  5367: 
00:00003730 4E75            	  5368:                 rts
                            	  5369: 
                            	  5370: 
                            	  5371: *-----------------------------------------------------------
                            	  5372: *-----------------------------------------------------------
                            	  5373: * OPCODE : SUBA
                            	  5374: *-----------------------------------------------------------
                            	  5375: *-----------------------------------------------------------
                            	  5376: 
                            	  5377: op_SUBA:
                            	  5378: 
                            	  5379: *  * <EA> to Register
00:00003732 203CA5A5A5A5    	  5380:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00003738 223C8167E123    	  5381:                 move.l #$8167E123,d1
00:0000373E 243CA5A5A5A5    	  5382:                 move.l #$a5a5a5a5,d2
00:00003744 7600            	  5383:                 moveq  #$00000000,d3
00:00003746 7800            	  5384:                 moveq  #$00000000,d4       * Cumulative data results
00:00003748 7A00            	  5385:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000374A 7C1E            	  5386:                 move.l #$0000001E,d6       * Inner loop counter
00:0000374C 7E1E            	  5387:                 move.l #$0000001E,d7       * Outer loop counter
00:0000374E 307C0100        	  5388:                 move.l #$00000100,a0       * Address for memory EA operations
00:00003752 227C8167E123    	  5389:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5390: 
                            	  5391: SUBA_OUTER1:
                            	  5392: 
                            	  5393: *     WORD
                            	  5394: *                move.l d1,(a0) * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5395: *                suba.w (a0),a1
                            	  5396: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5397: 
                            	  5398: *     LONG
00:00003758 2081            	  5399:                 move.l d1,(a0)
00:0000375A 93D0            	  5400:                 suba.l (a0),a1
00:0000375C D889            	  5401:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5402: 
00:0000375E E299            	  5403:                 ror.l #$1,d1
00:00003760 51CEFFF6        	  5404:                 dbf d6,SUBA_OUTER1
00:00003764 E299            	  5405:                 ror.l #$1,d1
00:00003766 2241            	  5406:                 move.l d1,a1
00:00003768 223C8167E123    	  5407:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000376E 7C1E            	  5408:                 move.l #$0000001E,d6       * Inner loop counter
00:00003770 51CFFFE6        	  5409:                 dbf d7,SUBA_OUTER1
                            	  5410: 
00:00003774 0C84E1E36D7A    	  5411:                 cmpi.l #$E1E36D7A,d4      * Check the data results
00:0000377A 66FE            	  5412:                 bne.s *
                            	  5413: 
                            	  5414: 
00:0000377C 4E75            	  5415:                 rts
                            	  5416: 
                            	  5417: 
                            	  5418: 
                            	  5419: *-----------------------------------------------------------
                            	  5420: *-----------------------------------------------------------
                            	  5421: * OPCODE : ADDX
                            	  5422: *-----------------------------------------------------------
                            	  5423: *-----------------------------------------------------------
                            	  5424: 
                            	  5425: op_ADDX:
                            	  5426: 
                            	  5427: 
                            	  5428: *  * Register to Register
00:0000377E 203CA5A5A5A5    	  5429:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00003784 223C8167E123    	  5430:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:0000378A 243CA5A5A5A5    	  5431:                 move.l #$a5a5a5a5,d2
00:00003790 7600            	  5432:                 moveq  #$00000000,d3
00:00003792 7800            	  5433:                 moveq  #$00000000,d4       * Cumulative data results
00:00003794 7A00            	  5434:                 moveq  #$00000000,d5       * Cumulative flag results
00:00003796 7C1E            	  5435:                 move.l #$0000001E,d6       * Inner loop counter
00:00003798 7E1E            	  5436:                 move.l #$0000001E,d7       * Outer loop counter
00:0000379A 307C0100        	  5437:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5438: 
                            	  5439: 
                            	  5440: ADDX_OUTER1:
                            	  5441: 
                            	  5442: *     BYTE
00:0000379E 2002            	  5443:                 move.l d2,d0
00:000037A0 D101            	  5444:                 addx.b d1,d0
00:000037A2 40C3            	  5445:                 move.w sr,d3
00:000037A4 02830000001F    	  5446:                 andi.l #$1F,d3            * Isolate flags
00:000037AA DA83            	  5447:                 add.l d3,d5               * Copy flag results into accumulator
00:000037AC D880            	  5448:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5449: 
                            	  5450: *     WORD
00:000037AE 2002            	  5451:                 move.l d2,d0
00:000037B0 D141            	  5452:                 addx.w d1,d0
00:000037B2 40C3            	  5453:                 move.w sr,d3
00:000037B4 02830000001F    	  5454:                 andi.l #$1F,d3            * Isolate flags
00:000037BA DA83            	  5455:                 add.l d3,d5               * Copy flag results into accumulator
00:000037BC D880            	  5456:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5457: 
                            	  5458: *     LONG
00:000037BE 2002            	  5459:                 move.l d2,d0
00:000037C0 D181            	  5460:                 addx.l d1,d0
00:000037C2 40C3            	  5461:                 move.w sr,d3
00:000037C4 02830000001F    	  5462:                 andi.l #$1F,d3            * Isolate flags
00:000037CA DA83            	  5463:                 add.l d3,d5               * Copy flag results into accumulator
00:000037CC D880            	  5464:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5465: 
00:000037CE E299            	  5466:                 ror.l #$1,d1
00:000037D0 51CEFFCC        	  5467:                 dbf d6,ADDX_OUTER1
00:000037D4 E29A            	  5468:                 ror.l #$1,d2
00:000037D6 223C8167E123    	  5469:                 move.l #$8167E123,d1       * Initial Data-Y
00:000037DC 7C1E            	  5470:                 move.l #$0000001E,d6       * Inner loop counter
00:000037DE 51CFFFBE        	  5471:                 dbf d7,ADDX_OUTER1
                            	  5472: 
00:000037E2 0C844E96A4D9    	  5473:                 cmpi.l #$4E96A4D9,d4      * Check the data results
00:000037E8 66FE            	  5474:                 bne.s *
00:000037EA 0C85000085CD    	  5475:                 cmpi.l #$000085CD,d5      * Check the Flag results
00:000037F0 66FE            	  5476:                 bne.s *
                            	  5477: 
                            	  5478: 
                            	  5479: 
                            	  5480: *     -(An),-(An)
                            	  5481: 
00:000037F2 7000            	  5482:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
00:000037F4 7200            	  5483:                 moveq  #$00000000,d1
00:000037F6 7400            	  5484:                 moveq  #$00000000,d2
00:000037F8 307C0100        	  5485:                 move.l #$00000100,a0       * Address for Data-X
00:000037FC 327C0200        	  5486:                 move.l #$00000200,a1       * Address for Data-Y
00:00003800 20FC11FF5580    	  5487:                 move.l #$11FF5580,(a0)+   * Populate test data
00:00003806 20FC1111FFFF    	  5488:                 move.l #$1111FFFF,(a0)+   * Populate test data
00:0000380C 20FC33333333    	  5489:                 move.l #$33333333,(a0)+   * Populate test data
00:00003812 20FC44444444    	  5490:                 move.l #$44444444,(a0)+   * Populate test data
00:00003818 22FC80FF337F    	  5491:                 move.l #$80FF337F,(a1)+   * Populate test data
00:0000381E 22FCFFFF1111    	  5492:                 move.l #$FFFF1111,(a1)+   * Populate test data
00:00003824 22FC33333333    	  5493:                 move.l #$33333333,(a1)+   * Populate test data
00:0000382A 22FC44444444    	  5494:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5495: 
                            	  5496: 
00:00003830 7C0F            	  5497:                 move.l #$0000000F,d6       * Loop counter
                            	  5498: 
00:00003832 D308            	  5499: ADDX_LOOP3:     addx.b -(a0),-(a1)
00:00003834 40C3            	  5500:                 move.w sr,d3
00:00003836 02830000000F    	  5501:                 andi.l #$0F,d3            * Isolate flags
00:0000383C D083            	  5502:                 add.l d3,d0               * Copy flag results into accumulator
00:0000383E D211            	  5503:                 add.b (a1),d1
00:00003840 51CEFFF0        	  5504:                 dbf d6,ADDX_LOOP3
                            	  5505: 
                            	  5506: 
00:00003844 307C0110        	  5507:                 move.l #$00000110,a0       * Address for Data-X
00:00003848 327C0210        	  5508:                 move.l #$00000210,a1       * Address for Data-Y
00:0000384C 7C07            	  5509:                 moveq  #$00000007,d6       * Loop counter
                            	  5510: 
00:0000384E D348            	  5511: ADDX_LOOP4:     addx.w -(a0),-(a1)
00:00003850 40C3            	  5512:                 move.w sr,d3
00:00003852 02830000000F    	  5513:                 andi.l #$0F,d3            * Isolate flags
00:00003858 D083            	  5514:                 add.l d3,d0               * Copy flag results into accumulator
00:0000385A D251            	  5515:                 add.w (a1),d1
00:0000385C 51CEFFF0        	  5516:                 dbf d6,ADDX_LOOP4
                            	  5517: 
                            	  5518: 
00:00003860 307C0110        	  5519:                 move.l #$00000110,a0       * Address for Data-X
00:00003864 327C0210        	  5520:                 move.l #$00000210,a1       * Address for Data-Y
00:00003868 7C03            	  5521:                 moveq  #$00000003,d6       * Loop counter
                            	  5522: 
00:0000386A D388            	  5523: ADDX_LOOP5:     addx.l -(a0),-(a1)
00:0000386C 40C3            	  5524:                 move.w sr,d3
00:0000386E 02830000000F    	  5525:                 andi.l #$0F,d3            * Isolate flags
00:00003874 D083            	  5526:                 add.l d3,d0               * Copy flag results into accumulator
00:00003876 D291            	  5527:                 add.l (a1),d1
00:00003878 51CEFFF0        	  5528:                 dbf d6,ADDX_LOOP5
                            	  5529: 
                            	  5530: 
00:0000387C 0C8000000095    	  5531:                 cmpi.l #$00000095,d0      * Check the flag results
00:00003882 66FE            	  5532:                 bne.s *
00:00003884 0C81C812A682    	  5533:                 cmpi.l #$C812A682,d1      * Check the data results
00:0000388A 66FE            	  5534:                 bne.s *
                            	  5535: 
00:0000388C 4E75            	  5536:                 rts
                            	  5537: 
                            	  5538: 
                            	  5539: 
                            	  5540: 
                            	  5541: *-----------------------------------------------------------
                            	  5542: *-----------------------------------------------------------
                            	  5543: * OPCODE : SUBX
                            	  5544: *-----------------------------------------------------------
                            	  5545: *-----------------------------------------------------------
                            	  5546: 
                            	  5547: op_SUBX:
                            	  5548: 
                            	  5549: 
                            	  5550: *  * Register to Register
00:0000388E 203CA5A5A5A5    	  5551:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00003894 223C8167E123    	  5552:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:0000389A 243CA5A5A5A5    	  5553:                 move.l #$a5a5a5a5,d2
00:000038A0 7600            	  5554:                 moveq  #$00000000,d3
00:000038A2 7800            	  5555:                 moveq  #$00000000,d4       * Cumulative data results
00:000038A4 7A00            	  5556:                 moveq  #$00000000,d5       * Cumulative flag results
00:000038A6 7C1E            	  5557:                 move.l #$0000001E,d6       * Inner loop counter
00:000038A8 7E1E            	  5558:                 move.l #$0000001E,d7       * Outer loop counter
00:000038AA 307C0100        	  5559:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5560: 
                            	  5561: 
                            	  5562: SUBX_OUTER1:
                            	  5563: 
                            	  5564: *     BYTE
00:000038AE 2002            	  5565:                 move.l d2,d0
00:000038B0 9101            	  5566:                 subx.b d1,d0
00:000038B2 40C3            	  5567:                 move.w sr,d3
00:000038B4 02830000001F    	  5568:                 andi.l #$1F,d3            * Isolate flags
00:000038BA DA83            	  5569:                 add.l d3,d5               * Copy flag results into accumulator
00:000038BC D880            	  5570:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5571: 
                            	  5572: *     WORD
00:000038BE 2002            	  5573:                 move.l d2,d0
00:000038C0 9141            	  5574:                 subx.w d1,d0
00:000038C2 40C3            	  5575:                 move.w sr,d3
00:000038C4 02830000001F    	  5576:                 andi.l #$1F,d3            * Isolate flags
00:000038CA DA83            	  5577:                 add.l d3,d5               * Copy flag results into accumulator
00:000038CC D880            	  5578:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5579: 
                            	  5580: *     LONG
00:000038CE 2002            	  5581:                 move.l d2,d0
00:000038D0 9181            	  5582:                 subx.l d1,d0
00:000038D2 40C3            	  5583:                 move.w sr,d3
00:000038D4 02830000001F    	  5584:                 andi.l #$1F,d3            * Isolate flags
00:000038DA DA83            	  5585:                 add.l d3,d5               * Copy flag results into accumulator
00:000038DC D880            	  5586:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5587: 
00:000038DE E299            	  5588:                 ror.l #$1,d1
00:000038E0 51CEFFCC        	  5589:                 dbf d6,SUBX_OUTER1
00:000038E4 E29A            	  5590:                 ror.l #$1,d2
00:000038E6 223C8167E123    	  5591:                 move.l #$8167E123,d1       * Initial Data-Y
00:000038EC 7C1E            	  5592:                 move.l #$0000001E,d6       * Inner loop counter
00:000038EE 51CFFFBE        	  5593:                 dbf d7,SUBX_OUTER1
                            	  5594: 
00:000038F2 0C84FCAA913E    	  5595:                 cmpi.l #$FCAA913E,d4      * Check the data results
00:000038F8 66FE            	  5596:                 bne.s *
00:000038FA 0C8500007E89    	  5597:                 cmpi.l #$00007E89,d5      * Check the Flag results
00:00003900 66FE            	  5598:                 bne.s *
                            	  5599: 
                            	  5600: 
                            	  5601: 
                            	  5602: *     -(An),-(An)
                            	  5603: 
00:00003902 7000            	  5604:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
00:00003904 7200            	  5605:                 moveq  #$00000000,d1
00:00003906 7400            	  5606:                 moveq  #$00000000,d2
00:00003908 307C0100        	  5607:                 move.l #$00000100,a0       * Address for Data-X
00:0000390C 327C0200        	  5608:                 move.l #$00000200,a1       * Address for Data-Y
00:00003910 20FC11FF5580    	  5609:                 move.l #$11FF5580,(a0)+   * Populate test data
00:00003916 20FC1111FFFF    	  5610:                 move.l #$1111FFFF,(a0)+   * Populate test data
00:0000391C 20FC80FF337F    	  5611:                 move.l #$80FF337F,(a0)+   * Populate test data
00:00003922 20FC44444444    	  5612:                 move.l #$44444444,(a0)+   * Populate test data
00:00003928 22FC80FF337F    	  5613:                 move.l #$80FF337F,(a1)+   * Populate test data
00:0000392E 22FC1111FFFF    	  5614:                 move.l #$1111FFFF,(a1)+   * Populate test data
00:00003934 22FC33333333    	  5615:                 move.l #$33333333,(a1)+   * Populate test data
00:0000393A 22FC5580EECC    	  5616:                 move.l #$5580EECC,(a1)+   * Populate test data
                            	  5617: 
                            	  5618: 
00:00003940 7C0F            	  5619:                 move.l #$0000000F,d6       * Loop counter
                            	  5620: 
00:00003942 9308            	  5621: SUBX_LOOP3:     subx.b -(a0),-(a1)
00:00003944 40C3            	  5622:                 move.w sr,d3
00:00003946 02830000000F    	  5623:                 andi.l #$0F,d3            * Isolate flags
00:0000394C D083            	  5624:                 add.l d3,d0               * Copy flag results into accumulator
00:0000394E D211            	  5625:                 add.b (a1),d1
00:00003950 51CEFFF0        	  5626:                 dbf d6,SUBX_LOOP3
                            	  5627: 
                            	  5628: 
00:00003954 307C0110        	  5629:                 move.l #$00000110,a0       * Address for Data-X
00:00003958 327C0210        	  5630:                 move.l #$00000210,a1       * Address for Data-Y
00:0000395C 7C07            	  5631:                 moveq  #$00000007,d6       * Loop counter
                            	  5632: 
00:0000395E 9348            	  5633: SUBX_LOOP4:     subx.w -(a0),-(a1)
00:00003960 40C3            	  5634:                 move.w sr,d3
00:00003962 02830000000F    	  5635:                 andi.l #$0F,d3            * Isolate flags
00:00003968 D083            	  5636:                 add.l d3,d0               * Copy flag results into accumulator
00:0000396A D251            	  5637:                 add.w (a1),d1
00:0000396C 51CEFFF0        	  5638:                 dbf d6,SUBX_LOOP4
                            	  5639: 
                            	  5640: 
00:00003970 307C0110        	  5641:                 move.l #$00000110,a0       * Address for Data-X
00:00003974 327C0210        	  5642:                 move.l #$00000210,a1       * Address for Data-Y
00:00003978 7C03            	  5643:                 moveq  #$00000003,d6       * Loop counter
                            	  5644: 
00:0000397A 9388            	  5645: SUBX_LOOP5:     subx.l -(a0),-(a1)
00:0000397C 40C3            	  5646:                 move.w sr,d3
00:0000397E 02830000000F    	  5647:                 andi.l #$0F,d3            * Isolate flags
00:00003984 D083            	  5648:                 add.l d3,d0               * Copy flag results into accumulator
00:00003986 D291            	  5649:                 add.l (a1),d1
00:00003988 51CEFFF0        	  5650:                 dbf d6,SUBX_LOOP5
                            	  5651: 
                            	  5652: 
00:0000398C 0C80000000B1    	  5653:                 cmpi.l #$000000B1,d0      * Check the flag results
00:00003992 66FE            	  5654:                 bne.s *
00:00003994 0C8162C6F417    	  5655:                 cmpi.l #$62C6F417,d1      * Check the data results
00:0000399A 66FE            	  5656:                 bne.s *
                            	  5657: 
00:0000399C 4E75            	  5658:                 rts
                            	  5659: 
                            	  5660: 
                            	  5661: *-----------------------------------------------------------
                            	  5662: *-----------------------------------------------------------
                            	  5663: * OPCODE : MULU
                            	  5664: *-----------------------------------------------------------
                            	  5665: *-----------------------------------------------------------
                            	  5666: 
                            	  5667: op_MULU:
                            	  5668: 
00:0000399E 203CFE805501    	  5669:                 move.l #$FE805501,d0        * Initial
00:000039A4 223C5697EDB6    	  5670:                 move.l #$5697EDB6,d1        * Initial Y
00:000039AA 243CFE805501    	  5671:                 move.l #$FE805501,d2
00:000039B0 7600            	  5672:                 moveq  #$00000000,d3
00:000039B2 7800            	  5673:                 moveq  #$00000000,d4        * Cumulative data results
00:000039B4 7A00            	  5674:                 moveq  #$00000000,d5       * Cumulative flag results
00:000039B6 7C0E            	  5675:                 move.l #$0000000E,d6       * Inner loop counter
00:000039B8 7E0E            	  5676:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5677: 
                            	  5678: 
00:000039BA C0C1            	  5679: MULU_OUTER1:    mulu d1,d0
00:000039BC 40C3            	  5680:                 move.w sr,d3
00:000039BE 02830000000C    	  5681:                 andi.l #$0C,d3            * Isolate flags
00:000039C4 DA83            	  5682:                 add.l d3,d5               * Copy flag results into accumulator
00:000039C6 D880            	  5683:                 add.l d0,d4               * Copy data results into data accumulator
00:000039C8 E299            	  5684:                 ror.l #$1,d1
                            	  5685: 
00:000039CA 51CEFFEE        	  5686:                 dbf d6,MULU_OUTER1
00:000039CE E29A            	  5687:                 ror.l #$1,d2
00:000039D0 2002            	  5688:                 move.l d2,d0
00:000039D2 7C0E            	  5689:                 move.l #$0000000E,d6       * Inner loop counter
00:000039D4 51CFFFE4        	  5690:                 dbf d7,MULU_OUTER1
                            	  5691: 
00:000039D8 0C8476FB988C    	  5692:                 cmpi.l #$76FB988C,d4      * Check the data results
00:000039DE 66FE            	  5693:                 bne.s *
                            	  5694: 
00:000039E0 0C8500000170    	  5695:                 cmpi.l #$00000170,d5      * Check the Flag results
00:000039E6 66FE            	  5696:                 bne.s *
                            	  5697: 
                            	  5698: 
00:000039E8 4E75            	  5699:                 rts
                            	  5700: 
                            	  5701: 
                            	  5702: *-----------------------------------------------------------
                            	  5703: *-----------------------------------------------------------
                            	  5704: * OPCODE : MULS
                            	  5705: *-----------------------------------------------------------
                            	  5706: *-----------------------------------------------------------
                            	  5707: 
                            	  5708: op_MULS:
                            	  5709: 
00:000039EA 203CFE805501    	  5710:                 move.l #$FE805501,d0        * Initial
00:000039F0 223C5697EDB6    	  5711:                 move.l #$5697EDB6,d1        * Initial Y
00:000039F6 243CFE805501    	  5712:                 move.l #$FE805501,d2
00:000039FC 7600            	  5713:                 moveq  #$00000000,d3
00:000039FE 7800            	  5714:                 moveq  #$00000000,d4        * Cumulative data results
00:00003A00 7A00            	  5715:                 moveq  #$00000000,d5       * Cumulative flag results
00:00003A02 7C0E            	  5716:                 move.l #$0000000E,d6       * Inner loop counter
00:00003A04 7E0E            	  5717:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5718: 
                            	  5719: 
00:00003A06 C1C1            	  5720: MULS_OUTER1:    muls d1,d0
00:00003A08 40C3            	  5721:                 move.w sr,d3
00:00003A0A 02830000000C    	  5722:                 andi.l #$0C,d3            * Isolate flags
00:00003A10 DA83            	  5723:                 add.l d3,d5               * Copy flag results into accumulator
00:00003A12 D880            	  5724:                 add.l d0,d4               * Copy data results into data accumulator
00:00003A14 E299            	  5725:                 ror.l #$1,d1
                            	  5726: 
00:00003A16 51CEFFEE        	  5727:                 dbf d6,MULS_OUTER1
00:00003A1A E29A            	  5728:                 ror.l #$1,d2
00:00003A1C 2002            	  5729:                 move.l d2,d0
00:00003A1E 7C0E            	  5730:                 move.l #$0000000E,d6       * Inner loop counter
00:00003A20 51CFFFE4        	  5731:                 dbf d7,MULS_OUTER1
                            	  5732: 
00:00003A24 0C84D4E2988C    	  5733:                 cmpi.l #$D4E2988C,d4      * Check the data results
00:00003A2A 66FE            	  5734:                 bne.s *
                            	  5735: 
00:00003A2C 0C85000003E0    	  5736:                 cmpi.l #$000003E0,d5      * Check the Flag results
00:00003A32 66FE            	  5737:                 bne.s *
                            	  5738: 
                            	  5739: 
00:00003A34 4E75            	  5740:                 rts
                            	  5741: 
                            	  5742: 
                            	  5743: 
                            	  5744: *-----------------------------------------------------------
                            	  5745: *-----------------------------------------------------------
                            	  5746: * OPCODE : EXG
                            	  5747: *-----------------------------------------------------------
                            	  5748: *-----------------------------------------------------------
                            	  5749: 
                            	  5750: op_EXG:
00:00003A36 223CD1D1D1D1    	  5751:                 move.l #$d1d1d1d1,d1
00:00003A3C 243CD2D2D2D2    	  5752:                 move.l #$d2d2d2d2,d2
00:00003A42 263CD3D3D3D3    	  5753:                 move.l #$d3d3d3d3,d3
00:00003A48 227CA1A1A1A1    	  5754:                 move.l #$a1a1a1a1,a1
00:00003A4E 247CA2A2A2A2    	  5755:                 move.l #$a2a2a2a2,a2
00:00003A54 267CA3A3A3A3    	  5756:                 move.l #$a3a3a3a3,a3
                            	  5757: 
00:00003A5A C342            	  5758:                 exg d1,d2
00:00003A5C C34A            	  5759:                 exg a1,a2
00:00003A5E C78B            	  5760:                 exg d3,a3
                            	  5761: 
00:00003A60 0C81D2D2D2D2    	  5762:                 cmpi.l #$d2d2d2d2,d1      * Check the results
00:00003A66 66FE            	  5763:                 bne.s *
00:00003A68 0C82D1D1D1D1    	  5764:                 cmpi.l #$d1d1d1d1,d2
00:00003A6E 66FE            	  5765:                 bne.s *
00:00003A70 0C83A3A3A3A3    	  5766:                 cmpi.l #$a3a3a3a3,d3
00:00003A76 66FE            	  5767:                 bne.s *
                            	  5768: 
00:00003A78 2209            	  5769:                 move.l a1,d1
00:00003A7A 240A            	  5770:                 move.l a2,d2
00:00003A7C 260B            	  5771:                 move.l a3,d3
                            	  5772: 
00:00003A7E 0C81A2A2A2A2    	  5773:                 cmpi.l #$a2a2a2a2,d1
00:00003A84 66FE            	  5774:                 bne.s *
00:00003A86 0C82A1A1A1A1    	  5775:                 cmpi.l #$a1a1a1a1,d2
00:00003A8C 66FE            	  5776:                 bne.s *
00:00003A8E 0C83D3D3D3D3    	  5777:                 cmpi.l #$d3d3d3d3,d3
00:00003A94 66FE            	  5778:                 bne.s *
                            	  5779: 
00:00003A96 4E75            	  5780:                 rts
                            	  5781: 
                            	  5782: 
                            	  5783: *-----------------------------------------------------------
                            	  5784: *-----------------------------------------------------------
                            	  5785: * OPCODE : ROx
                            	  5786: *-----------------------------------------------------------
                            	  5787: *-----------------------------------------------------------
                            	  5788: 
                            	  5789: *     Subroutine to check and accumulate the flags
00:00003A98 40C3            	  5790: ROx_FLAGS:      move.w sr,d3
00:00003A9A 02830000000F    	  5791:                 andi.l #$0F,d3            * Isolate flags
00:00003AA0 DA83            	  5792:                 add.l d3,d5               * Copy flag results into accumulator
00:00003AA2 4E75            	  5793:                 rts
                            	  5794: 
                            	  5795: op_ROx:
                            	  5796: 
                            	  5797: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  5798: 
                            	  5799: *        BYTE LEFT
00:00003AA4 203C80018FF1    	  5800:                 move.l #$80018FF1,d0
00:00003AAA 7A00            	  5801:                 moveq  #$00000000,d5
00:00003AAC 7C11            	  5802:                 moveq  #$00000011,d6
                            	  5803: ROx_LOOP1:
00:00003AAE ED38            	  5804:                 rol.b d6,d0
00:00003AB0 61E6            	  5805:                 bsr ROx_FLAGS
00:00003AB2 51CEFFFA        	  5806:                 dbf d6,ROx_LOOP1
00:00003AB6 0C8080018FE3    	  5807:                 cmpi.l #$80018FE3,d0
00:00003ABC 66FE            	  5808:                 bne.s *
00:00003ABE 0C850000006B    	  5809:                 cmpi.l #$0000006B,d5
00:00003AC4 66FE            	  5810:                 bne.s *
                            	  5811: 
                            	  5812: *        BYTE RIGHT
00:00003AC6 203C80018FF1    	  5813:                 move.l #$80018FF1,d0
00:00003ACC 7C12            	  5814:                 moveq  #$00000012,d6
                            	  5815: ROx_LOOP2:
00:00003ACE EC38            	  5816:                 ror.b d6,d0
00:00003AD0 61C6            	  5817:                 bsr ROx_FLAGS
00:00003AD2 51CEFFFA        	  5818:                 dbf d6,ROx_LOOP2
00:00003AD6 0C8080018F3E    	  5819:                 cmpi.l #$80018F3E,d0
00:00003ADC 66FE            	  5820:                 bne.s *
00:00003ADE 0C85000000C5    	  5821:                 cmpi.l #$000000C5,d5
00:00003AE4 66FE            	  5822:                 bne.s *
                            	  5823: 
                            	  5824: 
                            	  5825: *        WORD LEFT
00:00003AE6 203C80018FF1    	  5826:                 move.l #$80018FF1,d0
00:00003AEC 7C13            	  5827:                 moveq  #$00000013,d6
                            	  5828: ROx_LOOP3:
00:00003AEE ED78            	  5829:                 rol.w d6,d0
00:00003AF0 61A6            	  5830:                 bsr ROx_FLAGS
00:00003AF2 51CEFFFA        	  5831:                 dbf d6,ROx_LOOP3
00:00003AF6 0C80800163FC    	  5832:                 cmpi.l #$800163FC,d0
00:00003AFC 66FE            	  5833:                 bne.s *
00:00003AFE 0C8500000131    	  5834:                 cmpi.l #$00000131,d5
00:00003B04 66FE            	  5835:                 bne.s *
                            	  5836: 
                            	  5837: *        WORD RIGHT
00:00003B06 203C80018FF1    	  5838:                 move.l #$80018FF1,d0
00:00003B0C 7C1E            	  5839:                 move.l #$0000001E,d6
                            	  5840: ROx_LOOP4:
00:00003B0E EC78            	  5841:                 ror.w d6,d0
00:00003B10 6186            	  5842:                 bsr ROx_FLAGS
00:00003B12 51CEFFFA        	  5843:                 dbf d6,ROx_LOOP4
00:00003B16 0C808001C7F8    	  5844:                 cmpi.l #$8001C7F8,d0
00:00003B1C 66FE            	  5845:                 bne.s *
00:00003B1E 0C85000001DB    	  5846:                 cmpi.l #$000001DB,d5
00:00003B24 66FE            	  5847:                 bne.s *
                            	  5848: 
                            	  5849: 
                            	  5850: *        LONG LEFT
00:00003B26 203C80018FF1    	  5851:                 move.l #$80018FF1,d0
00:00003B2C 7C15            	  5852:                 moveq  #$00000015,d6
                            	  5853: ROx_LOOP5:
00:00003B2E EDB8            	  5854:                 rol.l d6,d0
00:00003B30 6100FF66        	  5855:                 bsr ROx_FLAGS
00:00003B34 51CEFFF8        	  5856:                 dbf d6,ROx_LOOP5
00:00003B38 0C8000C7F8C0    	  5857:                 cmpi.l #$00C7F8C0,d0
00:00003B3E 66FE            	  5858:                 bne.s *
00:00003B40 0C850000021A    	  5859:                 cmpi.l #$0000021A,d5
00:00003B46 66FE            	  5860:                 bne.s *
                            	  5861: 
                            	  5862: *        LONG RIGHT
00:00003B48 203C80018FF1    	  5863:                 move.l #$80018FF1,d0
00:00003B4E 7C16            	  5864:                 moveq  #$00000016,d6
                            	  5865: ROx_LOOP6:
00:00003B50 ECB8            	  5866:                 ror.l d6,d0
00:00003B52 6100FF44        	  5867:                 bsr ROx_FLAGS
00:00003B56 51CEFFF8        	  5868:                 dbf d6,ROx_LOOP6
00:00003B5A 0C80000C7F8C    	  5869:                 cmpi.l #$000C7F8C,d0
00:00003B60 66FE            	  5870:                 bne.s *
00:00003B62 0C8500000250    	  5871:                 cmpi.l #$00000250,d5
00:00003B68 66FE            	  5872:                 bne.s *
                            	  5873: 
                            	  5874: 
                            	  5875: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  5876: 
00:00003B6A 203C80018FF1    	  5877:                 move.l #$80018FF1,d0
00:00003B70 7A00            	  5878:                 moveq  #$00000000,d5
                            	  5879: 
                            	  5880: *        BYTE LEFT
00:00003B72 E318            	  5881:                 rol.b #1,d0
00:00003B74 6100FF22        	  5882:                 bsr ROx_FLAGS
00:00003B78 EB18            	  5883:                 rol.b #5,d0
00:00003B7A 6100FF1C        	  5884:                 bsr ROx_FLAGS
00:00003B7E EF18            	  5885:                 rol.b #7,d0
00:00003B80 6100FF16        	  5886:                 bsr ROx_FLAGS
00:00003B84 E118            	  5887:                 rol.b #8,d0
00:00003B86 6100FF10        	  5888:                 bsr ROx_FLAGS
00:00003B8A 0C8080018F3E    	  5889:                 cmpi.l #$80018F3E,d0
00:00003B90 66FE            	  5890:                 bne.s *
00:00003B92 0C8500000009    	  5891:                 cmpi.l #$00000009,d5
00:00003B98 66FE            	  5892:                 bne.s *
                            	  5893: 
                            	  5894: *        BYTE RIGHT
00:00003B9A E218            	  5895:                 ror.b #1,d0
00:00003B9C 6100FEFA        	  5896:                 bsr ROx_FLAGS
00:00003BA0 EA18            	  5897:                 ror.b #5,d0
00:00003BA2 6100FEF4        	  5898:                 bsr ROx_FLAGS
00:00003BA6 EE18            	  5899:                 ror.b #7,d0
00:00003BA8 6100FEEE        	  5900:                 bsr ROx_FLAGS
00:00003BAC E018            	  5901:                 ror.b #8,d0
00:00003BAE 6100FEE8        	  5902:                 bsr ROx_FLAGS
00:00003BB2 0C8080018FF1    	  5903:                 cmpi.l #$80018FF1,d0
00:00003BB8 66FE            	  5904:                 bne.s *
00:00003BBA 0C8500000024    	  5905:                 cmpi.l #$00000024,d5
00:00003BC0 66FE            	  5906:                 bne.s *
                            	  5907: 
                            	  5908: *        WORD LEFT
00:00003BC2 E358            	  5909:                 rol.w #1,d0
00:00003BC4 6100FED2        	  5910:                 bsr ROx_FLAGS
00:00003BC8 EB58            	  5911:                 rol.w #5,d0
00:00003BCA 6100FECC        	  5912:                 bsr ROx_FLAGS
00:00003BCE EF58            	  5913:                 rol.w #7,d0
00:00003BD0 6100FEC6        	  5914:                 bsr ROx_FLAGS
00:00003BD4 E158            	  5915:                 rol.w #8,d0
00:00003BD6 6100FEC0        	  5916:                 bsr ROx_FLAGS
00:00003BDA 0C808001FE31    	  5917:                 cmpi.l #$8001FE31,d0
00:00003BE0 66FE            	  5918:                 bne.s *
00:00003BE2 0C8500000037    	  5919:                 cmpi.l #$00000037,d5
00:00003BE8 66FE            	  5920:                 bne.s *
                            	  5921: 
                            	  5922: *        WORD RIGHT
00:00003BEA E258            	  5923:                 ror.w #1,d0
00:00003BEC 6100FEAA        	  5924:                 bsr ROx_FLAGS
00:00003BF0 EA58            	  5925:                 ror.w #5,d0
00:00003BF2 6100FEA4        	  5926:                 bsr ROx_FLAGS
00:00003BF6 EE58            	  5927:                 ror.w #7,d0
00:00003BF8 6100FE9E        	  5928:                 bsr ROx_FLAGS
00:00003BFC E058            	  5929:                 ror.w #8,d0
00:00003BFE 6100FE98        	  5930:                 bsr ROx_FLAGS
00:00003C02 0C8080018FF1    	  5931:                 cmpi.l #$80018FF1,d0
00:00003C08 66FE            	  5932:                 bne.s *
00:00003C0A 0C850000005B    	  5933:                 cmpi.l #$0000005B,d5
00:00003C10 66FE            	  5934:                 bne.s *
                            	  5935: 
                            	  5936: *        LONG LEFT
00:00003C12 E398            	  5937:                 rol.l #1,d0
00:00003C14 6100FE82        	  5938:                 bsr ROx_FLAGS
00:00003C18 EB98            	  5939:                 rol.l #5,d0
00:00003C1A 6100FE7C        	  5940:                 bsr ROx_FLAGS
00:00003C1E EF98            	  5941:                 rol.l #7,d0
00:00003C20 6100FE76        	  5942:                 bsr ROx_FLAGS
00:00003C24 E198            	  5943:                 rol.l #8,d0
00:00003C26 6100FE70        	  5944:                 bsr ROx_FLAGS
00:00003C2A 0C80FE300031    	  5945:                 cmpi.l #$FE300031,d0
00:00003C30 66FE            	  5946:                 bne.s *
00:00003C32 0C8500000065    	  5947:                 cmpi.l #$00000065,d5
00:00003C38 66FE            	  5948:                 bne.s *
                            	  5949: 
                            	  5950: *        LONG RIGHT
00:00003C3A E298            	  5951:                 ror.l #1,d0
00:00003C3C 6100FE5A        	  5952:                 bsr ROx_FLAGS
00:00003C40 EA98            	  5953:                 ror.l #5,d0
00:00003C42 6100FE54        	  5954:                 bsr ROx_FLAGS
00:00003C46 EE98            	  5955:                 ror.l #7,d0
00:00003C48 6100FE4E        	  5956:                 bsr ROx_FLAGS
00:00003C4C E098            	  5957:                 ror.l #8,d0
00:00003C4E 6100FE48        	  5958:                 bsr ROx_FLAGS
00:00003C52 0C8080018FF1    	  5959:                 cmpi.l #$80018FF1,d0
00:00003C58 66FE            	  5960:                 bne.s *
00:00003C5A 0C8500000080    	  5961:                 cmpi.l #$00000080,d5
00:00003C60 66FE            	  5962:                 bne.s *
                            	  5963: 
                            	  5964: 
                            	  5965: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  5966: 
00:00003C62 7A00            	  5967:                 moveq  #$00000000,d5
00:00003C64 307C0100        	  5968:                 move.l #$00000100,a0
00:00003C68 30BC8FF1        	  5969:                 move.w #$8FF1,(a0)
                            	  5970: 
                            	  5971: *        WORD LEFT
00:00003C6C E7D0            	  5972:                 rol (a0)
00:00003C6E 6100FE28        	  5973:                 bsr ROx_FLAGS
00:00003C72 E7D0            	  5974:                 rol (a0)
00:00003C74 6100FE22        	  5975:                 bsr ROx_FLAGS
00:00003C78 E7D0            	  5976:                 rol (a0)
00:00003C7A 6100FE1C        	  5977:                 bsr ROx_FLAGS
00:00003C7E E7D0            	  5978:                 rol (a0)
00:00003C80 6100FE16        	  5979:                 bsr ROx_FLAGS
00:00003C84 3010            	  5980:                 move.w (a0),d0
00:00003C86 0C808001FF18    	  5981:                 cmpi.l #$8001FF18,d0
00:00003C8C 66FE            	  5982:                 bne.s *
00:00003C8E 0C8500000009    	  5983:                 cmpi.l #$00000009,d5
00:00003C94 66FE            	  5984:                 bne.s *
                            	  5985: 
                            	  5986: *        WORD RIGHT
00:00003C96 E6D0            	  5987:                 ror (a0)
00:00003C98 6100FDFE        	  5988:                 bsr ROx_FLAGS
00:00003C9C E6D0            	  5989:                 ror (a0)
00:00003C9E 6100FDF8        	  5990:                 bsr ROx_FLAGS
00:00003CA2 E6D0            	  5991:                 ror (a0)
00:00003CA4 6100FDF2        	  5992:                 bsr ROx_FLAGS
00:00003CA8 E6D0            	  5993:                 ror (a0)
00:00003CAA 6100FDEC        	  5994:                 bsr ROx_FLAGS
00:00003CAE E6D0            	  5995:                 ror (a0)
00:00003CB0 6100FDE6        	  5996:                 bsr ROx_FLAGS
00:00003CB4 E6D0            	  5997:                 ror (a0)
00:00003CB6 6100FDE0        	  5998:                 bsr ROx_FLAGS
00:00003CBA 3010            	  5999:                 move.w (a0),d0
00:00003CBC 0C80800163FC    	  6000:                 cmpi.l #$800163FC,d0
00:00003CC2 66FE            	  6001:                 bne.s *
00:00003CC4 0C850000001B    	  6002:                 cmpi.l #$0000001B,d5
00:00003CCA 66FE            	  6003:                 bne.s *
                            	  6004: 
00:00003CCC 4E75            	  6005:                 rts
                            	  6006: 
                            	  6007: 
                            	  6008: 
                            	  6009: *-----------------------------------------------------------
                            	  6010: *-----------------------------------------------------------
                            	  6011: * OPCODE : ROXx
                            	  6012: *-----------------------------------------------------------
                            	  6013: *-----------------------------------------------------------
                            	  6014: 
                            	  6015: *     Subroutine to check and accumulate the flags
00:00003CCE 40C3            	  6016: ROXx_FLAGS:     move.w sr,d3
00:00003CD0 02830000000F    	  6017:                 andi.l #$0F,d3            * Isolate flags
00:00003CD6 DA83            	  6018:                 add.l d3,d5               * Copy flag results into accumulator
00:00003CD8 4E75            	  6019:                 rts
                            	  6020: 
                            	  6021: op_ROXx:
                            	  6022: 
                            	  6023: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6024: 
                            	  6025: *        BYTE LEFT
00:00003CDA 203C80018FF1    	  6026:                 move.l #$80018FF1,d0
00:00003CE0 7A00            	  6027:                 moveq  #$00000000,d5
00:00003CE2 7C11            	  6028:                 moveq  #$00000011,d6
                            	  6029: ROXx_LOOP1:
00:00003CE4 ED30            	  6030:                 roxl.b d6,d0
00:00003CE6 61E6            	  6031:                 bsr ROXx_FLAGS
00:00003CE8 51CEFFFA        	  6032:                 dbf d6,ROXx_LOOP1
00:00003CEC 0C8080018FD0    	  6033:                 cmpi.l #$80018FD0,d0
00:00003CF2 66FE            	  6034:                 bne.s *
00:00003CF4 0C8500000042    	  6035:                 cmpi.l #$00000042,d5
00:00003CFA 66FE            	  6036:                 bne.s *
                            	  6037: 
                            	  6038: *        BYTE RIGHT
00:00003CFC 203C80018FF1    	  6039:                 move.l #$80018FF1,d0
00:00003D02 7C12            	  6040:                 moveq  #$00000012,d6
                            	  6041: ROXx_LOOP2:
00:00003D04 EC30            	  6042:                 roxr.b d6,d0
00:00003D06 61C6            	  6043:                 bsr ROXx_FLAGS
00:00003D08 51CEFFFA        	  6044:                 dbf d6,ROXx_LOOP2
00:00003D0C 0C8080018F51    	  6045:                 cmpi.l #$80018F51,d0
00:00003D12 66FE            	  6046:                 bne.s *
00:00003D14 0C850000009C    	  6047:                 cmpi.l #$0000009C,d5
00:00003D1A 66FE            	  6048:                 bne.s *
                            	  6049: 
                            	  6050: 
                            	  6051: *        WORD LEFT
00:00003D1C 203C80018FF1    	  6052:                 move.l #$80018FF1,d0
00:00003D22 7C13            	  6053:                 moveq  #$00000013,d6
                            	  6054: ROXx_LOOP3:
00:00003D24 ED70            	  6055:                 roxl.w d6,d0
00:00003D26 61A6            	  6056:                 bsr ROXx_FLAGS
00:00003D28 51CEFFFA        	  6057:                 dbf d6,ROXx_LOOP3
00:00003D2C 0C8080013980    	  6058:                 cmpi.l #$80013980,d0
00:00003D32 66FE            	  6059:                 bne.s *
00:00003D34 0C85000000C9    	  6060:                 cmpi.l #$000000C9,d5
00:00003D3A 66FE            	  6061:                 bne.s *
                            	  6062: 
                            	  6063: *        WORD RIGHT
00:00003D3C 203C80018FF1    	  6064:                 move.l #$80018FF1,d0
00:00003D42 7C1E            	  6065:                 move.l #$0000001E,d6
                            	  6066: ROXx_LOOP4:
00:00003D44 EC70            	  6067:                 roxr.w d6,d0
00:00003D46 6186            	  6068:                 bsr ROXx_FLAGS
00:00003D48 51CEFFFA        	  6069:                 dbf d6,ROXx_LOOP4
00:00003D4C 0C8080010A1D    	  6070:                 cmpi.l #$80010A1D,d0
00:00003D52 66FE            	  6071:                 bne.s *
00:00003D54 0C850000014D    	  6072:                 cmpi.l #$0000014D,d5
00:00003D5A 66FE            	  6073:                 bne.s *
                            	  6074: 
                            	  6075: 
                            	  6076: *        LONG LEFT
00:00003D5C 203C80018FF1    	  6077:                 move.l #$80018FF1,d0
00:00003D62 7C15            	  6078:                 moveq  #$00000015,d6
                            	  6079: ROXx_LOOP5:
00:00003D64 EDB0            	  6080:                 roxl.l d6,d0
00:00003D66 6100FF66        	  6081:                 bsr ROXx_FLAGS
00:00003D6A 51CEFFF8        	  6082:                 dbf d6,ROXx_LOOP5
00:00003D6E 0C80800185D0    	  6083:                 cmpi.l #$800185D0,d0
00:00003D74 66FE            	  6084:                 bne.s *
00:00003D76 0C85000001A1    	  6085:                 cmpi.l #$000001A1,d5
00:00003D7C 66FE            	  6086:                 bne.s *
                            	  6087: 
                            	  6088: *        LONG RIGHT
00:00003D7E 203C80018FF1    	  6089:                 move.l #$80018FF1,d0
00:00003D84 7C16            	  6090:                 moveq  #$00000016,d6
                            	  6091: ROXx_LOOP6:
00:00003D86 ECB0            	  6092:                 roxr.l d6,d0
00:00003D88 6100FF44        	  6093:                 bsr ROXx_FLAGS
00:00003D8C 51CEFFF8        	  6094:                 dbf d6,ROXx_LOOP6
00:00003D90 0C80082D8200    	  6095:                 cmpi.l #$082D8200,d0
00:00003D96 66FE            	  6096:                 bne.s *
00:00003D98 0C85000001DE    	  6097:                 cmpi.l #$000001DE,d5
00:00003D9E 66FE            	  6098:                 bne.s *
                            	  6099: 
                            	  6100: 
                            	  6101: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6102: 
00:00003DA0 203C80018FF1    	  6103:                 move.l #$80018FF1,d0
00:00003DA6 7A00            	  6104:                 moveq  #$00000000,d5
                            	  6105: 
                            	  6106: *        BYTE LEFT
00:00003DA8 E310            	  6107:                 roxl.b #1,d0
00:00003DAA 6100FF22        	  6108:                 bsr ROXx_FLAGS
00:00003DAE EB10            	  6109:                 roxl.b #5,d0
00:00003DB0 6100FF1C        	  6110:                 bsr ROXx_FLAGS
00:00003DB4 EF10            	  6111:                 roxl.b #7,d0
00:00003DB6 6100FF16        	  6112:                 bsr ROXx_FLAGS
00:00003DBA E110            	  6113:                 roxl.b #8,d0
00:00003DBC 6100FF10        	  6114:                 bsr ROXx_FLAGS
00:00003DC0 0C8080018F09    	  6115:                 cmpi.l #$80018F09,d0
00:00003DC6 66FE            	  6116:                 bne.s *
00:00003DC8 0C850000000B    	  6117:                 cmpi.l #$0000000B,d5
00:00003DCE 66FE            	  6118:                 bne.s *
                            	  6119: 
                            	  6120: *        BYTE RIGHT
00:00003DD0 E210            	  6121:                 roxr.b #1,d0
00:00003DD2 6100FEFA        	  6122:                 bsr ROXx_FLAGS
00:00003DD6 EA10            	  6123:                 roxr.b #5,d0
00:00003DD8 6100FEF4        	  6124:                 bsr ROXx_FLAGS
00:00003DDC EE10            	  6125:                 roxr.b #7,d0
00:00003DDE 6100FEEE        	  6126:                 bsr ROXx_FLAGS
00:00003DE2 E010            	  6127:                 roxr.b #8,d0
00:00003DE4 6100FEE8        	  6128:                 bsr ROXx_FLAGS
00:00003DE8 0C8080018F00    	  6129:                 cmpi.l #$80018F00,d0
00:00003DEE 66FE            	  6130:                 bne.s *
00:00003DF0 0C8500000015    	  6131:                 cmpi.l #$00000015,d5
00:00003DF6 66FE            	  6132:                 bne.s *
                            	  6133: 
                            	  6134: *        WORD LEFT
00:00003DF8 E350            	  6135:                 roxl.w #1,d0
00:00003DFA 6100FED2        	  6136:                 bsr ROXx_FLAGS
00:00003DFE EB50            	  6137:                 roxl.w #5,d0
00:00003E00 6100FECC        	  6138:                 bsr ROXx_FLAGS
00:00003E04 EF50            	  6139:                 roxl.w #7,d0
00:00003E06 6100FEC6        	  6140:                 bsr ROXx_FLAGS
00:00003E0A E150            	  6141:                 roxl.w #8,d0
00:00003E0C 6100FEC0        	  6142:                 bsr ROXx_FLAGS
00:00003E10 0C808001B000    	  6143:                 cmpi.l #$8001B000,d0
00:00003E16 66FE            	  6144:                 bne.s *
00:00003E18 0C8500000027    	  6145:                 cmpi.l #$00000027,d5
00:00003E1E 66FE            	  6146:                 bne.s *
                            	  6147: 
                            	  6148: *        WORD RIGHT
00:00003E20 E250            	  6149:                 roxr.w #1,d0
00:00003E22 6100FEAA        	  6150:                 bsr ROXx_FLAGS
00:00003E26 EA50            	  6151:                 roxr.w #5,d0
00:00003E28 6100FEA4        	  6152:                 bsr ROXx_FLAGS
00:00003E2C EE50            	  6153:                 roxr.w #7,d0
00:00003E2E 6100FE9E        	  6154:                 bsr ROXx_FLAGS
00:00003E32 E050            	  6155:                 roxr.w #8,d0
00:00003E34 6100FE98        	  6156:                 bsr ROXx_FLAGS
00:00003E38 0C8080010A00    	  6157:                 cmpi.l #$80010A00,d0
00:00003E3E 66FE            	  6158:                 bne.s *
00:00003E40 0C8500000028    	  6159:                 cmpi.l #$00000028,d5
00:00003E46 66FE            	  6160:                 bne.s *
                            	  6161: 
                            	  6162: *        LONG LEFT
00:00003E48 E390            	  6163:                 roxl.l #1,d0
00:00003E4A 6100FE82        	  6164:                 bsr ROXx_FLAGS
00:00003E4E EB90            	  6165:                 roxl.l #5,d0
00:00003E50 6100FE7C        	  6166:                 bsr ROXx_FLAGS
00:00003E54 EF90            	  6167:                 roxl.l #7,d0
00:00003E56 6100FE76        	  6168:                 bsr ROXx_FLAGS
00:00003E5A E190            	  6169:                 roxl.l #8,d0
00:00003E5C 6100FE70        	  6170:                 bsr ROXx_FLAGS
00:00003E60 0C8040000010    	  6171:                 cmpi.l #$40000010,d0
00:00003E66 66FE            	  6172:                 bne.s *
00:00003E68 0C850000002A    	  6173:                 cmpi.l #$0000002A,d5
00:00003E6E 66FE            	  6174:                 bne.s *
                            	  6175: 
                            	  6176: *        LONG RIGHT
00:00003E70 E290            	  6177:                 roxr.l #1,d0
00:00003E72 6100FE5A        	  6178:                 bsr ROXx_FLAGS
00:00003E76 EA90            	  6179:                 roxr.l #5,d0
00:00003E78 6100FE54        	  6180:                 bsr ROXx_FLAGS
00:00003E7C EE90            	  6181:                 roxr.l #7,d0
00:00003E7E 6100FE4E        	  6182:                 bsr ROXx_FLAGS
00:00003E82 E090            	  6183:                 roxr.l #8,d0
00:00003E84 6100FE48        	  6184:                 bsr ROXx_FLAGS
00:00003E88 0C8000010200    	  6185:                 cmpi.l #$00010200,d0
00:00003E8E 66FE            	  6186:                 bne.s *
00:00003E90 0C8500000032    	  6187:                 cmpi.l #$00000032,d5
00:00003E96 66FE            	  6188:                 bne.s *
                            	  6189: 
                            	  6190: 
                            	  6191: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6192: 
00:00003E98 7A00            	  6193:                 moveq  #$00000000,d5
00:00003E9A 307C0100        	  6194:                 move.l #$00000100,a0
00:00003E9E 30BC8FF1        	  6195:                 move.w #$8FF1,(a0)
                            	  6196: 
                            	  6197: *        WORD LEFT
00:00003EA2 E5D0            	  6198:                 roxl (a0)
00:00003EA4 6100FE28        	  6199:                 bsr ROXx_FLAGS
00:00003EA8 E5D0            	  6200:                 roxl (a0)
00:00003EAA 6100FE22        	  6201:                 bsr ROXx_FLAGS
00:00003EAE E5D0            	  6202:                 roxl (a0)
00:00003EB0 6100FE1C        	  6203:                 bsr ROXx_FLAGS
00:00003EB4 E5D0            	  6204:                 roxl (a0)
00:00003EB6 6100FE16        	  6205:                 bsr ROXx_FLAGS
00:00003EBA 3010            	  6206:                 move.w (a0),d0
00:00003EBC 0C800001FF10    	  6207:                 cmpi.l #$0001FF10,d0
00:00003EC2 66FE            	  6208:                 bne.s *
00:00003EC4 0C8500000009    	  6209:                 cmpi.l #$00000009,d5
00:00003ECA 66FE            	  6210:                 bne.s *
                            	  6211: 
                            	  6212: *        WORD RIGHT
00:00003ECC E4D0            	  6213:                 roxr (a0)
00:00003ECE 6100FDFE        	  6214:                 bsr ROXx_FLAGS
00:00003ED2 E4D0            	  6215:                 roxr (a0)
00:00003ED4 6100FDF8        	  6216:                 bsr ROXx_FLAGS
00:00003ED8 E4D0            	  6217:                 roxr (a0)
00:00003EDA 6100FDF2        	  6218:                 bsr ROXx_FLAGS
00:00003EDE E4D0            	  6219:                 roxr (a0)
00:00003EE0 6100FDEC        	  6220:                 bsr ROXx_FLAGS
00:00003EE4 E4D0            	  6221:                 roxr (a0)
00:00003EE6 6100FDE6        	  6222:                 bsr ROXx_FLAGS
00:00003EEA E4D0            	  6223:                 roxr (a0)
00:00003EEC 6100FDE0        	  6224:                 bsr ROXx_FLAGS
00:00003EF0 3010            	  6225:                 move.w (a0),d0
00:00003EF2 0C80000103FC    	  6226:                 cmpi.l #$000103FC,d0
00:00003EF8 66FE            	  6227:                 bne.s *
00:00003EFA 0C850000000A    	  6228:                 cmpi.l #$0000000A,d5
00:00003F00 66FE            	  6229:                 bne.s *
                            	  6230: 
00:00003F02 4E75            	  6231:                 rts
                            	  6232: 
                            	  6233: 
                            	  6234: 
                            	  6235: 
                            	  6236: *-----------------------------------------------------------
                            	  6237: *-----------------------------------------------------------
                            	  6238: * OPCODE : SHIFTS
                            	  6239: *-----------------------------------------------------------
                            	  6240: *-----------------------------------------------------------
                            	  6241: 
                            	  6242: *     Subroutine to check and accumulate the flags
00:00003F04 40C3            	  6243: SHIFTS_FLAGS:   move.w sr,d3
00:00003F06 02830000000F    	  6244:                 andi.l #$0F,d3            * Isolate flags
00:00003F0C DA83            	  6245:                 add.l d3,d5               * Copy flag results into accumulator
00:00003F0E 4E75            	  6246:                 rts
                            	  6247: 
                            	  6248: op_SHIFTS:
                            	  6249: 
                            	  6250: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6251: 
                            	  6252: *        BYTE LEFT
00:00003F10 203C80018F81    	  6253:                 move.l #$80018F81,d0
00:00003F16 7A00            	  6254:                 moveq  #$00000000,d5
00:00003F18 7C02            	  6255:                 moveq  #$00000002,d6
                            	  6256: SHIFTS_LOOP1:
00:00003F1A ED20            	  6257:                 asl.b d6,d0
00:00003F1C 61E6            	  6258:                 bsr SHIFTS_FLAGS
00:00003F1E 51CEFFFA        	  6259:                 dbf d6,SHIFTS_LOOP1
00:00003F22 0C8080018F08    	  6260:                 cmpi.l #$80018F08,d0
00:00003F28 66FE            	  6261:                 bne.s *
00:00003F2A 0C8500000002    	  6262:                 cmpi.l #$00000002,d5
00:00003F30 66FE            	  6263:                 bne.s *
                            	  6264: 
                            	  6265: *        BYTE RIGHT
00:00003F32 203C80018F81    	  6266:                 move.l #$80018F81,d0
00:00003F38 7C02            	  6267:                 moveq  #$00000002,d6
                            	  6268: SHIFTS_LOOP2:
00:00003F3A EC20            	  6269:                 asr.b d6,d0
00:00003F3C 61C6            	  6270:                 bsr SHIFTS_FLAGS
00:00003F3E 51CEFFFA        	  6271:                 dbf d6,SHIFTS_LOOP2
00:00003F42 0C8080018FF0    	  6272:                 cmpi.l #$80018FF0,d0
00:00003F48 66FE            	  6273:                 bne.s *
00:00003F4A 0C850000001A    	  6274:                 cmpi.l #$0000001A,d5
00:00003F50 66FE            	  6275:                 bne.s *
                            	  6276: 
                            	  6277: 
                            	  6278: *        WORD LEFT
00:00003F52 203C80018FF1    	  6279:                 move.l #$80018FF1,d0
00:00003F58 7C02            	  6280:                 moveq  #$00000002,d6
                            	  6281: SHIFTS_LOOP3:
00:00003F5A ED60            	  6282:                 asl.w d6,d0
00:00003F5C 61A6            	  6283:                 bsr SHIFTS_FLAGS
00:00003F5E 51CEFFFA        	  6284:                 dbf d6,SHIFTS_LOOP3
00:00003F62 0C8080017F88    	  6285:                 cmpi.l #$80017F88,d0
00:00003F68 66FE            	  6286:                 bne.s *
00:00003F6A 0C850000001C    	  6287:                 cmpi.l #$0000001C,d5
00:00003F70 66FE            	  6288:                 bne.s *
                            	  6289: 
                            	  6290: *        WORD RIGHT
00:00003F72 203C80018FF1    	  6291:                 move.l #$80018FF1,d0
00:00003F78 7C02            	  6292:                 moveq  #$00000002,d6
                            	  6293: SHIFTS_LOOP4:
00:00003F7A EC60            	  6294:                 asr.w d6,d0
00:00003F7C 6186            	  6295:                 bsr SHIFTS_FLAGS
00:00003F7E 51CEFFFA        	  6296:                 dbf d6,SHIFTS_LOOP4
00:00003F82 0C808001F1FE    	  6297:                 cmpi.l #$8001F1FE,d0
00:00003F88 66FE            	  6298:                 bne.s *
00:00003F8A 0C8500000034    	  6299:                 cmpi.l #$00000034,d5
00:00003F90 66FE            	  6300:                 bne.s *
                            	  6301: 
                            	  6302: 
                            	  6303: *        LONG LEFT
00:00003F92 203C80018FF1    	  6304:                 move.l #$80018FF1,d0
00:00003F98 7C02            	  6305:                 moveq  #$00000002,d6
                            	  6306: SHIFTS_LOOP5:
00:00003F9A EDA0            	  6307:                 asl.l d6,d0
00:00003F9C 6100FF66        	  6308:                 bsr SHIFTS_FLAGS
00:00003FA0 51CEFFF8        	  6309:                 dbf d6,SHIFTS_LOOP5
00:00003FA4 0C80000C7F88    	  6310:                 cmpi.l #$000C7F88,d0
00:00003FAA 66FE            	  6311:                 bne.s *
00:00003FAC 0C8500000036    	  6312:                 cmpi.l #$00000036,d5
00:00003FB2 66FE            	  6313:                 bne.s *
                            	  6314: 
                            	  6315: *        LONG RIGHT
00:00003FB4 203C80018FF1    	  6316:                 move.l #$80018FF1,d0
00:00003FBA 7C02            	  6317:                 moveq  #$00000002,d6
                            	  6318: SHIFTS_LOOP6:
00:00003FBC ECA0            	  6319:                 asr.l d6,d0
00:00003FBE 6100FF44        	  6320:                 bsr SHIFTS_FLAGS
00:00003FC2 51CEFFF8        	  6321:                 dbf d6,SHIFTS_LOOP6
00:00003FC6 0C80F00031FE    	  6322:                 cmpi.l #$F00031FE,d0
00:00003FCC 66FE            	  6323:                 bne.s *
00:00003FCE 0C850000004E    	  6324:                 cmpi.l #$0000004E,d5
00:00003FD4 66FE            	  6325:                 bne.s *
                            	  6326: 
                            	  6327: 
                            	  6328: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6329: 
00:00003FD6 203C80018FF1    	  6330:                 move.l #$80018FF1,d0
00:00003FDC 7A00            	  6331:                 moveq  #$00000000,d5
                            	  6332: 
                            	  6333: *        BYTE LEFT
00:00003FDE D000            	  6334:                 asl.b #1,d0
00:00003FE0 6100FF22        	  6335:                 bsr SHIFTS_FLAGS
00:00003FE4 E500            	  6336:                 asl.b #2,d0
00:00003FE6 6100FF1C        	  6337:                 bsr SHIFTS_FLAGS
00:00003FEA D000            	  6338:                 asl.b #1,d0
00:00003FEC 6100FF16        	  6339:                 bsr SHIFTS_FLAGS
00:00003FF0 E700            	  6340:                 asl.b #3,d0
00:00003FF2 6100FF10        	  6341:                 bsr SHIFTS_FLAGS
00:00003FF6 0C8080018F80    	  6342:                 cmpi.l #$80018F80,d0
00:00003FFC 66FE            	  6343:                 bne.s *
00:00003FFE 0C850000001F    	  6344:                 cmpi.l #$0000001F,d5
00:00004004 66FE            	  6345:                 bne.s *
                            	  6346: 
                            	  6347: *        BYTE RIGHT
00:00004006 E200            	  6348:                 asr.b #1,d0
00:00004008 6100FEFA        	  6349:                 bsr SHIFTS_FLAGS
00:0000400C E400            	  6350:                 asr.b #2,d0
00:0000400E 6100FEF4        	  6351:                 bsr SHIFTS_FLAGS
00:00004012 E600            	  6352:                 asr.b #3,d0
00:00004014 6100FEEE        	  6353:                 bsr SHIFTS_FLAGS
00:00004018 E200            	  6354:                 asr.b #1,d0
00:0000401A 6100FEE8        	  6355:                 bsr SHIFTS_FLAGS
00:0000401E 0C8080018FFF    	  6356:                 cmpi.l #$80018FFF,d0
00:00004024 66FE            	  6357:                 bne.s *
00:00004026 0C850000003F    	  6358:                 cmpi.l #$0000003F,d5
00:0000402C 66FE            	  6359:                 bne.s *
                            	  6360: 
                            	  6361: *        WORD LEFT
00:0000402E D040            	  6362:                 asl.w #1,d0
00:00004030 6100FED2        	  6363:                 bsr SHIFTS_FLAGS
00:00004034 E540            	  6364:                 asl.w #2,d0
00:00004036 6100FECC        	  6365:                 bsr SHIFTS_FLAGS
00:0000403A E740            	  6366:                 asl.w #3,d0
00:0000403C 6100FEC6        	  6367:                 bsr SHIFTS_FLAGS
00:00004040 EB40            	  6368:                 asl.w #5,d0
00:00004042 6100FEC0        	  6369:                 bsr SHIFTS_FLAGS
00:00004046 0C808001F800    	  6370:                 cmpi.l #$8001F800,d0
00:0000404C 66FE            	  6371:                 bne.s *
00:0000404E 0C8500000056    	  6372:                 cmpi.l #$00000056,d5
00:00004054 66FE            	  6373:                 bne.s *
                            	  6374: 
                            	  6375: *        WORD RIGHT
00:00004056 EA40            	  6376:                 asr.w #5,d0
00:00004058 6100FEAA        	  6377:                 bsr SHIFTS_FLAGS
00:0000405C E240            	  6378:                 asr.w #1,d0
00:0000405E 6100FEA4        	  6379:                 bsr SHIFTS_FLAGS
00:00004062 E440            	  6380:                 asr.w #2,d0
00:00004064 6100FE9E        	  6381:                 bsr SHIFTS_FLAGS
00:00004068 E840            	  6382:                 asr.w #4,d0
00:0000406A 6100FE98        	  6383:                 bsr SHIFTS_FLAGS
00:0000406E 0C808001FFFF    	  6384:                 cmpi.l #$8001FFFF,d0
00:00004074 66FE            	  6385:                 bne.s *
00:00004076 0C8500000077    	  6386:                 cmpi.l #$00000077,d5
00:0000407C 66FE            	  6387:                 bne.s *
                            	  6388: 
                            	  6389: *        LONG LEFT
00:0000407E 203C80018FF1    	  6390:                 move.l #$80018FF1,d0
00:00004084 D080            	  6391:                 asl.l #1,d0
00:00004086 6100FE7C        	  6392:                 bsr SHIFTS_FLAGS
00:0000408A E580            	  6393:                 asl.l #2,d0
00:0000408C 6100FE76        	  6394:                 bsr SHIFTS_FLAGS
00:00004090 EF80            	  6395:                 asl.l #7,d0
00:00004092 6100FE70        	  6396:                 bsr SHIFTS_FLAGS
00:00004096 E980            	  6397:                 asl.l #4,d0
00:00004098 6100FE6A        	  6398:                 bsr SHIFTS_FLAGS
00:0000409C 0C8063FC4000    	  6399:                 cmpi.l #$63FC4000,d0
00:000040A2 66FE            	  6400:                 bne.s *
00:000040A4 0C850000007A    	  6401:                 cmpi.l #$0000007A,d5
00:000040AA 66FE            	  6402:                 bne.s *
                            	  6403: 
                            	  6404: *        LONG RIGHT
00:000040AC 203C80018FF1    	  6405:                 move.l #$80018FF1,d0
00:000040B2 E280            	  6406:                 asr.l #1,d0
00:000040B4 6100FE4E        	  6407:                 bsr SHIFTS_FLAGS
00:000040B8 EA80            	  6408:                 asr.l #5,d0
00:000040BA 6100FE48        	  6409:                 bsr SHIFTS_FLAGS
00:000040BE EE80            	  6410:                 asr.l #7,d0
00:000040C0 6100FE42        	  6411:                 bsr SHIFTS_FLAGS
00:000040C4 E080            	  6412:                 asr.l #8,d0
00:000040C6 6100FE3C        	  6413:                 bsr SHIFTS_FLAGS
00:000040CA 0C80FFFFFC00    	  6414:                 cmpi.l #$FFFFFC00,d0
00:000040D0 66FE            	  6415:                 bne.s *
00:000040D2 0C850000009C    	  6416:                 cmpi.l #$0000009C,d5
00:000040D8 66FE            	  6417:                 bne.s *
                            	  6418: 
                            	  6419: 
                            	  6420: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6421: 
00:000040DA 7A00            	  6422:                 moveq  #$00000000,d5
00:000040DC 307C0100        	  6423:                 move.l #$00000100,a0
00:000040E0 30BC8FF1        	  6424:                 move.w #$8FF1,(a0)
                            	  6425: 
                            	  6426: *        WORD LEFT
00:000040E4 E1D0            	  6427:                 asl  (a0)
00:000040E6 6100FE1C        	  6428:                 bsr SHIFTS_FLAGS
00:000040EA E1D0            	  6429:                 asl  (a0)
00:000040EC 6100FE16        	  6430:                 bsr SHIFTS_FLAGS
00:000040F0 E1D0            	  6431:                 asl  (a0)
00:000040F2 6100FE10        	  6432:                 bsr SHIFTS_FLAGS
00:000040F6 E1D0            	  6433:                 asl  (a0)
00:000040F8 6100FE0A        	  6434:                 bsr SHIFTS_FLAGS
00:000040FC 3010            	  6435:                 move.w (a0),d0
00:000040FE 0C80FFFFFF10    	  6436:                 cmpi.l #$FFFFFF10,d0
00:00004104 66FE            	  6437:                 bne.s *
00:00004106 0C850000000D    	  6438:                 cmpi.l #$0000000D,d5
00:0000410C 66FE            	  6439:                 bne.s *
                            	  6440: 
                            	  6441: *        WORD RIGHT
00:0000410E E0D0            	  6442:                 asr (a0)
00:00004110 6100FDF2        	  6443:                 bsr SHIFTS_FLAGS
00:00004114 E0D0            	  6444:                 asr (a0)
00:00004116 6100FDEC        	  6445:                 bsr SHIFTS_FLAGS
00:0000411A E0D0            	  6446:                 asr (a0)
00:0000411C 6100FDE6        	  6447:                 bsr SHIFTS_FLAGS
00:00004120 E0D0            	  6448:                 asr (a0)
00:00004122 6100FDE0        	  6449:                 bsr SHIFTS_FLAGS
00:00004126 E0D0            	  6450:                 asr (a0)
00:00004128 6100FDDA        	  6451:                 bsr SHIFTS_FLAGS
00:0000412C E0D0            	  6452:                 asr (a0)
00:0000412E 6100FDD4        	  6453:                 bsr SHIFTS_FLAGS
00:00004132 3010            	  6454:                 move.w (a0),d0
00:00004134 0C80FFFFFFFC    	  6455:                 cmpi.l #$FFFFFFFC,d0
00:0000413A 66FE            	  6456:                 bne.s *
00:0000413C 0C850000003E    	  6457:                 cmpi.l #$0000003E,d5
00:00004142 66FE            	  6458:                 bne.s *
                            	  6459: 
00:00004144 4E75            	  6460:                 rts
                            	  6461: 
                            	  6462: 
                            	  6463: 
                            	  6464: *-----------------------------------------------------------
                            	  6465: *-----------------------------------------------------------
                            	  6466: * OPCODE : SHIFTS2
                            	  6467: *-----------------------------------------------------------
                            	  6468: *-----------------------------------------------------------
                            	  6469: 
                            	  6470: *     Subroutine to check and accumulate the flags
00:00004146 40C3            	  6471: SHIFTS2_FLAGS:  move.w sr,d3
00:00004148 02830000000F    	  6472:                 andi.l #$0F,d3            * Isolate flags
00:0000414E DA83            	  6473:                 add.l d3,d5               * Copy flag results into accumulator
00:00004150 4E75            	  6474:                 rts
                            	  6475: 
                            	  6476: op_SHIFTS2:
                            	  6477: 
                            	  6478: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6479: 
                            	  6480: *        BYTE LEFT
00:00004152 203C80018F81    	  6481:                 move.l #$80018F81,d0
00:00004158 7A00            	  6482:                 moveq  #$00000000,d5
00:0000415A 7C02            	  6483:                 moveq  #$00000002,d6
                            	  6484: SHIFTS2_LOOP1:
00:0000415C ED28            	  6485:                 lsl.b d6,d0
00:0000415E 61E6            	  6486:                 bsr SHIFTS2_FLAGS
00:00004160 51CEFFFA        	  6487:                 dbf d6,SHIFTS2_LOOP1
00:00004164 0C8080018F08    	  6488:                 cmpi.l #$80018F08,d0
00:0000416A 66FE            	  6489:                 bne.s *
00:0000416C 4A85            	  6490:                 cmpi.l #$00000000,d5
00:0000416E 66FE            	  6491:                 bne.s *
                            	  6492: 
                            	  6493: *        BYTE RIGHT
00:00004170 203C80018F81    	  6494:                 move.l #$80018F81,d0
00:00004176 7C02            	  6495:                 moveq  #$00000002,d6
                            	  6496: SHIFTS2_LOOP2:
00:00004178 EC28            	  6497:                 lsr.b d6,d0
00:0000417A 61CA            	  6498:                 bsr SHIFTS2_FLAGS
00:0000417C 51CEFFFA        	  6499:                 dbf d6,SHIFTS2_LOOP2
00:00004180 0C8080018F10    	  6500:                 cmpi.l #$80018F10,d0
00:00004186 66FE            	  6501:                 bne.s *
00:00004188 4A85            	  6502:                 cmpi.l #$00000000,d5
00:0000418A 66FE            	  6503:                 bne.s *
                            	  6504: 
                            	  6505: 
                            	  6506: *        WORD LEFT
00:0000418C 203C80018FF1    	  6507:                 move.l #$80018FF1,d0
00:00004192 7C02            	  6508:                 moveq  #$00000002,d6
                            	  6509: SHIFTS2_LOOP3:
00:00004194 ED68            	  6510:                 lsl.w d6,d0
00:00004196 61AE            	  6511:                 bsr SHIFTS2_FLAGS
00:00004198 51CEFFFA        	  6512:                 dbf d6,SHIFTS2_LOOP3
00:0000419C 0C8080017F88    	  6513:                 cmpi.l #$80017F88,d0
00:000041A2 66FE            	  6514:                 bne.s *
00:000041A4 4A85            	  6515:                 cmpi.l #$00000000,d5
00:000041A6 66FE            	  6516:                 bne.s *
                            	  6517: 
                            	  6518: *        WORD RIGHT
00:000041A8 203C80018FF1    	  6519:                 move.l #$80018FF1,d0
00:000041AE 7C02            	  6520:                 moveq  #$00000002,d6
                            	  6521: SHIFTS2_LOOP4:
00:000041B0 EC68            	  6522:                 lsr.w d6,d0
00:000041B2 6192            	  6523:                 bsr SHIFTS2_FLAGS
00:000041B4 51CEFFFA        	  6524:                 dbf d6,SHIFTS2_LOOP4
00:000041B8 0C80800111FE    	  6525:                 cmpi.l #$800111FE,d0
00:000041BE 66FE            	  6526:                 bne.s *
00:000041C0 4A85            	  6527:                 cmpi.l #$00000000,d5
00:000041C2 66FE            	  6528:                 bne.s *
                            	  6529: 
                            	  6530: 
                            	  6531: *        LONG LEFT
00:000041C4 203C80018FF1    	  6532:                 move.l #$80018FF1,d0
00:000041CA 7C02            	  6533:                 moveq  #$00000002,d6
                            	  6534: SHIFTS2_LOOP5:
00:000041CC EDA8            	  6535:                 lsl.l d6,d0
00:000041CE 6100FF76        	  6536:                 bsr SHIFTS2_FLAGS
00:000041D2 51CEFFF8        	  6537:                 dbf d6,SHIFTS2_LOOP5
00:000041D6 0C80000C7F88    	  6538:                 cmpi.l #$000C7F88,d0
00:000041DC 66FE            	  6539:                 bne.s *
00:000041DE 4A85            	  6540:                 cmpi.l #$00000000,d5
00:000041E0 66FE            	  6541:                 bne.s *
                            	  6542: 
                            	  6543: *        LONG RIGHT
00:000041E2 203C80018FF1    	  6544:                 move.l #$80018FF1,d0
00:000041E8 7C02            	  6545:                 moveq  #$00000002,d6
                            	  6546: SHIFTS2_LOOP6:
00:000041EA ECA8            	  6547:                 lsr.l d6,d0
00:000041EC 6100FF58        	  6548:                 bsr SHIFTS2_FLAGS
00:000041F0 51CEFFF8        	  6549:                 dbf d6,SHIFTS2_LOOP6
00:000041F4 0C80100031FE    	  6550:                 cmpi.l #$100031FE,d0
00:000041FA 66FE            	  6551:                 bne.s *
00:000041FC 4A85            	  6552:                 cmpi.l #$00000000,d5
00:000041FE 66FE            	  6553:                 bne.s *
                            	  6554: 
                            	  6555: 
                            	  6556: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6557: 
00:00004200 203C80018FF1    	  6558:                 move.l #$80018FF1,d0
00:00004206 7A00            	  6559:                 moveq  #$00000000,d5
                            	  6560: 
                            	  6561: *        BYTE LEFT
00:00004208 E308            	  6562:                 lsl.b #1,d0
00:0000420A 6100FF3A        	  6563:                 bsr SHIFTS2_FLAGS
00:0000420E E508            	  6564:                 lsl.b #2,d0
00:00004210 6100FF34        	  6565:                 bsr SHIFTS2_FLAGS
00:00004214 E308            	  6566:                 lsl.b #1,d0
00:00004216 6100FF2E        	  6567:                 bsr SHIFTS2_FLAGS
00:0000421A E708            	  6568:                 lsl.b #3,d0
00:0000421C 6100FF28        	  6569:                 bsr SHIFTS2_FLAGS
00:00004220 0C8080018F80    	  6570:                 cmpi.l #$80018F80,d0
00:00004226 66FE            	  6571:                 bne.s *
00:00004228 0C850000001B    	  6572:                 cmpi.l #$0000001B,d5
00:0000422E 66FE            	  6573:                 bne.s *
                            	  6574: 
                            	  6575: *        BYTE RIGHT
00:00004230 E208            	  6576:                 lsr.b #1,d0
00:00004232 6100FF12        	  6577:                 bsr SHIFTS2_FLAGS
00:00004236 E408            	  6578:                 lsr.b #2,d0
00:00004238 6100FF0C        	  6579:                 bsr SHIFTS2_FLAGS
00:0000423C E608            	  6580:                 lsr.b #3,d0
00:0000423E 6100FF06        	  6581:                 bsr SHIFTS2_FLAGS
00:00004242 E208            	  6582:                 lsr.b #1,d0
00:00004244 6100FF00        	  6583:                 bsr SHIFTS2_FLAGS
00:00004248 0C8080018F01    	  6584:                 cmpi.l #$80018F01,d0
00:0000424E 66FE            	  6585:                 bne.s *
00:00004250 0C850000001B    	  6586:                 cmpi.l #$0000001B,d5
00:00004256 66FE            	  6587:                 bne.s *
                            	  6588: 
                            	  6589: *        WORD LEFT
00:00004258 E348            	  6590:                 lsl.w #1,d0
00:0000425A 6100FEEA        	  6591:                 bsr SHIFTS2_FLAGS
00:0000425E E548            	  6592:                 lsl.w #2,d0
00:00004260 6100FEE4        	  6593:                 bsr SHIFTS2_FLAGS
00:00004264 E748            	  6594:                 lsl.w #3,d0
00:00004266 6100FEDE        	  6595:                 bsr SHIFTS2_FLAGS
00:0000426A EB48            	  6596:                 lsl.w #5,d0
00:0000426C 6100FED8        	  6597:                 bsr SHIFTS2_FLAGS
00:00004270 0C8080010800    	  6598:                 cmpi.l #$80010800,d0
00:00004276 66FE            	  6599:                 bne.s *
00:00004278 0C8500000025    	  6600:                 cmpi.l #$00000025,d5
00:0000427E 66FE            	  6601:                 bne.s *
                            	  6602: 
                            	  6603: *        WORD RIGHT
00:00004280 EA48            	  6604:                 lsr.w #5,d0
00:00004282 6100FEC2        	  6605:                 bsr SHIFTS2_FLAGS
00:00004286 E248            	  6606:                 lsr.w #1,d0
00:00004288 6100FEBC        	  6607:                 bsr SHIFTS2_FLAGS
00:0000428C E448            	  6608:                 lsr.w #2,d0
00:0000428E 6100FEB6        	  6609:                 bsr SHIFTS2_FLAGS
00:00004292 E848            	  6610:                 lsr.w #4,d0
00:00004294 6100FEB0        	  6611:                 bsr SHIFTS2_FLAGS
00:00004298 0C8080010000    	  6612:                 cmpi.l #$80010000,d0
00:0000429E 66FE            	  6613:                 bne.s *
00:000042A0 0C850000002A    	  6614:                 cmpi.l #$0000002A,d5
00:000042A6 66FE            	  6615:                 bne.s *
                            	  6616: 
                            	  6617: *        LONG LEFT
00:000042A8 203C80018FF1    	  6618:                 move.l #$80018FF1,d0
00:000042AE E388            	  6619:                 lsl.l #1,d0
00:000042B0 6100FE94        	  6620:                 bsr SHIFTS2_FLAGS
00:000042B4 E588            	  6621:                 lsl.l #2,d0
00:000042B6 6100FE8E        	  6622:                 bsr SHIFTS2_FLAGS
00:000042BA EF88            	  6623:                 lsl.l #7,d0
00:000042BC 6100FE88        	  6624:                 bsr SHIFTS2_FLAGS
00:000042C0 E988            	  6625:                 lsl.l #4,d0
00:000042C2 6100FE82        	  6626:                 bsr SHIFTS2_FLAGS
00:000042C6 0C8063FC4000    	  6627:                 cmpi.l #$63FC4000,d0
00:000042CC 66FE            	  6628:                 bne.s *
00:000042CE 0C850000002B    	  6629:                 cmpi.l #$0000002B,d5
00:000042D4 66FE            	  6630:                 bne.s *
                            	  6631: 
                            	  6632: *        LONG RIGHT
00:000042D6 203C80018FF1    	  6633:                 move.l #$80018FF1,d0
00:000042DC E288            	  6634:                 lsr.l #1,d0
00:000042DE 6100FE66        	  6635:                 bsr SHIFTS2_FLAGS
00:000042E2 EA88            	  6636:                 lsr.l #5,d0
00:000042E4 6100FE60        	  6637:                 bsr SHIFTS2_FLAGS
00:000042E8 EE88            	  6638:                 lsr.l #7,d0
00:000042EA 6100FE5A        	  6639:                 bsr SHIFTS2_FLAGS
00:000042EE E088            	  6640:                 lsr.l #8,d0
00:000042F0 6100FE54        	  6641:                 bsr SHIFTS2_FLAGS
00:000042F4 0C8000000400    	  6642:                 cmpi.l #$00000400,d0
00:000042FA 66FE            	  6643:                 bne.s *
00:000042FC 0C850000002D    	  6644:                 cmpi.l #$0000002D,d5
00:00004302 66FE            	  6645:                 bne.s *
                            	  6646: 
                            	  6647: 
                            	  6648: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6649: 
00:00004304 7A00            	  6650:                 moveq  #$00000000,d5
00:00004306 307C0100        	  6651:                 move.l #$00000100,a0
00:0000430A 30BC8FF1        	  6652:                 move.w #$8FF1,(a0)
                            	  6653: 
                            	  6654: *        WORD LEFT
00:0000430E E3D0            	  6655:                 lsl  (a0)
00:00004310 6100FE34        	  6656:                 bsr SHIFTS2_FLAGS
00:00004314 E3D0            	  6657:                 lsl  (a0)
00:00004316 6100FE2E        	  6658:                 bsr SHIFTS2_FLAGS
00:0000431A E3D0            	  6659:                 lsl  (a0)
00:0000431C 6100FE28        	  6660:                 bsr SHIFTS2_FLAGS
00:00004320 E3D0            	  6661:                 lsl  (a0)
00:00004322 6100FE22        	  6662:                 bsr SHIFTS2_FLAGS
00:00004326 3010            	  6663:                 move.w (a0),d0
00:00004328 0C800000FF10    	  6664:                 cmpi.l #$0000FF10,d0
00:0000432E 66FE            	  6665:                 bne.s *
00:00004330 0C8500000009    	  6666:                 cmpi.l #$00000009,d5
00:00004336 66FE            	  6667:                 bne.s *
                            	  6668: 
                            	  6669: *        WORD RIGHT
00:00004338 E2D0            	  6670:                 lsr (a0)
00:0000433A 6100FE0A        	  6671:                 bsr SHIFTS2_FLAGS
00:0000433E E2D0            	  6672:                 lsr (a0)
00:00004340 6100FE04        	  6673:                 bsr SHIFTS2_FLAGS
00:00004344 E2D0            	  6674:                 lsr (a0)
00:00004346 6100FDFE        	  6675:                 bsr SHIFTS2_FLAGS
00:0000434A E2D0            	  6676:                 lsr (a0)
00:0000434C 6100FDF8        	  6677:                 bsr SHIFTS2_FLAGS
00:00004350 E2D0            	  6678:                 lsr (a0)
00:00004352 6100FDF2        	  6679:                 bsr SHIFTS2_FLAGS
00:00004356 E2D0            	  6680:                 lsr (a0)
00:00004358 6100FDEC        	  6681:                 bsr SHIFTS2_FLAGS
00:0000435C 3010            	  6682:                 move.w (a0),d0
00:0000435E 0C80000003FC    	  6683:                 cmpi.l #$000003FC,d0
00:00004364 66FE            	  6684:                 bne.s *
00:00004366 0C850000000A    	  6685:                 cmpi.l #$0000000A,d5
00:0000436C 66FE            	  6686:                 bne.s *
                            	  6687: 
00:0000436E 4E75            	  6688:                 rts
                            	  6689: 
                            	  6690: ;-----------------------------------------------------------
                            	  6691: ;-----------------------------------------------------------
                            	  6692: ; OPCODE : BSR / RTS
                            	  6693: ;-----------------------------------------------------------
                            	  6694: ;-----------------------------------------------------------
                            	  6695: 
                            	  6696: ;t3_bsr:
                            	  6697: ;	moveq	#3,d3
                            	  6698: ;	rts
                            	  6699: 
                            	  6700: ;t1_bsr:
                            	  6701: ;	moveq	#1,d1
                            	  6702: ;	rts
                            	  6703: 
                            	  6704: ;op_bsr:
                            	  6705: ;	bsr			t1_bsr
                            	  6706: ;	bsr			t2_bsr
                            	  6707: ;	bsr.w		t3_bsr
                            	  6708: ;	bsr.w		t4_bsr
                            	  6709: ;	cmpi.l	#1,d1
                            	  6710: ;	bne			*
                            	  6711: ;	cmpi.l	#2,d2
                            	  6712: ;	bne			*
                            	  6713: ;	cmpi.l	#3,d3
                            	  6714: ;	bne			*
                            	  6715: ;	cmpi.l	#4,d4
                            	  6716: ;	bne			*
                            	  6717: ;	rts
                            	  6718: 
                            	  6719: ;t2_bsr:
                            	  6720: ;	moveq	#2,d2
                            	  6721: ;	rts
                            	  6722: 	
                            	  6723: ;t4_bsr:
                            	  6724: ;	moveq	#4,d4
                            	  6725: ;	rts
                            	  6726: *    END
                            	  6727:     
                            	  6728: 

Source: "boot.x68"
                            	   983: 	include "TinyBasicFlt.x68"

Source: "TinyBasicFlt.x68"
                            	     1: ******************************************************************
                            	     2: *								 *
                            	     3: *		Tiny Float BASIC for the Motorola MC68000		 *
                            	     4: *								 *
                            	     5: * Derived from Palo Alto Tiny BASIC as published in the May 1976 *
                            	     6: * issue of Dr. Dobb's Journal.  Adapted to the 68000 by:         *
                            	     7: *	Gordon Brandly						 *
                            	     8: *								 *
                            	     9: ******************************************************************
                            	    10: *    Copyright (C) 1984 by Gordon Brandly. This program may be	 *
                            	    11: *    freely distributed for personal use only. All commercial	 *
                            	    12: *		       rights are reserved.			 *
                            	    13: ******************************************************************
                            	    14: * Modified (c) 2022 for the rf68000. Robert Finch
                            	    15: * Numerics changed to floating-point
                            	    16: * added string handling
                            	    17: ******************************************************************
                            	    18: 
                            	    19: * Vers. 1.0  1984/7/17	- Original version by Gordon Brandly
                            	    20: *	1.1  1984/12/9	- Addition of '$' print term by Marvin Lipford
                            	    21: *	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                            	    22: 
                            	    23: *	OPT	FRS,BRS 	forward ref.'s & branches default to short
                            	    24: 
                            	    25: ;CR	EQU	$0D		ASCII equates
                            	    26: ;LF	EQU	$0A
                            	    27: ;TAB	EQU	$09
                            	    28: ;CTRLC	EQU	$03
                            	    29: ;CTRLH	EQU	$08
                            	    30: ;CTRLS	EQU	$13
                            	    31: ;CTRLX	EQU	$18
                            	    32: 
                            	    33: DT_NONE equ 0
                            	    34: DT_NUMERIC equ 1
                            	    35: DT_STRING equ 2		; string descriptor
                            	    36: DT_TEXTPTR equ 3	; pointer into program text
                            	    37: 
                            	    38: BUFLEN	EQU	80		length of keyboard input buffer
                            	    39: STRAREASIZE	EQU	2048	; size of string area
                            	    40: 	CODE
                            	    41: *	ORG	$10000		first free address using Tutor
                            	    42: *
                            	    43: * Standard jump table. You can change these addresses if you are
                            	    44: * customizing this interpreter for a different environment.
                            	    45: *
00:00004370 6020            	    46: START	BRA	CSTART		Cold Start entry point
00:00004372 60000088        	    47: GOWARM	BRA	WSTART		Warm Start entry point
00:00004376 60001460        	    48: GOOUT	BRA OUTC		Jump to character-out routine
00:0000437A 6000146C        	    49: GOIN	BRA INC		Jump to character-in routine
00:0000437E 60001488        	    50: GOAUXO	BRA	AUXOUT		Jump to auxiliary-out routine
00:00004382 60001498        	    51: GOAUXI	BRA	AUXIN		Jump to auxiliary-in routine
00:00004386 600014B4        	    52: GOBYE	BRA	BYEBYE		Jump to monitor, DOS, etc.
                            	    53: *
                            	    54: * Modifiable system constants:
                            	    55: *
00:0000438A 00041000        	    56: TXTBGN	DC.L	$41000		beginning of program memory
00:0000438E 00047FF0        	    57: ENDMEM	DC.L	$47FF0		end of available memory
                            	    58: *
                            	    59: * The main interpreter starts here:
                            	    60: *
                            	    61: CSTART
00:00004392 2E7AFFFA        	    62: 	MOVE.L ENDMEM,SP	initialize stack pointer
00:00004396 23FC000057F40000	    63: 	move.l #INC1,INPPTR
00:0000439E 58AC
00:000043A0 4239000400A4    	    64: 	move.b #0,InputDevice
00:000043A6 13FC0001000400A8	    65: 	move.b #1,OutputDevice
00:000043AE 23FC000000010004	    66: 	move.l #1,_fpTextIncr
00:000043B6 0094
00:000043B8 4DFA1490        	    67: 	LEA	INITMSG,A6	tell who we are
00:000043BC 61001402        	    68: 	BSR	PRMESG
00:000043C0 23FAFFC8000058FC	    69: 	MOVE.L TXTBGN,TXTUNF	init. end-of-program pointer
00:000043C8 203AFFC4        	    70: 	MOVE.L ENDMEM,D0	get address of end of memory
00:000043CC 23FAFFC0000058B8	    71: 	move.l ENDMEM,STKFP
00:000043D4 90BC00001000    	    72: 	SUB.L	#4096,D0	reserve 4K for the stack
00:000043DA 23C0000058EC    	    73: 	MOVE.L D0,STRSTK
00:000043E0 D0BC00000020    	    74: 	ADD.L #32,D0
00:000043E6 23C000005904    	    75: 	MOVE.L D0,STKLMT
00:000043EC 90BC00000200    	    76: 	SUB.L	#512,D0 	reserve variable area (32 16 byte floats)
00:000043F2 23C000005900    	    77: 	MOVE.L D0,VARBGN
00:000043F8 610000C2        	    78: 	bsr ClearStringArea
                            	    79: WSTART
00:000043FC 7000            	    80: 	CLR.L	D0		initialize internal variables
00:000043FE 23FC000000010004	    81: 	move.l #1,_fpTextIncr
00:00004406 0094
00:00004408 42B9000058E8    	    82: 	clr.l IRQROUT
00:0000440E 23C0000058C4    	    83: 	MOVE.L	D0,LOPVAR
00:00004414 23C0000058BC    	    84: 	MOVE.L	D0,STKGOS
00:0000441A 23C0000058B4    	    85: 	MOVE.L	D0,CURRNT	; current line number pointer = 0
00:00004420 2E7AFF6C        	    86: 	MOVE.L ENDMEM,SP	; init S.P. again, just in case
00:00004424 610000B6        	    87: 	bsr ClearStringStack
00:00004428 4DFA1444        	    88: 	LEA	OKMSG,A6			; display "OK"
00:0000442C 61001392        	    89: 	bsr	PRMESG
                            	    90: ST3
00:00004430 103C003E        	    91: 	MOVE.B	#'>',D0         Prompt with a '>' and
00:00004434 610010CE        	    92: 	bsr	GETLN		read a line.
00:00004438 6100132A        	    93: 	bsr	TOUPBUF 	convert to upper case
00:0000443C 2848            	    94: 	MOVE.L	A0,A4		save pointer to end of line
00:0000443E 41FA14CC        	    95: 	LEA	BUFFER,A0	point to the beginning of line
00:00004442 610012CA        	    96: 	bsr	TSTNUM		is there a number there?
00:00004446 61001312        	    97: 	bsr	IGNBLK		skip trailing blanks
00:0000444A F2016080        	    98: 	FMOVE.L FP1,D1
00:0000444E 4A82            	    99: 	TST.L D2			; does line no. exist? (or nonzero?)
00:00004450 67000246        	   100: 	BEQ	DIRECT		; if not, it's a direct statement
00:00004454 B2BC0000FFFF    	   101: 	CMP.L	#$FFFF,D1	see if line no. is <= 16 bits
00:0000445A 6400109A        	   102: 	BCC	QHOW		if not, we've overflowed
00:0000445E 1101            	   103: 	MOVE.B	D1,-(A0)	store the binary line no.
00:00004460 E059            	   104: 	ROR	#8,D1		(Kludge to store a word on a
00:00004462 1101            	   105: 	MOVE.B	D1,-(A0)	possible byte boundary)
00:00004464 E159            	   106: 	ROL	#8,D1
00:00004466 6100113A        	   107: 	bsr	FNDLN		find this line in save area
00:0000446A 2A49            	   108: 	MOVE.L	A1,A5		save possible line pointer
00:0000446C 6614            	   109: 	BNE	ST4		if not found, insert
00:0000446E 61001158        	   110: 	bsr	FNDNXT		find the next line (into A1)
00:00004472 244D            	   111: 	MOVE.L	A5,A2		pointer to line to be deleted
00:00004474 267A1486        	   112: 	MOVE.L	TXTUNF,A3	points to top of save area
00:00004478 6100115E        	   113: 	bsr	MVUP		move up to delete
00:0000447C 23CA000058FC    	   114: 	MOVE.L	A2,TXTUNF	update the end pointer
                            	   115: ST4
00:00004482 200C            	   116: 	MOVE.L	A4,D0		calculate the length of new line
00:00004484 9088            	   117: 	SUB.L	A0,D0
00:00004486 B0BC00000003    	   118: 	CMP.L	#3,D0		is it just a line no. & CR?
00:0000448C 6FA2            	   119: 	BLE	ST3		if so, it was just a delete
00:0000448E 267A146C        	   120: 	MOVE.L TXTUNF,A3	compute new end
00:00004492 2C4B            	   121: 	MOVE.L A3,A6
00:00004494 D7C0            	   122: 	ADD.L	D0,A3
00:00004496 203A145C        	   123: 	MOVE.L StrArea,D0	see if there's enough room
00:0000449A B08B            	   124: 	CMP.L	A3,D0
00:0000449C 63001050        	   125: 	BLS	QSORRY		if not, say so
00:000044A0 23CB000058FC    	   126: 	MOVE.L	A3,TXTUNF	if so, store new end position
00:000044A6 224E            	   127: 	MOVE.L	A6,A1		points to old unfilled area
00:000044A8 244D            	   128: 	MOVE.L	A5,A2		points to beginning of move area
00:000044AA 61001140        	   129: 	bsr	MVDOWN		move things out of the way
00:000044AE 2248            	   130: 	MOVE.L	A0,A1		set up to do the insertion
00:000044B0 244D            	   131: 	MOVE.L	A5,A2
00:000044B2 264C            	   132: 	MOVE.L	A4,A3
00:000044B4 61001122        	   133: 	bsr	MVUP		do it
00:000044B8 6000FF76        	   134: 	BRA	ST3		go back and get another line
                            	   135: 
                            	   136: ClearStringArea:
00:000044BC 203A1442        	   137: 	move.l VARBGN,d0
00:000044C0 90BC00000800    	   138: 	SUB.L #STRAREASIZE,D0
00:000044C6 23C0000058F4    	   139: 	MOVE.L D0,StrArea
00:000044CC 23C0000058F8    	   140: 	MOVE.L D0,LastStr
00:000044D2 207A1420        	   141: 	move.l StrArea,a0
00:000044D6 4298            	   142: 	clr.l (a0)+
00:000044D8 4298            	   143: 	clr.l (a0)+
00:000044DA 4E75            	   144: 	rts
                            	   145: 
                            	   146: ClearStringStack:
00:000044DC 7007            	   147: 	moveq #7,d0
00:000044DE 227A140C        	   148: 	move.l STRSTK,a1
                            	   149: .0001
00:000044E2 4299            	   150: 	clr.l (a1)+				; clear the string stack
00:000044E4 51C8FFFC        	   151: 	dbra d0,.0001
00:000044E8 23C9000058F0    	   152: 	move.l a1,StrSp		; set string stack stack pointer
00:000044EE 4E75            	   153: 	rts
                            	   154: 
                            	   155: 	even
                            	   156: 
                            	   157: *******************************************************************
                            	   158: *
                            	   159: * *** Tables *** DIRECT *** EXEC ***
                            	   160: *
                            	   161: * This section of the code tests a string against a table. When
                            	   162: * a match is found, control is transferred to the section of
                            	   163: * code according to the table.
                            	   164: *
                            	   165: * At 'EXEC', A0 should point to the string, A1 should point to
                            	   166: * the character table, and A2 should point to the execution
                            	   167: * table. At 'DIRECT', A0 should point to the string, A1 and
                            	   168: * A2 will be set up to point to TAB1 and TAB1_1, which are
                            	   169: * the tables of all direct and statement commands.
                            	   170: *
                            	   171: * A '.' in the string will terminate the test and the partial
                            	   172: * match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                            	   173: * 'PRIN.', or 'PRINT' will all match 'PRINT'.
                            	   174: *
                            	   175: * There are two tables: the character table and the execution
                            	   176: * table. The character table consists of any number of text items.
                            	   177: * Each item is a string of characters with the last character's
                            	   178: * high bit set to one. The execution table holds a 16-bit
                            	   179: * execution addresses that correspond to each entry in the
                            	   180: * character table.
                            	   181: *
                            	   182: * The end of the character table is a 0 byte which corresponds
                            	   183: * to the default routine in the execution table, which is
                            	   184: * executed if none of the other table items are matched.
                            	   185: *
                            	   186: * Character-matching tables:
                            	   187: TAB1
00:000044F0 3C434F          	   188: 	DC.B	'<CO',('M'+$80)
00:000044F3 CD
00:000044F4 3C434F          	   189: 	DC.B	'<CO',('N'+$80)
00:000044F7 CE
00:000044F8 3E434F          	   190: 	DC.B	'>CO',('M'+$80)
00:000044FB CD
00:000044FC 3E434F          	   191: 	DC.B	'>CO',('N'+$80)
00:000044FF CE
00:00004500 3C3E434F        	   192: 	DC.B	'<>CO',('M'+$80)
00:00004504 CD
00:00004505 3C3E434F        	   193: 	DC.B	'<>CO',('N'+$80)
00:00004509 CE
00:0000450A 4C4953          	   194: 	DC.B	'LIS',('T'+$80)         Direct commands
00:0000450D D4
00:0000450E 4C4F41          	   195: 	DC.B	'LOA',('D'+$80)
00:00004511 C4
00:00004512 4E45            	   196: 	DC.B	'NE',('W'+$80)
00:00004514 D7
00:00004515 5255            	   197: 	DC.B	'RU',('N'+$80)
00:00004517 CE
00:00004518 534156          	   198: 	DC.B	'SAV',('E'+$80)
00:0000451B C5
00:0000451C 434C            	   199: 	DC.B 	'CL',('S'+$80)
00:0000451E D3
                            	   200: TAB2
00:0000451F 4E4558          	   201: 	DC.B	'NEX',('T'+$80)         Direct / statement
00:00004522 D4
00:00004523 4C45            	   202: 	DC.B	'LE',('T'+$80)
00:00004525 D4
00:00004526 49              	   203: 	DC.B	'I',('F'+$80)
00:00004527 C6
00:00004528 474F54          	   204: 	DC.B	'GOT',('O'+$80)
00:0000452B CF
00:0000452C 474F5355        	   205: 	DC.B	'GOSU',('B'+$80)
00:00004530 C2
00:00004531 5245545552      	   206: 	DC.B	'RETUR',('N'+$80)
00:00004536 CE
00:00004537 5245            	   207: 	DC.B	'RE',('M'+$80)
00:00004539 CD
00:0000453A 464F            	   208: 	DC.B	'FO',('R'+$80)
00:0000453C D2
00:0000453D 494E5055        	   209: 	DC.B	'INPU',('T'+$80)
00:00004541 D4
00:00004542 5052494E        	   210: 	DC.B	'PRIN',('T'+$80)
00:00004546 D4
00:00004547 504F4B          	   211: 	DC.B	'POK',('E'+$80)
00:0000454A C5
00:0000454B 53544F          	   212: 	DC.B	'STO',('P'+$80)
00:0000454E D0
00:0000454F 4259            	   213: 	DC.B	'BY',('E'+$80)
00:00004551 C5
00:00004552 43414C          	   214: 	DC.B	'CAL',('L'+$80)
00:00004555 CC
00:00004556 4F4E4952        	   215: 	DC.B	'ONIR',('Q'+$80)
00:0000455A D1
00:0000455B 00              	   216: 	DC.B	0
                            	   217: TAB4
00:0000455C 504545          	   218: 	DC.B	'PEE',('K'+$80)         Functions
00:0000455F CB
00:00004560 524E            	   219: 	DC.B	'RN',('D'+$80)
00:00004562 C4
00:00004563 4142            	   220: 	DC.B	'AB',('S'+$80)
00:00004565 D3
00:00004566 53495A          	   221: 	DC.B	'SIZ',('E'+$80)
00:00004569 C5
00:0000456A 544943          	   222: 	DC.B	'TIC',('K'+$80)
00:0000456D CB
00:0000456E 434F52454E      	   223: 	DC.B	'COREN',('O'+$80)
00:00004573 CF
00:00004574 4C454654        	   224: 	DC.B	'LEFT',('$'+$80)
00:00004578 A4
00:00004579 5249474854      	   225: 	DC.B	'RIGHT',('$'+$80)
00:0000457E A4
00:0000457F 4D4944          	   226: 	DC.B	'MID',('$'+$80)
00:00004582 A4
00:00004583 4C45            	   227: 	DC.B	'LE',('N'+$80)
00:00004585 CE
00:00004586 494E            	   228: 	DC.B	'IN',('T'+$80)
00:00004588 D4
00:00004589 434852          	   229: 	DC.B	'CHR',('$'+$80)
00:0000458C A4
00:0000458D 00              	   230: 	DC.B	0
                            	   231: TAB5
00:0000458E 54              	   232: 	DC.B	'T',('O'+$80)           "TO" in "FOR"
00:0000458F CF
00:00004590 00              	   233: 	DC.B	0
                            	   234: TAB6
00:00004591 535445          	   235: 	DC.B	'STE',('P'+$80)         "STEP" in "FOR"
00:00004594 D0
00:00004595 00              	   236: 	DC.B	0
                            	   237: TAB8
00:00004596 3E              	   238: 	DC.B	'>',('='+$80)           Relational operators
00:00004597 BD
00:00004598 3C              	   239: 	DC.B	'<',('>'+$80)
00:00004599 BE
00:0000459A BE              	   240: 	DC.B	('>'+$80)
00:0000459B BD              	   241: 	DC.B	('='+$80)
00:0000459C 3C              	   242: 	DC.B	'<',('='+$80)
00:0000459D BD
00:0000459E BC              	   243: 	DC.B	('<'+$80)
00:0000459F 00              	   244: 	DC.B	0
00:000045A0 00              	   245: 	DC.B	0	<- for aligning on a word boundary
                            	   246: TAB9
00:000045A1 414E            	   247: 	DC.B	'AN',('D'+$80)
00:000045A3 C4
00:000045A4 00              	   248: 	DC.B	0
                            	   249: TAB10
00:000045A5 4F              	   250: 	DC.B	'O',('R'+$80)
00:000045A6 D2
00:000045A7 00              	   251: 	DC.B	0
                            	   252: TAB11
00:000045A8 4D4F            	   253: 	DC.B	'MO',('D'+$80)
00:000045AA C4
00:000045AB 00              	   254: 	DC.B	0
00:000045AC 00              	   255: 	DC.B	0
                            	   256: 
                            	   257: ; Execution address tables:
                            	   258: 	align 2
                            	   259: TAB1_1	
00:000045B0 000046F0        	   260: 	DC.L	INCOM
00:000045B4 000046E2        	   261: 	DC.L	INCON
00:000045B8 00004708        	   262: 	DC.L	OUTCOM
00:000045BC 0000471E        	   263: 	DC.L	OUTCON
00:000045C0 000046FE        	   264: 	DC.L	IOCOM
00:000045C4 00004714        	   265: 	DC.L	IOCON
00:000045C8 00004808        	   266: 	DC.L	LIST			Direct commands
00:000045CC 00004AE6        	   267: 	DC.L	LOAD
00:000045D0 0000472A        	   268: 	DC.L	NEW
00:000045D4 00004746        	   269: 	DC.L	RUN
00:000045D8 00004B46        	   270: 	DC.L	SAVE
00:000045DC 000057CC        	   271: 	DC.L	CLS
                            	   272: TAB2_1
00:000045E0 000049A4        	   273: 	DC.L	NEXT			Direct / statement
00:000045E4 00004AD6        	   274: 	DC.L	LET
00:000045E8 00004A10        	   275: 	DC.L	IF
00:000045EC 000047C0        	   276: 	DC.L	GOTO
00:000045F0 000048BE        	   277: 	DC.L	GOSUB
00:000045F4 000048F8        	   278: 	DC.L	RETURN
00:000045F8 00004A0E        	   279: 	DC.L	REM
00:000045FC 00004924        	   280: 	DC.L	FOR
00:00004600 00004A38        	   281: 	DC.L	INPUT
00:00004604 00004834        	   282: 	DC.L	PRINT
00:00004608 00004BC4        	   283: 	DC.L	POKE
00:0000460C 0000473E        	   284: 	DC.L	STOP
00:00004610 00004386        	   285: 	DC.L	GOBYE
00:00004614 00004C3E        	   286: 	DC.L	CALL
00:00004618 000047D4        	   287: 	DC.L	ONIRQ
00:0000461C 00004ACE        	   288: 	DC.L	DEFLT
                            	   289: TAB4_1
00:00004620 000051EE        	   290: 	DC.L	PEEK			; Functions
00:00004624 00005256        	   291: 	DC.L	RND
00:00004628 00005280        	   292: 	DC.L	ABS
00:0000462C 0000528C        	   293: 	DC.L	SIZE
00:00004630 0000529C        	   294: 	DC.L	TICK
00:00004634 000052A8        	   295: 	DC.L	CORENO
00:00004638 000053BA        	   296: 	DC.L	LEFT
00:0000463C 000053C6        	   297: 	DC.L	RIGHT
00:00004640 000052F0        	   298: 	DC.L	MID
00:00004644 000053EE        	   299: 	DC.L	LEN
00:00004648 00005414        	   300: 	DC.L	INT
00:0000464C 0000542A        	   301: 	DC.L  CHR
00:00004650 00004EF8        	   302: 	DC.L	XP40
                            	   303: TAB5_1
00:00004654 0000493E        	   304: 	DC.L	FR1			; "TO" in "FOR"
00:00004658 000054AE        	   305: 	DC.L	QWHAT
                            	   306: TAB6_1
00:0000465C 00004956        	   307: 	DC.L	FR2			; "STEP" in "FOR"
00:00004660 0000495C        	   308: 	DC.L	FR3
                            	   309: TAB8_1
00:00004664 00004D2E        	   310: 	DC.L	XP11	>=		Relational operators
00:00004668 00004D3A        	   311: 	DC.L	XP12	<>
00:0000466C 00004D46        	   312: 	DC.L	XP13	>
00:00004670 00004D5E        	   313: 	DC.L	XP15	=
00:00004674 00004D52        	   314: 	DC.L	XP14	<=
00:00004678 00004D6C        	   315: 	DC.L	XP16	<
00:0000467C 00004D8A        	   316: 	DC.L	XP17
                            	   317: TAB9_1
00:00004680 00004CEC        	   318: 	DC.L	XP_AND
00:00004684 00004D02        	   319: 	DC.L	XP_ANDX
                            	   320: TAB10_1
00:00004688 00004CC4        	   321: 	DC.L	XP_OR
00:0000468C 00004D02        	   322: 	DC.L	XP_ORX
                            	   323: TAB11_1
00:00004690 00004ECA        	   324: 	DC.L	XP_MOD
00:00004694 00004E94        	   325: 	DC.L	XP31
                            	   326: 	even
                            	   327: 	
                            	   328: DIRECT
00:00004698 33FC000100005908	   329: 	move.w #1,DIRFLG
00:000046A0 43FAFE4E        	   330: 	LEA	TAB1,A1
00:000046A4 45FAFF0A        	   331: 	LEA	TAB1_1,A2
                            	   332: EXEC
00:000046A8 610010B0        	   333: 	bsr	IGNBLK				; ignore leading blanks
00:000046AC 2648            	   334: 	MOVE.L A0,A3			; save the pointer
00:000046AE 4202            	   335: 	CLR.B	D2					; clear match flag
                            	   336: EXLP
00:000046B0 1018            	   337: 	MOVE.B (A0)+,D0	 	; get the program character
00:000046B2 1211            	   338: 	MOVE.B (A1),D1 		; get the table character
00:000046B4 6604            	   339: 	BNE	EXNGO					; If end of table,
00:000046B6 204B            	   340: 	MOVE.L A3,A0			; restore the text pointer and...
00:000046B8 6024            	   341: 	BRA	EXGO					; execute the default.
                            	   342: EXNGO
00:000046BA 1600            	   343: 	MOVE.B D0,D3		 	; Else check for period...
00:000046BC C602            	   344: 	AND.B	D2,D3				; and a match.
00:000046BE B63C002E        	   345: 	CMP.B	#'.',D3
00:000046C2 671A            	   346: 	BEQ	EXGO					; if so, execute
00:000046C4 C23C007F        	   347: 	AND.B	#$7F,D1 		; ignore the table's high bit
00:000046C8 B200            	   348: 	CMP.B	D0,D1				; is there a match?
00:000046CA 670C            	   349: 	BEQ	EXMAT
00:000046CC 588A            	   350: 	ADDQ.L #4,A2			; if not, try the next entry
00:000046CE 204B            	   351: 	MOVE.L A3,A0			; reset the program pointer
00:000046D0 4202            	   352: 	CLR.B	D2					; sorry, no match
                            	   353: EX1
00:000046D2 4A19            	   354: 	TST.B	(A1)+				; get to the end of the entry
00:000046D4 6AFC            	   355: 	BPL	EX1
00:000046D6 60D8            	   356: 	BRA	EXLP					; back for more matching
                            	   357: EXMAT
00:000046D8 74FF            	   358: 	MOVEQ	#-1,D2			; we've got a match so far
00:000046DA 4A19            	   359: 	TST.B	(A1)+				; end of table entry?
00:000046DC 6AD2            	   360: 	BPL	EXLP					; if not, go back for more
                            	   361: EXGO
00:000046DE 2652            	   362: 	MOVE.L (A2),A3		; execute the appropriate routine
00:000046E0 4ED3            	   363: 	JMP	(A3)
                            	   364: 
                            	   365: *******************************************************************
                            	   366: * Console redirection
                            	   367: * <COM will redirect input to the COM port
                            	   368: * >COM will redirect output to the COM port
                            	   369: * <CON will redirect input to the console
                            	   370: * >CON will redirect output to the console
                            	   371: * <>COM will redirect input and output to the COM port
                            	   372: * <>CON will redirect input and output to the console
                            	   373: *******************************************************************
                            	   374: INCON
00:000046E2 23FC000057F40000	   375: 	move.l	#INC1,INPPTR
00:000046EA 58AC
00:000046EC 600001C8        	   376: 	bra			FINISH
                            	   377: INCOM
00:000046F0 23FC0000581C0000	   378: 	move.l	#AUXIN,INPPTR
00:000046F8 58AC
00:000046FA 600001BA        	   379: 	bra			FINISH
                            	   380: IOCOM
00:000046FE 23FC0000581C0000	   381: 	move.l	#AUXIN,INPPTR
00:00004706 58AC
                            	   382: OUTCOM
00:00004708 13FC0002000400A8	   383: 	move.b #2,OutputDevice
00:00004710 600001A4        	   384: 	bra	FINISH
                            	   385: IOCON
00:00004714 23FC000057F40000	   386: 	move.l	#INC1,INPPTR
00:0000471C 58AC
                            	   387: OUTCON
00:0000471E 13FC0001000400A8	   388: 	move.b #1,OutputDevice
00:00004726 6000018E        	   389: 	bra	FINISH
                            	   390: 
                            	   391: *******************************************************************
                            	   392: *
                            	   393: * What follows is the code to execute direct and statement
                            	   394: * commands. Control is transferred to these points via the command
                            	   395: * table lookup code of 'DIRECT' and 'EXEC' in the last section.
                            	   396: * After the command is executed, control is transferred to other
                            	   397: * sections as follows:
                            	   398: *
                            	   399: * For 'LIST', 'NEW', and 'STOP': go back to the warm start point.
                            	   400: * For 'RUN': go execute the first stored line if any; else go
                            	   401: * back to the warm start point.
                            	   402: * For 'GOTO' and 'GOSUB': go execute the target line.
                            	   403: * For 'RETURN' and 'NEXT'; go back to saved return line.
                            	   404: * For all others: if 'CURRNT' is 0, go to warm start; else go
                            	   405: * execute next command. (This is done in 'FINISH'.)
                            	   406: *
                            	   407: *******************************************************************
                            	   408: *
                            	   409: * *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                            	   410: *
                            	   411: * 'NEW<CR>' sets TXTUNF to point to TXTBGN
                            	   412: *
                            	   413: * 'STOP<CR>' goes back to WSTART
                            	   414: *
                            	   415: * 'RUN<CR>' finds the first stored line, stores its address
                            	   416: * in CURRNT, and starts executing it. Note that only those
                            	   417: * commands in TAB2 are legal for a stored program.
                            	   418: *
                            	   419: * There are 3 more entries in 'RUN':
                            	   420: * 'RUNNXL' finds next line, stores it's address and executes it.
                            	   421: * 'RUNTSL' stores the address of this line and executes it.
                            	   422: * 'RUNSML' continues the execution on same line.
                            	   423: *
                            	   424: * 'GOTO expr<CR>' evaluates the expression, finds the target
                            	   425: * line, and jumps to 'RUNTSL' to do it.
                            	   426: *
                            	   427: NEW
00:0000472A 61000D70        	   428: 	bsr	ENDCHK
00:0000472E 23FAFC5A000058FC	   429: 	MOVE.L TXTBGN,TXTUNF	set the end pointer
00:00004736 6100FD84        	   430: 	bsr ClearStringArea
00:0000473A 6100FDA0        	   431: 	bsr ClearStringStack
                            	   432: 
                            	   433: STOP
00:0000473E 61000D5C        	   434: 	bsr	ENDCHK
00:00004742 6000FCB8        	   435: 	BRA	WSTART
                            	   436: 
                            	   437: RUN
00:00004746 427900005908    	   438: 	clr.w DIRFLG
00:0000474C 61000D4E        	   439: 	bsr	ENDCHK
00:00004750 207AFC38        	   440: 	MOVE.L	TXTBGN,A0	set pointer to beginning
00:00004754 23C8000058B4    	   441: 	MOVE.L	A0,CURRNT
                            	   442: 
                            	   443: RUNNXL
00:0000475A 4AB9000058B4    	   444: 	TST.L	CURRNT		; executing a program?
00:00004760 6700FC9A        	   445: 	beq	WSTART			; if not, we've finished a direct stat.
00:00004764 4AB9000058E8    	   446: 	tst.l	IRQROUT		; are we handling IRQ's ?
00:0000476A 672E            	   447: 	beq	RUN1
00:0000476C 4A39000400A0    	   448: 	tst.b IRQFlag		; was there an IRQ ?
00:00004772 6726            	   449: 	beq	RUN1
00:00004774 4239000400A0    	   450: 	clr.b IRQFlag
                            	   451: 
                            	   452: 	; same code as GOSUB	
                            	   453: ;	sub.l #128,sp		; allocate storage for local variables
                            	   454: ;	move.l STKFP,-(sp)
                            	   455: ;	move.l sp,STKFP
00:0000477A 61000EB4        	   456: 	bsr	PUSHA				; save the current 'FOR' parameters
00:0000477E 2F08            	   457: 	MOVE.L A0,-(SP)	; save text pointer
00:00004780 2F3A1132        	   458: 	MOVE.L CURRNT,-(SP)	found it, save old 'CURRNT'...
00:00004784 2F3A1136        	   459: 	MOVE.L STKGOS,-(SP)	and 'STKGOS'
00:00004788 42B9000058C4    	   460: 	CLR.L	LOPVAR		; load new values
00:0000478E 23CF000058BC    	   461: 	MOVE.L SP,STKGOS
                            	   462: 
00:00004794 227A1152        	   463: 	move.l IRQROUT,a1
00:00004798 600C            	   464: 	bra	RUNTSL
                            	   465: RUN1
00:0000479A 7200            	   466: 	CLR.L	D1			; else find the next line number
00:0000479C 2248            	   467: 	MOVE.L A0,A1
00:0000479E 61000E10        	   468: 	bsr	FNDLNP
00:000047A2 6500FC58        	   469: 	BCS	WSTART		; if we've fallen off the end, stop
                            	   470: 
                            	   471: RUNTSL
00:000047A6 23C9000058B4    	   472: 	MOVE.L	A1,CURRNT	set CURRNT to point to the line no.
00:000047AC 2049            	   473: 	MOVE.L	A1,A0		set the text pointer to
00:000047AE 5488            	   474: 	ADDQ.L	#2,A0		the start of the line text
                            	   475: 
                            	   476: RUNSML
00:000047B0 61000FFC        	   477: 	bsr	CHKIO		see if a control-C was pressed
00:000047B4 43FAFD69        	   478: 	LEA	TAB2,A1 	find command in TAB2
00:000047B8 45FAFE26        	   479: 	LEA	TAB2_1,A2
00:000047BC 6000FEEA        	   480: 	BRA	EXEC		and execute it
                            	   481: 
                            	   482: GOTO	
00:000047C0 610004E0        	   483: 	bsr	INT_EXPR	; evaluate the following expression
00:000047C4 61000CD6        	   484: 	bsr	ENDCHK		; must find end of line
00:000047C8 2200            	   485: 	move.l d0,d1
00:000047CA 61000DD6        	   486: 	bsr	FNDLN			; find the target line
00:000047CE 66000D26        	   487: 	bne	QHOW			; no such line no.
00:000047D2 60D2            	   488: 	bra	RUNTSL		; go do it
                            	   489: 
                            	   490: ;******************************************************************
                            	   491: ; ONIRQ <line number>
                            	   492: ; ONIRQ sets up an interrupt handler which acts like a specialized
                            	   493: ; subroutine call. ONIRQ is coded like a GOTO that never executes.
                            	   494: ;******************************************************************
                            	   495: 
                            	   496: ONIRQ:
00:000047D4 610004CC        	   497: 	bsr	INT_EXPR		; evaluate the following expression
00:000047D8 61000CC2        	   498: 	bsr ENDCHK			; must find end of line
00:000047DC 2200            	   499: 	move.l d0,d1
00:000047DE 61000DC2        	   500: 	bsr FNDLN				; find the target line
00:000047E2 660A            	   501: 	bne	ONIRQ1
00:000047E4 42B9000058E8    	   502: 	clr.l IRQROUT
00:000047EA 600000CA        	   503: 	bra	FINISH
                            	   504: ONIRQ1:
00:000047EE 23C9000058E8    	   505: 	move.l a1,IRQROUT
00:000047F4 600000C0        	   506: 	jmp	FINISH
                            	   507: 
                            	   508: 
                            	   509: WAITIRQ:
00:000047F8 61000FB4        	   510: 	jsr	CHKIO				; see if a control-C was pressed
00:000047FC 4A39000400A0    	   511: 	tst.b IRQFlag
00:00004802 67F4            	   512: 	beq	WAITIRQ
00:00004804 600000B0        	   513: 	jmp	FINISH
                            	   514: 
                            	   515: *******************************************************************
                            	   516: *
                            	   517: * *** LIST *** PRINT ***
                            	   518: *
                            	   519: * LIST has two forms:
                            	   520: * 'LIST<CR>' lists all saved lines
                            	   521: * 'LIST #<CR>' starts listing at the line #
                            	   522: * Control-S pauses the listing, control-C stops it.
                            	   523: *
                            	   524: * PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                            	   525: * where '....' is a list of expressions, formats, back-arrows,
                            	   526: * and strings.	These items a separated by commas.
                            	   527: *
                            	   528: * A format is a pound sign followed by a number.  It controls
                            	   529: * the number of spaces the value of an expression is going to
                            	   530: * be printed in.  It stays effective for the rest of the print
                            	   531: * command unless changed by another format.  If no format is
                            	   532: * specified, 11 positions will be used.
                            	   533: *
                            	   534: * A string is quoted in a pair of single- or double-quotes.
                            	   535: *
                            	   536: * An underline (back-arrow) means generate a <CR> without a <LF>
                            	   537: *
                            	   538: * A <CR LF> is generated after the entire list has been printed
                            	   539: * or if the list is empty.  If the list ends with a semicolon,
                            	   540: * however, no <CR LF> is generated.
                            	   541: *
                            	   542: 
                            	   543: LIST	
00:00004808 61000F04        	   544: 	bsr	TSTNUM		see if there's a line no.
00:0000480C 61000C8E        	   545: 	bsr	ENDCHK		if not, we get a zero
00:00004810 61000D90        	   546: 	bsr	FNDLN		find this or next line
                            	   547: LS1
00:00004814 650000A0        	   548: 	BCS	FINISH		warm start if we passed the end
00:00004818 61000EBE        	   549: 	bsr	PRTLN		print the line
00:0000481C 61000F90        	   550: 	bsr	CHKIO		check for listing halt request
00:00004820 670C            	   551: 	BEQ	LS3
00:00004822 B03C0013        	   552: 	CMP.B	#CTRLS,D0	pause the listing?
00:00004826 6606            	   553: 	BNE	LS3
                            	   554: LS2
00:00004828 61000F84        	   555: 	bsr	CHKIO		if so, wait for another keypress
00:0000482C 67FA            	   556: 	BEQ	LS2
                            	   557: LS3
00:0000482E 61000D80        	   558: 	bsr	FNDLNP		find the next line
00:00004832 60E0            	   559: 	BRA	LS1
                            	   560: 
                            	   561: PRINT	
00:00004834 780B            	   562: 	MOVE.L #11,D4		D4 = number of print spaces
00:00004836 61000EBE        	   563: 	bsr	TSTC		if null list and ":"
00:0000483A 3A              	   564: 	DC.B	':',PR2-*
00:0000483B 09
00:0000483C 610011C8        	   565: 	bsr	CRLF		give CR-LF and continue
00:00004840 6000FF6E        	   566: 	BRA	RUNSML		execution on the same line
                            	   567: PR2	
00:00004844 61000EB0        	   568: 	bsr	TSTC		if null list and <CR>
00:00004848 0D              	   569: 	DC.B	CR,PR0-*
00:00004849 09
00:0000484A 610011BA        	   570: 	bsr	CRLF		also give CR-LF and
00:0000484E 6000FF0A        	   571: 	BRA	RUNNXL		execute the next line
                            	   572: PR0
00:00004852 61000EA2        	   573: 	bsr	TSTC				; else is it a format?
00:00004856 23              	   574: 	dc.b '#',PR1-*
00:00004857 09
00:00004858 61000448        	   575: 	bsr	INT_EXPR		; yes, evaluate expression
00:0000485C 2800            	   576: 	move.l d0,d4		; and save it as print width
00:0000485E 600E            	   577: 	bra	PR3					; look for more to print
                            	   578: PR1
00:00004860 61000E94        	   579: 	bsr	TSTC				; is character expression? (MRL)
00:00004864 24              	   580: 	dc.b '$',PR8-*
00:00004865 1B
00:00004866 6100043A        	   581: 	bsr	INT_EXPR		; yep. Evaluate expression (MRL)
00:0000486A 6100FB0A        	   582: 	bsr	GOOUT				; print low byte (MRL)
                            	   583: 	bra	PR3					; look for more. (MRL)
                            	   584: PR3
00:0000486E 61000E86        	   585: 	bsr	TSTC						; if ",", go find next
00:00004872 2C              	   586: 	dc.b ',',PR6-*
00:00004873 07
00:00004874 61000C0C        	   587: 	bsr	FIN							; in the list.
00:00004878 60D8            	   588: 	BRA	PR0
                            	   589: PR6
00:0000487A 6100118A        	   590: 	bsr	CRLF						; list ends here
00:0000487E 6036            	   591: 	BRA	FINISH
                            	   592: PR8
00:00004880 2F04            	   593: 	move.l d4,-(SP)			; save the width value
00:00004882 61000430        	   594: 	bsr	EXPR						; evaluate the expression
00:00004886 281F            	   595: 	move.l (sp)+,d4			; restore the width
00:00004888 0C8000000002    	   596: 	cmpi.l #DT_STRING,d0	; is it a string?
00:0000488E 670C            	   597: 	beq PR9
00:00004890 F2000080        	   598: 	fmove fp0,fp1
00:00004894 7823            	   599: 	move.l #35,d4
00:00004896 61000DF6        	   600: 	bsr	PRTNUM					; print its value
00:0000489A 60D2            	   601: 	bra	PR3							; more to print?
                            	   602: 	; Print a string
                            	   603: PR9
00:0000489C F239680000040600	   604: 	fmove.x fp0,_fpWork
00:000048A4 323900040600    	   605: 	move.w _fpWork,d1
00:000048AA 227900040604    	   606: 	move.l _fpWork+4,a1
00:000048B0 61000DD6        	   607: 	bsr PRTSTR2
00:000048B4 60B8            	   608: 	bra PR3
                            	   609: 
                            	   610: FINISH
00:000048B6 61000BCA        	   611: 	bsr	FIN			; Check end of command
00:000048BA 60000BF2        	   612: 	BRA	QWHAT		; print "What?" if wrong
                            	   613: 
                            	   614: ;******************************************************************
                            	   615: ;
                            	   616: ; *** GOSUB *** & RETURN ***
                            	   617: ;
                            	   618: ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                            	   619: ; except that the current text pointer, stack pointer, etc. are
                            	   620: ; saved so that execution can be continued after the subroutine
                            	   621: ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                            	   622: ; recursive), the save area must be stacked.  The stack pointer
                            	   623: ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                            	   624: ; If we are in the main routine, 'STKGOS' is zero (this was done
                            	   625: ; in the initialization section of the interpreter), but we still
                            	   626: ; save it as a flag for no further 'RETURN's.
                            	   627: ;
                            	   628: ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                            	   629: ; returns the execution to the command after the most recent
                            	   630: ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                            	   631: ; a 'GOSUB' and is thus an error.
                            	   632: 
                            	   633: GOSUB:
00:000048BE 4FEFFF80        	   634: 	sub.l #128,sp		; allocate storage for local variables
00:000048C2 2F3A0FF4        	   635: 	move.l STKFP,-(sp)
00:000048C6 23CF000058B8    	   636: 	move.l sp,STKFP
00:000048CC 61000D62        	   637: 	bsr	PUSHA				; save the current 'FOR' parameters
00:000048D0 610003D0        	   638: 	bsr	INT_EXPR		; get line number
00:000048D4 2F08            	   639: 	MOVE.L	A0,-(SP)	save text pointer
00:000048D6 2200            	   640: 	move.l	d0,d1
00:000048D8 61000CC8        	   641: 	bsr	FNDLN		find the target line
00:000048DC 66000C1A        	   642: 	BNE	AHOW		if not there, say "How?"
00:000048E0 2F3A0FD2        	   643: 	MOVE.L	CURRNT,-(SP)	found it, save old 'CURRNT'...
00:000048E4 2F3A0FD6        	   644: 	MOVE.L	STKGOS,-(SP)	and 'STKGOS'
00:000048E8 42B9000058C4    	   645: 	CLR.L	LOPVAR		load new values
00:000048EE 23CF000058BC    	   646: 	MOVE.L	SP,STKGOS
00:000048F4 6000FEB0        	   647: 	BRA	RUNTSL
                            	   648: 
                            	   649: RETURN:
00:000048F8 61000BA2        	   650: 	bsr	ENDCHK					; there should be just a <CR>
00:000048FC 223A0FBE        	   651: 	MOVE.L	STKGOS,D1		; get old stack pointer
00:00004900 67000BAC        	   652: 	BEQ	QWHAT						; if zero, it doesn't exist
00:00004904 2E41            	   653: 	MOVE.L	D1,SP				; else restore it
00:00004906 23DF000058BC    	   654: 	MOVE.L	(SP)+,STKGOS	; and the old 'STKGOS'
00:0000490C 23DF000058B4    	   655: 	MOVE.L	(SP)+,CURRNT	; and the old 'CURRNT'
00:00004912 205F            	   656: 	MOVE.L	(SP)+,A0		; and the old text pointer
00:00004914 61000CDE        	   657: 	bsr	POPA						; and the old 'FOR' parameters
                            	   658: ;	move.l STKFP,sp
00:00004918 23DF000058B8    	   659: 	move.l (sp)+,STKFP
00:0000491E 4FEF0080        	   660: 	add.l #128,sp				; remove local variable storage
00:00004922 6092            	   661: 	BRA	FINISH					; and we are back home
                            	   662: 
                            	   663: *******************************************************************
                            	   664: *
                            	   665: * *** FOR *** & NEXT ***
                            	   666: *
                            	   667: * 'FOR' has two forms:
                            	   668: * 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                            	   669: * The second form means the same thing as the first form with a
                            	   670: * STEP of positive 1.  The interpreter will find the variable 'var'
                            	   671: * and set its value to the current value of 'exp1'.  It also
                            	   672: * evaluates 'exp2' and 'exp1' and saves all these together with
                            	   673: * the text pointer, etc. in the 'FOR' save area, which consisits of
                            	   674: * 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                            	   675: * already something in the save area (indicated by a non-zero
                            	   676: * 'LOPVAR'), then the old save area is saved on the stack before
                            	   677: * the new values are stored.  The interpreter will then dig in the
                            	   678: * stack and find out if this same variable was used in another
                            	   679: * currently active 'FOR' loop.  If that is the case, then the old
                            	   680: * 'FOR' loop is deactivated. (i.e. purged from the stack)
                            	   681: *
                            	   682: * 'NEXT var' serves as the logical (not necessarily physical) end
                            	   683: * of the 'FOR' loop.  The control variable 'var' is checked with
                            	   684: * the 'LOPVAR'.  If they are not the same, the interpreter digs in
                            	   685: * the stack to find the right one and purges all those that didn't
                            	   686: * match.  Either way, it then adds the 'STEP' to that variable and
                            	   687: * checks the result with against the limit value.  If it is within
                            	   688: * the limit, control loops back to the command following the
                            	   689: * 'FOR'.  If it's outside the limit, the save area is purged and
                            	   690: * execution continues.
                            	   691: 
                            	   692: FOR
00:00004924 61000D0A        	   693: 	bsr	PUSHA			; save the old 'FOR' save area
00:00004928 61000B38        	   694: 	bsr	SETVAL		; set the control variable
00:0000492C 23CE000058C4    	   695: 	move.l a6,LOPVAR		; save its address
00:00004932 43FAFC5A        	   696: 	LEA	TAB5,A1 	; use 'EXEC' to test for 'TO'
00:00004936 45FAFD1C        	   697: 	LEA	TAB5_1,A2
00:0000493A 6000FD6C        	   698: 	BRA	EXEC
                            	   699: FR1	
00:0000493E 61000354        	   700: 	bsr	NUM_EXPR		; evaluate the limit
00:00004942 F2396800000058D4	   701: 	FMOVE.X	FP0,LOPLMT	; save that
00:0000494A 43FAFC45        	   702: 	LEA	TAB6,A1 		; use 'EXEC' to look for the
00:0000494E 45FAFD0C        	   703: 	LEA	TAB6_1,A2		; word 'STEP'
00:00004952 6000FD54        	   704: 	BRA	EXEC
                            	   705: FR2
00:00004956 6100033C        	   706: 	bsr	NUM_EXPR		found it, get the step value
00:0000495A 6006            	   707: 	BRA	FR4
                            	   708: FR3
00:0000495C F23C58000001    	   709: 	FMOVE.B #1,FP0	; not found, step defaults to 1
                            	   710: FR4
00:00004962 F2396800000058C8	   711: 	FMOVE.X	FP0,LOPINC	save that too
                            	   712: FR5	
00:0000496A 23FA0F48000058E0	   713: 	MOVE.L	CURRNT,LOPLN	save address of current line number
00:00004972 23C8000058E4    	   714: 	MOVE.L	A0,LOPPT	and text pointer
00:00004978 2C4F            	   715: 	MOVE.L	SP,A6		dig into the stack to find 'LOPVAR'
00:0000497A 600C            	   716: 	BRA	FR7
                            	   717: FR6
00:0000497C 4DEE0024        	   718: 	lea 36(a6),a6			; look at next stack frame
00:00004980 BDFAFA0C        	   719: 	cmp.l ENDMEM,a6		; safety check
00:00004984 64000B28        	   720: 	bhs QWHAT
                            	   721: FR7
00:00004988 2016            	   722: 	MOVE.L	(A6),D0 	; is it zero?
00:0000498A 6714            	   723: 	BEQ	FR8						; if so, we're done
00:0000498C B0BA0F36        	   724: 	CMP.L	LOPVAR,D0		; same as current LOPVAR?
00:00004990 66EA            	   725: 	BNE	FR6						; nope, look some more
00:00004992 244F            	   726: 	MOVE.L	SP,A2			; Else remove 9 long words from...
00:00004994 224E            	   727: 	MOVE.L	A6,A1			; inside the stack.
00:00004996 47E90024        	   728: 	lea	36(a1),a3
00:0000499A 61000C50        	   729: 	bsr	MVDOWN
00:0000499E 2E4B            	   730: 	MOVE.L	A3,SP		set the SP 9 long words up
                            	   731: FR8
00:000049A0 6000FF14        	   732: 	BRA	FINISH		and continue execution
                            	   733: 
                            	   734: NEXT	
00:000049A4 6100078A        	   735: 	bsr	TSTV						; get address of variable
00:000049A8 65000B04        	   736: 	bcs	QWHAT						; if no variable, say "What?"
00:000049AC 2240            	   737: 	move.l d0,a1				; save variable's address
                            	   738: NX0
00:000049AE 203A0F14        	   739: 	move.l LOPVAR,D0		; If 'LOPVAR' is zero, we never...
00:000049B2 67000AFA        	   740: 	beq	QWHAT						; had a FOR loop, so say "What?"
00:000049B6 B3C0            	   741: 	cmp.l	d0,a1					; else we check them
00:000049B8 6706            	   742: 	beq	NX3							; OK, they agree
00:000049BA 61000C38        	   743: 	bsr	POPA						; nope, let's see the next frame
00:000049BE 60EE            	   744: 	bra	NX0
                            	   745: NX3	
00:000049C0 F22948000004    	   746: 	fmove.x	4(a1),fp0		; get control variable's value
00:000049C6 F23A48220EFE    	   747: 	fadd.x LOPINC,fp0		; add in loop increment
                            	   748: ;	BVS	QHOW		say "How?" for 32-bit overflow
00:000049CC F22968000004    	   749: 	fmove.x	fp0,4(a1)		; save control variable's new value
00:000049D2 F23A48800EFE    	   750: 	fmove.x	LOPLMT,fp1	; get loop's limit value
00:000049D8 F23A503A0EEC    	   751: 	ftst LOPINC
00:000049DE F293000E        	   752: 	FBGE NX1				; branch if loop increment is positive
00:000049E2 F2276800        	   753: 	FMOVE.X FP0,-(a7)	; exchange FP0,FP1
00:000049E6 F2000400        	   754: 	FMOVE.X FP1,FP0
00:000049EA F21F4880        	   755: 	FMOVE.X (a7)+,FP1
                            	   756: NX1	
00:000049EE F20000B8        	   757: 	FCMP FP0,FP1		;	test against limit
00:000049F2 F2940012        	   758: 	FBLT NX2				; branch if outside limit
00:000049F6 23FA0EE8000058B4	   759: 	MOVE.L LOPLN,CURRNT	Within limit, go back to the...
00:000049FE 207A0EE4        	   760: 	MOVE.L LOPPT,A0	saved 'CURRNT' and text pointer.
00:00004A02 6000FEB2        	   761: 	BRA	FINISH
                            	   762: NX2
00:00004A06 61000BEC        	   763: 	bsr	POPA		purge this loop
00:00004A0A 6000FEAA        	   764: 	BRA	FINISH
                            	   765: 
                            	   766: *******************************************************************
                            	   767: *
                            	   768: * *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                            	   769: *
                            	   770: * 'REM' can be followed by anything and is ignored by the
                            	   771: * interpreter.
                            	   772: *
                            	   773: * 'IF' is followed by an expression, as a condition and one or
                            	   774: * more commands (including other 'IF's) separated by colons.
                            	   775: * Note that the word 'THEN' is not used.  The interpreter evaluates
                            	   776: * the expression.  If it is non-zero, execution continues.  If it
                            	   777: * is zero, the commands that follow are ignored and execution
                            	   778: * continues on the next line.
                            	   779: *
                            	   780: * 'INPUT' is like the 'PRINT' command, and is followed by a list
                            	   781: * of items.  If the item is a string in single or double quotes,
                            	   782: * or is an underline (back arrow), it has the same effect as in
                            	   783: * 'PRINT'.  If an item is a variable, this variable name is
                            	   784: * printed out followed by a colon, then the interpreter waits for
                            	   785: * an expression to be typed in.  The variable is then set to the
                            	   786: * value of this expression.  If the variable is preceeded by a
                            	   787: * string (again in single or double quotes), the string will be
                            	   788: * displayed followed by a colon.  The interpreter the waits for an
                            	   789: * expression to be entered and sets the variable equal to the
                            	   790: * expression's value.  If the input expression is invalid, the
                            	   791: * interpreter will print "What?", "How?", or "Sorry" and reprint
                            	   792: * the prompt and redo the input.  The execution will not terminate
                            	   793: * unless you press control-C.  This is handled in 'INPERR'.
                            	   794: *
                            	   795: * 'LET' is followed by a list of items separated by commas.
                            	   796: * Each item consists of a variable, an equals sign, and an
                            	   797: * expression.  The interpreter evaluates the expression and sets
                            	   798: * the variable to that value.  The interpreter will also handle
                            	   799: * 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                            	   800: 
                            	   801: REM
00:00004A0E 600A            	   802: 	BRA	IF2		skip the rest of the line
                            	   803: 
                            	   804: IF
00:00004A10 61000290        	   805: 	bsr	INT_EXPR		evaluate the expression
                            	   806: IF1
00:00004A14 4A80            	   807: 	TST.L	d0		is it zero?
00:00004A16 6600FD98        	   808: 	BNE	RUNSML		if not, continue
                            	   809: IF2
00:00004A1A 2248            	   810: 	MOVE.L	A0,A1
00:00004A1C 7200            	   811: 	CLR.L	D1
00:00004A1E 61000BAA        	   812: 	bsr	FNDSKP		if so, skip the rest of the line
00:00004A22 6400FD82        	   813: 	BCC	RUNTSL		and run the next line
00:00004A26 6000F9D4        	   814: 	BRA	WSTART		if no next line, do a warm start
                            	   815: 
00:00004A2A 2E7A0E94        	   816: INPERR	MOVE.L	STKINP,SP	restore the old stack pointer
00:00004A2E 23DF000058B4    	   817: 	MOVE.L	(SP)+,CURRNT	and old 'CURRNT'
00:00004A34 588F            	   818: 	ADDQ.L	#4,SP
00:00004A36 205F            	   819: 	MOVE.L	(SP)+,A0	and old text pointer
                            	   820: 
                            	   821: INPUT	
00:00004A38 2F08            	   822: 	MOVE.L	A0,-(SP)	save in case of error
00:00004A3A 61000278        	   823: 	bsr EXPR
00:00004A3E 0C000002        	   824: 	cmpi.b #DT_STRING,d0
00:00004A42 6622            	   825: 	bne IP6
00:00004A44 F239680000040600	   826: 	fmove.x fp0,_fpWork
00:00004A4C 323900040600    	   827: 	move.w _fpWork,d1
00:00004A52 227900040604    	   828: 	move.l _fpWork+4,a1
00:00004A58 61000C2E        	   829: 	bsr PRTSTR2
                            	   830: ;	bsr	QTSTG		is next item a string?
                            	   831: ;	BRA.S	IP2		nope
                            	   832: IP7
00:00004A5C 610006D2        	   833: 	bsr	TSTV		yes, but is it followed by a variable?
00:00004A60 655C            	   834: 	BCS	IP4		if not, branch
00:00004A62 2440            	   835: 	MOVE.L	D0,A2		put away the variable's address
00:00004A64 601E            	   836: 	BRA	IP3		if so, input to variable
                            	   837: IP6
00:00004A66 2057            	   838: 	move.l (sp),a0	; restore text pointer
00:00004A68 60F2            	   839: 	bra IP7
                            	   840: IP2
00:00004A6A 2F08            	   841: 	MOVE.L	A0,-(SP)	save for 'PRTSTG'
00:00004A6C 610006C2        	   842: 	bsr	TSTV		must be a variable now
00:00004A70 65000A3C        	   843: 	BCS	QWHAT		"What?" it isn't?
00:00004A74 2440            	   844: 	MOVE.L	D0,A2		put away the variable's address
00:00004A76 1410            	   845: 	MOVE.B	(A0),D2 	get ready for 'PRTSTG'
00:00004A78 4200            	   846: 	CLR.B	D0
00:00004A7A 1080            	   847: 	MOVE.B	D0,(A0)
00:00004A7C 225F            	   848: 	MOVE.L	(SP)+,A1
00:00004A7E 61000BE6        	   849: 	bsr	PRTSTG		print string as prompt
00:00004A82 1082            	   850: 	MOVE.B	D2,(A0) 	restore text
                            	   851: IP3
00:00004A84 2F08            	   852: 	MOVE.L	A0,-(SP)	save in case of error
00:00004A86 2F3A0E2C        	   853: 	MOVE.L	CURRNT,-(SP)	also save 'CURRNT'
00:00004A8A 23FCFFFFFFFF0000	   854: 	MOVE.L	#-1,CURRNT	flag that we are in INPUT
00:00004A92 58B4
00:00004A94 23CF000058C0    	   855: 	MOVE.L	SP,STKINP	save the stack pointer too
00:00004A9A 2F0A            	   856: 	MOVE.L	A2,-(SP)	save the variable address
00:00004A9C 103C003A        	   857: 	MOVE.B	#':',D0         print a colon first
00:00004AA0 61000A62        	   858: 	bsr	GETLN		then get an input line
00:00004AA4 41FA0E66        	   859: 	LEA	BUFFER,A0	point to the buffer
00:00004AA8 6100020A        	   860: 	bsr	EXPR		evaluate the input
00:00004AAC 245F            	   861: 	MOVE.L	(SP)+,A2	restore the variable address
00:00004AAE 2480            	   862: 	move.l d0,(a2)			; save data type
00:00004AB0 F22A68000004    	   863: 	FMOVE.X	FP0,4(A2) 	; save value in variable
00:00004AB6 23DF000058B4    	   864: 	MOVE.L	(SP)+,CURRNT	restore old 'CURRNT'
00:00004ABC 205F            	   865: 	MOVE.L	(SP)+,A0	and the old text pointer
                            	   866: IP4
00:00004ABE 588F            	   867: 	ADDQ.L	#4,SP		clean up the stack
00:00004AC0 61000C34        	   868: 	bsr	TSTC		is the next thing a comma?
00:00004AC4 2C              	   869: 	DC.B	',',IP5-*
00:00004AC5 05
00:00004AC6 6000FF70        	   870: 	BRA	INPUT		yes, more items
                            	   871: IP5
00:00004ACA 6000FDEA        	   872: 	BRA	FINISH
                            	   873: 
                            	   874: DEFLT
00:00004ACE 0C10000D        	   875: 	CMP.B	#CR,(A0)	; empty line is OK
00:00004AD2 6700FDE2        	   876: 	BEQ	FINISH			; else it is 'LET'
                            	   877: 
                            	   878: LET
00:00004AD6 6100098A        	   879: 	bsr	SETVAL		 	; do the assignment
00:00004ADA 61000C1A        	   880: 	bsr	TSTC				; check for more 'LET' items
00:00004ADE 2C              	   881: 	DC.B	',',LT1-*
00:00004ADF 03
00:00004AE0 60F4            	   882: 	BRA	LET
                            	   883: LT1
00:00004AE2 6000FDD2        	   884: 	BRA	FINISH			; until we are finished.
                            	   885: 
                            	   886: 
                            	   887: *******************************************************************
                            	   888: *
                            	   889: * *** LOAD *** & SAVE ***
                            	   890: *
                            	   891: * These two commands transfer a program to/from an auxiliary
                            	   892: * device such as a cassette, another computer, etc.  The program
                            	   893: * is converted to an easily-stored format: each line starts with
                            	   894: * a colon, the line no. as 4 hex digits, and the rest of the line.
                            	   895: * At the end, a line starting with an '@' sign is sent.  This
                            	   896: * format can be read back with a minimum of processing time by
                            	   897: * the 68000.
                            	   898: *
                            	   899: LOAD	
00:00004AE6 207AF8A2        	   900: 	MOVE.L TXTBGN,A0	set pointer to start of prog. area
00:00004AEA 103C000D        	   901: 	MOVE.B #CR,D0		For a CP/M host, tell it we're ready...
00:00004AEE 6100F88E        	   902: 	BSR	GOAUXO		by sending a CR to finish PIP command.
                            	   903: LOD1	
00:00004AF2 6100F88E        	   904: 	BSR	GOAUXI		look for start of line
00:00004AF6 67FA            	   905: 	BEQ	LOD1
00:00004AF8 B03C0040        	   906: 	CMP.B	#'@',D0         end of program?
00:00004AFC 671E            	   907: 	BEQ	LODEND
00:00004AFE B03C003A        	   908: 	CMP.B	#':',D0         if not, is it start of line?
00:00004B02 66EE            	   909: 	BNE	LOD1		if not, wait for it
00:00004B04 6120            	   910: 	BSR	GBYTE		get first byte of line no.
00:00004B06 10C1            	   911: 	MOVE.B	D1,(A0)+	store it
00:00004B08 611C            	   912: 	BSR	GBYTE		get 2nd bye of line no.
00:00004B0A 10C1            	   913: 	MOVE.B	D1,(A0)+	store that, too
                            	   914: LOD2
00:00004B0C 6100F874        	   915: 	BSR	GOAUXI		get another text char.
00:00004B10 67FA            	   916: 	BEQ	LOD2
00:00004B12 10C0            	   917: 	MOVE.B	D0,(A0)+	store it
00:00004B14 B03C000D        	   918: 	CMP.B	#CR,D0		is it the end of the line?
00:00004B18 66F2            	   919: 	BNE	LOD2		if not, go back for more
00:00004B1A 60D6            	   920: 	BRA	LOD1		if so, start a new line
                            	   921: LODEND
00:00004B1C 23C8000058FC    	   922: 	MOVE.L	A0,TXTUNF	set end-of program pointer
00:00004B22 6000F8D8        	   923: 	BRA	WSTART		back to direct mode
                            	   924: 
                            	   925: GBYTE
00:00004B26 7401            	   926: 	MOVEQ	#1,D2		get two hex characters from auxiliary
00:00004B28 7200            	   927: 	CLR.L	D1		and store them as a byte in D1
                            	   928: GBYTE1	
00:00004B2A 6100F856        	   929: 	BSR	GOAUXI		get a char.
00:00004B2E 67FA            	   930: 	BEQ	GBYTE1
00:00004B30 B03C0041        	   931: 	CMP.B	#'A',D0
00:00004B34 6502            	   932: 	BCS	GBYTE2
00:00004B36 5F00            	   933: 	SUBQ.B	#7,D0		if greater than 9, adjust
                            	   934: GBYTE2
00:00004B38 C03C000F        	   935: 	AND.B	#$F,D0		strip ASCII
00:00004B3C E909            	   936: 	LSL.B	#4,D1		put nybble into the result
00:00004B3E 8200            	   937: 	OR.B	D0,D1
00:00004B40 51CAFFE8        	   938: 	DBRA	D2,GBYTE1	get another char.
00:00004B44 4E75            	   939: 	RTS
                            	   940: 
                            	   941: SAVE
00:00004B46 207AF842        	   942: 	MOVE.L	TXTBGN,A0	set pointer to start of prog. area
00:00004B4A 227A0DB0        	   943: 	MOVE.L	TXTUNF,A1	set pointer to end of prog. area
                            	   944: SAVE1	
00:00004B4E 103C000D        	   945: 	MOVE.B	#CR,D0		send out a CR & LF (CP/M likes this)
00:00004B52 6100F82A        	   946: 	BSR	GOAUXO
00:00004B56 103C000A        	   947: 	MOVE.B	#LF,D0
00:00004B5A 6100F822        	   948: 	BSR	GOAUXO
00:00004B5E B3C8            	   949: 	CMP.L	A0,A1		are we finished?
00:00004B60 631E            	   950: 	BLS	SAVEND
00:00004B62 103C003A        	   951: 	MOVE.B	#':',D0         if not, start a line
00:00004B66 6100F816        	   952: 	BSR	GOAUXO
00:00004B6A 1218            	   953: 	MOVE.B	(A0)+,D1	send first half of line no.
00:00004B6C 6136            	   954: 	BSR	PBYTE
00:00004B6E 1218            	   955: 	MOVE.B	(A0)+,D1	and send 2nd half
00:00004B70 6132            	   956: 	BSR	PBYTE
                            	   957: SAVE2
00:00004B72 1018            	   958: 	MOVE.B	(A0)+,D0	get a text char.
00:00004B74 B03C000D        	   959: 	CMP.B	#CR,D0		is it the end of the line?
00:00004B78 67D4            	   960: 	BEQ	SAVE1		if so, send CR & LF and start new line
00:00004B7A 6100F802        	   961: 	BSR	GOAUXO		send it out
00:00004B7E 60F2            	   962: 	BRA	SAVE2		go back for more text
                            	   963: SAVEND
00:00004B80 103C0040        	   964: 	MOVE.B	#'@',D0         send end-of-program indicator
00:00004B84 6100F7F8        	   965: 	BSR	GOAUXO
00:00004B88 103C000D        	   966: 	MOVE.B	#CR,D0		followed by a CR & LF
00:00004B8C 6100F7F0        	   967: 	BSR	GOAUXO
00:00004B90 103C000A        	   968: 	MOVE.B	#LF,D0
00:00004B94 6100F7E8        	   969: 	BSR	GOAUXO
00:00004B98 103C001A        	   970: 	MOVE.B	#$1A,D0 	and a control-Z to end the CP/M file
00:00004B9C 6100F7E0        	   971: 	BSR	GOAUXO
00:00004BA0 6000F85A        	   972: 	BRA	WSTART		then go do a warm start
                            	   973: 
00:00004BA4 7401            	   974: PBYTE	MOVEQ	#1,D2		send two hex characters from D1's low byte
00:00004BA6 E919            	   975: PBYTE1	ROL.B	#4,D1		get the next nybble
00:00004BA8 1001            	   976: 	MOVE.B	D1,D0
00:00004BAA C03C000F        	   977: 	AND.B	#$F,D0		strip off garbage
00:00004BAE D03C0030        	   978: 	ADD.B	#'0',D0         make it into ASCII
00:00004BB2 B03C0039        	   979: 	CMP.B	#'9',D0
00:00004BB6 6302            	   980: 	BLS	PBYTE2
00:00004BB8 5E00            	   981: 	ADDQ.B	#7,D0		adjust if greater than 9
00:00004BBA 6100F7C2        	   982: PBYTE2	BSR	GOAUXO		send it out
00:00004BBE 51CAFFE6        	   983: 	DBRA	D2,PBYTE1	then send the next nybble
00:00004BC2 4E75            	   984: 	RTS
                            	   985: 
                            	   986: *******************************************************************
                            	   987: *
                            	   988: * *** POKE *** & CALL ***
                            	   989: *
                            	   990: * 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                            	   991: * address specified by 'expr1'.
                            	   992: *
                            	   993: * 'CALL expr' jumps to the machine language subroutine whose
                            	   994: * starting address is specified by 'expr'.  The subroutine can use
                            	   995: * all registers but must leave the stack the way it found it.
                            	   996: * The subroutine returns to the interpreter by executing an RTS.
                            	   997: *
                            	   998: POKE
00:00004BC4 1E3C0042        	   999: 	move.b #'B',d7
00:00004BC8 1210            	  1000: 	move.b (a0),d1
00:00004BCA 0C01002E        	  1001: 	cmpi.b #'.',d1
00:00004BCE 6620            	  1002: 	bne .0001
00:00004BD0 5248            	  1003: 	addq #1,a0
00:00004BD2 1210            	  1004: 	move.b (a0),d1
00:00004BD4 0C010042        	  1005: 	cmpi.b #'B',d1
00:00004BD8 6712            	  1006: 	beq .0002
00:00004BDA 0C010057        	  1007: 	cmpi.b #'W',d1
00:00004BDE 670C            	  1008: 	beq .0002
00:00004BE0 0C01004C        	  1009: 	cmpi.b #'L',d1
00:00004BE4 6706            	  1010: 	beq .0002
00:00004BE6 0C010046        	  1011: 	cmpi.b #'F',d1
00:00004BEA 664E            	  1012: 	bne	PKER
                            	  1013: .0002
00:00004BEC 5248            	  1014: 	addq #1,a0
00:00004BEE 1E01            	  1015: 	move.b d1,d7
                            	  1016: .0001
00:00004BF0 610000B0        	  1017: 	BSR	INT_EXPR		get the memory address
00:00004BF4 61000B00        	  1018: 	bsr	TSTC		it must be followed by a comma
00:00004BF8 2C              	  1019: 	DC.B	',',PKER-*
00:00004BF9 41
00:00004BFA 2F00            	  1020: 	move.l d0,-(sp)		; save the address
00:00004BFC 61000096        	  1021: 	BSR	NUM_EXPR			; get the value to be POKE'd
00:00004C00 225F            	  1022: 	move.l	(sp)+,a1	; get the address back
00:00004C02 0C070042        	  1023: 	CMPI.B #'B',D7
00:00004C06 6608            	  1024: 	BNE .0003
00:00004C08 F2117800        	  1025: 	FMOVE.B	FP0,(A1) 	store the byte in memory
00:00004C0C 6000FCA8        	  1026: 	BRA	FINISH
                            	  1027: .0003
00:00004C10 0C070057        	  1028: 	CMPI.B #'W',d7
00:00004C14 6608            	  1029: 	BNE .0004
00:00004C16 F2117000        	  1030: 	FMOVE.W FP0,(A1)
00:00004C1A 6000FC9A        	  1031: 	BRA FINISH
                            	  1032: .0004
00:00004C1E 0C07004C        	  1033: 	CMPI.B #'L',D7
00:00004C22 6608            	  1034: 	BNE .0005
00:00004C24 F2116000        	  1035: 	FMOVE.L FP0,(A1)
00:00004C28 6000FC8C        	  1036: 	BRA FINISH
                            	  1037: .0005
00:00004C2C 0C070046        	  1038: 	CMPI.B #'F',D7
00:00004C30 6608            	  1039: 	BNE .0006
00:00004C32 F2116800        	  1040: 	FMOVE.X FP0,(A1)
00:00004C36 6000FC7E        	  1041: 	BRA FINISH
                            	  1042: .0006
                            	  1043: PKER
00:00004C3A 60000872        	  1044: 	BRA	QWHAT		if no comma, say "What?"
                            	  1045: 
                            	  1046: CALL	
00:00004C3E 6162            	  1047: 	BSR	INT_EXPR		; get the subroutine's address
00:00004C40 4A80            	  1048: 	TST.l d0				; make sure we got a valid address
00:00004C42 670008B2        	  1049: 	BEQ QHOW				; if not, say "How?"
00:00004C46 2F08            	  1050: 	MOVE.L A0,-(SP)	; save the text pointer
00:00004C48 2240            	  1051: 	MOVE.L D0,A1
00:00004C4A 4E91            	  1052: 	JSR	(A1)				; jump to the subroutine
00:00004C4C 205F            	  1053: 	MOVE.L (SP)+,A0	; restore the text pointer
00:00004C4E 6000FC66        	  1054: 	BRA	FINISH
                            	  1055: 
                            	  1056: ;******************************************************************
                            	  1057: ;
                            	  1058: ; *** EXPR ***
                            	  1059: ;
                            	  1060: ; 'EXPR' evaluates arithmetical or logical expressions.
                            	  1061: ; <EXPR>::=<EXPR2>
                            	  1062: ;	   <EXPR2><rel.op.><EXPR2>
                            	  1063: ; where <rel.op.> is one of the operators in TAB8 and the result
                            	  1064: ; of these operations is 1 if true and 0 if false.
                            	  1065: ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                            	  1066: ; where () are optional and (... are optional repeats.
                            	  1067: ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                            	  1068: ; <EXPR4>::=<variable>
                            	  1069: ;	    <function>
                            	  1070: ;	    (<EXPR>)
                            	  1071: ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                            	  1072: ; as an index, functions can have an <EXPR> as arguments, and
                            	  1073: ; <EXPR4> can be an <EXPR> in parenthesis.
                            	  1074: 
                            	  1075: ;-------------------------------------------------------------------------------
                            	  1076: ; Push a value on the stack.
                            	  1077: ;-------------------------------------------------------------------------------
                            	  1078: 
                            	  1079: XP_PUSH:
00:00004C52 225F            	  1080: 	move.l (sp)+,a1				; a1 = return address
00:00004C54 2F3900040098    	  1081: 	move.l _canary,-(sp)	; push the canary
00:00004C5A 4FEFFFF0        	  1082: 	sub.l #16,sp					; allocate for value
00:00004C5E 2E80            	  1083: 	move.l d0,(sp)				; push data type
00:00004C60 F22F68000004    	  1084: 	fmove.x fp0,4(sp)			; and value
00:00004C66 4ED1            	  1085: 	jmp (a1)
                            	  1086: 
                            	  1087: ;-------------------------------------------------------------------------------
                            	  1088: ; Pop value from stack into first operand.
                            	  1089: ;-------------------------------------------------------------------------------
                            	  1090: 	
                            	  1091: XP_POP:
00:00004C68 225F            	  1092: 	move.l (sp)+,a1			; get return address
00:00004C6A 2017            	  1093: 	move.l (sp),d0			; pop data type
00:00004C6C F22F48000004    	  1094: 	fmove.x 4(sp),fp0		; and data element
00:00004C72 4FEF0010        	  1095: 	add.l #16,sp
00:00004C76 A2970003        	  1096: 	cchk (sp)						; check the canary
00:00004C7A 588F            	  1097: 	add.l #4,sp					; pop canary	
00:00004C7C 4ED1            	  1098: 	jmp (a1)
                            	  1099: 
                            	  1100: ;-------------------------------------------------------------------------------
                            	  1101: ; Pop value from stack into second operand.
                            	  1102: ;-------------------------------------------------------------------------------
                            	  1103: 
                            	  1104: XP_POP1:
00:00004C7E 225F            	  1105: 	move.l (sp)+,a1			; get return address
00:00004C80 2217            	  1106: 	move.l (sp),d1			; pop data type
00:00004C82 F22F48800004    	  1107: 	fmove.x 4(sp),fp1		; and data element
00:00004C88 4FEF0010        	  1108: 	add.l #16,sp
00:00004C8C A2970003        	  1109: 	cchk (sp)						; check the canary
00:00004C90 588F            	  1110: 	add.l #4,sp					; pop canary
00:00004C92 4ED1            	  1111: 	jmp (a1)
                            	  1112: 
                            	  1113: ;-------------------------------------------------------------------------------
                            	  1114: ; Get and expression and make sure it is numeric.
                            	  1115: ;-------------------------------------------------------------------------------
                            	  1116: 
                            	  1117: NUM_EXPR:
00:00004C94 611E            	  1118: 	bsr EXPR
00:00004C96 0C8000000001    	  1119: 	cmpi.l #DT_NUMERIC,d0
00:00004C9C 66000860        	  1120: 	bne ETYPE
00:00004CA0 4E75            	  1121: 	rts
                            	  1122: 
                            	  1123: ;-------------------------------------------------------------------------------
                            	  1124: ; Get and expression and make sure it is numeric. Convert to integer.
                            	  1125: ;-------------------------------------------------------------------------------
                            	  1126: 
                            	  1127: INT_EXPR:
00:00004CA2 6110            	  1128: 	bsr EXPR
00:00004CA4 0C8000000001    	  1129: 	cmpi.l #DT_NUMERIC,d0
00:00004CAA 66000852        	  1130: 	bne ETYPE
00:00004CAE F2006000        	  1131: 	fmove.l fp0,d0
00:00004CB2 4E75            	  1132: 	rts
                            	  1133: 
                            	  1134: ;-------------------------------------------------------------------------------
                            	  1135: ; The top level of the expression parser.
                            	  1136: ; Get an expression, string or numeric.
                            	  1137: ;
                            	  1138: ; EXEC will smash a lot of regs, so push the current expression value before
                            	  1139: ; doing EXEC
                            	  1140: ;-------------------------------------------------------------------------------
                            	  1141: 
                            	  1142: EXPR:
                            	  1143: EXPR_OR:
00:00004CB4 6124            	  1144: 	BSR EXPR_AND
00:00004CB6 619A            	  1145: 	BSR XP_PUSH
00:00004CB8 43FAF8EB        	  1146: 	LEA TAB10,A1
00:00004CBC 45FAF9CA        	  1147: 	LEA TAB10_1,A2
00:00004CC0 6000F9E6        	  1148: 	BRA EXEC
                            	  1149: 	
                            	  1150: ;-------------------------------------------------------------------------------
                            	  1151: ; Boolean 'Or' level
                            	  1152: ;-------------------------------------------------------------------------------
                            	  1153: 
                            	  1154: XP_OR:
00:00004CC4 6114            	  1155: 	BSR EXPR_AND
00:00004CC6 61B6            	  1156: 	bsr XP_POP1
00:00004CC8 613E            	  1157: 	bsr CheckNumeric
00:00004CCA F2016080        	  1158: 	FMOVE.L FP1,D1
00:00004CCE F2006000        	  1159: 	FMOVE.L FP0,D0
00:00004CD2 8081            	  1160: 	OR.L D1,D0
00:00004CD4 F2004000        	  1161: 	FMOVE.L D0,FP0
00:00004CD8 4E75            	  1162: 	rts
                            	  1163: 	
                            	  1164: ;-------------------------------------------------------------------------------
                            	  1165: ; Boolean 'And' level
                            	  1166: ;-------------------------------------------------------------------------------
                            	  1167: 
                            	  1168: EXPR_AND:
00:00004CDA 613E            	  1169: 	bsr EXPR_REL
00:00004CDC 6100FF74        	  1170: 	bsr XP_PUSH
00:00004CE0 43FAF8BF        	  1171: 	LEA TAB9,A1
00:00004CE4 45FAF99A        	  1172: 	LEA TAB9_1,A2
00:00004CE8 6000F9BE        	  1173: 	BRA EXEC
                            	  1174: 
                            	  1175: XP_AND:
00:00004CEC 612C            	  1176: 	BSR EXPR_REL
00:00004CEE 618E            	  1177: 	bsr XP_POP1
00:00004CF0 6116            	  1178: 	bsr CheckNumeric
00:00004CF2 F2016080        	  1179: 	FMOVE.L FP1,D1
00:00004CF6 F2006000        	  1180: 	FMOVE.L FP0,D0
00:00004CFA C081            	  1181: 	AND.L D1,D0
00:00004CFC F2004000        	  1182: 	FMOVE.L D0,FP0
00:00004D00 4E75            	  1183: 	RTS
                            	  1184: 	
                            	  1185: XP_ANDX:
                            	  1186: XP_ORX
00:00004D02 6100FF64        	  1187: 	bsr XP_POP
00:00004D06 4E75            	  1188: 	rts
                            	  1189: 
                            	  1190: ;-------------------------------------------------------------------------------
                            	  1191: ; Check that two numeric values are being used.
                            	  1192: ;-------------------------------------------------------------------------------
                            	  1193: 
                            	  1194: CheckNumeric:
00:00004D08 0C010001        	  1195: 	CMPI.B #DT_NUMERIC,D1
00:00004D0C 660007F0        	  1196: 	BNE ETYPE
00:00004D10 0C000001        	  1197: 	CMPI.B #DT_NUMERIC,D0
00:00004D14 660007E8        	  1198: 	BNE ETYPE
00:00004D18 4E75            	  1199: 	RTS
                            	  1200: 
                            	  1201: ;-------------------------------------------------------------------------------
                            	  1202: ; Relational operator level, <,<=,>=,>,=,<>
                            	  1203: ;-------------------------------------------------------------------------------
                            	  1204: 
                            	  1205: EXPR_REL:
00:00004D1A 61000088        	  1206: 	bsr	EXPR2
00:00004D1E 6100FF32        	  1207: 	bsr XP_PUSH
00:00004D22 43FAF872        	  1208: 	LEA	TAB8,A1 				; look up a relational operator
00:00004D26 45FAF93C        	  1209: 	LEA	TAB8_1,A2
00:00004D2A 6000F97C        	  1210: 	bra	EXEC		go do it
                            	  1211: 
                            	  1212: XP11:
00:00004D2E 6100FF38        	  1213: 	bsr XP_POP
00:00004D32 615C            	  1214: 	BSR	XP18		is it ">="?
00:00004D34 F2940044        	  1215: 	FBLT XPRT0		no, return D0=0
00:00004D38 6048            	  1216: 	BRA	XPRT1		else return D0=1
                            	  1217: 
                            	  1218: XP12:
00:00004D3A 6100FF2C        	  1219: 	bsr XP_POP
00:00004D3E 6150            	  1220: 	BSR	XP18		is it "<>"?
00:00004D40 F2810038        	  1221: 	FBEQ XPRT0		no, return D0=0
00:00004D44 603C            	  1222: 	BRA	XPRT1		else return D0=1
                            	  1223: 
                            	  1224: XP13:
00:00004D46 6100FF20        	  1225: 	bsr XP_POP
00:00004D4A 6144            	  1226: 	BSR	XP18		is it ">"?
00:00004D4C F295002C        	  1227: 	FBLE XPRT0		no, return D0=0
00:00004D50 6030            	  1228: 	BRA	XPRT1		else return D0=1
                            	  1229: 
                            	  1230: XP14:
00:00004D52 6100FF14        	  1231: 	bsr XP_POP
00:00004D56 6138            	  1232: 	BSR	XP18		;is it "<="?
00:00004D58 F2920020        	  1233: 	FBGT XPRT0	;	no, return D0=0
00:00004D5C 6024            	  1234: 	BRA	XPRT1		;else return D0=1
                            	  1235: 
                            	  1236: XP15:
00:00004D5E 6100FF08        	  1237: 	bsr XP_POP
00:00004D62 612C            	  1238: 	BSR	XP18		; is it "="?
00:00004D64 F28E0014        	  1239: 	FBNE XPRT0	;	if not, return D0=0
00:00004D68 6018            	  1240: 	BRA	XPRT1		;else return D0=1
                            	  1241: XP15RT
00:00004D6A 4E75            	  1242: 	RTS
                            	  1243: 
                            	  1244: XP16:
00:00004D6C 6100FEFA        	  1245: 	bsr XP_POP
00:00004D70 611E            	  1246: 	BSR	XP18		; is it "<"?
00:00004D72 F2930006        	  1247: 	FBGE XPRT0	;	if not, return D0=0
00:00004D76 600A            	  1248: 	BRA	XPRT1		; else return D0=1
00:00004D78 4E75            	  1249: 	RTS
                            	  1250: 
                            	  1251: XPRT0:
00:00004D7A F23C58000000    	  1252: 	FMOVE.B #0,FP0	; return fp0 = 0 (false)
00:00004D80 4E75            	  1253: 	RTS
                            	  1254: 
                            	  1255: XPRT1:
00:00004D82 F23C58000001    	  1256: 	FMOVE.B #1,FP0	; return fp0 = 1 (true)
00:00004D88 4E75            	  1257: 	RTS
                            	  1258: 
                            	  1259: XP17:								; it's not a rel. operator
00:00004D8A 6100FEDC        	  1260: 	bsr XP_POP				;	return FP0=<EXPR2>
00:00004D8E 4E75            	  1261: 	rts
                            	  1262: 
                            	  1263: XP18:
00:00004D90 6100FEC0        	  1264: 	bsr XP_PUSH
00:00004D94 610E            	  1265: 	bsr	EXPR2					; do second <EXPR2>
00:00004D96 6100FEE6        	  1266: 	bsr XP_POP1
00:00004D9A 6100FF6C        	  1267: 	bsr CheckNumeric
00:00004D9E F20000B8        	  1268: 	fcmp fp0,fp1			; compare with the first result
00:00004DA2 4E75            	  1269: 	rts								; return the result
                            	  1270: 
                            	  1271: ;-------------------------------------------------------------------------------
                            	  1272: ; Add/Subtract operator level, +,-
                            	  1273: ;-------------------------------------------------------------------------------
                            	  1274: 
                            	  1275: EXPR2
00:00004DA4 61000950        	  1276: 	bsr	TSTC		; negative sign?
00:00004DA8 2D              	  1277: 	DC.B	'-',XP21-*
00:00004DA9 09
00:00004DAA F23C58000000    	  1278: 	FMOVE.B #0,FP0
00:00004DB0 604C            	  1279: 	BRA	XP26
                            	  1280: XP21	
00:00004DB2 61000942        	  1281: 	bsr	TSTC		; positive sign? ignore it
00:00004DB6 2B              	  1282: 	DC.B	'+',XP22-*
00:00004DB7 01
                            	  1283: XP22
00:00004DB8 610000C8        	  1284: 	BSR	EXPR3		; first <EXPR3>
                            	  1285: XP23
00:00004DBC 61000938        	  1286: 	bsr	TSTC		; add?
00:00004DC0 2B              	  1287: 	DC.B	'+',XP25-*
00:00004DC1 37
00:00004DC2 6100FE8E        	  1288: 	bsr XP_PUSH
00:00004DC6 610000BA        	  1289: 	BSR	EXPR3					; get the second <EXPR3>
                            	  1290: XP24
00:00004DCA 6100FEB2        	  1291: 	bsr XP_POP1
00:00004DCE B03C0001        	  1292: 	CMP.B #DT_NUMERIC,d0
00:00004DD2 660C            	  1293: 	BNE .notNum
00:00004DD4 B23C0001        	  1294: 	CMP.B #DT_NUMERIC,d1
00:00004DD8 6606            	  1295: 	BNE .notNum
00:00004DDA F2000422        	  1296: 	FADD FP1,FP0			; add it to the first <EXPR3>
                            	  1297: ;	FBVS	QHOW		branch if there's an overflow
00:00004DDE 60DC            	  1298: 	BRA	XP23		else go back for more operations
                            	  1299: .notNum
00:00004DE0 B0BC00000002    	  1300: 	cmp.l #DT_STRING,d0
00:00004DE6 66000716        	  1301: 	bne ETYPE
00:00004DEA B2BC00000002    	  1302: 	cmp.l #DT_STRING,d1
00:00004DF0 6600070C        	  1303: 	bne ETYPE
00:00004DF4 611E            	  1304: 	bsr ConcatString
00:00004DF6 4E75            	  1305: 	rts
                            	  1306: 
                            	  1307: XP25
00:00004DF8 610008FC        	  1308: 	bsr	TSTC							; subtract?
00:00004DFC 2D              	  1309: 	dc.b	'-',XP27-*
00:00004DFD 15
                            	  1310: XP26
00:00004DFE 6100FE52        	  1311: 	bsr XP_PUSH
00:00004E02 617E            	  1312: 	BSR	EXPR3					; get second <EXPR3>
00:00004E04 0C000001        	  1313: 	cmpi.b #DT_NUMERIC,d0
00:00004E08 660006F4        	  1314: 	bne ETYPE
00:00004E0C F200001A        	  1315: 	FNEG FP0					; change its sign
00:00004E10 60B8            	  1316: 	JMP	XP24					; and do an addition
                            	  1317: 
                            	  1318: XP27
00:00004E12 4E75            	  1319: 	rts
                            	  1320: 
                            	  1321: ;-------------------------------------------------------------------------------
                            	  1322: ; Concatonate strings, for the '+' operator.
                            	  1323: ;
                            	  1324: ; Parameters:
                            	  1325: ;		fp0 = holds string descriptor for second string
                            	  1326: ;		fp1 = holds string descriptor for first string
                            	  1327: ;	Returns:
                            	  1328: ;		fp0 = string descriptor for combined strings
                            	  1329: ;-------------------------------------------------------------------------------
                            	  1330: 
                            	  1331: ConcatString:
00:00004E14 F239688000040600	  1332: 	fmove.x fp1,_fpWork		; save first string descriptor to memory
00:00004E1C F239680000040610	  1333: 	fmove.x fp0,_fpWork+16; save second string descriptor to memory
00:00004E24 343900040600    	  1334: 	move.w _fpWork,d2			; d2 = length of first string
00:00004E2A D47900040610    	  1335: 	add.w	_fpWork+16,d2		; add length of second string
00:00004E30 48C2            	  1336: 	ext.l d2							; make d2 a long word
00:00004E32 61000164        	  1337: 	bsr AllocateString		; allocate
00:00004E36 2849            	  1338: 	move.l a1,a4					; a4 = allocated string, saved for later
00:00004E38 2449            	  1339: 	move.l a1,a2					; a2 = allocated string
00:00004E3A 3542FFFE        	  1340: 	move.w d2,-2(a2)			; save length of new string (a2)
00:00004E3E 227900040604    	  1341: 	move.l _fpWork+4,a1		; a1 = pointer to string text of first string
00:00004E44 2649            	  1342: 	move.l a1,a3					; compute pointer to end of first string
00:00004E46 363900040600    	  1343: 	move.w _fpWork,d3			; d3 = length of first string
00:00004E4C 48C3            	  1344: 	ext.l d3
00:00004E4E D7C3            	  1345: 	add.l d3,a3						; add length of first string
00:00004E50 61000786        	  1346: 	bsr MVUP							; move from A1 to A2 until A1=A3
00:00004E54 227900040614    	  1347: 	move.l _fpWork+20,a1	; a1 = pointer to second string text
00:00004E5A 2649            	  1348: 	move.l a1,a3
00:00004E5C 363900040610    	  1349: 	move.w _fpWork+16,d3	; d3 = length of second string
00:00004E62 48C3            	  1350: 	ext.l d3
00:00004E64 D7C3            	  1351: 	add.l d3,a3						; a3 points to end of second string
00:00004E66 61000770        	  1352: 	bsr MVUP							; concatonate on second string
00:00004E6A 33C200040600    	  1353: 	move.w d2,_fpWork			; save total string length in fp work
00:00004E70 23CC00040604    	  1354: 	move.l a4,_fpWork+4		; save pointer in fp work area
00:00004E76 7002            	  1355: 	moveq #DT_STRING,d0		; set return data type = string
00:00004E78 F239480000040600	  1356: 	fmove.x _fpWork,fp0		; fp0 = string descriptor
00:00004E80 4E75            	  1357: 	rts
                            	  1358: 
                            	  1359: ;-------------------------------------------------------------------------------
                            	  1360: ; Multiply / Divide operator level, *,/,mod
                            	  1361: ;-------------------------------------------------------------------------------
                            	  1362: 
                            	  1363: EXPR3
00:00004E82 6168            	  1364: 	bsr	EXPR4					; get first <EXPR4>
                            	  1365: XP36
00:00004E84 6100FDCC        	  1366: 	bsr XP_PUSH
                            	  1367: XP30
00:00004E88 43FAF71E        	  1368: 	lea TAB11,a1
00:00004E8C 45FAF802        	  1369: 	lea TAB11_1,a2
00:00004E90 6000F816        	  1370: 	bra EXEC
                            	  1371: XP31
00:00004E94 61000860        	  1372: 	bsr	TSTC					; multiply?
00:00004E98 2A              	  1373: 	dc.b	'*',XP34-*
00:00004E99 11
00:00004E9A 6150            	  1374: 	bsr	EXPR4					; get second <EXPR4>
00:00004E9C 6100FDE0        	  1375: 	bsr XP_POP1
00:00004EA0 6100FE66        	  1376: 	bsr CheckNumeric
00:00004EA4 F2000423        	  1377: 	fmul fp1,fp0			; multiply the two
00:00004EA8 60DA            	  1378: 	bra	XP36					; then look for more terms
                            	  1379: XP34
00:00004EAA 6100084A        	  1380: 	bsr	TSTC					; divide?
00:00004EAE 2F              	  1381: 	dc.b	'/',XP35-*
00:00004EAF 15
00:00004EB0 613A            	  1382: 	bsr	EXPR4					; get second <EXPR4>
00:00004EB2 6100FDCA        	  1383: 	bsr XP_POP1
00:00004EB6 6100FE50        	  1384: 	bsr CheckNumeric
00:00004EBA F20000A0        	  1385: 	fdiv fp0,fp1			; do the division
00:00004EBE F2000400        	  1386: 	fmove fp1,fp0
00:00004EC2 60C0            	  1387: 	bra	XP36					; go back for any more terms
                            	  1388: XP35
00:00004EC4 6100FDA2        	  1389: 	bsr XP_POP
00:00004EC8 4E75            	  1390: 	rts
                            	  1391: XP_MOD:
00:00004ECA 6120            	  1392: 	bsr EXPR4
00:00004ECC 6100FDB0        	  1393: 	bsr XP_POP1
00:00004ED0 F20000A0        	  1394: 	fdiv fp0,fp1			; divide
00:00004ED4 F2006080        	  1395: 	fmove.l fp1,d0		; convert to integer
00:00004ED8 F2004180        	  1396: 	fmove.l d0,fp3		; convert back to float
00:00004EDC F20001A3        	  1397: 	fmul fp0,fp3			; multiply quotient times divisor
00:00004EE0 F2000CA8        	  1398: 	fsub fp3,fp1			; subtract from original number
00:00004EE4 F2000400        	  1399: 	fmove.x fp1,fp0		; return difference in fp0
00:00004EE8 7001            	  1400: 	moveq #DT_NUMERIC,d0
00:00004EEA 6098            	  1401: 	bra XP36					; go back and check for more multiply ops
                            	  1402: 	
                            	  1403: ;-------------------------------------------------------------------------------
                            	  1404: ; Lowest Level of expression evaluation.
                            	  1405: ;	Check for
                            	  1406: ;		a function or
                            	  1407: ;		a variable or
                            	  1408: ;		a number or
                            	  1409: ;		a string or
                            	  1410: ;		( expr )
                            	  1411: ;-------------------------------------------------------------------------------
                            	  1412: 
                            	  1413: EXPR4
00:00004EEC 43FAF66E        	  1414: 	LEA	TAB4,A1 			; find possible function
00:00004EF0 45FAF72E        	  1415: 	LEA	TAB4_1,A2
00:00004EF4 6000F7B2        	  1416: 	BRA	EXEC
                            	  1417: XP40
00:00004EF8 61000236        	  1418: 	bsr	TSTV					; nope, not a function
00:00004EFC 650C            	  1419: 	bcs	XP41					; nor a variable
00:00004EFE 2240            	  1420: 	move.l d0,a1			; a1 = variable address
00:00004F00 2011            	  1421: 	move.l (a1),d0		; return type in d0
00:00004F02 F22948000004    	  1422: 	fmove.x 4(a1),fp0	; if a variable, return its value in fp0
                            	  1423: EXP4RT
00:00004F08 4E75            	  1424: 	rts
                            	  1425: XP41
00:00004F0A 61000802        	  1426: 	bsr	TSTNUM				; or is it a number?
00:00004F0E F2000400        	  1427: 	fmove fp1,fp0
00:00004F12 0C8000000001    	  1428: 	cmpi.l #DT_NUMERIC,d0
00:00004F18 67EE            	  1429: 	beq	EXP4RT				; if so, return it in FP0
                            	  1430: XPSTNG
00:00004F1A 610007DA        	  1431: 	bsr TSTC					; is it a string constant?
00:00004F1E 22              	  1432: 	dc.b '"',XP44-*
00:00004F1F 57
00:00004F20 163C0022        	  1433: 	move.b #'"',d3
                            	  1434: XP45
00:00004F24 2248            	  1435: 	move.l a0,a1			; record start of string in a1
00:00004F26 243C000001FF    	  1436: 	move.l #511,d2		; max 512 characters
                            	  1437: .0003	
00:00004F2C 1018            	  1438: 	move.b (a0)+,d0		; get a character
00:00004F2E 670E            	  1439: 	beq .0001					; should not be a NULL
00:00004F30 0C00000D        	  1440: 	cmpi.b #CR,d0			; CR means the end of line was hit without a close quote
00:00004F34 6708            	  1441: 	beq .0001
00:00004F36 B003            	  1442: 	cmp.b d3,d0				; close quote?
00:00004F38 6708            	  1443: 	beq .0002
00:00004F3A 51CAFFF0        	  1444: 	dbra d2,.0003			; no close quote, go back for next char
                            	  1445: .0001
00:00004F3E 600005B6        	  1446: 	bra QHOW
                            	  1447: .0002
00:00004F42 2008            	  1448: 	move.l a0,d0				; d0 = end of string pointer
00:00004F44 9089            	  1449: 	sub.l a1,d0					; compute string length + 1
00:00004F46 5340            	  1450: 	subq #1,d0					; subtract out closing quote
00:00004F48 2400            	  1451: 	move.l d0,d2				; d2 = string length
00:00004F4A 2649            	  1452: 	move.l a1,a3				; a3 = pointer to string text
00:00004F4C 614A            	  1453: 	bsr AllocateString
00:00004F4E 2449            	  1454: 	move.l a1,a2				; a2 points to new text area
00:00004F50 2849            	  1455: 	move.l a1,a4				; save a1 for later
00:00004F52 224B            	  1456: 	move.l a3,a1				; a1 = pointer to string in program
00:00004F54 3542FFFE        	  1457: 	move.w d2,-2(a2)		; copy length into place
00:00004F58 D7C2            	  1458: 	add.l d2,a3					; a3 points to end of string
00:00004F5A 6100067C        	  1459: 	bsr MVUP						; move from A1 to A2 until A1=A3
00:00004F5E 33C200040600    	  1460: 	move.w d2,_fpWork		; copy length into place
00:00004F64 23CC00040604    	  1461: 	move.l a4,_fpWork+4	; copy pointer to text into place
00:00004F6A F239480000040600	  1462: 	fmove.x _fpWork,fp0	; put string descriptor into fp0
00:00004F72 7002            	  1463: 	moveq #DT_STRING,d0	; return string data type
00:00004F74 4E75            	  1464: 	rts
                            	  1465: XP44
00:00004F76 6100077E        	  1466: 	bsr TSTC					; alternate string constant?
00:00004F7A 27              	  1467: 	dc.b '''',PARN-*
00:00004F7B 07
00:00004F7C 163C0027        	  1468: 	move.b #'''',d3
00:00004F80 60A2            	  1469: 	bra XP45
                            	  1470: PARN
00:00004F82 61000772        	  1471: 	bsr	TSTC					; else look for ( EXPR )
00:00004F86 28              	  1472: 	dc.b '(',XP43-*
00:00004F87 0D
00:00004F88 6100FD2A        	  1473: 	bsr	EXPR
00:00004F8C 61000768        	  1474: 	bsr	TSTC
00:00004F90 29              	  1475: 	dc.b ')',XP43-*
00:00004F91 03
                            	  1476: XP42	
00:00004F92 4E75            	  1477: 	rts
                            	  1478: XP43
00:00004F94 60000518        	  1479: 	bra	QWHAT					; else say "What?"
                            	  1480: 
                            	  1481: ;-------------------------------------------------------------------------------	
                            	  1482: ; Allocate storage for a string variable.
                            	  1483: ;
                            	  1484: ; Parameters:
                            	  1485: ;		d2 = number of bytes needed
                            	  1486: ; Returns:
                            	  1487: ;		a1 = pointer to string text area
                            	  1488: ;-------------------------------------------------------------------------------	
                            	  1489: 
                            	  1490: AllocateString:
00:00004F98 48E7383C        	  1491: 	movem.l d2-d4/a2-a5,-(sp)
00:00004F9C 283A0962        	  1492: 	move.l VARBGN,d4
00:00004FA0 227A0956        	  1493: 	move.l LastStr,a1			; a1 = last string
00:00004FA4 3611            	  1494: 	move.w (a1),d3				; d3 = length of last string (0)
00:00004FA6 48C3            	  1495: 	ext.l d3
00:00004FA8 9883            	  1496: 	sub.l d3,d4						; subtract off length
00:00004FAA 5784            	  1497: 	subq.l #3,d4					; size of length field+1 for rounding
00:00004FAC 9889            	  1498: 	sub.l a1,d4						; and start position
00:00004FAE B484            	  1499: 	cmp.l d4,d2						; is there enough room?
00:00004FB0 6224            	  1500: 	bhi .needMoreRoom
                            	  1501: .0001
00:00004FB2 227A0944        	  1502: 	move.l LastStr,a1
00:00004FB6 2649            	  1503: 	move.l a1,a3
00:00004FB8 5489            	  1504: 	addq.l #2,a1					; point a1 to text part of string
00:00004FBA 3682            	  1505: 	move.w d2,(a3)				; save the length
00:00004FBC D7C2            	  1506: 	add.l d2,a3
00:00004FBE 568B            	  1507: 	addq.l #3,a3					; 2 for length field, 1 for rounding
00:00004FC0 260B            	  1508: 	move.l a3,d3
00:00004FC2 0283FFFFFFFE    	  1509: 	andi.l #$FFFFFFFE,d3	; make pointer even wyde
00:00004FC8 23CB000058F8    	  1510: 	move.l a3,LastStr			; set new last str position
00:00004FCE 4253            	  1511: 	clr.w (a3)						; set zero length
00:00004FD0 4CDF3C1C        	  1512: 	movem.l (sp)+,d2-d4/a2-a5
00:00004FD4 4E75            	  1513: 	rts
                            	  1514: .needMoreRoom
00:00004FD6 611E            	  1515: 	bsr GarbageCollectStrings
00:00004FD8 283A0926        	  1516: 	move.l VARBGN,d4			; d4 = start of variables
00:00004FDC 227A091A        	  1517: 	move.l LastStr,a1			; a1 = pointer to last string
00:00004FE0 3611            	  1518: 	move.w (a1),d3				; d3 = length of last string (likely 0)
00:00004FE2 48C3            	  1519: 	ext.l d3
00:00004FE4 D689            	  1520: 	add.l a1,d3						; d3 = pointer past end of last string
00:00004FE6 5683            	  1521: 	addq.l #3,d3					; 2 for length, 1 for rounding
00:00004FE8 9883            	  1522: 	sub.l d3,d4						; free = VARBGN - LastStr+length of (LastStr)
00:00004FEA B484            	  1523: 	cmp.l d4,d2						; request < free?
00:00004FEC 65C4            	  1524: 	blo .0001
00:00004FEE 4DFA089C        	  1525: 	lea NOSTRING,a6
00:00004FF2 600004C0        	  1526: 	bra ERROR
                            	  1527: 		
                            	  1528: ;-------------------------------------------------------------------------------	
                            	  1529: ; Garbage collect strings. This copies all strings in use to the lower end of
                            	  1530: ; the string area and adjusts the string pointers in variables and on the
                            	  1531: ; stack to point to the new location.
                            	  1532: ;
                            	  1533: ; Modifies:
                            	  1534: ;		none
                            	  1535: ;-------------------------------------------------------------------------------	
                            	  1536: 
                            	  1537: GarbageCollectStrings:
00:00004FF6 48E70074        	  1538: 	movem.l a1/a2/a3/a5,-(sp)
00:00004FFA 227A08F8        	  1539: 	move.l StrArea,a1			; source area pointer
00:00004FFE 247A08F4        	  1540: 	move.l StrArea,a2			; target area pointer
00:00005002 2A7A08F4        	  1541: 	move.l LastStr,a5
                            	  1542: .0001
00:00005006 6140            	  1543: 	bsr StringInVar				; check if the string is used by a variable
00:00005008 6506            	  1544: 	bcs .moveString
00:0000500A 610000A6        	  1545: 	bsr StringOnStack			; check if string is on string expression stack
00:0000500E 641C            	  1546: 	bcc .nextString				; if not on stack or in a var then move to next string
                            	  1547: 	
                            	  1548: 	; The string is in use, copy to active string area
                            	  1549: .moveString:
00:00005010 610000D0        	  1550: 	bsr UpdateStringPointers	; update pointer to string on stack or in variable
00:00005014 611C            	  1551: 	bsr NextString				; a3 = pointer to next string
00:00005016 610005CA        	  1552: 	bsr MVUPW							; will copy the length and string text
                            	  1553: .0005
00:0000501A B3CD            	  1554: 	cmp.l a5,a1						; is it the last string?
00:0000501C 63E8            	  1555: 	bls .0001
00:0000501E 23CA000058F8    	  1556: 	move.l a2,LastStr			; update last string pointer
00:00005024 4252            	  1557: 	clr.w (a2)						; set zero length
00:00005026 4CDF2E00        	  1558: 	movem.l (sp)+,a1/a2/a3/a5
00:0000502A 4E75            	  1559: 	rts
                            	  1560: .nextString:
00:0000502C 6104            	  1561: 	bsr NextString
00:0000502E 224B            	  1562: 	move.l a3,a1
00:00005030 60E8            	  1563: 	bra .0005
                            	  1564: 
                            	  1565: ;-------------------------------------------------------------------------------	
                            	  1566: ; Parameters:
                            	  1567: ;		a1 - pointer to current string
                            	  1568: ; Returns:
                            	  1569: ;		a3 - pointer to next string
                            	  1570: ;-------------------------------------------------------------------------------	
                            	  1571: 
                            	  1572: NextString:
00:00005032 2F04            	  1573: 	move.l d4,-(sp)
00:00005034 3811            	  1574: 	move.w (a1),d4				; d4 = string length
00:00005036 48C4            	  1575: 	ext.l d4							; make d4 long
00:00005038 5684            	  1576: 	addq.l #3,d4					; plus 2 for length field, 1 for rounding
00:0000503A D889            	  1577: 	add.l a1,d4
00:0000503C 0284FFFFFFFE    	  1578: 	andi.l #$FFFFFFFE,d4	; make even wyde address
00:00005042 2644            	  1579: 	move.l d4,a3
00:00005044 281F            	  1580: 	move.l (sp)+,d4
00:00005046 4E75            	  1581: 	rts
                            	  1582: 
                            	  1583: ;-------------------------------------------------------------------------------	
                            	  1584: ; Check if a variable is using a string
                            	  1585: ;
                            	  1586: ; Modifies:
                            	  1587: ;		d2,d3,a4
                            	  1588: ; Parameters:
                            	  1589: ;		a1 = pointer to string descriptor
                            	  1590: ; Returns:
                            	  1591: ;		cf = 1 if string in use, 0 otherwise
                            	  1592: ;-------------------------------------------------------------------------------	
                            	  1593: 
                            	  1594: StringInVar:
                            	  1595: 	; check global vars
00:00005048 287A08B6        	  1596: 	move.l VARBGN,a4
00:0000504C 761F            	  1597: 	moveq #31,d3			; 32 vars
00:0000504E 6116            	  1598: 	bsr SIV1
                            	  1599: 	; now check local vars
00:00005050 287A0866        	  1600: 	move.l STKFP,a4
                            	  1601: .0001
00:00005054 588C            	  1602: 	addq.l #4,a4			; point to variable area
00:00005056 7607            	  1603: 	moveq #7,d3
00:00005058 610C            	  1604: 	bsr SIV1					; check variable area
00:0000505A 286CFFFC        	  1605: 	move.l -4(a4),a4	; get previous frame pointer
00:0000505E B9FAF32E        	  1606: 	cmp.l ENDMEM,a4
00:00005062 65F0            	  1607: 	blo .0001
00:00005064 4E75            	  1608: 	rts
                            	  1609: 
                            	  1610: ;-------------------------------------------------------------------------------	
                            	  1611: ; SIV1 - string in variable helper. This routine does a two-up return if the
                            	  1612: ; string is found in a variable. No need to keep searching.
                            	  1613: ;
                            	  1614: ; Modifies:
                            	  1615: ;		d2,d3,a4
                            	  1616: ; Parameters:
                            	  1617: ;		d3 = number of variables-1 to check
                            	  1618: ;		a4 = string space
                            	  1619: ;		a1 = pointer to string descriptor
                            	  1620: ; Returns:
                            	  1621: ;		cf = 1 if string in use, 0 otherwise
                            	  1622: ;-------------------------------------------------------------------------------	
                            	  1623: 
                            	  1624: SIV1:
                            	  1625: .0003
00:00005066 0C9400000002    	  1626: 	cmp.l #DT_STRING,(a4)
00:0000506C 6612            	  1627: 	bne .0004
00:0000506E 242C0008        	  1628: 	move.l 8(a4),d2
00:00005072 5582            	  1629: 	subq.l #2,d2
00:00005074 B3C2            	  1630: 	cmp.l d2,a1
00:00005076 6608            	  1631: 	bne .0004
00:00005078 588F            	  1632: 	addq.l #4,sp			; pop return address
00:0000507A 003C0001        	  1633: 	ori #1,ccr
00:0000507E 4E75            	  1634: 	rts								; do two up return
                            	  1635: .0004
00:00005080 508C            	  1636: 	addq.l #8,a4			;  increment pointer by 16
00:00005082 508C            	  1637: 	addq.l #8,a4
00:00005084 51CBFFE0        	  1638: 	dbra d3,.0003
00:00005088 023C00FE        	  1639: 	andi #$FE,ccr
00:0000508C 4E75            	  1640: 	rts
                            	  1641: 
                            	  1642: ;-------------------------------------------------------------------------------	
                            	  1643: ; Check if a value could be a pointer into the string area.
                            	  1644: ; Even if the data type indicated a string, it may not be. It could just be a
                            	  1645: ; coincidence. So check that the pointer portion is pointing into string
                            	  1646: ; memory. It is extremely unlikely to have a data type and a valid pointer
                            	  1647: ; match and it not be a string.
                            	  1648: ;
                            	  1649: ; Returns
                            	  1650: ;		d3 = pointer to string
                            	  1651: ;		cf=1 if points into string area, 0 otherwise
                            	  1652: ;-------------------------------------------------------------------------------	
                            	  1653: 
                            	  1654: PointsIntoStringArea:
00:0000508E 0C9400000002    	  1655: 	cmp.l #DT_STRING,(a4)		; is it a string data type?
00:00005094 6616            	  1656: 	bne .0001
00:00005096 262C0008        	  1657: 	move.l 8(a4),d3					; likely a string if
00:0000509A B6BA0858        	  1658: 	cmp.l StrArea,d3				; flagged as a string, and pointer is into string area
00:0000509E 650C            	  1659: 	blo .0001
00:000050A0 B6BA085E        	  1660: 	cmp.l VARBGN,d3
00:000050A4 6406            	  1661: 	bhs .0001
00:000050A6 003C0001        	  1662: 	ori #1,ccr
00:000050AA 4E75            	  1663: 	rts
                            	  1664: .0001
00:000050AC 023C00FE        	  1665: 	andi #$FE,ccr
00:000050B0 4E75            	  1666: 	rts
                            	  1667: 
                            	  1668: ;-------------------------------------------------------------------------------	
                            	  1669: ; Check if the string is a temporary on stack
                            	  1670: ;
                            	  1671: ; Parameters:
                            	  1672: ;		a3 = pointer to old string text area
                            	  1673: ; Returns:
                            	  1674: ;		cf = 1 if string in use, 0 otherwise
                            	  1675: ;-------------------------------------------------------------------------------	
                            	  1676: 
                            	  1677: StringOnStack:
00:000050B2 48E72028        	  1678: 	movem.l d2/a2/a4,-(sp)
00:000050B6 7607            	  1679: 	moveq #7,d3
00:000050B8 284F            	  1680: 	move.l sp,a4
                            	  1681: .0002
00:000050BA 61D2            	  1682: 	bsr PointsIntoStringArea
00:000050BC 6408            	  1683: 	bcc .0003
00:000050BE 242C0008        	  1684: 	move.l 8(a4),d2			; d2 = string text pointer
00:000050C2 B7C2            	  1685: 	cmp.l d2,a3					; compare string pointers
00:000050C4 6712            	  1686: 	beq .0001						; same pointer?
                            	  1687: .0003
00:000050C6 588C            	  1688: 	addq.l #4,a4				; bump pointer into stack
00:000050C8 B9FAF2C4        	  1689: 	cmp.l ENDMEM,a4			; have we hit end of stack yet?
00:000050CC 65EC            	  1690: 	blo .0002
00:000050CE 4CDF1404        	  1691: 	movem.l (sp)+,d2/a2/a4
00:000050D2 023C00FE        	  1692: 	andi #$FE,ccr
00:000050D6 4E75            	  1693: 	rts
                            	  1694: .0001
00:000050D8 4CDF1404        	  1695: 	movem.l (sp)+,d2/a2/a4
00:000050DC 003C0001        	  1696: 	ori #1,ccr
00:000050E0 4E75            	  1697: 	rts
                            	  1698: 	
                            	  1699: ;-------------------------------------------------------------------------------	
                            	  1700: ; Update pointers to string to point to new area. All string areas must be
                            	  1701: ; completely checked because there may be more than one pointer to the string.
                            	  1702: ;
                            	  1703: ; Modifies:
                            	  1704: ;		d2,d3,d4,a4
                            	  1705: ; Parameters:
                            	  1706: ;		a1 = old pointer to string
                            	  1707: ;		a2 = new pointer to string
                            	  1708: ;-------------------------------------------------------------------------------	
                            	  1709: 
                            	  1710: UpdateStringPointers:
00:000050E2 2F0B            	  1711: 	move.l a3,-(sp)
00:000050E4 47E90002        	  1712: 	lea 2(a1),a3						; a3 points to old string text area
                            	  1713: 	; check global variable space
00:000050E8 287A0816        	  1714: 	move.l VARBGN,a4
00:000050EC 761F            	  1715: 	moveq #31,d3						; 32 vars to check
00:000050EE 611E            	  1716: 	bsr USP1
                            	  1717: 	; check stack for strings
00:000050F0 284F            	  1718: 	move.l sp,a4						; start at stack bottom and work towards top
                            	  1719: .0002
00:000050F2 619A            	  1720: 	bsr PointsIntoStringArea
00:000050F4 640C            	  1721: 	bcc .0001
                            	  1722: 	; Here we probably have a string, one last check
00:000050F6 B68A            	  1723: 	cmp.l a2,d3							; should be >= a2 as we are packing the space
00:000050F8 6508            	  1724: 	blo .0001
00:000050FA 294A0008        	  1725: 	move.l a2,8(a4)					; update pointer on stack with new address
00:000050FE 546C0008        	  1726: 	addi.w #2,8(a4)					; bump up to text part of string
                            	  1727: .0001
00:00005102 588C            	  1728: 	addq.l #4,a4
00:00005104 B9FAF288        	  1729: 	cmp.l ENDMEM,a4
00:00005108 65E8            	  1730: 	blo .0002
00:0000510A 265F            	  1731: 	move.l (sp)+,a3
00:0000510C 4E75            	  1732: 	rts
                            	  1733: 
                            	  1734: ;-------------------------------------------------------------------------------	
                            	  1735: ; Both global and local variable spaces are updated in the same manner.
                            	  1736: ;
                            	  1737: ; Parameters:
                            	  1738: ;		a1 = old pointer to string
                            	  1739: ;		a2 = new pointer to string
                            	  1740: ;		a4 = start of string space
                            	  1741: ;		d3 = number of string variables
                            	  1742: ;-------------------------------------------------------------------------------	
                            	  1743: 
                            	  1744: USP1:
                            	  1745: .0002
00:0000510E 0C9400000002    	  1746: 	cmp.l #DT_STRING,(a4)		; check the data type
00:00005114 6610            	  1747: 	bne .0001								; not a string, go to next
00:00005116 242C0008        	  1748: 	move.l 8(a4),d2					; d2 = pointer to string text
00:0000511A B7C2            	  1749: 	cmp.l d2,a3							; does pointer match old pointer?
00:0000511C 6608            	  1750: 	bne .0001
00:0000511E 294A0008        	  1751: 	move.l a2,8(a4)					; copy in new pointer
00:00005122 54AC0008        	  1752: 	addi.l #2,8(a4)					; point to string text
                            	  1753: .0001
00:00005126 508C            	  1754: 	addq.l #8,a4						; increment pointer by 16
00:00005128 508C            	  1755: 	addq.l #8,a4
00:0000512A 51CBFFE2        	  1756: 	dbra d3,.0002
00:0000512E 4E75            	  1757: 	rts
                            	  1758: 
                            	  1759: ;-------------------------------------------------------------------------------	
                            	  1760: ; ===== Test for a valid variable name.  Returns Carry=1 if not
                            	  1761: ;	found, else returns Carry=0 and the address of the
                            	  1762: ;	variable in D0.
                            	  1763: 
                            	  1764: TSTV:
00:00005130 61000628        	  1765: 	bsr	IGNBLK
00:00005134 7000            	  1766: 	CLR.L	D0
00:00005136 1010            	  1767: 	MOVE.B (A0),D0 	 	; look at the program text
00:00005138 903C0040        	  1768: 	SUB.B	#'@',D0
00:0000513C 6572            	  1769: 	BCS	TSTVRT				; C=1: not a variable
00:0000513E 6638            	  1770: 	BNE	TV1						; branch if not "@" array
00:00005140 5248            	  1771: 	ADDQ #1,A0				; If it is, it should be
00:00005142 6100FE3E        	  1772: 	BSR	PARN					; followed by (EXPR) as its index.
00:00005146 D080            	  1773: 	ADD.L	D0,D0
00:00005148 650003AC        	  1774: 	BCS	QHOW					; say "How?" if index is too big
00:0000514C D080            	  1775: 	ADD.L	D0,D0
00:0000514E 650003A6        	  1776: 	BCS	QHOW
00:00005152 D080            	  1777: 	ADD.L	D0,D0
00:00005154 650003A0        	  1778: 	BCS	QHOW
00:00005158 D080            	  1779: 	ADD.L	D0,D0
00:0000515A 6500039A        	  1780: 	BCS	QHOW
00:0000515E 2F00            	  1781: 	move.l d0,-(sp)		; save the index
00:00005160 6100012A        	  1782: 	bsr	SIZE					; get amount of free memory
00:00005164 221F            	  1783: 	move.l (sp)+,d1		; get back the index
00:00005166 F2006000        	  1784: 	fmove.l fp0,d0		; convert to integer
00:0000516A B081            	  1785: 	cmp.l	d1,d0				; see if there's enough memory
00:0000516C 63000380        	  1786: 	bls	QSORRY				; if not, say "Sorry"
00:00005170 203A078E        	  1787: 	move.l VARBGN,d0	; put address of array element...
00:00005174 9081            	  1788: 	sub.l	d1,d0				; into D0
00:00005176 4E75            	  1789: 	rts
                            	  1790: TV1
00:00005178 B03C001B        	  1791: 	CMP.B	#27,D0			; if not @, is it A through Z?
00:0000517C 0A3C0001        	  1792: 	EOR	#1,CCR
00:00005180 652E            	  1793: 	BCS	TSTVRT				; if not, set Carry and return
00:00005182 5248            	  1794: 	ADDQ #1,A0				; else bump the text pointer
00:00005184 0C00004C        	  1795: 	cmpi.b #'L',d0		; is it a local? L0 to L7
00:00005188 661E            	  1796: 	bne TV2
00:0000518A 1010            	  1797: 	move.b (a0),d0
00:0000518C 0C000030        	  1798: 	cmpi.b #'0',d0
00:00005190 6516            	  1799: 	blo TV2
00:00005192 0C000037        	  1800: 	cmpi.b #'7',d0
00:00005196 6210            	  1801: 	bhi TV2
00:00005198 903C0030        	  1802: 	sub.b #'0',d0
00:0000519C 5248            	  1803: 	addq #1,a0			; bump text pointer
00:0000519E E988            	  1804: 	lsl.l #4,d0			; *16 bytes per var
00:000051A0 D0BA0716        	  1805: 	add.l STKFP,d0
00:000051A4 5880            	  1806: 	add.l #4,d0
00:000051A6 4E75            	  1807: 	rts
                            	  1808: TV2
00:000051A8 E988            	  1809: 	LSL.L #4,D0			; compute the variable's address
00:000051AA 223A0754        	  1810: 	MOVE.L VARBGN,D1
00:000051AE D081            	  1811: 	ADD.L	D1,D0			; and return it in D0 with Carry=0
                            	  1812: TSTVRT
00:000051B0 4E75            	  1813: 	RTS
                            	  1814: 
                            	  1815: 
                            	  1816: * ===== Divide the 32 bit value in D0 by the 32 bit value in D1.
                            	  1817: *	Returns the 32 bit quotient in D0, remainder in D1.
                            	  1818: *
                            	  1819: DIV32
00:000051B2 4A81            	  1820: 	TST.L	D1		check for divide-by-zero
00:000051B4 67000340        	  1821: 	BEQ	QHOW		if so, say "How?"
00:000051B8 2401            	  1822: 	MOVE.L	D1,D2
00:000051BA 2801            	  1823: 	MOVE.L	D1,D4
00:000051BC B184            	  1824: 	EOR.L	D0,D4		see if the signs are the same
00:000051BE 4A80            	  1825: 	TST.L	D0		take absolute value of D0
00:000051C0 6A02            	  1826: 	BPL	DIV1
00:000051C2 4480            	  1827: 	NEG.L	D0
00:000051C4 4A81            	  1828: DIV1	TST.L	D1		take absolute value of D1
00:000051C6 6A02            	  1829: 	BPL	DIV2
00:000051C8 4481            	  1830: 	NEG.L	D1
00:000051CA 761F            	  1831: DIV2	MOVEQ	#31,D3		iteration count for 32 bits
00:000051CC 2200            	  1832: 	MOVE.L	D0,D1
00:000051CE 7000            	  1833: 	CLR.L	D0
00:000051D0 D281            	  1834: DIV3	ADD.L	D1,D1		(This algorithm was translated from
00:000051D2 D180            	  1835: 	ADDX.L	D0,D0		; the divide routine in Ron Cain's
00:000051D4 6708            	  1836: 	BEQ	DIV4		Small-C run time library.)
00:000051D6 B082            	  1837: 	CMP.L	D2,D0
00:000051D8 6B04            	  1838: 	BMI	DIV4
00:000051DA 5281            	  1839: 	ADDQ.L	#1,D1
00:000051DC 9082            	  1840: 	SUB.L	D2,D0
00:000051DE 51CBFFF0        	  1841: DIV4	DBRA	D3,DIV3
00:000051E2 C141            	  1842: 	EXG	D0,D1		put rem. & quot. in proper registers
00:000051E4 4A84            	  1843: 	TST.L	D4		were the signs the same?
00:000051E6 6A04            	  1844: 	BPL	DIVRT
00:000051E8 4480            	  1845: 	NEG.L	D0		if not, results are negative
00:000051EA 4481            	  1846: 	NEG.L	D1
00:000051EC 4E75            	  1847: DIVRT	RTS
                            	  1848: 
                            	  1849: 
                            	  1850: ; ===== The PEEK function returns the byte stored at the address
                            	  1851: ;	contained in the following expression.
                            	  1852: 
                            	  1853: PEEK
00:000051EE 1E3C0042        	  1854: 	MOVE.B #'B',d7
00:000051F2 1210            	  1855: 	MOVE.B (a0),d1
00:000051F4 0C01002E        	  1856: 	CMPI.B #'.',d1
00:000051F8 6604            	  1857: 	BNE .0001
00:000051FA 5248            	  1858: 	ADDQ #1,a0
00:000051FC 1E18            	  1859: 	move.b (a0)+,d7
                            	  1860: .0001
00:000051FE 6100FD82        	  1861: 	BSR	PARN		get the memory address
00:00005202 0C8000000001    	  1862: 	cmpi.l #DT_NUMERIC,d0
00:00005208 660002F4        	  1863: 	bne ETYPE
00:0000520C F2006000        	  1864: 	FMOVE.L FP0,D0
00:00005210 2240            	  1865: 	MOVE.L D0,A1
00:00005212 0C070042        	  1866: 	cmpi.b #'B',d7
00:00005216 660C            	  1867: 	bne .0002
                            	  1868: .0005
00:00005218 7000            	  1869: 	CLR.L	D0				; upper 3 bytes will be zero
00:0000521A 1011            	  1870: 	MOVE.B (A1),D0
00:0000521C F2005800        	  1871: 	FMOVE.B	D0,FP0 	; get the addressed byte
00:00005220 7001            	  1872: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00005222 4E75            	  1873: 	RTS							; and return it
                            	  1874: .0002
00:00005224 0C070057        	  1875: 	cmpi.b #'W',d7
00:00005228 660C            	  1876: 	bne .0003
00:0000522A 7000            	  1877: 	CLR.L d0
00:0000522C 3011            	  1878: 	MOVE.W (A1),D0
00:0000522E F2005000        	  1879: 	FMOVE.W	D0,FP0	;	get the addressed word
00:00005232 7001            	  1880: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00005234 4E75            	  1881: 	RTS							; and return it
                            	  1882: .0003
00:00005236 0C07004C        	  1883: 	cmpi.b #'L',d7
00:0000523A 660C            	  1884: 	bne .0004
00:0000523C 7000            	  1885: 	CLR.L d0
00:0000523E 2011            	  1886: 	MOVE.L (A1),D0
00:00005240 F2004000        	  1887: 	FMOVE.L	D0,FP0 	; get the lword
00:00005244 7001            	  1888: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00005246 4E75            	  1889: 	RTS							; and return it
                            	  1890: .0004
00:00005248 0C070046        	  1891: 	cmpi.b #'F',d7
00:0000524C 66CA            	  1892: 	bne .0005
00:0000524E F2114800        	  1893: 	FMOVE.X	(A1),FP0 		; get the addressed float
00:00005252 7001            	  1894: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00005254 4E75            	  1895: 	RTS			and return it
                            	  1896: 
                            	  1897: ;-------------------------------------------------------------------------------
                            	  1898: ; The RND function returns a random number from 0 to the value of the following
                            	  1899: ; expression in fp0.
                            	  1900: ;-------------------------------------------------------------------------------
                            	  1901: 
                            	  1902: RND:
00:00005256 6100FD2A        	  1903: 	bsr	PARN								; get the upper limit
00:0000525A 0C8000000001    	  1904: 	cmpi.l #DT_NUMERIC,d0		; must be numeric
00:00005260 6600029C        	  1905: 	bne ETYPE
00:00005264 F200003A        	  1906: 	ftst.x fp0							; it must be positive and non-zero
00:00005268 F281028C        	  1907: 	fbeq QHOW
00:0000526C F2940288        	  1908: 	fblt QHOW
00:00005270 F2000100        	  1909: 	fmove fp0,fp2
00:00005274 7028            	  1910: 	moveq #40,d0						; function #40 get random float
00:00005276 4E4F            	  1911: 	trap #15
00:00005278 F2000823        	  1912: 	fmul fp2,fp0
00:0000527C 7001            	  1913: 	moveq #DT_NUMERIC,d0		; data type is a number
00:0000527E 4E75            	  1914: 	rts
                            	  1915: 
                            	  1916: ; ===== The ABS function returns an absolute value in D0.
                            	  1917: 
                            	  1918: ABS:	
00:00005280 6100FD00        	  1919: 	bsr	PARN			; get the following expr.'s value
00:00005284 F2000018        	  1920: 	fabs.x fp0
00:00005288 7001            	  1921: 	moveq #DT_NUMERIC,d0					; data type is a number
00:0000528A 4E75            	  1922: 	rts
                            	  1923: 
                            	  1924: ; ===== The SIZE function returns the size of free memory in D0.
                            	  1925: 
                            	  1926: SIZE:
00:0000528C 203A0666        	  1927: 	move.l StrArea,d0		; get the number of free bytes...
00:00005290 90BA066A        	  1928: 	sub.l	 TXTUNF,d0		; between 'TXTUNF' and 'StrArea'
00:00005294 F2004000        	  1929: 	fmove.l d0,fp0
00:00005298 7001            	  1930: 	moveq #DT_NUMERIC,d0	; data type is a number
00:0000529A 4E75            	  1931: 	rts										; return the number in fp0
                            	  1932: 	
                            	  1933: ; ===== The TICK function returns the processor tick register in D0.
                            	  1934: 
                            	  1935: TICK:
00:0000529C 4E7A0FF0        	  1936: 	movec tick,d0
00:000052A0 F2004000        	  1937: 	fmove.l d0,fp0
00:000052A4 7001            	  1938: 	moveq #DT_NUMERIC,d0					; data type is a number
00:000052A6 4E75            	  1939: 	rts
                            	  1940: 
                            	  1941: ; ===== The CORENO function returns the core number in D0.
                            	  1942: 
                            	  1943: CORENO:
00:000052A8 4E7A0FE0        	  1944: 	movec coreno,d0
00:000052AC F2004000        	  1945: 	fmove.l d0,fp0
00:000052B0 7001            	  1946: 	moveq #DT_NUMERIC,d0					; data type is a number
00:000052B2 4E75            	  1947: 	rts
                            	  1948: 
                            	  1949: ;-------------------------------------------------------------------------------
                            	  1950: ; Get a pair of argments for the LEFT$ and RIGHT$ functions.
                            	  1951: ; 	(STRING, NUM)
                            	  1952: ; Returns:
                            	  1953: ;		fp0 = number
                            	  1954: ;		fp1 = string
                            	  1955: ;-------------------------------------------------------------------------------
                            	  1956: 
                            	  1957: LorRArgs:
00:000052B4 61000440        	  1958: 	bsr	TSTC						; else look for ( STRING EXPR, NUM EXPR )
00:000052B8 28              	  1959: 	dc.b	'(',LorR1-*
00:000052B9 33
00:000052BA 6100F9F8        	  1960: 	bsr	EXPR
00:000052BE 0C8000000002    	  1961: 	cmpi.l #DT_STRING,d0
00:000052C4 66000238        	  1962: 	bne ETYPE
00:000052C8 6100F988        	  1963: 	bsr XP_PUSH
00:000052CC 61000428        	  1964: 	bsr TSTC
00:000052D0 2C              	  1965: 	dc.b ',',LorR1-*
00:000052D1 1B
00:000052D2 6100F9E0        	  1966: 	bsr EXPR
00:000052D6 0C8000000001    	  1967: 	cmpi.l #DT_NUMERIC,d0
00:000052DC 66000220        	  1968: 	bne ETYPE
00:000052E0 61000414        	  1969: 	bsr	TSTC
00:000052E4 29              	  1970: 	dc.b	')',LorR1-*
00:000052E5 07
00:000052E6 6100F996        	  1971: 	bsr XP_POP1
00:000052EA 4E75            	  1972: 	rts
                            	  1973: LorR1
00:000052EC 60000208        	  1974: 	bra QHOW
                            	  1975: 	
                            	  1976: ;-------------------------------------------------------------------------------
                            	  1977: ; MID$ function gets a substring of characters from start position for
                            	  1978: ; requested length.
                            	  1979: ;-------------------------------------------------------------------------------
                            	  1980: 
                            	  1981: MID:
00:000052F0 61000404        	  1982: 	bsr	TSTC						; look for ( STRING EXPR, NUM EXPR [, NUM_EXPR] )
00:000052F4 28              	  1983: 	dc.b	'(',MID1-*
00:000052F5 C1
00:000052F6 6100F9BC        	  1984: 	bsr	EXPR
00:000052FA 0C8000000002    	  1985: 	cmpi.l #DT_STRING,d0
00:00005300 660001FC        	  1986: 	bne ETYPE
00:00005304 6100F94C        	  1987: 	bsr XP_PUSH
00:00005308 610003EC        	  1988: 	bsr TSTC
00:0000530C 2C              	  1989: 	dc.b ',',MID1-*
00:0000530D A9
00:0000530E 6100F9A4        	  1990: 	bsr EXPR
00:00005312 0C8000000001    	  1991: 	cmpi.l #DT_NUMERIC,d0
00:00005318 660001E4        	  1992: 	bne ETYPE
00:0000531C 6100F934        	  1993: 	bsr XP_PUSH
00:00005320 7A02            	  1994: 	moveq #2,d5
00:00005322 610003D2        	  1995: 	bsr	TSTC
00:00005326 2C              	  1996: 	dc.b ',',MID2-*
00:00005327 11
00:00005328 6100F98A        	  1997: 	bsr EXPR
00:0000532C 0C8000000001    	  1998: 	cmpi.l #DT_NUMERIC,d0
00:00005332 660001CA        	  1999: 	bne ETYPE
00:00005336 7A03            	  2000: 	moveq #3,d5					; d5 indicates 3 params
                            	  2001: MID2
00:00005338 610003BC        	  2002: 	bsr TSTC
00:0000533C 29              	  2003: 	dc.b ')',MID1-*
00:0000533D 79
00:0000533E 6100F93E        	  2004: 	bsr XP_POP1
00:00005342 0C050003        	  2005: 	cmpi.b #3,d5				; did we have 3 arguments?
00:00005346 6708            	  2006: 	beq MID5						; branch if did
00:00005348 F23C40000000FFFF	  2007: 	fmove.l #$FFFF,fp0	; set length = max
                            	  2008: MID5
00:00005350 F2000500        	  2009: 	fmove.x fp1,fp2			; fp2 = start pos
00:00005354 6100F928        	  2010: 	bsr XP_POP1					; fp1 = string descriptor
                            	  2011: ;-------------------------------------------------------------------------------
                            	  2012: ; Perform MID$ function
                            	  2013: ; 	fp1 = string descriptor
                            	  2014: ; 	fp2 = starting position
                            	  2015: ; 	fp0 = length
                            	  2016: ;-------------------------------------------------------------------------------
                            	  2017: DOMID
00:00005358 F239688000040600	  2018: 	fmove.x fp1,_fpWork	; _fpWork = string descriptor
00:00005360 F2036100        	  2019: 	fmove.l fp2,d3			; d3 = start pos
00:00005364 B67900040600    	  2020: 	cmp.w _fpWork,d3		; is start pos < length
00:0000536A 6400018A        	  2021: 	bhs QHOW
00:0000536E F2026000        	  2022: 	fmove.l fp0,d2			; d2=length
00:00005372 D682            	  2023: 	add.l d2,d3					; start pos + length < string length?
00:00005374 B47900040600    	  2024: 	cmp.w _fpWork,d2
00:0000537A 6308            	  2025: 	bls MID4
00:0000537C 343900040600    	  2026: 	move.w _fpWork,d2		; move string length to d2
00:00005382 48C2            	  2027: 	ext.l d2
                            	  2028: MID4
00:00005384 6100FC12        	  2029: 	bsr AllocateString	; a1 = pointer to new string
00:00005388 2449            	  2030: 	move.l a1,a2				; a2 = pointer to new string
00:0000538A 227900040604    	  2031: 	move.l _fpWork+4,a1	; a1 = pointer to string
00:00005390 F2036100        	  2032: 	fmove.l fp2,d3			; d3 = start pos
00:00005394 D3C3            	  2033: 	add.l d3,a1					; a1 = pointer to start pos
00:00005396 33C200040600    	  2034: 	move.w d2,_fpWork		; length
00:0000539C 23CA00040604    	  2035: 	move.l a2,_fpWork+4	; prep to return target string
00:000053A2 2649            	  2036: 	move.l a1,a3				; a3 = pointer to start pos
00:000053A4 D7C2            	  2037: 	add.l d2,a3					; a3 = pointer to end pos
00:000053A6 61000230        	  2038: 	bsr MVUP						; move A1 to A2 until A1 = A3
00:000053AA 7002            	  2039: 	moveq #DT_STRING,d0	; data type is a string
00:000053AC F239480000040600	  2040: 	fmove.x _fpWork,fp0	; string descriptor in fp0
00:000053B4 4E75            	  2041: 	rts
                            	  2042: MID1
00:000053B6 6000013E        	  2043: 	bra QHOW
                            	  2044: 	
                            	  2045: ;-------------------------------------------------------------------------------
                            	  2046: ; LEFT$ function truncates the string after fp0 characters.
                            	  2047: ; Just like MID$ but with a zero starting postion.
                            	  2048: ;-------------------------------------------------------------------------------
                            	  2049: 	
                            	  2050: LEFT:
00:000053BA 6100FEF8        	  2051: 	bsr LorRArgs				; get arguments
00:000053BE F23C59000000    	  2052: 	fmove.b #0,fp2			; start pos = 0
00:000053C4 6092            	  2053: 	bra DOMID
                            	  2054: 
                            	  2055: ;-------------------------------------------------------------------------------
                            	  2056: ; RIGHT$ function gets the rightmost characters.
                            	  2057: ; The start position must be calculated based on the number of characters
                            	  2058: ; requested and the string length.
                            	  2059: ;-------------------------------------------------------------------------------
                            	  2060: 
                            	  2061: RIGHT:
00:000053C6 6100FEEC        	  2062: 	bsr LorRArgs				; get arguments
00:000053CA F2026000        	  2063: 	fmove.l fp0,d2			; d2 = required length
00:000053CE F239688000040600	  2064: 	fmove.x fp1,_fpWork	; _fpWork = string descriptor
00:000053D6 363900040600    	  2065: 	move.w _fpWork,d3		; d3 = string length
00:000053DC 48C3            	  2066: 	ext.l d3						; make d3 a long
00:000053DE B682            	  2067: 	cmp.l d2,d3					; is length > right
00:000053E0 6202            	  2068: 	bhi .0001
00:000053E2 7400            	  2069: 	moveq #0,d2					; we want all the characters if length <= right
                            	  2070: .0001
00:000053E4 9682            	  2071: 	sub.l d2,d3					; d3 = startpos = length - right
00:000053E6 F2034100        	  2072: 	fmove.l d3,fp2			; fp2 = start position
00:000053EA 6000FF6C        	  2073: 	bra DOMID
                            	  2074: 
                            	  2075: ;-------------------------------------------------------------------------------
                            	  2076: ; LEN( EXPR ) returns the length of a string expression.
                            	  2077: ;-------------------------------------------------------------------------------
                            	  2078: 
                            	  2079: LEN:
00:000053EE 6100FB92        	  2080: 	bsr PARN
00:000053F2 0C8000000002    	  2081: 	cmpi.l #DT_STRING,d0
00:000053F8 66000104        	  2082: 	bne ETYPE
00:000053FC F239680000040600	  2083: 	fmove.x fp0,_fpWork
00:00005404 303900040600    	  2084: 	move.w _fpWork,d0
00:0000540A 48C0            	  2085: 	ext.l d0
00:0000540C F2005000        	  2086: 	fmove.w d0,fp0
00:00005410 7001            	  2087: 	moveq #DT_NUMERIC,d0
00:00005412 4E75            	  2088: 	rts
                            	  2089: 
                            	  2090: ;-------------------------------------------------------------------------------
                            	  2091: ; INT( EXPR ) returns the integer value of the expression.
                            	  2092: ; the expression must be in the range of a 32-bit integer.
                            	  2093: ;-------------------------------------------------------------------------------
                            	  2094: 
                            	  2095: INT:
00:00005414 6100FB6C        	  2096: 	bsr PARN
00:00005418 0C8000000001    	  2097: 	cmpi.l #DT_NUMERIC,d0
00:0000541E 660000DE        	  2098: 	bne ETYPE
00:00005422 F2000003        	  2099: 	fintrz fp0,fp0
                            	  2100: ;	fmove.l fp0,d0
                            	  2101: ;	fmove.l d0,fp0
00:00005426 7001            	  2102: 	moveq #DT_NUMERIC,d0
00:00005428 4E75            	  2103: 	rts
                            	  2104: 
                            	  2105: 
                            	  2106: ;-------------------------------------------------------------------------------
                            	  2107: ; CHR$( EXPR ) returns a one byte string containing the character.
                            	  2108: ;-------------------------------------------------------------------------------
                            	  2109: 
                            	  2110: CHR:
00:0000542A 6100FB56        	  2111: 	bsr PARN
00:0000542E 0C8000000001    	  2112: 	cmpi.l #DT_NUMERIC,d0
00:00005434 660000C8        	  2113: 	bne ETYPE
00:00005438 F2006000        	  2114: 	fmove.l fp0,d0
00:0000543C 7401            	  2115: 	moveq #1,d2
00:0000543E 6100FB58        	  2116: 	bsr AllocateString
00:00005442 1280            	  2117: 	move.b d0,(a1)
00:00005444 42290001        	  2118: 	clr.b 1(a1)
00:00005448 7002            	  2119: 	moveq #DT_STRING,d0
00:0000544A 23C900040604    	  2120: 	move.l a1,_fpWork+4
00:00005450 33FC000100040600	  2121: 	move.w #1,_fpWork
00:00005458 F239480000040600	  2122: 	fmove.x _fpWork,fp0
00:00005460 4E75            	  2123: 	rts
                            	  2124: 
                            	  2125: ********************************************************************
                            	  2126: *
                            	  2127: * *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                            	  2128: *
                            	  2129: * 'SETVAL' expects a variable, followed by an equal sign and then
                            	  2130: * an expression.  It evaluates the expression and sets the variable
                            	  2131: * to that value.
                            	  2132: *
                            	  2133: * 'FIN' checks the end of a command.  If it ended with ":",
                            	  2134: * execution continues.	If it ended with a CR, it finds the
                            	  2135: * the next line and continues from there.
                            	  2136: *
                            	  2137: * 'ENDCHK' checks if a command is ended with a CR. This is
                            	  2138: * required in certain commands, such as GOTO, RETURN, STOP, etc.
                            	  2139: *
                            	  2140: * 'ERROR' prints the string pointed to by A0. It then prints the
                            	  2141: * line pointed to by CURRNT with a "?" inserted at where the
                            	  2142: * old text pointer (should be on top of the stack) points to.
                            	  2143: * Execution of Tiny BASIC is stopped and a warm start is done.
                            	  2144: * If CURRNT is zero (indicating a direct command), the direct
                            	  2145: * command is not printed. If CURRNT is -1 (indicating
                            	  2146: * 'INPUT' command in progress), the input line is not printed
                            	  2147: * and execution is not terminated but continues at 'INPERR'.
                            	  2148: *
                            	  2149: * Related to 'ERROR' are the following:
                            	  2150: * 'QWHAT' saves text pointer on stack and gets "What?" message.
                            	  2151: * 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                            	  2152: * 'QSORRY' and 'ASORRY' do the same kind of thing.
                            	  2153: * 'QHOW' and 'AHOW' also do this for "How?".
                            	  2154: 
                            	  2155: ; SETVAL
                            	  2156: ; Returns:
                            	  2157: ;		a6 pointer to variable
                            	  2158: 
                            	  2159: SETVAL	
00:00005462 6100FCCC        	  2160: 	bsr	TSTV					; variable name?
00:00005466 6546            	  2161: 	bcs	QWHAT					; if not, say "What?"
00:00005468 2F00            	  2162: 	move.l d0,-(sp)		; save the variable's address
00:0000546A 6100028A        	  2163: 	bsr	TSTC					; get past the "=" sign
00:0000546E 3D              	  2164: 	dc.b	'=',SV1-*
00:0000546F 11
00:00005470 6100F842        	  2165: 	bsr	EXPR					; evaluate the expression
00:00005474 2C5F            	  2166: 	move.l (sp)+,a6
00:00005476 2C80            	  2167: 	move.l d0,(a6)		; save type
00:00005478 F22E68000004    	  2168: 	fmove.x fp0,4(a6) ; and save its value in the variable
00:0000547E 4E75            	  2169: 	rts
                            	  2170: SV1
00:00005480 602C            	  2171: 	bra	QWHAT					; if no "=" sign
                            	  2172: 
                            	  2173: FIN
00:00005482 61000272        	  2174: 	bsr	TSTC					; *** FIN ***
00:00005486 3A              	  2175: 	DC.B ':',FI1-*
00:00005487 07
00:00005488 588F            	  2176: 	ADDQ.L #4,SP			; if ":", discard return address
00:0000548A 6000F324        	  2177: 	BRA	RUNSML				; continue on the same line
                            	  2178: FI1
00:0000548E 61000266        	  2179: 	bsr	TSTC					; not ":", is it a CR?
00:00005492 0D              	  2180: 	DC.B	CR,FI2-*
00:00005493 07
00:00005494 588F            	  2181: 	ADDQ.L #4,SP			; yes, purge return address
00:00005496 6000F2C2        	  2182: 	BRA	RUNNXL				; execute the next line
                            	  2183: FI2
00:0000549A 4E75            	  2184: 	RTS								; else return to the caller
                            	  2185: 
                            	  2186: ENDCHK
00:0000549C 610002BC        	  2187: 	bsr	IGNBLK
00:000054A0 0C10003A        	  2188: 	CMP.B #':',(a0)
00:000054A4 6706            	  2189: 	BEQ ENDCHK1
00:000054A6 0C10000D        	  2190: 	CMP.B	#CR,(A0)		; does it end with a CR?
00:000054AA 6602            	  2191: 	BNE	QWHAT					; if not, say "WHAT?"
                            	  2192: ENDCHK1:
00:000054AC 4E75            	  2193: 	RTS
                            	  2194: 
                            	  2195: QWHAT
00:000054AE 2F08            	  2196: 	MOVE.L A0,-(SP)
                            	  2197: AWHAT
00:000054B0 4DFA03CA        	  2198: 	LEA	WHTMSG,A6
                            	  2199: ERROR
00:000054B4 6100030A        	  2200: 	bsr	PRMESG		display the error message
00:000054B8 205F            	  2201: 	MOVE.L	(SP)+,A0	restore the text pointer
00:000054BA 203A03F8        	  2202: 	MOVE.L	CURRNT,D0	get the current line number
00:000054BE 6700EF3C        	  2203: 	BEQ	WSTART		if zero, do a warm start
00:000054C2 B0BCFFFFFFFF    	  2204: 	CMP.L	#-1,D0		is the line no. pointer = -1?
00:000054C8 6700F560        	  2205: 	BEQ	INPERR		if so, redo input
00:000054CC 1F10            	  2206: 	MOVE.B	(A0),-(SP)	save the char. pointed to
00:000054CE 4210            	  2207: 	CLR.B	(A0)		put a zero where the error is
00:000054D0 227A03E2        	  2208: 	MOVE.L	CURRNT,A1	point to start of current line
00:000054D4 61000202        	  2209: 	bsr	PRTLN		display the line in error up to the 0
00:000054D8 109F            	  2210: 	MOVE.B	(SP)+,(A0)	restore the character
00:000054DA 103C003F        	  2211: 	MOVE.B	#'?',D0         display a "?"
00:000054DE 6100EE96        	  2212: 	BSR	GOOUT
00:000054E2 4240            	  2213: 	CLR	D0
00:000054E4 5389            	  2214: 	SUBQ.L	#1,A1		point back to the error char.
00:000054E6 6100017E        	  2215: 	bsr	PRTSTG		display the rest of the line
00:000054EA 6000EF10        	  2216: 	BRA	WSTART		and do a warm start
                            	  2217: QSORRY
00:000054EE 2F08            	  2218: 	MOVE.L	A0,-(SP)
                            	  2219: ASORRY
00:000054F0 4DFA03AC        	  2220: 	LEA	SRYMSG,A6
00:000054F4 60BE            	  2221: 	BRA	ERROR
                            	  2222: QHOW
00:000054F6 2F08            	  2223: 	MOVE.L	A0,-(SP)	Error: "How?"
                            	  2224: AHOW
00:000054F8 4DFA037B        	  2225: 	LEA	HOWMSG,A6
00:000054FC 60B6            	  2226: 	BRA	ERROR
                            	  2227: ETYPE
00:000054FE 4DFA0384        	  2228: 	lea TYPMSG,a6
00:00005502 60B0            	  2229: 	bra ERROR
                            	  2230: 
                            	  2231: *******************************************************************
                            	  2232: *
                            	  2233: * *** GETLN *** FNDLN (& friends) ***
                            	  2234: *
                            	  2235: * 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                            	  2236: * the character in D0 (given by the caller), then it fills the
                            	  2237: * buffer and echos. It ignores LF's but still echos
                            	  2238: * them back. Control-H is used to delete the last character
                            	  2239: * entered (if there is one), and control-X is used to delete the
                            	  2240: * whole line and start over again. CR signals the end of a line,
                            	  2241: * and causes 'GETLN' to return.
                            	  2242: *
                            	  2243: * 'FNDLN' finds a line with a given line no. (in D1) in the
                            	  2244: * text save area.  A1 is used as the text pointer. If the line
                            	  2245: * is found, A1 will point to the beginning of that line
                            	  2246: * (i.e. the high byte of the line no.), and flags are NC & Z.
                            	  2247: * If that line is not there and a line with a higher line no.
                            	  2248: * is found, A1 points there and flags are NC & NZ. If we reached
                            	  2249: * the end of the text save area and cannot find the line, flags
                            	  2250: * are C & NZ.
                            	  2251: * 'FNDLN' will initialize A1 to the beginning of the text save
                            	  2252: * area to start the search. Some other entries of this routine
                            	  2253: * will not initialize A1 and do the search.
                            	  2254: * 'FNDLNP' will start with A1 and search for the line no.
                            	  2255: * 'FNDNXT' will bump A1 by 2, find a CR and then start search.
                            	  2256: * 'FNDSKP' uses A1 to find a CR, and then starts the search.
                            	  2257: 
                            	  2258: GETLN
00:00005504 6100EE70        	  2259: 	BSR	GOOUT		display the prompt
00:00005508 103C0020        	  2260: 	MOVE.B	#' ',D0         and a space
00:0000550C 6100EE68        	  2261: 	BSR	GOOUT
00:00005510 41FA03FA        	  2262: 	LEA	BUFFER,A0	A0 is the buffer pointer
                            	  2263: GL1
00:00005514 61000298        	  2264: 	bsr	CHKIO		check keyboard
00:00005518 67FA            	  2265: 	BEQ	GL1		wait for a char. to come in
00:0000551A B03C0008        	  2266: 	CMP.B	#CTRLH,D0	delete last character?
00:0000551E 6726            	  2267: 	BEQ	GL3		if so
00:00005520 B03C0018        	  2268: 	CMP.B	#CTRLX,D0	delete the whole line?
00:00005524 6744            	  2269: 	BEQ	GL4		if so
00:00005526 B03C000D        	  2270: 	CMP.B	#CR,D0		accept a CR
00:0000552A 6706            	  2271: 	BEQ	GL2
00:0000552C B03C0020        	  2272: 	CMP.B	#' ',D0         if other control char., discard it
00:00005530 65E2            	  2273: 	BCS	GL1
                            	  2274: GL2
00:00005532 10C0            	  2275: 	MOVE.B	D0,(A0)+	save the char.
00:00005534 6100EE40        	  2276: 	BSR	GOOUT		echo the char back out
00:00005538 B03C000D        	  2277: 	CMP.B	#CR,D0		if it's a CR, end the line
00:0000553C 675C            	  2278: 	BEQ	GL7
00:0000553E B1FC0000595B    	  2279: 	CMP.L	#(BUFFER+BUFLEN-1),A0	any more room?
00:00005544 65CE            	  2280: 	BCS	GL1		yes: get some more, else delete last char.
                            	  2281: GL3
00:00005546 103C0008        	  2282: 	MOVE.B	#CTRLH,D0	delete a char. if possible
00:0000554A 6100EE2A        	  2283: 	BSR	GOOUT
00:0000554E 103C0020        	  2284: 	MOVE.B	#' ',D0
00:00005552 6100EE22        	  2285: 	BSR	GOOUT
00:00005556 B1FC0000590C    	  2286: 	CMP.L	#BUFFER,A0	any char.'s left?
00:0000555C 63B6            	  2287: 	BLS	GL1		if not
00:0000555E 103C0008        	  2288: 	MOVE.B	#CTRLH,D0	if so, finish the BS-space-BS sequence
00:00005562 6100EE12        	  2289: 	BSR	GOOUT
00:00005566 5388            	  2290: 	SUBQ.L	#1,A0		decrement the text pointer
00:00005568 60AA            	  2291: 	BRA	GL1		back for more
                            	  2292: GL4
00:0000556A 2208            	  2293: 	MOVE.L	A0,D1		delete the whole line
00:0000556C 92BC0000590C    	  2294: 	SUB.L	#BUFFER,D1	figure out how many backspaces we need
00:00005572 671E            	  2295: 	BEQ	GL6		if none needed, branch
00:00005574 5341            	  2296: 	SUBQ	#1,D1		adjust for DBRA
                            	  2297: GL5
00:00005576 103C0008        	  2298: 	MOVE.B	#CTRLH,D0	and display BS-space-BS sequences
00:0000557A 6100EDFA        	  2299: 	BSR	GOOUT
00:0000557E 103C0020        	  2300: 	MOVE.B	#' ',D0
00:00005582 6100EDF2        	  2301: 	BSR	GOOUT
00:00005586 103C0008        	  2302: 	MOVE.B	#CTRLH,D0
00:0000558A 6100EDEA        	  2303: 	BSR	GOOUT
00:0000558E 51C9FFE6        	  2304: 	DBRA	D1,GL5
                            	  2305: GL6
00:00005592 41FA0378        	  2306: 	LEA	BUFFER,A0	reinitialize the text pointer
00:00005596 6000FF7C        	  2307: 	BRA	GL1		and go back for more
                            	  2308: GL7
00:0000559A 103C000A        	  2309: 	MOVE.B	#LF,D0		echo a LF for the CR
00:0000559E 6000EDD6        	  2310: 	BRA	GOOUT
                            	  2311: 
                            	  2312: FNDLN
00:000055A2 B2BC0000FFFF    	  2313: 	CMP.L	#$FFFF,D1	line no. must be < 65535
00:000055A8 6400FF4C        	  2314: 	BCC	QHOW
00:000055AC 227AEDDC        	  2315: 	MOVE.L	TXTBGN,A1	init. the text save pointer
                            	  2316: 
                            	  2317: FNDLNP
00:000055B0 247A034A        	  2318: 	MOVE.L	TXTUNF,A2	check if we passed the end
00:000055B4 538A            	  2319: 	SUBQ.L	#1,A2
00:000055B6 B5C9            	  2320: 	CMP.L	A1,A2
00:000055B8 650C            	  2321: 	BCS	FNDRET		if so, return with Z=0 & C=1
00:000055BA 1411            	  2322: 	MOVE.B	(A1),D2	if not, get a line no.
00:000055BC E14A            	  2323: 	LSL	#8,D2
00:000055BE 14290001        	  2324: 	MOVE.B	1(A1),D2
00:000055C2 B441            	  2325: 	CMP.W	D1,D2		is this the line we want?
00:000055C4 6502            	  2326: 	BCS	FNDNXT		no, not there yet
                            	  2327: FNDRET
00:000055C6 4E75            	  2328: 	RTS			return the cond. codes
                            	  2329: 
                            	  2330: FNDNXT
00:000055C8 5489            	  2331: 	ADDQ.L	#2,A1		find the next line
                            	  2332: 
                            	  2333: FNDSKP	
00:000055CA 0C19000D        	  2334: 	CMP.B	#CR,(A1)+	try to find a CR
00:000055CE 67E0            	  2335: 	BEQ		FNDLNP
00:000055D0 B3FA032A        	  2336: 	CMP.L	TXTUNF,A1
00:000055D4 65F4            	  2337: 	BLO		FNDSKP
00:000055D6 60D8            	  2338: 	BRA		FNDLNP		check if end of text
                            	  2339: 
                            	  2340: ;******************************************************************
                            	  2341: ;
                            	  2342: ; *** MVUP *** MVDOWN *** POPA *** PUSHA ***
                            	  2343: ;
                            	  2344: ; 'MVUP' moves a block up from where A1 points to where A2 points
                            	  2345: ; until A1=A3
                            	  2346: ;
                            	  2347: ; 'MVDOWN' moves a block down from where A1 points to where A3
                            	  2348: ; points until A1=A2
                            	  2349: ;
                            	  2350: ; 'POPA' restores the 'FOR' loop variable save area from the stack
                            	  2351: ;
                            	  2352: ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                            	  2353: ;
                            	  2354: 
                            	  2355: MVUP
00:000055D8 B7C9            	  2356: 	CMP.L	A1,A3					; see the above description
00:000055DA 6304            	  2357: 	BLS	MVRET
00:000055DC 14D9            	  2358: 	MOVE.B	(A1)+,(A2)+
00:000055DE 60F8            	  2359: 	BRA	MVUP
                            	  2360: MVRET
00:000055E0 4E75            	  2361: 	RTS
                            	  2362: 
                            	  2363: ; For string movements only suitable in some circumstances
                            	  2364: 
                            	  2365: MVUPW
00:000055E2 B3CB            	  2366: 	cmp.l a3,a1
00:000055E4 6404            	  2367: 	bhs .0001
00:000055E6 34D9            	  2368: 	move.w (a1)+,(a2)+
00:000055E8 60F8            	  2369: 	bra MVUPW
                            	  2370: .0001
00:000055EA 4E75            	  2371: 	rts
                            	  2372: 
                            	  2373: MVDOWN
00:000055EC B5C9            	  2374: 	CMP.L	A1,A2		see the above description
00:000055EE 67F0            	  2375: 	BEQ	MVRET
00:000055F0 1721            	  2376: 	MOVE.B	-(A1),-(A3)
00:000055F2 60F8            	  2377: 	BRA	MVDOWN
                            	  2378: 
                            	  2379: POPA
00:000055F4 2C5F            	  2380: 	MOVE.L	(SP)+,A6			; A6 = return address
00:000055F6 23DF000058C4    	  2381: 	MOVE.L	(SP)+,LOPVAR	restore LOPVAR, but zero means no more
00:000055FC 6730            	  2382: 	BEQ	.0001
00:000055FE 23DF000058D0    	  2383: 	MOVE.L	(SP)+,LOPINC+8	if not zero, restore the rest
00:00005604 23DF000058CC    	  2384: 	MOVE.L	(SP)+,LOPINC+4
00:0000560A 23DF000058C8    	  2385: 	MOVE.L	(SP)+,LOPINC
00:00005610 23DF000058DC    	  2386: 	MOVE.L	(SP)+,LOPLMT+8
00:00005616 23DF000058D8    	  2387: 	MOVE.L	(SP)+,LOPLMT+4
00:0000561C 23DF000058D4    	  2388: 	MOVE.L	(SP)+,LOPLMT
00:00005622 23DF000058E0    	  2389: 	MOVE.L	(SP)+,LOPLN
00:00005628 23DF000058E4    	  2390: 	MOVE.L	(SP)+,LOPPT
                            	  2391: .0001
00:0000562E 4ED6            	  2392: 	JMP	(A6)		return
                            	  2393: 
                            	  2394: PUSHA
00:00005630 223A02D2        	  2395: 	MOVE.L	STKLMT,D1		; Are we running out of stack room?
00:00005634 928F            	  2396: 	SUB.L	SP,D1
00:00005636 6400FEB6        	  2397: 	BCC	QSORRY					; if so, say we're sorry
00:0000563A 2C5F            	  2398: 	MOVE.L	(SP)+,A6		; else get the return address
00:0000563C 223A0286        	  2399: 	MOVE.L	LOPVAR,D1		; save loop variables
00:00005640 6720            	  2400: 	BEQ	.0001						; if LOPVAR is zero, that's all
00:00005642 2F3A02A0        	  2401: 	MOVE.L	LOPPT,-(SP)	; else save all the others
00:00005646 2F3A0298        	  2402: 	MOVE.L	LOPLN,-(SP)
00:0000564A 2F3A0288        	  2403: 	MOVE.L	LOPLMT,-(SP)
00:0000564E 2F3A0288        	  2404: 	MOVE.L	LOPLMT+4,-(SP)
00:00005652 2F3A0288        	  2405: 	MOVE.L	LOPLMT+8,-(SP)
00:00005656 2F3A0270        	  2406: 	MOVE.L	LOPINC,-(SP)
00:0000565A 2F3A0270        	  2407: 	MOVE.L	LOPINC+4,-(SP)
00:0000565E 2F3A0270        	  2408: 	MOVE.L	LOPINC+8,-(SP)
                            	  2409: .0001
00:00005662 2F01            	  2410: 	MOVE.L	D1,-(SP)
00:00005664 4ED6            	  2411: 	JMP	(A6)		return
                            	  2412: 
                            	  2413: *******************************************************************
                            	  2414: *
                            	  2415: * *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                            	  2416: *
                            	  2417: * 'PRTSTG' prints a string pointed to by A1. It stops printing
                            	  2418: * and returns to the caller when either a CR is printed or when
                            	  2419: * the next byte is the same as what was passed in D0 by the
                            	  2420: * caller.
                            	  2421: *
                            	  2422: * 'QTSTG' looks for an underline (back-arrow on some systems),
                            	  2423: * single-quote, or double-quote.  If none of these are found, returns
                            	  2424: * to the caller.  If underline, outputs a CR without a LF.  If single
                            	  2425: * or double quote, prints the quoted string and demands a matching
                            	  2426: * end quote.  After the printing, the next 2 bytes of the caller are
                            	  2427: * skipped over (usually a short branch instruction).
                            	  2428: *
                            	  2429: * 'PRTNUM' prints the 32 bit number in D1, leading blanks are added if
                            	  2430: * needed to pad the number of spaces to the number in D4.
                            	  2431: * However, if the number of digits is larger than the no. in
                            	  2432: * D4, all digits are printed anyway. Negative sign is also
                            	  2433: * printed and counted in, positive sign is not.
                            	  2434: *
                            	  2435: * 'PRTLN' prints the saved text line pointed to by A1
                            	  2436: * with line no. and all.
                            	  2437: *
                            	  2438: PRTSTG:
00:00005666 1200            	  2439: 	MOVE.B	D0,D1		save the stop character
                            	  2440: PS1
00:00005668 1019            	  2441: 	MOVE.B	(A1)+,D0	get a text character
00:0000566A B200            	  2442: 	CMP.B	D0,D1		same as stop character?
00:0000566C 6712            	  2443: 	BEQ	PRTRET		if so, return
00:0000566E 6100ED06        	  2444: 	BSR	GOOUT		display the char.
00:00005672 B03C000D        	  2445: 	CMP.B	#CR,D0		is it a C.R.?
00:00005676 66F0            	  2446: 	BNE	PS1		no, go back for more
00:00005678 103C000A        	  2447: 	MOVE.B	#LF,D0		yes, add a L.F.
00:0000567C 6100ECF8        	  2448: 	BSR	GOOUT
                            	  2449: PRTRET
00:00005680 4E75            	  2450: 	RTS			then return
                            	  2451: 
                            	  2452: PRTSTR2a
00:00005682 1019            	  2453: 	move.b (a1)+,d0
00:00005684 6100ECF0        	  2454: 	bsr GOOUT
                            	  2455: PRTSTR2:
00:00005688 51C9FFF8        	  2456: 	dbra d1,PRTSTR2a
00:0000568C 4E75            	  2457: 	rts
                            	  2458: 	
                            	  2459: 	if 0
                            	  2460: QTSTG
                            	  2461: 	bsr	TSTC		*** QTSTG ***
                            	  2462: 	DC.B	'"',QT3-*
                            	  2463: 	MOVE.B	#'"',D0         it is a "
                            	  2464: QT1
                            	  2465: 	MOVE.L	A0,A1
                            	  2466: 	BSR	PRTSTG		print until another
                            	  2467: 	MOVE.L	A1,A0
                            	  2468: 	MOVE.L	(SP)+,A1	pop return address
                            	  2469: 	CMP.B	#LF,D0		was last one a CR?
                            	  2470: 	BEQ	RUNNXL		if so, run next line
                            	  2471: QT2
                            	  2472: 	ADDQ.L	#2,A1		skip 2 bytes on return
                            	  2473: 	JMP	(A1)		return
                            	  2474: QT3
                            	  2475: 	bsr	TSTC		is it a single quote?
                            	  2476: 	DC.B	'''',QT4-*
                            	  2477: 	MOVE.B	#'''',D0        if so, do same as above
                            	  2478: 	BRA	QT1
                            	  2479: QT4
                            	  2480: 	bsr	TSTC		is it an underline?
                            	  2481: 	DC.B	'_',QT5-*
                            	  2482: 	MOVE.B	#CR,D0		if so, output a CR without LF
                            	  2483: 	bsr	GOOUT
                            	  2484: 	MOVE.L	(SP)+,A1	pop return address
                            	  2485: 	BRA	QT2
                            	  2486: QT5
                            	  2487: 	RTS			none of the above
                            	  2488: 	endif
                            	  2489: 
                            	  2490: PRTNUM:
00:0000568E 4E52FFD0        	  2491: 	link a2,#-48
00:00005692 217900040098002C	  2492: 	move.l _canary,44(a0)
00:0000569A 48D7020F        	  2493: 	movem.l d0/d1/d2/d3/a1,(sp)
00:0000569E F22F68000014    	  2494: 	fmove.x fp0,20(sp)
00:000056A4 F22F68800020    	  2495: 	fmove.x fp1,32(sp)
00:000056AA F2000400        	  2496: 	fmove.x fp1,fp0					; fp0 = number to print
00:000056AE 43F900040520    	  2497: 	lea _fpBuf,a1						; a1 = pointer to buffer to use
00:000056B4 7027            	  2498: 	moveq #39,d0						; d0 = function #39 print float
00:000056B6 2204            	  2499: 	move.l d4,d1						; d1 = width
00:000056B8 2404            	  2500: 	move.l d4,d2						; d2 = precision max
00:000056BA 7665            	  2501: 	moveq #'e',d3
00:000056BC 4E4F            	  2502: 	trap #15
00:000056BE 4CD7020F        	  2503: 	movem.l (sp),d0/d1/d2/d3/a1
00:000056C2 F22F48000014    	  2504: 	fmove.x 20(sp),fp0
00:000056C8 F22F48800020    	  2505: 	fmove.x 32(sp),fp1
00:000056CE A2A80003002C    	  2506: 	cchk 44(a0)
00:000056D4 4E5A            	  2507: 	unlk a2
00:000056D6 4E75            	  2508: 	rts
                            	  2509: 
                            	  2510: ; Debugging
                            	  2511: 	if 0
                            	  2512: PRTFP0:
                            	  2513: 	link a2,#-48
                            	  2514: 	move.l _canary,44(a0)
                            	  2515: 	movem.l d0/d1/d2/d3/a1,(sp)
                            	  2516: 	fmove.x fp0,20(sp)
                            	  2517: 	lea _fpBuf,a1						; a1 = pointer to buffer to use
                            	  2518: 	moveq #39,d0						; d0 = function #39 print float
                            	  2519: 	moveq #30,d1						; d1 = width
                            	  2520: 	moveq #25,d2						; d2 = precision max
                            	  2521: 	moveq #'e',d3
                            	  2522: 	trap #15
                            	  2523: 	movem.l (sp),d0/d1/d2/d3/a1
                            	  2524: 	fmove.x 20(sp),fp0
                            	  2525: 	cchk 44(a0)
                            	  2526: 	unlk a2
                            	  2527: 	rts
                            	  2528: 	endif
                            	  2529: 
                            	  2530: PRTLN:
00:000056D8 7200            	  2531: 	CLR.L	D1
00:000056DA 1219            	  2532: 	MOVE.B (A1)+,D1	get the binary line number
00:000056DC E149            	  2533: 	LSL	#8,D1
00:000056DE 1219            	  2534: 	MOVE.B (A1)+,D1
00:000056E0 F2015080        	  2535: 	FMOVE.W D1,FP1
00:000056E4 7805            	  2536: 	MOVEQ	#5,D4			; display a 5 digit line no.
00:000056E6 61A6            	  2537: 	BSR	PRTNUM
00:000056E8 103C0020        	  2538: 	MOVE.B	#' ',D0         followed by a blank
00:000056EC 6100EC88        	  2539: 	BSR	GOOUT
00:000056F0 4240            	  2540: 	CLR	D0		stop char. is a zero
00:000056F2 6000FF72        	  2541: 	BRA	PRTSTG		display the rest of the line
                            	  2542: 
                            	  2543: 
                            	  2544: ; ===== Test text byte following the call to this subroutine. If it
                            	  2545: ; equals the byte pointed to by A0, return to the code following
                            	  2546: ; the call. If they are not equal, branch to the point
                            	  2547: ;	indicated by the offset byte following the text byte.
                            	  2548: 
                            	  2549: TSTC:
00:000056F6 6162            	  2550: 	BSR	IGNBLK				; ignore leading blanks
00:000056F8 225F            	  2551: 	MOVE.L (SP)+,A1		; get the return address
00:000056FA 1219            	  2552: 	MOVE.B (A1)+,D1		; get the byte to compare
00:000056FC B210            	  2553: 	CMP.B	(A0),D1 		;	is it = to what A0 points to?
00:000056FE 6708            	  2554: 	BEQ	TC1						; if so
00:00005700 7200            	  2555: 	CLR.L	D1					; If not, add the second
00:00005702 1211            	  2556: 	MOVE.B (A1),D1 		; byte following the call to
00:00005704 D3C1            	  2557: 	ADD.L	D1,A1				; the return address.
00:00005706 4ED1            	  2558: 	JMP	(A1)					; jump to the routine
                            	  2559: TC1
00:00005708 5288            	  2560: 	ADDQ.L #1,A0			; if equal, bump text pointer
00:0000570A 5289            	  2561: 	ADDQ.L #1,A1			; Skip the 2 bytes following
00:0000570C 4ED1            	  2562: 	JMP	(A1)					; the call and continue.
                            	  2563: 
                            	  2564: 
                            	  2565: ; ===== See if the text pointed to by A0 is a number. If so,
                            	  2566: ;	return the number in FP1 and the number of digits in D2,
                            	  2567: ;	else return zero in FP1 and D2.
                            	  2568: ; If text is not a number, then A0 is not updated, otherwise
                            	  2569: ; A0 is advanced past the number. Note A0 is always updated
                            	  2570: ; past leading spaces.
                            	  2571: 
                            	  2572: TSTNUM
00:0000570E 4E52FFE0        	  2573: 	link a2,#-32
00:00005712 2F7900040098001C	  2574: 	move.l _canary,28(sp)
00:0000571A 48D70202        	  2575: 	movem.l d1/a1,(sp)
00:0000571E F22F68000010    	  2576: 	fmove.x fp0,16(sp)
00:00005724 7029            	  2577: 	moveq #41,d0						; function #41, get float
00:00005726 7201            	  2578: 	moveq #1,d1							; d1 = input stride
00:00005728 2248            	  2579: 	move.l a0,a1						; a1 = pointer to input buffer
00:0000572A 4E4F            	  2580: 	trap #15								; call BIOS get float function
00:0000572C 2049            	  2581: 	move.l a1,a0						; set text pointer
00:0000572E 7001            	  2582: 	moveq #DT_NUMERIC,d0		; default data type = number
00:00005730 F2000080        	  2583: 	fmove.x fp0,fp1					; return expected in fp1
00:00005734 4A41            	  2584: 	tst.w d1								; check if a number (digits > 0?)
00:00005736 6706            	  2585: 	beq .0002
00:00005738 7400            	  2586: 	clr.l d2								; d2.l = 0
00:0000573A 3401            	  2587: 	move.w d1,d2						; d2 = number of digits
00:0000573C 6008            	  2588: 	bra .0001
                            	  2589: .0002											; not a number, return with orignal text pointer
00:0000573E 7000            	  2590: 	moveq #0,d0							; data type = not a number
00:00005740 7400            	  2591: 	moveq #0,d2							; d2 = 0
00:00005742 F2024080        	  2592: 	fmove.l d2,fp1					; return a zero
                            	  2593: .0001
00:00005746 4CD70202        	  2594: 	movem.l (sp),d1/a1
00:0000574A F22F48000010    	  2595: 	fmove.x 16(sp),fp0
00:00005750 A2AF0003001C    	  2596: 	cchk 28(sp)
00:00005756 4E5A            	  2597: 	unlk a2
00:00005758 4E75            	  2598: 	rts
                            	  2599: 		
                            	  2600: ; ===== Skip over blanks in the text pointed to by A0.
                            	  2601: 
                            	  2602: IGNBLK
00:0000575A 0C180020        	  2603: 	CMP.B	#' ',(A0)+		; see if it's a space
00:0000575E 67FA            	  2604: 	BEQ	IGNBLK					; if so, swallow it
00:00005760 5388            	  2605: 	SUBQ.L #1,A0				; decrement the text pointer
00:00005762 4E75            	  2606: 	RTS
                            	  2607: 
                            	  2608: *
                            	  2609: * ===== Convert the line of text in the input buffer to upper
                            	  2610: *	case (except for stuff between quotes).
                            	  2611: *
00:00005764 41FA01A6        	  2612: TOUPBUF LEA	BUFFER,A0	set up text pointer
00:00005768 4201            	  2613: 	CLR.B	D1		clear quote flag
                            	  2614: TOUPB1	
00:0000576A 1018            	  2615: 	MOVE.B	(A0)+,D0	get the next text char.
00:0000576C B03C000D        	  2616: 	CMP.B	#CR,D0		is it end of line?
00:00005770 6718            	  2617: 	BEQ	TOUPBRT 	if so, return
00:00005772 B03C0022        	  2618: 	CMP.B	#'"',D0         a double quote?
00:00005776 6714            	  2619: 	BEQ	DOQUO
00:00005778 B03C0027        	  2620: 	CMP.B	#'''',D0        or a single quote?
00:0000577C 670E            	  2621: 	BEQ	DOQUO
00:0000577E 4A01            	  2622: 	TST.B	D1		inside quotes?
00:00005780 66E8            	  2623: 	BNE	TOUPB1		if so, do the next one
00:00005782 6118            	  2624: 	BSR	TOUPPER 	convert to upper case
00:00005784 1100            	  2625: 	MOVE.B	D0,-(A0)	store it
00:00005786 5288            	  2626: 	ADDQ.L	#1,A0
00:00005788 60E0            	  2627: 	BRA	TOUPB1		and go back for more
                            	  2628: TOUPBRT
00:0000578A 4E75            	  2629: 	RTS
                            	  2630: 
00:0000578C 4A01            	  2631: DOQUO	TST.B	D1		are we inside quotes?
00:0000578E 6604            	  2632: 	BNE	DOQUO1
00:00005790 1200            	  2633: 	MOVE.B	D0,D1		if not, toggle inside-quotes flag
00:00005792 60D6            	  2634: 	BRA	TOUPB1
00:00005794 B200            	  2635: DOQUO1	CMP.B	D0,D1		make sure we're ending proper quote
00:00005796 66D2            	  2636: 	BNE	TOUPB1		if not, ignore it
00:00005798 4201            	  2637: 	CLR.B	D1		else clear quote flag
00:0000579A 60CE            	  2638: 	BRA	TOUPB1
                            	  2639: 
                            	  2640: *
                            	  2641: * ===== Convert the character in D0 to upper case
                            	  2642: *
00:0000579C B03C0061        	  2643: TOUPPER CMP.B	#'a',D0         is it < 'a'?
00:000057A0 650A            	  2644: 	BCS	TOUPRET
00:000057A2 B03C007A        	  2645: 	CMP.B	#'z',D0         or > 'z'?
00:000057A6 6204            	  2646: 	BHI	TOUPRET
00:000057A8 903C0020        	  2647: 	SUB.B	#32,D0		if not, make it upper case
00:000057AC 4E75            	  2648: TOUPRET RTS
                            	  2649: 
                            	  2650: *
                            	  2651: * 'CHKIO' checks the input. If there's no input, it will return
                            	  2652: * to the caller with the Z flag set. If there is input, the Z
                            	  2653: * flag is cleared and the input byte is in D0. However, if a
                            	  2654: * control-C is read, 'CHKIO' will warm-start BASIC and will not
                            	  2655: * return to the caller.
                            	  2656: *
                            	  2657: CHKIO
00:000057AE 6100EBCA        	  2658: 	bsr	GOIN		get input if possible
00:000057B2 670A            	  2659: 	BEQ	CHKRET		if Zero, no input
00:000057B4 B03C0003        	  2660: 	CMP.B	#CTRLC,D0	is it control-C?
00:000057B8 6604            	  2661: 	BNE	CHKRET		if not
00:000057BA 6000EC40        	  2662: 	BRA	WSTART		if so, do a warm start
                            	  2663: CHKRET
00:000057BE 4E75            	  2664: 	RTS
                            	  2665: 
                            	  2666: *
                            	  2667: * ===== Display a CR-LF sequence
                            	  2668: *
                            	  2669: ;CRLF	LEA	CLMSG,A6
                            	  2670: 
                            	  2671: 
                            	  2672: ; ===== Display a zero-ended string pointed to by register A6
                            	  2673: 
                            	  2674: PRMESG
00:000057C0 101E            	  2675: 	MOVE.B (A6)+,D0		; get the char.
00:000057C2 6706            	  2676: 	BEQ	PRMRET				; if it's zero, we're done
00:000057C4 6100EBB0        	  2677: 	BSR	GOOUT					; else display it
00:000057C8 60F6            	  2678: 	BRA	PRMESG
                            	  2679: PRMRET
00:000057CA 4E75            	  2680: 	RTS
                            	  2681: 
                            	  2682: ******************************************************
                            	  2683: * The following routines are the only ones that need *
                            	  2684: * to be changed for a different I/O environment.     *
                            	  2685: ******************************************************
                            	  2686: 
                            	  2687: ; ===== Clear screen and home cursor
                            	  2688: 
                            	  2689: CLS:
00:000057CC 700B            	  2690: 	moveq #11,d0			; set cursor position
00:000057CE 323CFF00        	  2691: 	move.w #$FF00,d1	; home cursor and clear screen
00:000057D2 4E4F            	  2692: 	trap #15
00:000057D4 6000F0E0        	  2693: 	bra FINISH
                            	  2694: 
                            	  2695: ; ===== Output character to the console (Port 1) from register D0
                            	  2696: ;(Preserves all registers.)
                            	  2697: 
                            	  2698: OUTC:
00:000057D8 48E7C000        	  2699: 	movem.l d0/d1,-(sp)
00:000057DC 2200            	  2700: 	move.l d0,d1
00:000057DE 7006            	  2701: 	moveq #6,d0
00:000057E0 4E4F            	  2702: 	trap #15
00:000057E2 4CDF0003        	  2703: 	movem.l (sp)+,d0/d1
00:000057E6 4E75            	  2704: 	rts
                            	  2705: 
                            	  2706: * ===== Input a character from the console into register D0 (or
                            	  2707: *	return Zero status if there's no character available).
                            	  2708: *
                            	  2709: INC
00:000057E8 2F0E            	  2710: 	move.l	a6,-(a7)
00:000057EA 2C7A00C0        	  2711: 	move.l	INPPTR,a6
00:000057EE 4E96            	  2712: 	jsr			(a6)
00:000057F0 2C5F            	  2713: 	move.l	(a7)+,a6
00:000057F2 4E75            	  2714: 	rts
                            	  2715: 
                            	  2716: INC1
00:000057F4 2F01            	  2717: 	move.l	d1,-(a7)
00:000057F6 7005            	  2718: 	moveq.l	#5,d0			* function 5 GetKey
00:000057F8 4E4F            	  2719: 	trap		#15
00:000057FA 2001            	  2720: 	move.l	d1,d0
00:000057FC 221F            	  2721: 	move.l	(a7)+,d1
00:000057FE 0C0000FF        	  2722: 	cmpi.b	#-1,d0
00:00005802 6602            	  2723: 	bne			.0001
00:00005804 4200            	  2724: 	clr.b		d0
                            	  2725: .0001:
00:00005806 4E75            	  2726: 	rts
                            	  2727: 
                            	  2728: *INC	BTST	#0,$10040	is character ready?
                            	  2729: *	BEQ	INCRET		if not, return Zero status
                            	  2730: *	MOVE.B	$10042,D0	else get the character
                            	  2731: *	AND.B	#$7F,D0 	zero out the high bit
                            	  2732: *INCRET	RTS
                            	  2733: 
                            	  2734: * ===== Output character to the host (Port 2) from register D0
                            	  2735: *	(Preserves all registers.)
                            	  2736: *
                            	  2737: AUXOUT:
00:00005808 13FC0002000400A8	  2738: 	move.b #2,OutputDevice
00:00005810 61C6            	  2739: 	bsr OUTC
00:00005812 13FC0001000400A8	  2740: 	move.b #1,OutputDevice
00:0000581A 4E75            	  2741: 	rts
                            	  2742: 
                            	  2743: *AUXOUT	BTST	#1,$10041	is port 2 ready for a character?
                            	  2744: *	BEQ	AUXOUT		if not, wait for it
                            	  2745: *	MOVE.B	D0,$10043	out it goes.
                            	  2746: *	RTS
                            	  2747: 
                            	  2748: *
                            	  2749: * ===== Input a character from the host into register D0 (or
                            	  2750: *	return Zero status if there's no character available).
                            	  2751: *
                            	  2752: AUXIN:
00:0000581C 2F01            	  2753: 	move.l	d1,-(a7)
00:0000581E 7024            	  2754: 	moveq		#36,d0				; serial get char from buffer
00:00005820 4E4F            	  2755: 	trap		#15
00:00005822 2001            	  2756: 	move.l	d1,d0
00:00005824 221F            	  2757: 	move.l	(a7)+,d1
00:00005826 0C40FFFF        	  2758: 	cmpi.w	#-1,d0
00:0000582A 670A            	  2759: 	beq			.0001
00:0000582C 0200007F        	  2760: 	andi.b	#$7F,d0				; clear high bit
00:00005830 4880            	  2761: 	ext.w		d0						; return character in d0
00:00005832 48C0            	  2762: 	ext.l		d0
00:00005834 4E75            	  2763: 	rts
                            	  2764: .0001:
00:00005836 7000            	  2765: 	moveq		#0,d0					; return zf=1 if no character available
00:00005838 4E75            	  2766: 	rts
                            	  2767: 
                            	  2768: ;AUXIN
                            	  2769: *AUXIN	BTST	#0,$10041	is character ready?
                            	  2770: *	BEQ	AXIRET		if not, return Zero status
                            	  2771: *	MOVE.B	$10043,D0	else get the character
                            	  2772: *	AND.B	#$7F,D0 	zero out the high bit
00:0000583A 4E75            	  2773: AXIRET	RTS
                            	  2774: 
                            	  2775: ; ===== Return to the resident monitor, operating system, etc.
                            	  2776: ;
                            	  2777: BYEBYE	
00:0000583C 23FC000000080004	  2778: 	move.l #8,_fpTextIncr
00:00005844 0094
00:00005846 600010D8        	  2779: 	bra		Monitor
                            	  2780: ;	MOVE.B	#228,D7 	return to Tutor
                            	  2781: ;	TRAP	#14
                            	  2782: 
00:0000584A 0D              	  2783: INITMSG DC.B	CR,LF,'MC68000 Tiny Float BASIC, v1.0',CR,LF,LF,0
00:0000584B 0A
00:0000584C 4D43363830303020
00:00005854 54696E7920466C6F
00:0000585C 6174204241534943
00:00005864 2C2076312E30
00:0000586A 0D
00:0000586B 0A
00:0000586C 0A
00:0000586D 00
00:0000586E 0D              	  2784: OKMSG	DC.B	CR,LF,'OK',CR,LF,0
00:0000586F 0A
00:00005870 4F4B
00:00005872 0D
00:00005873 0A
00:00005874 00
00:00005875 486F773F        	  2785: HOWMSG	DC.B	'How?',CR,LF,0
00:00005879 0D
00:0000587A 0A
00:0000587B 00
00:0000587C 576861743F      	  2786: WHTMSG	DC.B	'What?',CR,LF,0
00:00005881 0D
00:00005882 0A
00:00005883 00
00:00005884 547970653F      	  2787: TYPMSG	DC.B	'Type?',CR,LF,0
00:00005889 0D
00:0000588A 0A
00:0000588B 00
00:0000588C 4E6F20737472696E	  2788: NOSTRING	DC.B 'No string space',CR,LF,0
00:00005894 67207370616365
00:0000589B 0D
00:0000589C 0A
00:0000589D 00
00:0000589E 536F7272792E    	  2789: SRYMSG	DC.B	'Sorry.'
00:000058A4 0D              	  2790: CLMSG	DC.B	CR,LF,0
00:000058A5 0A
00:000058A6 00
00:000058A7 00              	  2791: 	DC.B	0	<- for aligning on a word boundary
                            	  2792: LSTROM	EQU	*		end of possible ROM area
                            	  2793: *
                            	  2794: * Internal variables follow:
                            	  2795: *
                            	  2796: 	align 2
00:000058A8 00004370        	  2797: RANPNT	DC.L	START		random number pointer
00:000058AC 00000000        	  2798: INPPTR	DS.L	1		input pointer
00:000058B0 00000000        	  2799: OUTPTR	DS.L	1 	output pointer
00:000058B4 00000000        	  2800: CURRNT	DS.L	1		; Current line pointer
00:000058B8 00000000        	  2801: STKFP		DS.L	1		; saves frame pointer
00:000058BC 00000000        	  2802: STKGOS	DS.L	1		Saves stack pointer in 'GOSUB'
00:000058C0 00000000        	  2803: STKINP	DS.L	1		Saves stack pointer during 'INPUT'
00:000058C4 00000000        	  2804: LOPVAR	DS.L	1		'FOR' loop save area
00:000058C8 00000000        	  2805: LOPINC	DS.L	3		increment
00:000058CC *
00:000058D4 00000000        	  2806: LOPLMT	DS.L	3		limit
00:000058D8 *
00:000058E0 00000000        	  2807: LOPLN	DS.L	1		line number
00:000058E4 00000000        	  2808: LOPPT	DS.L	1		text pointer
00:000058E8 00000000        	  2809: IRQROUT	DS.L	1
00:000058EC 00000000        	  2810: STRSTK	DS.L	1		; string pointer stack area, 8 entries
00:000058F0 00000000        	  2811: StrSp		DS.L	1		; string stack stack pointer
00:000058F4 00000000        	  2812: StrArea	DS.L	1		; pointer to string area
00:000058F8 00000000        	  2813: LastStr	DS.L	1		; pointer to last used string in area
00:000058FC 00000000        	  2814: TXTUNF	DS.L	1		points to unfilled text area
00:00005900 00000000        	  2815: VARBGN	DS.L	1		points to variable area
00:00005904 00000000        	  2816: STKLMT	DS.L	1		holds lower limit for stack growth
00:00005908 00000000        	  2817: DIRFLG	DS.L	1		; indicates 1=DIRECT mode
00:0000590C 00              	  2818: BUFFER	DS.B	BUFLEN		Keyboard input buffer
00:0000590D *
                            	  2819: TXT	EQU	*		Beginning of program area
                            	  2820: ;	END
                            	  2821: 

Source: "boot.x68"
                            	   984: 
                            	   985: ; -----------------------------------------------------------------------------
                            	   986: ; -----------------------------------------------------------------------------
                            	   987: 
                            	   988: set_text_mode:
00:0000595C 7040            	   989: 	moveq #64,d0
00:0000595E 13C0FD080000    	   990: 	move.b d0,TEXTREG					; number of columns
00:00005964 7020            	   991: 	moveq #32,d0
00:00005966 13C0FD080001    	   992: 	move.b d0,TEXTREG+1				; number of rows
00:0000596C 7000            	   993: 	moveq #0,d0
00:0000596E 13C0FD080003    	   994: 	move.b d0,TEXTREG+3				; text mode
00:00005974 7011            	   995: 	moveq #17,d0
00:00005976 13C0FD080008    	   996: 	move.b d0,TEXTREG+8				; max row scan
00:0000597C 700B            	   997: 	moveq #11,d0
00:0000597E 13C0FD08000A    	   998: 	move.b d0,TEXTREG+10			; max pix
00:00005984 4E75            	   999: 	rts
                            	  1000: 	
                            	  1001: set_graphics_mode:
00:00005986 7064            	  1002: 	moveq #100,d0
00:00005988 13C0FD080000    	  1003: 	move.b d0,TEXTREG					; number of columns
00:0000598E 704B            	  1004: 	moveq #75,d0
00:00005990 13C0FD080001    	  1005: 	move.b d0,TEXTREG+1				; number of rows
00:00005996 7001            	  1006: 	moveq #1,d0
00:00005998 13C0FD080003    	  1007: 	move.b d0,TEXTREG+3				; graphics mode
00:0000599E 7007            	  1008: 	moveq #7,d0
00:000059A0 13C0FD080008    	  1009: 	move.b d0,TEXTREG+8				; max row scan
00:000059A6 7007            	  1010: 	moveq #7,d0
00:000059A8 13C0FD08000A    	  1011: 	move.b d0,TEXTREG+10			; max pix
00:000059AE 4E75            	  1012: 	rts
                            	  1013: 	
                            	  1014: ; -----------------------------------------------------------------------------
                            	  1015: ; Gets the screen color in d0 and d1.
                            	  1016: ; -----------------------------------------------------------------------------
                            	  1017: 
                            	  1018: get_screen_color:
                            	  1019: 	if (SCREEN_FORMAT==1)
00:000059B0 203900040084    	  1020: 		move.l fgColor,d0				; get foreground color in bits 0 to 7
00:000059B6 E180            	  1021: 		asl.l #8,d0							; foreground color in bits 8 to 15
00:000059B8 80B900040088    	  1022: 		or.l bkColor,d0					;
00:000059BE 4840            	  1023: 		swap d0									; foreground color in bits 24 to 31, bk in 16 to 23
                            	  1024: 	else
                            	  1025: 		move.l	fgColor,d0			; get foreground color
                            	  1026: 		asl.l		#5,d0						; shift into position
                            	  1027: 		ori.l		#$40000000,d0		; set priority
                            	  1028: 		move.l	bkColor,d1
                            	  1029: 		lsr.l		#8,d1
                            	  1030: 		lsr.l		#8,d1
                            	  1031: 		andi.l	#31,d1					; mask off extra bits
                            	  1032: 		or.l		d1,d0						; set background color bits in upper long word
                            	  1033: 		move.l	bkColor,d1			; get background color
                            	  1034: 		asl.l		#8,d1						; shift into position for display ram
                            	  1035: 		asl.l		#8,d1
                            	  1036: 	endif
00:000059C0 4E75            	  1037: 	rts
                            	  1038: 
                            	  1039: ; -----------------------------------------------------------------------------
                            	  1040: ; -----------------------------------------------------------------------------
                            	  1041: 
                            	  1042: get_screen_address:
00:000059C2 207900040004    	  1043: 	move.l	TextScr,a0
00:000059C8 4E75            	  1044: 	rts
                            	  1045: 	
                            	  1046: ; -----------------------------------------------------------------------------
                            	  1047: ; -----------------------------------------------------------------------------
                            	  1048: 
                            	  1049: clear_screen:
00:000059CA 48E7E080        	  1050: 	movem.l	d0/d1/d2/a0,-(a7)
00:000059CE 4E7A0FE0        	  1051: 	movec		coreno,d0
00:000059D2 4840            	  1052: 	swap		d0	
                            	  1053: ;	moveq		#SCREEN_SEMA,d1
                            	  1054: ;	bsr			LockSemaphore
00:000059D4 61EC            	  1055: 	bsr	get_screen_address			; a0 = pointer to screen area
00:000059D6 10390004008C    	  1056: 	move.b	TextRows,d0					; d0 = rows
00:000059DC 14390004008D    	  1057: 	move.b	TextCols,d2					; d2 = cols
00:000059E2 4880            	  1058: 	ext.w		d0									; convert to word
00:000059E4 4882            	  1059: 	ext.w		d2									; convert to word
00:000059E6 C4C0            	  1060: 	mulu d0,d2									; d2 = number of character cells to clear
00:000059E8 61C6            	  1061: 	bsr	get_screen_color				; get the color bits
                            	  1062: 	if (SCREEN_FORMAT==1)
00:000059EA 00400020        	  1063: 		ori.w #32,d0
00:000059EE E158            	  1064: 		rol.w #8,d0
00:000059F0 4840            	  1065: 		swap d0
00:000059F2 E158            	  1066: 		rol.w #8,d0
                            	  1067: loop3:
00:000059F4 20C0            	  1068: 		move.l d0,(a0)+						; copy to cell
                            	  1069: 	else
                            	  1070: 		ori.w	#32,d1							; load space character
                            	  1071: 		rol.w	#8,d1								; swap endian, text controller expects little endian
                            	  1072: 		swap d1
                            	  1073: 		rol.w	#8,d1
                            	  1074: 		rol.w	#8,d0								; swap endian
                            	  1075: 		swap d0
                            	  1076: 		rol.w	#8,d0
                            	  1077: loop3:
                            	  1078: 		move.l d1,(a0)+						; copy char plus bkcolor to cell
                            	  1079: 		move.l d0,(a0)+						; copy fgcolor to cell
                            	  1080: 	endif
00:000059F6 51CAFFFC        	  1081: 	dbra d2,loop3
00:000059FA 4E7A0FE0        	  1082: 	movec coreno,d0
00:000059FE 4840            	  1083: 	swap d0	
                            	  1084: ;	moveq #SCREEN_SEMA,d1
                            	  1085: ;	bsr UnlockSemaphore
00:00005A00 4CDF0107        	  1086: 	movem.l (a7)+,d0/d1/d2/a0
00:00005A04 4E75            	  1087: 	rts
                            	  1088: 
                            	  1089: CRLF:
00:00005A06 48E7C000        	  1090: 	movem.l d0/d1,-(a7)
00:00005A0A 123C000D        	  1091: 	move.b #13,d1
00:00005A0E 7006            	  1092: 	moveq #6,d0						; output character function
00:00005A10 4E4F            	  1093: 	trap #15
00:00005A12 123C000A        	  1094: 	move.b #10,d1
00:00005A16 7006            	  1095: 	moveq #6,d0						; output character function
00:00005A18 4E4F            	  1096: 	trap #15
00:00005A1A 4CDF0003        	  1097: 	movem.l (a7)+,d0/d1
00:00005A1E 4E75            	  1098: 	rts
                            	  1099: 
                            	  1100: ;------------------------------------------------------------------------------
                            	  1101: ;------------------------------------------------------------------------------
                            	  1102: 
                            	  1103: UpdateTextPos:
00:00005A20 103900040000    	  1104: 	move.b	CursorRow,d0		; compute screen location
00:00005A26 0240007F        	  1105: 	andi.w	#$7f,d0
00:00005A2A 14390004008D    	  1106: 	move.b	TextCols,d2
00:00005A30 4882            	  1107: 	ext.w		d2
00:00005A32 C0C2            	  1108: 	mulu.w	d2,d0
00:00005A34 2600            	  1109: 	move.l	d0,d3
00:00005A36 143900040001    	  1110: 	move.b	CursorCol,d2
00:00005A3C 024200FF        	  1111: 	andi.w	#$ff,d2
00:00005A40 D042            	  1112: 	add.w		d2,d0
00:00005A42 33C000040002    	  1113: 	move.w	d0,TextPos			; save cursor pos
00:00005A48 4E75            	  1114: 	rts
                            	  1115: 
                            	  1116: ;------------------------------------------------------------------------------
                            	  1117: ; Calculate screen memory location from CursorRow,CursorCol.
                            	  1118: ; Destroys d0,d2,a0
                            	  1119: ;------------------------------------------------------------------------------
                            	  1120: 
                            	  1121: CalcScreenLoc:
00:00005A4A 61D4            	  1122: 	bsr	UpdateTextPos
00:00005A4C 48C0            	  1123: 	ext.l	d0									;	 make it into a long
                            	  1124: 	if (SCREEN_FORMAT==1)
00:00005A4E E580            	  1125: 		asl.l #2,d0							; 4 bytes per char
                            	  1126: 	else
                            	  1127: 		asl.l	#3,d0							; 8 bytes per char
                            	  1128: 	endif
00:00005A50 6100FF70        	  1129: 	bsr	get_screen_address
00:00005A54 D1C0            	  1130: 	add.l	d0,a0								; a0 = screen location
00:00005A56 4E75            	  1131: 	rts
                            	  1132: 
                            	  1133: ;------------------------------------------------------------------------------
                            	  1134: ; Display a character on the screen
                            	  1135: ; d1.b = char to display
                            	  1136: ;------------------------------------------------------------------------------
                            	  1137: 
                            	  1138: DisplayChar:
00:00005A58 48E77000        	  1139: 	movem.l	d1/d2/d3,-(a7)
00:00005A5C 4E7A2FE0        	  1140: 	movec		coreno,d2
00:00005A60 0C020002        	  1141: 	cmpi.b	#2,d2
                            	  1142: ;	bne.s		.0001
                            	  1143: ;	bsr			SerialPutChar
                            	  1144: .0001:
00:00005A64 0281000000FF    	  1145: 	andi.l	#$ff,d1				; zero out upper bytes of d1
00:00005A6A 0C01000D        	  1146: 	cmpi.b	#13,d1				; carriage return ?
00:00005A6E 6610            	  1147: 	bne			dccr
00:00005A70 423900040001    	  1148: 	clr.b		CursorCol			; just set cursor column to zero on a CR
                            	  1149: dcx14:
00:00005A76 61000294        	  1150: 	bsr			SyncCursor		; set position in text controller
                            	  1151: dcx7:
00:00005A7A 4CDF000E        	  1152: 	movem.l	(a7)+,d1/d2/d3
00:00005A7E 4E75            	  1153: 	rts
                            	  1154: dccr:
00:00005A80 0C010091        	  1155: 	cmpi.b	#$91,d1			; cursor right ?
00:00005A84 6618            	  1156: 	bne.s   dcx6
00:00005A86 14390004008D    	  1157: 	move.b	TextCols,d2
00:00005A8C 5302            	  1158: 	sub.b		#1,d2
00:00005A8E 943900040001    	  1159: 	sub.b		CursorCol,d2
00:00005A94 67E4            	  1160: 	beq.s		dcx7
00:00005A96 523900040001    	  1161: 	addi.b	#1,CursorCol
00:00005A9C 60D8            	  1162: 	bra.s		dcx14
                            	  1163: dcx6:
00:00005A9E 0C010090        	  1164: 	cmpi.b	#$90,d1			; cursor up ?
00:00005AA2 6610            	  1165: 	bne.s		dcx8
00:00005AA4 4A3900040000    	  1166: 	cmpi.b	#0,CursorRow
00:00005AAA 67CE            	  1167: 	beq.s		dcx7
00:00005AAC 533900040000    	  1168: 	subi.b	#1,CursorRow
00:00005AB2 60C2            	  1169: 	bra.s		dcx14
                            	  1170: dcx8:
00:00005AB4 0C010093        	  1171: 	cmpi.b	#$93,d1			; cursor left?
00:00005AB8 6610            	  1172: 	bne.s		dcx9
00:00005ABA 4A3900040001    	  1173: 	cmpi.b	#0,CursorCol
00:00005AC0 67B8            	  1174: 	beq.s		dcx7
00:00005AC2 533900040001    	  1175: 	subi.b	#1,CursorCol
00:00005AC8 60AC            	  1176: 	bra.s		dcx14
                            	  1177: dcx9:
00:00005ACA 0C010092        	  1178: 	cmpi.b	#$92,d1			; cursor down ?
00:00005ACE 6618            	  1179: 	bne.s		dcx10
00:00005AD0 14390004008C    	  1180: 	move.b	TextRows,d2
00:00005AD6 5302            	  1181: 	sub.b		#1,d2
00:00005AD8 B43900040000    	  1182: 	cmp.b		CursorRow,d2
00:00005ADE 679A            	  1183: 	beq.s		dcx7
00:00005AE0 523900040000    	  1184: 	addi.b	#1,CursorRow
00:00005AE6 608E            	  1185: 	bra.s		dcx14
                            	  1186: dcx10:
00:00005AE8 0C010094        	  1187: 	cmpi.b	#$94,d1			; cursor home ?
00:00005AEC 661C            	  1188: 	bne.s		dcx11
00:00005AEE 4A3900040001    	  1189: 	cmpi.b	#0,CursorCol
00:00005AF4 670A            	  1190: 	beq.s		dcx12
00:00005AF6 423900040001    	  1191: 	clr.b		CursorCol
00:00005AFC 6000FF78        	  1192: 	bra			dcx14
                            	  1193: dcx12:
00:00005B00 423900040000    	  1194: 	clr.b		CursorRow
00:00005B06 6000FF6E        	  1195: 	bra			dcx14
                            	  1196: dcx11:
00:00005B0A 48E7E080        	  1197: 	movem.l	d0/d1/d2/a0,-(a7)
00:00005B0E 0C010099        	  1198: 	cmpi.b	#$99,d1			; delete ?
00:00005B12 6750            	  1199: 	beq.s		doDelete
00:00005B14 0C010008        	  1200: 	cmpi.b	#CTRLH,d1			; backspace ?
00:00005B18 673C            	  1201: 	beq.s   doBackspace
00:00005B1A 0C010018        	  1202: 	cmpi.b	#CTRLX,d1			; delete line ?
00:00005B1E 677A            	  1203: 	beq			doCtrlX
00:00005B20 0C01000A        	  1204: 	cmpi.b	#10,d1		; linefeed ?
00:00005B24 671E            	  1205: 	beq.s		dclf
                            	  1206: 
                            	  1207: 	; regular char
00:00005B26 6100FF22        	  1208: 	bsr			CalcScreenLoc	; a0 = screen location
00:00005B2A 2401            	  1209: 	move.l	d1,d2					; d2 = char
00:00005B2C 6100FE82        	  1210: 	bsr			get_screen_color	; d0,d1 = color
                            	  1211: 	if (SCREEN_FORMAT==1)
00:00005B30 8081            	  1212: 		or.l d1,d0
00:00005B32 E158            	  1213: 		rol.w	#8,d0					; swap bytes
00:00005B34 4840            	  1214: 		swap d0							; swap halfs
00:00005B36 E158            	  1215: 		rol.w	#8,d0					; swap remaining bytes
00:00005B38 20C0            	  1216: 		move.l d0,(a0)+
                            	  1217: 	else
                            	  1218: 		or.l		d2,d1					; d1 = char + color
                            	  1219: 		rol.w		#8,d1					; text controller expects little endian data
                            	  1220: 		swap		d1
                            	  1221: 		rol.w		#8,d1
                            	  1222: 		move.l d1,(a0)+
                            	  1223: 		rol.w		#8,d0					; swap bytes
                            	  1224: 		swap		d0						; swap halfs
                            	  1225: 		rol.w		#8,d0					; swap remaining bytes
                            	  1226: 		move.l d0,(a0)+
                            	  1227: 	endif
00:00005B3A 61000082        	  1228: 	bsr	IncCursorPos
00:00005B3E 610001CC        	  1229: 	bsr	SyncCursor
00:00005B42 6008            	  1230: 	bra	dcx4
                            	  1231: dclf:
00:00005B44 61000098        	  1232: 	bsr			IncCursorRow
                            	  1233: dcx16:
00:00005B48 610001C2        	  1234: 	bsr			SyncCursor
                            	  1235: dcx4:
00:00005B4C 4CDF0107        	  1236: 	movem.l	(a7)+,d0/d1/d2/a0		; get back a0
00:00005B50 4CDF000E        	  1237: 	movem.l	(a7)+,d1/d2/d3
00:00005B54 4E75            	  1238: 	rts
                            	  1239: 
                            	  1240: 	;---------------------------
                            	  1241: 	; CTRL-H: backspace
                            	  1242: 	;---------------------------
                            	  1243: doBackspace:
00:00005B56 4A3900040001    	  1244: 	cmpi.b	#0,CursorCol		; if already at start of line
00:00005B5C 67EE            	  1245: 	beq.s   dcx4						; nothing to do
00:00005B5E 533900040001    	  1246: 	subi.b	#1,CursorCol		; decrement column
                            	  1247: 
                            	  1248: 	;---------------------------
                            	  1249: 	; Delete key
                            	  1250: 	;---------------------------
                            	  1251: doDelete:
00:00005B64 48E7C080        	  1252: 	movem.l	d0/d1/a0,-(a7)	; save off screen location
00:00005B68 6100FEE0        	  1253: 	bsr	CalcScreenLoc				; a0 = screen location
00:00005B6C 103900040001    	  1254: 	move.b CursorCol,d0
                            	  1255: .0001:
                            	  1256: 	if (SCREEN_FORMAT==1)
00:00005B72 20A80004        	  1257: 		move.l 4(a0),(a0)				; pull remaining characters on line over 1
00:00005B76 5888            	  1258: 		adda.l #4,a0
                            	  1259: 	else
                            	  1260: 		move.l 8(a0),(a0)				; pull remaining characters on line over 1
                            	  1261: 		move.l 12(a0),4(a0)
                            	  1262: 		adda.l #8,a0
                            	  1263: 	endif
00:00005B78 5200            	  1264: 	addi.b #1,d0
00:00005B7A B0390004008D    	  1265: 	cmp.b	TextCols,d0
00:00005B80 65F0            	  1266: 	blo.s	.0001
00:00005B82 6100FE2C        	  1267: 	bsr	get_screen_color
                            	  1268: 	if (SCREEN_FORMAT==1)
00:00005B86 303C0020        	  1269: 		move.w #' ',d0
00:00005B8A E158            	  1270: 		rol.w	#8,d0
00:00005B8C 4840            	  1271: 		swap d0
00:00005B8E E158            	  1272: 		rol.w	#8,d0
00:00005B90 2140FFFC        	  1273: 		move.l d0,-4(a0)
                            	  1274: 	else
                            	  1275: 		move.w #' ',d1					; terminate line with a space
                            	  1276: 		rol.w	#8,d1
                            	  1277: 		swap d1
                            	  1278: 		rol.w	#8,d1
                            	  1279: 		move.l d1,-8(a0)
                            	  1280: 	endif
00:00005B94 4CDF0103        	  1281: 	movem.l	(a7)+,d0/d1/a0
00:00005B98 60AE            	  1282: 	bra.s		dcx16				; finished
                            	  1283: 
                            	  1284: 	;---------------------------
                            	  1285: 	; CTRL-X: erase line
                            	  1286: 	;---------------------------
                            	  1287: doCtrlX:
00:00005B9A 423900040001    	  1288: 	clr.b	CursorCol			; Reset cursor to start of line
00:00005BA0 10390004008D    	  1289: 	move.b TextCols,d0	; and display TextCols number of spaces
00:00005BA6 4880            	  1290: 	ext.w	d0
00:00005BA8 48C0            	  1291: 	ext.l	d0
00:00005BAA 123C0020        	  1292: 	move.b #' ',d1			; d1 = space char
                            	  1293: .0001:
                            	  1294: 	; DisplayChar is called recursively here
                            	  1295: 	; It's safe to do because we know it won't recurse again due to the
                            	  1296: 	; fact we know the character being displayed is a space char
00:00005BAE 6100273A        	  1297: 	bsr	OutputChar			
00:00005BB2 5340            	  1298: 	subq #1,d0
00:00005BB4 66F8            	  1299: 	bne.s	.0001
00:00005BB6 423900040001    	  1300: 	clr.b	CursorCol			; now really go back to start of line
00:00005BBC 608A            	  1301: 	bra	dcx16						; we're done
                            	  1302: 
                            	  1303: ;------------------------------------------------------------------------------
                            	  1304: ; Increment the cursor position, scroll the screen if needed.
                            	  1305: ;------------------------------------------------------------------------------
                            	  1306: 
                            	  1307: IncCursorPos:
00:00005BBE 527900040002    	  1308: 	addi.w	#1,TextCurpos
00:00005BC4 523900040001    	  1309: 	addi.b	#1,CursorCol
00:00005BCA 10390004008D    	  1310: 	move.b	TextCols,d0
00:00005BD0 B03900040001    	  1311: 	cmp.b		CursorCol,d0
00:00005BD6 6438            	  1312: 	bhs.s		icc1
00:00005BD8 423900040001    	  1313: 	clr.b		CursorCol
                            	  1314: IncCursorRow:
00:00005BDE 523900040000    	  1315: 	addi.b	#1,CursorRow
00:00005BE4 10390004008C    	  1316: 	move.b	TextRows,d0
00:00005BEA B03900040000    	  1317: 	cmp.b		CursorRow,d0
00:00005BF0 621E            	  1318: 	bhi.s		icc1
00:00005BF2 10390004008C    	  1319: 	move.b	TextRows,d0
00:00005BF8 13C000040000    	  1320: 	move.b	d0,CursorRow		; in case CursorRow is way over
00:00005BFE 533900040000    	  1321: 	subi.b	#1,CursorRow
00:00005C04 4880            	  1322: 	ext.w		d0
00:00005C06 D040            	  1323: 	asl.w		#1,d0
00:00005C08 917900040002    	  1324: 	sub.w		d0,TextCurpos
00:00005C0E 6102            	  1325: 	bsr			ScrollUp
                            	  1326: icc1:
00:00005C10 4E75            	  1327: 	rts
                            	  1328: 
                            	  1329: ;------------------------------------------------------------------------------
                            	  1330: ; Scroll screen up.
                            	  1331: ;------------------------------------------------------------------------------
                            	  1332: 
                            	  1333: ScrollUp:
00:00005C12 48E7C084        	  1334: 	movem.l	d0/d1/a0/a5,-(a7)		; save off some regs
00:00005C16 4E7A0FE0        	  1335: 	movec	coreno,d0
00:00005C1A 4840            	  1336: 	swap d0	
00:00005C1C 7205            	  1337: 	moveq	#SCREEN_SEMA,d1
00:00005C1E 6100AB2C        	  1338: 	bsr	LockSemaphore
00:00005C22 6100FD9E        	  1339: 	bsr	get_screen_address
00:00005C26 2A48            	  1340: 	move.l a0,a5								; a5 = pointer to text screen
                            	  1341: .0003:								
00:00005C28 10390004008D    	  1342: 	move.b TextCols,d0					; d0 = columns
00:00005C2E 12390004008C    	  1343: 	move.b TextRows,d1					; d1 = rows
00:00005C34 4880            	  1344: 	ext.w d0										;	make cols into a word value
00:00005C36 4881            	  1345: 	ext.w	d1										; make rows into a word value
                            	  1346: 	if (SCREEN_FORMAT==1)
00:00005C38 E540            	  1347: 		asl.w	#2,d0								; make into cell index
                            	  1348: 	else
                            	  1349: 		asl.w	#3,d0								; make into cell index
                            	  1350: 	endif
00:00005C3A 41F50000        	  1351: 	lea	0(a5,d0.w),a0						; a0 = pointer to second row of text screen
                            	  1352: 	if (SCREEN_FORMAT==1)
00:00005C3E E448            	  1353: 		lsr.w	#2,d0								; get back d0
                            	  1354: 	else
                            	  1355: 		lsr.w	#3,d0								; get back d0
                            	  1356: 	endif
00:00005C40 5341            	  1357: 	subq #1,d1									; number of rows-1
00:00005C42 C0C1            	  1358: 	mulu d1,d0									; d0 = count of characters to move
                            	  1359: 	if (SCREEN_FORMAT==1)
                            	  1360: 	else
                            	  1361: 		add.l d0,d0									; d0*2 2 longs per char
                            	  1362: 	endif
                            	  1363: .0001:
00:00005C44 2AD8            	  1364: 	move.l (a0)+,(a5)+
00:00005C46 51C8FFFC        	  1365: 	dbra d0,.0001
00:00005C4A 4E7A0FE0        	  1366: 	movec coreno,d0
00:00005C4E 4840            	  1367: 	swap d0	
00:00005C50 7205            	  1368: 	moveq #SCREEN_SEMA,d1
00:00005C52 6100AB34        	  1369: 	bsr UnlockSemaphore
00:00005C56 4CDF2103        	  1370: 	movem.l (a7)+,d0/d1/a0/a5
                            	  1371: 	; Fall through into blanking out last line
                            	  1372: 
                            	  1373: ;------------------------------------------------------------------------------
                            	  1374: ; Blank out the last line on the screen.
                            	  1375: ;------------------------------------------------------------------------------
                            	  1376: 
                            	  1377: BlankLastLine:
00:00005C5A 48E7E080        	  1378: 	movem.l	d0/d1/d2/a0,-(a7)
00:00005C5E 4E7A0FE0        	  1379: 	movec	coreno,d0
00:00005C62 4840            	  1380: 	swap d0	
00:00005C64 7205            	  1381: 	moveq	#SCREEN_SEMA,d1
00:00005C66 6100AAE4        	  1382: 	bsr	LockSemaphore
00:00005C6A 6100FD56        	  1383: 	bsr	get_screen_address
00:00005C6E 10390004008C    	  1384: 	move.b TextRows,d0					; d0 = rows
00:00005C74 12390004008D    	  1385: 	move.b TextCols,d1					; d1 = columns
00:00005C7A 4880            	  1386: 	ext.w	d0
00:00005C7C 4881            	  1387: 	ext.w	d1
00:00005C7E 5340            	  1388: 	subq #1,d0									; last row = #rows-1
00:00005C80 C0C1            	  1389: 	mulu d1,d0									; d0 = index of last line
                            	  1390: 	if (SCREEN_FORMAT==1)
00:00005C82 E548            	  1391: 		lsl.w	#2,d0								; *4 bytes per char
                            	  1392: 	else
                            	  1393: 		lsl.w	#3,d0								; *8 bytes per char
                            	  1394: 	endif
00:00005C84 41F00000        	  1395: 	lea	(a0,d0.w),a0						; point a0 to last row
00:00005C88 14390004008D    	  1396: 	move.b TextCols,d2					; number of text cells to clear
00:00005C8E 4882            	  1397: 	ext.w	d2
00:00005C90 5342            	  1398: 	subi.w #1,d2								; count must be one less than desired
00:00005C92 6100FD1C        	  1399: 	bsr	get_screen_color				; d0,d1 = screen color
                            	  1400: 	if (SCREEN_FORMAT==1)
00:00005C96 103C0020        	  1401: 		move.b #32,d0
                            	  1402: 	else
                            	  1403: 		move.b #32,d1								; set the character for display in low 16 bits
                            	  1404: 		bsr	rbo											; reverse the byte order
                            	  1405: 	endif
00:00005C9A E158            	  1406: 	rol.w	#8,d0
00:00005C9C 4840            	  1407: 	swap d0
00:00005C9E E158            	  1408: 	rol.w	#8,d0
                            	  1409: .0001:
                            	  1410: 	if (SCREEN_FORMAT==1)
00:00005CA0 20C0            	  1411: 		move.l d0,(a0)+
                            	  1412: 	else
                            	  1413: 		move.l d0,(a0)+
                            	  1414: 		move.l d1,(a0)+
                            	  1415: 	endif
00:00005CA2 51CAFFFC        	  1416: 	dbra d2,.0001
00:00005CA6 4E7A0FE0        	  1417: 	movec	coreno,d0
00:00005CAA 4840            	  1418: 	swap d0	
00:00005CAC 7205            	  1419: 	moveq #SCREEN_SEMA,d1
00:00005CAE 6100AAD8        	  1420: 	bsr UnlockSemaphore
00:00005CB2 4CDF0107        	  1421: 	movem.l	(a7)+,d0/d1/d2/a0
00:00005CB6 4E75            	  1422: 	rts
                            	  1423: 
                            	  1424: ;------------------------------------------------------------------------------
                            	  1425: ; Display a string on standard output.
                            	  1426: ;------------------------------------------------------------------------------
                            	  1427: 
                            	  1428: DisplayString:
00:00005CB8 48E7C040        	  1429: 	movem.l	d0/d1/a1,-(a7)
                            	  1430: dspj1:
00:00005CBC 7200            	  1431: 	clr.l d1							; clear upper bits of d1
00:00005CBE 1219            	  1432: 	move.b (a1)+,d1				; move string char into d1
00:00005CC0 6706            	  1433: 	beq.s dsret						; is it end of string ?
00:00005CC2 7006            	  1434: 	moveq #6,d0						; output character function
00:00005CC4 4E4F            	  1435: 	trap #15
00:00005CC6 60F4            	  1436: 	bra.s	dspj1						; go back for next character
                            	  1437: dsret:
00:00005CC8 4CDF0203        	  1438: 	movem.l	(a7)+,d0/d1/a1
00:00005CCC 4E75            	  1439: 	rts
                            	  1440: 
                            	  1441: ;------------------------------------------------------------------------------
                            	  1442: ; Display a string on the screen followed by carriage return / linefeed.
                            	  1443: ;------------------------------------------------------------------------------
                            	  1444: 
                            	  1445: DisplayStringCRLF:
00:00005CCE 61E8            	  1446: 	bsr		DisplayString
00:00005CD0 6000FD34        	  1447: 	bra		CRLF
                            	  1448: 
                            	  1449: ;------------------------------------------------------------------------------
                            	  1450: ; Display a string on the screen limited to 255 chars max.
                            	  1451: ;------------------------------------------------------------------------------
                            	  1452: 
                            	  1453: DisplayStringLimited:
00:00005CD4 48E7E040        	  1454: 	movem.l	d0/d1/d2/a1,-(a7)
00:00005CD8 3401            	  1455: 	move.w	d1,d2					; d2 = max count
00:00005CDA 024200FF        	  1456: 	andi.w	#$00FF,d2			; limit to 255 chars
00:00005CDE 600A            	  1457: 	bra.s		.0003					; enter loop at bottom
                            	  1458: .0001:
00:00005CE0 7200            	  1459: 	clr.l d1							; clear upper bits of d1
00:00005CE2 1219            	  1460: 	move.b (a1)+,d1				; move string char into d1
00:00005CE4 6708            	  1461: 	beq.s .0002						; is it end of string ?
00:00005CE6 7006            	  1462: 	moveq #6,d0						; output character function
00:00005CE8 4E4F            	  1463: 	trap #15
                            	  1464: .0003:
00:00005CEA 51CAFFF4        	  1465: 	dbra		d2,.0001			; go back for next character
                            	  1466: .0002:
00:00005CEE 4CDF0207        	  1467: 	movem.l	(a7)+,d0/d1/d2/a1
00:00005CF2 4E75            	  1468: 	rts
                            	  1469: 
                            	  1470: DisplayStringLimitedCRLF:
00:00005CF4 61DE            	  1471: 	bsr		DisplayStringLimited
00:00005CF6 6000FD0E        	  1472: 	bra		CRLF
                            	  1473: 	
                            	  1474: ;------------------------------------------------------------------------------
                            	  1475: ; Set cursor position to top left of screen.
                            	  1476: ;
                            	  1477: ; Parameters:
                            	  1478: ;		<none>
                            	  1479: ; Returns:
                            	  1480: ;		<none>
                            	  1481: ; Registers Affected:
                            	  1482: ;		<none>
                            	  1483: ;------------------------------------------------------------------------------
                            	  1484: 
                            	  1485: HomeCursor:
00:00005CFA 423900040000    	  1486: 	clr.b		CursorRow
00:00005D00 423900040001    	  1487: 	clr.b		CursorCol
00:00005D06 427900040002    	  1488: 	clr.w		TextPos
                            	  1489: 	; fall through
                            	  1490: 
                            	  1491: ;------------------------------------------------------------------------------
                            	  1492: ; SyncCursor:
                            	  1493: ;
                            	  1494: ; Sync the hardware cursor's position to the text cursor position but only for
                            	  1495: ; the core with the IO focus.
                            	  1496: ;
                            	  1497: ; Parameters:
                            	  1498: ;		<none>
                            	  1499: ; Returns:
                            	  1500: ;		<none>
                            	  1501: ; Registers Affected:
                            	  1502: ;		<none>
                            	  1503: ;------------------------------------------------------------------------------
                            	  1504: 
                            	  1505: SyncCursor:
00:00005D0C 48E7E080        	  1506: 	movem.l	d0/d1/d2/a0,-(a7)
00:00005D10 6100FD0E        	  1507: 	bsr	UpdateTextPos
00:00005D14 7200            	  1508: 	clr.l d1
00:00005D16 3200            	  1509: 	move.w d0,d1
00:00005D18 4E7A2FE0        	  1510: 	movec	coreno,d2
00:00005D1C B43900100000    	  1511: 	cmp.b	IOFocus,d2
00:00005D22 6616            	  1512: 	bne.s .0001
00:00005D24 5542            	  1513: 	subi.w #2,d2				; factor in location of screen in controller
00:00005D26 C4FC0800        	  1514: 	mulu #2048,d2				; 2048 cells per screen
00:00005D2A D282            	  1515: 	add.l	d2,d1
00:00005D2C E159            	  1516: 	rol.w	#8,d1					; swap byte order
00:00005D2E 4841            	  1517: 	swap d1
00:00005D30 E159            	  1518: 	rol.w #8,d1
00:00005D32 41F9FD080024    	  1519: 	lea TEXTREG+$24,a0
00:00005D38 2081            	  1520: 	move.l d1,(a0)
                            	  1521: .0001:	
00:00005D3A 4CDF0107        	  1522: 	movem.l	(a7)+,a0/d0/d1/d2
00:00005D3E 4E75            	  1523: 	rts
                            	  1524: 
                            	  1525: ;==============================================================================
                            	  1526: ; TRAP #15 handler
                            	  1527: ;
                            	  1528: ; Parameters:
                            	  1529: ;		d0.w = function number to perform
                            	  1530: ;==============================================================================
                            	  1531: 
                            	  1532: TRAP15:
00:00005D40 48E78080        	  1533: 	movem.l	d0/a0,-(a7)
00:00005D44 41FA0012        	  1534: 	lea T15DispatchTable,a0
00:00005D48 E580            	  1535: 	asl.l #2,d0
00:00005D4A 20700000        	  1536: 	move.l (a0,d0.w),a0
00:00005D4E 4E90            	  1537: 	jsr (a0)
00:00005D50 4CDF0101        	  1538: 	movem.l (a7)+,d0/a0
00:00005D54 4E73            	  1539: 	rte
                            	  1540: 
                            	  1541: 		align	2
                            	  1542: T15DispatchTable:
00:00005D58 00005CF4        	  1543: 	dc.l	DisplayStringLimitedCRLF
00:00005D5C 00005CD4        	  1544: 	dc.l	DisplayStringLimited
00:00005D60 00005E40        	  1545: 	dc.l	StubRout
00:00005D64 00005E40        	  1546: 	dc.l	StubRout
00:00005D68 00005E40        	  1547: 	dc.l	StubRout
00:00005D6C 000061B4        	  1548: 	dc.l	GetKey
00:00005D70 000082EA        	  1549: 	dc.l	OutputChar
00:00005D74 000061A8        	  1550: 	dc.l	CheckForKey
00:00005D78 00005E40        	  1551: 	dc.l	StubRout
00:00005D7C 00005E40        	  1552: 	dc.l	StubRout
                            	  1553: 	; 10
00:00005D80 00005E40        	  1554: 	dc.l	StubRout
00:00005D84 00005E08        	  1555: 	dc.l	Cursor1
00:00005D88 000061A0        	  1556: 	dc.l	SetKeyboardEcho
00:00005D8C 00005CCE        	  1557: 	dc.l	DisplayStringCRLF
00:00005D90 00005CB8        	  1558: 	dc.l	DisplayString
00:00005D94 00005E40        	  1559: 	dc.l	StubRout
00:00005D98 00005E40        	  1560: 	dc.l	StubRout
00:00005D9C 00005E40        	  1561: 	dc.l	StubRout
00:00005DA0 00005E40        	  1562: 	dc.l	StubRout
00:00005DA4 00005E40        	  1563: 	dc.l	StubRout
                            	  1564: 	; 20
00:00005DA8 00005E40        	  1565: 	dc.l	StubRout
00:00005DAC 00005E40        	  1566: 	dc.l	StubRout
00:00005DB0 00005E40        	  1567: 	dc.l	StubRout
00:00005DB4 00005E40        	  1568: 	dc.l	StubRout
00:00005DB8 00005E40        	  1569: 	dc.l	StubRout
00:00005DBC 00005E40        	  1570: 	dc.l	StubRout
00:00005DC0 00005E40        	  1571: 	dc.l	StubRout
00:00005DC4 00005E40        	  1572: 	dc.l	StubRout
00:00005DC8 00005E40        	  1573: 	dc.l	StubRout
00:00005DCC 00005E40        	  1574: 	dc.l	StubRout
                            	  1575: 	; 30
00:00005DD0 00005E40        	  1576: 	dc.l	StubRout
00:00005DD4 00005E40        	  1577: 	dc.l	StubRout
00:00005DD8 00005E54        	  1578: 	dc.l	rotate_iofocus
00:00005DDC 00007CEA        	  1579: 	dc.l	SerialPeekCharDirect
00:00005DE0 00007D04        	  1580: 	dc.l	SerialPutChar
00:00005DE4 00007CAE        	  1581: 	dc.l	SerialPeekChar
00:00005DE8 00007C36        	  1582: 	dc.l	SerialGetChar
00:00005DEC 000007A4        	  1583: 	dc.l	T15LockSemaphore
00:00005DF0 000007AA        	  1584: 	dc.l	T15UnlockSemaphore
00:00005DF4 00008248        	  1585: 	dc.l	prtflt
                            	  1586: 	; 40
00:00005DF8 000006EE        	  1587: 	dc.l  _GetRand
00:00005DFC 000007B0        	  1588: 	dc.l	T15GetFloat
00:00005E00 000007BE        	  1589: 	dc.l	T15Abort
00:00005E04 0000828E        	  1590: 	dc.l	T15FloatToString
                            	  1591: 
                            	  1592: ;------------------------------------------------------------------------------
                            	  1593: ; Cursor positioning / Clear screen
                            	  1594: ; - out of range settings are ignored
                            	  1595: ;
                            	  1596: ; Parameters:
                            	  1597: ;		d1.w cursor position, bits 0 to 7 are row, bits 8 to 15 are column.
                            	  1598: ;	Returns:
                            	  1599: ;		none
                            	  1600: ;------------------------------------------------------------------------------
                            	  1601: 
                            	  1602: Cursor1:
00:00005E08 2F01            	  1603: 	move.l d1,-(a7)
00:00005E0A 0C41FF00        	  1604: 	cmpi.w #$FF00,d1
00:00005E0E 660A            	  1605: 	bne.s .0002
00:00005E10 6100FBB8        	  1606: 	bsr	clear_screen
00:00005E14 221F            	  1607: 	move.l (a7)+,d1
00:00005E16 6000FEE2        	  1608: 	bra	HomeCursor
                            	  1609: .0002:
00:00005E1A B2390004008C    	  1610: 	cmp.b TextRows,d1		; if cursor pos out of range, ignore setting
00:00005E20 6406            	  1611: 	bhs.s	.0003
00:00005E22 13C100040000    	  1612: 	move.b d1,CursorRow
                            	  1613: .0003:
00:00005E28 E059            	  1614: 	ror.w	#8,d1
00:00005E2A B2390004008D    	  1615: 	cmp.b	TextCols,d1
00:00005E30 6406            	  1616: 	bhs.s	.0001
00:00005E32 13C100040001    	  1617: 	move.b d1,CursorCol
                            	  1618: .0001:
00:00005E38 6100FED2        	  1619: 	bsr SyncCursor			; update hardware cursor
00:00005E3C 221F            	  1620: 	move.l (a7)+,d1
00:00005E3E 4E75            	  1621: 	rts
                            	  1622: 
                            	  1623: ;------------------------------------------------------------------------------
                            	  1624: ; Stub routine for unimplemented functionality.
                            	  1625: ;------------------------------------------------------------------------------
                            	  1626: 
                            	  1627: StubRout:
00:00005E40 4E75            	  1628: 	rts
                            	  1629: 
                            	  1630: ;------------------------------------------------------------------------------
                            	  1631: ; Select a specific IO focus.
                            	  1632: ;------------------------------------------------------------------------------
                            	  1633: 
                            	  1634: select_iofocus:
00:00005E42 0C010002        	  1635: 	cmpi.b	#2,d1
00:00005E46 650A            	  1636: 	blo.s		.0001
00:00005E48 0C010005        	  1637: 	cmpi.b	#NCORES+1,d1
00:00005E4C 6204            	  1638: 	bhi.s		.0001
00:00005E4E 2001            	  1639: 	move.l	d1,d0
00:00005E50 6014            	  1640: 	bra.s		select_focus1
                            	  1641: .0001:
00:00005E52 4E75            	  1642: 	rts
                            	  1643: 
                            	  1644: ;------------------------------------------------------------------------------
                            	  1645: ; Rotate the IO focus, done when ALT-Tab is pressed.
                            	  1646: ;
                            	  1647: ; Modifies:
                            	  1648: ;		d0, IOFocus BIOS variable
                            	  1649: ;		updates the text screen pointer
                            	  1650: ;------------------------------------------------------------------------------
                            	  1651: 
                            	  1652: rotate_iofocus:
00:00005E54 103900100000    	  1653: 	move.b IOFocus,d0					; d0 = focus, we can trash d0
00:00005E5A 5200            	  1654: 	add.b	#1,d0								; increment the focus
00:00005E5C B03C0005        	  1655: 	cmp.b	#NCORES+1,d0				; limit to 2 to 9
00:00005E60 6304            	  1656: 	bls.s	.0001
00:00005E62 103C0002        	  1657: 	move.b #2,d0
                            	  1658: .0001:
                            	  1659: select_focus1:
00:00005E66 13C000100000    	  1660: 	move.b	d0,IOFocus				; set IO focus
                            	  1661: 	; reset keyboard processor to focus core
                            	  1662: ;	move.l #$3C060500,d0			; core=??,level sensitive,enabled,irq6,inta
                            	  1663: ;	or.b IOFocus,d0
                            	  1664: ;	move.l d0,PLIC+$80+4*30		; set register
                            	  1665: 	; Adjust text screen pointer
00:00005E6C 5500            	  1666: 	subi.b #2,d0							; screen is 0 to 7, focus is 2 to 9
00:00005E6E 4880            	  1667: 	ext.w	d0									; make into word value
00:00005E70 C0FC0800        	  1668: 	mulu #2048,d0							; * 2048	cells per screen
00:00005E74 E158            	  1669: 	rol.w	#8,d0								; swap byte order
00:00005E76 4840            	  1670: 	swap d0										; get bits 16-31
00:00005E78 E158            	  1671: 	rol.w	#8,d0								; swap byte order
00:00005E7A 23C0FD080028    	  1672: 	move.l d0,TEXTREG+$28			; update screen address in text controller
00:00005E80 6000FE8A        	  1673: 	bra	SyncCursor						; set cursor position
                            	  1674: 
                            	  1675: ;==============================================================================
                            	  1676: ; PLIC - platform level interrupt controller
                            	  1677: ;
                            	  1678: ; Register layout:
                            	  1679: ;   bits 0 to 7  = cause code to issue (vector number)
                            	  1680: ;   bits 8 to 11 = irq level to issue
                            	  1681: ;   bit 16 = irq enable
                            	  1682: ;   bit 17 = edge sensitivity
                            	  1683: ;   bit 18 = 0=vpa, 1=inta
                            	  1684: ;		bit 24 to 29 target core
                            	  1685: ;
                            	  1686: ; Note byte order must be reversed for PLIC.
                            	  1687: ;==============================================================================
                            	  1688: 
                            	  1689: init_plic:
00:00005E84 41F9FD090000    	  1690: 	lea	PLIC,a0							; a0 points to PLIC
00:00005E8A 43E800F4        	  1691: 	lea	$80+4*29(a0),a1			; point to timer registers (29)
00:00005E8E 22BC0006033F    	  1692: 	move.l #$0006033F,(a1)	; initialize, core=63,edge sensitive,enabled,irq6,vpa
00:00005E94 5889            	  1693: 	lea	4(a1),a1						; point to keyboard registers (30)
00:00005E96 22BC3C060502    	  1694: 	move.l #$3C060502,(a1)	; core=2,level sensitive,enabled,irq6,inta
00:00005E9C 5889            	  1695: 	lea	4(a1),a1						; point to nmi button register (31)
00:00005E9E 22BC00070302    	  1696: 	move.l #$00070302,(a1)	; initialize, core=2,edge sensitive,enabled,irq7,vpa
00:00005EA4 43E800C0        	  1697: 	lea	$80+4*16(a0),a1			; a1 points to ACIA register
00:00005EA8 22BC3D030502    	  1698: 	move.l #$3D030502,(a1)	; core=2,level sensitive,enabled,irq3,inta	
00:00005EAE 43E80090        	  1699: 	lea	$80+4*4(a0),a1			; a1 points to io_bitmap irq
00:00005EB2 22BC3B060702    	  1700: 	move.l #$3B060702,(a1)	; core=2,edge sensitive,enabled,irq6,inta	
00:00005EB8 4E75            	  1701: 	rts
                            	  1702: 
                            	  1703: ;==============================================================================
                            	  1704: ; Keyboard stuff
                            	  1705: ;
                            	  1706: ; KeyState2_
                            	  1707: ; 876543210
                            	  1708: ; ||||||||+ = shift
                            	  1709: ; |||||||+- = alt
                            	  1710: ; ||||||+-- = control
                            	  1711: ; |||||+--- = numlock
                            	  1712: ; ||||+---- = capslock
                            	  1713: ; |||+----- = scrolllock
                            	  1714: ; ||+------ =
                            	  1715: ; |+------- = 
                            	  1716: ; +-------- = extended
                            	  1717: ;
                            	  1718: ;==============================================================================
                            	  1719: 
                            	  1720: ;------------------------------------------------------------------------------
                            	  1721: ; Setup the Keyboard device
                            	  1722: ;------------------------------------------------------------------------------
                            	  1723: setup_keybd:
                            	  1724: keybd_init:
00:00005EBA 701F            	  1725: 	moveq #31,d0
00:00005EBC 41F900040A40    	  1726: 	lea.l keybd_dcb,a0
                            	  1727: .0001:
00:00005EC2 4298            	  1728: 	clr.l (a0)+
00:00005EC4 51C8FFFC        	  1729: 	dbra d0,.0001
00:00005EC8 23FC204243440004	  1730: 	move.l #$20424344,keybd_dcb+DCB_MAGIC				; 'DCB'
00:00005ED0 0A40
00:00005ED2 23FC2044424B0004	  1731: 	move.l #$2044424B,keybd_dcb+DCB_NAME				; 'KBD'
00:00005EDA 0A44
00:00005EDC 23FC00005F480004	  1732: 	move.l #keybd_cmdproc,con_dcb+DCB_CMDPROC
00:00005EE4 0A98
00:00005EE6 23FC001000200004	  1733: 	move.l #_KeybdBuf,keybd_dcb+DCB_INBUFPTR
00:00005EEE 0A68
00:00005EF0 23FC001000800004	  1734: 	move.l #_KeybdOBuf,keybd_dcb+DCB_OUTBUFPTR
00:00005EF8 0A6C
00:00005EFA 23FC000000200004	  1735: 	move.l #32,keybd_dcb+DCB_INBUFSIZE
00:00005F02 0A70
00:00005F04 23FC000000200004	  1736: 	move.l #32,keybd_dcb+DCB_OUTBUFSIZE
00:00005F0C 0A74
00:00005F0E 423900040A7B    	  1737: 	clr.b keybd_dcb+DCB_OUTCOLS	; set rows and columns
00:00005F14 423900040A7A    	  1738: 	clr.b keybd_dcb+DCB_OUTROWS
00:00005F1A 423900040A79    	  1739: 	clr.b keybd_dcb+DCB_INCOLS		; set rows and columns
00:00005F20 423900040A78    	  1740: 	clr.b keybd_dcb+DCB_INROWS
                            	  1741: ;	bsr KeybdInit
00:00005F26 4E75            	  1742: 	rts
                            	  1743: 
                            	  1744: 	align 2
                            	  1745: KBD_CMDTBL:
00:00005F28 00005EBA        	  1746: 	dc.l keybd_init
00:00005F2C 00005F6E        	  1747: 	dc.l keybd_stat
00:00005F30 00005F76        	  1748: 	dc.l keybd_putchar
00:00005F34 00005F86        	  1749: 	dc.l keybd_putbuf
00:00005F38 00005F7E        	  1750: 	dc.l keybd_getchar
00:00005F3C 00005F86        	  1751: 	dc.l keybd_getbuf
00:00005F40 00005F86        	  1752: 	dc.l keybd_set_inpos
00:00005F44 00005F86        	  1753: 	dc.l keybd_set_outpos
                            	  1754: 
                            	  1755: keybd_cmdproc:
00:00005F48 0C060008        	  1756: 	cmpi.b #8,d6
00:00005F4C 641C            	  1757: 	bhs.s .0001
00:00005F4E 4A06            	  1758: 	tst.b d6
00:00005F50 6B18            	  1759: 	bmi.s .0001
00:00005F52 48E70280        	  1760: 	movem.l d6/a0,-(a7)
00:00005F56 E506            	  1761: 	asl.b #2,d6
00:00005F58 4886            	  1762: 	ext.w d6
00:00005F5A 41FAFFCC        	  1763: 	lea KBD_CMDTBL,a0
00:00005F5E 20706000        	  1764: 	move.l (a0,d6.w),a0
00:00005F62 4E90            	  1765: 	jsr (a0)
00:00005F64 4CDF0140        	  1766: 	movem.l (a7)+,d6/a0
00:00005F68 4E75            	  1767: 	rts
                            	  1768: .0001:
00:00005F6A 7002            	  1769: 	moveq #E_Func,d0
00:00005F6C 4E75            	  1770: 	rts
                            	  1771: 
                            	  1772: keybd_stat:
00:00005F6E 61000196        	  1773: 	bsr _KeybdGetStatus
00:00005F72 7000            	  1774: 	moveq #E_Ok,d0
00:00005F74 4E75            	  1775: 	rts
                            	  1776: 
                            	  1777: keybd_putchar:
00:00005F76 610004FC        	  1778: 	bsr KeybdSendByte
00:00005F7A 7000            	  1779: 	moveq #E_Ok,d0
00:00005F7C 4E75            	  1780: 	rts
                            	  1781: 
                            	  1782: keybd_getchar:
00:00005F7E 61000234        	  1783: 	bsr GetKey
00:00005F82 7000            	  1784: 	moveq #E_Ok,d0
00:00005F84 4E75            	  1785: 	rts
                            	  1786: 
                            	  1787: keybd_putbuf:
                            	  1788: keybd_getbuf:
                            	  1789: keybd_set_inpos:
                            	  1790: keybd_set_outpos:
00:00005F86 700A            	  1791: 	moveq #E_NotSupported,d0
00:00005F88 4E75            	  1792: 	rts
                            	  1793: 
                            	  1794: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1795: ; Get ID - get the keyboards identifier code.
                            	  1796: ;
                            	  1797: ; Parameters: none
                            	  1798: ; Returns: d = $AB83, $00 on fail
                            	  1799: ; Modifies: d, KeybdID updated
                            	  1800: ; Stack Space: 2 words
                            	  1801: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1802: 
                            	  1803: KeybdGetID:
00:00005F8A 323C00F2        	  1804: 	move.w	#$F2,d1
00:00005F8E 610004E4        	  1805: 	bsr			KeybdSendByte
00:00005F92 610001E6        	  1806: 	bsr			KeybdWaitTx
00:00005F96 610001C0        	  1807: 	bsr			KeybdRecvByte
00:00005F9A 08010007        	  1808: 	btst		#7,d1
00:00005F9E 6624            	  1809: 	bne			kgnotKbd
00:00005FA0 0C0100AB        	  1810: 	cmpi.b	#$AB,d1
00:00005FA4 661E            	  1811: 	bne			kgnotKbd
00:00005FA6 610001B0        	  1812: 	bsr			KeybdRecvByte
00:00005FAA 08010007        	  1813: 	btst		#7,d1
00:00005FAE 6614            	  1814: 	bne			kgnotKbd
00:00005FB0 0C010083        	  1815: 	cmpi.b	#$83,d1
00:00005FB4 660E            	  1816: 	bne			kgnotKbd
00:00005FB6 223C0000AB83    	  1817: 	move.l	#$AB83,d1
                            	  1818: kgid1:
00:00005FBC 33C100100018    	  1819: 	move.w	d1,KeybdID
00:00005FC2 4E75            	  1820: 	rts
                            	  1821: kgnotKbd:
00:00005FC4 7200            	  1822: 	moveq		#0,d1
00:00005FC6 60F4            	  1823: 	bra			kgid1
                            	  1824: 
                            	  1825: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1826: ; Set the LEDs on the keyboard.
                            	  1827: ;
                            	  1828: ; Parameters:
                            	  1829: ;		d1.b = LED state
                            	  1830: ;	Modifies:
                            	  1831: ;		none
                            	  1832: ; Returns:
                            	  1833: ;		none
                            	  1834: ; Stack Space:
                            	  1835: ;		1 long word
                            	  1836: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1837: 
                            	  1838: KeybdSetLED:
00:00005FC8 2F01            	  1839: 	move.l	d1,-(a7)
00:00005FCA 123C00ED        	  1840: 	move.b	#$ED,d1
00:00005FCE 610004A4        	  1841: 	bsr			KeybdSendByte
00:00005FD2 610001A6        	  1842: 	bsr			KeybdWaitTx
00:00005FD6 61000180        	  1843: 	bsr			KeybdRecvByte
00:00005FDA 4A01            	  1844: 	tst.b		d1
00:00005FDC 6B12            	  1845: 	bmi			.0001
00:00005FDE 0C0100FA        	  1846: 	cmpi.b	#$FA,d1
00:00005FE2 2217            	  1847: 	move.l	(a7),d1
00:00005FE4 6100048E        	  1848: 	bsr			KeybdSendByte
00:00005FE8 61000190        	  1849: 	bsr			KeybdWaitTx
00:00005FEC 6100016A        	  1850: 	bsr			KeybdRecvByte
                            	  1851: .0001:
00:00005FF0 221F            	  1852: 	move.l	(a7)+,d1
00:00005FF2 4E75            	  1853: 	rts
                            	  1854: 
                            	  1855: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1856: ; Initialize the keyboard.
                            	  1857: ;
                            	  1858: ; Parameters:
                            	  1859: ;		none
                            	  1860: ;	Modifies:
                            	  1861: ;		none
                            	  1862: ; Returns:
                            	  1863: ;		none
                            	  1864: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1865: 
                            	  1866: _KeybdInit:
                            	  1867: KeybdInit:
                            	  1868: ;	movem.l	d0/d1/d3/a1,-(a7)
00:00005FF4 42390010000F    	  1869: 	clr.b	_KeyState1		; records key up/down state
00:00005FFA 423900100010    	  1870: 	clr.b	_KeyState2		; records shift,ctrl,alt state
00:00006000 4E75            	  1871: 	rts
                            	  1872: 
00:00006002 61000494        	  1873: 	bsr			Wait300ms
00:00006006 610000FE        	  1874: 	bsr			_KeybdGetStatus	; wait for response from keyboard
00:0000600A 4A01            	  1875: 	tst.b		d1
00:0000600C 6A10            	  1876: 	bpl			.0001					; is input buffer full ? no, branch
00:0000600E 61000114        	  1877: 	bsr	_KeybdGetScancode
00:00006012 6100012E        	  1878: 	bsr _KeybdClearIRQ
00:00006016 0C0100AA        	  1879: 	cmpi.b	#$AA,d1				; keyboard Okay
00:0000601A 67000098        	  1880: 	beq			kbdi0005
                            	  1881: .0001:
00:0000601E 760A            	  1882: 	moveq		#10,d3
                            	  1883: kbdi0002:
00:00006020 6100045A        	  1884: 	bsr			Wait10ms
00:00006024 4239FD0FFE01    	  1885: 	clr.b		KEYBD+1				; clear receive register (write $00 to status reg)
00:0000602A 6100A600        	  1886: 	bsr net_delay
00:0000602E 72FF            	  1887: 	moveq		#-1,d1				; send reset code to keyboard
00:00006030 13C1FD0FFE01    	  1888: 	move.b	d1,KEYBD+1		; write $FF to status reg to clear TX state
00:00006036 6100A5F4        	  1889: 	bsr net_delay
00:0000603A 61000438        	  1890: 	bsr			KeybdSendByte	; now write ($FF) to transmit register for reset
00:0000603E 6100013A        	  1891: 	bsr			KeybdWaitTx		; wait until no longer busy
00:00006042 4A81            	  1892: 	tst.l		d1
00:00006044 6B000088        	  1893: 	bmi			kbdiXmitBusy
00:00006048 6100010E        	  1894: 	bsr			KeybdRecvByte	; look for an ACK ($FA)
00:0000604C 0C0100FA        	  1895: 	cmpi.b	#$FA,d1
00:00006050 6604            	  1896: 	bne			.0001
00:00006052 61000104        	  1897: 	bsr			KeybdRecvByte	; look for BAT completion code ($AA)
                            	  1898: .0001:
00:00006056 0C0100FC        	  1899: 	cmpi.b	#$FC,d1				; reset error ?
00:0000605A 672E            	  1900: 	beq			kbdiTryAgain
00:0000605C 0C0100AA        	  1901: 	cmpi.b	#$AA,d1				; reset complete okay ?
00:00006060 6628            	  1902: 	bne			kbdiTryAgain
                            	  1903: 
                            	  1904: 	; After a reset, scan code set #2 should be active
                            	  1905: .config:
00:00006062 323C00F0        	  1906: 	move.w	#$F0,d1			; send scan code select
00:00006066 13C1FD0FFF00    	  1907: 	move.b	d1,leds
00:0000606C 6100A5BE        	  1908: 	bsr net_delay
00:00006070 61000402        	  1909: 	bsr			KeybdSendByte
00:00006074 61000104        	  1910: 	bsr			KeybdWaitTx
00:00006078 4A81            	  1911: 	tst.l		d1
00:0000607A 6B52            	  1912: 	bmi			kbdiXmitBusy
00:0000607C 610000DA        	  1913: 	bsr			KeybdRecvByte	; wait for response from keyboard
00:00006080 4A41            	  1914: 	tst.w		d1
00:00006082 6B06            	  1915: 	bmi			kbdiTryAgain
00:00006084 0C0100FA        	  1916: 	cmpi.b	#$FA,d1				; ACK
00:00006088 670E            	  1917: 	beq			kbdi0004
                            	  1918: kbdiTryAgain:
00:0000608A 51CBFF94        	  1919: 	dbra		d3,kbdi0002
                            	  1920: .keybdErr:
00:0000608E 43FA004C        	  1921: 	lea			msgBadKeybd,a1
00:00006092 6100FC3A        	  1922: 	bsr			DisplayStringCRLF
00:00006096 6020            	  1923: 	bra			ledxit
                            	  1924: kbdi0004:
00:00006098 7202            	  1925: 	moveq		#2,d1			; select scan code set #2
00:0000609A 610003D8        	  1926: 	bsr			KeybdSendByte
00:0000609E 610000DA        	  1927: 	bsr			KeybdWaitTx
00:000060A2 4A81            	  1928: 	tst.l		d1
00:000060A4 6B28            	  1929: 	bmi			kbdiXmitBusy
00:000060A6 610000B0        	  1930: 	bsr			KeybdRecvByte	; wait for response from keyboard
00:000060AA 4A41            	  1931: 	tst.w		d1
00:000060AC 6BDC            	  1932: 	bmi			kbdiTryAgain
00:000060AE 0C0100FA        	  1933: 	cmpi.b	#$FA,d1
00:000060B2 66D6            	  1934: 	bne			kbdiTryAgain
                            	  1935: kbdi0005:
00:000060B4 6100FED4        	  1936: 	bsr			KeybdGetID
                            	  1937: ledxit:
00:000060B8 7207            	  1938: 	moveq		#$07,d1
00:000060BA 6100FF0C        	  1939: 	bsr			KeybdSetLED
00:000060BE 610003D8        	  1940: 	bsr			Wait300ms
00:000060C2 7200            	  1941: 	moveq		#$00,d1
00:000060C4 6100FF02        	  1942: 	bsr			KeybdSetLED
00:000060C8 4CDF020B        	  1943: 	movem.l	(a7)+,d0/d1/d3/a1
00:000060CC 4E75            	  1944: 	rts
                            	  1945: kbdiXmitBusy:
00:000060CE 43FA001B        	  1946: 	lea			msgXmitBusy,a1
00:000060D2 6100FBFA        	  1947: 	bsr			DisplayStringCRLF
00:000060D6 4CDF020B        	  1948: 	movem.l	(a7)+,d0/d1/d3/a1
00:000060DA 4E75            	  1949: 	rts
                            	  1950: 	
                            	  1951: msgBadKeybd:
00:000060DC 4B6579626F617264	  1952: 	dc.b		"Keyboard error",0
00:000060E4 206572726F72
00:000060EA 00
                            	  1953: msgXmitBusy:
00:000060EB 4B6579626F617264	  1954: 	dc.b		"Keyboard transmitter stuck",0
00:000060F3 207472616E736D69
00:000060FB 7474657220737475
00:00006103 636B
00:00006105 00
                            	  1955: 
                            	  1956: 	even
                            	  1957: _KeybdGetStatus:
00:00006106 4E7A1FE0        	  1958: 	movec coreno,d1
00:0000610A 0C010002        	  1959: 	cmpi.b #2,d1
00:0000610E 660A            	  1960: 	bne .0001
00:00006110 7200            	  1961: 	moveq	#0,d1
00:00006112 1239FD0FFE01    	  1962: 	move.b KEYBD+1,d1
00:00006118 4E75            	  1963: 	rts
                            	  1964: .0001:
00:0000611A 7200            	  1965: 	moveq #0,d1
00:0000611C 1239FD0FFE03    	  1966: 	move.b KEYBD+3,d1
00:00006122 4E75            	  1967: 	rts
                            	  1968: 
                            	  1969: ; Get the scancode from the keyboard port
                            	  1970: 
                            	  1971: _KeybdGetScancode:
00:00006124 4E7A1FE0        	  1972: 	movec coreno,d1
00:00006128 0C010002        	  1973: 	cmpi.b #2,d1
00:0000612C 660A            	  1974: 	bne .0001
00:0000612E 7200            	  1975: 	moveq		#0,d1
00:00006130 1239FD0FFE00    	  1976: 	move.b	KEYBD,d1				; get the scan code
00:00006136 4E75            	  1977: 	rts
                            	  1978: .0001:
00:00006138 7200            	  1979: 	moveq #0,d1
00:0000613A 1239FD0FFE02    	  1980: 	move.b KEYBD+2,d1
00:00006140 4E75            	  1981: 	rts
                            	  1982: 
                            	  1983: _KeybdClearIRQ:
00:00006142 2F01            	  1984: 	move.l d1,-(a7)
00:00006144 4E7A1FE0        	  1985: 	movec coreno,d1
00:00006148 0C010002        	  1986: 	cmpi.b #2,d1
00:0000614C 6606            	  1987: 	bne .0001
00:0000614E 4239FD0FFE01    	  1988: 	move.b	#0,KEYBD+1			; clear receive register
                            	  1989: .0001:
00:00006154 221F            	  1990: 	move.l (a7)+,d1
00:00006156 4E75            	  1991: 	rts
                            	  1992: 
                            	  1993: ; Recieve a byte from the keyboard, used after a command is sent to the
                            	  1994: ; keyboard in order to wait for a response.
                            	  1995: ;
                            	  1996: KeybdRecvByte:
00:00006158 2F03            	  1997: 	move.l	d3,-(a7)
00:0000615A 363C0064        	  1998: 	move.w	#100,d3		; wait up to 1s
                            	  1999: .0003:
00:0000615E 61A6            	  2000: 	bsr			_KeybdGetStatus	; wait for response from keyboard
00:00006160 4A01            	  2001: 	tst.b		d1
00:00006162 6B0E            	  2002: 	bmi			.0004			; is input buffer full ? yes, branch
00:00006164 61000316        	  2003: 	bsr			Wait10ms	; wait a bit
00:00006168 51CBFFF4        	  2004: 	dbra		d3,.0003	; go back and try again
00:0000616C 261F            	  2005: 	move.l	(a7)+,d3
00:0000616E 72FF            	  2006: 	moveq		#-1,d1		; return -1
00:00006170 4E75            	  2007: 	rts
                            	  2008: .0004:
00:00006172 61B0            	  2009: 	bsr	_KeybdGetScancode
00:00006174 61CC            	  2010: 	bsr _KeybdClearIRQ
00:00006176 261F            	  2011: 	move.l	(a7)+,d3
00:00006178 4E75            	  2012: 	rts
                            	  2013: 
                            	  2014: 
                            	  2015: ; Wait until the keyboard transmit is complete
                            	  2016: ; Returns -1 if timedout, 0 if transmit completed
                            	  2017: ;
                            	  2018: KeybdWaitTx:
00:0000617A 48E73000        	  2019: 	movem.l	d2/d3,-(a7)
00:0000617E 7664            	  2020: 	moveq		#100,d3		; wait a max of 1s
                            	  2021: .0001:
00:00006180 6184            	  2022: 	bsr	_KeybdGetStatus
00:00006182 08010006        	  2023: 	btst #6,d1				; check for transmit complete bit
00:00006186 6610            	  2024: 	bne	.0002					; branch if bit set
00:00006188 610002F2        	  2025: 	bsr	Wait10ms			; delay a little bit
00:0000618C 51CBFFF2        	  2026: 	dbra d3,.0001			; go back and try again
00:00006190 4CDF000C        	  2027: 	movem.l	(a7)+,d2/d3
00:00006194 72FF            	  2028: 	moveq	#-1,d1			; return -1
00:00006196 4E75            	  2029: 	rts
                            	  2030: .0002:
00:00006198 4CDF000C        	  2031: 	movem.l	(a7)+,d2/d3
00:0000619C 7200            	  2032: 	moveq	#0,d1		; return 0
00:0000619E 4E75            	  2033: 	rts
                            	  2034: 
                            	  2035: ;------------------------------------------------------------------------------
                            	  2036: ; d1.b 0=echo off, non-zero = echo on
                            	  2037: ;------------------------------------------------------------------------------
                            	  2038: 
                            	  2039: SetKeyboardEcho:
00:000061A0 13C10004000C    	  2040: 	move.b	d1,KeybdEcho
00:000061A6 4E75            	  2041: 	rts
                            	  2042: 
                            	  2043: ;------------------------------------------------------------------------------
                            	  2044: ; Get key pending status into d1.b
                            	  2045: ;
                            	  2046: ; Returns:
                            	  2047: ;		d1.b = 1 if a key is available, otherwise zero.
                            	  2048: ;------------------------------------------------------------------------------
                            	  2049: 
                            	  2050: CheckForKey:
00:000061A8 7200            	  2051: 	moveq.l	#0,d1					; clear high order bits
                            	  2052: ;	move.b	KEYBD+1,d1		; get keyboard port status
                            	  2053: ;	smi.b		d1						; set true/false
                            	  2054: ;	andi.b	#1,d1					; return true (1) if key available, 0 otherwise
00:000061AA 4A3900100013    	  2055: 	tst.b	_KeybdCnt
00:000061B0 56C1            	  2056: 	sne.b	d1
00:000061B2 4E75            	  2057: 	rts
                            	  2058: 
                            	  2059: ;------------------------------------------------------------------------------
                            	  2060: ; GetKey
                            	  2061: ; 	Get a character from the keyboard. 
                            	  2062: ;
                            	  2063: ; Modifies:
                            	  2064: ;		d1
                            	  2065: ; Returns:
                            	  2066: ;		d1 = -1 if no key available or not in focus, otherwise key
                            	  2067: ;------------------------------------------------------------------------------
                            	  2068: 
                            	  2069: GetKey:
00:000061B4 2F00            	  2070: 	move.l	d0,-(a7)					; push d0
00:000061B6 123900100000    	  2071: 	move.b	IOFocus,d1				; Check if the core has the IO focus
00:000061BC 4E7A0FE0        	  2072: 	movec.l	coreno,d0
00:000061C0 B200            	  2073: 	cmp.b	d0,d1
00:000061C2 6622            	  2074: 	bne.s	.0004								; go return no key available, if not in focus
00:000061C4 6132            	  2075: 	bsr	KeybdGetCharNoWait		; get a character
00:000061C6 4A81            	  2076: 	tst.l	d1									; was a key available?
00:000061C8 6B1C            	  2077: 	bmi.s	.0004
00:000061CA 4A390004000C    	  2078: 	tst.b	KeybdEcho						; is keyboard echo on ?
00:000061D0 6710            	  2079: 	beq.s	.0003								; no echo, just return the key
00:000061D2 0C01000D        	  2080: 	cmpi.b #CR,d1							; convert CR keystroke into CRLF
00:000061D6 6606            	  2081: 	bne.s	.0005
00:000061D8 6100F82C        	  2082: 	bsr	CRLF
00:000061DC 6004            	  2083: 	bra.s	.0003
                            	  2084: .0005:
00:000061DE 6100210A        	  2085: 	bsr	OutputChar
                            	  2086: .0003:
00:000061E2 201F            	  2087: 	move.l (a7)+,d0						; pop d0
00:000061E4 4E75            	  2088: 	rts												; return key
                            	  2089: ; Return -1 indicating no char was available
                            	  2090: .0004:
00:000061E6 201F            	  2091: 	move.l (a7)+,d0						; pop d0
00:000061E8 72FF            	  2092: 	moveq	#-1,d1							; return no key available
00:000061EA 4E75            	  2093: 	rts
                            	  2094: 
                            	  2095: CheckForCtrlC:
00:000061EC 610A            	  2096: 	bsr	KeybdGetCharNoWait
00:000061EE 0C010003        	  2097: 	cmpi.b #CTRLC,d1
00:000061F2 6700072C        	  2098: 	beq	Monitor
00:000061F6 4E75            	  2099: 	rts
                            	  2100: 
                            	  2101: ;------------------------------------------------------------------------------
                            	  2102: ;------------------------------------------------------------------------------
                            	  2103: 
                            	  2104: KeybdGetCharNoWait:
00:000061F8 42390004000D    	  2105: 	clr.b	KeybdWaitFlag
00:000061FE 6008            	  2106: 	bra	KeybdGetChar
                            	  2107: 
                            	  2108: KeybdGetCharWait:
00:00006200 13FC00FF0004000D	  2109: 	move.b #-1,KeybdWaitFlag
                            	  2110: 
                            	  2111: KeybdGetChar:
00:00006208 48E7B080        	  2112: 	movem.l	d0/d2/d3/a0,-(a7)
                            	  2113: .0003:
00:0000620C 4E7A0FE0        	  2114: 	movec	coreno,d0
00:00006210 4840            	  2115: 	swap d0
00:00006212 7203            	  2116: 	moveq	#KEYBD_SEMA,d1
00:00006214 6100A536        	  2117: 	bsr	LockSemaphore
00:00006218 143900100013    	  2118: 	move.b	_KeybdCnt,d2		; get count of buffered scan codes
00:0000621E 673E            	  2119: 	beq.s		.0015						;
00:00006220 143900100011    	  2120: 	move.b	_KeybdHead,d2		; d2 = buffer head
00:00006226 4882            	  2121: 	ext.w		d2
00:00006228 41F900100020    	  2122: 	lea			_KeybdBuf,a0		; a0 = pointer to keyboard buffer
00:0000622E 7200            	  2123: 	clr.l		d1
00:00006230 12302000        	  2124: 	move.b	(a0,d2.w),d1		; d1 = scan code from buffer
00:00006234 5202            	  2125: 	addi.b	#1,d2						; increment keyboard head index
00:00006236 0202001F        	  2126: 	andi.b	#31,d2					; and wrap around at buffer size
00:0000623A 13C200100011    	  2127: 	move.b	d2,_KeybdHead
00:00006240 533900100013    	  2128: 	subi.b	#1,_KeybdCnt		; decrement count of scan codes in buffer
00:00006246 C342            	  2129: 	exg			d1,d2						; save scancode value in d2
00:00006248 4E7A0FE0        	  2130: 	movec		coreno,d0
00:0000624C 4840            	  2131: 	swap		d0
00:0000624E 7203            	  2132: 	moveq		#KEYBD_SEMA,d1
00:00006250 6100A536        	  2133: 	bsr			UnlockSemaphore
00:00006254 C541            	  2134: 	exg			d2,d1						; restore scancode value
00:00006256 602A            	  2135: 	bra			.0001						; go process scan code
                            	  2136: .0014:
00:00006258 6100FEAC        	  2137: 	bsr		_KeybdGetStatus		; check keyboard status for key available
00:0000625C 6B1C            	  2138: 	bmi		.0006							; yes, go process
                            	  2139: .0015:
00:0000625E 4E7A0FE0        	  2140: 	movec		coreno,d0
00:00006262 4840            	  2141: 	swap		d0
00:00006264 7203            	  2142: 	moveq		#KEYBD_SEMA,d1
00:00006266 6100A520        	  2143: 	bsr			UnlockSemaphore
00:0000626A 4A390004000D    	  2144: 	tst.b		KeybdWaitFlag			; are we willing to wait for a key ?
00:00006270 6B9A            	  2145: 	bmi			.0003							; yes, branch back
00:00006272 4CDF010D        	  2146: 	movem.l	(a7)+,d0/d2/d3/a0
00:00006276 72FF            	  2147: 	moveq		#-1,d1						; flag no char available
00:00006278 4E75            	  2148: 	rts
                            	  2149: .0006:
00:0000627A 6100FEA8        	  2150: 	bsr	_KeybdGetScancode
00:0000627E 6100FEC2        	  2151: 	bsr _KeybdClearIRQ
                            	  2152: .0001:
00:00006282 33FC0001FD0FFF00	  2153: 	move.w	#1,leds
00:0000628A B23C00F0        	  2154: 	cmp.b	#SC_KEYUP,d1
00:0000628E 670000C0        	  2155: 	beq		.doKeyup
00:00006292 B23C00E0        	  2156: 	cmp.b	#SC_EXTEND,d1
00:00006296 670000C4        	  2157: 	beq		.doExtend
00:0000629A B23C0014        	  2158: 	cmp.b	#SC_CTRL,d1
00:0000629E 670000C8        	  2159: 	beq		.doCtrl
00:000062A2 B23C0012        	  2160: 	cmp.b	#SC_LSHIFT,d1
00:000062A6 6700012A        	  2161: 	beq		.doShift
00:000062AA B23C0059        	  2162: 	cmp.b	#SC_RSHIFT,d1
00:000062AE 67000122        	  2163: 	beq		.doShift
00:000062B2 B23C0077        	  2164: 	cmp.b	#SC_NUMLOCK,d1
00:000062B6 67000142        	  2165: 	beq		.doNumLock
00:000062BA B23C0058        	  2166: 	cmp.b	#SC_CAPSLOCK,d1
00:000062BE 67000148        	  2167: 	beq		.doCapsLock
00:000062C2 B23C007E        	  2168: 	cmp.b	#SC_SCROLLLOCK,d1
00:000062C6 6700014E        	  2169: 	beq		.doScrollLock
00:000062CA B23C0011        	  2170: 	cmp.b   #SC_ALT,d1
00:000062CE 670000C0        	  2171: 	beq     .doAlt
00:000062D2 14390010000F    	  2172: 	move.b	_KeyState1,d2			; check key up/down
00:000062D8 42390010000F    	  2173: 	move.b	#0,_KeyState1			; clear keyup status
00:000062DE 4A02            	  2174: 	tst.b	d2
00:000062E0 6600FF2A        	  2175: 	bne	    .0003					; ignore key up
00:000062E4 B23C000D        	  2176: 	cmp.b   #SC_TAB,d1
00:000062E8 670000CE        	  2177: 	beq     .doTab
                            	  2178: .0013:
00:000062EC 143900100010    	  2179: 	move.b	_KeyState2,d2
00:000062F2 6A1A            	  2180: 	bpl		.0010					; is it extended code ?
00:000062F4 C43C007F        	  2181: 	and.b	#$7F,d2					; clear extended bit
00:000062F8 13C200100010    	  2182: 	move.b	d2,_KeyState2
00:000062FE 42390010000F    	  2183: 	move.b	#0,_KeyState1			; clear keyup
00:00006304 41FA04E4        	  2184: 	lea		_keybdExtendedCodes,a0
00:00006308 12301000        	  2185: 	move.b	(a0,d1.w),d1
00:0000630C 6034            	  2186: 	bra		.0008
                            	  2187: .0010:
00:0000630E 08020002        	  2188: 	btst	#2,d2					; is it CTRL code ?
00:00006312 670E            	  2189: 	beq		.0009
00:00006314 C27C007F        	  2190: 	and.w	#$7F,d1
00:00006318 41FA0450        	  2191: 	lea		_keybdControlCodes,a0
00:0000631C 12301000        	  2192: 	move.b	(a0,d1.w),d1
00:00006320 6020            	  2193: 	bra		.0008
                            	  2194: .0009:
00:00006322 08020000        	  2195: 	btst	#0,d2					; is it shift down ?
00:00006326 670A            	  2196: 	beq  	.0007
00:00006328 41FA0340        	  2197: 	lea		_shiftedScanCodes,a0
00:0000632C 12301000        	  2198: 	move.b	(a0,d1.w),d1
00:00006330 6010            	  2199: 	bra		.0008
                            	  2200: .0007:
00:00006332 41FA0236        	  2201: 	lea		_unshiftedScanCodes,a0
00:00006336 12301000        	  2202: 	move.b	(a0,d1.w),d1
00:0000633A 33FC0202FD0FFF00	  2203: 	move.w	#$0202,leds
                            	  2204: .0008:
00:00006342 33FC0303FD0FFF00	  2205: 	move.w	#$0303,leds
00:0000634A 4CDF010D        	  2206: 	movem.l	(a7)+,d0/d2/d3/a0
00:0000634E 4E75            	  2207: 	rts
                            	  2208: .doKeyup:
00:00006350 13FC00FF0010000F	  2209: 	move.b	#-1,_KeyState1
00:00006358 6000FEB2        	  2210: 	bra		.0003
                            	  2211: .doExtend:
00:0000635C 0039008000100010	  2212: 	or.b	#$80,_KeyState2
00:00006364 6000FEA6        	  2213: 	bra		.0003
                            	  2214: .doCtrl:
00:00006368 12390010000F    	  2215: 	move.b	_KeyState1,d1
00:0000636E 42390010000F    	  2216: 	clr.b	_KeyState1
00:00006374 4A01            	  2217: 	tst.b	d1
00:00006376 6A0C            	  2218: 	bpl.s	.0004
00:00006378 08B9000200100010	  2219: 	bclr	#2,_KeyState2
00:00006380 6000FE8A        	  2220: 	bra		.0003
                            	  2221: .0004:
00:00006384 08F9000200100010	  2222: 	bset	#2,_KeyState2
00:0000638C 6000FE7E        	  2223: 	bra		.0003
                            	  2224: .doAlt:
00:00006390 12390010000F    	  2225: 	move.b	_KeyState1,d1
00:00006396 42390010000F    	  2226: 	clr.b	_KeyState1
00:0000639C 4A01            	  2227: 	tst.b	d1
00:0000639E 6A0C            	  2228: 	bpl		.0011
00:000063A0 08B9000100100010	  2229: 	bclr	#1,_KeyState2
00:000063A8 6000FE62        	  2230: 	bra		.0003
                            	  2231: .0011:
00:000063AC 08F9000100100010	  2232: 	bset	#1,_KeyState2
00:000063B4 6000FE56        	  2233: 	bra		.0003
                            	  2234: .doTab:
00:000063B8 2F01            	  2235: 	move.l	d1,-(a7)
00:000063BA 123900100010    	  2236:   move.b  _KeyState2,d1
00:000063C0 08010001        	  2237:   btst	#1,d1                 ; is ALT down ?
00:000063C4 6706            	  2238:   beq     .0012
                            	  2239: ;    	inc     _iof_switch
00:000063C6 221F            	  2240:   move.l	(a7)+,d1
00:000063C8 6000FE42        	  2241:   bra     .0003
                            	  2242: .0012:
00:000063CC 221F            	  2243:   move.l	(a7)+,d1
00:000063CE 6000FF1C        	  2244:   bra     .0013
                            	  2245: .doShift:
00:000063D2 12390010000F    	  2246: 	move.b	_KeyState1,d1
00:000063D8 42390010000F    	  2247: 	clr.b	_KeyState1
00:000063DE 4A01            	  2248: 	tst.b	d1
00:000063E0 6A0C            	  2249: 	bpl.s	.0005
00:000063E2 08B9000000100010	  2250: 	bclr	#0,_KeyState2
00:000063EA 6000FE20        	  2251: 	bra		.0003
                            	  2252: .0005:
00:000063EE 08F9000000100010	  2253: 	bset	#0,_KeyState2
00:000063F6 6000FE14        	  2254: 	bra		.0003
                            	  2255: .doNumLock:
00:000063FA 0879000400100010	  2256: 	bchg	#4,_KeyState2
00:00006402 6120            	  2257: 	bsr		KeybdSetLEDStatus
00:00006404 6000FE06        	  2258: 	bra		.0003
                            	  2259: .doCapsLock:
00:00006408 0879000500100010	  2260: 	bchg	#5,_KeyState2
00:00006410 6112            	  2261: 	bsr		KeybdSetLEDStatus
00:00006412 6000FDF8        	  2262: 	bra		.0003
                            	  2263: .doScrollLock:
00:00006416 0879000600100010	  2264: 	bchg	#6,_KeyState2
00:0000641E 6104            	  2265: 	bsr		KeybdSetLEDStatus
00:00006420 6000FDEA        	  2266: 	bra		.0003
                            	  2267: 
                            	  2268: KeybdSetLEDStatus:
00:00006424 48E73000        	  2269: 	movem.l	d2/d3,-(a7)
00:00006428 42390010000E    	  2270: 	clr.b		KeybdLEDs
00:0000642E 0839000400100010	  2271: 	btst		#4,_KeyState2
00:00006436 6708            	  2272: 	beq.s		.0002
00:00006438 13FC00020010000E	  2273: 	move.b	#2,KeybdLEDs
                            	  2274: .0002:
00:00006440 0839000500100010	  2275: 	btst		#5,_KeyState2
00:00006448 6708            	  2276: 	beq.s		.0003
00:0000644A 08F900020010000E	  2277: 	bset		#2,KeybdLEDs
                            	  2278: .0003:
00:00006452 0839000600100010	  2279: 	btst		#6,_KeyState2
00:0000645A 6708            	  2280: 	beq.s		.0004
00:0000645C 08F900000010000E	  2281: 	bset		#0,KeybdLEDs
                            	  2282: .0004:
00:00006464 12390010000E    	  2283: 	move.b	KeybdLEDs,d1
00:0000646A 6100FB5C        	  2284: 	bsr			KeybdSetLED
00:0000646E 4CDF000C        	  2285: 	movem.l	(a7)+,d2/d3
00:00006472 4E75            	  2286: 	rts
                            	  2287: 
                            	  2288: KeybdSendByte:
00:00006474 13C1FD0FFE00    	  2289: 	move.b d1,KEYBD
00:0000647A 4E75            	  2290: 	rts
                            	  2291: 	
                            	  2292: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2293: ; Wait for 10 ms
                            	  2294: ;
                            	  2295: ; Parameters: none
                            	  2296: ; Returns: none
                            	  2297: ; Modifies: none
                            	  2298: ; Stack Space: 2 long words
                            	  2299: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2300: 
                            	  2301: Wait10ms:
00:0000647C 48E7C000        	  2302: 	movem.l	d0/d1,-(a7)
00:00006480 4E7A0FF0        	  2303: 	movec	tick,d0
00:00006484 068000061A80    	  2304: 	addi.l #400000,d0			; 400,000 cycles at 40MHz
                            	  2305: .0001:
00:0000648A 4E7A1FF0        	  2306: 	movec	tick,d1
00:0000648E B081            	  2307: 	cmp.l	d1,d0
00:00006490 62F8            	  2308: 	bhi	.0001
00:00006492 4CDF0003        	  2309: 	movem.l	(a7)+,d0/d1
00:00006496 4E75            	  2310: 	rts
                            	  2311: 
                            	  2312: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2313: ; Wait for 300 ms
                            	  2314: ;
                            	  2315: ; Parameters: none
                            	  2316: ; Returns: none
                            	  2317: ; Modifies: none
                            	  2318: ; Stack Space: 2 long words
                            	  2319: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2320: 
                            	  2321: Wait300ms:
00:00006498 48E7C000        	  2322: 	movem.l	d0/d1,-(a7)
00:0000649C 4E7A0FF0        	  2323: 	movec		tick,d0
00:000064A0 068000B71B00    	  2324: 	addi.l	#12000000,d0			; 12,000,000 cycles at 40MHz
                            	  2325: .0001:
00:000064A6 4E7A1FF0        	  2326: 	movec		tick,d1
00:000064AA B081            	  2327: 	cmp.l		d1,d0
00:000064AC 62F8            	  2328: 	bhi			.0001
00:000064AE 4CDF0003        	  2329: 	movem.l	(a7)+,d0/d1
00:000064B2 4E75            	  2330: 	rts
                            	  2331: 
                            	  2332: ;--------------------------------------------------------------------------
                            	  2333: ; Keyboard IRQ routine.
                            	  2334: ; - only core 2 processes keyboard interrupts.
                            	  2335: ; - the keyboard buffer is in shared global scratchpad space.
                            	  2336: ;
                            	  2337: ; Returns:
                            	  2338: ; 	d1 = -1 if keyboard routine handled interrupt, otherwise positive.
                            	  2339: ;--------------------------------------------------------------------------
                            	  2340: 
                            	  2341: KeybdIRQ:
00:000064B4 46FC2600        	  2342: 	move.w #$2600,sr					; disable lower interrupts
00:000064B8 48E7C080        	  2343: 	movem.l	d0/d1/a0,-(a7)
00:000064BC 46B9FD000000    	  2344: 	eori.l #-1,$FD000000
00:000064C2 7200            	  2345: 	moveq	#0,d1								; check if keyboard IRQ
00:000064C4 1239FD0FFE01    	  2346: 	move.b KEYBD+1,d1					; get status reg
00:000064CA 4A01            	  2347: 	tst.b	d1
00:000064CC 6A000096        	  2348: 	bpl	.0001									; branch if not keyboard
00:000064D0 4E7A0FE0        	  2349: 	movec	coreno,d0
00:000064D4 4840            	  2350: 	swap d0
00:000064D6 7203            	  2351: 	moveq	#KEYBD_SEMA,d1
00:000064D8 6100A272        	  2352: 	bsr LockSemaphore
00:000064DC 1239FD0FFE00    	  2353: 	move.b KEYBD,d1						; get scan code
00:000064E2 4239FD0FFE01    	  2354: 	clr.b KEYBD+1							; clear status register (clears IRQ AND scancode)
00:000064E8 0839000100100010	  2355: 	btst #1,_KeyState2				; Is Alt down?
00:000064F0 6738            	  2356: 	beq.s	.0003
00:000064F2 0C01000D        	  2357: 	cmpi.b #SC_TAB,d1					; is Alt-Tab?
00:000064F6 6632            	  2358: 	bne.s	.0003
00:000064F8 4E7A0FF0        	  2359: 	movec tick,d0
00:000064FC 90B90001001C    	  2360: 	sub.l _Keybd_tick,d0
00:00006502 B0BC0000000A    	  2361: 	cmp.l #10,d0							; has it been 10 or more ticks?
                            	  2362: ;	blo.s .0002
00:00006508 4E7A0FF0        	  2363: 	movec tick,d0							; update tick of last ALT-Tab
00:0000650C 23C00001001C    	  2364: 	move.l d0,_Keybd_tick
00:00006512 6100F940        	  2365: 	bsr	rotate_iofocus
00:00006516 423900100011    	  2366: 	clr.b	_KeybdHead					; clear keyboard buffer
00:0000651C 423900100012    	  2367: 	clr.b	_KeybdTail
00:00006522 423900100013    	  2368: 	clr.b	_KeybdCnt
00:00006528 602E            	  2369: 	bra	.0002									; do not store Alt-Tab
                            	  2370: .0003:
                            	  2371: 	; Insert keyboard scan code into raw keyboard buffer
00:0000652A 0C39002000100013	  2372: 	cmpi.b #32,_KeybdCnt			; see if keyboard buffer full
00:00006532 6424            	  2373: 	bhs.s	.0002
00:00006534 103900100012    	  2374: 	move.b _KeybdTail,d0			; keyboard buffer not full, add to tail
00:0000653A 4880            	  2375: 	ext.w	d0
00:0000653C 41F900100020    	  2376: 	lea	_KeybdBuf,a0					; a0 = pointer to buffer
00:00006542 11810000        	  2377: 	move.b d1,(a0,d0.w)				; put scancode in buffer
00:00006546 5200            	  2378: 	addi.b #1,d0							; increment tail index
00:00006548 0200001F        	  2379: 	andi.b #31,d0							; wrap at buffer limit
00:0000654C 13C000100012    	  2380: 	move.b d0,_KeybdTail			; update tail index
00:00006552 523900100013    	  2381: 	addi.b #1,_KeybdCnt				; increment buffer count
                            	  2382: .0002:
00:00006558 4E7A0FE0        	  2383: 	movec	coreno,d0
00:0000655C 4840            	  2384: 	swap d0
00:0000655E 7203            	  2385: 	moveq	#KEYBD_SEMA,d1
00:00006560 6100A226        	  2386: 	bsr	UnlockSemaphore
                            	  2387: .0001:
00:00006564 4CDF0103        	  2388: 	movem.l	(a7)+,d0/d1/a0		; return
00:00006568 4E73            	  2389: 	rte
                            	  2390: 
                            	  2391: ;--------------------------------------------------------------------------
                            	  2392: ; PS2 scan codes to ascii conversion tables.
                            	  2393: ;--------------------------------------------------------------------------
                            	  2394: ;
                            	  2395: _unshiftedScanCodes:
00:0000656A 2E              	  2396: 	dc.b	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
00:0000656B A9
00:0000656C 2E
00:0000656D A5
00:0000656E A3
00:0000656F A1
00:00006570 A2
00:00006571 AC
00:00006572 2E              	  2397: 	dc.b	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
00:00006573 AA
00:00006574 A8
00:00006575 A6
00:00006576 A4
00:00006577 09
00:00006578 60
00:00006579 2E
00:0000657A 2E              	  2398: 	dc.b	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
00:0000657B 2E
00:0000657C 2E
00:0000657D 2E
00:0000657E 2E
00:0000657F 71
00:00006580 31
00:00006581 2E
00:00006582 2E              	  2399: 	dc.b	$2e,$2e,$7a,$73,$61,$77,$32,$2e
00:00006583 2E
00:00006584 7A
00:00006585 73
00:00006586 61
00:00006587 77
00:00006588 32
00:00006589 2E
00:0000658A 2E              	  2400: 	dc.b	$2e,$63,$78,$64,$65,$34,$33,$2e
00:0000658B 63
00:0000658C 78
00:0000658D 64
00:0000658E 65
00:0000658F 34
00:00006590 33
00:00006591 2E
00:00006592 2E              	  2401: 	dc.b	$2e,$20,$76,$66,$74,$72,$35,$2e
00:00006593 20
00:00006594 76
00:00006595 66
00:00006596 74
00:00006597 72
00:00006598 35
00:00006599 2E
00:0000659A 2E              	  2402: 	dc.b	$2e,$6e,$62,$68,$67,$79,$36,$2e
00:0000659B 6E
00:0000659C 62
00:0000659D 68
00:0000659E 67
00:0000659F 79
00:000065A0 36
00:000065A1 2E
00:000065A2 2E              	  2403: 	dc.b	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
00:000065A3 2E
00:000065A4 6D
00:000065A5 6A
00:000065A6 75
00:000065A7 37
00:000065A8 38
00:000065A9 2E
00:000065AA 2E              	  2404: 	dc.b	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
00:000065AB 2C
00:000065AC 6B
00:000065AD 69
00:000065AE 6F
00:000065AF 30
00:000065B0 39
00:000065B1 2E
00:000065B2 2E              	  2405: 	dc.b	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
00:000065B3 2E
00:000065B4 2F
00:000065B5 6C
00:000065B6 3B
00:000065B7 70
00:000065B8 2D
00:000065B9 2E
00:000065BA 2E              	  2406: 	dc.b	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
00:000065BB 2E
00:000065BC 27
00:000065BD 2E
00:000065BE 5B
00:000065BF 3D
00:000065C0 2E
00:000065C1 2E
00:000065C2 AD              	  2407: 	dc.b	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
00:000065C3 2E
00:000065C4 0D
00:000065C5 5D
00:000065C6 2E
00:000065C7 5C
00:000065C8 2E
00:000065C9 2E
00:000065CA 2E              	  2408: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
00:000065CB 2E
00:000065CC 2E
00:000065CD 2E
00:000065CE 2E
00:000065CF 2E
00:000065D0 08
00:000065D1 2E
00:000065D2 2E              	  2409: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
00:000065D3 95
00:000065D4 2E
00:000065D5 93
00:000065D6 94
00:000065D7 2E
00:000065D8 2E
00:000065D9 2E
00:000065DA 98              	  2410: 	dc.b	$98,$7f,$92,$2e,$91,$90,$1b,$af
00:000065DB 7F
00:000065DC 92
00:000065DD 2E
00:000065DE 91
00:000065DF 90
00:000065E0 1B
00:000065E1 AF
00:000065E2 AB              	  2411: 	dc.b	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
00:000065E3 2E
00:000065E4 97
00:000065E5 2E
00:000065E6 2E
00:000065E7 96
00:000065E8 AE
00:000065E9 2E
                            	  2412: 
00:000065EA 2E              	  2413: 	dc.b	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
00:000065EB 2E
00:000065EC 2E
00:000065ED A7
00:000065EE 2E
00:000065EF 2E
00:000065F0 2E
00:000065F1 2E
00:000065F2 2E              	  2414: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:000065F3 2E
00:000065F4 2E
00:000065F5 2E
00:000065F6 2E
00:000065F7 2E
00:000065F8 2E
00:000065F9 2E
00:000065FA 2E              	  2415: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:000065FB 2E
00:000065FC 2E
00:000065FD 2E
00:000065FE 2E
00:000065FF 2E
00:00006600 2E
00:00006601 2E
00:00006602 2E              	  2416: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006603 2E
00:00006604 2E
00:00006605 2E
00:00006606 2E
00:00006607 2E
00:00006608 2E
00:00006609 2E
00:0000660A 2E              	  2417: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000660B 2E
00:0000660C 2E
00:0000660D 2E
00:0000660E 2E
00:0000660F 2E
00:00006610 2E
00:00006611 2E
00:00006612 2E              	  2418: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006613 2E
00:00006614 2E
00:00006615 2E
00:00006616 2E
00:00006617 2E
00:00006618 2E
00:00006619 2E
00:0000661A 2E              	  2419: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000661B 2E
00:0000661C 2E
00:0000661D 2E
00:0000661E 2E
00:0000661F 2E
00:00006620 2E
00:00006621 2E
00:00006622 2E              	  2420: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006623 2E
00:00006624 2E
00:00006625 2E
00:00006626 2E
00:00006627 2E
00:00006628 2E
00:00006629 2E
00:0000662A 2E              	  2421: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000662B 2E
00:0000662C 2E
00:0000662D 2E
00:0000662E 2E
00:0000662F 2E
00:00006630 2E
00:00006631 2E
00:00006632 2E              	  2422: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006633 2E
00:00006634 2E
00:00006635 2E
00:00006636 2E
00:00006637 2E
00:00006638 2E
00:00006639 2E
00:0000663A 2E              	  2423: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000663B 2E
00:0000663C 2E
00:0000663D 2E
00:0000663E 2E
00:0000663F 2E
00:00006640 2E
00:00006641 2E
00:00006642 2E              	  2424: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006643 2E
00:00006644 2E
00:00006645 2E
00:00006646 2E
00:00006647 2E
00:00006648 2E
00:00006649 2E
00:0000664A 2E              	  2425: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000664B 2E
00:0000664C 2E
00:0000664D 2E
00:0000664E 2E
00:0000664F 2E
00:00006650 2E
00:00006651 2E
00:00006652 2E              	  2426: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006653 2E
00:00006654 2E
00:00006655 2E
00:00006656 2E
00:00006657 2E
00:00006658 2E
00:00006659 2E
00:0000665A 2E              	  2427: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000665B 2E
00:0000665C 2E
00:0000665D 2E
00:0000665E 2E
00:0000665F 2E
00:00006660 2E
00:00006661 2E
00:00006662 2E              	  2428: 	dc.b	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
00:00006663 2E
00:00006664 FA
00:00006665 2E
00:00006666 2E
00:00006667 2E
00:00006668 2E
00:00006669 2E
                            	  2429: 
                            	  2430: _shiftedScanCodes:
00:0000666A 2E              	  2431: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000666B 2E
00:0000666C 2E
00:0000666D 2E
00:0000666E 2E
00:0000666F 2E
00:00006670 2E
00:00006671 2E
00:00006672 2E              	  2432: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
00:00006673 2E
00:00006674 2E
00:00006675 2E
00:00006676 2E
00:00006677 09
00:00006678 7E
00:00006679 2E
00:0000667A 2E              	  2433: 	dc.b	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
00:0000667B 2E
00:0000667C 2E
00:0000667D 2E
00:0000667E 2E
00:0000667F 51
00:00006680 21
00:00006681 2E
00:00006682 2E              	  2434: 	dc.b	$2e,$2e,$5a,$53,$41,$57,$40,$2e
00:00006683 2E
00:00006684 5A
00:00006685 53
00:00006686 41
00:00006687 57
00:00006688 40
00:00006689 2E
00:0000668A 2E              	  2435: 	dc.b	$2e,$43,$58,$44,$45,$24,$23,$2e
00:0000668B 43
00:0000668C 58
00:0000668D 44
00:0000668E 45
00:0000668F 24
00:00006690 23
00:00006691 2E
00:00006692 2E              	  2436: 	dc.b	$2e,$20,$56,$46,$54,$52,$25,$2e
00:00006693 20
00:00006694 56
00:00006695 46
00:00006696 54
00:00006697 52
00:00006698 25
00:00006699 2E
00:0000669A 2E              	  2437: 	dc.b	$2e,$4e,$42,$48,$47,$59,$5e,$2e
00:0000669B 4E
00:0000669C 42
00:0000669D 48
00:0000669E 47
00:0000669F 59
00:000066A0 5E
00:000066A1 2E
00:000066A2 2E              	  2438: 	dc.b	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
00:000066A3 2E
00:000066A4 4D
00:000066A5 4A
00:000066A6 55
00:000066A7 26
00:000066A8 2A
00:000066A9 2E
00:000066AA 2E              	  2439: 	dc.b	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
00:000066AB 3C
00:000066AC 4B
00:000066AD 49
00:000066AE 4F
00:000066AF 29
00:000066B0 28
00:000066B1 2E
00:000066B2 2E              	  2440: 	dc.b	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
00:000066B3 3E
00:000066B4 3F
00:000066B5 4C
00:000066B6 3A
00:000066B7 50
00:000066B8 5F
00:000066B9 2E
00:000066BA 2E              	  2441: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
00:000066BB 2E
00:000066BC 22
00:000066BD 2E
00:000066BE 7B
00:000066BF 2B
00:000066C0 2E
00:000066C1 2E
00:000066C2 2E              	  2442: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
00:000066C3 2E
00:000066C4 0D
00:000066C5 7D
00:000066C6 2E
00:000066C7 7C
00:000066C8 2E
00:000066C9 2E
00:000066CA 2E              	  2443: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
00:000066CB 2E
00:000066CC 2E
00:000066CD 2E
00:000066CE 2E
00:000066CF 2E
00:000066D0 08
00:000066D1 2E
00:000066D2 2E              	  2444: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:000066D3 2E
00:000066D4 2E
00:000066D5 2E
00:000066D6 2E
00:000066D7 2E
00:000066D8 2E
00:000066D9 2E
00:000066DA 2E              	  2445: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
00:000066DB 7F
00:000066DC 2E
00:000066DD 2E
00:000066DE 2E
00:000066DF 2E
00:000066E0 1B
00:000066E1 2E
00:000066E2 2E              	  2446: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:000066E3 2E
00:000066E4 2E
00:000066E5 2E
00:000066E6 2E
00:000066E7 2E
00:000066E8 2E
00:000066E9 2E
                            	  2447: 
00:000066EA 2E              	  2448: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:000066EB 2E
00:000066EC 2E
00:000066ED 2E
00:000066EE 2E
00:000066EF 2E
00:000066F0 2E
00:000066F1 2E
00:000066F2 2E              	  2449: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:000066F3 2E
00:000066F4 2E
00:000066F5 2E
00:000066F6 2E
00:000066F7 2E
00:000066F8 2E
00:000066F9 2E
00:000066FA 2E              	  2450: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:000066FB 2E
00:000066FC 2E
00:000066FD 2E
00:000066FE 2E
00:000066FF 2E
00:00006700 2E
00:00006701 2E
00:00006702 2E              	  2451: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006703 2E
00:00006704 2E
00:00006705 2E
00:00006706 2E
00:00006707 2E
00:00006708 2E
00:00006709 2E
00:0000670A 2E              	  2452: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000670B 2E
00:0000670C 2E
00:0000670D 2E
00:0000670E 2E
00:0000670F 2E
00:00006710 2E
00:00006711 2E
00:00006712 2E              	  2453: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006713 2E
00:00006714 2E
00:00006715 2E
00:00006716 2E
00:00006717 2E
00:00006718 2E
00:00006719 2E
00:0000671A 2E              	  2454: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000671B 2E
00:0000671C 2E
00:0000671D 2E
00:0000671E 2E
00:0000671F 2E
00:00006720 2E
00:00006721 2E
00:00006722 2E              	  2455: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006723 2E
00:00006724 2E
00:00006725 2E
00:00006726 2E
00:00006727 2E
00:00006728 2E
00:00006729 2E
00:0000672A 2E              	  2456: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000672B 2E
00:0000672C 2E
00:0000672D 2E
00:0000672E 2E
00:0000672F 2E
00:00006730 2E
00:00006731 2E
00:00006732 2E              	  2457: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006733 2E
00:00006734 2E
00:00006735 2E
00:00006736 2E
00:00006737 2E
00:00006738 2E
00:00006739 2E
00:0000673A 2E              	  2458: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000673B 2E
00:0000673C 2E
00:0000673D 2E
00:0000673E 2E
00:0000673F 2E
00:00006740 2E
00:00006741 2E
00:00006742 2E              	  2459: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006743 2E
00:00006744 2E
00:00006745 2E
00:00006746 2E
00:00006747 2E
00:00006748 2E
00:00006749 2E
00:0000674A 2E              	  2460: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000674B 2E
00:0000674C 2E
00:0000674D 2E
00:0000674E 2E
00:0000674F 2E
00:00006750 2E
00:00006751 2E
00:00006752 2E              	  2461: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006753 2E
00:00006754 2E
00:00006755 2E
00:00006756 2E
00:00006757 2E
00:00006758 2E
00:00006759 2E
00:0000675A 2E              	  2462: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000675B 2E
00:0000675C 2E
00:0000675D 2E
00:0000675E 2E
00:0000675F 2E
00:00006760 2E
00:00006761 2E
00:00006762 2E              	  2463: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006763 2E
00:00006764 2E
00:00006765 2E
00:00006766 2E
00:00006767 2E
00:00006768 2E
00:00006769 2E
                            	  2464: 
                            	  2465: ; control
                            	  2466: _keybdControlCodes:
00:0000676A 2E              	  2467: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000676B 2E
00:0000676C 2E
00:0000676D 2E
00:0000676E 2E
00:0000676F 2E
00:00006770 2E
00:00006771 2E
00:00006772 2E              	  2468: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
00:00006773 2E
00:00006774 2E
00:00006775 2E
00:00006776 2E
00:00006777 09
00:00006778 7E
00:00006779 2E
00:0000677A 2E              	  2469: 	dc.b	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
00:0000677B 2E
00:0000677C 2E
00:0000677D 2E
00:0000677E 2E
00:0000677F 11
00:00006780 21
00:00006781 2E
00:00006782 2E              	  2470: 	dc.b	$2e,$2e,$1a,$13,$01,$17,$40,$2e
00:00006783 2E
00:00006784 1A
00:00006785 13
00:00006786 01
00:00006787 17
00:00006788 40
00:00006789 2E
00:0000678A 2E              	  2471: 	dc.b	$2e,$03,$18,$04,$05,$24,$23,$2e
00:0000678B 03
00:0000678C 18
00:0000678D 04
00:0000678E 05
00:0000678F 24
00:00006790 23
00:00006791 2E
00:00006792 2E              	  2472: 	dc.b	$2e,$20,$16,$06,$14,$12,$25,$2e
00:00006793 20
00:00006794 16
00:00006795 06
00:00006796 14
00:00006797 12
00:00006798 25
00:00006799 2E
00:0000679A 2E              	  2473: 	dc.b	$2e,$0e,$02,$08,$07,$19,$5e,$2e
00:0000679B 0E
00:0000679C 02
00:0000679D 08
00:0000679E 07
00:0000679F 19
00:000067A0 5E
00:000067A1 2E
00:000067A2 2E              	  2474: 	dc.b	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
00:000067A3 2E
00:000067A4 0D
00:000067A5 0A
00:000067A6 15
00:000067A7 26
00:000067A8 2A
00:000067A9 2E
00:000067AA 2E              	  2475: 	dc.b	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
00:000067AB 3C
00:000067AC 0B
00:000067AD 09
00:000067AE 0F
00:000067AF 29
00:000067B0 28
00:000067B1 2E
00:000067B2 2E              	  2476: 	dc.b	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
00:000067B3 3E
00:000067B4 3F
00:000067B5 0C
00:000067B6 3A
00:000067B7 10
00:000067B8 5F
00:000067B9 2E
00:000067BA 2E              	  2477: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
00:000067BB 2E
00:000067BC 22
00:000067BD 2E
00:000067BE 7B
00:000067BF 2B
00:000067C0 2E
00:000067C1 2E
00:000067C2 2E              	  2478: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
00:000067C3 2E
00:000067C4 0D
00:000067C5 7D
00:000067C6 2E
00:000067C7 7C
00:000067C8 2E
00:000067C9 2E
00:000067CA 2E              	  2479: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
00:000067CB 2E
00:000067CC 2E
00:000067CD 2E
00:000067CE 2E
00:000067CF 2E
00:000067D0 08
00:000067D1 2E
00:000067D2 2E              	  2480: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:000067D3 2E
00:000067D4 2E
00:000067D5 2E
00:000067D6 2E
00:000067D7 2E
00:000067D8 2E
00:000067D9 2E
00:000067DA 2E              	  2481: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
00:000067DB 7F
00:000067DC 2E
00:000067DD 2E
00:000067DE 2E
00:000067DF 2E
00:000067E0 1B
00:000067E1 2E
00:000067E2 2E              	  2482: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:000067E3 2E
00:000067E4 2E
00:000067E5 2E
00:000067E6 2E
00:000067E7 2E
00:000067E8 2E
00:000067E9 2E
                            	  2483: 
                            	  2484: _keybdExtendedCodes:
00:000067EA 2E              	  2485: 	dc.b	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
00:000067EB 2E
00:000067EC 2E
00:000067ED 2E
00:000067EE A3
00:000067EF A1
00:000067F0 A2
00:000067F1 2E
00:000067F2 2E              	  2486: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:000067F3 2E
00:000067F4 2E
00:000067F5 2E
00:000067F6 2E
00:000067F7 2E
00:000067F8 2E
00:000067F9 2E
00:000067FA 2E              	  2487: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:000067FB 2E
00:000067FC 2E
00:000067FD 2E
00:000067FE 2E
00:000067FF 2E
00:00006800 2E
00:00006801 2E
00:00006802 2E              	  2488: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006803 2E
00:00006804 2E
00:00006805 2E
00:00006806 2E
00:00006807 2E
00:00006808 2E
00:00006809 2E
00:0000680A 2E              	  2489: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000680B 2E
00:0000680C 2E
00:0000680D 2E
00:0000680E 2E
00:0000680F 2E
00:00006810 2E
00:00006811 2E
00:00006812 2E              	  2490: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006813 2E
00:00006814 2E
00:00006815 2E
00:00006816 2E
00:00006817 2E
00:00006818 2E
00:00006819 2E
00:0000681A 2E              	  2491: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000681B 2E
00:0000681C 2E
00:0000681D 2E
00:0000681E 2E
00:0000681F 2E
00:00006820 2E
00:00006821 2E
00:00006822 2E              	  2492: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006823 2E
00:00006824 2E
00:00006825 2E
00:00006826 2E
00:00006827 2E
00:00006828 2E
00:00006829 2E
00:0000682A 2E              	  2493: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000682B 2E
00:0000682C 2E
00:0000682D 2E
00:0000682E 2E
00:0000682F 2E
00:00006830 2E
00:00006831 2E
00:00006832 2E              	  2494: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006833 2E
00:00006834 2E
00:00006835 2E
00:00006836 2E
00:00006837 2E
00:00006838 2E
00:00006839 2E
00:0000683A 2E              	  2495: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000683B 2E
00:0000683C 2E
00:0000683D 2E
00:0000683E 2E
00:0000683F 2E
00:00006840 2E
00:00006841 2E
00:00006842 2E              	  2496: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006843 2E
00:00006844 2E
00:00006845 2E
00:00006846 2E
00:00006847 2E
00:00006848 2E
00:00006849 2E
00:0000684A 2E              	  2497: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:0000684B 2E
00:0000684C 2E
00:0000684D 2E
00:0000684E 2E
00:0000684F 2E
00:00006850 2E
00:00006851 2E
00:00006852 2E              	  2498: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
00:00006853 95
00:00006854 2E
00:00006855 93
00:00006856 94
00:00006857 2E
00:00006858 2E
00:00006859 2E
00:0000685A 98              	  2499: 	dc.b	$98,$99,$92,$2e,$91,$90,$2e,$2e
00:0000685B 99
00:0000685C 92
00:0000685D 2E
00:0000685E 91
00:0000685F 90
00:00006860 2E
00:00006861 2E
00:00006862 2E              	  2500: 	dc.b	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
00:00006863 2E
00:00006864 97
00:00006865 2E
00:00006866 2E
00:00006867 96
00:00006868 2E
00:00006869 2E
                            	  2501: 
                            	  2502: ;==============================================================================
                            	  2503: ;==============================================================================
                            	  2504: ; Monitor
                            	  2505: ;==============================================================================
                            	  2506: ;==============================================================================
                            	  2507: 
                            	  2508: cmdString:
00:0000686A BF              	  2509: 	dc.b	'?'+$80						; ? display help
00:0000686B CC              	  2510: 	dc.b	'L'+$80						; L load S19 file
00:0000686C 46              	  2511: 	dc.b	'F','B'+$80				; FB fill with byte
00:0000686D C2
00:0000686E 46              	  2512: 	dc.b	'F','W'+$80				; FW fill with wyde
00:0000686F D7
00:00006870 46              	  2513: 	dc.b	'F','L'+$80				; FL fill with long wyde
00:00006871 CC
00:00006872 464D54          	  2514: 	dc.b	'FMT','K'+$80			; FMTK run Femtiki OS
00:00006875 CB
00:00006876 42              	  2515: 	dc.b	'B','A'+$80				; BA start Tiny Basic
00:00006877 C1
00:00006878 42              	  2516: 	dc.b	'B','R'+$80				; BR breakpoint
00:00006879 D2
00:0000687A 44              	  2517: 	dc.b	'D','I'+$80				; DI disassemble
00:0000687B C9
00:0000687C 44              	  2518: 	dc.b	'D','R'+$80				; DR dump registers
00:0000687D D2
00:0000687E C4              	  2519: 	dc.b	'D'+$80						; D dump memory
00:0000687F CA              	  2520: 	dc.b	'J'+$80						; J jump to code
00:00006880 C5              	  2521: 	dc.b	'E'+$80						; : edit memory
00:00006881 434C            	  2522: 	dc.b	"CL",'S'+$80			; CLS clear screen
00:00006883 D3
00:00006884 434F52          	  2523: 	dc.b	"COR",'E'+$80			; CORE <n> switch to core
00:00006887 C5
00:00006888 5446            	  2524: 	dc.b	"TF",'P'+$80			; TFP test fp
00:0000688A D0
00:0000688B 5447            	  2525: 	dc.b  "TG",'F'+$80			; TGF test get float
00:0000688D C6
00:0000688E 545241          	  2526: 	dc.b  "TRA",'M'+$80			; TRAM test RAM
00:00006891 CD
00:00006892 54              	  2527: 	dc.b	'T','R'+$80				; TR test serial receive
00:00006893 D2
00:00006894 D4              	  2528: 	dc.b	'T'+$80						; T test CPU
00:00006895 D3              	  2529: 	dc.b	'S'+$80						; S send serial
00:00006896 52455345        	  2530: 	dc.b	"RESE",'T'+$80		; RESET <n>
00:0000689A D4
00:0000689B 434C4F43        	  2531: 	dc.b	"CLOC",'K'+$80		; CLOCK <n>
00:0000689F CB
00:000068A0 D2              	  2532: 	dc.b	'R'+$80						; R receive serial
00:000068A1 D6              	  2533: 	dc.b	'V'+$80
                            	  2534: 
                            	  2535: 	align	2
                            	  2536: cmdTable:
00:000068A4 00006B90        	  2537: 	dc.l	cmdHelp
00:000068A8 000078FC        	  2538: 	dc.l	cmdLoadS19
00:000068AC 00006E4C        	  2539: 	dc.l	cmdFillB
00:000068B0 00006EA0        	  2540: 	dc.l	cmdFillW
00:000068B4 00006EF4        	  2541: 	dc.l	cmdFillL
00:000068B8 00006A5E        	  2542: 	dc.l	cmdFMTK
00:000068BC 00006A1A        	  2543: 	dc.l	cmdTinyBasic
00:000068C0 000069F6        	  2544: 	dc.l	cmdBreakpoint
00:000068C4 00007006        	  2545: 	dc.l	cmdDisassemble
00:000068C8 00007120        	  2546: 	dc.l	cmdDumpRegs
00:000068CC 00007056        	  2547: 	dc.l	cmdDumpMemory
00:000068D0 00006FF6        	  2548: 	dc.l	cmdJump
00:000068D4 00006FA0        	  2549: 	dc.l	cmdEditMemory
00:000068D8 00006A2E        	  2550: 	dc.l	cmdClearScreen
00:000068DC 00006A3A        	  2551: 	dc.l	cmdCore
00:000068E0 00006A66        	  2552: 	dc.l  cmdTestFP
00:000068E4 00006AF2        	  2553: 	dc.l	cmdTestGF
00:000068E8 0000783A        	  2554: 	dc.l  cmdTestRAM
00:000068EC 000071CA        	  2555: 	dc.l	cmdTestSerialReceive
00:000068F0 00006A1E        	  2556: 	dc.l	cmdTestCPU
00:000068F4 00006DE8        	  2557: 	dc.l	cmdSendSerial
00:000068F8 00006B3E        	  2558: 	dc.l	cmdReset
00:000068FC 00006B20        	  2559: 	dc.l	cmdClock
00:00006900 00006E18        	  2560: 	dc.l	cmdReceiveSerial	
00:00006904 000069B6        	  2561: 	dc.l	cmdVideoMode
00:00006908 00006920        	  2562: 	dc.l	cmdMonitor
                            	  2563: 
                            	  2564: ; Get a word from screen memory and swap byte order
                            	  2565: 
                            	  2566: FromScreen:
00:0000690C 2210            	  2567: 	move.l (a0),d1
00:0000690E 61001204        	  2568: 	bsr	rbo
                            	  2569: 	if (SCREEN_FORMAT==1)
00:00006912 5888            	  2570: 		lea	4(a0),a0	; increment screen pointer
                            	  2571: 	else
                            	  2572: 		lea	8(a0),a0	; increment screen pointer
                            	  2573: 	endif
00:00006914 4E75            	  2574: 	rts
                            	  2575: 
                            	  2576: StartMon:
00:00006916 427900040202    	  2577: 	clr.w	NumSetBreakpoints
00:0000691C 61001896        	  2578: 	bsr	ClearBreakpointList
                            	  2579: cmdMonitor:
                            	  2580: Monitor:
                            	  2581: 	; Reset the stack pointer on each entry into the monitor
00:00006920 2E7C00040FFC    	  2582: 	move.l #$40FFC,sp		; reset core's stack
00:00006926 46FC2200        	  2583: 	move.w #$2200,sr		; enable level 2 and higher interrupts
00:0000692A 4E7A0FE0        	  2584: 	movec	coreno,d0
00:0000692E 4840            	  2585: 	swap d0
00:00006930 7201            	  2586: 	moveq	#1,d1
00:00006932 61009E54        	  2587: 	bsr	UnlockSemaphore
00:00006936 42390004000C    	  2588: 	clr.b KeybdEcho			; turn off keyboard echo
                            	  2589: PromptLn:
00:0000693C 6100F0C8        	  2590: 	bsr	CRLF
00:00006940 123C0024        	  2591: 	move.b #'$',d1
00:00006944 610019A4        	  2592: 	bsr OutputChar
                            	  2593: 
                            	  2594: ; Get characters until a CR is keyed
                            	  2595: ;
                            	  2596: Prompt3:
00:00006948 6100F86A        	  2597: 	bsr	GetKey
00:0000694C 0C0100FF        	  2598: 	cmpi.b #-1,d1
00:00006950 67F6            	  2599: 	beq.s	Prompt3
00:00006952 0C01000D        	  2600: 	cmpi.b #CR,d1
00:00006956 6706            	  2601: 	beq.s	Prompt1
00:00006958 61001990        	  2602: 	bsr	OutputChar
00:0000695C 60EA            	  2603: 	bra.s	Prompt3
                            	  2604: 
                            	  2605: ; Process the screen line that the CR was keyed on
                            	  2606: 
                            	  2607: Prompt1:
00:0000695E 423900040001    	  2608: 	clr.b	CursorCol				; go back to the start of the line
00:00006964 6100F0E4        	  2609: 	bsr	CalcScreenLoc			; a0 = screen memory location
                            	  2610: .0001:
00:00006968 61A2            	  2611: 	bsr	FromScreen				; grab character off screen
00:0000696A 0C010024        	  2612: 	cmpi.b #'$',d1				; skip over '$' prompt character
00:0000696E 67F8            	  2613: 	beq.s	.0001
                            	  2614: 	
                            	  2615: ; Dispatch based on command string
                            	  2616: 
                            	  2617: cmdDispatch:
00:00006970 45FAFEF8        	  2618: 	lea	cmdString,a2
00:00006974 7800            	  2619: 	clr.l	d4							; command counter
                            	  2620: 	if (SCREEN_FORMAT==1)
00:00006976 5988            	  2621: 		lea	-4(a0),a0				; backup a character
                            	  2622: 	else
                            	  2623: 		lea	-8(a0),a0				; backup a character
                            	  2624: 	endif
00:00006978 2648            	  2625: 	move.l	a0,a3					; a3 = start of command on screen
                            	  2626: .checkNextCmd:
00:0000697A 6190            	  2627: 	bsr	FromScreen				; d1 = char from input screen
00:0000697C 1A1A            	  2628: 	move.b (a2)+,d5
00:0000697E BB01            	  2629: 	eor.b	d5,d1						; does it match with command string?
00:00006980 67F8            	  2630: 	beq.s	.checkNextCmd		; If it does, keep matching for longest match
00:00006982 0C010080        	  2631: 	cmpi.b #$80,d1				; didn't match, was it the end of the command?
00:00006986 6724            	  2632: 	beq.s	.foundCmd
00:00006988 4A2AFFFF        	  2633: 	tst.b	-1(a2)					; was end of table hit?
00:0000698C 6712            	  2634: 	beq.s	.endOfTable
00:0000698E 5844            	  2635: 	addi.w #4,d4					; increment command counter
00:00006990 204B            	  2636: 	move.l a3,a0					; reset input pointer
00:00006992 4A2AFFFF        	  2637: 	tst.b	-1(a2)					; were we at the end of the command?
00:00006996 6BE2            	  2638: 	bmi.s	.checkNextCmd		; if were at end continue, otherwise scan for end of cmd
                            	  2639: .scanToEndOfCmd
00:00006998 4A1A            	  2640: 	tst.b	(a2)+						; scan to end of command
00:0000699A 6704            	  2641: 	beq.s	.endOfTable
00:0000699C 6AFA            	  2642: 	bpl.s	.scanToEndOfCmd
00:0000699E 6BDA            	  2643: 	bmi.s	.checkNextCmd
                            	  2644: .endOfTable
00:000069A0 43FA0380        	  2645: 	lea	msgUnknownCmd,a1
00:000069A4 6100F328        	  2646: 	bsr	DisplayStringCRLF
00:000069A8 6000FF76        	  2647: 	bra	Monitor
                            	  2648: .foundCmd:
00:000069AC 43FAFEF6        	  2649: 	lea	cmdTable,a1				; a1 = pointer to command address table
00:000069B0 22714000        	  2650: 	move.l (a1,d4.w),a1		; fetch command routine address from table
00:000069B4 4ED1            	  2651: 	jmp	(a1)							; go execute command
                            	  2652: 
                            	  2653: cmdVideoMode:
00:000069B6 61000588        	  2654: 	bsr ignBlanks
00:000069BA 6100082E        	  2655: 	bsr GetHexNumber
00:000069BE 4A01            	  2656: 	cmpi.b #0,d1
00:000069C0 660C            	  2657: 	bne.s .0001
00:000069C2 6100EF98        	  2658: 	bsr set_text_mode
00:000069C6 6100F002        	  2659: 	bsr clear_screen
00:000069CA 6000FF54        	  2660: 	bra Monitor
                            	  2661: .0001:
00:000069CE 6100EFB6        	  2662: 	bsr set_graphics_mode
00:000069D2 6100EFEE        	  2663: 	bsr get_screen_address
00:000069D6 42B9FD0FFD04    	  2664: 	move.l #0,RAND+4		; select stream 0
00:000069DC 343C1D4B        	  2665: 	move.w #7499,d2
                            	  2666: .0002:
00:000069E0 2239FD0FFD00    	  2667: 	move.l RAND,d1
00:000069E6 42B9FD0FFD00    	  2668: 	move.l #0,RAND			; cause new number generation
00:000069EC 20C1            	  2669: 	move.l d1,(a0)+			; random display
00:000069EE 51CAFFF0        	  2670: 	dbra d2,.0002
00:000069F2 6000FF2C        	  2671: 	bra Monitor
                            	  2672: 
                            	  2673: cmdBreakpoint:
00:000069F6 61000548        	  2674: 	bsr	ignBlanks
00:000069FA 6100FF10        	  2675: 	bsr	FromScreen
00:000069FE 0C01002B        	  2676: 	cmpi.b	#'+',d1
00:00006A02 670016BE        	  2677: 	beq	ArmBreakpoint
00:00006A06 0C01002D        	  2678: 	cmpi.b	#'-',d1
00:00006A0A 67001734        	  2679: 	beq	DisarmBreakpoint
00:00006A0E 0C01004C        	  2680: 	cmpi.b	#'L',d1
00:00006A12 67001780        	  2681: 	beq	ListBreakpoints
00:00006A16 6000FF08        	  2682: 	bra	Monitor
                            	  2683: 
                            	  2684: cmdTinyBasic:
00:00006A1A 6000D976        	  2685: 	bra	CSTART
                            	  2686: 
                            	  2687: cmdTestCPU:
00:00006A1E 61009E02        	  2688: 	bsr	cpu_test
00:00006A22 43FA1AB7        	  2689: 	lea	msg_test_done,a1
00:00006A26 6100F2A6        	  2690: 	bsr	DisplayStringCRLF
00:00006A2A 6000FEF4        	  2691: 	bra	Monitor
                            	  2692: 
                            	  2693: cmdClearScreen:
00:00006A2E 610010DE        	  2694: 	bsr	ClearScreen
00:00006A32 6100F2C6        	  2695: 	bsr	HomeCursor
00:00006A36 6000FEE8        	  2696: 	bra	Monitor
                            	  2697: 
                            	  2698: cmdCore:
00:00006A3A 61000504        	  2699: 	bsr			ignBlanks
00:00006A3E 6100FECC        	  2700: 	bsr			FromScreen
00:00006A42 0C010032        	  2701: 	cmpi.b	#'2',d1					; check range
00:00006A46 6500FED8        	  2702: 	blo			Monitor
00:00006A4A 0C010035        	  2703: 	cmpi.b	#'0'+NCORES+1,d1
00:00006A4E 6200FED0        	  2704: 	bhi			Monitor
00:00006A52 04010030        	  2705: 	subi.b	#'0',d1					; convert ascii to binary
00:00006A56 6100F3EA        	  2706: 	bsr			select_iofocus
00:00006A5A 6000FEC4        	  2707: 	bra			Monitor
                            	  2708: 
                            	  2709: cmdFMTK:
00:00006A5E 610097C0        	  2710: 	bsr FemtikiInit
00:00006A62 6000FEBC        	  2711: 	bra Monitor
                            	  2712: 
                            	  2713: cmdTestFP:
00:00006A66 7029            	  2714: 	moveq #41,d0						; function #41, get float
00:00006A68 7208            	  2715: 	moveq #8,d1							; d1 = input stride
00:00006A6A 2248            	  2716: 	move.l a0,a1						; a1 = pointer to input buffer
00:00006A6C 4E4F            	  2717: 	trap #15
00:00006A6E 2049            	  2718: 	move.l a1,a0
00:00006A70 F2000200        	  2719: 	fmove.x fp0,fp4
00:00006A74 610004CA        	  2720: 	bsr ignBlanks
00:00006A78 6100FE92        	  2721: 	bsr FromScreen
00:00006A7C 1E01            	  2722: 	move.b d1,d7
00:00006A7E 7029            	  2723: 	moveq #41,d0						; function #41, get float
00:00006A80 7208            	  2724: 	move.l #8,d1						; d1 = input stride
00:00006A82 2248            	  2725: 	move.l a0,a1						; a1 = pointer to input buffer
00:00006A84 4E4F            	  2726: 	trap #15
00:00006A86 2049            	  2727: 	move.l a1,a0
00:00006A88 F2000100        	  2728: 	fmove.x fp0,fp2
00:00006A8C 6100EF78        	  2729: 	bsr CRLF
                            	  2730: ;	moveq #39,d0
                            	  2731: ;	moveq #40,d1
                            	  2732: ;	moveq #30,d2
                            	  2733: ;	moveq #'e',d3
                            	  2734: ;	trap #15
                            	  2735: ;	bsr CRLF
00:00006A90 F2396A00000402C0	  2736: 	fmove.x fp4,fpBuf
00:00006A98 F2396900000402D0	  2737: 	fmove.x fp2,fpBuf+16
00:00006AA0 0C07002B        	  2738: 	cmpi.b #'+',d7
00:00006AA4 6606            	  2739: 	bne .0001
00:00006AA6 F2000A22        	  2740: 	fadd fp2,fp4
00:00006AAA 6022            	  2741: 	bra .0002
                            	  2742: .0001
00:00006AAC 0C07002D        	  2743: 	cmpi.b #'-',d7
00:00006AB0 6606            	  2744: 	bne .0003
00:00006AB2 F2000A28        	  2745: 	fsub fp2,fp4
00:00006AB6 6016            	  2746: 	bra .0002
                            	  2747: .0003
00:00006AB8 0C07002A        	  2748: 	cmpi.b #'*',d7
00:00006ABC 6606            	  2749: 	bne .0004
00:00006ABE F2000A23        	  2750: 	fmul fp2,fp4
00:00006AC2 600A            	  2751: 	bra .0002
                            	  2752: .0004
00:00006AC4 0C07002F        	  2753: 	cmpi.b #'/',d7
00:00006AC8 6620            	  2754: 	bne .0005
00:00006ACA F2000A20        	  2755: 	fdiv fp2,fp4
                            	  2756: 	bra .0002
                            	  2757: .0002
00:00006ACE F2396A00000402E0	  2758: 	fmove.x fp4,fpBuf+32
00:00006AD6 F2001000        	  2759: 	fmove.x fp4,fp0
00:00006ADA 43F900040520    	  2760: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
00:00006AE0 7027            	  2761: 	moveq #39,d0						; function #39 print float
00:00006AE2 7228            	  2762: 	moveq #40,d1						; width
00:00006AE4 741E            	  2763: 	moveq #30,d2						; precision
00:00006AE6 7665            	  2764: 	moveq #'e',d3
00:00006AE8 4E4F            	  2765: 	trap #15
                            	  2766: .0005
00:00006AEA 6100EF1A        	  2767: 	bsr CRLF
00:00006AEE 6000FE30        	  2768: 	bra Monitor
                            	  2769: 
                            	  2770: cmdTestGF:
00:00006AF2 6100EF12        	  2771: 	bsr CRLF
00:00006AF6 7029            	  2772: 	moveq #41,d0						; function #41, get float
00:00006AF8 7208            	  2773: 	move.l #8,d1						; d1 = input stride
00:00006AFA 2248            	  2774: 	move.l a0,a1						; a1 = pointer to input buffer
00:00006AFC 4E4F            	  2775: 	trap #15
00:00006AFE F2396800000402E0	  2776: 	fmove.x fp0,fpBuf+32
00:00006B06 43F900040520    	  2777: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
00:00006B0C 7027            	  2778: 	moveq #39,d0
00:00006B0E 7228            	  2779: 	moveq #40,d1
00:00006B10 741E            	  2780: 	moveq #30,d2
00:00006B12 7665            	  2781: 	moveq #'e',d3
00:00006B14 4E4F            	  2782: 	trap #15
00:00006B16 2049            	  2783: 	move.l a1,a0
00:00006B18 6100EEEC        	  2784: 	bsr CRLF
00:00006B1C 6000FE02        	  2785: 	bra Monitor
                            	  2786: 		
                            	  2787: ;-------------------------------------------------------------------------------
                            	  2788: ; CLOCK <n>
                            	  2789: ;    Set the clock register to n which will turn off or on clocks to the CPUs.
                            	  2790: ;-------------------------------------------------------------------------------
                            	  2791: 
                            	  2792: cmdClock:
00:00006B20 6100041E        	  2793: 	bsr			ignBlanks
00:00006B24 610006C4        	  2794: 	bsr			GetHexNumber
00:00006B28 4A00            	  2795: 	tst.b		d0							; was there a number?
00:00006B2A 6700FDF4        	  2796: 	beq			Monitor
00:00006B2E 00400004        	  2797: 	ori.w		#4,d0						; primary core's clock cannot be turned off
00:00006B32 E159            	  2798: 	rol.w		#8,d1						; switch byte order
00:00006B34 33C1FD0FFC02    	  2799: 	move.w	d1,RST_REG+2
00:00006B3A 6000FDE4        	  2800: 	bra			Monitor
                            	  2801: 
                            	  2802: ;-------------------------------------------------------------------------------
                            	  2803: ; RESET <n>
                            	  2804: ;    Reset the specified core. Resetting the core automatically turns on the 
                            	  2805: ; core's clock.
                            	  2806: ;-------------------------------------------------------------------------------
                            	  2807: 
                            	  2808: cmdReset:
00:00006B3E 61000400        	  2809: 	bsr			ignBlanks
00:00006B42 6100FDC8        	  2810: 	bsr			FromScreen
00:00006B46 0C010032        	  2811: 	cmpi.b	#'2',d1					; check range
00:00006B4A 6500FDD4        	  2812: 	blo			Monitor
00:00006B4E 0C010039        	  2813: 	cmpi.b	#'9',d1
00:00006B52 6200FDCC        	  2814: 	bhi			Monitor
00:00006B56 04010030        	  2815: 	subi.b	#'0',d1					; convert ascii to binary
00:00006B5A E349            	  2816: 	lsl.w		#1,d1						; make into index
00:00006B5C 43FA0012        	  2817: 	lea			tblPow2,a1
00:00006B60 32311000        	  2818: 	move.w	(a1,d1.w),d1
00:00006B64 E159            	  2819: 	rol.w		#8,d1						; reverse byte order
00:00006B66 33C1FD0FFC00    	  2820: 	move.w	d1,RST_REG
00:00006B6C 6000FDB2        	  2821: 	bra			Monitor
                            	  2822: 
                            	  2823: tblPow2:
00:00006B70 0001            	  2824: 	dc.w		1
00:00006B72 0002            	  2825: 	dc.w		2
00:00006B74 0004            	  2826: 	dc.w		4
00:00006B76 0008            	  2827: 	dc.w		8
00:00006B78 0010            	  2828: 	dc.w		16
00:00006B7A 0020            	  2829: 	dc.w		32
00:00006B7C 0040            	  2830: 	dc.w		64
00:00006B7E 0080            	  2831: 	dc.w		128
00:00006B80 0100            	  2832: 	dc.w		256
00:00006B82 0200            	  2833: 	dc.w		512
00:00006B84 0400            	  2834: 	dc.w		1024
00:00006B86 0800            	  2835: 	dc.w		2048
00:00006B88 1000            	  2836: 	dc.w		4096
00:00006B8A 2000            	  2837: 	dc.w		8192
00:00006B8C 4000            	  2838: 	dc.w		16384
00:00006B8E 8000            	  2839: 	dc.w		32768
                            	  2840: 	even
                            	  2841: 	
                            	  2842: cmdHelp:
                            	  2843: DisplayHelp:
00:00006B90 43FA000A        	  2844: 	lea			HelpMsg,a1
00:00006B94 6100F122        	  2845: 	bsr			DisplayString
00:00006B98 6000FD86        	  2846: 	bra			Monitor
                            	  2847: 
                            	  2848: HelpMsg:
00:00006B9C 3F203D2044697370	  2849: 	dc.b	"? = Display help",LF,CR
00:00006BA4 6C61792068656C70
00:00006BAC 0A
00:00006BAD 0D
00:00006BAE 434F5245206E203D	  2850: 	dc.b  "CORE n = switch to core n, n = 2 to 9",LF,CR
00:00006BB6 2073776974636820
00:00006BBE 746F20636F726520
00:00006BC6 6E2C206E203D2032
00:00006BCE 20746F2039
00:00006BD3 0A
00:00006BD4 0D
00:00006BD5 5245534554206E20	  2851: 	dc.b  "RESET n = reset core n",LF,CR
00:00006BDD 3D20726573657420
00:00006BE5 636F7265206E
00:00006BEB 0A
00:00006BEC 0D
00:00006BED 434C53203D20636C	  2852: 	dc.b	"CLS = clear screen",LF,CR
00:00006BF5 6561722073637265
00:00006BFD 656E
00:00006BFF 0A
00:00006C00 0D
00:00006C01 4542203D20456469	  2853: 	dc.b	"EB = Edit memory bytes, EW, EL",LF,CR
00:00006C09 74206D656D6F7279
00:00006C11 2062797465732C20
00:00006C19 45572C20454C
00:00006C1F 0A
00:00006C20 0D
00:00006C21 4642203D2046696C	  2854: 	dc.b	"FB = Fill memory bytes, FW, FL",LF,CR
00:00006C29 6C206D656D6F7279
00:00006C31 2062797465732C20
00:00006C39 46572C20464C
00:00006C3F 0A
00:00006C40 0D
00:00006C41 464D544B203D2072	  2855: 	dc.b	"FMTK = run Femtiki OS",LF,CR
00:00006C49 756E2046656D7469
00:00006C51 6B69204F53
00:00006C56 0A
00:00006C57 0D
00:00006C58 4C203D204C6F6164	  2856: 	dc.b	"L = Load S19 file",LF,CR
00:00006C60 205331392066696C
00:00006C68 65
00:00006C69 0A
00:00006C6A 0D
00:00006C6B 44203D2044756D70	  2857: 	dc.b	"D = Dump memory, DR = dump registers",LF,CR
00:00006C73 206D656D6F72792C
00:00006C7B 204452203D206475
00:00006C83 6D70207265676973
00:00006C8B 74657273
00:00006C8F 0A
00:00006C90 0D
00:00006C91 4449203D20446973	  2858: 	dc.b	"DI = Disassemble",LF,CR
00:00006C99 617373656D626C65
00:00006CA1 0A
00:00006CA2 0D
00:00006CA3 4241203D20737461	  2859: 	dc.b	"BA = start tiny basic",LF,CR
00:00006CAB 72742074696E7920
00:00006CB3 6261736963
00:00006CB8 0A
00:00006CB9 0D
00:00006CBA 4252203D20736574	  2860: 	dc.b  "BR = set breakpoint",LF,CR
00:00006CC2 20627265616B706F
00:00006CCA 696E74
00:00006CCD 0A
00:00006CCE 0D
00:00006CCF 4A203D204A756D70	  2861: 	dc.b	"J = Jump to code",LF,CR
00:00006CD7 20746F20636F6465
00:00006CDF 0A
00:00006CE0 0D
00:00006CE1 53203D2073656E64	  2862: 	dc.b  "S = send to serial port",LF,CR
00:00006CE9 20746F2073657269
00:00006CF1 616C20706F7274
00:00006CF8 0A
00:00006CF9 0D
00:00006CFA 54203D2063707520	  2863: 	dc.b	"T = cpu test program",LF,CR
00:00006D02 746573742070726F
00:00006D0A 6772616D
00:00006D0E 0A
00:00006D0F 0D
00:00006D10 5452414D203D2074	  2864: 	dc.b	"TRAM = test RAM",LF,CR,0
00:00006D18 6573742052414D
00:00006D1F 0A
00:00006D20 0D
00:00006D21 00
                            	  2865: 
                            	  2866: msgUnknownCmd:
00:00006D22 636F6D6D616E6420	  2867: 	dc.b	"command unknown",0
00:00006D2A 756E6B6E6F776E
00:00006D31 00
                            	  2868: 
                            	  2869: msgHello:
00:00006D32 0A              	  2870: 	dc.b	LF,CR,"Hello World!",LF,CR,0
00:00006D33 0D
00:00006D34 48656C6C6F20576F
00:00006D3C 726C6421
00:00006D40 0A
00:00006D41 0D
00:00006D42 00
                            	  2871: 	even
                            	  2872: 
                            	  2873: ;------------------------------------------------------------------------------
                            	  2874: ; This routine borrowed from Gordo's Tiny Basic interpreter.
                            	  2875: ; Used to fetch a command line. (Not currently used).
                            	  2876: ;
                            	  2877: ; d0.b	- command prompt
                            	  2878: ;------------------------------------------------------------------------------
                            	  2879: 
                            	  2880: GetCmdLine:
00:00006D44 610015A4        	  2881: 		bsr		OutputChar		; display prompt
00:00006D48 103C0020        	  2882: 		move.b	#' ',d0
00:00006D4C 6100159C        	  2883: 		bsr		OutputChar
00:00006D50 41F900040040    	  2884: 		lea		CmdBuf,a0
                            	  2885: .0001:
00:00006D56 6100F45C        	  2886: 		bsr		GetKey
00:00006D5A B03C0008        	  2887: 		cmp.b	#CTRLH,d0
00:00006D5E 6728            	  2888: 		beq.s	.0003
00:00006D60 B03C0018        	  2889: 		cmp.b	#CTRLX,d0
00:00006D64 6746            	  2890: 		beq.s	.0004
00:00006D66 B03C000D        	  2891: 		cmp.b	#CR,d0
00:00006D6A 6706            	  2892: 		beq.s	.0002
00:00006D6C B03C0020        	  2893: 		cmp.b	#' ',d0
00:00006D70 65E4            	  2894: 		bcs.s	.0001
                            	  2895: .0002:
00:00006D72 1080            	  2896: 		move.b	d0,(a0)
00:00006D74 5088            	  2897: 		lea			8(a0),a0
00:00006D76 61001572        	  2898: 		bsr		OutputChar
00:00006D7A B03C000D        	  2899: 		cmp.b	#CR,d0
00:00006D7E 675E            	  2900: 		beq		.0007
00:00006D80 B1FC0004007F    	  2901: 		cmp.l	#CmdBufEnd-1,a0
00:00006D86 65CE            	  2902: 		bcs.s	.0001
                            	  2903: .0003:
00:00006D88 103C0008        	  2904: 		move.b	#CTRLH,d0
00:00006D8C 6100155C        	  2905: 		bsr		OutputChar
00:00006D90 103C0020        	  2906: 		move.b	#' ',d0
00:00006D94 61001554        	  2907: 		bsr		OutputChar
00:00006D98 B1FC00040040    	  2908: 		cmp.l	#CmdBuf,a0
00:00006D9E 63B6            	  2909: 		bls.s	.0001
00:00006DA0 103C0008        	  2910: 		move.b	#CTRLH,d0
00:00006DA4 61001544        	  2911: 		bsr		OutputChar
00:00006DA8 5388            	  2912: 		subq.l	#1,a0
00:00006DAA 60AA            	  2913: 		bra.s	.0001
                            	  2914: .0004:
00:00006DAC 2208            	  2915: 		move.l	a0,d1
00:00006DAE 92BC00040040    	  2916: 		sub.l	#CmdBuf,d1
00:00006DB4 671E            	  2917: 		beq.s	.0006
00:00006DB6 5341            	  2918: 		subq	#1,d1
                            	  2919: .0005:
00:00006DB8 103C0008        	  2920: 		move.b	#CTRLH,d0
00:00006DBC 6100152C        	  2921: 		bsr		OutputChar
00:00006DC0 103C0020        	  2922: 		move.b	#' ',d0
00:00006DC4 61001524        	  2923: 		bsr		OutputChar
00:00006DC8 103C0008        	  2924: 		move.b	#CTRLH,d0
00:00006DCC 6100151C        	  2925: 		bsr		OutputChar
00:00006DD0 51C9FFE6        	  2926: 		dbra	d1,.0005
                            	  2927: .0006:
00:00006DD4 41F900040040    	  2928: 		lea		CmdBuf,a0
00:00006DDA 6000FF7A        	  2929: 		bra		.0001
                            	  2930: .0007:
00:00006DDE 103C000A        	  2931: 		move.b	#LF,d0
00:00006DE2 61001506        	  2932: 		bsr		OutputChar
00:00006DE6 4E75            	  2933: 		rts
                            	  2934: 
                            	  2935: ;------------------------------------------------------------------------------
                            	  2936: ; S <address> <length>
                            	  2937: ; Send data buffer to serial port
                            	  2938: ; S 40000 40
                            	  2939: ;------------------------------------------------------------------------------
                            	  2940: 
                            	  2941: cmdSendSerial:
00:00006DE8 61000156        	  2942: 	bsr			ignBlanks
00:00006DEC 610003FC        	  2943: 	bsr			GetHexNumber
00:00006DF0 6700FB2E        	  2944: 	beq			Monitor
00:00006DF4 2C01            	  2945: 	move.l	d1,d6					; d6 points to buffer
00:00006DF6 61000148        	  2946: 	bsr			ignBlanks
00:00006DFA 610003EE        	  2947: 	bsr			GetHexNumber
00:00006DFE 6602            	  2948: 	bne.s		.0003
00:00006E00 7210            	  2949: 	moveq		#16,d1
                            	  2950: .0003:
00:00006E02 2246            	  2951: 	move.l	d6,a1					; a1 points to buffer
00:00006E04 2401            	  2952: 	move.l	d1,d2					; d2 = count of bytes to send
00:00006E06 6008            	  2953: 	bra.s		.0002					; enter loop at bottom
                            	  2954: .0001:
00:00006E08 1219            	  2955: 	move.b	(a1)+,d1
00:00006E0A 303C0022        	  2956: 	move.w	#34,d0				; serial putchar
00:00006E0E 4E4F            	  2957: 	trap		#15
                            	  2958: .0002:
00:00006E10 51CAFFF6        	  2959: 	dbra		d2,.0001
00:00006E14 6000FB0A        	  2960: 	bra			Monitor
                            	  2961: 		
                            	  2962: ;------------------------------------------------------------------------------
                            	  2963: ; R <address> <length>
                            	  2964: ; Send data buffer to serial port
                            	  2965: ; R 10000 40
                            	  2966: ;------------------------------------------------------------------------------
                            	  2967: 
                            	  2968: cmdReceiveSerial:
00:00006E18 61000126        	  2969: 	bsr			ignBlanks
00:00006E1C 610003CC        	  2970: 	bsr			GetHexNumber
00:00006E20 6700FAFE        	  2971: 	beq			Monitor
00:00006E24 2C01            	  2972: 	move.l	d1,d6					; d6 points to buffer
00:00006E26 61000118        	  2973: 	bsr			ignBlanks
00:00006E2A 610003BE        	  2974: 	bsr			GetHexNumber
00:00006E2E 6602            	  2975: 	bne.s		.0003
00:00006E30 7210            	  2976: 	moveq		#16,d1
                            	  2977: .0003:
00:00006E32 2246            	  2978: 	move.l	d6,a1					; a1 points to buffer
00:00006E34 2401            	  2979: 	move.l	d1,d2					; d2 = count of bytes to send
00:00006E36 600C            	  2980: 	bra.s		.0002					; enter loop at bottom
                            	  2981: .0001:
00:00006E38 303C0024        	  2982: 	move.w	#36,d0				; serial peek char
00:00006E3C 4E4F            	  2983: 	trap		#15
00:00006E3E 4A81            	  2984: 	tst.l		d1
00:00006E40 6BF6            	  2985: 	bmi.s		.0001
00:00006E42 12C1            	  2986: 	move.b	d1,(a1)+
                            	  2987: .0002:
00:00006E44 51CAFFF2        	  2988: 	dbra		d2,.0001
00:00006E48 6000FAD6        	  2989: 	bra			Monitor
                            	  2990: 		
                            	  2991: ;------------------------------------------------------------------------------
                            	  2992: ; Fill memory
                            	  2993: ;
                            	  2994: ; FB = fill bytes		FB 00000010 100 FF	; fill starting at 10 for 256 bytes
                            	  2995: ; FB = fill bytes		FB 00000010 100 R		; fill with random bytes
                            	  2996: ; FW = fill words
                            	  2997: ; FL = fill longs
                            	  2998: ; F = fill bytes
                            	  2999: ;------------------------------------------------------------------------------
                            	  3000: 
                            	  3001: cmdFillB:
00:00006E4C 610000F2        	  3002: 	bsr			ignBlanks
00:00006E50 61000398        	  3003: 	bsr			GetHexNumber
00:00006E54 2241            	  3004: 	move.l	d1,a1					; a1 = start
00:00006E56 610000E8        	  3005: 	bsr			ignBlanks
00:00006E5A 6100038E        	  3006: 	bsr			GetHexNumber
00:00006E5E 2601            	  3007: 	move.l	d1,d3					; d3 = count
00:00006E60 6700FABE        	  3008: 	beq			Monitor
00:00006E64 610000DA        	  3009: 	bsr			ignBlanks
00:00006E68 610000E8        	  3010: 	bsr PeekScreenChar
00:00006E6C 0C010052        	  3011: 	cmpi.b #'R',d1
00:00006E70 660A            	  3012: 	bne.s .0002
00:00006E72 6100FA98        	  3013: 	bsr FromScreen
00:00006E76 1A3C0052        	  3014: 	move.b #'R',d5
00:00006E7A 6006            	  3015: 	bra.s .fmem
                            	  3016: .0002:
00:00006E7C 6100036C        	  3017: 	bsr	GetHexNumber		; fill value
00:00006E80 1801            	  3018: 	move.b d1,d4
                            	  3019: .fmem:
00:00006E82 3409            	  3020: 	move.w a1,d2
00:00006E84 4A42            	  3021: 	tst.w d2
00:00006E86 6604            	  3022: 	bne.s .0001
00:00006E88 6100F362        	  3023: 	bsr	CheckForCtrlC
                            	  3024: .0001:	
00:00006E8C 0C050052        	  3025: 	cmpi.b #'R',d5
00:00006E90 6604            	  3026: 	bne.s .0003
00:00006E92 6100982C        	  3027: 	bsr RandGetNum
                            	  3028: .0003:
00:00006E96 12C4            	  3029: 	move.b d4,(a1)+
00:00006E98 5383            	  3030: 	sub.l	#1,d3
00:00006E9A 66E6            	  3031: 	bne.s	.fmem
00:00006E9C 6000FA82        	  3032: 	bra	Monitor
                            	  3033: 	
                            	  3034: cmdFillW:
00:00006EA0 6100009E        	  3035: 	bsr			ignBlanks
00:00006EA4 61000344        	  3036: 	bsr			GetHexNumber
00:00006EA8 2241            	  3037: 	move.l	d1,a1					; a1 = start
00:00006EAA 61000094        	  3038: 	bsr			ignBlanks
00:00006EAE 6100033A        	  3039: 	bsr			GetHexNumber
00:00006EB2 2601            	  3040: 	move.l	d1,d3					; d3 = count
00:00006EB4 6700FA6A        	  3041: 	beq			Monitor
00:00006EB8 61000086        	  3042: 	bsr			ignBlanks
00:00006EBC 61000094        	  3043: 	bsr PeekScreenChar
00:00006EC0 0C010052        	  3044: 	cmpi.b #'R',d1
00:00006EC4 660A            	  3045: 	bne.s .0002
00:00006EC6 6100FA44        	  3046: 	bsr FromScreen
00:00006ECA 1A3C0052        	  3047: 	move.b #'R',d5
00:00006ECE 6006            	  3048: 	bra.s .fmem
                            	  3049: .0002:
00:00006ED0 61000318        	  3050: 	bsr	GetHexNumber			; fill value
00:00006ED4 3801            	  3051: 	move.w d1,d4
                            	  3052: .fmem:
00:00006ED6 3409            	  3053: 	move.w a1,d2
00:00006ED8 4A42            	  3054: 	tst.w d2
00:00006EDA 6604            	  3055: 	bne.s .0001
00:00006EDC 6100F30E        	  3056: 	bsr	CheckForCtrlC
                            	  3057: .0001:	
00:00006EE0 0C050052        	  3058: 	cmpi.b #'R',d5
00:00006EE4 6604            	  3059: 	bne.s .0003
00:00006EE6 610097D8        	  3060: 	bsr RandGetNum
                            	  3061: .0003:
00:00006EEA 32C4            	  3062: 	move.w d4,(a1)+
00:00006EEC 5383            	  3063: 	sub.l	#1,d3
00:00006EEE 66E6            	  3064: 	bne.s	.fmem
00:00006EF0 6000FA2E        	  3065: 	bra	Monitor
                            	  3066: 	
                            	  3067: cmdFillL:
00:00006EF4 614A            	  3068: 	bsr			ignBlanks
00:00006EF6 610002F2        	  3069: 	bsr			GetHexNumber
00:00006EFA 2241            	  3070: 	move.l	d1,a1					; a1 = start
00:00006EFC 6142            	  3071: 	bsr			ignBlanks
00:00006EFE 610002EA        	  3072: 	bsr			GetHexNumber
00:00006F02 2601            	  3073: 	move.l	d1,d3					; d3 = count
00:00006F04 6700FA1A        	  3074: 	beq			Monitor
00:00006F08 6136            	  3075: 	bsr			ignBlanks
00:00006F0A 6146            	  3076: 	bsr PeekScreenChar
00:00006F0C 0C010052        	  3077: 	cmpi.b #'R',d1
00:00006F10 660A            	  3078: 	bne.s .0002
00:00006F12 6100F9F8        	  3079: 	bsr FromScreen
00:00006F16 1A3C0052        	  3080: 	move.b #'R',d5
00:00006F1A 6006            	  3081: 	bra.s .fmem
                            	  3082: .0002:
00:00006F1C 610002CC        	  3083: 	bsr			GetHexNumber	; fill value
00:00006F20 2801            	  3084: 	move.l d1,d4
                            	  3085: .fmem:
00:00006F22 3409            	  3086: 	move.w a1,d2
00:00006F24 4A42            	  3087: 	tst.w d2
00:00006F26 6604            	  3088: 	bne.s .0001
00:00006F28 6100F2C2        	  3089: 	bsr	CheckForCtrlC
                            	  3090: .0001:	
00:00006F2C 0C050052        	  3091: 	cmpi.b #'R',d5
00:00006F30 6604            	  3092: 	bne.s .0003
00:00006F32 6100978C        	  3093: 	bsr RandGetNum
                            	  3094: .0003:
00:00006F36 22C4            	  3095: 	move.l d4,(a1)+
00:00006F38 5383            	  3096: 	sub.l	#1,d3
00:00006F3A 66E6            	  3097: 	bne.s	.fmem
00:00006F3C 6000F9E2        	  3098: 	bra	Monitor
                            	  3099: 	
                            	  3100: ;------------------------------------------------------------------------------
                            	  3101: ; Modifies:
                            	  3102: ;	a0	- text pointer
                            	  3103: ;------------------------------------------------------------------------------
                            	  3104: 
                            	  3105: ignBlanks:
00:00006F40 2F01            	  3106: 	move.l d1,-(a7)
                            	  3107: .0001:
00:00006F42 6100F9C8        	  3108: 	bsr	FromScreen
00:00006F46 0C010020        	  3109: 	cmpi.b #' ',d1
00:00006F4A 67F6            	  3110: 	beq.s .0001
                            	  3111: 	if (SCREEN_FORMAT==1)
00:00006F4C 5988            	  3112: 		lea	-4(a0),a0
                            	  3113: 	else
                            	  3114: 		lea	-8(a0),a0
                            	  3115: 	endif
00:00006F4E 221F            	  3116: 	move.l (a7)+,d1
00:00006F50 4E75            	  3117: 	rts
                            	  3118: 
                            	  3119: 
                            	  3120: ;------------------------------------------------------------------------------
                            	  3121: ;------------------------------------------------------------------------------
                            	  3122: 
                            	  3123: PeekScreenChar:
00:00006F52 2210            	  3124: 	move.l (a0),d1
00:00006F54 60000BBE        	  3125: 	bra rbo
                            	  3126: 
                            	  3127: ;------------------------------------------------------------------------------
                            	  3128: ; Get the size character
                            	  3129: ; If the size is not recognized, assume a byte size
                            	  3130: ;
                            	  3131: ; Modifies:
                            	  3132: ;		a0	- text pointer
                            	  3133: ;		d1
                            	  3134: ; Returns:
                            	  3135: ;		d4 = size character 'B','W' or 'L'
                            	  3136: ;------------------------------------------------------------------------------
                            	  3137: 
                            	  3138: GetSzChar:
00:00006F58 61E6            	  3139: 	bsr	ignBlanks
00:00006F5A 7842            	  3140: 	moveq #'B',d4		; assume byte
00:00006F5C 2210            	  3141: 	move.l (a0),d1
00:00006F5E 61000BB4        	  3142: 	bsr	rbo
00:00006F62 0C010042        	  3143: 	cmpi.b #'B',d1
00:00006F66 670E            	  3144: 	beq.s .0002
00:00006F68 0C010057        	  3145: 	cmpi.b #'W',d1
00:00006F6C 6708            	  3146: 	beq.s .0002
00:00006F6E 0C01004C        	  3147: 	cmpi.b #'L',d1
00:00006F72 6702            	  3148: 	beq.s .0002
00:00006F74 4E75            	  3149: 	rts
                            	  3150: .0002:
00:00006F76 6100F994        	  3151: 	bsr FromScreen
00:00006F7A 1801            	  3152: 	move.b d1,d4
00:00006F7C 4E75            	  3153: 	rts
                            	  3154: 
                            	  3155: ;------------------------------------------------------------------------------
                            	  3156: ; Edit memory byte.
                            	  3157: ;    Bytes are built into long words in case the memory is only longword
                            	  3158: ; accessible.
                            	  3159: ;------------------------------------------------------------------------------
                            	  3160: 
                            	  3161: EditMemHelper:
00:00006F7E 61C0            	  3162: 	bsr ignBlanks
00:00006F80 61000268        	  3163: 	bsr GetHexNumber
00:00006F84 0C04004C        	  3164: 	cmpi.b #'L',d4
00:00006F88 6604            	  3165: 	bne.s .0001
00:00006F8A 2401            	  3166: 	move.l d1,d2
00:00006F8C 4E75            	  3167: 	rts
                            	  3168: .0001:
00:00006F8E 0C040057        	  3169: 	cmpi.b #'W',d4
00:00006F92 6606            	  3170: 	bne.s .0002
00:00006F94 4842            	  3171: 	swap d2
00:00006F96 3401            	  3172: 	move.w d1,d2
00:00006F98 4E75            	  3173: 	rts
                            	  3174: .0002:
00:00006F9A E18A            	  3175: 	lsl.l #8,d2
00:00006F9C 1401            	  3176: 	move.b d1,d2
00:00006F9E 4E75            	  3177: 	rts
                            	  3178: 	
                            	  3179: cmdEditMemory:
00:00006FA0 61B6            	  3180: 	bsr GetSzChar
00:00006FA2 619C            	  3181: 	bsr ignBlanks
00:00006FA4 61000244        	  3182: 	bsr	GetHexNumber
00:00006FA8 2241            	  3183: 	move.l d1,a1
                            	  3184: edtmem1:
00:00006FAA 0C04004C        	  3185: 	cmpi.b #'L',d4
00:00006FAE 6610            	  3186: 	bne.s .0004
00:00006FB0 7400            	  3187: 	clr.l	d2
00:00006FB2 61CA            	  3188: 	bsr EditMemHelper
00:00006FB4 22C2            	  3189: 	move.l d2,(a1)+
00:00006FB6 7400            	  3190: 	clr.l	d2
00:00006FB8 61C4            	  3191: 	bsr EditMemHelper
00:00006FBA 22C2            	  3192: 	move.l d2,(a1)+
00:00006FBC 6000F962        	  3193: 	bra Monitor
                            	  3194: .0004:
00:00006FC0 0C040057        	  3195: 	cmpi.b #'W',d4
00:00006FC4 6614            	  3196: 	bne.s .0005
00:00006FC6 7400            	  3197: 	clr.l	d2
00:00006FC8 61B4            	  3198: 	bsr EditMemHelper
00:00006FCA 61B2            	  3199: 	bsr EditMemHelper
00:00006FCC 22C2            	  3200: 	move.l d2,(a1)+
00:00006FCE 7400            	  3201: 	clr.l	d2
00:00006FD0 61AC            	  3202: 	bsr EditMemHelper
00:00006FD2 61AA            	  3203: 	bsr EditMemHelper
00:00006FD4 22C2            	  3204: 	move.l d2,(a1)+
00:00006FD6 6000F948        	  3205: 	bra Monitor
                            	  3206: .0005:
00:00006FDA 7400            	  3207: 	clr.l	d2
00:00006FDC 61A0            	  3208: 	bsr EditMemHelper
00:00006FDE 619E            	  3209: 	bsr EditMemHelper
00:00006FE0 619C            	  3210: 	bsr EditMemHelper
00:00006FE2 619A            	  3211: 	bsr EditMemHelper
00:00006FE4 22C2            	  3212: 	move.l d2,(a1)+
00:00006FE6 7400            	  3213: 	clr.l	d2
00:00006FE8 6194            	  3214: 	bsr EditMemHelper
00:00006FEA 6192            	  3215: 	bsr EditMemHelper
00:00006FEC 6190            	  3216: 	bsr EditMemHelper
00:00006FEE 618E            	  3217: 	bsr EditMemHelper
00:00006FF0 22C2            	  3218: 	move.l d2,(a1)+
00:00006FF2 6000F92C        	  3219: 	bra Monitor
                            	  3220: 
                            	  3221: ;------------------------------------------------------------------------------
                            	  3222: ; Execute code at the specified address.
                            	  3223: ;------------------------------------------------------------------------------
                            	  3224: 
                            	  3225: cmdJump:
                            	  3226: ExecuteCode:
00:00006FF6 6100FF48        	  3227: 	bsr	ignBlanks
00:00006FFA 610001EE        	  3228: 	bsr	GetHexNumber
00:00006FFE 2041            	  3229: 	move.l d1,a0
00:00007000 4E90            	  3230: 	jsr	(a0)
00:00007002 6000F91C        	  3231: 	bra Monitor
                            	  3232: 
                            	  3233: ;------------------------------------------------------------------------------
                            	  3234: ; Disassemble code
                            	  3235: ; DI 1000
                            	  3236: ;------------------------------------------------------------------------------
                            	  3237: ;        CALLING SEQUENCE:
                            	  3238: ;   D0,D1,D2 = CODE TO BE DISASSEMBLED
                            	  3239: ;   A4 = VALUE OF PROGRAM COUNTER FOR THE CODE
                            	  3240: ;   A5 = POINTER TO STORE DATA (BUFSIZE = 80 ASSUMED)
                            	  3241: ;        JSR       DCODE68K
                            	  3242: ;
                            	  3243: ;        RETURN:
                            	  3244: ;   A4 = VALUE OF PROGRAM COUNTER FOR NEXT INSTRUCTION
                            	  3245: ;   A5 = POINTER TO LINE AS DISASSEMBLED
                            	  3246: ;   A6 = POINTER TO END OF LINE
                            	  3247: 
                            	  3248: 
                            	  3249: cmdDisassemble:
00:00007006 6100FF38        	  3250: 	bsr ignBlanks
00:0000700A 610001DE        	  3251: 	bsr GetHexNumber
00:0000700E 6700F910        	  3252: 	beq Monitor
00:00007012 363C0014        	  3253: 	move.w #20,d3			; number of lines to disassemble
                            	  3254: .0002:
00:00007016 2F03            	  3255: 	move.l d3,-(a7)
00:00007018 2041            	  3256: 	move.l d1,a0
00:0000701A 2841            	  3257: 	move.l d1,a4			; a4 = PC of code
00:0000701C 3018            	  3258: 	move.w (a0)+,d0		; d0 to d2 = bytes of instruction to decode
00:0000701E 4840            	  3259: 	swap d0
00:00007020 3018            	  3260: 	move.w (a0)+,d0
00:00007022 3218            	  3261: 	move.w (a0)+,d1		; d0 to d2 = bytes of instruction to decode
00:00007024 4841            	  3262: 	swap d1
00:00007026 3218            	  3263: 	move.w (a0)+,d1
00:00007028 3418            	  3264: 	move.w (a0)+,d2		; d0 to d2 = bytes of instruction to decode
00:0000702A 4842            	  3265: 	swap d2
00:0000702C 3418            	  3266: 	move.w (a0)+,d2
00:0000702E 4BF900040800    	  3267: 	lea _dasmbuf,a5		; a5 = pointer to disassembly buffer
00:00007034 61001DC0        	  3268: 	bsr DCODE68K	
00:00007038 383C003E        	  3269: 	move.w #62,d4
                            	  3270: .0001:
00:0000703C 121D            	  3271: 	move.b (a5)+,d1
00:0000703E 610012AA        	  3272: 	bsr OutputChar
00:00007042 51CCFFF8        	  3273: 	dbra d4,.0001
00:00007046 6100E9BE        	  3274: 	bsr CRLF
00:0000704A 220C            	  3275: 	move.l a4,d1
00:0000704C 261F            	  3276: 	move.l (a7)+,d3
00:0000704E 51CBFFC6        	  3277: 	dbra d3,.0002
00:00007052 6000F8CC        	  3278: 	bra Monitor
                            	  3279: 	
                            	  3280: ;------------------------------------------------------------------------------
                            	  3281: ; Do a memory dump of the requested location.
                            	  3282: ; DB 0800 0850
                            	  3283: ;------------------------------------------------------------------------------
                            	  3284: 
                            	  3285: cmdDumpMemory:
00:00007056 6100FF00        	  3286: 	bsr GetSzChar
00:0000705A 6100FEE4        	  3287: 	bsr ignBlanks
00:0000705E 6100018A        	  3288: 	bsr	GetHexNumber
00:00007062 6700F8BC        	  3289: 	beq	Monitor					; was there a number ? no, other garbage, just ignore
00:00007066 2601            	  3290: 	move.l d1,d3				; save off start of range
00:00007068 6100FED6        	  3291: 	bsr	ignBlanks
00:0000706C 6100017C        	  3292: 	bsr	GetHexNumber
00:00007070 6608            	  3293: 	bne.s	DumpMem1
00:00007072 2203            	  3294: 	move.l d3,d1
00:00007074 068100000040    	  3295: 	addi.l #64,d1				;	no end specified, just dump 64 bytes
                            	  3296: DumpMem1:
00:0000707A 2043            	  3297: 	move.l d3,a0
00:0000707C 2241            	  3298: 	move.l d1,a1
00:0000707E 6100E986        	  3299: 	bsr	CRLF
                            	  3300: .0001:
00:00007082 B3C8            	  3301: 	cmpa.l a0,a1
00:00007084 6300F89A        	  3302: 	bls	Monitor
00:00007088 6102            	  3303: 	bsr	DisplayMem
00:0000708A 60F6            	  3304: 	bra.s	.0001
                            	  3305: 
                            	  3306: ;------------------------------------------------------------------------------
                            	  3307: ; Display memory dump in a format suitable for edit.
                            	  3308: ;
                            	  3309: ;	EB 12345678 00 11 22 33 44 55 66 77  "........"
                            	  3310: ;
                            	  3311: ; Modifies:
                            	  3312: ;		d1,d2,a0
                            	  3313: ;------------------------------------------------------------------------------
                            	  3314: 	
                            	  3315: DisplayMem:
00:0000708C 123C0045        	  3316: 	move.b #'E',d1
00:00007090 61001258        	  3317: 	bsr	OutputChar
00:00007094 1204            	  3318: 	move.b d4,d1
00:00007096 61001252        	  3319: 	bsr OutputChar
00:0000709A 61000720        	  3320: 	bsr DisplaySpace
00:0000709E 2208            	  3321: 	move.l a0,d1
00:000070A0 61000722        	  3322: 	bsr	DisplayTetra
00:000070A4 7407            	  3323: 	moveq #7,d2						; assume bytes
00:000070A6 0C04004C        	  3324: 	cmpi.b #'L',d4
00:000070AA 6604            	  3325: 	bne.s .0004
00:000070AC 7401            	  3326: 	moveq	#1,d2
00:000070AE 6008            	  3327: 	bra.s dspmem1
                            	  3328: .0004:
00:000070B0 0C040057        	  3329: 	cmpi.b #'W',d4
00:000070B4 6602            	  3330: 	bne.s dspmem1
00:000070B6 7403            	  3331: 	moveq #3,d2
                            	  3332: dspmem1:
00:000070B8 123C0020        	  3333: 	move.b #' ',d1
00:000070BC 6100122C        	  3334: 	bsr	OutputChar
00:000070C0 0C04004C        	  3335: 	cmpi.b #'L',d4
00:000070C4 6608            	  3336: 	bne.s .0005
00:000070C6 2218            	  3337: 	move.l (a0)+,d1
00:000070C8 610006FA        	  3338: 	bsr	DisplayTetra
00:000070CC 6014            	  3339: 	bra.s .0006
                            	  3340: .0005:
00:000070CE 0C040057        	  3341: 	cmpi.b #'W',d4
00:000070D2 6608            	  3342: 	bne.s .0007
00:000070D4 3218            	  3343: 	move.w (a0)+,d1
00:000070D6 610006F2        	  3344: 	bsr	DisplayWyde
00:000070DA 6006            	  3345: 	bra.s .0006
                            	  3346: .0007:
00:000070DC 1218            	  3347: 	move.b (a0)+,d1
00:000070DE 610006F0        	  3348: 	bsr DisplayByte
                            	  3349: .0006:
00:000070E2 51CAFFD4        	  3350: 	dbra d2,dspmem1
00:000070E6 610006C2        	  3351: 	bsr	DisplayTwoSpaces
00:000070EA 123C0022        	  3352: 	move.b #34,d1
00:000070EE 610011FA        	  3353: 	bsr	OutputChar
00:000070F2 5188            	  3354: 	lea	-8(a0),a0
00:000070F4 7407            	  3355: 	moveq	#7,d2
                            	  3356: .0002:
00:000070F6 1218            	  3357: 	move.b (a0)+,d1
00:000070F8 B23C0020        	  3358: 	cmp.b	#' ',d1
00:000070FC 6506            	  3359: 	blo.s	.0003
00:000070FE B23C007F        	  3360: 	cmp.b	#127,d1
00:00007102 6304            	  3361: 	bls.s	.0001
                            	  3362: .0003:
00:00007104 123C002E        	  3363: 	move.b #'.',d1
                            	  3364: .0001:
00:00007108 610011E0        	  3365: 	bsr	OutputChar
00:0000710C 51CAFFE8        	  3366: 	dbra d2,.0002
00:00007110 123C0022        	  3367: 	move.b #34,d1
00:00007114 610011D4        	  3368: 	bsr	OutputChar
00:00007118 6100F0D2        	  3369: 	bsr	CheckForCtrlC
00:0000711C 6000E8E8        	  3370: 	bra	CRLF
                            	  3371: 
                            	  3372: ;------------------------------------------------------------------------------
                            	  3373: ; Dump Registers
                            	  3374: ;    The dump is in a format that allows the register value to be edited.
                            	  3375: ;
                            	  3376: ; RegD0 12345678
                            	  3377: ; RegD1 77777777
                            	  3378: ;	... etc
                            	  3379: ;------------------------------------------------------------------------------
                            	  3380: 
                            	  3381: cmdDumpRegs:
00:00007120 6100E8E4        	  3382: 	bsr	CRLF
00:00007124 363C000F        	  3383: 	move.w #15,d3						; number of registers-1
00:00007128 41FA007A        	  3384: 	lea	msg_reglist,a0			;
00:0000712C 43FA0072        	  3385: 	lea	msg_regs,a1
00:00007130 45F900040100    	  3386: 	lea	Regsave,a2					; a2 points to register save area
                            	  3387: .0001:
00:00007136 6100EB80        	  3388: 	bsr			DisplayString
00:0000713A 1218            	  3389: 	move.b	(a0)+,d1
00:0000713C 610011AC        	  3390: 	bsr			OutputChar
00:00007140 1218            	  3391: 	move.b	(a0)+,d1
00:00007142 610011A6        	  3392: 	bsr			OutputChar
00:00007146 61000674        	  3393: 	bsr			DisplaySpace
00:0000714A 221A            	  3394: 	move.l	(a2)+,d1
00:0000714C 61000676        	  3395: 	bsr			DisplayTetra
00:00007150 6100E8B4        	  3396: 	bsr			CRLF
00:00007154 51CBFFE0        	  3397: 	dbra		d3,.0001
00:00007158 6100EB5E        	  3398: 	bsr			DisplayString
00:0000715C 1218            	  3399: 	move.b	(a0)+,d1
00:0000715E 6100118A        	  3400: 	bsr			OutputChar
00:00007162 1218            	  3401: 	move.b	(a0)+,d1
00:00007164 61001184        	  3402: 	bsr			OutputChar
00:00007168 61000652        	  3403: 	bsr			DisplaySpace
00:0000716C 223900040144    	  3404: 	move.l	Regsave+$44,d1
00:00007172 61000650        	  3405: 	bsr			DisplayTetra
00:00007176 6100E88E        	  3406: 	bsr			CRLF
00:0000717A 6100EB3C        	  3407: 	bsr			DisplayString
00:0000717E 1218            	  3408: 	move.b	(a0)+,d1
00:00007180 61001168        	  3409: 	bsr			OutputChar
00:00007184 1218            	  3410: 	move.b	(a0)+,d1
00:00007186 61001162        	  3411: 	bsr			OutputChar
00:0000718A 61000630        	  3412: 	bsr			DisplaySpace
00:0000718E 323900040140    	  3413: 	move.w	Regsave+$40,d1
00:00007194 61000634        	  3414: 	bsr			DisplayWyde
00:00007198 6100E86C        	  3415: 	bsr			CRLF
00:0000719C 6000F782        	  3416: 	bra			Monitor
                            	  3417: 
                            	  3418: msg_regs:
00:000071A0 526567          	  3419: 	dc.b	"Reg",0
00:000071A3 00
                            	  3420: msg_reglist:
00:000071A4 4430443144324433	  3421: 	dc.b	"D0D1D2D3D4D5D6D7A0A1A2A3A4A5A6A7PCSR",0
00:000071AC 4434443544364437
00:000071B4 4130413141324133
00:000071BC 4134413541364137
00:000071C4 50435352
00:000071C8 00
                            	  3422: 
                            	  3423: 	align	1
                            	  3424: 
                            	  3425: ;------------------------------------------------------------------------------
                            	  3426: ;------------------------------------------------------------------------------
                            	  3427: 
                            	  3428: cmdTestSerialReceive:
                            	  3429: .0002:
00:000071CA 7024            	  3430: 	moveq		#36,d0				; serial get char from buffer
00:000071CC 4E4F            	  3431: 	trap		#15
                            	  3432: ;	bsr			SerialPeekCharDirect
00:000071CE 4A41            	  3433: 	tst.w		d1
00:000071D0 6B0A            	  3434: 	bmi.s		.0001
00:000071D2 0C01001A        	  3435: 	cmpi.b	#CTRLZ,d1
00:000071D6 670A            	  3436: 	beq			.0003
00:000071D8 61001110        	  3437: 	bsr			OutputChar
                            	  3438: .0001:	
00:000071DC 6100F00E        	  3439: 	bsr			CheckForCtrlC
00:000071E0 60E8            	  3440: 	bra			.0002
                            	  3441: .0003:
00:000071E2 6100EE10        	  3442: 	bsr			_KeybdInit
00:000071E6 6000F738        	  3443: 	bra			Monitor
                            	  3444: 
                            	  3445: ;------------------------------------------------------------------------------
                            	  3446: ; Get a hexidecimal number. Maximum of eight digits.
                            	  3447: ;
                            	  3448: ; Returns:
                            	  3449: ;		d0 = number of digits
                            	  3450: ;		d1 = value of number
                            	  3451: ;		zf = number of digits == 0
                            	  3452: ;------------------------------------------------------------------------------
                            	  3453: 
                            	  3454: GetHexNumber:
00:000071EA 2F02            	  3455: 	move.l d2,-(a7)
00:000071EC 7400            	  3456: 	clr.l	d2
00:000071EE 7000            	  3457: 	moveq	#0,d0
                            	  3458: .0002
00:000071F0 6100F71A        	  3459: 	bsr	FromScreen
00:000071F4 6100057A        	  3460: 	bsr	AsciiToHexNybble
00:000071F8 0C0100FF        	  3461: 	cmpi.b #$ff,d1
00:000071FC 6712            	  3462: 	beq.s	.0001
00:000071FE E98A            	  3463: 	lsl.l	#4,d2
00:00007200 02810000000F    	  3464: 	andi.l #$0f,d1
00:00007206 8481            	  3465: 	or.l d1,d2
00:00007208 5240            	  3466: 	addq #1,d0
00:0000720A 0C000008        	  3467: 	cmpi.b #8,d0
00:0000720E 65E0            	  3468: 	blo.s	.0002
                            	  3469: .0001
00:00007210 2202            	  3470: 	move.l d2,d1
00:00007212 241F            	  3471: 	move.l (a7)+,d2
00:00007214 4A00            	  3472: 	tst.b	d0
00:00007216 4E75            	  3473: 	rts	
                            	  3474: 
                            	  3475: GetDecNumber:
00:00007218 48E73000        	  3476: 	movem.l d2/d3,-(a7)
00:0000721C 7400            	  3477: 	clr.l d2
00:0000721E 7000            	  3478: 	clr.l d0
                            	  3479: .0002
00:00007220 6100F6EA        	  3480: 	bsr FromScreen					; grab a character off the screen
00:00007224 6100054A        	  3481: 	bsr	AsciiToHexNybble		; convert to an ascii nybble
00:00007228 0C0100FF        	  3482: 	cmpi.b #$ff,d1
00:0000722C 6718            	  3483: 	beq.s	.0001
00:0000722E 02810000000F    	  3484: 	andi.l #$0F,d1					; d1 = 0 to 9
00:00007234 2602            	  3485: 	move.l d2,d3						; d3 = current number
00:00007236 D683            	  3486: 	add.l d3,d3							; d3*2
00:00007238 E78A            	  3487: 	lsl.l #3,d2							; current number * 8
00:0000723A D483            	  3488: 	add.l d3,d2							; current number * 10
00:0000723C D481            	  3489: 	add.l d1,d2							; add in new digit
00:0000723E 5240            	  3490: 	addq #1,d0							; increment number of digits
00:00007240 0C000009        	  3491: 	cmpi.b #9,d0						; make sure 9 or fewer
00:00007244 65DA            	  3492: 	blo .0002
                            	  3493: .0001
00:00007246 2202            	  3494: 	move.l d2,d1						; return number in d1
00:00007248 4CDF000C        	  3495: 	movem.l (a7)+,d2/d3
00:0000724C 4A00            	  3496: 	tst.b d0
00:0000724E 4E75            	  3497: 	rts
                            	  3498: 	
                            	  3499: 	include "FloatToString.x68"

Source: "FloatToString.x68"
                            	     1: 	code
                            	     2: ;==============================================================================
                            	     3: ; Decimal-Floating point to string conversion routine.
                            	     4: ;
                            	     5: ; Modifies
                            	     6: ;		_fpWork work area
                            	     7: ; Register Usage:
                            	     8: ; 	fp0 = input decimal-float to convert
                            	     9: ;		fp1 = constant holder, 1.0, 10.0
                            	    10: ;		fp2 = 1.0e<fp0 exponent> value for conversion
                            	    11: ;		fp3 = holds digit value during significand conversion
                            	    12: ; 	a0 = pointer to string buffer, updated to point to NULL at end of string
                            	    13: ;		a1 = pointer to "Nan" or "Inf" message string
                            	    14: ;		d0 = temporary
                            	    15: ;		d1 = digit value during exponent, significand conversion
                            	    16: ; 	d6 = exponent
                            	    17: ;==============================================================================
                            	    18: 	align 4
00:00007250 25FF0000        	    19: _dfOne	dc.l $25ff0000,$00000000,$00000000
00:00007254 00000000
00:00007258 00000000
00:0000725C 2600C000        	    20: _dfTen	dc.l $2600C000,$00000000,$00000000
00:00007260 00000000
00:00007264 00000000
00:00007268 2606DDFA        	    21: _dfMil  dc.l $2606DDFA,$1C000000,$00000000
00:0000726C 1C000000
00:00007270 00000000
                            	    22: 
00:00007274 4E614E          	    23: _msgNan	dc.b "NaN",0
00:00007277 00
00:00007278 496E66          	    24: _msgInf dc.b "Inf",0
00:0000727B 00
                            	    25: 	even
                            	    26: 
                            	    27: ;------------------------------------------------------------------------------
                            	    28: ; Check for the special Nan and infinity values. Output the appropriate string.
                            	    29: ;
                            	    30: ; Modifies
                            	    31: ;		_fpWork area
                            	    32: ;		a0
                            	    33: ; Parameters:
                            	    34: ;		fp0 = dbl
                            	    35: ;------------------------------------------------------------------------------
                            	    36: 
                            	    37: _CheckNan:
00:0000727C 4E52FFF4        	    38: 	link a2,#-12
00:00007280 48D70201        	    39: 	movem.l d0/a1,(sp)
00:00007284 2F79000400980008	    40: 	move.l _canary,8(sp)
00:0000728C F239680000040600	    41: 	fmove.x fp0,_fpWork
00:00007294 103900040600    	    42: 	move.b _fpWork,d0				; get sign+combo
00:0000729A 0200007C        	    43: 	andi.b #$7C,d0					; mask for combo bits
00:0000729E 0C00007C        	    44: 	cmpi.b #$7C,d0					; is it the Nan combo?
00:000072A2 6606            	    45: 	bne .notNan
00:000072A4 43FAFFCE        	    46: 	lea _msgNan,a1					; output "Nan"
00:000072A8 600A            	    47: 	bra .outStr
                            	    48: .notNan
00:000072AA 0C000078        	    49: 	cmpi.b #$78,d0					; is it infinity combo?
00:000072AE 661E            	    50: 	bne .notInf
00:000072B0 43FAFFC6        	    51: 	lea _msgInf,a1
                            	    52: .outStr
00:000072B4 10D9            	    53: 	move.b (a1)+,(a0)+			; output "Inf"
00:000072B6 10D9            	    54: 	move.b (a1)+,(a0)+
00:000072B8 10D9            	    55: 	move.b (a1)+,(a0)+
00:000072BA 4210            	    56: 	clr.b (a0)
00:000072BC 4CD70201        	    57: 	movem.l (sp),d0/a1
00:000072C0 A2AF00030008    	    58: 	cchk 8(sp)
00:000072C6 4E5A            	    59: 	unlk a2
00:000072C8 003C0001        	    60: 	ori #1,ccr							; set carry and return
00:000072CC 4E75            	    61: 	rts
                            	    62: .notInf
00:000072CE 4CD70201        	    63: 	movem.l (sp),d0/a1
00:000072D2 A2AF00030008    	    64: 	cchk 8(sp)
00:000072D8 4E5A            	    65: 	unlk a2
00:000072DA 023C00FE        	    66: 	andi #$FE,ccr						; clear carry and return
00:000072DE 4E75            	    67: 	rts
                            	    68: 
                            	    69: ;------------------------------------------------------------------------------
                            	    70: ; Check for a zero value. Output a single "0" if zero,
                            	    71: ;
                            	    72: ; Modifies:
                            	    73: ;		a0
                            	    74: ; Parameters:
                            	    75: ;		fp0 = dbl
                            	    76: ;------------------------------------------------------------------------------
                            	    77: 
                            	    78: _CheckZero:
00:000072E0 F200003A        	    79: 	ftst fp0								; check if number is zero
00:000072E4 F28E000E        	    80: 	fbne .0003
00:000072E8 10FC0030        	    81: 	move.b #'0',(a0)+				; if zero output "0"
00:000072EC 4210            	    82: 	clr.b (a0)
00:000072EE 003C0004        	    83: 	ori #4,ccr							; set zf
00:000072F2 4E75            	    84: 	rts
                            	    85: .0003
00:000072F4 023C00FB        	    86: 	andi #$FB,ccr						; clear zf
00:000072F8 4E75            	    87: 	rts
                            	    88: 
                            	    89: ;------------------------------------------------------------------------------
                            	    90: ; Check for a negative number. This includes Nans and Infinities. Output a "-"
                            	    91: ; if negative.
                            	    92: ;
                            	    93: ;	Modifies
                            	    94: ;		a0
                            	    95: ; Parameters:
                            	    96: ;		fp0 = dbl
                            	    97: ;------------------------------------------------------------------------------
                            	    98: 
                            	    99: _CheckNegative:
00:000072FA F200003A        	   100: 	ftst fp0								; is number negative?
00:000072FE F293000A        	   101: 	fbge .0002
00:00007302 10FC002D        	   102: 	move.b #'-',(a0)+				; yes, output '-'
00:00007306 F200001A        	   103: 	fneg fp0								; make fp0 positive
                            	   104: .0002
00:0000730A 4E75            	   105: 	rts
                            	   106: 
                            	   107: ;------------------------------------------------------------------------------
                            	   108: ; Make the input value larger so that digits may appear before the decimal
                            	   109: ; point.
                            	   110: ;
                            	   111: ; Modifies:
                            	   112: ;		fp0,fp1,d6
                            	   113: ; Parameters:
                            	   114: ;		fp0 = dbl
                            	   115: ;------------------------------------------------------------------------------
                            	   116: 
                            	   117: ;	if (dbl < 1.0) {
                            	   118: ;		while (dbl < 1.0) {
                            	   119: ;			dbl *= 1000000.0;
                            	   120: ;			exp -= 6;  
                            	   121: ;		}
                            	   122: ;	}
                            	   123: 
                            	   124: _MakeBig:
00:0000730C F23C50800001    	   125: 	fmove.w #1,fp1
                            	   126: .0002
00:00007312 F2000438        	   127: 	fcmp fp1,fp0						; is fp0 > 1?
00:00007316 F293000E        	   128: 	fbge .0001							; yes, return
00:0000731A F23C402600000006	   129: 	fscale.l #6,fp0					; multiply fp0 by a million
00:00007322 5D46            	   130: 	subi.w #6,d6						; decrement exponent by six
00:00007324 60EC            	   131: 	bra .0002								; keep trying until number is > 1
                            	   132: .0001
00:00007326 4E75            	   133: 	rts
                            	   134: 	
                            	   135: ;------------------------------------------------------------------------------
                            	   136: ;	Create a number dbl2 on the same order of magnitude as dbl, but
                            	   137: ;	less than dbl. The number will be 1.0e<dbl's exponent>
                            	   138: ;
                            	   139: ; Modifies:
                            	   140: ;		d6,fp2
                            	   141: ; Parameters:
                            	   142: ;		fp0 = dbl
                            	   143: ;------------------------------------------------------------------------------
                            	   144: 
                            	   145: ;	// The following is similar to using log10() and pow() functions.
                            	   146: ;	// Now dbl is >= 1.0
                            	   147: ;	// Create a number dbl2 on the same order of magnitude as dbl, but
                            	   148: ;	// less than dbl.
                            	   149: ;	dbl2 = 1.0;
                            	   150: ;	dbla = dbl2;
                            	   151: ;	if (dbl > dbl2) {	// dbl > 1.0 ?
                            	   152: ;		while (dbl2 <= dbl) {
                            	   153: ;			dbla = dbl2;
                            	   154: ;			dbl2 *= 10.0;	// increase power of 10
                            	   155: ;			exp++;
                            	   156: ;		}
                            	   157: ;		// The above loop goes one too far, we want the last value less
                            	   158: ;		// than dbl.
                            	   159: ;		dbl2 = dbla;
                            	   160: ;		exp--;
                            	   161: ;	}
                            	   162: 
                            	   163: _LessThanDbl:
00:00007328 F23C51000001    	   164: 	fmove.w #1,fp2			; setup fp2 = 1
00:0000732E F2000838        	   165: 	fcmp fp2,fp0				; if (dbl > dbl2)
00:00007332 F295001E        	   166: 	fble .0004
                            	   167: .0006
00:00007336 F2000138        	   168: 	fcmp fp0,fp2				; while (dbl2 <= dbl)
00:0000733A F292000C        	   169: 	fbgt .0005
00:0000733E F23C51260001    	   170: 	fscale.w #1,fp2			; dbl2 *= 10 (increase exponent by one)
00:00007344 5246            	   171: 	addi.w #1,d6				; exp++
00:00007346 60EE            	   172: 	bra .0006
                            	   173: .0005
00:00007348 F23C4126FFFFFFFF	   174: 	fscale.l #-1,fp2		; dbl2 /= 10 (decrease exponent by one)
00:00007350 5346            	   175: 	subi.w #1,d6				; exp--;
                            	   176: .0004	
                            	   177: ;	fmove.x fp0,_fpWork	; debugging
                            	   178: ;	fmove.x fp2,_fpWork+12
00:00007352 4E75            	   179: 	rts
                            	   180: 
                            	   181: ;------------------------------------------------------------------------------
                            	   182: ; Compute the number of digits before the decimal point.
                            	   183: ;
                            	   184: ; Modifies:
                            	   185: ;		d0,d6,_digits_before_decpt
                            	   186: ; Parameters:
                            	   187: ;		d6 = exponent
                            	   188: ;------------------------------------------------------------------------------
                            	   189: 
                            	   190: ; if (exp >= 0 && exp < 6) {
                            	   191: ;   digits_before_decpt = exp+1;
                            	   192: ;		exp = 0;
                            	   193: ;	}
                            	   194: ;	else if (exp >= -7)
                            	   195: ;		digits_before_decpt = 1;
                            	   196: ;	else
                            	   197: ;		digits_before_decpt = -1;
                            	   198: 
                            	   199: _ComputeDigitsBeforeDecpt:
00:00007354 2F00            	   200: 	move.l d0,-(a7)
00:00007356 4A46            	   201: 	tst.w d6
00:00007358 6B16            	   202: 	bmi .0007
00:0000735A 0C460006        	   203: 	cmpi.w #6,d6
00:0000735E 6C10            	   204: 	bge .0007
00:00007360 3006            	   205: 	move.w d6,d0
00:00007362 5240            	   206: 	addi.w #1,d0
00:00007364 33C000040510    	   207: 	move.w d0,_digits_before_decpt	
00:0000736A 4246            	   208: 	clr.w d6
00:0000736C 201F            	   209: 	move.l (a7)+,d0
00:0000736E 4E75            	   210: 	rts
                            	   211: .0007
00:00007370 0C46FFF9        	   212: 	cmpi.w #-7,d6
00:00007374 6D0C            	   213: 	blt .0009
00:00007376 33FC000100040510	   214: 	move.w #1,_digits_before_decpt
00:0000737E 201F            	   215: 	move.l (a7)+,d0
00:00007380 4E75            	   216: 	rts
                            	   217: .0009
00:00007382 33FCFFFF00040510	   218: 	move.w #-1,_digits_before_decpt
00:0000738A 201F            	   219: 	move.l (a7)+,d0
00:0000738C 4E75            	   220: 	rts
                            	   221: 
                            	   222: ;------------------------------------------------------------------------------
                            	   223: ;	Spit out a leading zero before the decimal point for a small number.
                            	   224: ;
                            	   225: ; Modifies:
                            	   226: ;		a0
                            	   227: ; Parameters:
                            	   228: ;		d6 = exponent
                            	   229: ;------------------------------------------------------------------------------
                            	   230: 
                            	   231: ;  if (exp < -7) {
                            	   232: ;		 buf[ndx] = '0';
                            	   233: ;		 ndx++;
                            	   234: ;    buf[ndx] = '.';
                            	   235: ;    ndx++;
                            	   236: ;  }
                            	   237: 
                            	   238: _LeadingZero:
00:0000738E 0C46FFF9        	   239: 	cmpi.w #-7,d6
00:00007392 6C08            	   240: 	bge .0010
00:00007394 10FC0030        	   241: 	move.b #'0',(a0)+
00:00007398 10FC002E        	   242: 	move.b #'.',(a0)+
                            	   243: .0010
00:0000739C 4E75            	   244: 	rts
                            	   245: 
                            	   246: ;------------------------------------------------------------------------------
                            	   247: ; Extract the digits of the significand.
                            	   248: ;
                            	   249: ; Modifies:
                            	   250: ;		_precision variable
                            	   251: ; Register Usage
                            	   252: ;		d0 = counter
                            	   253: ;		d1 = digit
                            	   254: ;		fp0 = dbl
                            	   255: ;		fp2 = dbl2
                            	   256: ;		fp3 = digit as decimal float
                            	   257: ;		fp7 = dbla
                            	   258: ; Parameters:
                            	   259: ;		fp0, fp2
                            	   260: ;------------------------------------------------------------------------------
                            	   261: 
                            	   262: ;	// Now loop processing one digit at a time.
                            	   263: ;  for (nn = 0; nn < 25 && precision > 0; nn++) {
                            	   264: ;    digit = 0;
                            	   265: ;		dbla = dbl;
                            	   266: ;		// dbl is on the same order of magnitude as dbl2 so
                            	   267: ;		// a repeated subtract can be used to find the digit.
                            	   268: ;    while (dbl >= dbl2) {
                            	   269: ;      dbl -= dbl2;
                            	   270: ;      digit++;
                            	   271: ;    }
                            	   272: ;    buf[ndx] = digit + '0';
                            	   273: ;		// Now go back and perform just a single subtract and
                            	   274: ;		// a multiply to find out how much to reduce dbl by.
                            	   275: ;		// This should improve the accuracy
                            	   276: ;		if (digit > 2)
                            	   277: ;			dbl = dbla - dbl2 * digit;
                            	   278: ;    ndx++;
                            	   279: ;    digits_before_decpt--;
                            	   280: ;    if (digits_before_decpt==0) {
                            	   281: ;			buf[ndx] = '.';
                            	   282: ;			ndx++;
                            	   283: ;    }
                            	   284: ;    else if (digits_before_decpt < 0)
                            	   285: ;      precision--;
                            	   286: ;		// Shift the next digit to be tested into position.
                            	   287: ;    dbl *= 10.0;
                            	   288: ;  }
                            	   289: 	
                            	   290: _SpitOutDigits:
00:0000739E 4E52FFE8        	   291: 	link a2,#-24
00:000073A2 2F79000400980014	   292: 	move.l _canary,20(sp)
00:000073AA F2176B80        	   293: 	fmove.x fp7,(sp)
00:000073AE 48EF0003000C    	   294: 	movem.l d0/d1,12(sp)
00:000073B4 303C0018        	   295: 	move.w #24,d0			; d0 = nn
                            	   296: .0017	
00:000073B8 4AB900040514    	   297: 	tst.l _precision
00:000073BE 6F46            	   298: 	ble .0011
00:000073C0 7200            	   299: 	moveq #0,d1				; digit = 0
00:000073C2 F2000380        	   300: 	fmove fp0,fp7			; dbla = dbl
                            	   301: .0013
00:000073C6 F2000838        	   302: 	fcmp fp2,fp0
00:000073CA F294000A        	   303: 	fblt .0012
00:000073CE F2000828        	   304: 	fsub fp2,fp0			; dbl -= dbl2
00:000073D2 5201            	   305: 	addi.b #1,d1			; digit++
00:000073D4 60F0            	   306: 	bra .0013
                            	   307: .0012
00:000073D6 06010030        	   308: 	addi.b #'0',d1		; convert digit to ascii
00:000073DA 10C1            	   309: 	move.b d1,(a0)+		; and store
00:000073DC 04010030        	   310: 	subi.b #'0',d1		; d1 = binary digit again
                            	   311: ;	cmpi.b #2,d1
                            	   312: ;	ble .0014
                            	   313: 
                            	   314: ;	ext.w d1
                            	   315: ;	ext.l d1
                            	   316: ;	fmove.l d1,fp3		; fp3 = digit
                            	   317: ;	fmul fp2,fp3			; fp3 = dbl2 * digit
                            	   318: ;	fmove fp7,fp0
                            	   319: ;	fsub fp3,fp0			; dbl = dbla - dbl2 * digit
                            	   320: .0014
00:000073E0 537900040510    	   321: 	subi.w #1,_digits_before_decpt
00:000073E6 6604            	   322: 	bne .0015
00:000073E8 10FC002E        	   323: 	move.b #'.',(a0)+
                            	   324: .0015
00:000073EC 4A7900040510    	   325: 	tst.w _digits_before_decpt
00:000073F2 6C06            	   326: 	bge .0016
00:000073F4 53B900040514    	   327: 	subi.l #1,_precision
                            	   328: .0016
00:000073FA F23C4126FFFFFFFF	   329: 	fscale.l #-1,fp2		; dbl *= 10.0
00:00007402 51C8FFB4        	   330: 	dbra d0,.0017
                            	   331: .0011
00:00007406 4CEF0003000C    	   332: 	movem.l 12(sp),d0/d1
00:0000740C F2174B80        	   333: 	fmove.x (sp),fp7
00:00007410 A2AF00030014    	   334: 	cchk 20(sp)
00:00007416 4E5A            	   335: 	unlk a2
00:00007418 4E75            	   336: 	rts
                            	   337: 
                            	   338: ;------------------------------------------------------------------------------
                            	   339: ; If the number ends in a decimal point, trim off the point.
                            	   340: ;
                            	   341: ; Registers Modified:
                            	   342: ;		none
                            	   343: ; Parameters:
                            	   344: ;		a0 = pointer to end of number
                            	   345: ; Returns:
                            	   346: ;		a0 = updated to point just past last digit.
                            	   347: ;------------------------------------------------------------------------------
                            	   348: 
                            	   349: _TrimTrailingPoint:
00:0000741A 0C28002EFFFF    	   350: 	cmpi.b #'.',-1(a0)
00:00007420 6604            	   351: 	bne .0001
00:00007422 4220            	   352: 	clr.b -(a0)
00:00007424 4E75            	   353: 	rts
                            	   354: .0001
00:00007426 0C10002E        	   355: 	cmpi.b #'.',(a0)
00:0000742A 660A            	   356: 	bne .0002
00:0000742C 4A280001        	   357: 	cmpi.b #0,1(a0)
00:00007430 6604            	   358: 	bne .0002
00:00007432 4210            	   359: 	clr.b (a0)
00:00007434 5348            	   360: 	subq #1,a0
                            	   361: .0002
00:00007436 4E75            	   362: 	rts
                            	   363: 	
                            	   364: ;------------------------------------------------------------------------------
                            	   365: ; If the number ends in .0 get rid of the .0
                            	   366: ;
                            	   367: ; Registers Modified:
                            	   368: ;		none
                            	   369: ; Parameters:
                            	   370: ;		a0 = pointer to last digits of number
                            	   371: ; Returns:
                            	   372: ;		a0 = updated to point just past last digit.
                            	   373: ;------------------------------------------------------------------------------
                            	   374: 
                            	   375: _TrimDotZero:
00:00007438 4A10            	   376: 	tst.b (a0)
00:0000743A 6616            	   377: 	bne .0004
00:0000743C 0C280030FFFF    	   378: 	cmpi.b #'0',-1(a0)
00:00007442 660E            	   379: 	bne .0004
00:00007444 0C28002EFFFE    	   380: 	cmpi.b #'.',-2(a0)
00:0000744A 6606            	   381: 	bne .0004
00:0000744C 4228FFFE        	   382: 	clr.b -2(a0)
00:00007450 5548            	   383: 	subq #2,a0
                            	   384: .0004
00:00007452 4E75            	   385: 	rts
                            	   386: 
                            	   387: ;------------------------------------------------------------------------------
                            	   388: ; Trim trailing zeros from the number. Generally there is no need to display
                            	   389: ; trailing zeros.
                            	   390: ; Turns a number like 652.000000000000000000000 into 650.0
                            	   391: ;
                            	   392: ; Registers Modified:
                            	   393: ;		none
                            	   394: ; Parameters:
                            	   395: ;		a0 = pointer to last digits of number
                            	   396: ; Returns:
                            	   397: ;		a0 = updated to point just past last digit.
                            	   398: ;------------------------------------------------------------------------------
                            	   399: 
                            	   400: ;	// Trim trailing zeros from the number
                            	   401: ;  do {
                            	   402: ;      ndx--;
                            	   403: ;  } while(buf[ndx]=='0');
                            	   404: ;  ndx++;
                            	   405: 
                            	   406: _TrimTrailingZeros:
                            	   407: .0018	
00:00007454 0C200030        	   408: 	cmpi.b #'0',-(a0)		; if the last digit was a zero, backup
00:00007458 67FA            	   409: 	beq .0018
00:0000745A 5248            	   410: 	addq #1,a0					; now advance by one
00:0000745C 4210            	   411: 	move.b #0,(a0)			; NULL terminate string
00:0000745E 4E75            	   412: 	rts
                            	   413: 
                            	   414: ;------------------------------------------------------------------------------
                            	   415: ; Output 'e+' or 'e-'
                            	   416: ;
                            	   417: ; Registers Modified:
                            	   418: ;		d6.w (if negative)
                            	   419: ; Parameters:
                            	   420: ;		a0 = pointer to last digits of number
                            	   421: ; Returns:
                            	   422: ;		a0 = updated to point just past '+' or '-'.
                            	   423: ;------------------------------------------------------------------------------
                            	   424: 
                            	   425: ;	// Spit out +/-E
                            	   426: ;  buf[ndx] = E;
                            	   427: ;  ndx++;
                            	   428: ;  if (exp < 0) {
                            	   429: ;    buf[ndx]='-';
                            	   430: ;    ndx++;
                            	   431: ;    exp = -exp;
                            	   432: ;  }
                            	   433: ;  else {
                            	   434: ;		buf[ndx]='+';
                            	   435: ;		ndx++;
                            	   436: ;  }
                            	   437: 
                            	   438: _SpitOutE:	
00:00007460 10F90004050C    	   439: 	move.b _E,(a0)+
00:00007466 4A46            	   440: 	tst.w d6
00:00007468 6C08            	   441: 	bge .0021
00:0000746A 10FC002D        	   442: 	move.b #'-',(a0)+
00:0000746E 4446            	   443: 	neg.w d6
00:00007470 6004            	   444: 	bra .0022
                            	   445: .0021
00:00007472 10FC002B        	   446: 	move.b #'+',(a0)+
                            	   447: .0022
00:00007476 4E75            	   448: 	rts
                            	   449: 
                            	   450: ;------------------------------------------------------------------------------
                            	   451: ; Extract a single digit of the exponent. Extract works from the leftmost digit
                            	   452: ; to the rightmost.
                            	   453: ;
                            	   454: ; Register Usage
                            	   455: ;		d2 = history of zeros
                            	   456: ;		d3 = digit
                            	   457: ; Modifies
                            	   458: ;		d2,d6,a0
                            	   459: ; Parameter
                            	   460: ; 	d1.w = power of ten
                            	   461: ;		d6.w = exponent
                            	   462: ;------------------------------------------------------------------------------
                            	   463: 
                            	   464: _ExtExpDigit:
00:00007478 2F03            	   465: 	move.l d3,-(a7)
00:0000747A 48C6            	   466: 	ext.l d6				; make d6 a long
00:0000747C 8CC1            	   467: 	divu d1,d6			; divide by power of ten
00:0000747E 1606            	   468: 	move.b d6,d3		; d3 = quotient (0 to 9)
00:00007480 4846            	   469: 	swap d6					; d6 = remainder, setup for next digit
00:00007482 8403            	   470: 	or.b d3,d2
00:00007484 4A03            	   471: 	tst.b d3
00:00007486 6604            	   472: 	bne .0003
00:00007488 4A02            	   473: 	tst.b d2	
00:0000748A 6706            	   474: 	beq .0004
                            	   475: .0003
00:0000748C 06030030        	   476: 	addi.b #'0',d3	; convert to ascii
00:00007490 10C3            	   477: 	move.b d3,(a0)+
                            	   478: .0004
00:00007492 261F            	   479: 	move.l (a7)+,d3
00:00007494 4E75            	   480: 	rts
                            	   481: 
                            	   482: ;------------------------------------------------------------------------------
                            	   483: ; Extract all the digits of the exponent.
                            	   484: ;
                            	   485: ; Register Usage
                            	   486: ;		d1 = power of 10
                            	   487: ;		d2 = history of zeros
                            	   488: ; Parameters
                            	   489: ;		a0 = pointer to string buffer
                            	   490: ;		d6 = exponent
                            	   491: ;------------------------------------------------------------------------------
                            	   492: 
                            	   493: ;	// If the number is times 10^0 don't output the exponent
                            	   494: ;  if (exp==0) {
                            	   495: ;    buf[ndx]='\0';
                            	   496: ;    goto prt;
                            	   497: ;  }
                            	   498: 
                            	   499: _ExtExpDigits:
00:00007496 2F01            	   500: 	move.l d1,-(a7)
00:00007498 4A46            	   501: 	tst.w d6							; is exponent zero?
00:0000749A 671C            	   502: 	beq .0002
00:0000749C 61C2            	   503: 	bsr _SpitOutE					; exponent is non-zero e+
00:0000749E 4202            	   504: 	clr.b d2							; d2 = history of zeros
00:000074A0 323C03E8        	   505: 	move.w #1000,d1
00:000074A4 61D2            	   506: 	bsr _ExtExpDigit
00:000074A6 323C0064        	   507: 	move.w #100,d1
00:000074AA 61CC            	   508: 	bsr _ExtExpDigit
00:000074AC 323C000A        	   509: 	move.w #10,d1
00:000074B0 61C6            	   510: 	bsr _ExtExpDigit
00:000074B2 323C0001        	   511: 	move.w #1,d1
00:000074B6 61C0            	   512: 	bsr _ExtExpDigit
                            	   513: .0002:
00:000074B8 221F            	   514: 	move.l (a7)+,d1
00:000074BA 4210            	   515: 	move.b #0,(a0)				; NULL terminate string
00:000074BC 4E75            	   516: 	rts										; and return
                            	   517: 
                            	   518: ;------------------------------------------------------------------------------
                            	   519: ; Pad the left side of the output string.
                            	   520: ;
                            	   521: ; Modifies:
                            	   522: ;		d0,d1,d2,d3
                            	   523: ;------------------------------------------------------------------------------
                            	   524: 
                            	   525: ;  // pad left
                            	   526: ;  if (width > 0) {
                            	   527: ;    if (ndx < width) {
                            	   528: ;      for (nn = 39; nn >= width-ndx; nn--)
                            	   529: ;        buf[nn] = buf[nn-(width-ndx)];
                            	   530: ;      for (; nn >= 0; nn--)
                            	   531: ;        buf[nn] = ' ';
                            	   532: ;    }
                            	   533: ;  }
                            	   534: 	
                            	   535: _PadLeft:
00:000074BE 48E7F000        	   536: 	movem.l d0/d1/d2/d3,-(a7)
00:000074C2 4A3900040508    	   537: 	tst.b _width
00:000074C8 6F3E            	   538: 	ble .0041
00:000074CA 2008            	   539: 	move.l a0,d0
00:000074CC 90BC00040520    	   540: 	sub.l #_fpBuf,d0	; d0 = ndx
00:000074D2 B03900040508    	   541: 	cmp.b _width,d0
00:000074D8 6C2E            	   542: 	bge .0041
00:000074DA 323C0031        	   543: 	move.w #49,d1			; d1 = nn
                            	   544: .0040
00:000074DE 143900040508    	   545: 	move.b _width,d2
00:000074E4 4882            	   546: 	ext.w d2
00:000074E6 9440            	   547: 	sub.w d0,d2				; d2 = width-ndx
00:000074E8 B242            	   548: 	cmp.w d2,d1
00:000074EA 6D0E            	   549: 	blt .0039
00:000074EC 3601            	   550: 	move.w d1,d3			; d3 = nn
00:000074EE 9642            	   551: 	sub.w d2,d3				; d3 = nn-(width-ndx)
00:000074F0 11B030001000    	   552: 	move.b (a0,d3.w),(a0,d1.w)
00:000074F6 5341            	   553: 	subi.w #1,d1
00:000074F8 60E4            	   554: 	bra .0040
                            	   555: .0039
00:000074FA 4A41            	   556: 	tst.w d1
00:000074FC 6B0A            	   557: 	bmi .0041
00:000074FE 11BC00201000    	   558: 	move.b #' ',(a0,d1.w)
00:00007504 5341            	   559: 	subi.w #1,d1
00:00007506 60F2            	   560: 	bra .0039
                            	   561: .0041
00:00007508 4CDF000F        	   562: 	movem.l (a7)+,d0/d1/d2/d3
00:0000750C 4E75            	   563: 	rts
                            	   564: 
                            	   565: ;------------------------------------------------------------------------------
                            	   566: ; Pad the right side of the output string.
                            	   567: ;
                            	   568: ; Parameters:
                            	   569: ;		a0 = pointer to end of string
                            	   570: ; Modifies:
                            	   571: ;		none
                            	   572: ; Returns:
                            	   573: ;		none
                            	   574: ;------------------------------------------------------------------------------
                            	   575: 
                            	   576: ;  // pad right
                            	   577: ;  if (width < 0) {
                            	   578: ;    width = -width;
                            	   579: ;    while (ndx < width) {
                            	   580: ;      buf[ndx]=' ';
                            	   581: ;      ndx++;
                            	   582: ;    }
                            	   583: ;    buf[ndx]='\0';
                            	   584: ;  }
                            	   585: ;  return (ndx);
                            	   586: 
                            	   587: _PadRight:
00:0000750E 2F00            	   588: 	move.l d0,-(a7)
00:00007510 4A3900040508    	   589: 	tst.b _width
00:00007516 6A24            	   590: 	bpl .0042
00:00007518 443900040508    	   591: 	neg.b _width
00:0000751E 2008            	   592: 	move.l a0,d0
00:00007520 90BC00040520    	   593: 	sub.l #_fpBuf,d0	; d0 = ndx
                            	   594: .0044
00:00007526 B03900040508    	   595: 	cmp.b _width,d0
00:0000752C 6C0A            	   596: 	bge .0043
00:0000752E 11BC00200000    	   597: 	move.b #' ',(a0,d0.w)
00:00007534 5240            	   598: 	addi.w #1,d0
00:00007536 60EE            	   599: 	bra .0044
                            	   600: .0043
00:00007538 42300000        	   601: 	move.b #0,(a0,d0.w)
                            	   602: .0042
00:0000753C 201F            	   603: 	move.l (a7)+,d0
00:0000753E 4E75            	   604: 	rts
                            	   605: 
                            	   606: ;------------------------------------------------------------------------------
                            	   607: ; Output a string representation of a decimal floating point number to a 
                            	   608: ; buffer.
                            	   609: ;
                            	   610: ; Register Usage
                            	   611: ;		a0 = pointer to string buffer
                            	   612: ;		d6 = exponent
                            	   613: ; Modifies:
                            	   614: ;		a0 = points to end of string
                            	   615: ; Parameters:
                            	   616: ;		fp0 = number to convert
                            	   617: ; Returns:
                            	   618: ;		none
                            	   619: ;------------------------------------------------------------------------------
                            	   620: 
                            	   621: _FloatToString:
00:00007540 2F06            	   622: 	move.l d6,-(a7)
00:00007542 6100FDB6        	   623: 	bsr _CheckNegative			; is number negative?
00:00007546 6100FD98        	   624: 	bsr _CheckZero					; check for zero
00:0000754A 6732            	   625: 	beq .0001								; branch since already output "0"
00:0000754C 6100FD2E        	   626: 	bsr _CheckNan						; check for Nan or infinity
00:00007550 652C            	   627: 	bcs .0001								; branch if nan/inf string output
                            	   628: 	; Now the fun begins
00:00007552 7C00            	   629: 	clr.l d6								; exponent = 0
00:00007554 6100FDB6        	   630: 	bsr _MakeBig
00:00007558 6100FDCE        	   631: 	bsr _LessThanDbl
00:0000755C 6100FDF6        	   632: 	bsr _ComputeDigitsBeforeDecpt
00:00007560 6100FE2C        	   633: 	bsr _LeadingZero
00:00007564 6100FE38        	   634: 	bsr _SpitOutDigits
00:00007568 6100FEEA        	   635: 	bsr _TrimTrailingZeros
00:0000756C 6100FEAC        	   636: 	bsr _TrimTrailingPoint
00:00007570 6100FEC6        	   637: 	bsr _TrimDotZero
00:00007574 6100FF20        	   638: 	bsr _ExtExpDigits				; extract exponent digits
00:00007578 6100FF44        	   639: 	bsr _PadLeft						; pad the number to the left or right
00:0000757C 6190            	   640: 	bsr _PadRight
                            	   641: .0001
00:0000757E 2C1F            	   642: 	move.l (a7)+,d6
00:00007580 4E75            	   643: 	rts
                            	   644: 
                            	   645: 

Source: "boot.x68"
                            	  3500: 	include "GetFloat.asm"

Source: "GetFloat.asm"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;
                            	    37: ; Get a floating point number
                            	    38: ;
                            	    39: _GetFloatGetChar:
00:00007582 1210            	    40: 	move.b (a0),d1
00:00007584 D1C0            	    41: 	add.l d0,a0
00:00007586 4E75            	    42: 	rts
                            	    43: _GetFloatIgnBlanks:
                            	    44: .0001
00:00007588 61F8            	    45: 	bsr _GetFloatGetChar
00:0000758A 0C010020        	    46: 	cmpi.b #' ',d1
00:0000758E 67F8            	    47: 	beq .0001
                            	    48: _GetFloatBackupChar:
00:00007590 91C0            	    49: 	sub.l d0,a0
00:00007592 4E75            	    50: 	rts
                            	    51: 
                            	    52: ;-------------------------------------------------------------------------------
                            	    53: ; Get fractional part of a number, 25 digits max, into a float register.
                            	    54: ;
                            	    55: ; Register Usage:
                            	    56: ;		d1 = digit from input screen
                            	    57: ;		d4 = digit count
                            	    58: ;		d6 = digit scaling factor
                            	    59: ;		fp1 = digit as float number
                            	    60: ; Returns:
                            	    61: ;		fp0 = fraction
                            	    62: ;-------------------------------------------------------------------------------
                            	    63: 
                            	    64: _GetFraction:
00:00007594 4E52FFE4        	    65: 	link a2,#-28
00:00007598 2F79000400980018	    66: 	move.l _canary,24(sp)
00:000075A0 48D70052        	    67: 	movem.l d1/d4/d6,(sp)
00:000075A4 F22F6880000C    	    68: 	fmove.x fp1,12(sp)
00:000075AA 7C00            	    69: 	clr.l d6							; d6 = scale factor
00:000075AC F23C50000000    	    70: 	fmove.w #0,fp0				; fract = 0.0
00:000075B2 7818            	    71: 	moveq #24,d4
                            	    72: .0002
00:000075B4 61CC            	    73: 	bsr _GetFloatGetChar
00:000075B6 0C010030        	    74: 	cmpi.b #'0',d1
00:000075BA 6520            	    75: 	blo .0001
00:000075BC 0C010039        	    76: 	cmpi.b #'9',d1				; make sure between 0 and 9
00:000075C0 621A            	    77: 	bhi .0001
00:000075C2 04010030        	    78: 	subi.b #'0',d1
00:000075C6 F23C50260001    	    79: 	fscale.w #1,fp0				; fract * 10.0
00:000075CC 5246            	    80: 	addq #1,d6						; record scaling
00:000075CE F2015880        	    81: 	fmove.b d1,fp1				; fp1 = digit
00:000075D2 F2000422        	    82: 	fadd fp1,fp0					; fract += digit
00:000075D6 5245            	    83: 	addq.w #1,d5					; increment number of digits in number
00:000075D8 51CCFFDA        	    84: 	dbra d4,.0002
                            	    85: .0001
00:000075DC 61B2            	    86: 	bsr _GetFloatBackupChar
00:000075DE 4446            	    87: 	neg d6
00:000075E0 F2064026        	    88: 	fscale.l d6,fp0				; fract /= scale
00:000075E4 4CD70052        	    89: 	movem.l (sp),d1/d4/d6
00:000075E8 F22F4880000C    	    90: 	fmove.x 12(sp),fp1
00:000075EE A2AF00030018    	    91: 	cchk 24(sp)
00:000075F4 4E5A            	    92: 	unlk a2
00:000075F6 4E75            	    93: 	rts
                            	    94: 
                            	    95: ;-------------------------------------------------------------------------------
                            	    96: ; Get exponent part of a number, 4 digits max, into a float register.
                            	    97: ;
                            	    98: ; Register Usage:
                            	    99: ;		d1 = digit from input screen
                            	   100: ;		d2 = exponent
                            	   101: ;		d3 = temp, number times 2
                            	   102: ;		d4 = digit counter
                            	   103: ; Parameters:
                            	   104: ;		fp0 = float number
                            	   105: ; Returns:
                            	   106: ;		fp0 = float number with exponent factored in
                            	   107: ;-------------------------------------------------------------------------------
                            	   108: 
                            	   109: _GetExponent:
00:000075F8 4E52FFE0        	   110: 	link a2,#-32
00:000075FC 2F7900040098001C	   111: 	move.l _canary,28(sp)
00:00007604 48D7001E        	   112: 	movem.l d1/d2/d3/d4,(sp)
00:00007608 F22F69000010    	   113: 	fmove.x fp2,16(sp)
00:0000760E 7400            	   114: 	clr.l d2							; d2 = number = 0
00:00007610 F23C51000000    	   115: 	fmove.w #0,fp2				; fp2 = exp = 0.0
00:00007616 7601            	   116: 	moveq #1,d3						; d3 = exscale = 1
00:00007618 6100FF68        	   117: 	bsr _GetFloatGetChar
00:0000761C 0C01002D        	   118: 	cmpi.b #'-',d1
00:00007620 6608            	   119: 	bne .0001
00:00007622 4483            	   120: 	neg.l d3							; exscale = -1
                            	   121: .0006
00:00007624 6100FF62        	   122: 	bsr _GetFloatIgnBlanks
00:00007628 600A            	   123: 	bra .0002
                            	   124: .0001
00:0000762A 0C01002B        	   125: 	cmpi.b #'+',d1
00:0000762E 67F4            	   126: 	beq .0006
00:00007630 6100FF5E        	   127: 	bsr _GetFloatBackupChar
                            	   128: .0002	
00:00007634 7803            	   129: 	moveq #3,d4						; d4 = max 4 digits
                            	   130: .0004
00:00007636 6100FF4A        	   131: 	bsr _GetFloatGetChar	; d1 = digit char
00:0000763A 0C010030        	   132: 	cmpi.b #'0',d1
00:0000763E 651E            	   133: 	blo .0003
00:00007640 0C010039        	   134: 	cmpi.b #'9',d1				; ensure between 0 and 9
00:00007644 6218            	   135: 	bhi .0003
00:00007646 04010030        	   136: 	subi.b #'0',d1
00:0000764A D482            	   137: 	add.l d2,d2						; number *2
00:0000764C 2602            	   138: 	move.l d2,d3
00:0000764E E58A            	   139: 	lsl.l #2,d2						; number *8
00:00007650 D483            	   140: 	add.l d3,d2						; number *10	
00:00007652 4881            	   141: 	ext.w d1
00:00007654 48C1            	   142: 	ext.l d1
00:00007656 D481            	   143: 	add.l d1,d2						; number + digit
00:00007658 5245            	   144: 	addq.w #1,d5					; increment number of digits in number
00:0000765A 51CCFFDA        	   145: 	dbra d4,.0004
                            	   146: .0003
00:0000765E 6100FF30        	   147: 	bsr _GetFloatBackupChar	; backup a character
00:00007662 C4C3            	   148: 	mulu d3,d2						; *1 or *-1
00:00007664 48C2            	   149: 	ext.l d2
00:00007666 F2024126        	   150: 	fscale.l d2,fp2				; exp * exmul
00:0000766A F2000823        	   151: 	fmul fp2,fp0					; rval *= exp
00:0000766E 4CD7001E        	   152: 	movem.l (sp),d1/d2/d3/d4
00:00007672 F22F49000010    	   153: 	fmove.x 16(sp),fp2
00:00007678 A2AF0003001C    	   154: 	cchk 28(sp)
00:0000767E 4E5A            	   155: 	unlk a2
00:00007680 4E75            	   156: 	rts	
                            	   157: 
                            	   158: ;-------------------------------------------------------------------------------
                            	   159: ; Get an integer number, positive or negative, 25 digits max, into a float
                            	   160: ; register.
                            	   161: ;
                            	   162: ; Register Usage:
                            	   163: ;		d1 = digit from input screen
                            	   164: ;		d2 = digit down counter
                            	   165: ;		d3 = sign of number '+' or '-'
                            	   166: ;		fp1 = digit
                            	   167: ; Modifies:
                            	   168: ;		a0,fp0
                            	   169: ; Returns:
                            	   170: ;		a0 = updated buffer pointer
                            	   171: ;		fp0 = integer number
                            	   172: ;-------------------------------------------------------------------------------
                            	   173: 
                            	   174: _GetInteger:
00:00007682 4E52FFE4        	   175: 	link a2,#-28
00:00007686 2F79000400980018	   176: 	move.l _canary,24(sp)
00:0000768E 48D7000E        	   177: 	movem.l d1/d2/d3,(sp)
00:00007692 F22F6880000C    	   178: 	fmove.x fp1,12(sp)
00:00007698 F23C50000000    	   179: 	fmove.w #0,fp0
00:0000769E 7418            	   180: 	moveq #24,d2					; d2 = digit count (25 max)
00:000076A0 6100FEE6        	   181: 	bsr _GetFloatIgnBlanks
00:000076A4 6100FEDC        	   182: 	bsr _GetFloatGetChar	; get the sign of the number
00:000076A8 0C01002B        	   183: 	cmpi.b #'+',d1
00:000076AC 670A            	   184: 	beq .0002
                            	   185: .0003
00:000076AE 0C01002D        	   186: 	cmpi.b #'-',d1
00:000076B2 6608            	   187: 	bne .0004
00:000076B4 1E3C002D        	   188: 	move.b #'-',d7
                            	   189: .0002
00:000076B8 6100FEC8        	   190: 	bsr _GetFloatGetChar
                            	   191: .0004
00:000076BC 0C010030        	   192: 	cmpi.b #'0',d1				; only characters 0 to 9 valid
00:000076C0 651E            	   193: 	blo .0001
00:000076C2 0C010039        	   194: 	cmpi.b #'9',d1
00:000076C6 6218            	   195: 	bhi .0001
00:000076C8 04010030        	   196: 	subi.b #'0',d1
00:000076CC F23C50260001    	   197: 	fscale.w #1,fp0				; number *10
00:000076D2 F2015880        	   198: 	fmove.b d1,fp1				; fp1 = digit
00:000076D6 F2000422        	   199: 	fadd fp1,fp0
00:000076DA 5245            	   200: 	addq.w #1,d5
00:000076DC 51CAFFDA        	   201: 	dbra d2,.0002
                            	   202: .0001
00:000076E0 6100FEAE        	   203: 	bsr _GetFloatBackupChar
00:000076E4 4CD7000E        	   204: 	movem.l (sp),d1/d2/d3
00:000076E8 F22F4880000C    	   205: 	fmove.x 12(sp),fp1
00:000076EE A2AF00030018    	   206: 	cchk 24(sp)
00:000076F4 4E5A            	   207: 	unlk a2
00:000076F6 4E75            	   208: 	rts
                            	   209: 		
                            	   210: ;-------------------------------------------------------------------------------
                            	   211: ; Get a floating point number off the input screen.
                            	   212: ;
                            	   213: ; Parameters:
                            	   214: ;		a0 = pointer to buffer containing string
                            	   215: ;		d0 = stride of buffer (increment / decrement amount)
                            	   216: ; Register Usage:
                            	   217: ;		d1 = character from input screen
                            	   218: ;		d5.lo = number of digits in number, d5.hi = number of characters fetched
                            	   219: ; Returns:
                            	   220: ;		fp0 = number
                            	   221: ;		a0 = updated buffer pointer
                            	   222: ;		d0 = length of number >0 if a number
                            	   223: ;-------------------------------------------------------------------------------
                            	   224: 
                            	   225: _GetFloat:
00:000076F8 4E52FFE0        	   226: 	link a2,#-32
00:000076FC 2F7900040098001C	   227: 	move.l _canary,28(sp)
00:00007704 48D702A2        	   228: 	movem.l d1/d5/d7/a1,(sp)
00:00007708 F22F69000010    	   229: 	fmove.x fp2,16(sp)
00:0000770E 7A00            	   230: 	clr.l d5
00:00007710 1E3C002B        	   231: 	move.b #'+',d7				; assume a positive number
00:00007714 2248            	   232: 	move.l a0,a1					; a1 = copy of pointer to buffer
00:00007716 6100FF6A        	   233: 	bsr _GetInteger				; rval = integer
00:0000771A F2000100        	   234: 	fmove.x fp0,fp2
00:0000771E 6100FE62        	   235: 	bsr _GetFloatGetChar
00:00007722 0C01002E        	   236: 	cmpi.b #'.',d1
00:00007726 6706            	   237: 	beq .0004
                            	   238: .0005
00:00007728 6100FE66        	   239: 	bsr _GetFloatBackupChar
00:0000772C 601C            	   240: 	bra .0002
                            	   241: .0004
00:0000772E 6100FE64        	   242: 	bsr _GetFraction
00:00007732 F2000822        	   243: 	fadd fp2,fp0					; rval += fraction
00:00007736 6100FE4A        	   244: 	bsr _GetFloatGetChar
00:0000773A 0C010065        	   245: 	cmpi.b #'e',d1				; accept either 'e' or 'E' indicating exponent
00:0000773E 6706            	   246: 	beq .0001
00:00007740 0C010045        	   247: 	cmpi.b #'E',d1
00:00007744 66E2            	   248: 	bne .0005
                            	   249: .0001
00:00007746 6100FEB0        	   250: 	bsr _GetExponent			; factor exponent into fp0
                            	   251: .0002
00:0000774A 0C07002D        	   252: 	cmpi.b #'-',d7				; adjust number for sign
00:0000774E 6604            	   253: 	bne .0003
00:00007750 F200001A        	   254: 	fneg fp0
                            	   255: .0003
00:00007754 93C8            	   256: 	suba.l a0,a1					; compute number of characters fetched
00:00007756 3009            	   257: 	move.w a1,d0					; move it to d0.hi
00:00007758 4840            	   258: 	swap d0
00:0000775A 3005            	   259: 	move.w d5,d0					; return digit/character count in d0 (non zero for a number)
00:0000775C 4CD702A2        	   260: 	movem.l (sp),d1/d5/d7/a1
00:00007760 F22F49000010    	   261: 	fmove.x 16(sp),fp2
00:00007766 A2AF0003001C    	   262: 	cchk 28(sp)
00:0000776C 4E5A            	   263: 	unlk a2
00:0000776E 4E75            	   264: 	rts	
                            	   265: 
                            	   266: 		

Source: "boot.x68"
                            	  3501: 
                            	  3502: ;------------------------------------------------------------------------------
                            	  3503: ; Convert ASCII character in the range '0' to '9', 'a' tr 'f' or 'A' to 'F'
                            	  3504: ; to a hex nybble.
                            	  3505: ;------------------------------------------------------------------------------
                            	  3506: 
                            	  3507: AsciiToHexNybble:
00:00007770 0C010030        	  3508: 	cmpi.b	#'0',d1
00:00007774 6530            	  3509: 	blo.s		gthx3
00:00007776 0C010039        	  3510: 	cmpi.b	#'9',d1
00:0000777A 6206            	  3511: 	bhi.s		gthx5
00:0000777C 04010030        	  3512: 	subi.b	#'0',d1
00:00007780 4E75            	  3513: 	rts
                            	  3514: gthx5:
00:00007782 0C010041        	  3515: 	cmpi.b	#'A',d1
00:00007786 651E            	  3516: 	blo.s		gthx3
00:00007788 0C010046        	  3517: 	cmpi.b	#'F',d1
00:0000778C 6206            	  3518: 	bhi.s		gthx6
00:0000778E 060100C9        	  3519: 	addi.b	#10-'A',d1
00:00007792 4E75            	  3520: 	rts
                            	  3521: gthx6:
00:00007794 0C010061        	  3522: 	cmpi.b	#'a',d1
00:00007798 650C            	  3523: 	blo.s		gthx3
00:0000779A 0C010066        	  3524: 	cmpi.b	#'f',d1
00:0000779E 6206            	  3525: 	bhi.s		gthx3
00:000077A0 060100A9        	  3526: 	addi.b	#10-'a',d1
00:000077A4 4E75            	  3527: 	rts
                            	  3528: gthx3:
00:000077A6 72FF            	  3529: 	moveq	#-1,d1		; not a hex number
00:000077A8 4E75            	  3530: 	rts
                            	  3531: 
                            	  3532: ;------------------------------------------------------------------------------
                            	  3533: ;------------------------------------------------------------------------------
                            	  3534: 
                            	  3535: DisplayTwoSpaces:
00:000077AA 2F01            	  3536: 	move.l	d1,-(a7)
00:000077AC 123C0020        	  3537: 	move.b	#' ',d1
00:000077B0 61000B38        	  3538: 	bsr			OutputChar
                            	  3539: dspspc1:
00:000077B4 61000B34        	  3540: 	bsr			OutputChar
00:000077B8 221F            	  3541: 	move.l	(a7)+,d1
00:000077BA 4E75            	  3542: 	rts
                            	  3543: 
                            	  3544: DisplaySpace:
00:000077BC 2F01            	  3545: 	move.l	d1,-(a7)
00:000077BE 123C0020        	  3546: 	move.b	#' ',d1
00:000077C2 60F0            	  3547: 	bra			dspspc1
                            	  3548: 
                            	  3549: ;------------------------------------------------------------------------------
                            	  3550: ; Display the 32 bit word in D1.L
                            	  3551: ;------------------------------------------------------------------------------
                            	  3552: 
                            	  3553: DisplayTetra:
00:000077C4 4841            	  3554: 	swap	d1
00:000077C6 6102            	  3555: 	bsr		DisplayWyde
00:000077C8 4841            	  3556: 	swap	d1
                            	  3557: 
                            	  3558: ;------------------------------------------------------------------------------
                            	  3559: ; Display the byte in D1.W
                            	  3560: ;------------------------------------------------------------------------------
                            	  3561: 
                            	  3562: DisplayWyde:
00:000077CA E059            	  3563: 	ror.w		#8,d1
00:000077CC 6102            	  3564: 	bsr			DisplayByte
00:000077CE E159            	  3565: 	rol.w		#8,d1
                            	  3566: 
                            	  3567: ;------------------------------------------------------------------------------
                            	  3568: ; Display the byte in D1.B
                            	  3569: ;------------------------------------------------------------------------------
                            	  3570: 
                            	  3571: DisplayByte:
00:000077D0 E819            	  3572: 	ror.b		#4,d1
00:000077D2 6102            	  3573: 	bsr			DisplayNybble
00:000077D4 E919            	  3574: 	rol.b		#4,d1
                            	  3575: 
                            	  3576: ;------------------------------------------------------------------------------
                            	  3577: ; Display nybble in D1.B
                            	  3578: ;------------------------------------------------------------------------------
                            	  3579: 
                            	  3580: DisplayNybble:
00:000077D6 2F01            	  3581: 	move.l	d1,-(a7)
00:000077D8 0201000F        	  3582: 	andi.b	#$F,d1
00:000077DC 06010030        	  3583: 	addi.b	#'0',d1
00:000077E0 0C010039        	  3584: 	cmpi.b	#'9',d1
00:000077E4 6302            	  3585: 	bls.s		.0001
00:000077E6 5E01            	  3586: 	addi.b	#7,d1
                            	  3587: .0001:
00:000077E8 61000B00        	  3588: 	bsr			OutputChar
00:000077EC 221F            	  3589: 	move.l	(a7)+,d1
00:000077EE 4E75            	  3590: 	rts
                            	  3591: 
                            	  3592: ;------------------------------------------------------------------------------
                            	  3593: ; Buffer tetra in d0 to buffer pointed to by a6
                            	  3594: ;------------------------------------------------------------------------------
                            	  3595: 
                            	  3596: BufTetra:
00:000077F0 4840            	  3597: 	swap d0
00:000077F2 6102            	  3598: 	bsr BufWyde
00:000077F4 4840            	  3599: 	swap d0
                            	  3600: 
                            	  3601: BufWyde:
00:000077F6 E058            	  3602: 	ror.w #8,d0
00:000077F8 6102            	  3603: 	bsr BufByte
00:000077FA E158            	  3604: 	rol.w #8,d0
                            	  3605: 	
                            	  3606: BufByte:
00:000077FC E818            	  3607: 	ror.b #4,d0
00:000077FE 6102            	  3608: 	bsr BufNybble
00:00007800 E918            	  3609: 	rol.b #4,d0
                            	  3610: 
                            	  3611: BufNybble:
00:00007802 2F00            	  3612: 	move.l d0,-(a7)
00:00007804 0200000F        	  3613: 	andi.b #$F,d0
00:00007808 06000030        	  3614: 	addi.b #'0',d0
00:0000780C 0C000039        	  3615: 	cmpi.b #'9',d0
00:00007810 6302            	  3616: 	bls.s .0001
00:00007812 5E00            	  3617: 	addi.b #7,d0
                            	  3618: .0001:
00:00007814 1CC0            	  3619: 	move.b d0,(a6)+
00:00007816 201F            	  3620: 	move.l (a7)+,d0
00:00007818 4E75            	  3621: 	rts
                            	  3622: 
                            	  3623: ;------------------------------------------------------------------------------
                            	  3624: ;------------------------------------------------------------------------------
                            	  3625: ;
                            	  3626: ;DisplayHexNumber:
                            	  3627: ;	move.w	#$A6A6,leds		; diagnostics
                            	  3628: ;	move.l	#VDGREG,a6
                            	  3629: ;	move.w	#7,d2		; number-1 of digits to display
                            	  3630: ;disphnum1:
                            	  3631: ;	move.b	d1,d0		; get digit into d0.b
                            	  3632: ;	andi.w	#$0f,d0
                            	  3633: ;	cmpi.w	#$09,d0
                            	  3634: ;	bls.s	disphnum2
                            	  3635: ;	addi.w	#7,d0
                            	  3636: ;disphnum2:
                            	  3637: ;	addi.w	#$30,d0	; convert to display char
                            	  3638: ;	move.w	d2,d3		; char count into d3
                            	  3639: ;	asl.w	#3,d3		; scale * 8
                            	  3640: ;disphnum3:
                            	  3641: ;	move.w	$42C(a6),d4			; read character queue index into d4
                            	  3642: ;	cmp.w	#28,d4					; allow up 28 entries to be in progress
                            	  3643: ;	bhs.s	disphnum3				; branch if too many chars queued
                            	  3644: ;	ext.w	d0						; zero out high order bits
                            	  3645: ;	move.w	d0,$420(a6)			; set char code
                            	  3646: ;	move.w	#WHITE,$422(a6)		; set fg color
                            	  3647: ;	move.w	#DARK_BLUE,$424(a6)	; set bk color
                            	  3648: ;	move.w	d3,$426(a6)			; set x pos
                            	  3649: ;	move.w	#8,$428(a6)			; set y pos
                            	  3650: ;	move.w	#$0707,$42A(a6)		; set font x,y extent
                            	  3651: ;	move.w	#0,$42E(a6)			; pulse character queue write signal
                            	  3652: ;	ror.l	#4,d1					; rot to next digit
                            	  3653: ;	dbeq	d2,disphnum1
                            	  3654: ;	jmp		(a5)
                            	  3655: 
                            	  3656: 	include "ramtest.x68"

Source: "ramtest.x68"
                            	     1: ;===============================================================================
                            	     2: ;    Perform ram test. (Uses checkerboard testing).
                            	     3: ; 
                            	     4: ;    Local ram, which does not get tested, is used for the stack.
                            	     5: ;===============================================================================
                            	     6: 	code
                            	     7: 	even
                            	     8: DisplayAddr:
00:0000781A 2208            	     9: 	move.l a0,d1
00:0000781C E089            	    10: 	lsr.l #8,d1
00:0000781E E089            	    11: 	lsr.l #8,d1
00:00007820 E889            	    12: 	lsr.l #4,d1
00:00007822 04410400        	    13: 	subi.w #1024,d1
00:00007826 A2C10000        	    14: 	bin2bcd d1
00:0000782A 619E            	    15: 	bsr	DisplayWyde
00:0000782C 618E            	    16: 	bsr DisplaySpace
00:0000782E 123C000D        	    17: 	move.b #CR,d1
00:00007832 6000E224        	    18: 	bra DisplayChar
00:00007836 08000083        	    19: 	btst #$83,d0
                            	    20: 	
                            	    21: cmdTestRAM:
                            	    22: ramtest:
00:0000783A 33FCA5A5FD0FFF00	    23: 	move.w	#$A5A5,leds		; diagnostics
00:00007842 263CAAAAAAAA    	    24:   move.l #$aaaaaaaa,d3
00:00007848 283C55555555    	    25:   move.l #$55555555,d4
00:0000784E 6134            	    26:   bsr ramtest0
                            	    27:   ; switch checkerboard pattern and repeat test.
00:00007850 C744            	    28:   exg d3,d4
00:00007852 6130            	    29:   bsr ramtest0
                            	    30: 	; Save last ram address in end of memory pointer.
                            	    31: rmtst5:
00:00007854 7025            	    32: 	moveq #37,d0					; lock semaphore
00:00007856 7206            	    33: 	moveq #MEMORY_SEMA,d1
                            	    34: ;	trap #15
00:00007858 207C7FFFFFF8    	    35:   movea.l #$7FFFFFF8,a0
00:0000785E 23C800100004    	    36:   move.l a0,memend
                            	    37: 	; Create very first memory block.
00:00007864 207C3FFFFFF4    	    38:   movea.l #$3FFFFFF4,a0
00:0000786A 23C840000004    	    39:   move.l a0,$40000004		; length of block
00:00007870 23FC465245454000	    40:   move.l #$46524545,$40000000
00:00007878 0000
00:0000787A 7026            	    41: 	moveq #38,d0					; unlock semaphore
00:0000787C 7206            	    42: 	moveq #MEMORY_SEMA,d1
00:0000787E 4E4F            	    43: 	trap #15
00:00007880 6000F09E        	    44: 	bra Monitor
                            	    45: ;  rts
                            	    46: 
                            	    47: ramtest0:
00:00007884 2003            	    48: 	move.l d3,d0
00:00007886 207C40000000    	    49:   movea.l #$40000000,a0
                            	    50: ;-----------------------------------------------------------
                            	    51: ;   Write checkerboard pattern to ram then read it back to
                            	    52: ; find the highest usable ram address (maybe). This address
                            	    53: ; must be lower than the start of the rom (0xe00000).
                            	    54: ;-----------------------------------------------------------
                            	    55: ramtest1:
00:0000788C 20C3            	    56:   move.l d3,(a0)+
00:0000788E 20C4            	    57:   move.l d4,(a0)+
00:00007890 2208            	    58:   move.l a0,d1
00:00007892 4A41            	    59:   tst.w	d1
00:00007894 6606            	    60:   bne.s rmtst1
00:00007896 6182            	    61:   bsr DisplayAddr
00:00007898 6100E952        	    62:   bsr CheckForCtrlC
                            	    63: rmtst1:
00:0000789C B1FC7FFFFFF8    	    64:   cmpa.l #$7FFFFFF8,a0
00:000078A2 65E8            	    65:   blo.s ramtest1
00:000078A4 6100E160        	    66:   bsr	CRLF
                            	    67: ;------------------------------------------------------
                            	    68: ;   Save maximum useable address for later comparison.
                            	    69: ;------------------------------------------------------
                            	    70: ramtest6:
00:000078A8 33FCA7A7FD0FFF00	    71: 	move.w	#$A7A7,leds		; diagnostics
00:000078B0 2448            	    72:   movea.l a0,a2
00:000078B2 207C40000000    	    73:   movea.l #$40000000,a0
                            	    74: ;--------------------------------------------
                            	    75: ;   Read back checkerboard pattern from ram.
                            	    76: ;--------------------------------------------
                            	    77: ramtest2
00:000078B8 2A18            	    78:   move.l (a0)+,d5
00:000078BA 2C18            	    79:   move.l (a0)+,d6
00:000078BC B1CA            	    80:   cmpa.l a2,a0
00:000078BE 643A            	    81:   bhs.s	ramtest3
00:000078C0 2208            	    82:   move.l a0,d1
00:000078C2 4A41            	    83:   tst.w	d1
00:000078C4 6608            	    84:   bne.s	rmtst2
00:000078C6 6100FF52        	    85:   bsr	DisplayAddr
00:000078CA 6100E920        	    86: 	bsr CheckForCtrlC
                            	    87: rmtst2
00:000078CE BA83            	    88:   cmp.l d3,d5
00:000078D0 6604            	    89:   bne.s rmtst3
00:000078D2 BC84            	    90:   cmp.l d4,d6
00:000078D4 67E2            	    91:   beq.s ramtest2
                            	    92: ;----------------------------------
                            	    93: ; Report error in ram.
                            	    94: ;----------------------------------
                            	    95: rmtst3
00:000078D6 6100E12E        	    96: 	bsr CRLF
00:000078DA 7245            	    97: 	moveq	#'E',d1
00:000078DC 6100E17A        	    98: 	bsr DisplayChar
00:000078E0 6100FEDA        	    99: 	bsr DisplaySpace
00:000078E4 2208            	   100: 	move.l a0,d1
00:000078E6 6100FEDC        	   101: 	bsr DisplayTetra
00:000078EA 6100FED0        	   102: 	bsr DisplaySpace
00:000078EE 2205            	   103: 	move.l d5,d1
00:000078F0 6100FED2        	   104: 	bsr DisplayTetra
00:000078F4 6100E8F6        	   105: 	bsr CheckForCtrlC
00:000078F8 60BE            	   106: 	bra ramtest2
                            	   107: ramtest3
00:000078FA 4E75            	   108: 	rts
                            	   109: 

Source: "boot.x68"
                            	  3657: 	include "LoadS19.x68"

Source: "LoadS19.x68"
                            	     1: ;==============================================================================
                            	     2: ; Load an S19 format file
                            	     3: ;==============================================================================
                            	     4: 	code
                            	     5: 	even
                            	     6: cmdLoadS19:
00:000078FC 6100E108        	     7: 	bsr			CRLF					; move display to next line
00:00007900 6012            	     8: 	bra			ProcessRec
                            	     9: NextRec:
00:00007902 610001DC        	    10: 	bsr			sGetChar			; get character from serial port routines
00:00007906 0C01000A        	    11: 	cmpi.b	#LF,d1				; look for a line-feed
00:0000790A 66F6            	    12: 	bne			NextRec
00:0000790C 123C002E        	    13: 	move.b	#'.',d1				; progress display
00:00007910 6100E146        	    14: 	bsr			DisplayChar
                            	    15: ProcessRec:
00:00007914 6100E8D6        	    16: 	bsr			CheckForCtrlC	; check for CTRL-C once per record
00:00007918 610001C6        	    17: 	bsr			sGetChar
00:0000791C 0C01000D        	    18: 	cmpi.b	#CR,d1
00:00007920 67F2            	    19: 	beq.s		ProcessRec
00:00007922 423900100150    	    20: 	clr.b		S19Checksum		; clear the checksum
00:00007928 1801            	    21: 	move.b	d1,d4
00:0000792A 0C04001A        	    22: 	cmpi.b	#CTRLZ,d4			; CTRL-Z ?
00:0000792E 6700EFF0        	    23: 	beq			Monitor
00:00007932 0C040053        	    24: 	cmpi.b	#'S',d4				; All records must begin with an 'S'
00:00007936 66CA            	    25: 	bne.s		NextRec
00:00007938 610001A6        	    26: 	bsr			sGetChar
00:0000793C 1801            	    27: 	move.b	d1,d4
00:0000793E 0C040030        	    28: 	cmpi.b	#'0',d4				; Record type must be between '0' and '9'
00:00007942 65BE            	    29: 	blo.s		NextRec
00:00007944 0C040039        	    30: 	cmpi.b	#'9',d4				; d4 = record type
00:00007948 62B8            	    31: 	bhi.s		NextRec
00:0000794A 61000194        	    32: 	bsr			sGetChar			; get byte count for record
00:0000794E 6100FE20        	    33: 	bsr			AsciiToHexNybble
00:00007952 1401            	    34: 	move.b	d1,d2
00:00007954 6100018A        	    35: 	bsr			sGetChar
00:00007958 6100FE16        	    36: 	bsr			AsciiToHexNybble
00:0000795C E90A            	    37: 	lsl.b		#4,d2
00:0000795E 8202            	    38: 	or.b		d2,d1					; d1 = byte count
00:00007960 1601            	    39: 	move.b	d1,d3					; d3 = byte count
00:00007962 D73900100150    	    40: 	add.b		d3,S19Checksum
00:00007968 0C040030        	    41: 	cmpi.b	#'0',d4				; manufacturer ID record, ignore
00:0000796C 6794            	    42: 	beq			NextRec
00:0000796E 0C040031        	    43: 	cmpi.b	#'1',d4
00:00007972 670000A2        	    44: 	beq			ProcessS1
00:00007976 0C040032        	    45: 	cmpi.b	#'2',d4
00:0000797A 6700009E        	    46: 	beq			ProcessS2
00:0000797E 0C040033        	    47: 	cmpi.b	#'3',d4
00:00007982 6700009A        	    48: 	beq			ProcessS3
00:00007986 0C040035        	    49: 	cmpi.b	#'5',d4				; record count record, ignore
00:0000798A 6700FF76        	    50: 	beq			NextRec
00:0000798E 0C040037        	    51: 	cmpi.b	#'7',d4
00:00007992 6700008E        	    52: 	beq			ProcessS7
00:00007996 0C040038        	    53: 	cmpi.b	#'8',d4
00:0000799A 67000096        	    54: 	beq			ProcessS8
00:0000799E 0C040039        	    55: 	cmpi.b	#'9',d4
00:000079A2 6700009E        	    56: 	beq			ProcessS9
00:000079A6 6000FF5A        	    57: 	bra			NextRec
                            	    58: 
                            	    59: pcssxa:
00:000079AA 2209            	    60: 	move.l	a1,d1
00:000079AC 6100FE16        	    61: 	bsr			DisplayTetra
00:000079B0 123C000D        	    62: 	move.b	#CR,d1
00:000079B4 6100E0A2        	    63: 	bsr			DisplayChar
00:000079B8 024300FF        	    64: 	andi.w	#$ff,d3
00:000079BC 5343            	    65: 	subi.w	#1,d3			; one less for dbra
                            	    66: .0001:
00:000079BE 7400            	    67: 	clr.l		d2
00:000079C0 6100011E        	    68: 	bsr			sGetChar
00:000079C4 6100FDAA        	    69: 	bsr			AsciiToHexNybble
00:000079C8 E98A            	    70: 	lsl.l		#4,d2
00:000079CA 8401            	    71: 	or.b		d1,d2
00:000079CC 61000112        	    72: 	bsr			sGetChar
00:000079D0 6100FD9E        	    73: 	bsr			AsciiToHexNybble
00:000079D4 E98A            	    74: 	lsl.l		#4,d2
00:000079D6 8401            	    75: 	or.b		d1,d2
00:000079D8 D53900100150    	    76: 	add.b		d2,S19Checksum
00:000079DE 12C2            	    77: 	move.b	d2,(a1)+			; move byte to memory
00:000079E0 51CBFFDC        	    78: 	dbra		d3,.0001
                            	    79: 	; Get the checksum byte
00:000079E4 7400            	    80: 	clr.l		d2
00:000079E6 610000F8        	    81: 	bsr			sGetChar
00:000079EA 6100FD84        	    82: 	bsr			AsciiToHexNybble
00:000079EE E98A            	    83: 	lsl.l		#4,d2
00:000079F0 8401            	    84: 	or.b		d1,d2
00:000079F2 610000EC        	    85: 	bsr			sGetChar
00:000079F6 6100FD78        	    86: 	bsr			AsciiToHexNybble
00:000079FA E98A            	    87: 	lsl.l		#4,d2
00:000079FC 8401            	    88: 	or.b		d1,d2
00:000079FE 4602            	    89: 	eor.b		#$FF,d2
00:00007A00 B43900100150    	    90: 	cmp.b		S19Checksum,d2
00:00007A06 6700FEFA        	    91: 	beq			NextRec
00:00007A0A 123C0045        	    92: 	move.b	#'E',d1
00:00007A0E 6100E048        	    93: 	bsr			DisplayChar
00:00007A12 6000FEEE        	    94: 	bra			NextRec
                            	    95: 
                            	    96: ProcessS1:
00:00007A16 613A            	    97: 	bsr			S19Get16BitAddress
00:00007A18 6090            	    98: 	bra			pcssxa
                            	    99: ProcessS2:
00:00007A1A 6144            	   100: 	bsr			S19Get24BitAddress
00:00007A1C 608C            	   101: 	bra			pcssxa
                            	   102: ProcessS3:
00:00007A1E 614C            	   103: 	bsr			S19Get32BitAddress
00:00007A20 6088            	   104: 	bra			pcssxa
                            	   105: ProcessS7:
00:00007A22 6148            	   106: 	bsr			S19Get32BitAddress
00:00007A24 23C900040008    	   107: 	move.l	a1,S19StartAddress
00:00007A2A 6100E5C8        	   108: 	bsr			_KeybdInit
00:00007A2E 6000EEF0        	   109: 	bra			Monitor
                            	   110: ProcessS8:
00:00007A32 612C            	   111: 	bsr			S19Get24BitAddress
00:00007A34 23C900040008    	   112: 	move.l	a1,S19StartAddress
00:00007A3A 6100E5B8        	   113: 	bsr			_KeybdInit
00:00007A3E 6000EEE0        	   114: 	bra			Monitor
                            	   115: ProcessS9:
00:00007A42 610E            	   116: 	bsr			S19Get16BitAddress
00:00007A44 23C900040008    	   117: 	move.l	a1,S19StartAddress
00:00007A4A 6100E5A8        	   118: 	bsr			_KeybdInit
00:00007A4E 6000EED0        	   119: 	bra			Monitor
                            	   120: 
                            	   121: S19Get16BitAddress:
00:00007A52 7400            	   122: 	clr.l		d2
00:00007A54 6100008A        	   123: 	bsr			sGetChar
00:00007A58 6100FD16        	   124: 	bsr			AsciiToHexNybble
00:00007A5C 1401            	   125: 	move.b	d1,d2
00:00007A5E 603E            	   126: 	bra			S1932b
                            	   127: 
                            	   128: S19Get24BitAddress:
00:00007A60 7400            	   129: 	clr.l		d2
00:00007A62 617C            	   130: 	bsr			sGetChar
00:00007A64 6100FD0A        	   131: 	bsr			AsciiToHexNybble
00:00007A68 1401            	   132: 	move.b	d1,d2
00:00007A6A 601E            	   133: 	bra			S1932a
                            	   134: 
                            	   135: S19Get32BitAddress:
00:00007A6C 7400            	   136: 	clr.l		d2
00:00007A6E 6170            	   137: 	bsr			sGetChar
00:00007A70 6100FCFE        	   138: 	bsr			AsciiToHexNybble
00:00007A74 1401            	   139: 	move.b	d1,d2
00:00007A76 6168            	   140: 	bsr			sGetChar
00:00007A78 6100FCF6        	   141: 	bsr			AsciiToHexNybble
00:00007A7C E98A            	   142: 	lsl.l		#4,d2
00:00007A7E 8401            	   143: 	or.b		d1,d2
00:00007A80 615E            	   144: 	bsr			sGetChar
00:00007A82 6100FCEC        	   145: 	bsr			AsciiToHexNybble
00:00007A86 E98A            	   146: 	lsl.l		#4,d2
00:00007A88 8401            	   147: 	or.b		d1,d2
                            	   148: S1932a:
00:00007A8A 6154            	   149: 	bsr			sGetChar
00:00007A8C 6100FCE2        	   150: 	bsr			AsciiToHexNybble
00:00007A90 E98A            	   151: 	lsl.l		#4,d2
00:00007A92 8401            	   152: 	or.b		d1,d2
00:00007A94 614A            	   153: 	bsr			sGetChar
00:00007A96 6100FCD8        	   154: 	bsr			AsciiToHexNybble
00:00007A9A E98A            	   155: 	lsl.l		#4,d2
00:00007A9C 8401            	   156: 	or.b		d1,d2
                            	   157: S1932b:
00:00007A9E 6140            	   158: 	bsr			sGetChar
00:00007AA0 6100FCCE        	   159: 	bsr			AsciiToHexNybble
00:00007AA4 E98A            	   160: 	lsl.l		#4,d2
00:00007AA6 8401            	   161: 	or.b		d1,d2
00:00007AA8 6136            	   162: 	bsr			sGetChar
00:00007AAA 6100FCC4        	   163: 	bsr			AsciiToHexNybble
00:00007AAE E98A            	   164: 	lsl.l		#4,d2
00:00007AB0 8401            	   165: 	or.b		d1,d2
00:00007AB2 612C            	   166: 	bsr			sGetChar
00:00007AB4 6100FCBA        	   167: 	bsr			AsciiToHexNybble
00:00007AB8 E98A            	   168: 	lsl.l		#4,d2
00:00007ABA 8401            	   169: 	or.b		d1,d2
00:00007ABC 7800            	   170: 	clr.l		d4
00:00007ABE 2242            	   171: 	move.l	d2,a1
                            	   172: 	; Add bytes from address value to checksum
00:00007AC0 D53900100150    	   173: 	add.b		d2,S19Checksum
00:00007AC6 E08A            	   174: 	lsr.l		#8,d2
00:00007AC8 D53900100150    	   175: 	add.b		d2,S19Checksum
00:00007ACE E08A            	   176: 	lsr.l		#8,d2
00:00007AD0 D53900100150    	   177: 	add.b		d2,S19Checksum
00:00007AD6 E08A            	   178: 	lsr.l		#8,d2
00:00007AD8 D53900100150    	   179: 	add.b		d2,S19Checksum
00:00007ADE 4E75            	   180: 	rts
                            	   181: 
                            	   182: ;------------------------------------------------------------------------------
                            	   183: ; Get a character from auxillary input. Waiting for a character is limited to
                            	   184: ; 32000 tries. If a character is not available within the limit, then a return
                            	   185: ; to the monitor is done.
                            	   186: ;
                            	   187: ;	Parameters:
                            	   188: ;		none
                            	   189: ; Returns:
                            	   190: ;		d1 = character from receive buffer or -1 if no char available
                            	   191: ;------------------------------------------------------------------------------
                            	   192: 
                            	   193: sGetChar:
00:00007AE0 48E7A000        	   194: 	movem.l	d0/d2,-(a7)
00:00007AE4 343C7D00        	   195: 	move.w	#32000,d2
                            	   196: .0001:
00:00007AE8 7024            	   197: 	moveq		#36,d0				; serial get char from buffer
00:00007AEA 4E4F            	   198: 	trap		#15
00:00007AEC 4A41            	   199: 	tst.w		d1						; was there a char available?
00:00007AEE 6A0C            	   200: 	bpl.s		.0002
00:00007AF0 51CAFFF6        	   201: 	dbra		d2,.0001			; no - try again
00:00007AF4 4CDF0005        	   202: 	movem.l	(a7)+,d0/d2
                            	   203: .0003:
                            	   204: ;	bsr			_KeybdInit
00:00007AF8 6000EE26        	   205: 	bra			Monitor				; ran out of tries
                            	   206: .0002:
00:00007AFC 4CDF0005        	   207: 	movem.l	(a7)+,d0/d2
00:00007B00 0C01001A        	   208: 	cmpi.b	#CTRLZ,d1			; receive end of file?
00:00007B04 67F2            	   209: 	beq			.0003
00:00007B06 4E75            	   210: 	rts
                            	   211: 
                            	   212: 

Source: "boot.x68"
                            	  3658: 	
                            	  3659: AudioInputTest:
00:00007B08 4E75            	  3660: 	rts
                            	  3661: BouncingBalls:
00:00007B0A 4E75            	  3662: 	rts
                            	  3663: GraphicsDemo:
00:00007B0C 4E75            	  3664: 	rts
                            	  3665: ClearScreen:
00:00007B0E 6000DEBA        	  3666: 	bra		clear_screen
00:00007B12 4E75            	  3667: 	rts
                            	  3668: 
                            	  3669: ;------------------------------------------------------------------------------
                            	  3670: ; Reverse the order of bytes in d1.
                            	  3671: ;------------------------------------------------------------------------------
                            	  3672: 
                            	  3673: rbo:
00:00007B14 E159            	  3674: 	rol.w	#8,d1
00:00007B16 4841            	  3675: 	swap d1
00:00007B18 E159            	  3676: 	rol.w	#8,d1
00:00007B1A 4E75            	  3677: 	rts
                            	  3678: 
                            	  3679: ;==============================================================================
                            	  3680: ; Serial I/O routines
                            	  3681: ;==============================================================================
                            	  3682: 
                            	  3683: ;------------------------------------------------------------------------------
                            	  3684: ; Setup the console device
                            	  3685: ; stdout = text screen controller
                            	  3686: ;------------------------------------------------------------------------------
                            	  3687: 
                            	  3688: serial_init:
                            	  3689: setup_serial:
00:00007B1C 701F            	  3690: 	moveq #31,d0
00:00007B1E 41F900040B40    	  3691: 	lea.l serial_dcb,a0
                            	  3692: .0001:
00:00007B24 4298            	  3693: 	clr.l (a0)+
00:00007B26 51C8FFFC        	  3694: 	dbra d0,.0001
00:00007B2A 23FC204243440004	  3695: 	move.l #$20424344,serial_dcb+DCB_MAGIC				; 'DCB'
00:00007B32 0B40
00:00007B34 23FC204F4F430004	  3696: 	move.l #$204F4F43,serial_dcb+DCB_NAME				; 'COM'
00:00007B3C 0B44
00:00007B3E 23FC00007B9C0004	  3697: 	move.l #serial_cmdproc,serial_dcb+DCB_CMDPROC
00:00007B46 0B58
00:00007B48 23FC001010000004	  3698: 	move.l #SerRcvBuf,serial_dcb+DCB_INBUFPTR
00:00007B50 0B68
00:00007B52 23FC001020000004	  3699: 	move.l #SerXmitBuf,serial_dcb+DCB_OUTBUFPTR
00:00007B5A 0B6C
00:00007B5C 23FC000010000004	  3700: 	move.l #4096,serial_dcb+DCB_INBUFSIZE
00:00007B64 0B70
00:00007B66 61000090        	  3701: 	bsr SerialInit
00:00007B6A 4E75            	  3702: 	rts
                            	  3703: 
                            	  3704: 	align 2
                            	  3705: COM_CMDTBL:
00:00007B6C 00007B1C        	  3706: 	dc.l serial_init
00:00007B70 00007BC2        	  3707: 	dc.l serial_stat
00:00007B74 00007BC6        	  3708: 	dc.l serial_putchar
00:00007B78 00007BF4        	  3709: 	dc.l serial_putbuf
00:00007B7C 00007BCE        	  3710: 	dc.l serial_getchar
00:00007B80 00007BF4        	  3711: 	dc.l serial_getbuf
00:00007B84 00007BF4        	  3712: 	dc.l serial_set_inpos
00:00007B88 00007BF4        	  3713: 	dc.l serial_set_outpos
00:00007B8C 00007BD4        	  3714: 	dc.l serial_getchar_direct
00:00007B90 00007BDC        	  3715: 	dc.l serial_peek_char
00:00007B94 00007BE4        	  3716: 	dc.l serial_peek_char_direct
00:00007B98 00007BEC        	  3717: 	dc.l serial_putchar_direct
                            	  3718: 
                            	  3719: serial_cmdproc:
00:00007B9C 0C06000C        	  3720: 	cmpi.b #12,d6
00:00007BA0 641C            	  3721: 	bhs.s .0001
00:00007BA2 4A06            	  3722: 	tst.b d6
00:00007BA4 6B18            	  3723: 	bmi.s .0001
00:00007BA6 48E70280        	  3724: 	movem.l d6/a0,-(a7)
00:00007BAA E506            	  3725: 	asl.b #2,d6
00:00007BAC 4886            	  3726: 	ext.w d6
00:00007BAE 41FAFFBC        	  3727: 	lea COM_CMDTBL,a0
00:00007BB2 20706000        	  3728: 	move.l (a0,d6.w),a0
00:00007BB6 4E90            	  3729: 	jsr (a0)
00:00007BB8 4CDF0140        	  3730: 	movem.l (a7)+,d6/a0
00:00007BBC 4E75            	  3731: 	rts
                            	  3732: .0001:
00:00007BBE 7002            	  3733: 	moveq #E_Func,d0
00:00007BC0 4E75            	  3734: 	rts
                            	  3735: 
                            	  3736: serial_stat:
00:00007BC2 7000            	  3737: 	moveq #E_Ok,d0
00:00007BC4 4E75            	  3738: 	rts
                            	  3739: 
                            	  3740: serial_putchar:
00:00007BC6 6100013C        	  3741: 	bsr SerialPutChar
00:00007BCA 7000            	  3742: 	moveq #E_Ok,d0
00:00007BCC 4E75            	  3743: 	rts
                            	  3744: 
                            	  3745: serial_getchar:
00:00007BCE 6166            	  3746: 	bsr SerialGetChar
00:00007BD0 7000            	  3747: 	moveq #E_Ok,d0
00:00007BD2 4E75            	  3748: 	rts
                            	  3749: 
                            	  3750: serial_getchar_direct:
00:00007BD4 61000114        	  3751: 	bsr SerialPeekCharDirect
00:00007BD8 7000            	  3752: 	moveq #E_Ok,d0
00:00007BDA 4E75            	  3753: 	rts
                            	  3754: 
                            	  3755: serial_peek_char:
00:00007BDC 610000D0        	  3756: 	bsr SerialPeekChar
00:00007BE0 7000            	  3757: 	moveq #E_Ok,d0
00:00007BE2 4E75            	  3758: 	rts
                            	  3759: 
                            	  3760: serial_peek_char_direct:
00:00007BE4 61000104        	  3761: 	bsr SerialPeekCharDirect
00:00007BE8 7000            	  3762: 	moveq #E_Ok,d0
00:00007BEA 4E75            	  3763: 	rts
                            	  3764: 
                            	  3765: serial_putchar_direct:
00:00007BEC 6100017A        	  3766: 	bsr SerialPutCharDirect
00:00007BF0 7000            	  3767: 	moveq #E_Ok,d0
00:00007BF2 4E75            	  3768: 	rts
                            	  3769: 
                            	  3770: serial_putbuf:
                            	  3771: serial_getbuf:
                            	  3772: serial_set_inpos:
                            	  3773: serial_set_outpos:
00:00007BF4 700A            	  3774: 	moveq #E_NotSupported,d0
00:00007BF6 4E75            	  3775: 	rts
                            	  3776: 
                            	  3777: ;------------------------------------------------------------------------------
                            	  3778: ; Initialize the serial port an enhanced 6551 circuit.
                            	  3779: ;
                            	  3780: ; Select internal baud rate clock divider for 9600 baud
                            	  3781: ; Reset fifos, set threshold to 3/4 full on transmit and 3/4 empty on receive
                            	  3782: ; Note that the byte order is swapped.
                            	  3783: ;------------------------------------------------------------------------------
                            	  3784: 
                            	  3785: SerialInit:
00:00007BF8 427900100162    	  3786: 	clr.w		SerHeadRcv					; clear receive buffer indexes
00:00007BFE 427900100160    	  3787: 	clr.w		SerTailRcv
00:00007C04 427900100168    	  3788: 	clr.w		SerHeadXmit					; clear transmit buffer indexes
00:00007C0A 427900100166    	  3789: 	clr.w		SerTailXmit
00:00007C10 423900100164    	  3790: 	clr.b		SerRcvXon						; and Xon,Xoff flags
00:00007C16 423900100165    	  3791: 	clr.b		SerRcvXoff
00:00007C1C 203C09000000    	  3792: 	move.l	#$09000000,d0				; dtr,rts active, rxint enabled, no parity
00:00007C22 23C0FD060008    	  3793: 	move.l	d0,ACIA+ACIA_CMD
                            	  3794: ;	move.l	#$1E00F700,d0				; fifos enabled
00:00007C28 203C1E000000    	  3795: 	move.l	#$1E000000,d0				; fifos disabled
00:00007C2E 23C0FD06000C    	  3796: 	move.l	d0,ACIA+ACIA_CTRL
00:00007C34 4E75            	  3797: 	rts
                            	  3798: ;	move.l	#$0F000000,d0				; transmit a break for a while
                            	  3799: ;	move.l	d0,ACIA+ACIA_CMD
                            	  3800: ;	move.l	#300000,d2					; wait 100 ms
                            	  3801: ;	bra			.0001
                            	  3802: ;.0003:
                            	  3803: ;	swap		d2
                            	  3804: ;.0001:
                            	  3805: ;	nop
                            	  3806: ;	dbra		d2,.0001
                            	  3807: ;.0002:
                            	  3808: ;	swap		d2
                            	  3809: ;	dbra		d2,.0003
                            	  3810: ;	move.l	#$07000000,d0				; clear break
                            	  3811: ;	move.l	d0,ACIA+ACIA_CMD
                            	  3812: ;	rts
                            	  3813: 	
                            	  3814: ;------------------------------------------------------------------------------
                            	  3815: ; SerialGetChar
                            	  3816: ;
                            	  3817: ; Check the serial port buffer to see if there's a char available. If there's
                            	  3818: ; a char available then return it. If the buffer is almost empty then send an
                            	  3819: ; XON.
                            	  3820: ;
                            	  3821: ; Stack Space:
                            	  3822: ;		2 long words
                            	  3823: ; Parameters:
                            	  3824: ;		none
                            	  3825: ; Modifies:
                            	  3826: ;		d0,a0
                            	  3827: ; Returns:
                            	  3828: ;		d1 = character or -1
                            	  3829: ;------------------------------------------------------------------------------
                            	  3830: 
                            	  3831: SerialGetChar:
00:00007C36 2F02            	  3832: 	move.l		d2,-(a7)
00:00007C38 4E7A0FE0        	  3833: 	movec			coreno,d0
00:00007C3C 4840            	  3834: 	swap			d0
00:00007C3E 7202            	  3835: 	moveq			#SERIAL_SEMA,d1
00:00007C40 61008B0A        	  3836: 	bsr				LockSemaphore
00:00007C44 61000146        	  3837: 	bsr				SerialRcvCount			; check number of chars in receive buffer
00:00007C48 0C400008        	  3838: 	cmpi.w		#8,d0								; less than 8?
00:00007C4C 621C            	  3839: 	bhi				.sgc2
00:00007C4E 4A3900100164    	  3840: 	tst.b			SerRcvXon						; skip sending XON if already sent
00:00007C54 6614            	  3841: 	bne	  		.sgc2            		; XON already sent?
00:00007C56 123C0011        	  3842: 	move.b		#XON,d1							; if <8 send an XON
00:00007C5A 423900100165    	  3843: 	clr.b			SerRcvXoff					; clear XOFF status
00:00007C60 13C100100164    	  3844: 	move.b		d1,SerRcvXon				; flag so we don't send it multiple times
00:00007C66 6100009C        	  3845: 	bsr				SerialPutChar				; send it
                            	  3846: .sgc2:
00:00007C6A 323900100162    	  3847: 	move.w		SerHeadRcv,d1				; check if anything is in buffer
00:00007C70 B27900100160    	  3848: 	cmp.w			SerTailRcv,d1
00:00007C76 6720            	  3849: 	beq				.NoChars						; no?
00:00007C78 41F900101000    	  3850: 	lea				SerRcvBuf,a0
00:00007C7E 12301000        	  3851: 	move.b		(a0,d1.w),d1				; get byte from buffer
00:00007C82 527900100162    	  3852: 	addi.w		#1,SerHeadRcv
00:00007C88 02790FFF00100162	  3853: 	andi.w		#$FFF,SerHeadRcv		; 4k wrap around
00:00007C90 0281000000FF    	  3854: 	andi.l		#$FF,d1
00:00007C96 6002            	  3855: 	bra				.Xit
                            	  3856: .NoChars:
00:00007C98 72FF            	  3857: 	moveq			#-1,d1
                            	  3858: .Xit:
00:00007C9A C342            	  3859: 	exg				d1,d2
00:00007C9C 4E7A0FE0        	  3860: 	movec			coreno,d0
00:00007CA0 4840            	  3861: 	swap			d0
00:00007CA2 7202            	  3862: 	moveq			#SERIAL_SEMA,d1
00:00007CA4 61008AE2        	  3863: 	bsr				UnlockSemaphore
00:00007CA8 C541            	  3864: 	exg				d2,d1
00:00007CAA 241F            	  3865: 	move.l		(a7)+,d2
00:00007CAC 4E75            	  3866: 	rts
                            	  3867: 
                            	  3868: ;------------------------------------------------------------------------------
                            	  3869: ; SerialPeekChar
                            	  3870: ;
                            	  3871: ; Check the serial port buffer to see if there's a char available. If there's
                            	  3872: ; a char available then return it. But don't update the buffer indexes. No need
                            	  3873: ; to send an XON here.
                            	  3874: ;
                            	  3875: ; Stack Space:
                            	  3876: ;		1 long word
                            	  3877: ; Parameters:
                            	  3878: ;		none
                            	  3879: ; Modifies:
                            	  3880: ;		d0,a0
                            	  3881: ; Returns:
                            	  3882: ;		d1 = character or -1
                            	  3883: ;------------------------------------------------------------------------------
                            	  3884: 
                            	  3885: SerialPeekChar:
00:00007CAE 2F02            	  3886: 	move.l d2,-(a7)
00:00007CB0 4E7A0FE0        	  3887: 	movec	coreno,d0
00:00007CB4 4840            	  3888: 	swap d0
00:00007CB6 7202            	  3889: 	moveq	#SERIAL_SEMA,d1
00:00007CB8 61008A92        	  3890: 	bsr	LockSemaphore
00:00007CBC 343900100162    	  3891: 	move.w SerHeadRcv,d2		; check if anything is in buffer
00:00007CC2 B47900100160    	  3892: 	cmp.w	SerTailRcv,d2
00:00007CC8 670C            	  3893: 	beq	.NoChars				; no?
00:00007CCA 41F900101000    	  3894: 	lea	SerRcvBuf,a0
00:00007CD0 14302000        	  3895: 	move.b (a0,d2.w),d2		; get byte from buffer
00:00007CD4 6002            	  3896: 	bra	.Xit
                            	  3897: .NoChars:
00:00007CD6 74FF            	  3898: 	moveq	#-1,d2
                            	  3899: .Xit:
00:00007CD8 4E7A0FE0        	  3900: 	movec	coreno,d0
00:00007CDC 4840            	  3901: 	swap d0
00:00007CDE 7202            	  3902: 	moveq	#SERIAL_SEMA,d1
00:00007CE0 61008AA6        	  3903: 	bsr	UnlockSemaphore
00:00007CE4 2202            	  3904: 	move.l	d2,d1
00:00007CE6 241F            	  3905: 	move.l (a7)+,d2
00:00007CE8 4E75            	  3906: 	rts
                            	  3907: 
                            	  3908: ;------------------------------------------------------------------------------
                            	  3909: ; SerialPeekChar
                            	  3910: ;		Get a character directly from the I/O port. This bypasses the input
                            	  3911: ; buffer.
                            	  3912: ;
                            	  3913: ; Stack Space:
                            	  3914: ;		0 words
                            	  3915: ; Parameters:
                            	  3916: ;		none
                            	  3917: ; Modifies:
                            	  3918: ;		d
                            	  3919: ; Returns:
                            	  3920: ;		d1 = character or -1
                            	  3921: ;------------------------------------------------------------------------------
                            	  3922: 
                            	  3923: SerialPeekCharDirect:
00:00007CEA 1239FD060004    	  3924: 	move.b	ACIA+ACIA_STAT,d1	; get serial status
00:00007CF0 08010003        	  3925: 	btst		#3,d1							; look for Rx not empty
00:00007CF4 670A            	  3926: 	beq.s		.0001
00:00007CF6 7200            	  3927: 	moveq.l	#0,d1							; clear upper bits of return value
00:00007CF8 1239FD060000    	  3928: 	move.b	ACIA+ACIA_RX,d1		; get data from ACIA
00:00007CFE 4E75            	  3929: 	rts												; return
                            	  3930: .0001:
00:00007D00 72FF            	  3931: 	moveq		#-1,d1
00:00007D02 4E75            	  3932: 	rts
                            	  3933: 
                            	  3934: ;------------------------------------------------------------------------------
                            	  3935: ; SerialPutChar
                            	  3936: ;		If there is a transmit buffer, adds the character to the transmit buffer
                            	  3937: ; if it can, otherwise will wait for a byte to be freed up in the transmit
                            	  3938: ; buffer (blocks).
                            	  3939: ;		If there is no transmit buffer, put a character to the directly to the
                            	  3940: ; serial transmitter. This routine blocks until the transmitter is empty. 
                            	  3941: ;
                            	  3942: ; Stack Space
                            	  3943: ;		4 long words
                            	  3944: ; Parameters:
                            	  3945: ;		d1.b = character to put
                            	  3946: ; Modifies:
                            	  3947: ;		none
                            	  3948: ;------------------------------------------------------------------------------
                            	  3949: 
                            	  3950: SerialPutChar:
                            	  3951: .0004:
00:00007D04 4A7900040B74    	  3952: 	tst.w serial_dcb+DCB_OUTBUFSIZE	; buffered output?
00:00007D0A 675C            	  3953: 	beq.s SerialPutCharDirect
00:00007D0C 48E7E080        	  3954: 	movem.l d0/d1/d2/a0,-(a7)
00:00007D10 4E7A0FE0        	  3955: 	movec	coreno,d0
00:00007D14 4840            	  3956: 	swap d0
00:00007D16 7202            	  3957: 	moveq	#SERIAL_SEMA,d1
00:00007D18 61008A32        	  3958: 	bsr	LockSemaphore
00:00007D1C 303900100166    	  3959: 	move.w SerTailXmit,d0
00:00007D22 3400            	  3960: 	move.w d0,d2
00:00007D24 5240            	  3961: 	addi.w #1,d0
00:00007D26 B07900040B74    	  3962: 	cmp.w serial_dcb+DCB_OUTBUFSIZE,d0
00:00007D2C 6502            	  3963: 	blo.s .0002
00:00007D2E 4240            	  3964: 	clr.w d0
                            	  3965: .0002:
00:00007D30 B07900100168    	  3966: 	cmp.w SerHeadXmit,d0			; Is Xmit buffer full?
00:00007D36 660E            	  3967: 	bne.s .0003
00:00007D38 4E7A0FE0        	  3968: 	movec	coreno,d0						; buffer full, unlock semaphore and wait
00:00007D3C 4840            	  3969: 	swap d0
00:00007D3E 7202            	  3970: 	moveq	#SERIAL_SEMA,d1
00:00007D40 61008A46        	  3971: 	bsr	UnlockSemaphore
00:00007D44 60BE            	  3972: 	bra.s .0004
                            	  3973: .0003:
00:00007D46 33C000100166    	  3974: 	move.w d0,SerTailXmit			; update tail pointer
00:00007D4C 41F900102000    	  3975: 	lea SerXmitBuf,a0
00:00007D52 11812000        	  3976: 	move.b d1,(a0,d2.w)				; store byte in Xmit buffer
00:00007D56 4E7A0FE0        	  3977: 	movec	coreno,d0						; unlock semaphore
00:00007D5A 4840            	  3978: 	swap d0
00:00007D5C 7202            	  3979: 	moveq	#SERIAL_SEMA,d1
00:00007D5E 61008A28        	  3980: 	bsr	UnlockSemaphore
00:00007D62 4CDF0107        	  3981: 	movem.l (a7)+,d0/d1/d2/a0
00:00007D66 4E75            	  3982: 	rts
                            	  3983: 
                            	  3984: SerialPutCharDirect:
00:00007D68 48E7C000        	  3985: 	movem.l	d0/d1,-(a7)							; push d0,d1
                            	  3986: .0001:
00:00007D6C 1039FD060004    	  3987: 	move.b ACIA+ACIA_STAT,d0	; wait until the uart indicates tx empty
00:00007D72 08000004        	  3988: 	btst #4,d0								; bit #4 of the status reg
00:00007D76 67F4            	  3989: 	beq.s	.0001			    			; branch if transmitter is not empty
00:00007D78 13C1FD060000    	  3990: 	move.b d1,ACIA+ACIA_TX		; send the byte
00:00007D7E 4CDF0003        	  3991: 	movem.l	(a7)+,d0/d1				; pop d0,d1
00:00007D82 4E75            	  3992: 	rts
                            	  3993: 	
                            	  3994: ;------------------------------------------------------------------------------
                            	  3995: ; Reverse the order of bytes in d1.
                            	  3996: ;------------------------------------------------------------------------------
                            	  3997: 
                            	  3998: SerialRbo:
00:00007D84 E159            	  3999: 	rol.w		#8,d1
00:00007D86 4841            	  4000: 	swap		d1
00:00007D88 E159            	  4001: 	rol.w		#8,d1
00:00007D8A 4E75            	  4002: 	rts
                            	  4003: 
                            	  4004: ;------------------------------------------------------------------------------
                            	  4005: ; Calculate number of character in input buffer
                            	  4006: ;
                            	  4007: ; Returns:
                            	  4008: ;		d0 = number of bytes in buffer.
                            	  4009: ;------------------------------------------------------------------------------
                            	  4010: 
                            	  4011: SerialRcvCount:
00:00007D8C 303900100160    	  4012: 	move.w	SerTailRcv,d0
00:00007D92 907900100162    	  4013: 	sub.w		SerHeadRcv,d0
00:00007D98 6C10            	  4014: 	bge			.0001
00:00007D9A 303C1000        	  4015: 	move.w	#$1000,d0
00:00007D9E 907900100162    	  4016: 	sub.w		SerHeadRcv,d0
00:00007DA4 D07900100160    	  4017: 	add.w		SerTailRcv,d0
                            	  4018: .0001:
00:00007DAA 4E75            	  4019: 	rts
                            	  4020: 
                            	  4021: ;------------------------------------------------------------------------------
                            	  4022: ; Serial IRQ routine
                            	  4023: ;
                            	  4024: ; Keeps looping as long as it finds characters in the ACIA recieve buffer/fifo.
                            	  4025: ; Received characters are buffered. If the buffer becomes full, new characters
                            	  4026: ; will be lost.
                            	  4027: ;
                            	  4028: ; Parameters:
                            	  4029: ;		none
                            	  4030: ; Modifies:
                            	  4031: ;		none
                            	  4032: ; Returns:
                            	  4033: ;		d1 = -1 if IRQ handled, otherwise zero
                            	  4034: ;------------------------------------------------------------------------------
                            	  4035: 
                            	  4036: SerialIRQ:
00:00007DAC 46FC2300        	  4037: 	move.w	#$2300,sr						; disable lower level IRQs
00:00007DB0 48E7E080        	  4038: 	movem.l	d0/d1/d2/a0,-(a7)
00:00007DB4 4E7A0FE0        	  4039: 	movec	coreno,d0
00:00007DB8 4840            	  4040: 	swap d0
00:00007DBA 7202            	  4041: 	moveq	#SERIAL_SEMA,d1
00:00007DBC 6100898E        	  4042: 	bsr	LockSemaphore
                            	  4043: sirqNxtByte:
00:00007DC0 1239FD060004    	  4044: 	move.b ACIA+ACIA_STAT,d1		; check the status
00:00007DC6 08010003        	  4045: 	btst #3,d1									; bit 3 = rx full
00:00007DCA 6756            	  4046: 	beq	notRxInt
00:00007DCC 1239FD060000    	  4047: 	move.b ACIA+ACIA_RX,d1
                            	  4048: sirq0001:
00:00007DD2 303900100160    	  4049: 	move.w SerTailRcv,d0				; check if recieve buffer full
00:00007DD8 5240            	  4050: 	addi.w #1,d0
00:00007DDA 02400FFF        	  4051: 	andi.w #$FFF,d0
00:00007DDE B07900100162    	  4052: 	cmp.w	SerHeadRcv,d0
00:00007DE4 673C            	  4053: 	beq	sirqRxFull
00:00007DE6 33C000100160    	  4054: 	move.w d0,SerTailRcv				; update tail pointer
00:00007DEC 5340            	  4055: 	subi.w #1,d0								; backup
00:00007DEE 02400FFF        	  4056: 	andi.w #$FFF,d0
00:00007DF2 41F900101000    	  4057: 	lea	SerRcvBuf,a0						; a0 = buffer address
00:00007DF8 11810000        	  4058: 	move.b d1,(a0,d0.w)					; store recieved byte in buffer
00:00007DFC 4A3900100165    	  4059: 	tst.b	SerRcvXoff						; check if xoff already sent
00:00007E02 66BC            	  4060: 	bne	sirqNxtByte
00:00007E04 6186            	  4061: 	bsr	SerialRcvCount					; if more than 4080 chars in buffer
00:00007E06 0C400FF0        	  4062: 	cmpi.w #4080,d0
00:00007E0A 65B4            	  4063: 	blo	sirqNxtByte
00:00007E0C 123C0013        	  4064: 	move.b #XOFF,d1							; send an XOFF
00:00007E10 423900100164    	  4065: 	clr.b	SerRcvXon							; clear XON status
00:00007E16 13C100100165    	  4066: 	move.b d1,SerRcvXoff				; set XOFF status
00:00007E1C 6100FEE6        	  4067: 	bsr	SerialPutChar						; send XOFF
00:00007E20 609E            	  4068: 	bra	sirqNxtByte     				; check the status for another byte
                            	  4069: sirqRxFull:
                            	  4070: notRxInt:
00:00007E22 08010004        	  4071: 	btst #4,d1									; TX empty?
00:00007E26 6748            	  4072: 	beq.s notTxInt
00:00007E28 4A390010016A    	  4073: 	tst.b SerXmitXoff						; and allowed to send?
00:00007E2E 6640            	  4074: 	bne.s sirqXmitOff
00:00007E30 4AB900040B74    	  4075: 	tst.l serial_dcb+DCB_OUTBUFSIZE	; Is there a buffer being transmitted?
00:00007E36 6738            	  4076: 	beq.s notTxInt
00:00007E38 303900100168    	  4077: 	move.w SerHeadXmit,d0
00:00007E3E B07900100166    	  4078: 	cmp.w SerTailXmit,d0
00:00007E44 672A            	  4079: 	beq.s sirqTxEmpty
00:00007E46 41F900102000    	  4080: 	lea SerXmitBuf,a0
00:00007E4C 12300000        	  4081: 	move.b (a0,d0.w),d1
00:00007E50 13C1FD060000    	  4082: 	move.b d1,ACIA+ACIA_TX			; transmit character
00:00007E56 527900100168    	  4083: 	addi.w #1,SerHeadXmit				; advance head index
00:00007E5C 303900040B74    	  4084: 	move.w serial_dcb+DCB_OUTBUFSIZE,d0
00:00007E62 B07900100168    	  4085: 	cmp.w SerHeadXmit,d0
00:00007E68 6206            	  4086: 	bhi.s sirq0002
00:00007E6A 427900100168    	  4087: 	clr.w SerHeadXmit						; wrap around
                            	  4088: sirq0002:
                            	  4089: sirqXmitOff:
                            	  4090: sirqTxEmpty:
                            	  4091: notTxInt:
00:00007E70 4E7A0FE0        	  4092: 	movec	coreno,d0
00:00007E74 4840            	  4093: 	swap d0
00:00007E76 7202            	  4094: 	moveq	#SERIAL_SEMA,d1
00:00007E78 6100890E        	  4095: 	bsr	UnlockSemaphore
00:00007E7C 4CDF0107        	  4096: 	movem.l	(a7)+,d0/d1/d2/a0
00:00007E80 4E73            	  4097: 	rte
                            	  4098: 
                            	  4099: nmeSerial:
00:00007E82 53657269616C    	  4100: 	dc.b		"Serial",0
00:00007E88 00
                            	  4101: 
                            	  4102: ;===============================================================================
                            	  4103: ; Generic I2C routines
                            	  4104: ;===============================================================================
                            	  4105: 
                            	  4106: 	even
                            	  4107: ; i2c
                            	  4108: i2c_setup:
                            	  4109: ;		lea		I2C,a6				
                            	  4110: ;		move.w	#19,I2C_PREL(a6)	; setup prescale for 400kHz clock
                            	  4111: ;		move.w	#0,I2C_PREH(a6)
                            	  4112: init_i2c:
00:00007E8A 4DF9FD069000    	  4113: 	lea	I2C2,a6				
00:00007E90 1CBC0013        	  4114: 	move.b #19,I2C_PREL(a6)	; setup prescale for 400kHz clock, 40MHz master
00:00007E94 422E0001        	  4115: 	move.b #0,I2C_PREH(a6)
00:00007E98 4E75            	  4116: 	rts
                            	  4117: 
                            	  4118: ; Wait for I2C transfer to complete
                            	  4119: ;
                            	  4120: ; Parameters
                            	  4121: ; 	a6 - I2C controller base address
                            	  4122: 
                            	  4123: i2c_wait_tip:
00:00007E9A 2F00            	  4124: 	move.l d0,-(a7)
                            	  4125: .0001				
00:00007E9C 102E0004        	  4126: 	move.b I2C_STAT(a6),d0		; wait for tip to clear
00:00007EA0 08000001        	  4127: 	btst #1,d0
00:00007EA4 66F6            	  4128: 	bne.s	.0001
00:00007EA6 201F            	  4129: 	move.l (a7)+,d0
00:00007EA8 4E75            	  4130: 	rts
                            	  4131: 
                            	  4132: ; Parameters
                            	  4133: ;	d0.b - data to transmit
                            	  4134: ;	d1.b - command value
                            	  4135: ;	a6	 - I2C controller base address
                            	  4136: ;
                            	  4137: i2c_wr_cmd:
00:00007EAA 1D400003        	  4138: 	move.b d0,I2C_TXR(a6)
00:00007EAE 1D410004        	  4139: 	move.b d1,I2C_CMD(a6)
00:00007EB2 61E6            	  4140: 	bsr	i2c_wait_tip
00:00007EB4 102E0004        	  4141: 	move.b I2C_STAT(a6),d0
00:00007EB8 4E75            	  4142: 	rts
                            	  4143: 
                            	  4144: i2c_xmit1:
00:00007EBA 2F00            	  4145: 	move.l d0,-(a7)
00:00007EBC 1D7C00010002    	  4146: 	move.b #1,I2C_CTRL(a6)		; enable the core
00:00007EC2 7076            	  4147: 	moveq	#$76,d0				; set slave address = %0111011
00:00007EC4 323C0090        	  4148: 	move.w #$90,d1				; set STA, WR
00:00007EC8 61E0            	  4149: 	bsr i2c_wr_cmd
00:00007ECA 610C            	  4150: 	bsr	i2c_wait_rx_nack
00:00007ECC 201F            	  4151: 	move.l (a7)+,d0
00:00007ECE 323C0050        	  4152: 	move.w #$50,d1				; set STO, WR
00:00007ED2 61D6            	  4153: 	bsr i2c_wr_cmd
00:00007ED4 61000002        	  4154: 	bsr	i2c_wait_rx_nack
                            	  4155: 
                            	  4156: i2c_wait_rx_nack:
00:00007ED8 2F00            	  4157: 	move.l d0,-(a7)
                            	  4158: .0001						
00:00007EDA 102E0004        	  4159: 	move.b I2C_STAT(a6),d0		; wait for RXack = 0
00:00007EDE 08000007        	  4160: 	btst #7,d0
00:00007EE2 66F6            	  4161: 	bne.s	.0001
00:00007EE4 201F            	  4162: 	move.l (a7)+,d0
00:00007EE6 4E75            	  4163: 	rts
                            	  4164: 
                            	  4165: ;===============================================================================
                            	  4166: ; Realtime clock routines
                            	  4167: ;===============================================================================
                            	  4168: 
                            	  4169: rtc_read:
00:00007EE8 2C7CFD069000    	  4170: 	movea.l	#I2C2,a6
00:00007EEE 4BF900100200    	  4171: 	lea	RTCBuf,a5
00:00007EF4 1D7C00800002    	  4172: 	move.b	#$80,I2C_CTRL(a6)	; enable I2C
00:00007EFA 103C00DE        	  4173: 	move.b	#$DE,d0				; read address, write op
00:00007EFE 123C0090        	  4174: 	move.b	#$90,d1				; STA + wr bit
00:00007F02 61A6            	  4175: 	bsr	i2c_wr_cmd
00:00007F04 4A00            	  4176: 	tst.b	d0
00:00007F06 6B66            	  4177: 	bmi	.rxerr
00:00007F08 4200            	  4178: 	move.b #$00,d0				; address zero
00:00007F0A 123C0010        	  4179: 	move.b #$10,d1				; wr bit
00:00007F0E 619A            	  4180: 	bsr	i2c_wr_cmd
00:00007F10 4A00            	  4181: 	tst.b	d0
00:00007F12 6B5A            	  4182: 	bmi	.rxerr
00:00007F14 103C00DF        	  4183: 	move.b #$DF,d0				; read address, read op
00:00007F18 123C0090        	  4184: 	move.b #$90,d1				; STA + wr bit
00:00007F1C 618C            	  4185: 	bsr i2c_wr_cmd
00:00007F1E 4A00            	  4186: 	tst.b	d0
00:00007F20 6B4C            	  4187: 	bmi	.rxerr
                            	  4188: 		
00:00007F22 343C0020        	  4189: 	move.w #$20,d2
                            	  4190: .0001
00:00007F26 1D7C00200004    	  4191: 	move.b #$20,I2C_CMD(a6)	; rd bit
00:00007F2C 6100FF6C        	  4192: 	bsr	i2c_wait_tip
00:00007F30 61A6            	  4193: 	bsr	i2c_wait_rx_nack
00:00007F32 102E0004        	  4194: 	move.b I2C_STAT(a6),d0
00:00007F36 4A00            	  4195: 	tst.b	d0
00:00007F38 6B34            	  4196: 	bmi	.rxerr
00:00007F3A 102E0003        	  4197: 	move.b I2C_RXR(a6),d0
00:00007F3E 1B802000        	  4198: 	move.b d0,(a5,d2.w)
00:00007F42 5242            	  4199: 	addi.w #1,d2
00:00007F44 0C42005F        	  4200: 	cmpi.w #$5F,d2
00:00007F48 66DC            	  4201: 	bne	.0001
00:00007F4A 1D7C00680004    	  4202: 	move.b #$68,I2C_CMD(a6)	; STO, rd bit + nack
00:00007F50 6100FF48        	  4203: 	bsr i2c_wait_tip
00:00007F54 6182            	  4204: 	bsr i2c_wait_rx_nack
00:00007F56 102E0004        	  4205: 	move.b I2C_STAT(a6),d0
00:00007F5A 4A00            	  4206: 	tst.b	d0
00:00007F5C 6B10            	  4207: 	bmi	.rxerr
00:00007F5E 102E0003        	  4208: 	move.b I2C_RXR(a6),d0
00:00007F62 1B802000        	  4209: 	move.b d0,(a5,d2.w)
00:00007F66 422E0002        	  4210: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
00:00007F6A 7000            	  4211: 	moveq	#0,d0
00:00007F6C 4E75            	  4212: 	rts
                            	  4213: .rxerr
00:00007F6E 422E0002        	  4214: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
00:00007F72 4E75            	  4215: 	rts
                            	  4216: 
                            	  4217: rtc_write:
00:00007F74 2C7CFD069000    	  4218: 	movea.l	#I2C2,a6
00:00007F7A 4BF900100200    	  4219: 	lea	RTCBuf,a5
00:00007F80 1D7C00800002    	  4220: 	move.b #$80,I2C_CTRL(a6)	; enable I2C
00:00007F86 103C00DE        	  4221: 	move.b #$DE,d0				; read address, write op
00:00007F8A 123C0090        	  4222: 	move.b #$90,d1				; STA + wr bit
00:00007F8E 6100FF1A        	  4223: 	bsr	i2c_wr_cmd
00:00007F92 4A00            	  4224: 	tst.b	d0
00:00007F94 6B42            	  4225: 	bmi	.rxerr
00:00007F96 4200            	  4226: 	move.b #$00,d0				; address zero
00:00007F98 123C0010        	  4227: 	move.b #$10,d1				; wr bit
00:00007F9C 6100FF0C        	  4228: 	bsr	i2c_wr_cmd
00:00007FA0 4A00            	  4229: 	tst.b	d0
00:00007FA2 6B34            	  4230: 	bmi	.rxerr
00:00007FA4 343C0020        	  4231: 	move.w #$20,d2
                            	  4232: .0001
00:00007FA8 10352000        	  4233: 	move.b (a5,d2.w),d0
00:00007FAC 123C0010        	  4234: 	move.b #$10,d1
00:00007FB0 6100FEF8        	  4235: 	bsr	i2c_wr_cmd
00:00007FB4 4A00            	  4236: 	tst.b	d0
00:00007FB6 6B20            	  4237: 	bmi	.rxerr
00:00007FB8 5242            	  4238: 	addi.w #1,d2
00:00007FBA 0C42005F        	  4239: 	cmpi.w #$5F,d2
00:00007FBE 66E8            	  4240: 	bne.s	.0001
00:00007FC0 10352000        	  4241: 	move.b (a5,d2.w),d0
00:00007FC4 123C0050        	  4242: 	move.b #$50,d1				; STO, wr bit
00:00007FC8 6100FEE0        	  4243: 	bsr	i2c_wr_cmd
00:00007FCC 4A00            	  4244: 	tst.b	d0
00:00007FCE 6B08            	  4245: 	bmi	.rxerr
00:00007FD0 422E0002        	  4246: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
00:00007FD4 7000            	  4247: 	moveq	#0,d0
00:00007FD6 4E75            	  4248: 	rts
                            	  4249: .rxerr:
00:00007FD8 422E0002        	  4250: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
00:00007FDC 4E75            	  4251: 	rts
                            	  4252: 
                            	  4253: msgRtcReadFail:
00:00007FDE 5254432072656164	  4254: 	dc.b	"RTC read/write failed.",$0A,$0D,$00
00:00007FE6 2F77726974652066
00:00007FEE 61696C65642E
00:00007FF4 0A
00:00007FF5 0D
00:00007FF6 00
                            	  4255: 
                            	  4256: msgBusErr:
00:00007FF7 0A              	  4257: 	dc.b	$0A,$0D,"Bus error at: ",$00
00:00007FF8 0D
00:00007FF9 427573206572726F
00:00008001 722061743A20
00:00008007 00
                            	  4258: 	even
                            	  4259: 
                            	  4260: ;------------------------------------------------------------------------------
                            	  4261: ;------------------------------------------------------------------------------
                            	  4262: 	even
                            	  4263: 
                            	  4264: bus_err:
00:00008008 4E71            	  4265: 	nop
00:0000800A 43FAFFEB        	  4266: 	lea.l msgBusErr,a1
00:0000800E 6100DCA8        	  4267: 	bsr DisplayString
00:00008012 222F0002        	  4268: 	move.l 2(a7),d1
00:00008016 6100F7AC        	  4269: 	bsr DisplayTetra
00:0000801A 6100D9EA        	  4270: 	bsr CRLF
00:0000801E 6000E900        	  4271: 	bra	Monitor
                            	  4272: 
                            	  4273: trap3:
                            	  4274: 	; First save all registers
00:00008022 48F9FFFF00040100	  4275: 	movem.l		d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
00:0000802A 33DF00040140    	  4276: 	move.w		(a7)+,Regsave+$40
00:00008030 23DF00040144    	  4277: 	move.l		(a7)+,Regsave+$44
00:00008036 2E7C00040FFC    	  4278: 	move.l		#$40FFC,a7			; reset stack pointer
00:0000803C 46FC2500        	  4279: 	move.w		#$2500,sr				; enable interrupts
00:00008040 303900040202    	  4280: 	move.w		NumSetBreakpoints,d0
00:00008046 5340            	  4281: 	subi.w		#1,d0
00:00008048 41F900040220    	  4282: 	lea				Breakpoints,a0
00:0000804E 223900040144    	  4283: 	move.l		Regsave+$44,d1
                            	  4284: .0001:
00:00008054 B298            	  4285: 	cmp.l			(a0)+,d1
00:00008056 6708            	  4286: 	beq.s			ProcessBreakpoint
00:00008058 51C8FFFA        	  4287: 	dbra			d0,.0001
00:0000805C 6000E8C2        	  4288: 	bra				Monitor					; not a breakpoint
                            	  4289: ProcessBreakpoint:
00:00008060 6104            	  4290: 	bsr				DisarmAllBreakpoints
00:00008062 6000F0BC        	  4291: 	bra				cmdDumpRegs
                            	  4292: 
                            	  4293: ;------------------------------------------------------------------------------
                            	  4294: ; DisarmAllBreakpoints, used when entering the monitor.
                            	  4295: ;------------------------------------------------------------------------------
                            	  4296: 
                            	  4297: DisarmAllBreakpoints:
00:00008066 48E780E0        	  4298: 	movem.l	d0/a0/a1/a2,-(a7)			; stack some regs
00:0000806A 303900040202    	  4299: 	move.w	NumSetBreakpoints,d0	; d0 = number of breakpoints that are set
00:00008070 0C400008        	  4300: 	cmpi.w	#numBreakpoints,d0		; check for valid number
00:00008074 641A            	  4301: 	bhs.s		.0001
00:00008076 45F900040220    	  4302: 	lea			Breakpoints,a2				; a2 = pointer to breakpoint address table
00:0000807C 41F900040280    	  4303: 	lea			BreakpointWords,a0		; a0 = pointer to breakpoint instruction word table
00:00008082 6004            	  4304: 	bra.s		.0003									; enter loop at bottom
                            	  4305: .0002:
00:00008084 225A            	  4306: 	move.l	(a2)+,a1							; a1 = address of breakpoint
00:00008086 3298            	  4307: 	move.w	(a0)+,(a1)						; copy instruction word back to code
                            	  4308: .0003:
00:00008088 51C8FFFA        	  4309: 	dbra		d0,.0002
00:0000808C 4CDF0701        	  4310: 	movem.l	(a7)+,d0/a0/a1/a2			; restore regs
                            	  4311: .0001:
00:00008090 4E75            	  4312: 	rts	
                            	  4313: 
                            	  4314: ;------------------------------------------------------------------------------
                            	  4315: ; ArmAllBreakpoints, used when entering the monitor.
                            	  4316: ;------------------------------------------------------------------------------
                            	  4317: 
                            	  4318: ArmAllBreakpoints:
00:00008092 48E780E0        	  4319: 	movem.l		d0/a0/a1/a2,-(a7)			; stack some regs
00:00008096 303900040202    	  4320: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
00:0000809C 0C400008        	  4321: 	cmpi.w		#numBreakpoints,d0		; is the number valid?
00:000080A0 641E            	  4322: 	bhs.s			.0001
00:000080A2 45F900040220    	  4323: 	lea				Breakpoints,a2				; a2 = pointer to breakpoint address table
00:000080A8 41F900040280    	  4324: 	lea				BreakpointWords,a0		; a0 = pointer to instruction word table
00:000080AE 6008            	  4325: 	bra.s			.0003									; enter loop at bottom
                            	  4326: .0002:
00:000080B0 225A            	  4327: 	move.l		(a2)+,a1							; a1 = address of breakpoint
00:000080B2 3091            	  4328: 	move.w		(a1),(a0)							; copy instruction word to table
00:000080B4 30FC4E43        	  4329: 	move.w		#$4E43,(a0)+					; set instruction = TRAP3
                            	  4330: .0003:
00:000080B8 51C8FFF6        	  4331: 	dbra			d0,.0002
00:000080BC 4CDF0701        	  4332: 	movem.l		(a7)+,d0/a0/a1/a2			; restore regs
                            	  4333: .0001:
00:000080C0 4E75            	  4334: 	rts	
                            	  4335: 
                            	  4336: ;------------------------------------------------------------------------------
                            	  4337: ;------------------------------------------------------------------------------
                            	  4338: 
                            	  4339: ArmBreakpoint:
00:000080C2 48E7E0E0        	  4340: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
00:000080C6 303900040202    	  4341: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
00:000080CC 0C400008        	  4342: 	cmpi.w		#numBreakpoints,d0		; check if too many
00:000080D0 645A            	  4343: 	bhs.s			.0001
00:000080D2 527900040202    	  4344: 	addi.w		#1,NumSetBreakpoints	; increment number of breakpoints
00:000080D8 2400            	  4345: 	move.l		d0,d2
00:000080DA 6100EE64        	  4346: 	bsr				ignBlanks
00:000080DE 6100F10A        	  4347: 	bsr				GetHexNumber
00:000080E2 6748            	  4348: 	beq.s			.0001									; was there an address?
00:000080E4 08010000        	  4349: 	btst			#0,d1									; address value must be even
00:000080E8 6642            	  4350: 	bne.s			.0001
                            	  4351: 	; See if the breakpoint is in the table already
00:000080EA 43F900040220    	  4352: 	lea				Breakpoints,a1				; a1 points to breakpoint table
00:000080F0 343C0007        	  4353: 	move.w		#numBreakpoints-1,d2
                            	  4354: .0002:
00:000080F4 B299            	  4355: 	cmp.l			(a1)+,d1
00:000080F6 673A            	  4356: 	beq.s			.0003									; breakpoint is in table already
00:000080F8 51CAFFFA        	  4357: 	dbra			d2,.0002
                            	  4358: 	; Add breakpoint to table
                            	  4359: 	; Search for empty entry
00:000080FC 43F900040220    	  4360: 	lea				Breakpoints,a1				; a1 = pointer to breakpoint address table
00:00008102 4242            	  4361: 	clr.w			d2										; d2 = count
                            	  4362: .0006:
00:00008104 4A91            	  4363: 	tst.l			(a1)									; is the entry empty?
00:00008106 670C            	  4364: 	beq.s			.0005									; branch if found empty entry
00:00008108 5889            	  4365: 	lea				4(a1),a1							; point to next entry
00:0000810A 5242            	  4366: 	addi.w		#1,d2									; increment count
00:0000810C 0C420008        	  4367: 	cmpi.w		#numBreakpoints,d2		; safety: check against max number
00:00008110 65F2            	  4368: 	blo.s			.0006
00:00008112 6018            	  4369: 	bra.s			.0001									; what? no empty entries found, table corrupt?
                            	  4370: .0005:
00:00008114 E542            	  4371: 	asl.w			#2,d2									; d2 = long word index
00:00008116 23812000        	  4372: 	move.l		d1,(a1,d2.w)					; move breakpoint address to table
00:0000811A 2441            	  4373: 	move.l		d1,a2
00:0000811C E24A            	  4374: 	lsr.w			#1,d2									; d2 = word index
                            	  4375: .0004:
00:0000811E 43F900040280    	  4376: 	lea				BreakpointWords,a1
00:00008124 33922000        	  4377: 	move.w		(a2),(a1,d2.w)				; copy instruction word to table
00:00008128 34BC4E43        	  4378: 	move.w		#$4E43,(a2)						; replace word with TRAP3
                            	  4379: .0001:
00:0000812C 4CDF0707        	  4380: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
00:00008130 4E75            	  4381: 	rts
                            	  4382: .0003:
00:00008132 2469FFFC        	  4383: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
00:00008136 0C524E43        	  4384: 	cmpi.w		#$4E43,(a2)						; see if breakpoint already armed
00:0000813A 67F0            	  4385: 	beq.s			.0001
00:0000813C D482            	  4386: 	asl.l			#1,d2									; d2 = word index
00:0000813E 60DE            	  4387: 	bra.s			.0004
                            	  4388: 
                            	  4389: 
                            	  4390: ;------------------------------------------------------------------------------
                            	  4391: ;------------------------------------------------------------------------------
                            	  4392: 
                            	  4393: DisarmBreakpoint:
00:00008140 48E7E0E0        	  4394: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
00:00008144 303900040202    	  4395: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
00:0000814A 0C400008        	  4396: 	cmpi.w		#numBreakpoints,d0		; check if too many
00:0000814E 623E            	  4397: 	bhi.s			.0001
00:00008150 2400            	  4398: 	move.l		d0,d2
00:00008152 6100EDEC        	  4399: 	bsr				ignBlanks
00:00008156 6100F092        	  4400: 	bsr				GetHexNumber
00:0000815A 6732            	  4401: 	beq.s			.0001									; was there an address?
00:0000815C 08010000        	  4402: 	btst			#0,d1									; address value must be even
00:00008160 662C            	  4403: 	bne.s			.0001
                            	  4404: 	; See if the breakpoint is in the table already
00:00008162 43F900040220    	  4405: 	lea				Breakpoints,a1				; a1 points to breakpoint table
00:00008168 5342            	  4406: 	subi.w		#1,d2
                            	  4407: .0002:
00:0000816A B299            	  4408: 	cmp.l			(a1)+,d1
00:0000816C 6706            	  4409: 	beq.s			.0003									; breakpoint is in table already
00:0000816E 51CAFFFA        	  4410: 	dbra			d2,.0002
00:00008172 601A            	  4411: 	bra				.0001									; breakpoint was not in table
                            	  4412: .0003:
                            	  4413: 	; Remove breakpoint from table
00:00008174 537900040202    	  4414: 	subi.w		#1,NumSetBreakpoints	; decrement number of breakpoints
00:0000817A 2469FFFC        	  4415: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
00:0000817E 42A9FFFC        	  4416: 	clr.l			-4(a1)								; empty out breakpoint
00:00008182 43F900040280    	  4417: 	lea				BreakpointWords,a1
00:00008188 D482            	  4418: 	asl.l			#1,d2									; d2 = word index
00:0000818A 34B12000        	  4419: 	move.w		(a1,d2.w),(a2)				; copy instruction from table back to code
                            	  4420: .0001:
00:0000818E 4CDF0707        	  4421: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
00:00008192 4E75            	  4422: 	rts
                            	  4423: 
                            	  4424: ;------------------------------------------------------------------------------
                            	  4425: ;------------------------------------------------------------------------------
                            	  4426: 
                            	  4427: ListBreakpoints:
00:00008194 6100D870        	  4428: 	bsr			CRLF
00:00008198 343C0008        	  4429: 	move.w	#numBreakpoints,d2
00:0000819C 43F900040220    	  4430: 	lea			Breakpoints,a1
                            	  4431: .0001:
00:000081A2 2219            	  4432: 	move.l	(a1)+,d1
00:000081A4 6100F61E        	  4433: 	bsr			DisplayTetra
00:000081A8 6100D85C        	  4434: 	bsr			CRLF
00:000081AC 51CAFFF4        	  4435: 	dbra		d2,.0001
00:000081B0 6000E76E        	  4436: 	bra			Monitor
                            	  4437: 
                            	  4438: ;------------------------------------------------------------------------------
                            	  4439: ;------------------------------------------------------------------------------
                            	  4440: 
                            	  4441: ClearBreakpointList:
00:000081B4 343C0008        	  4442: 	move.w	#numBreakpoints,d2
00:000081B8 43F900040220    	  4443: 	lea			Breakpoints,a1
                            	  4444: .0001:
00:000081BE 4299            	  4445: 	clr.l		(a1)+
00:000081C0 51CAFFFC        	  4446: 	dbra		d2,.0001
00:000081C4 4E75            	  4447: 	rts
                            	  4448: 
                            	  4449: ;------------------------------------------------------------------------------
                            	  4450: ; SendMsg
                            	  4451: ; 00100xy0
                            	  4452: ;
                            	  4453: ; Parameters:
                            	  4454: ;		d1 = target core number
                            	  4455: ;		d2 = argument 1
                            	  4456: ;		d3 = argument 2
                            	  4457: ;		d4 = argument 3
                            	  4458: ;
                            	  4459: ;------------------------------------------------------------------------------
                            	  4460: 
                            	  4461: SendMsg:
00:000081C6 48E70440        	  4462: 	movem.l	d5/a1,-(a7)
00:000081CA E149            	  4463: 	lsl.w		#8,d1
00:000081CC 4E7A5FE0        	  4464: 	movec		coreno,d5
00:000081D0 E94D            	  4465: 	lsl.w		#4,d5
00:000081D2 8245            	  4466: 	or.w		d5,d1
00:000081D4 43F900100000    	  4467: 	lea			$00100000,a1
00:000081DA 4AB11000        	  4468: 	tst.l		0(a1,d1.w)
00:000081DE 661C            	  4469: 	bne			.msgFull
00:000081E0 4E7A5FE0        	  4470: 	movec		coreno,d5
00:000081E4 23851000        	  4471: 	move.l	d5,0(a1,d1.w)
00:000081E8 23821004        	  4472: 	move.l	d2,4(a1,d1.w)
00:000081EC 23831008        	  4473: 	move.l	d3,8(a1,d1.w)
00:000081F0 2384100C        	  4474: 	move.l	d4,12(a1,d1.w)
00:000081F4 4CDF0220        	  4475: 	movem.l	(a7)+,d5/a1
00:000081F8 7200            	  4476: 	moveq		#0,d1
00:000081FA 4E75            	  4477: 	rts
                            	  4478: .msgFull:
00:000081FC 4CDF0220        	  4479: 	movem.l	(a7)+,d5/a1
00:00008200 72FF            	  4480: 	moveq		#-1,d1
00:00008202 4E75            	  4481: 	rts
                            	  4482: 
                            	  4483: ;------------------------------------------------------------------------------
                            	  4484: ; ReceiveMsg
                            	  4485: ;		Scan the message table for messages and dispatch them.
                            	  4486: ; 00100xy0
                            	  4487: ;
                            	  4488: ; Parameters:
                            	  4489: ;------------------------------------------------------------------------------
                            	  4490: 
                            	  4491: ReceiveMsg:
00:00008204 48E77F40        	  4492: 	movem.l		d1/d2/d3/d4/d5/d6/d7/a1,-(a7)
00:00008208 43F900100000    	  4493: 	lea				$00100000,a1
00:0000820E 4E7A5FE0        	  4494: 	movec			coreno,d5
00:00008212 E14D            	  4495: 	lsl.w			#8,d5
00:00008214 7C02            	  4496: 	moveq			#2,d6
                            	  4497: .nextCore:
00:00008216 3E06            	  4498: 	move.w		d6,d7
00:00008218 E94F            	  4499: 	lsl.w			#4,d7
00:0000821A DE45            	  4500: 	add.w			d5,d7
00:0000821C 4AB17000        	  4501: 	tst.l			0(a1,d7.w)			; Is there a message from core d6?
00:00008220 6716            	  4502: 	beq.s			.noMsg
00:00008222 22317000        	  4503: 	move.l		0(a1,d7.w),d1
00:00008226 24317004        	  4504: 	move.l		4(a1,d7.w),d2
00:0000822A 26317008        	  4505: 	move.l		8(a1,d7.w),d3
00:0000822E 2831700C        	  4506: 	move.l		12(a1,d7.w),d4
00:00008232 42B17000        	  4507: 	clr.l			0(a1,d7.w)			; indicate message was received
00:00008236 610E            	  4508: 	bsr				DispatchMsg
                            	  4509: .noMsg:
00:00008238 5246            	  4510: 	addq			#1,d6
00:0000823A BC7C0009        	  4511: 	cmp.w			#9,d6
00:0000823E 63D6            	  4512: 	bls				.nextCore
00:00008240 4CDF02FE        	  4513: 	movem.l		(a7)+,d1/d2/d3/d4/d5/d6/d7/a1
00:00008244 4E75            	  4514: 	rts
                            	  4515: 
                            	  4516: ;------------------------------------------------------------------------------
                            	  4517: ;------------------------------------------------------------------------------
                            	  4518: 
                            	  4519: DispatchMsg:
00:00008246 4E75            	  4520: 	rts
                            	  4521: 
                            	  4522: ;------------------------------------------------------------------------------
                            	  4523: ; Trap #15, function 39 - convert floating-point to string and display
                            	  4524: ;
                            	  4525: ; Parameters
                            	  4526: ;		a1 = pointer to buffer
                            	  4527: ;		fp0 = number to print
                            	  4528: ;		d1 = width of print field
                            	  4529: ;		d2 = precision
                            	  4530: ;		d3 = 'E' or 'e'
                            	  4531: ;------------------------------------------------------------------------------
                            	  4532: 
                            	  4533: prtflt:
00:00008248 4E52FFD0        	  4534: 	link a2,#-48
00:0000824C 2F7900040098002C	  4535: 	move.l _canary,44(sp)
00:00008254 48D7074F        	  4536: 	movem.l d0/d1/d2/d3/d6/a0/a1/a2,(sp)
00:00008258 F22F68000020    	  4537: 	fmove.x fp0,32(sp)
00:0000825E 2049            	  4538: 	move.l a1,a0						; a0 = pointer to buffer to use
00:00008260 13C100040508    	  4539: 	move.b d1,_width
00:00008266 23C200040514    	  4540: 	move.l d2,_precision
00:0000826C 13C30004050C    	  4541: 	move.b d3,_E
00:00008272 6100F2CC        	  4542: 	bsr _FloatToString
00:00008276 6100DA40        	  4543: 	bsr DisplayString
00:0000827A F22F48000020    	  4544: 	fmove.x 32(sp),fp0
00:00008280 4CD7074F        	  4545: 	movem.l (sp),d0/d1/d2/d3/d6/a0/a1/a2
00:00008284 A2AF0003002C    	  4546: 	cchk 44(sp)
00:0000828A 4E5A            	  4547: 	unlk a2
00:0000828C 4E75            	  4548: 	rts
                            	  4549: 
                            	  4550: T15FloatToString:
00:0000828E 4E52FFD4        	  4551: 	link a2,#-44
00:00008292 48D7034F        	  4552: 	movem.l d0/d1/d2/d3/d6/a0/a1,(sp)
00:00008296 F22F6800001C    	  4553: 	fmove.x fp0,28(sp)
00:0000829C 2049            	  4554: 	move.l a1,a0						; a0 = pointer to buffer to use
00:0000829E 13C100040508    	  4555: 	move.b d1,_width
00:000082A4 23C200040514    	  4556: 	move.l d2,_precision
00:000082AA 13C30004050C    	  4557: 	move.b d3,_E
00:000082B0 6100F28E        	  4558: 	bsr _FloatToString
00:000082B4 F22F4800001C    	  4559: 	fmove.x 28(sp),fp0
00:000082BA 4CD7034F        	  4560: 	movem.l (sp),d0/d1/d2/d3/d6/a0/a1
00:000082BE 4E5A            	  4561: 	unlk a2
00:000082C0 4E75            	  4562: 	rts
                            	  4563: 
                            	  4564: ;==============================================================================
                            	  4565: ; Parameters:
                            	  4566: ;		d7 = device number
                            	  4567: ;		d6 = function number
                            	  4568: ;		d0 to d5 = arguments
                            	  4569: ;==============================================================================
                            	  4570: 
                            	  4571: io_trap:
00:000082C2 0C070002        	  4572: 	cmpi.b #2,d7							; make sure legal device
00:000082C6 621E            	  4573: 	bhi.s .0002
00:000082C8 4A07            	  4574: 	tst.b d7
00:000082CA 6B1A            	  4575: 	bmi.s .0002
00:000082CC 48E70180        	  4576: 	movem.l d7/a0,-(a7)
00:000082D0 CEFC0040        	  4577: 	mulu #DCB_SIZE,d7					; index to DCB
00:000082D4 207C00040A00    	  4578: 	move.l #null_dcb,a0
00:000082DA 20707018        	  4579: 	move.l DCB_CMDPROC(a0,d7.w),a0
00:000082DE 4E90            	  4580: 	jsr (a0)
00:000082E0 4CDF0180        	  4581: 	movem.l (a7)+,d7/a0
00:000082E4 4E73            	  4582: 	rte
                            	  4583: .0002:
00:000082E6 7020            	  4584: 	moveq #E_BadDevNum,d0
00:000082E8 4E73            	  4585: 	rte
                            	  4586: 
                            	  4587: ;==============================================================================
                            	  4588: ; Output a character to the current output device.
                            	  4589: ;==============================================================================
                            	  4590: 
                            	  4591: OutputChar:
00:000082EA 48E70300        	  4592: 	movem.l d6/d7,-(a7)
00:000082EE 7E00            	  4593: 	clr.l d7
00:000082F0 1E39000400A8    	  4594: 	move.b OutputDevice,d7		; d7 = output device
00:000082F6 3C3C0002        	  4595: 	move.w #DEV_PUTCHAR,d6		; d6 = function
00:000082FA 4E40            	  4596: 	trap #0
00:000082FC 4CDF00C0        	  4597: 	movem.l (a7)+,d6/d7
00:00008300 4E75            	  4598: 	rts
                            	  4599: 
00:00008302 0C390001000400A8	  4600: 	cmpi.b #1,OutputDevice	; stdout
00:0000830A 6604            	  4601: 	bne .0001
00:0000830C 6000D74A        	  4602: 	bra DisplayChar
                            	  4603: .0001:
00:00008310 0C390002000400A8	  4604: 	cmpi.b #2,OutputDevice
00:00008318 6604            	  4605: 	bne .0003
00:0000831A 6000F9E8        	  4606: 	bra	SerialPutChar
                            	  4607: .0003:
00:0000831E 4E75            	  4608: 	rts
                            	  4609: 
                            	  4610: ;------------------------------------------------------------------------------
                            	  4611: ;------------------------------------------------------------------------------
                            	  4612: 
                            	  4613: InitIRQ:
00:00008320 7006            	  4614: 	moveq		#6,d0
00:00008322 41FAE190        	  4615: 	lea			KeybdIRQ,a0
00:00008326 610C            	  4616: 	bsr			InstallIRQ
00:00008328 41FA004E        	  4617: 	lea			TickIRQ,a0
00:0000832C 6106            	  4618: 	bsr			InstallIRQ
00:0000832E 7003            	  4619: 	moveq		#3,d0
00:00008330 41FAFA7A        	  4620: 	lea			SerialIRQ,a0
                            	  4621: 	; fall through
                            	  4622: 
                            	  4623: ;------------------------------------------------------------------------------
                            	  4624: ; Install an IRQ handler.
                            	  4625: ;
                            	  4626: ; Parameters:
                            	  4627: ;		a0 = pointer to bucket containing vector
                            	  4628: ;		d0 = vector (64 to 255)
                            	  4629: ; Returns:
                            	  4630: ;		d0 = 0 if successfully added, otherwise E_NotAlloc
                            	  4631: ;		nf = 0, zf = 1 if successfully added, otherwise nf = 1, zf = 0
                            	  4632: ;------------------------------------------------------------------------------
                            	  4633: 
                            	  4634: InstallIRQ:
00:00008334 48E70060        	  4635: 	movem.l a1/a2,-(a7)				; save working register
00:00008338 4A90            	  4636: 	tst.l (a0)								; link field must be NULL
00:0000833A 6634            	  4637: 	bne.s .0003
00:0000833C 0C400040        	  4638: 	cmpi.w #64,d0							; is vector in range (64 to 255)?
00:00008340 652E            	  4639: 	blo.s .0003
00:00008342 0C4000FF        	  4640: 	cmpi.w #255,d0
00:00008346 6228            	  4641: 	bhi.s .0003
00:00008348 45F80400        	  4642: 	lea	irq_list_tbl,a2				; a2 points to installed IRQ list
00:0000834C E748            	  4643: 	lsl.w	#3,d0								; multiply by 2 long words
00:0000834E 22720000        	  4644: 	move.l (a2,d0.w),a1				; get first link
00:00008352 45F20000        	  4645: 	lea (a2,d0.w),a2					; 
                            	  4646: .0002:
00:00008356 B1C9            	  4647: 	cmpa.l a1,a0							; installed already?
00:00008358 6716            	  4648: 	beq.s .0003
00:0000835A B2FC0000        	  4649: 	cmpa.l #0,a1							; is link NULL?
00:0000835E 6706            	  4650: 	beq.s .0001
00:00008360 2449            	  4651: 	move.l a1,a2							; save previous link
00:00008362 2251            	  4652: 	move.l (a1),a1						; get next link
00:00008364 60F0            	  4653: 	bra .0002
                            	  4654: .0001:
00:00008366 2488            	  4655: 	move.l a0,(a2)						; set link
00:00008368 225F245F        	  4656: 	movem.l (a7)+,a1/a2
00:0000836C 7000            	  4657: 	moveq #E_Ok,d0
00:0000836E 4E75            	  4658: 	rts
                            	  4659: .0003:
00:00008370 225F245F        	  4660: 	movem.l (a7)+,a1/a2
00:00008374 7009            	  4661: 	moveq #E_NotAlloc,d0			; return failed to add
00:00008376 4E75            	  4662: 	rts
                            	  4663: 
                            	  4664: ;------------------------------------------------------------------------------
                            	  4665: ; TickIRQ
                            	  4666: ; - this IRQ is processed by all cores.
                            	  4667: ; - reset the edge circuit.
                            	  4668: ; - an IRQ live indicator is updated on the text screen for the core
                            	  4669: ;------------------------------------------------------------------------------
                            	  4670: 
                            	  4671: TickIRQ:
00:00008378 46FC2600        	  4672: 	move.w #$2600,sr					; disable lower level IRQs
00:0000837C 48E77080        	  4673: 	movem.l	d1/d2/d3/a0,-(a7)
00:00008380 13FC0001000400A0	  4674: 	move.b #1,IRQFlag					; tick interrupt indicator in local memory
00:00008388 4E7A1FE0        	  4675: 	movec	coreno,d1						; d1 = core number
00:0000838C 2601            	  4676: 	move.l d1,d3
                            	  4677: 	if (SCREEN_FORMAT==1)
00:0000838E E583            	  4678: 		asl.l #2,d3								; 4 bytes per text cell
                            	  4679: 	else
                            	  4680: 		asl.l #3,d3								; 8 bytes per text cell
                            	  4681: 	endif
00:00008390 23FC1D000000FD09	  4682: 	move.l #$1D000000,PLIC+$14	; reset edge sense circuit
00:00008398 0014
00:0000839A 41F9FD0000C8    	  4683: 	lea $FD0000C8,a0					; display field address
00:000083A0 24303004        	  4684: 	move.l 4(a0,d3.w),d2			; get char from screen
                            	  4685: ;	rol.l #8,d2								; extract char field
                            	  4686: ;	clr.b d2									; clear char field
                            	  4687: ;	addi.b #'0',d1						; binary to ascii core number
                            	  4688: ;	or.b	d1,d2								; insert core number
                            	  4689: ;	ror.l #8,d2								; reposition to proper place
                            	  4690: ;	addi.w #1,d2							; flashy colors
00:000083A4 5282            	  4691: 	addi.l #$0001,d2
00:000083A6 21823004        	  4692: 	move.l d2,4(a0,d3.w)			; update onscreen IRQ flag
00:000083AA 6100FE58        	  4693: 	bsr	ReceiveMsg
00:000083AE 4CDF010E        	  4694: 	movem.l	(a7)+,d1/d2/d3/a0
00:000083B2 4E73            	  4695: 	rte
                            	  4696: 
                            	  4697: ;------------------------------------------------------------------------------
                            	  4698: ;------------------------------------------------------------------------------
                            	  4699: 
                            	  4700: irq3_rout:
                            	  4701: ;	movem.l	d0/d1/a0/a1,-(a7)
                            	  4702: ;	lea			InstalledIRQ+8*4*3,a0
                            	  4703: ;	bra			irq_rout
                            	  4704: 
                            	  4705: irq6_rout:
                            	  4706: ;	movem.l	d0/d1/a0/a1,-(a7)
                            	  4707: ;	lea			InstalledIRQ+8*4*6,a0
                            	  4708: irq_rout:
00:000083B4 7007            	  4709: 	moveq		#7,d0
                            	  4710: .nextHandler:
00:000083B6 2258            	  4711: 	move.l	(a0)+,a1
00:000083B8 6706            	  4712: 	beq.s		.0003
00:000083BA 4E91            	  4713: 	jsr			(a1)
00:000083BC 4A81            	  4714: 	tst.l		d1								; was IRQ handled?
00:000083BE 6B04            	  4715: 	bmi.s		.0002							; first one to return handled quits loop
                            	  4716: .0003:
00:000083C0 51C8FFF4        	  4717: 	dbra		d0,.nextHandler
                            	  4718: .0002:
00:000083C4 4CDF0303        	  4719: 	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  4720: 
                            	  4721: ; Load head of list into an address register, then branch to a generic routine.
                            	  4722: 
                            	  4723: ;	rept 192
                            	  4724: ;	macIRQ_proc_label REPTN
                            	  4725: ;	movem.l a0/a1,-(a7)
                            	  4726: ;	move.l irq_list_tbl+REPTN*4,a1	; get the head of the list
                            	  4727: ;	jmp irq_proc_generic
                            	  4728: ;	endr
                            	  4729: 
                            	  4730: irq_proc_generic:
                            	  4731: .0003:
00:000083C8 20690004        	  4732: 	move.l 4(a1),a0									; a0 = vector
00:000083CC B0FC0000        	  4733: 	cmpa.l #0,a0										; ugh. move to address does not set flags
00:000083D0 6706            	  4734: 	beq.s .0001											; valid vector?
00:000083D2 4E90            	  4735: 	jsr (a0)												; call the interrupt routine
00:000083D4 4A81            	  4736: 	tst.l d1												; IRQ handled?
00:000083D6 6B08            	  4737: 	bmi.s .0002											
                            	  4738: .0001:
00:000083D8 2251            	  4739: 	move.l (a1),a1
00:000083DA B0FC0000        	  4740: 	cmpa.l #0,a0										; end of list?
00:000083DE 66E8            	  4741: 	bne.s .0003
                            	  4742: .0002:
00:000083E0 205F225F        	  4743: 	movem.l (a7)+,a0/a1
00:000083E4 4E73            	  4744: 	rte 
                            	  4745: 
                            	  4746: SpuriousIRQ:
00:000083E6 4E73            	  4747: 	rte
                            	  4748: 
                            	  4749: ;	bsr			KeybdIRQ
                            	  4750: ;	tst.l		d1								; handled by KeybdIRQ?
                            	  4751: ;	bmi.s		.0002							; if yes, go return
                            	  4752: ;.0001:
                            	  4753: ;	move.l	#$1D000000,PLIC+$14	; reset edge sense circuit
                            	  4754: ;	move.l	TextScr,a0				; a0 = screen address
                            	  4755: ;	addi.l	#1,40(a0)					; update onscreen IRQ flag
                            	  4756: ;.0002:	
                            	  4757: ;	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  4758: ;	rte
                            	  4759: 
                            	  4760: nmi_rout:
00:000083E8 48E7C080        	  4761: 	movem.l	d0/d1/a0,-(a7)
00:000083EC 123C004E        	  4762: 	move.b	#'N',d1
00:000083F0 6100FEF8        	  4763: 	bsr			OutputChar
00:000083F4 4CDF0103        	  4764: 	movem.l	(a7)+,d0/d1/a0		; return
00:000083F8 4E73            	  4765: 	rte
                            	  4766: 
                            	  4767: addr_err:
00:000083FA 544F            	  4768: 	addq		#2,sp						; get rid of sr
00:000083FC 221F            	  4769: 	move.l	(sp)+,d1				; pop exception address
00:000083FE 6100F3C4        	  4770: 	bsr			DisplayTetra		; and display it
00:00008402 43FA00A6        	  4771: 	lea			msgAddrErr,a1	; followed by message
00:00008406 6100D8C6        	  4772: 	bsr			DisplayStringCRLF
                            	  4773: .0001:
00:0000840A 60FE            	  4774: 	bra			.0001
00:0000840C 6000E512        	  4775: 	bra			Monitor
                            	  4776: 	
                            	  4777: brdisp_trap:
00:00008410 48F9FFFF00040100	  4778: 	movem.l	d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
00:00008418 33DF00040140    	  4779: 	move.w	(a7)+,Regsave+$40
00:0000841E 23DF00040144    	  4780: 	move.l	(a7)+,Regsave+$44
00:00008424 2E7C00040FFC    	  4781: 	move.l	#$40FFC,a7			; reset stack pointer
00:0000842A 46FC2500        	  4782: 	move.w	#$2500,sr				; enable interrupts
00:0000842E 43FA0099        	  4783: 	lea			msg_bad_branch_disp,a1
00:00008432 6100D884        	  4784: 	bsr			DisplayString
00:00008436 6100F384        	  4785: 	bsr			DisplaySpace
00:0000843A 223900040144    	  4786: 	move.l	Regsave+$44,d1	; exception address
00:00008440 6100F382        	  4787: 	bsr			DisplayTetra		; and display it
                            	  4788: ;	move.l	(sp)+,d1				; pop format word 68010 mode only
00:00008444 6000ECDA        	  4789: 	bra			cmdDumpRegs
                            	  4790: 
                            	  4791: illegal_trap:
00:00008448 544F            	  4792: 	addq		#2,sp						; get rid of sr
00:0000844A 221F            	  4793: 	move.l	(sp)+,d1				; pop exception address
00:0000844C 6100F376        	  4794: 	bsr			DisplayTetra		; and display it
00:00008450 43FA0065        	  4795: 	lea			msg_illegal,a1	; followed by message
00:00008454 6100D862        	  4796: 	bsr			DisplayString
                            	  4797: .0001:
00:00008458 60FE            	  4798: 	bra			.0001
00:0000845A 6000E4C4        	  4799: 	bra			Monitor
                            	  4800: 	
                            	  4801: io_irq:
00:0000845E 544F            	  4802: 	addq #2,sp
00:00008460 221F            	  4803: 	move.l (sp)+,d1
00:00008462 6100F360        	  4804: 	bsr DisplayTetra
00:00008466 43FA0083        	  4805: 	lea msg_io_access,a1
00:0000846A 6100D84C        	  4806: 	bsr DisplayString
00:0000846E 6000ECB0        	  4807: 	bra cmdDumpRegs
                            	  4808: 
                            	  4809: ; -----------------------------------------------------------------------------
                            	  4810: ; -----------------------------------------------------------------------------
                            	  4811: 
                            	  4812: msg_start:
00:00008472 46656D74696B6920	  4813: 	dc.b	"Femtiki rf68k Multi-core OS Starting",LF,CR,0
00:0000847A 726636386B204D75
00:00008482 6C74692D636F7265
00:0000848A 204F532053746172
00:00008492 74696E67
00:00008496 0A
00:00008497 0D
00:00008498 00
                            	  4814: ;	dc.b	"rf68k System Starting",CR,LF,0
                            	  4815: msg_core_start:
00:00008499 20636F7265207374	  4816: 	dc.b	" core starting",CR,LF,0
00:000084A1 617274696E67
00:000084A7 0D
00:000084A8 0A
00:000084A9 00
                            	  4817: msgAddrErr
00:000084AA 2061646472657373	  4818: 	dc.b	" address err",0
00:000084B2 20657272
00:000084B6 00
                            	  4819: msg_illegal:
00:000084B7 20696C6C6567616C	  4820: 	dc.b	" illegal opcode",CR,LF,0
00:000084BF 206F70636F6465
00:000084C6 0D
00:000084C7 0A
00:000084C8 00
                            	  4821: msg_bad_branch_disp:
00:000084C9 206272616E636820	  4822: 	dc.b	" branch selfref: ",0
00:000084D1 73656C667265663A
00:000084D9 20
00:000084DA 00
                            	  4823: msg_test_done:
00:000084DB 2043505520746573	  4824: 	dc.b	" CPU test done.",0
00:000084E3 7420646F6E652E
00:000084EA 00
                            	  4825: msg_io_access
00:000084EB 20756E7065726D69	  4826: 	dc.b " unpermitted access to I/O",0
00:000084F3 7474656420616363
00:000084FB 65737320746F2049
00:00008503 2F4F
00:00008505 00
                            	  4827: msgChk
00:00008506 20636865636B2066	  4828: 	dc.b " check failed",0
00:0000850E 61696C6564
00:00008513 00
                            	  4829: msgStackCanary
00:00008514 20737461636B2063	  4830: 	dc.b " stack canary overwritten",0
00:0000851C 616E617279206F76
00:00008524 6572777269747465
00:0000852C 6E
00:0000852D 00
                            	  4831: 
                            	  4832: 	even
                            	  4833: 
                            	  4834: ;-------------------------------------------------------------------------
                            	  4835: ; File HEX2DEC   HEX2DEC convert hex to decimal                   11/02/81
                            	  4836: ;
                            	  4837: ;    CONVERT BINARY TO DECIMAL  REG  D0 PUT IN ( A6) BUFFER AS ASCII
                            	  4838: 
                            	  4839: ; Shift buffer one character to left
                            	  4840: ShiftBuf:
00:0000852E 48E78028        	  4841: 	movem.l d0/a2/a4,-(a7)
00:00008532 200B            	  4842: 	move.l a3,d0
00:00008534 06800000003F    	  4843: 	addi.l #BUFSIZE,d0
                            	  4844: .0001:
00:0000853A 18EC0001        	  4845: 	move.b 1(a4),(a4)+
00:0000853E B08C            	  4846: 	cmp.l a4,d0
00:00008540 65F8            	  4847: 	blo.s .0001
00:00008542 4CDF1401        	  4848: 	movem.l (a7)+,d0/a2/a4
00:00008546 4E75            	  4849: 	rts
                            	  4850: 
                            	  4851: HEX2DEC2:
00:00008548 48E7C01C        	  4852: 	movem.l d0/d1/a3/a4/a5,-(a7)
00:0000854C 264E            	  4853: 	move.l a6,a3
00:0000854E 284E            	  4854: 	move.l a6,a4
00:00008550 2200            	  4855: 	move.l d0,d1
00:00008552 6A0A            	  4856: 	bpl.s .0001
00:00008554 4480            	  4857: 	neg.l d0										;
00:00008556 6B32            	  4858: 	bmi.s .0002									; neg and still minus, must be -tve zero
00:00008558 1CFC002D        	  4859: 	move.b #'-',(a6)+
00:0000855C 284E            	  4860: 	move.l a6,a4
                            	  4861: .0001:
00:0000855E 82FC0064        	  4862: 	divu #100,d1								; scale d1 - chop last 2 decimal digits
00:00008562 A2C10000        	  4863: 	bin2bcd d1									; convert to BCD
00:00008566 6100F288        	  4864: 	bsr BufTetra								; capture in buffer (8 digits)
00:0000856A 2200            	  4865: 	move.l d0,d1
00:0000856C A2C10000        	  4866: 	bin2bcd d1									; convert to BCD
00:00008570 6100F28A        	  4867: 	bsr BufByte									; capture last 2 digits in buffer
                            	  4868: .0004:
00:00008574 0C140030        	  4869: 	cmpi.b #'0',(a4)						; Is there a leading zero?
00:00008578 6606            	  4870: 	bne.s .0003									; No, we're done shifting
00:0000857A 61B2            	  4871: 	bsr ShiftBuf								; Shift the buffer over a character
00:0000857C 538E            	  4872: 	subq.l #1,a6								; adjust buffer pos.
00:0000857E 60F4            	  4873: 	bra.s .0004									; go check next character
                            	  4874: .0003:
00:00008580 4A14            	  4875: 	tst.b (a4)
00:00008582 6706            	  4876: 	beq.s .0002
00:00008584 0C140020        	  4877: 	cmpi.b #' ',(a4)						; is the buffer empty?
00:00008588 6606            	  4878: 	bne.s .0005
                            	  4879: .0002:
00:0000858A 18FC0030        	  4880: 	move.b #'0',(a4)+						; ensure at least a '0'
00:0000858E 2C4C            	  4881: 	move.l a4,a6
                            	  4882: .0005:
00:00008590 4CDF3803        	  4883: 	movem.l (a7)+,d0/d1/a3/a4/a5
00:00008594 4E75            	  4884: 	rts
                            	  4885: 
                            	  4886: HEX2DEC: 
00:00008596 48E77B00        	  4887: 	movem.l D1-D4/D6-D7,-(A7)   ; SAVE REGISTERS
00:0000859A 2E00            	  4888: 	move.l D0,D7          			; SAVE IT HERE
00:0000859C 6A08            	  4889: 	bpl.s HX2DC
00:0000859E 4487            	  4890: 	neg.l D7              			; CHANGE TO POSITIVE
00:000085A0 6B4E            	  4891: 	bmi.s HX2DC57          			; SPECIAL CASE (-0)
00:000085A2 1CFC002D        	  4892: 	move.b #'-',(A6)+      			; PUT IN NEG SIGN
                            	  4893: HX2DC:  
00:000085A6 4244            	  4894: 	clr.w D4              			; FOR ZERO SURPRESS
00:000085A8 7C0A            	  4895: 	moveq #10,D6          			; COUNTER
                            	  4896: HX2DC0:
00:000085AA 7401            	  4897:   moveq #1,D2           			; VALUE TO SUB
00:000085AC 2206            	  4898: 	move.l D6,D1          			; COUNTER
00:000085AE 5381            	  4899: 	subq.l #1,D1           			; ADJUST - FORM POWER OF TEN
00:000085B0 671A            	  4900: 	beq.s HX2DC2           			; IF POWER IS ZERO
                            	  4901: HX2DC1:
00:000085B2 3602            	  4902:   move.w D2,D3          			; D3=LOWER WORD
00:000085B4 C6FC000A        	  4903: 	mulu #10,D3
00:000085B8 4842            	  4904: 	swap D2              				; D2=UPPER WORD
00:000085BA C4FC000A        	  4905: 	mulu #10,D2
00:000085BE 4843            	  4906: 	swap D3              				; ADD UPPER TO UPPER
00:000085C0 D443            	  4907: 	add.w D3,D2
00:000085C2 4842            	  4908: 	swap D2              				; PUT UPPER IN UPPER
00:000085C4 4843            	  4909: 	swap D3              				; PUT LOWER IN LOWER
00:000085C6 3403            	  4910: 	move.w D3,D2          			; D2=UPPER & LOWER
00:000085C8 5381            	  4911: 	subq.l #1,D1
00:000085CA 66E6            	  4912: 	bne.s HX2DC1
                            	  4913: HX2DC2:
00:000085CC 7000            	  4914:   clr.l D0              			; HOLDS SUB AMT
                            	  4915: HX2DC22:
00:000085CE BE82            	  4916: 	cmp.l D2,D7
00:000085D0 6D06            	  4917:   blt.s HX2DC3           			; IF NO MORE SUB POSSIBLE
00:000085D2 5280            	  4918: 	addq.l #1,D0           			; BUMP SUBS
00:000085D4 9E82            	  4919: 	sub.l D2,D7          				; COUNT DOWN BY POWERS OF TEN
00:000085D6 60F6            	  4920: 	bra.s HX2DC22          			; DO MORE
                            	  4921: HX2DC3:
00:000085D8 4A00            	  4922:   tst.b D0              			; ANY VALUE?
00:000085DA 6604            	  4923: 	bne.s HX2DC4
00:000085DC 4A44            	  4924: 	tst.w D4              			; ZERO SURPRESS
00:000085DE 6708            	  4925: 	beq.s HX2DC5
                            	  4926: HX2DC4:
00:000085E0 06000030        	  4927:   addi.b #$30,D0         		; BINARY TO ASCII
00:000085E4 1CC0            	  4928: 	move.b D0,(A6)+       			; PUT IN BUFFER
00:000085E6 1800            	  4929: 	move.b D0,D4          			; MARK AS NON ZERO SURPRESS
                            	  4930: HX2DC5:
00:000085E8 5386            	  4931:   subq.l #1,D6           			; NEXT POWER
00:000085EA 66BE            	  4932: 	bne.s HX2DC0
00:000085EC 4A44            	  4933: 	tst.w D4              			; SEE IF ANYTHING PRINTED
00:000085EE 6604            	  4934: 	bne.s HX2DC6
                            	  4935: HX2DC57:
00:000085F0 1CFC0030        	  4936:  move.b #'0',(A6)+      			; PRINT AT LEST A ZERO
                            	  4937: HX2DC6:
00:000085F4 4CDF00DE        	  4938: 	movem.l (A7)+,D1-D4/D6-D7 ; RESTORE REGISTERS
00:000085F8 4E75            	  4939:   rts                      	; END OF ROUTINE
                            	  4940: 
                            	  4941: 
                            	  4942: PNT4HX:
                            	  4943: PNT4HEX:
00:000085FA 6000F1FA        	  4944: 	bra BufWyde
                            	  4945: PNT6HX:
00:000085FE 4840            	  4946: 	swap d0
00:00008600 6100F1FA        	  4947: 	bsr BufByte
00:00008604 4840            	  4948: 	swap d0
00:00008606 6000F1EE        	  4949: 	bra BufWyde
                            	  4950: PNT8HX:
00:0000860A 6000F1E4        	  4951: 	bra BufTetra
                            	  4952: 	
                            	  4953: ; FORMAT RELATIVE ADDRESS  AAAAAA+Rn
                            	  4954: ;        ENTER     D0 = VALUE
                            	  4955: ;                  A6 = STORE POINTER
                            	  4956: ;
                            	  4957: FRELADDR:
00:0000860E 48E74780        	  4958: 	movem.l D1/D5-D7/A0,-(A7)
00:00008612 41F900040880    	  4959: 	lea OFFSET,A0
00:00008618 7EFF            	  4960: 	moveq #-1,D7        	; D7 = DIFF. BEST FIT
00:0000861A 7C00            	  4961: 	clr.l D6            	; D6 = OFFSET POSITION
                            	  4962: FREL10:
00:0000861C 2200            	  4963:   move.l D0,D1
00:0000861E 4A90            	  4964: 	tst.l (a0)
00:00008620 670C            	  4965: 	beq.s FREL15         	; ZERO OFFSET
00:00008622 9290            	  4966: 	sub.l (a0),d1      		; D1 = DIFF.
00:00008624 6B08            	  4967: 	bmi.s FREL15         	; NO FIT
00:00008626 B287            	  4968: 	cmp.l D7,D1
00:00008628 6404            	  4969: 	bcc.s FREL15         	; OLD FIT BETTER
00:0000862A 2E01            	  4970: 	move.l D1,D7        	; D7 = NEW BEST FIT
00:0000862C 2A06            	  4971: 	move.l D6,D5        	; D5 = POSITION
                            	  4972: FREL15:
00:0000862E 5888            	  4973:   addq.l #4,A0
00:00008630 5286            	  4974: 	addq.l #1,D6
00:00008632 0C460008        	  4975: 	cmpi.w #8,D6
00:00008636 66E4            	  4976: 	bne.s FREL10         	; MORE OFFSETS TO CHECK
00:00008638 4A87            	  4977: 	tst.l D7
00:0000863A 6B1E            	  4978: 	bmi.s FREL25         	; NO FIT
00:0000863C 4A46            	  4979: 	tst D6
00:0000863E 6608            	  4980: 	bne.s FREL20
00:00008640 4AB900040880    	  4981: 	tst.l OFFSET
00:00008646 6712            	  4982: 	beq.s FREL25         	; R0 = 000000; NO FIT
                            	  4983: FREL20:
00:00008648 2007            	  4984:   move.l D7,D0
00:0000864A 61B2            	  4985: 	bsr	PNT6HX         		; FORMAT OFFSET
00:0000864C 1CFC002B        	  4986: 	move.b #'+',(A6)+    	; +
00:00008650 1CFC0052        	  4987: 	move.b #'R',(A6)+    	; R
00:00008654 06050030        	  4988: 	addi.b #'0',D5       	; MAKE ASCII
00:00008658 600A            	  4989: 	bra.s FREL30
                            	  4990: FREL25:
00:0000865A 61A2            	  4991:   bsr	PNT6HX         	; FORMAT ADDRESS AS IS
00:0000865C 1A3C0020        	  4992: 	move.b #BLANK,D5
00:00008660 1CC5            	  4993: 	move.b D5,(A6)+     	; THREE SPACES FOR ALIGNMENT
00:00008662 1CC5            	  4994: 	move.b D5,(A6)+
                            	  4995: FREL30:
00:00008664 1CC5            	  4996:   move.b D5,(A6)+
00:00008666 4CDF01E2        	  4997: 	movem.l (A7)+,D1/D5-D7/A0
00:0000866A 4E75            	  4998: 	rts
                            	  4999: 
                            	  5000: 	include "dcode68k.x68"

Source: "dcode68k.x68"
                            	     1: ;-------------------------------------------------------------------------
                            	     2: ; File DCODE68K  68K ONE LINE DISASSEMBLER                        07/28/82
                            	     3: ;
                            	     4: ;        CALLING SEQUENCE:
                            	     5: ;   D0,D1,D2 = CODE TO BE DISASSEMBLED
                            	     6: ;   A4 = VALUE OF PROGRAM COUNTER FOR THE CODE
                            	     7: ;   A5 = POINTER TO STORE DATA (BUFSIZE = 80 ASSUMED)
                            	     8: ;        JSR       DCODE68K
                            	     9: ;
                            	    10: ;        RETURN:
                            	    11: ;   A4 = VALUE OF PROGRAM COUNTER FOR NEXT INSTRUCTION
                            	    12: ;   A5 = POINTER TO LINE AS DISASSEMBLED
                            	    13: ;   A6 = POINTER TO END OF LINE
                            	    14: ;
                            	    15: ; 01234567890123456789012345678901234567890123456789
                            	    16: ; AAAAAA FDATA.DDDDDDDDDDDDDD FOC.... FOP.....
                            	    17: ;
                            	    18: ;FDATA   =       10             DATA FIELD
                            	    19: ;FOC     =       31             OP-CODE FIELD
                            	    20: ;FOP     =       39             OPERAND FIELD
                            	    21: ;
                            	    22: ; CAUSES ORGIN MODULO 4
                            	    23: ; LONG:    macro
                            	    24: ;         .align  2
                            	    25: ;         DS.B    (;-X)&2
                            	    26: ;         endm
                            	    27: LOCVARSZ = 16
                            	    28: BUFSIZE  = 63
                            	    29: FDATA    =       10        ; OFFSET TO DATA
                            	    30: FOL      =       31        ; OFFSET TO LABEL
                            	    31: FOC      =       31        ; OFFSET TO OP-CODE (NO LABEL FIELD)
                            	    32: FOP      =       39        ; OFFSET TO OPERAND (NO LABEL FIELD)
                            	    33: 
                            	    34: 					code
                            	    35: 					even
                            	    36: X:       ;              ; BASE ADDRESS THIS MODULE
                            	    37:                                 ; LONG
                            	    38: 
                            	    39: ;  MOVEM REGISTERS TO EA
                            	    40: ;
                            	    41: ;        01001D001S......
                            	    42: ;        ..........XXXXXX       EFFECTIVE ADDRESS
                            	    43: ;        .........0......       WORD
                            	    44: ;        .........1......       LONG
                            	    45: ;        .....0..........       REGISTER TO MEMORY
                            	    46: ;        .....1..........       MEMORY TO REGISTER
                            	    47: ;
                            	    48: ;
                            	    49: IMOVEMFR:
00:0000866C 610006F8        	    50:          BSR     MOVEMS         ; SIZE
                            	    51: 
00:00008670 7C38            	    52:          MOVEQ   #$0038,D6
00:00008672 CC54            	    53:          AND.W   (A4),D6
00:00008674 0C460020        	    54:          CMPI.W  #$0020,D6
00:00008678 6706            	    55:          BEQ.S   IM7788         ; PREDECREMENT MODE
                            	    56: 
00:0000867A 7C01            	    57:          MOVEQ   #1,D6         ; D6 = INCREMENTER (BIT POSITION)
00:0000867C 7200            	    58:          MOVEQ   #0,D1         ; D1 = BIT POSITION
00:0000867E 6004            	    59:          BRA.S   IM7799
                            	    60: 
00:00008680 7CFF            	    61: IM7788:  MOVEQ   #-1,D6        ; D6 = DECREMENTER (BIT POSITION)
00:00008682 720F            	    62:          MOVEQ   #15,D1        ; D1 = BIT POSITION
00:00008684 610006F4        	    63: IM7799:  BSR     MOVEMR         ; BUILD MASK WORD
                            	    64: 
00:00008688 1CFC002C        	    65:          MOVE.B  #',',(A6)+    ; STORE COMMA
                            	    66: 
00:0000868C 5483            	    67:          ADDQ.L  #2,D3
00:0000868E 3814            	    68:          MOVE.W  (A4),D4
00:00008690 3E3C01F4        	    69:          MOVE.W  #$1F4,D7     ; CONTROL + PREDECREMENT
00:00008694 6100050E        	    70:          BSR     EEA
00:00008698 601A            	    71:          BRA.S   CS16           ; COMMON
                            	    72: 
                            	    73:          
                            	    74: 
                            	    75: ; MOVEM  EA  TO REGISTERS
                            	    76: ;
00:0000869A 610006CA        	    77: IMOVEMTR:BSR     MOVEMS         ; SIZE
00:0000869E 5483            	    78:          ADDQ.L  #2,D3
00:000086A0 3E3C07EC        	    79:          MOVE.W  #$7EC,D7     ; CONTROL + POSTINCREMENT
00:000086A4 610004FE        	    80:          BSR     EEA
                            	    81: 
00:000086A8 1CFC002C        	    82:          MOVE.B  #',',(A6)+    ; STORE COMMA
                            	    83: 
00:000086AC 7C01            	    84:          MOVEQ   #1,D6         ; D6 = BIT POSITION INCREMENTER
00:000086AE 7200            	    85:          MOVEQ   #0,D1         ; D1 = BIT POSITION
00:000086B0 610006C8        	    86:          BSR     MOVEMR
                            	    87: 
00:000086B4 606C            	    88: CS16:    BRA.S   CS15           ; COMMON
                            	    89: 
                            	    90:          
                            	    91: ISTOP:
00:000086B6 302C0002        	    92: 	move.w 2(A4),D0
00:000086BA 1CFC0023        	    93: 	move.b #'#',(A6)+    	; IMMEDIATE
00:000086BE 1CFC0024        	    94: 	move.b #'$',(A6)+    	; HEX
00:000086C2 6100FF36        	    95: 	bsr PNT4HX         		; VALUE
00:000086C6 600007C6        	    96: 	bra COMMON4
                            	    97: 
                            	    98: IMMED:   ;.align  2              ; ADD  AND  CMP #  EOR  OR  SUB
00:000086CA 6100044E        	    99: 	bsr FORMSIZE
00:000086CE 5483            	   100: 	addq.l #2,D3         	; SIZE = 4
00:000086D0 1CFC0023        	   101: 	move.b #'#',(A6)+    	; IMMEDIATE
00:000086D4 7000            	   102: 	clr.l D0
00:000086D6 302C0002        	   103: 	move.w 2(A4),D0     	; D0 = EXTENSION WORD
00:000086DA 3214            	   104: 	move.w (A4),D1
00:000086DC EC49            	   105: 	lsr.w #6,D1
00:000086DE 02410003        	   106: 	andi.w #3,D1
00:000086E2 6746            	   107: 	beq.s IMMED65        	; .BYTE
00:000086E4 0C010001        	   108: 	cmpi.b #1,D1
00:000086E8 6750            	   109: 	beq.s IMMED75        	; .WORD
00:000086EA 5483            	   110: 	addq.l #2,D3         	; .LONG    SIZE = 6
00:000086EC 202C0002        	   111: 	move.l 2(A4),D0     	; D0 = LONG EXTENSION WORD
                            	   112: 
                            	   113: IMMED45:
00:000086F0 6100FEA4        	   114: 	bsr HEX2DEC        		; DECIMAL
00:000086F4 1CC5            	   115: 	move.b D5,(A6)+     	; COMMA SEPARATOR
00:000086F6 3014            	   116: 	move (A4),D0
00:000086F8 0240003F        	   117: 	andi.w #$003F,D0
00:000086FC 0C40003C        	   118: 	cmpi.w #$003C,D0    	; DESTINATION ADDRESS MODE 111100  "SR"
00:00008700 6622            	   119: 	bne.s IMMED55        	; NOT FOUND
00:00008702 3014            	   120: 	move.w (A4),D0      	; "SR"  ILLEGAL FOR
00:00008704 02404000        	   121: 	andi.w #$4000,D0    	; ADDI   SUBI  CMPI
00:00008708 660007AE        	   122: 	bne FERROR         		; 0600   0400  0C00
00:0000870C 3214            	   123: 	move.w (A4),D1
00:0000870E 024100C0        	   124: 	andi.w #$00C0,D1
00:00008712 0C410080        	   125: 	cmpi.w #$0080,D1
00:00008716 670007A0        	   126: 	beq FERROR         		; .LONG NOT ALLOWED
00:0000871A 1CFC0053        	   127: 	move.b #'S',(A6)+    	; #,SR FOR ANDI, EORI, ORI
00:0000871E 1CFC0052        	   128: 	move.b #'R',(A6)+
                            	   129: CS15:
00:00008722 603C            	   130: 	bra.s CS14           	; COMMON
                            	   131: IMMED55:
00:00008724 6100047E        	   132: 	bsr EEA
00:00008728 6036            	   133: 	bra.s CS14           	; COMMON
                            	   134: IMMED65:
00:0000872A 2200            	   135: 	move.l D0,D1        	; D1 = XXXXXXXX........
00:0000872C E049            	   136: 	lsr.w #8,D1         	; D1 = 00000000XXXXXXXX
00:0000872E 670A            	   137: 	beq.s IMMED75
00:00008730 2200            	   138: 	move.l D0,D1
00:00008732 EE41            	   139: 	asr.w #7,D1
00:00008734 5241            	   140: 	addq.w #1,D1         ; CHECK FOR NEGATIVE
00:00008736 66000780        	   141: 	bne FERROR
                            	   142: IMMED75:
00:0000873A 48C0            	   143: 	ext.l D0
00:0000873C 60B2            	   144: 	bra.s IMMED45
                            	   145: 
                            	   146: ;  BIT   5432109876543210
                            	   147: ;        ....RRRMMM......       ; DESTINATION REGISTER MODE
                            	   148: ;        ..........MMMRRR       ; SOURCE MODE REGISTER
                            	   149: ;        0001............       ; .BYTE
                            	   150: ;        0011............       ; .WORD
                            	   151: ;        0010............       ; .LONG
                            	   152: ;
                            	   153: ; IF BYTE SIZE; DESTINATION ADDRESS DIRECT NOT ALLOWED
                            	   154:    
                            	   155: IMOVE:
00:0000873E 6000037E        	   156: 	bra IMOVEA1
                            	   157: 
                            	   158: ILINK:
00:00008742 6158            	   159: 	bsr.s FORMREGA
00:00008744 1CC5            	   160: 	move.b D5,(A6)+     ; COMMA SERARATOR
00:00008746 1CFC0023        	   161: 	move.b #'#',(A6)+
00:0000874A 302C0002        	   162: 	move.w 2(A4),D0
00:0000874E 48C0            	   163: 	ext.l D0
00:00008750 6100FE44        	   164: 	bsr HEX2DEC        	; DECIMAL DISPLACEMENT
00:00008754 60000738        	   165: 	bra COMMON4
                            	   166:          
                            	   167:          ; CLR  NEG  NEGX  NOT TST
                            	   168: FORM1:
00:00008758 610003C0        	   169: 	bsr FORMSIZE
                            	   170: ;                               ; NBCD TAS
                            	   171: FORM1A:
00:0000875C 61000446        	   172: 	bsr EEA            	; DATA ALTERABLE ONLY
                            	   173: CS14:
00:00008760 6068            	   174: 	bra.s CS13          ; COMMON
                            	   175:      
                            	   176: 
                            	   177: 				;.align  2              ; EXT  SWAP
                            	   178: FORM3:   
00:00008762 6148            	   179: 	bsr.s FORMREGD
00:00008764 6064            	   180: 	bra.s CS13           	; COMMON
                            	   181:          
                            	   182: 
                            	   183: FORM4:	;   .align  2              ; TRAP
00:00008766 1CFC0023        	   184:          MOVE.B  #'#',(A6)+
00:0000876A 3014            	   185:          MOVE.W  (A4),D0
00:0000876C 02800000000F    	   186:          ANDI.L  #$0F,D0
00:00008772 6100FE22        	   187:          BSR     HEX2DEC        ; DECIMAL
00:00008776 6052            	   188:          BRA.S   CS13           ; COMMON
                            	   189: 
                            	   190:          
                            	   191: 
                            	   192: FORM5:	;   .align  2              ; UNLNK
00:00008778 6122            	   193:          BSR.S   FORMREGA
00:0000877A 604E            	   194:          BRA.S   CS13           ; COMMON
                            	   195: 
                            	   196: ;  BIT   5432109876543210
                            	   197: ;        ....RRR.........       ; ADDRESS REGISTER
                            	   198: ;        ..........XXXXXX       ; EFFECTIVE ADDRESS
                            	   199: ;
                            	   200:          
                            	   201: 
                            	   202: FORM6A:	;  .align  2              ; LEA
00:0000877C 3E3C07E4        	   203:          MOVE.W  #$7E4,D7     ; CONTROL ADDRESSING
00:00008780 6150            	   204:          BSR.S   EEA10
                            	   205: 
00:00008782 1CC5            	   206:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   207: 
00:00008784 3814            	   208:          MOVE.W  (A4),D4
00:00008786 EF5C            	   209:          ROL.W   #7,D4
00:00008788 6112            	   210:          BSR.S   FORMREGA
00:0000878A 603E            	   211:          BRA.S   CS13           ; COMMON
                            	   212: 
                            	   213: ;  BIT   5432109876543210
                            	   214: ;        ....DDD.........       ; DATA REGISTER
                            	   215: ;        ..........XXXXXX       ; EFFECTIVE ADDRESS
                            	   216: ;
                            	   217:          
                            	   218: 
                            	   219: FORM6D:  ;.align  2              ; CHK  DIVS  DIVU  MULS  MULU
00:0000878C 3E3C0FFD        	   220:          MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:00008790 6140            	   221:          BSR.S   EEA10
                            	   222: 
00:00008792 1CC5            	   223:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   224: 
00:00008794 3814            	   225:          MOVE.W  (A4),D4
00:00008796 EF5C            	   226:          ROL.W   #7,D4
00:00008798 6112            	   227:          BSR.S   FORMREGD
00:0000879A 602E            	   228:          BRA.S   CS13           ; COMMON
                            	   229: 
00:0000879C 1CFC0041        	   230: FORMREGA:MOVE.B  #'A',(A6)+    ; FORMAT A@
00:000087A0 02040007        	   231: FORMREG5:ANDI.B  #$07,D4
00:000087A4 00040030        	   232:          ORI.B   #'0',D4
00:000087A8 1CC4            	   233:          MOVE.B  D4,(A6)+
00:000087AA 4E75            	   234:          RTS
                            	   235: 
00:000087AC 1CFC0044        	   236: FORMREGD:MOVE.B  #'D',(A6)+    ; FORMAT D@
00:000087B0 60EE            	   237:          BRA.S   FORMREG5
                            	   238: 
                            	   239: ;  BIT   5432109876543210
                            	   240: ;        ....DDD......DDD       ; DATA REGISTERS
                            	   241: ;
                            	   242:         
                            	   243: FORM7: ;  .align  2              ; EXG
00:000087B2 EF5C            	   244: 	rol.w #7,D4
00:000087B4 61F6            	   245: 	bsr.s FORMREGD
00:000087B6 1CC5            	   246: 	move.b D5,(A6)+     	; COMMA SEPARATOR
00:000087B8 3814            	   247: 	move.w (A4),D4
00:000087BA 61F0            	   248: 	bsr.s FORMREGD
00:000087BC 600C            	   249: 	bra.s CS13           	; COMMON
                            	   250: 
                            	   251: ;  BIT   5432109876543210
                            	   252: ;        ....AAA......AAA       ; ADDRESS REGISTERS
                            	   253: ;
                            	   254:          
                            	   255: FORM8:   ;.align  2              ; EXG
00:000087BE EF5C            	   256:          ROL.W   #7,D4
00:000087C0 61DA            	   257:          BSR.S   FORMREGA
                            	   258: 
                            	   259: FORM815:
00:000087C2 1CFC002C        	   260: 	MOVE.B  #',',(A6)+    ; COMMA SEPARATOR
00:000087C6 3814            	   261: 	MOVE.W  (A4),D4
00:000087C8 61D2            	   262: 	BSR.S   FORMREGA
                            	   263: CS13:
00:000087CA 6078            	   264: 	BRA     CS12           ; COMMON
                            	   265: 
                            	   266: ;  BIT   5432109876543210
                            	   267: ;        ....DDD.........       ; DATA REGISTER
                            	   268: ;        .............AAA       ; ADDRESS REGISTER
                            	   269: ;
                            	   270:          
                            	   271: 
                            	   272: FORM9:   ;.align  2              ; EXG
00:000087CC EF5C            	   273:          ROL.W   #7,D4
00:000087CE 61DC            	   274:          BSR.S   FORMREGD       ; DATA REGISTER
00:000087D0 60F0            	   275:          BRA.S   FORM815
                            	   276: 
00:000087D2 600003D0        	   277: EEA10:   BRA     EEA
                            	   278: 
                            	   279: ;  BIT   5432109876543210
                            	   280: ;        ..........AAAAAA         EFFECTIVE ADDRESS
                            	   281: ;        .......MMM......         OP-MODE
                            	   282: ;        ....RRR.........         D-REGISTER
                            	   283: ;        .......011......         WORD  EA,A@
                            	   284: ;        .......111......         LONG  EA,A@
                            	   285: ;        .......000......         EA,D@ BYTE (ADDRESS REGISTER DIRECT NOT ALLOWED)
                            	   286: ;        .......0........         EA,D@
                            	   287: ;        .......1........         D@,EA
                            	   288: ;        ........00......         BYTE
                            	   289: ;        ........01......         WORD
                            	   290: ;        ........10......         LONG
                            	   291: ;
                            	   292:          
                            	   293: 
                            	   294: ;                               ADD <EA>,A@   CMP <EA>,A@   SUB <EA>,A@
                            	   295: FORM10EX:	;.align  2              ; ADD  CMP  SUB
00:000087D6 3E3C0FFF        	   296:          MOVE.W  #$FFF,D7     ; ALL MODES ALLOWED
00:000087DA 2004            	   297:          MOVE.L  D4,D0
00:000087DC 024001C0        	   298:          ANDI.W  #$01C0,D0
00:000087E0 6738            	   299:          BEQ.S   FORM103        ; .......000......
00:000087E2 0C4001C0        	   300:          CMPI.W  #$01C0,D0
00:000087E6 6710            	   301:          BEQ.S   FORM10E3       ; .......111......
00:000087E8 0C4000C0        	   302:          CMPI.W  #$00C0,D0
00:000087EC 661E            	   303:          BNE.S   FORM10E6
                            	   304: 
00:000087EE 1AFC002E        	   305:          MOVE.B  #'.',(A5)+    ; .......011......       STORE PERIOD
00:000087F2 1AFC0057        	   306:          MOVE.B  #'W',(A5)+
00:000087F6 6008            	   307:          BRA.S   FORM10E4
                            	   308: 
00:000087F8 1AFC002E        	   309: FORM10E3:MOVE.B  #'.',(A5)+
00:000087FC 1AFC004C        	   310:          MOVE.B  #'L',(A5)+
                            	   311: 
00:00008800 61D0            	   312: FORM10E4:BSR.S   EEA10
                            	   313: 
00:00008802 1CC5            	   314:          MOVE.B  D5,(A6)+     ; STORE COMMA SEPARATOR
                            	   315: 
00:00008804 3814            	   316:          MOVE.W  (A4),D4
00:00008806 EF5C            	   317:          ROL.W   #7,D4
00:00008808 6192            	   318:          BSR.S   FORMREGA       ; <EA>,A@
00:0000880A 6038            	   319:          BRA.S   CS12           ; COMMON
                            	   320: 
00:0000880C 08140000        	   321: FORM10E6:BTST.B  #0,(A4)
00:00008810 661C            	   322:          BNE.S   FORM105        ; .......1........    D@,<EA>
00:00008812 600A            	   323:          BRA.S   FORM104        ; .......0........    <EA>,D@
                            	   324: 
                            	   325: ;  BIT   5432109876543210
                            	   326: ;        ..........AAAAAA       EFFECTIVE ADDRESS
                            	   327: ;        .......MMM......       OP-MODE
                            	   328: ;        ....RRR.........       D-REGISTER
                            	   329: ;        .......0........       EA,D@
                            	   330: ;        .......1........       D@,EA
                            	   331: ;        ........00......       BYTE
                            	   332: ;        ........01......       WORD
                            	   333: ;        ........10......       LONG
                            	   334: 
                            	   335:          
                            	   336: 
                            	   337: FORM10:  ;.align  2              ; AND  EOR  OR
00:00008814 08140000        	   338:          BTST.B  #0,(A4)
00:00008818 6614            	   339:          BNE.S   FORM105
                            	   340: 
00:0000881A 3E3C0FFD        	   341: FORM103: MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:0000881E 610002FA        	   342: FORM104: BSR     FORMSIZE
00:00008822 61AE            	   343:          BSR.S   EEA10          ; <EA>,D@
                            	   344: 
00:00008824 1CC5            	   345:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   346: 
00:00008826 1814            	   347:          MOVE.B  (A4),D4
00:00008828 E20C            	   348:          LSR.B   #1,D4
00:0000882A 6180            	   349:          BSR     FORMREGD
00:0000882C 6016            	   350:          BRA.S   CS12           ; COMMON
                            	   351: 
00:0000882E 610002EA        	   352: FORM105: BSR     FORMSIZE       ; D@,<EA>
00:00008832 1814            	   353:          MOVE.B  (A4),D4
00:00008834 E20C            	   354:          LSR.B   #1,D4
00:00008836 6100FF74        	   355:          BSR     FORMREGD
                            	   356: 
00:0000883A 1CC5            	   357:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   358: 
00:0000883C 3814            	   359:          MOVE.W  (A4),D4
00:0000883E 3E3C01FD        	   360:          MOVE.W  #$1FD,D7     ; ALTERABLE MEMORY ADDRESSING
00:00008842 618E            	   361:          BSR.S   EEA10
00:00008844 6000064A        	   362: CS12:    BRA     COMMON
                            	   363: 
                            	   364:          
                            	   365: 
                            	   366: ;                               PEA     (JMP  JSR)
00:00008848 3E3C07E4        	   367: FORM11:  MOVE.W  #$7E4,D7     ; CONTROL ADDERSSING
00:0000884C 6184            	   368:          BSR     EEA10
00:0000884E 60F4            	   369:          BRA.S   CS12           ; COMMON
                            	   370: 
                            	   371:          
                            	   372: 
                            	   373: ;                               ; JMP  JSR
00:00008850 2004            	   374: FORM11SL:MOVE.L  D4,D0        ; LOOK FOR .S  OR  .L
00:00008852 0240003F        	   375:          ANDI.W  #$3F,D0
00:00008856 0C400038        	   376:          CMPI.W  #$38,D0
00:0000885A 6608            	   377:          BNE.S   FORM112        ; NOT .S
00:0000885C 1AFC002E        	   378:          MOVE.B  #'.',(A5)+    ; PERIOD
00:00008860 1AFC0053        	   379:          MOVE.B  #'S',(A5)+    ; S
00:00008864 0C400039        	   380: FORM112: CMPI.W  #$39,D0
00:00008868 6608            	   381:          BNE.S   FORM114
00:0000886A 1AFC002E        	   382:          MOVE.B  #'.',(A5)+    ; PERIOD
00:0000886E 1AFC004C        	   383:          MOVE.B  #'L',(A5)+    ; L
00:00008872 60D4            	   384: FORM114: BRA.S   FORM11
                            	   385: 
                            	   386: ;  BIT   5432109876543210
                            	   387: ;        ....XXX.....0...       DATA DESTINATION REGISTER
                            	   388: ;        ....XXX.....1...       ADDRESS REGISTER
                            	   389: ;        ....XXX.00......       BYTE
                            	   390: ;        ........01......       WORD
                            	   391: ;        ........10......       LONG
                            	   392: ;        ............0...       DATA REGISTER TO DATA REGISTER
                            	   393: ;        ............1...       MEMORY TO MEMORY
                            	   394: ;        ............0xXX       DATA SOURCE REGISTER
                            	   395: ;        ............1XXX       ADDRESS SOURCE REGISTER
                            	   396: ;
                            	   397:          
                            	   398: 
                            	   399: FORM12:  ;.align  2              ; ABCD  ADDX  SBCD  SUBX
00:00008874 610002A4        	   400:          BSR     FORMSIZE
                            	   401: 
00:00008878 08040003        	   402:          BTST    #3,D4
00:0000887C 6610            	   403:          BNE.S   FORM125
                            	   404: 
00:0000887E 6100FF2C        	   405:          BSR     FORMREGD       ; D@,D@;   FORMAT SOURCE
                            	   406: 
00:00008882 1CC5            	   407:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   408: 
00:00008884 1814            	   409:          MOVE.B  (A4),D4
00:00008886 E20C            	   410:          LSR.B   #1,D4
00:00008888 6100FF22        	   411:          BSR     FORMREGD       ; FORMAT DESTINATION
00:0000888C 6046            	   412:          BRA.S   CS11           ; COMMON
                            	   413: 
00:0000888E 1CFC002D        	   414: FORM125: MOVE.B  #'-',(A6)+    ; -
00:00008892 1CFC0028        	   415:          MOVE.B  #'(',(A6)+    ; (
00:00008896 6100FF04        	   416:          BSR     FORMREGA       ; A@    SOURCE
                            	   417: 
00:0000889A 203C282D2C29    	   418:          MOVE.L  #$282d2c29,D0 ; ),-(
00:000088A0 6152            	   419:          BSR.S   SCHR           ; STORE CHARS
                            	   420: 
00:000088A2 1814            	   421:          MOVE.B  (A4),D4
00:000088A4 E20C            	   422:          LSR.B   #1,D4
00:000088A6 6100FEF4        	   423:          BSR     FORMREGA       ; A@   DESTINATION
00:000088AA 1CFC0029        	   424:          MOVE.B  #')',(A6)+
00:000088AE 6024            	   425:          BRA.S   CS11           ; COMMON
                            	   426: 
                            	   427: ;  BIT   5432109876543210
                            	   428: ;        ....XXX.....1...       ADDRESS REGISTER    DESTINATION
                            	   429: ;        ....XXX.00......       BYTE
                            	   430: ;        ........01......       WORD
                            	   431: ;        ........10......       LONG
                            	   432: ;        ............1...       MEMORY TO MEMORY
                            	   433: ;        ............1XXX       ADDRESS SOURCE REGISTER
                            	   434: ;
                            	   435:          
                            	   436: 
                            	   437: FORM12A: ;.align  2              ; CMPM
00:000088B0 61000268        	   438:          BSR     FORMSIZE
                            	   439: 
00:000088B4 1CFC0028        	   440:          MOVE.B  #'(',(A6)+    ; (
00:000088B8 6100FEE2        	   441:          BSR     FORMREGA       ; A@
                            	   442: 
00:000088BC 203C282C2B29    	   443:          MOVE.L  #$282c2b29,D0  ; )+,(
00:000088C2 6130            	   444:          BSR.S   SCHR           ; STORE CHARS
                            	   445: 
00:000088C4 1814            	   446:          MOVE.B  (A4),D4
00:000088C6 E20C            	   447:          LSR.B   #1,D4
00:000088C8 6100FED2        	   448:          BSR     FORMREGA       ; A@
00:000088CC 1CFC0029        	   449:          MOVE.B  #')',(A6)+
00:000088D0 1CFC002B        	   450:          MOVE.B  #'+',(A6)+
00:000088D4 600005BA        	   451: CS11:    BRA     COMMON
                            	   452: 
                            	   453:          
                            	   454: 
00:000088D8 60000210        	   455: IQUICK:  BRA     IQUICKA        ; ADDQ  SUBQ
                            	   456: 
                            	   457: ;  BIT   5432109876543210
                            	   458: ;        0111...0........       FIXED
                            	   459: ;        ....RRR.........       DATA REGISTER
                            	   460: ;        ........DDDDDDDD       SIGN EXTENDED DATA
                            	   461: ;
                            	   462:          
                            	   463: 
                            	   464: IMOVEQ:  ;.align  2
00:000088DC 1CFC0023        	   465:          MOVE.B  #'#',(A6)+    ; IMMEDIATE
                            	   466: 
00:000088E0 3014            	   467:          MOVE.W  (A4),D0
00:000088E2 4880            	   468:          EXT.W   D0
00:000088E4 48C0            	   469:          EXT.L   D0
00:000088E6 6100FCAE        	   470:          BSR     HEX2DEC        ; DECIMAL
                            	   471: 
00:000088EA 1CC5            	   472:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   473: 
00:000088EC EF5C            	   474:          ROL.W   #7,D4
00:000088EE 6100FEBC        	   475:          BSR     FORMREGD
00:000088F2 60E0            	   476:          BRA.S   CS11           ; COMMON
                            	   477: 
00:000088F4 1CC0            	   478: SCHR:    MOVE.B  D0,(A6)+     ; OUTPUT STRING
00:000088F6 E088            	   479:          LSR.L   #8,D0
00:000088F8 66FA            	   480:          BNE.S   SCHR           ; MORE TO OUTPUT
00:000088FA 4E75            	   481:          RTS
                            	   482: 
                            	   483: ; MOVE FROM SR  (STATUS REGISTER)
                            	   484: ;
                            	   485:          
                            	   486: 
00:000088FC 203C002C5253    	   487: IMVFSR:  MOVE.L  #$002c5253,D0 ; SR,
                            	   488: 
00:00008902 61F0            	   489:          BSR.S   SCHR
00:00008904 6100029E        	   490:          BSR     EEA            ; DATA ALTERABLE
00:00008908 60CA            	   491:          BRA.S   CS11           ; COMMON
                            	   492: 
                            	   493: ; MOVE FROM USP (USER STACK POINTER)
                            	   494: ;
                            	   495:          
                            	   496: 
00:0000890A 203C2C505355    	   497: IMVFUSP: MOVE.L  #$2c505355,D0 ; USP,
00:00008910 61E2            	   498:          BSR.S   SCHR
00:00008912 6100FE88        	   499:          BSR     FORMREGA
00:00008916 60BC            	   500:          BRA.S   CS11           ; COMMON
                            	   501: 
                            	   502: ; MOVE TO SR (STATUS REGISTER)
                            	   503: ;
                            	   504:          
                            	   505: 
00:00008918 3E3C0FFD        	   506: IMVTSR:  MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:0000891C 61000286        	   507:          BSR     EEA
00:00008920 203C0052532C    	   508:          MOVE.L  #$0052532c,D0 ; ,SR
00:00008926 61CC            	   509: IMVT44:  BSR.S   SCHR
00:00008928 60AA            	   510:          BRA.S   CS11           ; COMMON
                            	   511: 
                            	   512: ; MOVE TO USP (USER STACK POINTER)
                            	   513: ;
                            	   514:          
                            	   515: 
00:0000892A 6100FE70        	   516: IMVTUSP: BSR     FORMREGA
00:0000892E 203C5053552C    	   517:          MOVE.L  #$5053552c,D0 ; ,USP
00:00008934 60F0            	   518:          BRA.S   IMVT44
                            	   519: 
                            	   520: ;  MOVE TO CCR (CONDITION CODE REGISTER)
                            	   521: ;
                            	   522:          
                            	   523: 
00:00008936 3E3C0FFD        	   524: IMVTCCR: MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:0000893A 61000268        	   525:          BSR     EEA
00:0000893E 203C5243432C    	   526:          MOVE.L  #$5243432c,D0 ; ,CCR
00:00008944 60E0            	   527:          BRA.S   IMVT44
                            	   528: 
                            	   529: ;  BIT   5432109876543210
                            	   530: ;        0000...1..001...       FIXED
                            	   531: ;        ....XXX.........       DATA REGISTER
                            	   532: ;        ........0.......       MEMORY TO REGISTER
                            	   533: ;        ........1.......       REGISTER TO MEMORY
                            	   534: ;        .........0......       WORD
                            	   535: ;        .........1......       LONG
                            	   536: ;        .............XXX       ADDRESS REGISTER
                            	   537: ;
                            	   538:          
                            	   539: 
                            	   540: IMOVEP:  ;.align  2
00:00008946 1AFC002E        	   541:          MOVE.B  #'.',(A5)+    ; D@,#(A@)
00:0000894A 303C4C57        	   542:          MOVE.W  #$4c57,D0    ; "LW"
00:0000894E 08040006        	   543:          BTST    #6,D4
00:00008952 6702            	   544:          BEQ.S   IMOVEP11       ; USE "W"
00:00008954 E048            	   545:          LSR.W   #8,D0         ; USE "L"
00:00008956 1AC0            	   546: IMOVEP11:MOVE.B  D0,(A5)+     ; LENGTH
                            	   547: 
00:00008958 1814            	   548:          MOVE.B  (A4),D4
00:0000895A E20C            	   549:          LSR.B   #1,D4
                            	   550: 
00:0000895C 082C00070001    	   551:          BTST.B  #7,1(A4)
00:00008962 670E            	   552:          BEQ.S   IMOVEP35
                            	   553: 
00:00008964 6100FE46        	   554:          BSR     FORMREGD       ; D@,$HHHH(A@)
                            	   555: 
00:00008968 1CC5            	   556:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   557: 
00:0000896A 3814            	   558:          MOVE.W  (A4),D4
00:0000896C 6112            	   559:          BSR.S   IMOVEP66
00:0000896E 6000051E        	   560: CS20:    BRA     COMMON4
                            	   561: 
00:00008972 610C            	   562: IMOVEP35:BSR.S   IMOVEP66       ; $HHHH(A@),D@
                            	   563: 
00:00008974 1CC5            	   564:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   565: 
00:00008976 1814            	   566:          MOVE.B  (A4),D4
00:00008978 E20C            	   567:          LSR.B   #1,D4
00:0000897A 6100FE30        	   568:          BSR     FORMREGD
00:0000897E 60EE            	   569:          BRA.S   CS20           ; COMMON4
                            	   570: 
00:00008980 1CFC0024        	   571: IMOVEP66:MOVE.B  #'$',(A6)+    ; FORMAT DISPLACEMENT
00:00008984 302C0002        	   572:          MOVE.W  2(A4),D0
00:00008988 6100FC70        	   573:          BSR     PNT4HX
                            	   574: 
00:0000898C 1CFC0028        	   575:          MOVE.B  #'(',(A6)+
                            	   576: 
00:00008990 3814            	   577:          MOVE.W  (A4),D4
00:00008992 6100FE08        	   578:          BSR     FORMREGA
00:00008996 1CFC0029        	   579:          MOVE.B  #')',(A6)+
00:0000899A 4E75            	   580:          RTS
                            	   581: 
                            	   582: SCOMMON:
00:0000899C 600004F2        	   583: 	bra COMMON         ; NOP RESET RTE RTR RTS TRAPV
                            	   584:         
                            	   585: 
00:000089A0 610000E4        	   586: ISCC:    BSR     ICCCC          ; GET REST OF OP-CODE
00:000089A4 610001FE        	   587:          BSR     EEA            ; DATA ALTERABLE
00:000089A8 60F2            	   588:          BRA.S   SCOMMON
                            	   589: 
                            	   590:          
                            	   591: 
                            	   592: IDBCC:   ;.align  2              ; DB--
00:000089AA 3814            	   593:          MOVE.W  (A4),D4
00:000089AC 6100FDFE        	   594:          BSR     FORMREGD
                            	   595: 
00:000089B0 1CC5            	   596:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
00:000089B2 1CFC0024        	   597:          MOVE.B  #'$',(A6)+    ; HEX FIELD TO FOLLOW
                            	   598: 
00:000089B6 610000CE        	   599:          BSR     ICCCC
00:000089BA 602C            	   600:          BRA.S   ICC55
                            	   601: 
                            	   602: ;  BIT   5432109876543210
                            	   603: ;        0110............       FIXED
                            	   604: ;        ....CCCC........       CONDITION
                            	   605: ;        ........DDDDDDD0       DISPLACEMENT
                            	   606: ;        ...............1       ERROR (ODD BOUNDRY DISPLACEMENT)
                            	   607: ;
                            	   608:          
                            	   609: 
                            	   610: ICC:     ;.align  2              ; B--
00:000089BC 610000C8        	   611:          BSR     ICCCC
                            	   612: 
00:000089C0 1CFC0024        	   613: IBSR:    MOVE.B  #'$',(A6)+    ; BSR.S BRA
                            	   614: 
00:000089C4 4A04            	   615:          TST.B   D4
00:000089C6 6720            	   616:          BEQ.S   ICC55          ; 16 BIT DISPLACEMENT
                            	   617: 
00:000089C8 1AFC002E        	   618:          MOVE.B  #'.',(A5)+
00:000089CC 1AFC0053        	   619:          MOVE.B  #'S',(A5)+
00:000089D0 4884            	   620:          EXT.W   D4            ; 8 BIT DISPLACEMENT
                            	   621: 
00:000089D2 48C4            	   622: ICC35:   EXT.L   D4            ; SIGN-EXTENDED DISPLACEMENT
00:000089D4 D8A9FFFC        	   623:          ADD.L   HISPC(A1),D4  ; + PROGRAM COUNTER
00:000089D8 5484            	   624:          ADDQ.L  #2,D4         ; + TWO
00:000089DA 2004            	   625:          MOVE.L  D4,D0
                            	   626: 
00:000089DC E284            	   627:          ASR.L   #1,D4
00:000089DE 650004D8        	   628:          BCS     FERROR         ; ODD BOUNDRY DISPLACEMENT
                            	   629: 
00:000089E2 6100FC1A        	   630:          BSR     PNT6HX
00:000089E6 60B4            	   631:          BRA.S   SCOMMON
                            	   632: 
00:000089E8 5483            	   633: ICC55:   ADDQ.L  #2,D3         ; SIZE
00:000089EA 382C0002        	   634:          MOVE.W  2(A4),D4
00:000089EE 1AFC002E        	   635:          MOVE.B  #'.',(A5)+
00:000089F2 1AFC004C        	   636:          MOVE.B  #'L',(A5)+    ; .L FOR 16 BIT DISPLACEMENT
00:000089F6 60DA            	   637:          BRA.S   ICC35
                            	   638: 
                            	   639:          
                            	   640: ;                               ; BCHG  BCLR  BSET  BTST
                            	   641: ISETD:   ;.align  2              ; DYNAMIC BIT
00:000089F8 EF5C            	   642:          ROL.W   #7,D4
00:000089FA 6100FDB0        	   643:          BSR     FORMREGD       ; DATA REGISTER
                            	   644: 
00:000089FE 1CC5            	   645: ISETD12: MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   646: 
00:00008A00 3814            	   647:          MOVE.W  (A4),D4
00:00008A02 610001A0        	   648:          BSR     EEA            ; DATA ALTERABLE
00:00008A06 6094            	   649: CS18:    BRA.S   SCOMMON
                            	   650: 
                            	   651:          ;.align   4
                            	   652: 
                            	   653: ;                            BCHG  BCLR  BSET  BTST
                            	   654: ;  1ST WORD     .... .... ..XX XXXX    EA   DATA ALTERABLE ONLY
                            	   655: ;  2ND WORD     0000 0000 000Y YYYY    BIT NUMBER
                            	   656: ;
                            	   657: ISETS:   ;.align  2              ; STATIC BIT
00:00008A08 5483            	   658:          ADDQ.L  #2,D3         ; SIZE
00:00008A0A 1CFC0023        	   659:          MOVE.B  #'#',(A6)+    ; IMMEDIATE
                            	   660: 
00:00008A0E 7000            	   661:          CLR.L   D0
00:00008A10 302C0002        	   662:          MOVE.W  2(A4),D0     ; GET BIT POSITION FROM 2ND WORD
00:00008A14 2200            	   663:          MOVE.L  D0,D1
00:00008A16 EA89            	   664:          LSR.L   #5,D1
00:00008A18 6600049E        	   665:          BNE     FERROR
00:00008A1C 6100FB78        	   666:          BSR     HEX2DEC        ; DECIMAL
                            	   667: 
00:00008A20 60DC            	   668:          BRA.S   ISETD12
                            	   669: 
                            	   670: ;   BIT  5432109876543210
                            	   671: ;        ....XXX.........       IMMEDIATE COUNT/REGISTER
                            	   672: ;        .......0........       RIGHT SHIFT
                            	   673: ;        .......1........       LEFT SHIFT
                            	   674: ;        ........00......       BYTE
                            	   675: ;        ........01......       WORD
                            	   676: ;        ........10......       LONG
                            	   677: ;        ....0...11......       WORD (MEMORY)
                            	   678: ;        ....0...11AAAAAA       EFFECTIVE ADDRESS
                            	   679: ;        ..........0.....       SHIFT IMMEDIATE COUNT
                            	   680: ;        ..........1.....       SHIFT COUNT (MODULO 64) IN DATA REGISTER
                            	   681: ;
                            	   682:          ;.align   4
                            	   683: 
                            	   684: ISHIFT:  ;.align   2             ; AS-  LS-  RO-  ROX-
00:00008A22 303C4C52        	   685:          MOVE.W  #$4c52,D0    ; "LR"
00:00008A26 08040008        	   686:          BTST    #8,D4         ; DIRECTION BIT
00:00008A2A 6702            	   687:          BEQ.S   ISHIFT13       ; RIGHT
00:00008A2C E048            	   688:          LSR.W   #8,D0         ; LEFT
00:00008A2E 1AC0            	   689: ISHIFT13:MOVE.B  D0,(A5)+     ; DIRECTION; "L" OR "R"
                            	   690: 
00:00008A30 3014            	   691:          MOVE.W  (A4),D0
00:00008A32 024000C0        	   692:          ANDI.W  #$00C0,D0
00:00008A36 0C4000C0        	   693:          CMPI.W  #$00C0,D0
00:00008A3A 6730            	   694:          BEQ.S   ISHIFTM1       ; MEMORY SHIFT
                            	   695: 
00:00008A3C 610000DC        	   696:          BSR     FORMSIZE
                            	   697: 
00:00008A40 EF5C            	   698:          ROL.W   #7,D4
00:00008A42 0804000C        	   699:          BTST    #12,D4        ; I/R BIT
00:00008A46 6616            	   700:          BNE.S   ISHIFT33       ; COUNT IN REGISTER
                            	   701: 
00:00008A48 02040007        	   702:          ANDI.B  #$07,D4      ; IMMEDIATE COUNT
00:00008A4C 6604            	   703:          BNE.S   ISHIFT23
00:00008A4E 00040008        	   704:          ORI.B   #$08,D4      ; CHANGE ZERO TO EIGHT
00:00008A52 00040030        	   705: ISHIFT23:ORI.B   #'0',D4
00:00008A56 1CFC0023        	   706:          MOVE.B  #'#',(A6)+
00:00008A5A 1CC4            	   707:          MOVE.B  D4,(A6)+
00:00008A5C 6004            	   708:          BRA.S   ISHIFT44
                            	   709: 
00:00008A5E 6100FD4C        	   710: ISHIFT33:BSR     FORMREGD
                            	   711: 
00:00008A62 1CC5            	   712: ISHIFT44:MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   713: 
00:00008A64 3814            	   714:          MOVE.W  (A4),D4
00:00008A66 6100FD44        	   715:          BSR     FORMREGD
00:00008A6A 609A            	   716: CS17:    BRA.S   CS18           ; COMMON
                            	   717: 
00:00008A6C 1AFC002E        	   718: ISHIFTM1:MOVE.B  #'.',(A5)+    ; PERIOD
00:00008A70 1AFC0057        	   719:          MOVE.B  #'W',(A5)+    ; .WORD
                            	   720: 
00:00008A74 0804000B        	   721:          BTST    #11,D4
00:00008A78 6600043E        	   722:          BNE     FERROR         ; BIT 11 MUST BE ZERO
                            	   723: 
00:00008A7C 3E3C01FC        	   724:          MOVE.W  #$1FC,D7     ; MEMORY ALTERABLE ADDRESSING
00:00008A80 61000122        	   725:          BSR     EEA
00:00008A84 60E4            	   726:          BRA.S   CS17           ; COMMON
                            	   727: 
00:00008A86 700F            	   728: ICCCC:   MOVEQ   #$0F,D0      ; APPEND CONDITION CODE
00:00008A88 C014            	   729:          AND.B   (A4),D0      ; D0 = CCC
00:00008A8A E388            	   730:          LSL.L   #1,D0         ; D0 = CCC;2
                            	   731: 
00:00008A8C 323B0010        	   732:          MOVE.W  BRTBL(PC,D0.W),D1 ; GET BRANCH MNEMONIC
00:00008A90 1AC1            	   733:          MOVE.B  D1,(A5)+     ; (REVERSED) FROM THE TABLE
00:00008A92 E049            	   734:          LSR.W   #8,D1         ; AND ADD THE NONBLANK PORTION
00:00008A94 0C010020        	   735:          CMPI.B  #BLANK,D1     ; TO THE BUFFER.
00:00008A98 6702            	   736:          BEQ.S   ICCCC9
00:00008A9A 1AC1            	   737:          MOVE.B  D1,(A5)+
00:00008A9C 4E75            	   738: ICCCC9:  RTS
                            	   739: 
00:00008A9E 2054            	   740: BRTBL:   dc.b  " T"           ; "T " BRA ACCEPTED
00:00008AA0 2046            	   741:          dc.b  " F"           ; "F "
00:00008AA2 4948            	   742:          dc.b  "IH"           ; "HI"
00:00008AA4 534C            	   743:          dc.b  "SL"           ; "LS"
00:00008AA6 4343            	   744:          dc.b  "CC"           ; "CC"
00:00008AA8 5343            	   745:          dc.b  "SC"           ; "CS"
00:00008AAA 454E            	   746:          dc.b  "EN"           ; "NE"
00:00008AAC 5145            	   747:          dc.b  "QE"           ; "EQ"
00:00008AAE 4356            	   748:          dc.b  "CV"           ; "VC"
00:00008AB0 5356            	   749:          dc.b  "SV"           ; "VS"
00:00008AB2 4C50            	   750:          dc.b  "LP"           ; "PL"
00:00008AB4 494D            	   751:          dc.b  "IM"           ; "MI"
00:00008AB6 4547            	   752:          dc.b  "EG"           ; "GE"
00:00008AB8 544C            	   753:          dc.b  "TL"           ; "LT"
00:00008ABA 5447            	   754:          dc.b  "TG"           ; "GT"
00:00008ABC 454C            	   755:          dc.b  "EL"           ; "LE"
                            	   756: 
                            	   757: ;   BIT  5432109876543210
                            	   758: ;        ....RRRMMM......    DESTINATION REGISTER MODE
                            	   759: ;        ..........MMMRRR    SOURCE MODE REGISTER
                            	   760: ;
                            	   761: ; IF BYTE SIZE; ADDRESS DIRECT NOT ALLOWED AS SOURCE
                            	   762: ;
                            	   763: 					even
                            	   764: IMOVEA1: ;.align  2
00:00008ABE 3E3C0FFF        	   765:          MOVE.W  #$FFF,D7     ; ALL MODES
00:00008AC2 610000E0        	   766:          BSR     EEA
                            	   767: 
00:00008AC6 1CC5            	   768:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   769: 
00:00008AC8 3814            	   770:          MOVE.W  (A4),D4      ; ....RRRMMM......
00:00008ACA E24C            	   771:          LSR.W   #1,D4         ; .....RRRMMM.....
00:00008ACC EA0C            	   772:          LSR.B   #5,D4         ; .....RRR.....MMM
00:00008ACE E05C            	   773:          ROR.W   #8,D4         ; .....MMM.....RRR
00:00008AD0 EB0C            	   774:          LSL.B   #5,D4         ; .....MMMRRR.....
00:00008AD2 EA4C            	   775:          LSR.W   #5,D4         ; ..........MMMRRR
                            	   776: 
                            	   777: ; IF .BYTE DESTINATION A@ NOT ALLOWED
00:00008AD4 3E3C01FF        	   778:          MOVE.W  #$1FF,D7     ; DATA ALTERABLE + A@
00:00008AD8 1014            	   779:          MOVE.B  (A4),D0
00:00008ADA 0C000001        	   780:          CMPI.B  #$01,D0
00:00008ADE 6604            	   781:          BNE.S   IMOVE19        ; NOT BYTE SIZE
                            	   782: 
00:00008AE0 3E3C01FD        	   783:          MOVE.W  #$1FD,D7     ; DATA ALTERABLE
                            	   784: IMOVE19:
                            	   785: 
00:00008AE4 610000BE        	   786:          BSR     EEA
00:00008AE8 602C            	   787:          BRA.S   CS19           ; COMMON
                            	   788: 
                            	   789: ;  IF BYTE; ADDRESS REGISTER DIRECT NOT ALLOWED
                            	   790: IQUICKA: ;.align  2              ; ADDQ  SUBQ
00:00008AEA 612E            	   791:          BSR.S   FORMSIZE
                            	   792: 
00:00008AEC 1CFC0023        	   793:          MOVE.B  #'#',(A6)+
00:00008AF0 EF5C            	   794:          ROL.W   #7,D4
00:00008AF2 02040007        	   795:          ANDI.B  #7,D4
00:00008AF6 6604            	   796:          BNE.S   IQUICK21
00:00008AF8 00040008        	   797:          ORI.B   #8,D4         ; MAKE ZERO INTO EIGHT
00:00008AFC 00040030        	   798: IQUICK21:ORI.B   #'0',D4       ; MAKE ASCII
00:00008B00 1CC4            	   799:          MOVE.B  D4,(A6)+
                            	   800: 
00:00008B02 1CC5            	   801:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   802: 
00:00008B04 3814            	   803:          MOVE.W  (A4),D4
                            	   804: 
00:00008B06 3014            	   805:          MOVE.W  (A4),D0
00:00008B08 024000C0        	   806:          ANDI.W  #$00C0,D0
00:00008B0C 6704            	   807:          BEQ.S   IQUICK31       ; DATA ALTERABLE
00:00008B0E 3E3C01FF        	   808:          MOVE.W  #$1FF,D7     ; ALTERABLE ADDRESSING
00:00008B12 61000090        	   809: IQUICK31:BSR     EEA
00:00008B16 60000378        	   810: CS19:    BRA     COMMON
                            	   811: 
                            	   812: ;  BIT   5432109876543210
                            	   813: ;        ........00......       BYTE
                            	   814: ;        ........01......       WORD
                            	   815: ;        ........10......       LONG
                            	   816: ;        ........11......       ERROR
                            	   817: ;
                            	   818: FORMSIZE: ;.align  2
00:00008B1A 3414            	   819:          MOVE.W  (A4),D2
00:00008B1C 1AFC002E        	   820:          MOVE.B  #'.',(A5)+    ; STORE PERIOD
00:00008B20 EC4A            	   821:          LSR.W   #6,D2
00:00008B22 02420003        	   822:          ANDI.W  #$03,D2
00:00008B26 6606            	   823:          BNE.S   FORM91
00:00008B28 1AFC0042        	   824:          MOVE.B  #'B',(A5)+    ; STORE "B"
00:00008B2C 6016            	   825:          BRA.S   FORM95
                            	   826: 
00:00008B2E 103C0057        	   827: FORM91:  MOVE.B  #'W',D0
00:00008B32 0C020001        	   828:          CMPI.B  #1,D2
00:00008B36 670A            	   829:          BEQ.S   FORM93
00:00008B38 103C004C        	   830:          MOVE.B  #'L',D0
00:00008B3C 0C020002        	   831:          CMPI.B  #2,D2
00:00008B40 665E            	   832:          BNE.S   FE10           ; FERROR
00:00008B42 1AC0            	   833: FORM93:  MOVE.B  D0,(A5)+     ; STORE "W" OR "L"
00:00008B44 4E75            	   834: FORM95:  RTS
                            	   835: 
00:00008B46 6100FC64        	   836: EA000:   BSR     FORMREGD
00:00008B4A 08070000        	   837:          BTST    #0,D7
00:00008B4E 6750            	   838:          BEQ.S   FE10           ; FERROR
00:00008B50 4E75            	   839:          RTS
                            	   840: 
00:00008B52 6100FC48        	   841: EA001:   BSR     FORMREGA
00:00008B56 08070001        	   842:          BTST    #1,D7
00:00008B5A 6744            	   843:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
00:00008B5C 4E75            	   844:          RTS
                            	   845: 
00:00008B5E 1CFC0028        	   846: EA010:   MOVE.B  #'(',(A6)+
00:00008B62 6100FC38        	   847:          BSR     FORMREGA
00:00008B66 1CFC0029        	   848:          MOVE.B  #')',(A6)+
00:00008B6A 08070002        	   849:          BTST    #2,D7
00:00008B6E 6730            	   850:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
00:00008B70 4E75            	   851:          RTS
                            	   852: 
00:00008B72 1CFC0028        	   853: EA011:   MOVE.B  #'(',(A6)+
00:00008B76 6100FC24        	   854:          BSR     FORMREGA
00:00008B7A 1CFC0029        	   855:          MOVE.B  #')',(A6)+
00:00008B7E 1CFC002B        	   856:          MOVE.B  #'+',(A6)+
00:00008B82 08070003        	   857:          BTST    #3,D7
00:00008B86 6718            	   858:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
00:00008B88 4E75            	   859: EA011RTS:RTS
                            	   860: 
00:00008B8A 1CFC002D        	   861: EA100:   MOVE.B  #'-',(A6)+
00:00008B8E 1CFC0028        	   862:          MOVE.B  #'(',(A6)+
00:00008B92 6100FC08        	   863:          BSR     FORMREGA
00:00008B96 1CFC0029        	   864:          MOVE.B  #')',(A6)+
00:00008B9A 08070004        	   865:          BTST    #4,D7
00:00008B9E 66E8            	   866:          BNE.S   EA011RTS
00:00008BA0 60000316        	   867: FE10:    BRA     FERROR         ; THIS MODE NOT ALLOWED
                            	   868: 
                            	   869: ;  ENTER       A4 = POINTER TO FIRST WORD
                            	   870: ;              D3 = OFFSET TO EXTENSION
                            	   871: ;              D4 = VALUE TO PROCESS
                            	   872: ;              D7 = MODES ALLOWED MASK
                            	   873: ;
                            	   874: EEA:     ;.align  2
00:00008BA4 2004            	   875: 	move.l D4,D0
00:00008BA6 E648            	   876: 	lsr.w #3,D0
00:00008BA8 02400007        	   877: 	andi.w #$7,D0
00:00008BAC 6798            	   878: 	beq.s EA000
00:00008BAE 0C000001        	   879: 	cmpi.b #1,D0
00:00008BB2 679E            	   880: 	beq.s EA001
00:00008BB4 0C000002        	   881: 	cmpi.b #2,D0
00:00008BB8 67A4            	   882: 	beq.s EA010
00:00008BBA 0C000003        	   883: 	cmpi.b #3,D0
00:00008BBE 67B2            	   884: 	beq.s EA011
00:00008BC0 0C000004        	   885: 	cmpi.b #4,D0
00:00008BC4 67C4            	   886: 	beq.s EA100
00:00008BC6 0C000005        	   887: 	cmpi.b #5,D0
00:00008BCA 6760            	   888: 	beq.s EA101
00:00008BCC 0C000007        	   889: 	cmpi.b #7,D0
00:00008BD0 6770            	   890: 	beq.s EA111
                            	   891: 
                            	   892: ;    EXTENSION WORD
                            	   893: ;   BIT  5432109876543210
                            	   894: ;        0...............    DATA REGISTER
                            	   895: ;        1...............    ADDRESS REGISTER
                            	   896: ;        .RRR............    REGISTER
                            	   897: ;        ....0...........    SIGN EXTENDED, LOW ORDER INTEGER IN INDEX REG
                            	   898: ;        ....1...........    LONG VALUE IN INDEX REGISTER
                            	   899: ;        .....000........
                            	   900: ;        ........DDDDDDDD    DISPLACEMENT INTEGER
                            	   901: ;
                            	   902: ; EA110            ADDRESS REGISTER INDIRECT WITH INDEX
                            	   903: 
00:00008BD2 08070006        	   904:          BTST    #6,D7
00:00008BD6 67C8            	   905:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
                            	   906: 
00:00008BD8 32343000        	   907:          MOVE.W  (A4,D3.W),D1
00:00008BDC 02410700        	   908:          ANDI.W  #$0700,D1
00:00008BE0 66BE            	   909:          BNE.S   FE10           ; FERROR  BITS 10-8 MUST BE ZERO
                            	   910: 
00:00008BE2 30343000        	   911:          MOVE.W  (A4,D3.W),D0  ; D0 = DISPLACEMENT
00:00008BE6 4880            	   912:          EXT.W   D0
00:00008BE8 48C0            	   913:          EXT.L   D0
00:00008BEA 6100F9AA        	   914:          BSR     HEX2DEC        ; DECIMAL
00:00008BEE 1CFC0028        	   915:          MOVE.B  #'(',(A6)+    ; (
                            	   916: 
00:00008BF2 6100FBA8        	   917:          BSR     FORMREGA       ; XX(A@
                            	   918: 
00:00008BF6 1CFC002C        	   919:          MOVE.B  #',',(A6)+    ; XX(A@,
                            	   920: 
00:00008BFA 18343000        	   921:          MOVE.B  (A4,D3.W),D4
00:00008BFE E804            	   922:          ASR.B   #4,D4
00:00008C00 6A06            	   923:          BPL.S   EA1105
00:00008C02 6100FB98        	   924:          BSR     FORMREGA
00:00008C06 6004            	   925:          BRA.S   EA1107
                            	   926: 
00:00008C08 6100FBA2        	   927: EA1105:  BSR     FORMREGD
00:00008C0C 1CFC002E        	   928: EA1107:  MOVE.B  #'.',(A6)+    ; XX(A@,X@.
                            	   929: 
00:00008C10 38343000        	   930:          MOVE.W  (A4,D3.W),D4 ; D4 = R@
00:00008C14 103C0057        	   931:          MOVE.B  #'W',D0       ; ..........W
00:00008C18 0804000B        	   932:          BTST    #11,D4
00:00008C1C 6704            	   933:          BEQ.S   EA1109
00:00008C1E 103C004C        	   934:          MOVE.B  #'L',D0       ; ..........L
00:00008C22 1CC0            	   935: EA1109:  MOVE.B  D0,(A6)+
00:00008C24 1CFC0029        	   936:          MOVE.B  #')',(A6)+    ; ...........)
00:00008C28 5483            	   937:          ADDQ.L  #2,D3
00:00008C2A 4E75            	   938:          RTS
                            	   939: 
                            	   940: ; ADDRESS REGISTER INDIRECT WITH DISPLACEMENT
                            	   941: ;
                            	   942: EA101:
00:00008C2C 08070005        	   943: 	btst #5,D7         	; 101000;   DIS(A@)
00:00008C30 6756            	   944: 	beq.s FE11          ; FERROR;  THIS MODE NOT ALLOWED
00:00008C32 30343000        	   945: 	move.w (A4,D3.W),D0
00:00008C36 48C0            	   946: 	ext.l D0
00:00008C38 6100F95C        	   947: 	bsr HEX2DEC        	; DECIMAL
00:00008C3C 5483            	   948: 	addq.l #2,D3        ; SIZE
00:00008C3E 6000FF1E        	   949: 	bra EA010
                            	   950: 
                            	   951: ;  111000        ABSOLUTE SHORT
                            	   952: ;  111001        ABSOLUTE LONG
                            	   953: ;  111010        PROGRAM COUNTER WITH DISPLACEMENT
                            	   954: ;  111011        PROGRAM COUNTER WITH INDEX
                            	   955: ;  111100        IMMEDIATE OR STATUS REG
                            	   956: ;
                            	   957: EA111:
00:00008C42 02440007        	   958: 	andi.w #7,D4
00:00008C46 6618            	   959: 	bne.s EA1112
00:00008C48 08070007        	   960: 	btst #7,D7
00:00008C4C 673A            	   961: 	beq.s FE11           	; FERROR;  THIS MODE NOT ALLOWED
00:00008C4E 30343000        	   962: 	move.w (A4,D3.W),D0 	; 111000;   ABSOLUTE SHORT
00:00008C52 48C0            	   963: 	ext.l D0
00:00008C54 1CFC0024        	   964: 	move.b #'$',(A6)+
00:00008C58 6100F9B0        	   965: 	bsr PNT8HX         		; SIGN EXTENDED VALUE
00:00008C5C 5483            	   966: 	addq.l #2,D3         	; SIZE + 2
00:00008C5E 4E75            	   967: 	rts
                            	   968: 
                            	   969: EA1112:
00:00008C60 0C040001        	   970: 	cmpi.b #1,D4
00:00008C64 6616            	   971: 	bne.s EA1113
00:00008C66 08070008        	   972: 	btst #8,D7
00:00008C6A 671C            	   973: 	beq.s FE11          	; FERROR;  THIS MODE NOT ALLOWED
00:00008C6C 1CFC0024        	   974: 	move.b #'$',(A6)+    	; HEX
00:00008C70 20343000        	   975: 	move.l (A4,D3.W),D0  	; 111001;     ABSOLUTE LONG
00:00008C74 6100F994        	   976: 	bsr PNT8HX
                            	   977: 	;-       MOVE.B  #'.',(A6)+    ; FORCE LONG FORMAT
                            	   978: 	;-       MOVE.B  #'L',(A6)+    ; IE   .L
00:00008C78 5883            	   979: 	addq.l #4,D3
00:00008C7A 4E75            	   980: 	rts
                            	   981: 
                            	   982: EA1113:
00:00008C7C 0C040002        	   983: 	cmpi.b #2,D4
00:00008C80 662C            	   984: 	bne.s EA1114
00:00008C82 08070009        	   985: 	btst #9,D7
00:00008C86 6604            	   986: 	bne.s EA1113A
                            	   987: FE11:
00:00008C88 6000022E        	   988: 	bra FERROR         	; THIS MODE NOT ALLOWED
                            	   989: 
                            	   990: EA1113A:
00:00008C8C 30343000        	   991: 	move.w (A4,D3.W),D0  ; 111010;  PC + DISPLACEMENT  DESTINATION(PC)
00:00008C90 48C0            	   992: 	ext.l D0
00:00008C92 D0A9FFFC        	   993: 	add.l HISPC(A1),D0
00:00008C96 5480            	   994: 	addq.l #2,D0
00:00008C98 1CFC0024        	   995: 	move.b #'$',(A6)+    ; HEX "$"
00:00008C9C 6100F96C        	   996: 	bsr PNT8HX         ; DESTINATION
00:00008CA0 203C29435028    	   997: 	move.l #$29435028,D0  ; (PC)
00:00008CA6 6100FC4C        	   998: 	bsr SCHR           ; STORE WORD
00:00008CAA 5483            	   999: 	addq.l #2,D3         ; SIZE
00:00008CAC 4E75            	  1000: 	rts
                            	  1001: 
                            	  1002: EA1114:
00:00008CAE 0C040003        	  1003: 	cmpi.b #3,D4
00:00008CB2 6664            	  1004: 	bne.s EA1115
                            	  1005: 
                            	  1006: ; PROGRAM COUNTER WITH INDEX    DESTINATION(PC,R@.X)
                            	  1007: ;
                            	  1008: ;        5432109876543210       SECOND WORD
                            	  1009: ;        0...............       DATA REGISTER
                            	  1010: ;        1...............       ADDRESS REGISTER
                            	  1011: ;        .XXX............       REGISTER
                            	  1012: ;        ....0...........       SIGN-EXTENDED, LOW ORDER WORD INTEGER
                            	  1013: ;                               ..IN INDEX REGISTER
                            	  1014: ;        ....1...........       LONG VALUE IN INDEX REGISTER
                            	  1015: ;        .....000........
                            	  1016: ;        ........XXXXXXXX       DISPLACEMENT INTEGER
                            	  1017: ;
00:00008CB4 0807000A        	  1018:          BTST    #10,D7
00:00008CB8 67CE            	  1019:          BEQ.S   FE11           ; FERROR  THIS MODE NOT ASLLOWED
                            	  1020: 
00:00008CBA 32343000        	  1021:          MOVE.W  (A4,D3.W),D1
00:00008CBE 02410700        	  1022:          ANDI.W  #$0700,D1
00:00008CC2 66C4            	  1023:          BNE.S   FE11           ; FERROR;  BITS 10-8 MUST BE ZERO
                            	  1024: 
00:00008CC4 10343001        	  1025:          MOVE.B  1(A4,D3.W),D0 ; 111100;   DESTINATION(PC,R@.X)
00:00008CC8 4880            	  1026:          EXT.W   D0
00:00008CCA 48C0            	  1027:          EXT.L   D0
00:00008CCC D0A9FFFC        	  1028:          ADD.L   HISPC(A1),D0
00:00008CD0 5480            	  1029:          ADDQ.L  #2,D0
00:00008CD2 1CFC0024        	  1030:          MOVE.B  #'$',(A6)+    ; HEX "$"
00:00008CD6 6100F932        	  1031:          BSR     PNT8HX         ; DESTINATION
                            	  1032: 
00:00008CDA 203C2C435028    	  1033:          MOVE.L  #$2c435028,D0
00:00008CE0 6100FC12        	  1034:          BSR     SCHR           ; DES(PC,
                            	  1035: 
00:00008CE4 38343000        	  1036:          MOVE.W  (A4,D3.W),D4
00:00008CE8 E95C            	  1037:          ROL.W   #4,D4
00:00008CEA 08040003        	  1038:          BTST    #3,D4
00:00008CEE 6706            	  1039:          BEQ.S   EAF25
00:00008CF0 6100FAAA        	  1040:          BSR     FORMREGA
00:00008CF4 6004            	  1041:          BRA.S   EAF27
00:00008CF6 6100FAB4        	  1042: EAF25:   BSR     FORMREGD       ; DES(PC,R@
                            	  1043: EAF27:
                            	  1044: 
00:00008CFA 1CFC002E        	  1045:          MOVE.B  #'.',(A6)+    ; DES(PC,R@.
                            	  1046: 
00:00008CFE 38343000        	  1047:          MOVE.W  (A4,D3.W),D4
00:00008D02 303C4C57        	  1048:          MOVE.W  #$4c57,D0    ; "LW"
00:00008D06 0804000B        	  1049:          BTST    #11,D4
00:00008D0A 6702            	  1050:          BEQ.S   EAF35
00:00008D0C E048            	  1051:          LSR.W   #8,D0
00:00008D0E 1CC0            	  1052: EAF35:   MOVE.B  D0,(A6)+     ; DES(PC,R@.X
                            	  1053: 
00:00008D10 1CFC0029        	  1054:          MOVE.B  #')',(A6)+    ; DES(PC,R@.X)
00:00008D14 5483            	  1055:          ADDQ.L  #2,D3
00:00008D16 4E75            	  1056:          RTS
                            	  1057: 
                            	  1058: ;   BIT  5432109876543210
                            	  1059: ;        ..........111100       ; FIRST WORD;  #<IMMEDIATE>
                            	  1060: ;
00:00008D18 0C040004        	  1061: EA1115:  CMPI.B  #4,D4
00:00008D1C 6600FF6A        	  1062:          BNE     FE11           ; FERROR
                            	  1063: 
00:00008D20 0807000B        	  1064:          BTST    #11,D7
00:00008D24 6700FF62        	  1065:          BEQ     FE11           ; FERROR;  THIS MODE NOT ALLOWED
                            	  1066: 
00:00008D28 1CFC0023        	  1067:          MOVE.B  #'#',(A6)+    ; IMMEDIATE
                            	  1068: 
00:00008D2C 122DFFFF        	  1069:          MOVE.B  -1(A5),D1
00:00008D30 0C01004C        	  1070:          CMPI.B  #'L',D1
00:00008D34 6724            	  1071:          BEQ.S   EA11155        ; LONG
                            	  1072: 
00:00008D36 30343000        	  1073:          MOVE.W  (A4,D3.W),D0
                            	  1074: 
00:00008D3A 0C010042        	  1075:          CMPI.B  #'B',D1
00:00008D3E 6610            	  1076:          BNE.S   EA11153        ; .WORD
                            	  1077: 
                            	  1078: ; BYTE SIZE; DATA ALLOWED
                            	  1079: ;  0000 0000 XXXX XXXX
                            	  1080: ;  1111 1111 1XXX XXXX
00:00008D40 2200            	  1081:          MOVE.L  D0,D1
00:00008D42 E049            	  1082:          LSR.W   #8,D1
00:00008D44 670A            	  1083:          BEQ.S   EA11153
00:00008D46 2200            	  1084:          MOVE.L  D0,D1
00:00008D48 EE41            	  1085:          ASR.W   #7,D1
00:00008D4A 5241            	  1086:          ADDQ.W  #1,D1
00:00008D4C 6600FF3A        	  1087:          BNE     FE11           ; FERROR
                            	  1088: 
00:00008D50 48C0            	  1089: EA11153: EXT.L   D0
00:00008D52 6100F842        	  1090:          BSR     HEX2DEC
00:00008D56 5483            	  1091:          ADDQ.L  #2,D3
00:00008D58 4E75            	  1092:          RTS
                            	  1093: 
00:00008D5A 20343000        	  1094: EA11155: MOVE.L  (A4,D3.W),D0
00:00008D5E 6100F836        	  1095:          BSR     HEX2DEC
00:00008D62 5883            	  1096:          ADDQ.L  #4,D3         ; SIZE
00:00008D64 4E75            	  1097:          RTS
                            	  1098: 
00:00008D66 1AFC002E        	  1099: MOVEMS:  MOVE.B  #'.',(A5)+    ; PERIOD
00:00008D6A 303C4C57        	  1100:          MOVE.W  #$4c57,D0    ; "LW"
00:00008D6E 08040006        	  1101:          BTST    #6,D4
00:00008D72 6702            	  1102:          BEQ.S   MOVEMS2
00:00008D74 E048            	  1103:          LSR.W   #8,D0
00:00008D76 1AC0            	  1104: MOVEMS2: MOVE.B  D0,(A5)+     ; SIZE
00:00008D78 4E75            	  1105:          RTS
                            	  1106: 
                            	  1107: ; MOVEM - REGISTER EXPANSION
                            	  1108: ;
                            	  1109: MOVEMR:  ;.align  2
00:00008D7A 342C0002        	  1110:          MOVE.W  2(A4),D2     ; D2 = SECOND WORD
00:00008D7E 7020            	  1111:          MOVEQ   #$20,D0      ; D0 = SPACE
00:00008D80 7E2F            	  1112:          MOVEQ   #$2F,D7      ; D7 = /
00:00008D82 538E            	  1113:          SUBQ.L  #1,A6         ; ADJUST STORE POINTER
00:00008D84 7A30            	  1114:          MOVEQ   #$30,D5      ; D5 = REGISTER #
00:00008D86 383C4144        	  1115:          MOVE.W  #$4144,D4    ; "AD" D4 = REG CLASS
                            	  1116: 
00:00008D8A 0302            	  1117: MOVEMR11:BTST    D1,D2
00:00008D8C 6730            	  1118:          BEQ.S   MOVEMR77       ; BIT RESET
                            	  1119: 
00:00008D8E B016            	  1120:          CMP.B   (A6),D0      ; BIT SET
00:00008D90 6612            	  1121:          BNE.S   MOVEMR44       ; NOT SPACE
                            	  1122: 
00:00008D92 1D440001        	  1123: MOVEMR33:MOVE.B  D4,1(A6)     ; REG TYPE
00:00008D96 1D450002        	  1124:          MOVE.B  D5,2(A6)     ; REG #
00:00008D9A 1D7C002D0003    	  1125:          MOVE.B  #'-',3(A6)    ; -
00:00008DA0 568E            	  1126:          ADDQ.L  #3,A6
00:00008DA2 602E            	  1127:          BRA.S   MOVEMR88
                            	  1128: 
                            	  1129: MOVEMR44:
00:00008DA4 0C16002C        	  1130: 	cmpi.b #',',(A6)
00:00008DA8 67E8            	  1131: 	beq.s MOVEMR33      ; COMMA SEPARATOR
00:00008DAA BE16            	  1132: 	cmp.b (A6),D7      	; / SEPARATOR
00:00008DAC 67E4            	  1133: 	beq.s MOVEMR33
00:00008DAE 1D440001        	  1134: 	move.b D4,1(A6)     ; REG TYPE
00:00008DB2 1D450002        	  1135: 	move.b D5,2(A6)     ; REG #
00:00008DB6 1D7C002D0003    	  1136: 	move.b #'-',3(A6)   ; - SEPARATOR
00:00008DBC 6014            	  1137: 	bra.s MOVEMR88
                            	  1138: 
                            	  1139: MOVEMR77:
00:00008DBE 0C16002C        	  1140: 	cmpi.b #',',(A6)
00:00008DC2 670E            	  1141: 	beq.s MOVEMR88       ; COMMA
00:00008DC4 B016            	  1142: 	cmp.b (A6),D0
00:00008DC6 670A            	  1143: 	beq.s MOVEMR88       ; SPACE
00:00008DC8 B02E0001        	  1144: 	cmp.b 1(A6),D0
00:00008DCC 6702            	  1145: 	beq.s MOVEMR79       ; SPACE
00:00008DCE 568E            	  1146: 	addq.l #3,A6
                            	  1147: MOVEMR79:
00:00008DD0 1C87            	  1148: 	move.b D7,(A6)      ; / SEPARATOR
                            	  1149: 
                            	  1150: MOVEMR88:
00:00008DD2 5285            	  1151: 	addq.l #1,D5
00:00008DD4 D286            	  1152: 	add.l D6,D1        ; D1 = BIT POSITION
00:00008DD6 0C050038        	  1153: 	cmpi.b #'8',D5
00:00008DDA 66AE            	  1154: 	bne.s MOVEMR11
00:00008DDC B016            	  1155: 	cmp.b (A6),D0      ; SPACE
00:00008DDE 670A            	  1156: 	beq.s MOVEMR94
00:00008DE0 B02E0001        	  1157: 	cmp.b 1(A6),D0     ; SPACE
00:00008DE4 6704            	  1158: 	beq.s MOVEMR94
00:00008DE6 568E            	  1159: 	addq.l #3,A6
00:00008DE8 1C87            	  1160: 	move.b D7,(A6)      ; /   SEPARATOR
                            	  1161: 
                            	  1162: MOVEMR94:
00:00008DEA 1A3C0030        	  1163: 	move.b #'0',D5       	; RESET REG TO ZERO
00:00008DEE E04C            	  1164: 	lsr.w #8,D4         	; CHANGE REG TYPE
00:00008DF0 6698            	  1165: 	bne.s MOVEMR11       	; MORE
00:00008DF2 1C80            	  1166: 	move.b D0,(A6)      	; SPACE
00:00008DF4 4E75            	  1167: 	rts
                            	  1168: 
                            	  1169: DCODE68K:
00:00008DF6 4E51FFF0        	  1170: 	link A1,#-LOCVARSZ 	; CREATE A FRAME FOR THE
00:00008DFA 48E91007FFF0    	  1171: 	movem.l D0-D2/A4,DDATA(A1)  ; CODE AND ITS PC.  A4
00:00008E00 49E9FFF0        	  1172: 	lea DDATA(A1),A4 		; POINTS TO THE CODE.
00:00008E04 264D            	  1173: 	move.l A5,A3        ; A3 = START OF OUTPUT BUFFER
00:00008E06 2C4D            	  1174: 	move.l A5,A6
00:00008E08 703F            	  1175: 	moveq #BUFSIZE,D0
                            	  1176: DEC311:
00:00008E0A 1CFC0020        	  1177:   move.b #BLANK,(a6)+  ; SPACE FILL BUFFER
00:00008E0E 5380            	  1178: 	subq.l #1,D0
00:00008E10 66F8            	  1179: 	bne.s DEC311
00:00008E12 421E            	  1180: 	clr.b (a6)+					; NULL temrinate
00:00008E14 2C4B            	  1181: 	move.l A3,A6        ; FORMAT ADDRESS
00:00008E16 2029FFFC        	  1182: 	move.l HISPC(A1),D0
00:00008E1A 6100F7F2        	  1183: 	bsr FRELADDR
                            	  1184: 
                            	  1185: ; CHECK FOR KNOWN ILLEGAL CODES
00:00008E1E 3014            	  1186: 	move.w (a4),d0
00:00008E20 4BFA00C0        	  1187: 	lea KI(PC),a5
00:00008E24 2C4D            	  1188: 	move.l a5,a6
00:00008E26 548E            	  1189: 	add.l #KIEND-KI,a6
                            	  1190: DEC404:
00:00008E28 B05D            	  1191:   cmp.w (a5)+,d0
00:00008E2A 671A            	  1192: 	beq.s FE12           ; FERROR;  ILLEGAL CODE
00:00008E2C BBCE            	  1193: 	cmp.l a6,a5
00:00008E2E 66F8            	  1194: 	bne.s DEC404
                            	  1195: 
                            	  1196: ; LOOK FOR MATCH OF OP-CODE
                            	  1197: ;
00:00008E30 4BFA00B2        	  1198: 	lea TBL(PC),A5   		; A5 = POINTER TO DECODE TABLE
00:00008E34 4DFA0366        	  1199: 	lea TBLE(PC),A6  		; A6 = POINTER TO END OF TABLE
                            	  1200: DEC411:
00:00008E38 3014            	  1201: 	move.w (A4),D0      ;  FIRST WORD
00:00008E3A C05D            	  1202: 	and.w (A5)+,D0     	;  MASK
00:00008E3C B05D            	  1203: 	cmp.w (A5)+,D0
00:00008E3E 6708            	  1204: 	beq.s DEC425        ; FOUND MATCH
00:00008E40 588D            	  1205: 	addq.l #4,A5        ; UPDATE POINTER
00:00008E42 BBCE            	  1206: 	cmp.l A6,A5
00:00008E44 65F2            	  1207: 	blo.s DEC411        ; MORE TABLE
                            	  1208: FE12:
00:00008E46 6070            	  1209: 	bra.s FERROR        ; ILLEGAL INSTRUCTION
                            	  1210: DEC425:
00:00008E48 7C00            	  1211:   clr.l D6
00:00008E4A 3C1D            	  1212: 	move.w (A5)+,D6     ; D6 = (GOTO OFFSET)/4
                            	  1213: ;         LSL.L   #2,D6
00:00008E4C 7E00            	  1214: 	clr.l D7
00:00008E4E 3E1D            	  1215: 	move.w (A5)+,D7     ; D7 = INDEX TO OP-CODE
                            	  1216: 
                            	  1217: ; MOVE OP-CODE TO BUFFER
                            	  1218: ;
00:00008E50 41FA034A        	  1219: 	lea OPCTBL(PC),A0
                            	  1220: DEC510:
00:00008E54 4A47            	  1221:   tst D7
00:00008E56 6708            	  1222: 	beq.s DEC530         	; AT INDEX
                            	  1223: DEC515:
00:00008E58 4A18            	  1224:   tst.b (A0)+
00:00008E5A 6AFC            	  1225: 	bpl.s DEC515         	; MOVE THROUGH FIELD
00:00008E5C 5387            	  1226: 	subq.l #1,D7
00:00008E5E 60F4            	  1227: 	bra.s DEC510
                            	  1228: DEC530:
00:00008E60 701F            	  1229: 	moveq #FOC,D0
00:00008E62 4BF30000        	  1230: 	lea.l (A3,D0.W),A5 		; A5 = STORE POINTER  OP-CODE
                            	  1231: DEC535:
00:00008E66 1018            	  1232:   move.b (A0)+,D0
00:00008E68 08800007        	  1233: 	bclr #7,D0
00:00008E6C 6604            	  1234: 	bne.s DEC537         	; END OF MOVE
00:00008E6E 1AC0            	  1235: 	move.b D0,(A5)+
00:00008E70 60F4            	  1236: 	bra.s DEC535
                            	  1237: DEC537:
00:00008E72 1AC0            	  1238:   move.b D0,(A5)+
                            	  1239: 
                            	  1240: ; CALCULATE GOTO AND GO
                            	  1241: ;
00:00008E74 7602            	  1242: 	moveq #2,D3         ; D3= SIZE
00:00008E76 41FAF7F4        	  1243: 	lea X(PC),A0
00:00008E7A D1C6            	  1244: 	add.l D6,A0
00:00008E7C 7027            	  1245: 	moveq #FOP,D0
00:00008E7E 4DF30000        	  1246: 	lea.l (A3,D0.W),A6 	; A6 = POINTER FOR OPERAND
00:00008E82 3814            	  1247: 	move.w (A4),D4      ; D4 = FIRST WORD
00:00008E84 1A3C002C        	  1248: 	move.b #',',D5      ; D5 = CONTAINS ASCII COMMA
00:00008E88 3E3C01FD        	  1249: 	move.w #$1FD,D7     ; D7 = DATA ALTERABLE MODES ALLOWED
00:00008E8C 4ED0            	  1250: 	jmp (A0)
                            	  1251: 
                            	  1252: ;	 A3 = pointer to beginning of buffer
                            	  1253: ;  A4 = POINTER TO DATA IN FRAME CREATED BY "LINK A1,..."
                            	  1254: ;  A5 = POINTER STORE OP-CODE
                            	  1255: ;  A6 = POINTER STORE OPERAND
                            	  1256: ;  D3 = SIZE = 2 BYTES
                            	  1257: ;  D4 = FIRST WORD
                            	  1258: ;  D7 = ADDRESS MODES ALLOWED ($1FD) DATA ALTERABLE
                            	  1259: 
                            	  1260: COMMON4:
00:00008E8E 5483            	  1261: 	addq.l #2,D3         	; SIZE = 4
                            	  1262: COMMON:
00:00008E90 2C03            	  1263: 	move.l D3,D6        	; D6 = SIZE
00:00008E92 1CFC0020        	  1264: 	move.b #BLANK,(A6)+ 	; SPACE AS LAST CHAR
00:00008E96 2A4E            	  1265: 	move.l A6,A5        	; SAVE END OF BUFFER POINTER
00:00008E98 700A            	  1266: 	moveq #FDATA,D0
00:00008E9A 4DF30000        	  1267: 	lea.l (A3,D0.W),A6
                            	  1268: COMMON35:
00:00008E9E 301C            	  1269: 	move.w (A4)+,D0     	; GET NEXT WORD OF DATA.
00:00008EA0 54A9FFFC        	  1270: 	addq.l #2,HISPC(A1)  	; ADJUST PROG COUNTER.
00:00008EA4 6100F754        	  1271: 	bsr PNT4HX         		; FORMAT DATA. (A6)+
00:00008EA8 5503            	  1272: 	subq.b #2,D3
00:00008EAA 66F2            	  1273: 	bne.s COMMON35
00:00008EAC 2C4D            	  1274: 	move.l A5,A6        	; A6 = RESTORE END POINTER
00:00008EAE 2A4B            	  1275: 	move.l A3,A5        	; A5 =  BEGINNING OF BUFFER
00:00008EB0 2869FFFC        	  1276: 	move.l HISPC(A1),A4 	; MOVE THE UPDATED PC
00:00008EB4 4E59            	  1277: 	unlk A1            		; TO A4 AND UNDO FRAME.
00:00008EB6 4E75            	  1278: 	rts
                            	  1279: 
                            	  1280: FERROR:  ;.align  2
                            	  1281: ; ILLEGAL INSTRUCTION
                            	  1282: ;
00:00008EB8 701F            	  1283: 	moveq #FOC,D0
00:00008EBA 4DF30000        	  1284: 	lea.l (A3,D0.W),A6
00:00008EBE 4BFA0018        	  1285: 	lea MSG111(PC),A5
                            	  1286: FERROR35:
00:00008EC2 101D            	  1287: 	move.b (A5)+,D0
00:00008EC4 0C000004        	  1288: 	cmpi.b #EOT,D0
00:00008EC8 6704            	  1289: 	beq.s FERROR39
00:00008ECA 1CC0            	  1290: 	move.b D0,(A6)+
00:00008ECC 60F4            	  1291: 	bra.s FERROR35
                            	  1292: FERROR39:
00:00008ECE 3014            	  1293: 	move.w (A4),D0
00:00008ED0 6100F728        	  1294: 	bsr PNT4HX
00:00008ED4 7602            	  1295: 	moveq #2,D3         ; SIZE
00:00008ED6 60B8            	  1296: 	bra.s COMMON
                            	  1297: MSG111:  
00:00008ED8 44432E5720202020	  1298: 	dc.b "DC.W    $"
00:00008EE0 24
00:00008EE1 04              	  1299: 	dc.b EOT
                            	  1300: 
                            	  1301: KI:
00:00008EE2 4AFB            	  1302: 	dc.w $4AFB         ; KNOWN ILLEGAL CODES
                            	  1303: KIEND:   
                            	  1304: 	even
                            	  1305: 
                            	  1306: ;  \1   MASK
                            	  1307: ;  \2   OP-CODE PATTERN
                            	  1308: ;  \3   GOTO OFFSET
                            	  1309: ;  \4   INDEX TO OP-CODE
                            	  1310: C68:     macro arg1,arg2,arg3,arg4
                            	  1311:          DC.W    $\1
                            	  1312:          DC.W    $\2
                            	  1313:          DC.W    (\3-X)
                            	  1314:          DC.w    \4
                            	  1315:          endm
                            	  1316: 
                            	  1317: 				 even
                            	  1318: TBL:     ;.align  2
                            	  1319:          C68     FEC0,E6C0,ISHIFT,56           ; RO
00:00008EE4 FEC0            	     1M          DC.W    $FEC0
00:00008EE6 E6C0            	     2M          DC.W    $E6C0
00:00008EE8 03B6            	     3M          DC.W    (ISHIFT-X)
00:00008EEA 0038            	     4M          DC.w    56
                            	  1320:          C68     FEC0,E4C0,ISHIFT,57           ; ROX
00:00008EEC FEC0            	     1M          DC.W    $FEC0
00:00008EEE E4C0            	     2M          DC.W    $E4C0
00:00008EF0 03B6            	     3M          DC.W    (ISHIFT-X)
00:00008EF2 0039            	     4M          DC.w    57
                            	  1321:          C68     FEC0,E2C0,ISHIFT,55           ; LS
00:00008EF4 FEC0            	     1M          DC.W    $FEC0
00:00008EF6 E2C0            	     2M          DC.W    $E2C0
00:00008EF8 03B6            	     3M          DC.W    (ISHIFT-X)
00:00008EFA 0037            	     4M          DC.w    55
                            	  1322:          C68     FEC0,E0C0,ISHIFT,54           ; AS
00:00008EFC FEC0            	     1M          DC.W    $FEC0
00:00008EFE E0C0            	     2M          DC.W    $E0C0
00:00008F00 03B6            	     3M          DC.W    (ISHIFT-X)
00:00008F02 0036            	     4M          DC.w    54
                            	  1323:          C68     F018,E018,ISHIFT,56           ; RO
00:00008F04 F018            	     1M          DC.W    $F018
00:00008F06 E018            	     2M          DC.W    $E018
00:00008F08 03B6            	     3M          DC.W    (ISHIFT-X)
00:00008F0A 0038            	     4M          DC.w    56
                            	  1324:          C68     F018,E010,ISHIFT,57           ; ROX
00:00008F0C F018            	     1M          DC.W    $F018
00:00008F0E E010            	     2M          DC.W    $E010
00:00008F10 03B6            	     3M          DC.W    (ISHIFT-X)
00:00008F12 0039            	     4M          DC.w    57
                            	  1325:          C68     F018,E008,ISHIFT,55           ; LS
00:00008F14 F018            	     1M          DC.W    $F018
00:00008F16 E008            	     2M          DC.W    $E008
00:00008F18 03B6            	     3M          DC.W    (ISHIFT-X)
00:00008F1A 0037            	     4M          DC.w    55
                            	  1326:          C68     F018,E000,ISHIFT,54           ; AS
00:00008F1C F018            	     1M          DC.W    $F018
00:00008F1E E000            	     2M          DC.W    $E000
00:00008F20 03B6            	     3M          DC.W    (ISHIFT-X)
00:00008F22 0036            	     4M          DC.w    54
                            	  1327:          C68     F0C0,D0C0,FORM10EX,4          ; ADD       <EA>,A@
00:00008F24 F0C0            	     1M          DC.W    $F0C0
00:00008F26 D0C0            	     2M          DC.W    $D0C0
00:00008F28 016A            	     3M          DC.W    (FORM10EX-X)
00:00008F2A 0004            	     4M          DC.w    4
                            	  1328:          C68     F130,D100,FORM12,53           ; ADDX
00:00008F2C F130            	     1M          DC.W    $F130
00:00008F2E D100            	     2M          DC.W    $D100
00:00008F30 0208            	     3M          DC.W    (FORM12-X)
00:00008F32 0035            	     4M          DC.w    53
                            	  1329:          C68     F000,D000,FORM10EX,4          ; ADD
00:00008F34 F000            	     1M          DC.W    $F000
00:00008F36 D000            	     2M          DC.W    $D000
00:00008F38 016A            	     3M          DC.W    (FORM10EX-X)
00:00008F3A 0004            	     4M          DC.w    4
                            	  1330:          C68     F1F8,C188,FORM9,50            ; EXG
00:00008F3C F1F8            	     1M          DC.W    $F1F8
00:00008F3E C188            	     2M          DC.W    $C188
00:00008F40 0160            	     3M          DC.W    (FORM9-X)
00:00008F42 0032            	     4M          DC.w    50
                            	  1331:          C68     F1F8,C148,FORM8,50            ; EXG
00:00008F44 F1F8            	     1M          DC.W    $F1F8
00:00008F46 C148            	     2M          DC.W    $C148
00:00008F48 0152            	     3M          DC.W    (FORM8-X)
00:00008F4A 0032            	     4M          DC.w    50
                            	  1332:          C68     F1F8,C140,FORM7,50            ; EXG
00:00008F4C F1F8            	     1M          DC.W    $F1F8
00:00008F4E C140            	     2M          DC.W    $C140
00:00008F50 0146            	     3M          DC.W    (FORM7-X)
00:00008F52 0032            	     4M          DC.w    50
                            	  1333:          C68     F1F0,C100,FORM12,49           ; ABCD
00:00008F54 F1F0            	     1M          DC.W    $F1F0
00:00008F56 C100            	     2M          DC.W    $C100
00:00008F58 0208            	     3M          DC.W    (FORM12-X)
00:00008F5A 0031            	     4M          DC.w    49
                            	  1334:          C68     F1C0,C1C0,FORM6D,48           ; MULS
00:00008F5C F1C0            	     1M          DC.W    $F1C0
00:00008F5E C1C0            	     2M          DC.W    $C1C0
00:00008F60 0120            	     3M          DC.W    (FORM6D-X)
00:00008F62 0030            	     4M          DC.w    48
                            	  1335:          C68     F1C0,C0C0,FORM6D,47           ; MULU
00:00008F64 F1C0            	     1M          DC.W    $F1C0
00:00008F66 C0C0            	     2M          DC.W    $C0C0
00:00008F68 0120            	     3M          DC.W    (FORM6D-X)
00:00008F6A 002F            	     4M          DC.w    47
                            	  1336:          C68     F000,C000,FORM10,2            ; AND
00:00008F6C F000            	     1M          DC.W    $F000
00:00008F6E C000            	     2M          DC.W    $C000
00:00008F70 01A8            	     3M          DC.W    (FORM10-X)
00:00008F72 0002            	     4M          DC.w    2
                            	  1337:          C68     F0C0,B0C0,FORM10EX,6          ; CMP     <EA>,A@
00:00008F74 F0C0            	     1M          DC.W    $F0C0
00:00008F76 B0C0            	     2M          DC.W    $B0C0
00:00008F78 016A            	     3M          DC.W    (FORM10EX-X)
00:00008F7A 0006            	     4M          DC.w    6
                            	  1338:          C68     F138,B108,FORM12A,46          ; CMPM
00:00008F7C F138            	     1M          DC.W    $F138
00:00008F7E B108            	     2M          DC.W    $B108
00:00008F80 0244            	     3M          DC.W    (FORM12A-X)
00:00008F82 002E            	     4M          DC.w    46
                            	  1339:          C68     F100,B100,FORM10,5            ; EOR
00:00008F84 F100            	     1M          DC.W    $F100
00:00008F86 B100            	     2M          DC.W    $B100
00:00008F88 01A8            	     3M          DC.W    (FORM10-X)
00:00008F8A 0005            	     4M          DC.w    5
                            	  1340:          C68     F000,B000,FORM10EX,6          ; CMP
00:00008F8C F000            	     1M          DC.W    $F000
00:00008F8E B000            	     2M          DC.W    $B000
00:00008F90 016A            	     3M          DC.W    (FORM10EX-X)
00:00008F92 0006            	     4M          DC.w    6
                            	  1341:          C68     F0C0,90C0,FORM10EX,44         ; SUB       <EA>,A@
00:00008F94 F0C0            	     1M          DC.W    $F0C0
00:00008F96 90C0            	     2M          DC.W    $90C0
00:00008F98 016A            	     3M          DC.W    (FORM10EX-X)
00:00008F9A 002C            	     4M          DC.w    44
                            	  1342:          C68     F130,9100,FORM12,45           ; SUBX
00:00008F9C F130            	     1M          DC.W    $F130
00:00008F9E 9100            	     2M          DC.W    $9100
00:00008FA0 0208            	     3M          DC.W    (FORM12-X)
00:00008FA2 002D            	     4M          DC.w    45
                            	  1343:          C68     F000,9000,FORM10EX,44         ; SUB
00:00008FA4 F000            	     1M          DC.W    $F000
00:00008FA6 9000            	     2M          DC.W    $9000
00:00008FA8 016A            	     3M          DC.W    (FORM10EX-X)
00:00008FAA 002C            	     4M          DC.w    44
                            	  1344:          C68     F1F0,8100,FORM12,43           ; SBCD
00:00008FAC F1F0            	     1M          DC.W    $F1F0
00:00008FAE 8100            	     2M          DC.W    $8100
00:00008FB0 0208            	     3M          DC.W    (FORM12-X)
00:00008FB2 002B            	     4M          DC.w    43
                            	  1345:          C68     F1C0,81C0,FORM6D,42           ; DIVS
00:00008FB4 F1C0            	     1M          DC.W    $F1C0
00:00008FB6 81C0            	     2M          DC.W    $81C0
00:00008FB8 0120            	     3M          DC.W    (FORM6D-X)
00:00008FBA 002A            	     4M          DC.w    42
                            	  1346:          C68     F1C0,80C0,FORM6D,41           ; DIVU
00:00008FBC F1C0            	     1M          DC.W    $F1C0
00:00008FBE 80C0            	     2M          DC.W    $80C0
00:00008FC0 0120            	     3M          DC.W    (FORM6D-X)
00:00008FC2 0029            	     4M          DC.w    41
                            	  1347:          C68     F000,8000,FORM10,40           ; OR
00:00008FC4 F000            	     1M          DC.W    $F000
00:00008FC6 8000            	     2M          DC.W    $8000
00:00008FC8 01A8            	     3M          DC.W    (FORM10-X)
00:00008FCA 0028            	     4M          DC.w    40
                            	  1348:          C68     F100,7000,IMOVEQ,39           ; MOVEQ
00:00008FCC F100            	     1M          DC.W    $F100
00:00008FCE 7000            	     2M          DC.W    $7000
00:00008FD0 0270            	     3M          DC.W    (IMOVEQ-X)
00:00008FD2 0027            	     4M          DC.w    39
                            	  1349:          C68     FF00,6100,IBSR,51             ; BSR
00:00008FD4 FF00            	     1M          DC.W    $FF00
00:00008FD6 6100            	     2M          DC.W    $6100
00:00008FD8 0354            	     3M          DC.W    (IBSR-X)
00:00008FDA 0033            	     4M          DC.w    51
                            	  1350:          C68     FF00,6000,IBSR,65             ; BRA
00:00008FDC FF00            	     1M          DC.W    $FF00
00:00008FDE 6000            	     2M          DC.W    $6000
00:00008FE0 0354            	     3M          DC.W    (IBSR-X)
00:00008FE2 0041            	     4M          DC.w    65
                            	  1351:          C68     F000,6000,ICC,38              ; B
00:00008FE4 F000            	     1M          DC.W    $F000
00:00008FE6 6000            	     2M          DC.W    $6000
00:00008FE8 0350            	     3M          DC.W    (ICC-X)
00:00008FEA 0026            	     4M          DC.w    38
                            	  1352:          C68     F0F8,50C8,IDBCC,37            ; DB
00:00008FEC F0F8            	     1M          DC.W    $F0F8
00:00008FEE 50C8            	     2M          DC.W    $50C8
00:00008FF0 033E            	     3M          DC.W    (IDBCC-X)
00:00008FF2 0025            	     4M          DC.w    37
                            	  1353:          C68     F0C0,50C0,ISCC,36             ; S
00:00008FF4 F0C0            	     1M          DC.W    $F0C0
00:00008FF6 50C0            	     2M          DC.W    $50C0
00:00008FF8 0334            	     3M          DC.W    (ISCC-X)
00:00008FFA 0024            	     4M          DC.w    36
                            	  1354:          C68     F100,5100,IQUICK,35           ; SUBQ
00:00008FFC F100            	     1M          DC.W    $F100
00:00008FFE 5100            	     2M          DC.W    $5100
00:00009000 026C            	     3M          DC.W    (IQUICK-X)
00:00009002 0023            	     4M          DC.w    35
                            	  1355:          C68     F100,5000,IQUICK,34           ; ADDQ
00:00009004 F100            	     1M          DC.W    $F100
00:00009006 5000            	     2M          DC.W    $5000
00:00009008 026C            	     3M          DC.W    (IQUICK-X)
00:0000900A 0022            	     4M          DC.w    34
                            	  1356:          C68     F1C0,41C0,FORM6A,33           ; LEA
00:0000900C F1C0            	     1M          DC.W    $F1C0
00:0000900E 41C0            	     2M          DC.W    $41C0
00:00009010 0110            	     3M          DC.W    (FORM6A-X)
00:00009012 0021            	     4M          DC.w    33
                            	  1357:          C68     F1C0,4180,FORM6D,32           ; CHK
00:00009014 F1C0            	     1M          DC.W    $F1C0
00:00009016 4180            	     2M          DC.W    $4180
00:00009018 0120            	     3M          DC.W    (FORM6D-X)
00:0000901A 0020            	     4M          DC.w    32
                            	  1358:          C68     FFC0,4EC0,FORM11SL,31         ; JMP
00:0000901C FFC0            	     1M          DC.W    $FFC0
00:0000901E 4EC0            	     2M          DC.W    $4EC0
00:00009020 01E4            	     3M          DC.W    (FORM11SL-X)
00:00009022 001F            	     4M          DC.w    31
                            	  1359:          C68     FFC0,4E80,FORM11SL,30         ; JSR
00:00009024 FFC0            	     1M          DC.W    $FFC0
00:00009026 4E80            	     2M          DC.W    $4E80
00:00009028 01E4            	     3M          DC.W    (FORM11SL-X)
00:0000902A 001E            	     4M          DC.w    30
                            	  1360:          C68     FFFF,4E77,SCOMMON,29          ; RTR
00:0000902C FFFF            	     1M          DC.W    $FFFF
00:0000902E 4E77            	     2M          DC.W    $4E77
00:00009030 0330            	     3M          DC.W    (SCOMMON-X)
00:00009032 001D            	     4M          DC.w    29
                            	  1361:          C68     FFFF,4E76,SCOMMON,28          ; TRAPV
00:00009034 FFFF            	     1M          DC.W    $FFFF
00:00009036 4E76            	     2M          DC.W    $4E76
00:00009038 0330            	     3M          DC.W    (SCOMMON-X)
00:0000903A 001C            	     4M          DC.w    28
                            	  1362:          C68     FFFF,4E75,SCOMMON,27          ; RTS
00:0000903C FFFF            	     1M          DC.W    $FFFF
00:0000903E 4E75            	     2M          DC.W    $4E75
00:00009040 0330            	     3M          DC.W    (SCOMMON-X)
00:00009042 001B            	     4M          DC.w    27
                            	  1363:          C68     FFFF,4E73,SCOMMON,26          ; RTE
00:00009044 FFFF            	     1M          DC.W    $FFFF
00:00009046 4E73            	     2M          DC.W    $4E73
00:00009048 0330            	     3M          DC.W    (SCOMMON-X)
00:0000904A 001A            	     4M          DC.w    26
                            	  1364:          C68     FFFF,4E72,ISTOP,25            ; STOP
00:0000904C FFFF            	     1M          DC.W    $FFFF
00:0000904E 4E72            	     2M          DC.W    $4E72
00:00009050 004A            	     3M          DC.W    (ISTOP-X)
00:00009052 0019            	     4M          DC.w    25
                            	  1365:          C68     FFFF,4E71,SCOMMON,24          ; NOP
00:00009054 FFFF            	     1M          DC.W    $FFFF
00:00009056 4E71            	     2M          DC.W    $4E71
00:00009058 0330            	     3M          DC.W    (SCOMMON-X)
00:0000905A 0018            	     4M          DC.w    24
                            	  1366:          C68     FFFF,4E70,SCOMMON,23          ; RESET
00:0000905C FFFF            	     1M          DC.W    $FFFF
00:0000905E 4E70            	     2M          DC.W    $4E70
00:00009060 0330            	     3M          DC.W    (SCOMMON-X)
00:00009062 0017            	     4M          DC.w    23
                            	  1367:          C68     FFF8,4E68,IMVFUSP,60          ; MOVE FROM USP
00:00009064 FFF8            	     1M          DC.W    $FFF8
00:00009066 4E68            	     2M          DC.W    $4E68
00:00009068 029E            	     3M          DC.W    (IMVFUSP-X)
00:0000906A 003C            	     4M          DC.w    60
                            	  1368:          C68     FFF8,4E60,IMVTUSP,60          ; MOVE TO USP
00:0000906C FFF8            	     1M          DC.W    $FFF8
00:0000906E 4E60            	     2M          DC.W    $4E60
00:00009070 02BE            	     3M          DC.W    (IMVTUSP-X)
00:00009072 003C            	     4M          DC.w    60
                            	  1369:          C68     FFF8,4E58,FORM5,22            ; UNLINK
00:00009074 FFF8            	     1M          DC.W    $FFF8
00:00009076 4E58            	     2M          DC.W    $4E58
00:00009078 010C            	     3M          DC.W    (FORM5-X)
00:0000907A 0016            	     4M          DC.w    22
                            	  1370:          C68     FFF8,4E50,ILINK,21            ; LINK
00:0000907C FFF8            	     1M          DC.W    $FFF8
00:0000907E 4E50            	     2M          DC.W    $4E50
00:00009080 00D6            	     3M          DC.W    (ILINK-X)
00:00009082 0015            	     4M          DC.w    21
                            	  1371:          C68     FFF0,4E40,FORM4,20            ; TRAP
00:00009084 FFF0            	     1M          DC.W    $FFF0
00:00009086 4E40            	     2M          DC.W    $4E40
00:00009088 00FA            	     3M          DC.W    (FORM4-X)
00:0000908A 0014            	     4M          DC.w    20
                            	  1372:          C68     FF80,4C80,IMOVEMTR,15         ; MOVEM FROM REGISTERS
00:0000908C FF80            	     1M          DC.W    $FF80
00:0000908E 4C80            	     2M          DC.W    $4C80
00:00009090 002E            	     3M          DC.W    (IMOVEMTR-X)
00:00009092 000F            	     4M          DC.w    15
                            	  1373:          C68     FFC0,4AC0,FORM1A,19           ; TAS
00:00009094 FFC0            	     1M          DC.W    $FFC0
00:00009096 4AC0            	     2M          DC.W    $4AC0
00:00009098 00F0            	     3M          DC.W    (FORM1A-X)
00:0000909A 0013            	     4M          DC.w    19
                            	  1374:          C68     FF00,4A00,FORM1,18            ; TST
00:0000909C FF00            	     1M          DC.W    $FF00
00:0000909E 4A00            	     2M          DC.W    $4A00
00:000090A0 00EC            	     3M          DC.W    (FORM1-X)
00:000090A2 0012            	     4M          DC.w    18
                            	  1375:          C68     FFF8,48C0,FORM3,17            ; EXT.L
00:000090A4 FFF8            	     1M          DC.W    $FFF8
00:000090A6 48C0            	     2M          DC.W    $48C0
00:000090A8 00F6            	     3M          DC.W    (FORM3-X)
00:000090AA 0011            	     4M          DC.w    17
                            	  1376:          C68     FFF8,4880,FORM3,16            ; EXT.W
00:000090AC FFF8            	     1M          DC.W    $FFF8
00:000090AE 4880            	     2M          DC.W    $4880
00:000090B0 00F6            	     3M          DC.W    (FORM3-X)
00:000090B2 0010            	     4M          DC.w    16
                            	  1377:          C68     FF80,4880,IMOVEMFR,15         ; MOVEA TO REGISTERS
00:000090B4 FF80            	     1M          DC.W    $FF80
00:000090B6 4880            	     2M          DC.W    $4880
00:000090B8 0000            	     3M          DC.W    (IMOVEMFR-X)
00:000090BA 000F            	     4M          DC.w    15
                            	  1378:          C68     FFF8,4840,FORM3,14            ; SWAP
00:000090BC FFF8            	     1M          DC.W    $FFF8
00:000090BE 4840            	     2M          DC.W    $4840
00:000090C0 00F6            	     3M          DC.W    (FORM3-X)
00:000090C2 000E            	     4M          DC.w    14
                            	  1379:          C68     FFC0,4840,FORM11,13           ; PEA
00:000090C4 FFC0            	     1M          DC.W    $FFC0
00:000090C6 4840            	     2M          DC.W    $4840
00:000090C8 01DC            	     3M          DC.W    (FORM11-X)
00:000090CA 000D            	     4M          DC.w    13
                            	  1380:          C68     FFC0,4800,FORM1A,12           ; NBCD
00:000090CC FFC0            	     1M          DC.W    $FFC0
00:000090CE 4800            	     2M          DC.W    $4800
00:000090D0 00F0            	     3M          DC.W    (FORM1A-X)
00:000090D2 000C            	     4M          DC.w    12
                            	  1381:          C68     FFC0,46C0,IMVTSR,59           ; MOVE TO SR
00:000090D4 FFC0            	     1M          DC.W    $FFC0
00:000090D6 46C0            	     2M          DC.W    $46C0
00:000090D8 02AC            	     3M          DC.W    (IMVTSR-X)
00:000090DA 003B            	     4M          DC.w    59
                            	  1382:          C68     FF00,4600,FORM1,11            ; NOT
00:000090DC FF00            	     1M          DC.W    $FF00
00:000090DE 4600            	     2M          DC.W    $4600
00:000090E0 00EC            	     3M          DC.W    (FORM1-X)
00:000090E2 000B            	     4M          DC.w    11
                            	  1383:          C68     FFC0,44C0,IMVTCCR,59          ; MOVE TO CCR
00:000090E4 FFC0            	     1M          DC.W    $FFC0
00:000090E6 44C0            	     2M          DC.W    $44C0
00:000090E8 02CA            	     3M          DC.W    (IMVTCCR-X)
00:000090EA 003B            	     4M          DC.w    59
                            	  1384:          C68     FF00,4400,FORM1,10            ; NEG
00:000090EC FF00            	     1M          DC.W    $FF00
00:000090EE 4400            	     2M          DC.W    $4400
00:000090F0 00EC            	     3M          DC.W    (FORM1-X)
00:000090F2 000A            	     4M          DC.w    10
                            	  1385:          C68     FF00,4200,FORM1,9             ; CLR
00:000090F4 FF00            	     1M          DC.W    $FF00
00:000090F6 4200            	     2M          DC.W    $4200
00:000090F8 00EC            	     3M          DC.W    (FORM1-X)
00:000090FA 0009            	     4M          DC.w    9
                            	  1386:          C68     FFC0,40C0,IMVFSR,59           ; MOVE.W  FROM  SR
00:000090FC FFC0            	     1M          DC.W    $FFC0
00:000090FE 40C0            	     2M          DC.W    $40C0
00:00009100 0290            	     3M          DC.W    (IMVFSR-X)
00:00009102 003B            	     4M          DC.w    59
                            	  1387:          C68     FF00,4000,FORM1,8             ; NEGX
00:00009104 FF00            	     1M          DC.W    $FF00
00:00009106 4000            	     2M          DC.W    $4000
00:00009108 00EC            	     3M          DC.W    (FORM1-X)
00:0000910A 0008            	     4M          DC.w    8
                            	  1388:          C68     F000,3000,IMOVE,59            ; MOVE.W
00:0000910C F000            	     1M          DC.W    $F000
00:0000910E 3000            	     2M          DC.W    $3000
00:00009110 00D2            	     3M          DC.W    (IMOVE-X)
00:00009112 003B            	     4M          DC.w    59
                            	  1389:          C68     F000,2000,IMOVE,60            ; MOVE.L
00:00009114 F000            	     1M          DC.W    $F000
00:00009116 2000            	     2M          DC.W    $2000
00:00009118 00D2            	     3M          DC.W    (IMOVE-X)
00:0000911A 003C            	     4M          DC.w    60
                            	  1390:          C68     F000,1000,IMOVE,58            ; MOVE.B
00:0000911C F000            	     1M          DC.W    $F000
00:0000911E 1000            	     2M          DC.W    $1000
00:00009120 00D2            	     3M          DC.W    (IMOVE-X)
00:00009122 003A            	     4M          DC.w    58
                            	  1391:          C68     FF00,0C00,IMMED,6             ; CMP       #
00:00009124 FF00            	     1M          DC.W    $FF00
00:00009126 0C00            	     2M          DC.W    $0C00
00:00009128 005E            	     3M          DC.W    (IMMED-X)
00:0000912A 0006            	     4M          DC.w    6
                            	  1392:          C68     FF00,0A00,IMMED,5             ; EOR       #
00:0000912C FF00            	     1M          DC.W    $FF00
00:0000912E 0A00            	     2M          DC.W    $0A00
00:00009130 005E            	     3M          DC.W    (IMMED-X)
00:00009132 0005            	     4M          DC.w    5
                            	  1393:          C68     FF00,0600,IMMED,4             ; ADD       #
00:00009134 FF00            	     1M          DC.W    $FF00
00:00009136 0600            	     2M          DC.W    $0600
00:00009138 005E            	     3M          DC.W    (IMMED-X)
00:0000913A 0004            	     4M          DC.w    4
                            	  1394:          C68     FF00,0400,IMMED,3             ; SUB       #
00:0000913C FF00            	     1M          DC.W    $FF00
00:0000913E 0400            	     2M          DC.W    $0400
00:00009140 005E            	     3M          DC.W    (IMMED-X)
00:00009142 0003            	     4M          DC.w    3
                            	  1395:          C68     FF00,0200,IMMED,2             ; AND       #
00:00009144 FF00            	     1M          DC.W    $FF00
00:00009146 0200            	     2M          DC.W    $0200
00:00009148 005E            	     3M          DC.W    (IMMED-X)
00:0000914A 0002            	     4M          DC.w    2
                            	  1396:          C68     FF00,0000,IMMED,1             ; OR        #
00:0000914C FF00            	     1M          DC.W    $FF00
00:0000914E 0000            	     2M          DC.W    $0000
00:00009150 005E            	     3M          DC.W    (IMMED-X)
00:00009152 0001            	     4M          DC.w    1
                            	  1397:          C68     F138,0108,IMOVEP,0            ; MOVEP
00:00009154 F138            	     1M          DC.W    $F138
00:00009156 0108            	     2M          DC.W    $0108
00:00009158 02DA            	     3M          DC.W    (IMOVEP-X)
00:0000915A 0000            	     4M          DC.w    0
                            	  1398:          C68     FFC0,08C0,ISETS,64            ; BSET
00:0000915C FFC0            	     1M          DC.W    $FFC0
00:0000915E 08C0            	     2M          DC.W    $08C0
00:00009160 039C            	     3M          DC.W    (ISETS-X)
00:00009162 0040            	     4M          DC.w    64
                            	  1399:          C68     FFC0,0880,ISETS,63            ; BCLR
00:00009164 FFC0            	     1M          DC.W    $FFC0
00:00009166 0880            	     2M          DC.W    $0880
00:00009168 039C            	     3M          DC.W    (ISETS-X)
00:0000916A 003F            	     4M          DC.w    63
                            	  1400:          C68     FFC0,0840,ISETS,62            ; BCHG
00:0000916C FFC0            	     1M          DC.W    $FFC0
00:0000916E 0840            	     2M          DC.W    $0840
00:00009170 039C            	     3M          DC.W    (ISETS-X)
00:00009172 003E            	     4M          DC.w    62
                            	  1401:          C68     FFC0,0800,ISETS,61            ; BTST
00:00009174 FFC0            	     1M          DC.W    $FFC0
00:00009176 0800            	     2M          DC.W    $0800
00:00009178 039C            	     3M          DC.W    (ISETS-X)
00:0000917A 003D            	     4M          DC.w    61
                            	  1402:          C68     F1C0,01C0,ISETD,64            ; BSET
00:0000917C F1C0            	     1M          DC.W    $F1C0
00:0000917E 01C0            	     2M          DC.W    $01C0
00:00009180 038C            	     3M          DC.W    (ISETD-X)
00:00009182 0040            	     4M          DC.w    64
                            	  1403:          C68     F1C0,0180,ISETD,63            ; BCLR
00:00009184 F1C0            	     1M          DC.W    $F1C0
00:00009186 0180            	     2M          DC.W    $0180
00:00009188 038C            	     3M          DC.W    (ISETD-X)
00:0000918A 003F            	     4M          DC.w    63
                            	  1404:          C68     F1C0,0140,ISETD,62            ; BCHG
00:0000918C F1C0            	     1M          DC.W    $F1C0
00:0000918E 0140            	     2M          DC.W    $0140
00:00009190 038C            	     3M          DC.W    (ISETD-X)
00:00009192 003E            	     4M          DC.w    62
                            	  1405:          C68     F1C0,0100,ISETD,61            ; BTST
00:00009194 F1C0            	     1M          DC.W    $F1C0
00:00009196 0100            	     2M          DC.W    $0100
00:00009198 038C            	     3M          DC.W    (ISETD-X)
00:0000919A 003D            	     4M          DC.w    61
                            	  1406: TBLE:
                            	  1407:           even
                            	  1408: 
                            	  1409: N68:     macro arg1,arg2
                            	  1410:          dc.b  "\1",\2
                            	  1411:          endm
                            	  1412: 
                            	  1413: 				even
                            	  1414: OPCTBL:  ;.align  2
                            	  1415:          N68     MOVE,$d0    ; 0
00:0000919C 4D4F5645        	     1M          dc.b  "MOVE",$d0
00:000091A0 D0
                            	  1416:          N68     O,$d2       ; 1
00:000091A1 4F              	     1M          dc.b  "O",$d2
00:000091A2 D2
                            	  1417:          N68     AN,$c4      ; 2
00:000091A3 414E            	     1M          dc.b  "AN",$c4
00:000091A5 C4
                            	  1418:          N68     SU,$c2      ; 3
00:000091A6 5355            	     1M          dc.b  "SU",$c2
00:000091A8 C2
                            	  1419:          N68     AD,$c4      ; 4
00:000091A9 4144            	     1M          dc.b  "AD",$c4
00:000091AB C4
                            	  1420:          N68     EO,$d2      ; 5
00:000091AC 454F            	     1M          dc.b  "EO",$d2
00:000091AE D2
                            	  1421:          N68     CM,$d0      ; 6
00:000091AF 434D            	     1M          dc.b  "CM",$d0
00:000091B1 D0
                            	  1422:          N68     MOV,$c5     ; 7
00:000091B2 4D4F56          	     1M          dc.b  "MOV",$c5
00:000091B5 C5
                            	  1423:          N68     NEG,$d8     ; 8
00:000091B6 4E4547          	     1M          dc.b  "NEG",$d8
00:000091B9 D8
                            	  1424:          N68     CL,$d2      ; 9
00:000091BA 434C            	     1M          dc.b  "CL",$d2
00:000091BC D2
                            	  1425:          N68     NE,$c7      ; 10
00:000091BD 4E45            	     1M          dc.b  "NE",$c7
00:000091BF C7
                            	  1426:          N68     NO,$d4      ; 11
00:000091C0 4E4F            	     1M          dc.b  "NO",$d4
00:000091C2 D4
                            	  1427:          N68     NBC,$c4     ; 12
00:000091C3 4E4243          	     1M          dc.b  "NBC",$c4
00:000091C6 C4
                            	  1428:          N68     PEA.,$cc    ; 13
00:000091C7 5045412E        	     1M          dc.b  "PEA.",$cc
00:000091CB CC
                            	  1429:          N68     SWAP.,$d7   ; 14
00:000091CC 535741502E      	     1M          dc.b  "SWAP.",$d7
00:000091D1 D7
                            	  1430:          N68     MOVE,$cd    ; 15
00:000091D2 4D4F5645        	     1M          dc.b  "MOVE",$cd
00:000091D6 CD
                            	  1431:          N68     EXT.,$d7    ; 16
00:000091D7 4558542E        	     1M          dc.b  "EXT.",$d7
00:000091DB D7
                            	  1432:          N68     EXT.,$cc    ; 17
00:000091DC 4558542E        	     1M          dc.b  "EXT.",$cc
00:000091E0 CC
                            	  1433:          N68     TS,$d4      ; 18
00:000091E1 5453            	     1M          dc.b  "TS",$d4
00:000091E3 D4
                            	  1434:          N68     TAS.,$c2    ; 19
00:000091E4 5441532E        	     1M          dc.b  "TAS.",$c2
00:000091E8 C2
                            	  1435:          N68     TRA,$d0     ; 20
00:000091E9 545241          	     1M          dc.b  "TRA",$d0
00:000091EC D0
                            	  1436:          N68     LIN,$cb     ; 21
00:000091ED 4C494E          	     1M          dc.b  "LIN",$cb
00:000091F0 CB
                            	  1437:          N68     UNL,$cb     ; 22
00:000091F1 554E4C          	     1M          dc.b  "UNL",$cb
00:000091F4 CB
                            	  1438:          N68     RESE,$d4    ; 23
00:000091F5 52455345        	     1M          dc.b  "RESE",$d4
00:000091F9 D4
                            	  1439:          N68     NO,$d0      ; 24
00:000091FA 4E4F            	     1M          dc.b  "NO",$d0
00:000091FC D0
                            	  1440:          N68     STO,$d0     ; 25
00:000091FD 53544F          	     1M          dc.b  "STO",$d0
00:00009200 D0
                            	  1441:          N68     RT,$c5      ; 26
00:00009201 5254            	     1M          dc.b  "RT",$c5
00:00009203 C5
                            	  1442:          N68     RT,$d3      ; 27
00:00009204 5254            	     1M          dc.b  "RT",$d3
00:00009206 D3
                            	  1443:          N68     TRAP,$d6    ; 28
00:00009207 54524150        	     1M          dc.b  "TRAP",$d6
00:0000920B D6
                            	  1444:          N68     RT,$d2      ; 29
00:0000920C 5254            	     1M          dc.b  "RT",$d2
00:0000920E D2
                            	  1445:          N68     JS,$d2      ; 30
00:0000920F 4A53            	     1M          dc.b  "JS",$d2
00:00009211 D2
                            	  1446:          N68     JM,$d0      ; 31
00:00009212 4A4D            	     1M          dc.b  "JM",$d0
00:00009214 D0
                            	  1447:          N68     CHK.,$d7    ; 32
00:00009215 43484B2E        	     1M          dc.b  "CHK.",$d7
00:00009219 D7
                            	  1448:          N68     LEA.,$cc    ; 33
00:0000921A 4C45412E        	     1M          dc.b  "LEA.",$cc
00:0000921E CC
                            	  1449:          N68     ADD,$d1     ; 34
00:0000921F 414444          	     1M          dc.b  "ADD",$d1
00:00009222 D1
                            	  1450:          N68     SUB,$d1     ; 35
00:00009223 535542          	     1M          dc.b  "SUB",$d1
00:00009226 D1
00:00009227 D3              	  1451:          DC.B    $d3         ; 36
                            	  1452:          N68     D,$c2       ; 37
00:00009228 44              	     1M          dc.b  "D",$c2
00:00009229 C2
00:0000922A C2              	  1453:          DC.B    $c2         ; 38
                            	  1454:          N68     MOVEQ.,$cc  ; .....39
00:0000922B 4D4F5645512E    	     1M          dc.b  "MOVEQ.",$cc
00:00009231 CC
                            	  1455:          N68     O,$d2       ; 40
00:00009232 4F              	     1M          dc.b  "O",$d2
00:00009233 D2
                            	  1456:          N68     DIVU.,$d7   ; 41
00:00009234 444956552E      	     1M          dc.b  "DIVU.",$d7
00:00009239 D7
                            	  1457:          N68     DIVS.,$d7   ; 42
00:0000923A 444956532E      	     1M          dc.b  "DIVS.",$d7
00:0000923F D7
                            	  1458:          N68     SBC,$c4     ; 43
00:00009240 534243          	     1M          dc.b  "SBC",$c4
00:00009243 C4
                            	  1459:          N68     SU,$c2      ; 44
00:00009244 5355            	     1M          dc.b  "SU",$c2
00:00009246 C2
                            	  1460:          N68     SUB,$d8     ; 45
00:00009247 535542          	     1M          dc.b  "SUB",$d8
00:0000924A D8
                            	  1461:          N68     CMP,$cd     ; 46
00:0000924B 434D50          	     1M          dc.b  "CMP",$cd
00:0000924E CD
                            	  1462:          N68     MULU.,$d7   ; 47
00:0000924F 4D554C552E      	     1M          dc.b  "MULU.",$d7
00:00009254 D7
                            	  1463:          N68     MULS.,$d7   ; 48
00:00009255 4D554C532E      	     1M          dc.b  "MULS.",$d7
00:0000925A D7
                            	  1464:          N68     ABC,$c4     ; 49
00:0000925B 414243          	     1M          dc.b  "ABC",$c4
00:0000925E C4
                            	  1465:          N68     EX,$c7      ; 50
00:0000925F 4558            	     1M          dc.b  "EX",$c7
00:00009261 C7
                            	  1466:          N68     BS,$d2      ; .....51
00:00009262 4253            	     1M          dc.b  "BS",$d2
00:00009264 D2
                            	  1467:          N68     NUL,$cc     ; .....52
00:00009265 4E554C          	     1M          dc.b  "NUL",$cc
00:00009268 CC
                            	  1468:          N68     ADD,$d8     ; 53
00:00009269 414444          	     1M          dc.b  "ADD",$d8
00:0000926C D8
                            	  1469:          N68     A,$d3       ; 54
00:0000926D 41              	     1M          dc.b  "A",$d3
00:0000926E D3
                            	  1470:          N68     L,$d3       ; 55
00:0000926F 4C              	     1M          dc.b  "L",$d3
00:00009270 D3
                            	  1471:          N68     R,$cf       ; 56
00:00009271 52              	     1M          dc.b  "R",$cf
00:00009272 CF
                            	  1472:          N68     RO,$d8      ; 57
00:00009273 524F            	     1M          dc.b  "RO",$d8
00:00009275 D8
                            	  1473:          N68     MOVE.,$c2   ; 58
00:00009276 4D4F56452E      	     1M          dc.b  "MOVE.",$c2
00:0000927B C2
                            	  1474:          N68     MOVE.,$d7   ; 59
00:0000927C 4D4F56452E      	     1M          dc.b  "MOVE.",$d7
00:00009281 D7
                            	  1475:          N68     MOVE.,$cc   ; 60
00:00009282 4D4F56452E      	     1M          dc.b  "MOVE.",$cc
00:00009287 CC
                            	  1476:          N68     BTS,$d4     ; 61
00:00009288 425453          	     1M          dc.b  "BTS",$d4
00:0000928B D4
                            	  1477:          N68     BCH,$c7     ; 62
00:0000928C 424348          	     1M          dc.b  "BCH",$c7
00:0000928F C7
                            	  1478:          N68     BCL,$d2     ; 63
00:00009290 42434C          	     1M          dc.b  "BCL",$d2
00:00009293 D2
                            	  1479:          N68     BSE,$d4     ; 64
00:00009294 425345          	     1M          dc.b  "BSE",$d4
00:00009297 D4
                            	  1480:          N68     BR,$c1      ; 65
00:00009298 4252            	     1M          dc.b  "BR",$c1
00:0000929A C1
                            	  1481: 
00:0000929B 00              	  1482:          DC.B    0         ; PAD BYTE
                            	  1483: 
                            	  1484: 

Source: "boot.x68"
                            	  5001: 


Symbols by name:
ABCD_INNER1                     00:00002B9E
ABCD_INNER2                     00:00002C0C
ABCD_NO_C1                      00:00002BBA
ABCD_NO_C2                      00:00002BC2
ABCD_NO_C3                      00:00002C28
ABCD_NO_C4                      00:00002C30
ABCD_OUTER1                     00:00002B9C
ABCD_OUTER2                     00:00002C0A
ABS                             00:00005280
ACIA                             E:FD060000
ACIA_CMD                         E:00000008
ACIA_CTRL                        E:0000000C
ACIA_RX                          E:00000000
ACIA_STAT                        E:00000004
ACIA_TX                          E:00000000
ADDA_OUTER1                     00:0000370C
ADDQ_LOOP1                      00:00002F26
ADDQ_LOOP2                      00:00002F64
ADDQ_LOOP3                      00:00002F9A
ADDX_LOOP3                      00:00003832
ADDX_LOOP4                      00:0000384E
ADDX_LOOP5                      00:0000386A
ADDX_OUTER1                     00:0000379E
ADD_OUTER1                      00:00003532
ADD_OUTER2                      00:000035A6
AHOW                            00:000054F8
ALL_DONE                        00:00000900
AND_OUTER1                      00:00003250
AND_OUTER2                      00:000032C4
ASORRY                          00:000054F0
AUXIN                           00:0000581C
AUXOUT                          00:00005808
AWHAT                           00:000054B0
AXIRET                          00:0000583A
AllocateString                  00:00004F98
ArmAllBreakpoints               00:00008092
ArmBreakpoint                   00:000080C2
AsciiToHexNybble                00:00007770
AudioInputTest                  00:00007B08
BCC1                            00:00002E44
BCC10                           00:00002E96
BCC11                           00:00002E9E
BCC12                           00:00002EA8
BCC13                           00:00002EB0
BCC14                           00:00002EBA
BCC2                            00:00002E4E
BCC3                            00:00002E56
BCC4                            00:00002E60
BCC5                            00:00002E68
BCC6                            00:00002E72
BCC7                            00:00002E7A
BCC8                            00:00002E84
BCC9                            00:00002E8C
BLANK                            E:00000020
BRTBL                           00:00008A9E
BSR_CLOSE1                      00:000019D4
BSR_CLOSE2                      00:00001A0A
BSR_FAR1                        00:00000902
BSR_FAR2                        00:00002E34
BUFFER                          00:0000590C
BUFLEN                           E:00000050
BUFSIZE                          E:0000003F
BYEBYE                          00:0000583C
BlankLastLine                   00:00005C5A
BouncingBalls                   00:00007B0A
BreakpointWords                  E:00040280
Breakpoints                      E:00040220
BufByte                         00:000077FC
BufNybble                       00:00007802
BufTetra                        00:000077F0
BufWyde                         00:000077F6
CALL                            00:00004C3E
CHKIO                           00:000057AE
CHKRET                          00:000057BE
CHR                             00:0000542A
CLMSG                           00:000058A4
CLS                             00:000057CC
CMPA_OUTER1                     00:00003426
CMPM_LOOP1                      00:000034B4
CMPM_LOOP2                      00:000034CE
CMPM_LOOP3                      00:000034E8
CMP_OUTER1                      00:000033B0
COMMON                          00:00008E90
COMMON35                        00:00008E9E
COMMON4                         00:00008E8E
COM_CMDTBL                      00:00007B6C
CON_CMDTBL                      00:000005A8
CORENO                          00:000052A8
CR                               E:0000000D
CRLF                            00:00005A06
CS11                            00:000088D4
CS12                            00:00008844
CS13                            00:000087CA
CS14                            00:00008760
CS15                            00:00008722
CS16                            00:000086B4
CS17                            00:00008A6A
CS18                            00:00008A06
CS19                            00:00008B16
CS20                            00:0000896E
CSTART                          00:00004392
CTRLC                            E:00000003
CTRLH                            E:00000008
CTRLS                            E:00000013
CTRLX                            E:00000018
CTRLZ                            E:0000001A
CURRNT                          00:000058B4
CalcScreenLoc                   00:00005A4A
CallOS                          00:00000240
CheckForCtrlC                   00:000061EC
CheckForKey                     00:000061A8
CheckNumeric                    00:00004D08
ClearBreakpointList             00:000081B4
ClearScreen                     00:00007B0E
ClearStringArea                 00:000044BC
ClearStringStack                00:000044DC
CmdBuf                           E:00040040
CmdBufEnd                        E:00040080
ConcatString                    00:00004E14
Cursor1                         00:00005E08
CursorCol                        E:00040001
CursorRow                        E:00040000
DBCC_LOOP1                      00:00002EC4
DBCC_LOOP2                      00:00002ED2
DCB_CMDPROC                      E:00000018
DCB_INBUFPTR                     E:00000028
DCB_INBUFSIZE                    E:00000030
DCB_INCOLS                       E:00000039
DCB_INROWS                       E:00000038
DCB_MAGIC                        E:00000000
DCB_NAME                         E:00000004
DCB_OUTBUFPTR                    E:0000002C
DCB_OUTBUFSIZE                   E:00000034
DCB_OUTCOLS                      E:0000003B
DCB_OUTROWS                      E:0000003A
DCB_SIZE                         E:00000040
DCODE68K                        00:00008DF6
DDATA                            E:FFFFFFF0
DEC311                          00:00008E0A
DEC404                          00:00008E28
DEC411                          00:00008E38
DEC425                          00:00008E48
DEC510                          00:00008E54
DEC515                          00:00008E58
DEC530                          00:00008E60
DEC535                          00:00008E66
DEC537                          00:00008E72
DEFLT                           00:00004ACE
DEV_PUTCHAR                      E:00000002
DIRECT                          00:00004698
DIRFLG                          00:00005908
DIV1                            00:000051C4
DIV2                            00:000051CA
DIV3                            00:000051D0
DIV32                           00:000051B2
DIV4                            00:000051DE
DIVRT                           00:000051EC
DIVS_OUTER1                     00:00003110
DIVU_OUTER1                     00:000030BE
DOMID                           00:00005358
DOQUO                           00:0000578C
DOQUO1                          00:00005794
DT_NUMERIC                       E:00000001
DT_STRING                        E:00000002
Delay3s                         00:000007E2
Delay3s2                        00:00000806
DisarmAllBreakpoints            00:00008066
DisarmBreakpoint                00:00008140
DispatchMsg                     00:00008246
DisplayAddr                     00:0000781A
DisplayByte                     00:000077D0
DisplayChar                     00:00005A58
DisplayHelp                     00:00006B90
DisplayMem                      00:0000708C
DisplayNybble                   00:000077D6
DisplaySpace                    00:000077BC
DisplayString                   00:00005CB8
DisplayStringCRLF               00:00005CCE
DisplayStringLimited            00:00005CD4
DisplayStringLimitedCRLF        00:00005CF4
DisplayTetra                    00:000077C4
DisplayTwoSpaces                00:000077AA
DisplayWyde                     00:000077CA
DumpMem1                        00:0000707A
EA000                           00:00008B46
EA001                           00:00008B52
EA010                           00:00008B5E
EA011                           00:00008B72
EA011RTS                        00:00008B88
EA100                           00:00008B8A
EA101                           00:00008C2C
EA1105                          00:00008C08
EA1107                          00:00008C0C
EA1109                          00:00008C22
EA111                           00:00008C42
EA1112                          00:00008C60
EA1113                          00:00008C7C
EA1113A                         00:00008C8C
EA1114                          00:00008CAE
EA1115                          00:00008D18
EA11153                         00:00008D50
EA11155                         00:00008D5A
EAF25                           00:00008CF6
EAF27                           00:00008CFA
EAF35                           00:00008D0E
EEA                             00:00008BA4
EEA10                           00:000087D2
ENDCHK                          00:0000549C
ENDCHK1                         00:000054AC
ENDMEM                          00:0000438E
EOR_OUTER2                      00:0000333A
EOT                              E:00000004
ERROR                           00:000054B4
ETYPE                           00:000054FE
EX1                             00:000046D2
EXCEPTION_6                     00:0000090A
EXCEPTION_7                     00:00000912
EXEC                            00:000046A8
EXGO                            00:000046DE
EXLP                            00:000046B0
EXMAT                           00:000046D8
EXNGO                           00:000046BA
EXP4RT                          00:00004F08
EXPR                            00:00004CB4
EXPR2                           00:00004DA4
EXPR3                           00:00004E82
EXPR4                           00:00004EEC
EXPR_AND                        00:00004CDA
EXPR_OR                         00:00004CB4
EXPR_REL                        00:00004D1A
E_BadDevNum                      E:00000020
E_Func                           E:00000002
E_NotAlloc                       E:00000009
E_NotSupported                   E:0000000A
E_Ok                             E:00000000
EditMemHelper                   00:00006F7E
ExecuteCode                     00:00006FF6
FDATA                            E:0000000A
FE10                            00:00008BA0
FE11                            00:00008C88
FE12                            00:00008E46
FERROR                          00:00008EB8
FERROR35                        00:00008EC2
FERROR39                        00:00008ECE
FI1                             00:0000548E
FI2                             00:0000549A
FIN                             00:00005482
FINISH                          00:000048B6
FMTK_SEMA                        E:00000008
FNDLN                           00:000055A2
FNDLNP                          00:000055B0
FNDNXT                          00:000055C8
FNDRET                          00:000055C6
FNDSKP                          00:000055CA
FOC                              E:0000001F
FOP                              E:00000027
FOR                             00:00004924
FORM1                           00:00008758
FORM10                          00:00008814
FORM103                         00:0000881A
FORM104                         00:0000881E
FORM105                         00:0000882E
FORM10E3                        00:000087F8
FORM10E4                        00:00008800
FORM10E6                        00:0000880C
FORM10EX                        00:000087D6
FORM11                          00:00008848
FORM112                         00:00008864
FORM114                         00:00008872
FORM11SL                        00:00008850
FORM12                          00:00008874
FORM125                         00:0000888E
FORM12A                         00:000088B0
FORM1A                          00:0000875C
FORM3                           00:00008762
FORM4                           00:00008766
FORM5                           00:00008778
FORM6A                          00:0000877C
FORM6D                          00:0000878C
FORM7                           00:000087B2
FORM8                           00:000087BE
FORM815                         00:000087C2
FORM9                           00:000087CC
FORM91                          00:00008B2E
FORM93                          00:00008B42
FORM95                          00:00008B44
FORMREG5                        00:000087A0
FORMREGA                        00:0000879C
FORMREGD                        00:000087AC
FORMSIZE                        00:00008B1A
FR1                             00:0000493E
FR2                             00:00004956
FR3                             00:0000495C
FR4                             00:00004962
FR5                             00:0000496A
FR6                             00:0000497C
FR7                             00:00004988
FR8                             00:000049A0
FRAMEBUF                         E:FD200000
FREL10                          00:0000861C
FREL15                          00:0000862E
FREL20                          00:00008648
FREL25                          00:0000865A
FREL30                          00:00008664
FRELADDR                        00:0000860E
FemtikiInit                     00:00000220
FemtikiInitIRQ                  00:00000230
FemtikiTimerIRQ                 00:0000030E
ForceUnlockSemaphore            00:0000076E
FreeTCB                          E:0010030C
FromScreen                      00:0000690C
GBYTE                           00:00004B26
GBYTE1                          00:00004B2A
GBYTE2                          00:00004B38
GETLN                           00:00005504
GL1                             00:00005514
GL2                             00:00005532
GL3                             00:00005546
GL4                             00:0000556A
GL5                             00:00005576
GL6                             00:00005592
GL7                             00:0000559A
GOAUXI                          00:00004382
GOAUXO                          00:0000437E
GOBYE                           00:00004386
GOIN                            00:0000437A
GOOUT                           00:00004376
GOSUB                           00:000048BE
GOTO                            00:000047C0
GOWARM                          00:00004372
GarbageCollectStrings           00:00004FF6
GetCmdLine                      00:00006D44
GetDecNumber                    00:00007218
GetHexNumber                    00:000071EA
GetKey                          00:000061B4
GetRunningTCBPointer            00:000002AA
GetSzChar                       00:00006F58
GlobalReadLong                  00:00000622
GlobalWriteLong                 00:00000628
GraphicsDemo                    00:00007B0C
HAS_MMU                          E:00000000
HEX2DEC                         00:00008596
HEX2DEC2                        00:00008548
HISPC                            E:FFFFFFFC
HOWMSG                          00:00005875
HX2DC                           00:000085A6
HX2DC0                          00:000085AA
HX2DC1                          00:000085B2
HX2DC2                          00:000085CC
HX2DC22                         00:000085CE
HX2DC3                          00:000085D8
HX2DC4                          00:000085E0
HX2DC5                          00:000085E8
HX2DC57                         00:000085F0
HX2DC6                          00:000085F4
HelpMsg                         00:00006B9C
HomeCursor                      00:00005CFA
I2C2                             E:FD069000
I2C_CMD                          E:00000004
I2C_CTRL                         E:00000002
I2C_PREH                         E:00000001
I2C_PREL                         E:00000000
I2C_RXR                          E:00000003
I2C_STAT                         E:00000004
I2C_TXR                          E:00000003
IBSR                            00:000089C0
ICC                             00:000089BC
ICC35                           00:000089D2
ICC55                           00:000089E8
ICCCC                           00:00008A86
ICCCC9                          00:00008A9C
IDBCC                           00:000089AA
IF                              00:00004A10
IF1                             00:00004A14
IF2                             00:00004A1A
IGNBLK                          00:0000575A
ILINK                           00:00008742
IM7788                          00:00008680
IM7799                          00:00008684
IMMED                           00:000086CA
IMMED45                         00:000086F0
IMMED55                         00:00008724
IMMED65                         00:0000872A
IMMED75                         00:0000873A
IMOVE                           00:0000873E
IMOVE19                         00:00008AE4
IMOVEA1                         00:00008ABE
IMOVEMFR                        00:0000866C
IMOVEMTR                        00:0000869A
IMOVEP                          00:00008946
IMOVEP11                        00:00008956
IMOVEP35                        00:00008972
IMOVEP66                        00:00008980
IMOVEQ                          00:000088DC
IMVFSR                          00:000088FC
IMVFUSP                         00:0000890A
IMVT44                          00:00008926
IMVTCCR                         00:00008936
IMVTSR                          00:00008918
IMVTUSP                         00:0000892A
INC                             00:000057E8
INC1                            00:000057F4
INCOM                           00:000046F0
INCON                           00:000046E2
INITMSG                         00:0000584A
INPERR                          00:00004A2A
INPPTR                          00:000058AC
INPUT                           00:00004A38
INT                             00:00005414
INT_EXPR                        00:00004CA2
IOCOM                           00:000046FE
IOCON                           00:00004714
IOFocus                          E:00100000
IP2                             00:00004A6A
IP3                             00:00004A84
IP4                             00:00004ABE
IP5                             00:00004ACA
IP6                             00:00004A66
IP7                             00:00004A5C
IQUICK                          00:000088D8
IQUICK21                        00:00008AFC
IQUICK31                        00:00008B12
IQUICKA                         00:00008AEA
IRQFlag                          E:000400A0
IRQROUT                         00:000058E8
IRQ_trampolines                 01:00000100
ISCC                            00:000089A0
ISETD                           00:000089F8
ISETD12                         00:000089FE
ISETS                           00:00008A08
ISHIFT                          00:00008A22
ISHIFT13                        00:00008A2E
ISHIFT23                        00:00008A52
ISHIFT33                        00:00008A5E
ISHIFT44                        00:00008A62
ISHIFTM1                        00:00008A6C
ISTOP                           00:000086B6
IncCursorPos                    00:00005BBE
IncCursorRow                    00:00005BDE
InitIOPBitmap                   00:00000630
InitIRQ                         00:00008320
InitRand                        00:00000680
InitSemaphores                  00:00000726
InputDevice                      E:000400A4
InstallIRQ                      00:00008334
KBD_CMDTBL                      00:00005F28
KEYBD                            E:FD0FFE00
KEYBD_SEMA                       E:00000003
KI                              00:00008EE2
KIEND                           00:00008EE4
KeybdEcho                        E:0004000C
KeybdGetChar                    00:00006208
KeybdGetCharNoWait              00:000061F8
KeybdGetCharWait                00:00006200
KeybdGetID                      00:00005F8A
KeybdID                          E:00100018
KeybdIRQ                        00:000064B4
KeybdInit                       00:00005FF4
KeybdLEDs                        E:0010000E
KeybdRecvByte                   00:00006158
KeybdSendByte                   00:00006474
KeybdSetLED                     00:00005FC8
KeybdSetLEDStatus               00:00006424
KeybdWaitFlag                    E:0004000D
KeybdWaitTx                     00:0000617A
LEA1                            00:000023E0
LEFT                            00:000053BA
LEN                             00:000053EE
LET                             00:00004AD6
LF                               E:0000000A
LIST                            00:00004808
LOAD                            00:00004AE6
LOCVARSZ                         E:00000010
LOD1                            00:00004AF2
LOD2                            00:00004B0C
LODEND                          00:00004B1C
LOPINC                          00:000058C8
LOPLMT                          00:000058D4
LOPLN                           00:000058E0
LOPPT                           00:000058E4
LOPVAR                          00:000058C4
LS1                             00:00004814
LS2                             00:00004828
LS3                             00:0000482E
LSTROM                          00:000058A8
LT1                             00:00004AE2
LastStr                         00:000058F8
ListBreakpoints                 00:00008194
LockSemaphore                   00:0000074C
LockSysSemaphore                00:00000396
LorR1                           00:000052EC
LorRArgs                        00:000052B4
MAX_TID                          E:00000FFF
MEMORY_SEMA                      E:00000006
MID                             00:000052F0
MID1                            00:000053B6
MID2                            00:00005338
MID4                            00:00005384
MID5                            00:00005350
MMU                              E:FDC00000
MOVE1                           00:0000204E
MOVE2                           00:00001FD2
MOVE3                           00:000020CE
MOVE4                           00:00002228
MOVEMR                          00:00008D7A
MOVEMR11                        00:00008D8A
MOVEMR33                        00:00008D92
MOVEMR44                        00:00008DA4
MOVEMR77                        00:00008DBE
MOVEMR79                        00:00008DD0
MOVEMR88                        00:00008DD2
MOVEMR94                        00:00008DEA
MOVEMS                          00:00008D66
MOVEMS2                         00:00008D76
MSG111                          00:00008ED8
MULS_OUTER1                     00:00003A06
MULU_OUTER1                     00:000039BA
MVDOWN                          00:000055EC
MVRET                           00:000055E0
MVUP                            00:000055D8
MVUPW                           00:000055E2
Monitor                         00:00006920
NBCD_LOOP                       00:00002D84
NBCD_LOOP1                      00:00002DCA
NBCD_NO_C                       00:00002D90
NBCD_NO_C1                      00:00002DDE
NBCD_NO_Z                       00:00002D94
NBCD_NO_Z1                      00:00002DE2
NCORES                           E:00000004
NEW                             00:0000472A
NEXT                            00:000049A4
NOSTRING                        00:0000588C
NR_TCB                           E:00001000
NUM_EXPR                        00:00004C94
NX0                             00:000049AE
NX1                             00:000049EE
NX2                             00:00004A06
NX3                             00:000049C0
NextRec                         00:00007902
NextString                      00:00005032
NumSetBreakpoints                E:00040202
OFFSET                           E:00040880
OKMSG                           00:0000586E
ONIRQ                           00:000047D4
ONIRQ1                          00:000047EE
OPCTBL                          00:0000919C
OR_OUTER1                       00:00003166
OR_OUTER2                       00:000031DA
OSCallTable                     00:0000023E
OUTC                            00:000057D8
OUTCOM                          00:00004708
OUTCON                          00:0000471E
OUTPTR                          00:000058B0
OutputChar                      00:000082EA
OutputDevice                     E:000400A8
PARN                            00:00004F82
PBYTE                           00:00004BA4
PBYTE1                          00:00004BA6
PBYTE2                          00:00004BBA
PEEK                            00:000051EE
PKER                            00:00004C3A
PLIC                             E:FD090000
PNT4HEX                         00:000085FA
PNT4HX                          00:000085FA
PNT6HX                          00:000085FE
PNT8HX                          00:0000860A
POKE                            00:00004BC4
POPA                            00:000055F4
PR0                             00:00004852
PR1                             00:00004860
PR2                             00:00004844
PR3                             00:0000486E
PR6                             00:0000487A
PR8                             00:00004880
PR9                             00:0000489C
PRINT                           00:00004834
PRMESG                          00:000057C0
PRMRET                          00:000057CA
PRTLN                           00:000056D8
PRTNUM                          00:0000568E
PRTRET                          00:00005680
PRTSTG                          00:00005666
PRTSTR2                         00:00005688
PRTSTR2a                        00:00005682
PS1                             00:00005668
PUSHA                           00:00005630
PeekScreenChar                  00:00006F52
PointsIntoStringArea            00:0000508E
ProcessBreakpoint               00:00008060
ProcessRec                      00:00007914
ProcessS1                       00:00007A16
ProcessS2                       00:00007A1A
ProcessS3                       00:00007A1E
ProcessS7                       00:00007A22
ProcessS8                       00:00007A32
ProcessS9                       00:00007A42
Prompt1                         00:0000695E
Prompt3                         00:00006948
PromptLn                        00:0000693C
QHOW                            00:000054F6
QSORRY                          00:000054EE
QWHAT                           00:000054AE
QueueCycle                       E:0010031C
RAND                             E:FD0FFD00
RAND_MW                          E:FD0FFD0C
RAND_MZ                          E:FD0FFD08
RAND_NUM                         E:FD0FFD00
RAND_SEMA                        E:00000004
RAND_STRM                        E:FD0FFD04
RANPNT                          00:000058A8
REM                             00:00004A0E
RETURN                          00:000048F8
RIGHT                           00:000053C6
RND                             00:00005256
ROXx_FLAGS                      00:00003CCE
ROXx_LOOP1                      00:00003CE4
ROXx_LOOP2                      00:00003D04
ROXx_LOOP3                      00:00003D24
ROXx_LOOP4                      00:00003D44
ROXx_LOOP5                      00:00003D64
ROXx_LOOP6                      00:00003D86
ROx_FLAGS                       00:00003A98
ROx_LOOP1                       00:00003AAE
ROx_LOOP2                       00:00003ACE
ROx_LOOP3                       00:00003AEE
ROx_LOOP4                       00:00003B0E
ROx_LOOP5                       00:00003B2E
ROx_LOOP6                       00:00003B50
RST_REG                          E:FD0FFC00
RTCBuf                           E:00100200
RTR_DONE                        00:00002E26
RUN                             00:00004746
RUN1                            00:0000479A
RUNNXL                          00:0000475A
RUNSML                          00:000047B0
RUNTSL                          00:000047A6
RandGetNum                      00:000006C0
RandInit                        00:00000680
RandWait                        00:00000710
ReceiveMsg                      00:00008204
Regsave                          E:00040100
RunningTCB                       E:00100224
S1932a                          00:00007A8A
S1932b                          00:00007A9E
S19Checksum                      E:00100150
S19Get16BitAddress              00:00007A52
S19Get24BitAddress              00:00007A60
S19Get32BitAddress              00:00007A6C
S19StartAddress                  E:00040008
SAVE                            00:00004B46
SAVE1                           00:00004B4E
SAVE2                           00:00004B72
SAVEND                          00:00004B80
SBCD_INNER1                     00:00002C96
SBCD_INNER2                     00:00002D04
SBCD_NO_C1                      00:00002CB2
SBCD_NO_C2                      00:00002CBA
SBCD_NO_C3                      00:00002D20
SBCD_NO_C4                      00:00002D28
SBCD_OUTER1                     00:00002C94
SBCD_OUTER2                     00:00002D02
SCHR                            00:000088F4
SCOMMON                         00:0000899C
SCREEN_FORMAT                    E:00000001
SCREEN_SEMA                      E:00000005
SC_ALT                           E:00000011
SC_CAPSLOCK                      E:00000058
SC_CTRL                          E:00000014
SC_EXTEND                        E:000000E0
SC_KEYUP                         E:000000F0
SC_LSHIFT                        E:00000012
SC_NUMLOCK                       E:00000077
SC_RSHIFT                        E:00000059
SC_SCROLLLOCK                    E:0000007E
SC_TAB                           E:0000000D
SERIAL_SEMA                      E:00000002
SETVAL                          00:00005462
SHIFTS2_FLAGS                   00:00004146
SHIFTS2_LOOP1                   00:0000415C
SHIFTS2_LOOP2                   00:00004178
SHIFTS2_LOOP3                   00:00004194
SHIFTS2_LOOP4                   00:000041B0
SHIFTS2_LOOP5                   00:000041CC
SHIFTS2_LOOP6                   00:000041EA
SHIFTS_FLAGS                    00:00003F04
SHIFTS_LOOP1                    00:00003F1A
SHIFTS_LOOP2                    00:00003F3A
SHIFTS_LOOP3                    00:00003F5A
SHIFTS_LOOP4                    00:00003F7A
SHIFTS_LOOP5                    00:00003F9A
SHIFTS_LOOP6                    00:00003FBC
SIV1                            00:00005066
SIZE                            00:0000528C
SRYMSG                          00:0000589E
ST3                             00:00004430
ST4                             00:00004482
START                           00:00004370
STKFP                           00:000058B8
STKGOS                          00:000058BC
STKINP                          00:000058C0
STKLMT                          00:00005904
STOP                            00:0000473E
STRAREASIZE                      E:00000800
STRSTK                          00:000058EC
SUBA_OUTER1                     00:00003758
SUBQ_LOOP1                      00:00002FE4
SUBQ_LOOP2                      00:0000301E
SUBQ_LOOP3                      00:00003054
SUBX_LOOP3                      00:00003942
SUBX_LOOP4                      00:0000395E
SUBX_LOOP5                      00:0000397A
SUBX_OUTER1                     00:000038AE
SUB_OUTER1                      00:0000361C
SUB_OUTER2                      00:00003690
SV1                             00:00005480
ScrollUp                        00:00005C12
SelectThreadToRun               00:000002C2
SendMsg                         00:000081C6
SerHeadRcv                       E:00100162
SerHeadXmit                      E:00100168
SerRcvBuf                        E:00101000
SerRcvXoff                       E:00100165
SerRcvXon                        E:00100164
SerTailRcv                       E:00100160
SerTailXmit                      E:00100166
SerXmitBuf                       E:00102000
SerXmitXoff                      E:0010016A
SerialGetChar                   00:00007C36
SerialIRQ                       00:00007DAC
SerialInit                      00:00007BF8
SerialPeekChar                  00:00007CAE
SerialPeekCharDirect            00:00007CEA
SerialPutChar                   00:00007D04
SerialPutCharDirect             00:00007D68
SerialRbo                       00:00007D84
SerialRcvCount                  00:00007D8C
SetKeyboardEcho                 00:000061A0
ShiftBuf                        00:0000852E
SpuriousIRQ                     00:000083E6
StartMon                        00:00006916
StartQ                          00:00000172
StrArea                         00:000058F4
StrSp                           00:000058F0
StringInVar                     00:00005048
StringOnStack                   00:000050B2
StubRout                        00:00005E40
SyncCursor                      00:00005D0C
T15Abort                        00:000007BE
T15DispatchTable                00:00005D58
T15FloatToString                00:0000828E
T15GetFloat                     00:000007B0
T15LockSemaphore                00:000007A4
T15UnlockSemaphore              00:000007AA
TAB1                            00:000044F0
TAB10                           00:000045A5
TAB10_1                         00:00004688
TAB11                           00:000045A8
TAB11_1                         00:00004690
TAB1_1                          00:000045B0
TAB2                            00:0000451F
TAB2_1                          00:000045E0
TAB4                            00:0000455C
TAB4_1                          00:00004620
TAB5                            00:0000458E
TAB5_1                          00:00004654
TAB6                            00:00004591
TAB6_1                          00:0000465C
TAB8                            00:00004596
TAB8_1                          00:00004664
TAB9                            00:000045A1
TAB9_1                          00:00004680
TBL                             00:00008EE4
TBLE                            00:0000919C
TC1                             00:00005708
TCBAffineChose                  00:000000A0
TCBAffinity                      E:00000084
TCBAffinityBase                  E:00000082
TCBAlloc                        00:0000006E
TCBEndTick                       E:00000070
TCBFree                         00:00000092
TCBHandleToPointer              00:00000028
TCBIAlloc                       00:00000050
TCBIFree                        00:0000007C
TCBInit                         00:00000000
TCBInsertIntoReadyQueue         00:000000D8
TCBNext                          E:0000007C
TCBPC                            E:00000050
TCBPointerToHandle              00:00000040
TCBPopReadyQueue                00:0000017A
TCBPrev                          E:00000080
TCBPriority                      E:00000055
TCBRegs                          E:00000004
TCBRemoveFromReadyQueue         00:00000150
TCBSR                            E:0000004C
TCBSSP                           E:00000048
TCBStartTick                     E:0000006C
TCBStatus                        E:00000054
TCBTicks                         E:00000074
TCBUSP                           E:00000044
TCB_SIZE                         E:00000100
TEXTREG                          E:FD080000
TICK                            00:0000529C
TOUPB1                          00:0000576A
TOUPBRT                         00:0000578A
TOUPBUF                         00:00005764
TOUPPER                         00:0000579C
TOUPRET                         00:000057AC
TRAP15                          00:00005D40
TSTC                            00:000056F6
TSTNUM                          00:0000570E
TSTV                            00:00005130
TSTVRT                          00:000051B0
TS_PREEMPT                       E:00000020
TS_RUNNING                       E:00000080
TV1                             00:00005178
TV2                             00:000051A8
TXT                             00:0000595C
TXTBGN                          00:0000438A
TXTUNF                          00:000058FC
TYPMSG                          00:00005884
TextCols                         E:0004008D
TextCurpos                       E:00040002
TextPos                          E:00040002
TextRows                         E:0004008C
TextScr                          E:00040004
TickIRQ                         00:00008378
TimerStack                       E:00040BFC
USP1                            00:0000510E
UnlockSemaphore                 00:00000788
UnlockSysSemaphore              00:000003A6
UpdateIRQLive                   00:000002EC
UpdateStringPointers            00:000050E2
UpdateTextPos                   00:00005A20
VARBGN                          00:00005900
WAITIRQ                         00:000047F8
WHTMSG                          00:0000587C
WSTART                          00:000043FC
Wait10ms                        00:0000647C
Wait300ms                       00:00006498
X                               00:0000866C
XOFF                             E:00000013
XON                              E:00000011
XP11                            00:00004D2E
XP12                            00:00004D3A
XP13                            00:00004D46
XP14                            00:00004D52
XP15                            00:00004D5E
XP15RT                          00:00004D6A
XP16                            00:00004D6C
XP17                            00:00004D8A
XP18                            00:00004D90
XP21                            00:00004DB2
XP22                            00:00004DB8
XP23                            00:00004DBC
XP24                            00:00004DCA
XP25                            00:00004DF8
XP26                            00:00004DFE
XP27                            00:00004E12
XP30                            00:00004E88
XP31                            00:00004E94
XP34                            00:00004EAA
XP35                            00:00004EC4
XP36                            00:00004E84
XP40                            00:00004EF8
XP41                            00:00004F0A
XP42                            00:00004F92
XP43                            00:00004F94
XP44                            00:00004F76
XP45                            00:00004F24
XPRT0                           00:00004D7A
XPRT1                           00:00004D82
XPSTNG                          00:00004F1A
XP_AND                          00:00004CEC
XP_ANDX                         00:00004D02
XP_MOD                          00:00004ECA
XP_OR                           00:00004CC4
XP_ORX                          00:00004D02
XP_POP                          00:00004C68
XP_POP1                         00:00004C7E
XP_PUSH                         00:00004C52
_CheckNan                       00:0000727C
_CheckNegative                  00:000072FA
_CheckZero                      00:000072E0
_ComputeDigitsBeforeDecpt       00:00007354
_E                               E:0004050C
_ExtExpDigit                    00:00007478
_ExtExpDigits                   00:00007496
_FloatToString                  00:00007540
_GetExponent                    00:000075F8
_GetFloat                       00:000076F8
_GetFloatBackupChar             00:00007590
_GetFloatGetChar                00:00007582
_GetFloatIgnBlanks              00:00007588
_GetFraction                    00:00007594
_GetInteger                     00:00007682
_GetRand                        00:000006EE
_KeyState1                       E:0010000F
_KeyState2                       E:00100010
_KeybdBuf                        E:00100020
_KeybdClearIRQ                  00:00006142
_KeybdCnt                        E:00100013
_KeybdGetScancode               00:00006124
_KeybdGetStatus                 00:00006106
_KeybdHead                       E:00100011
_KeybdInit                      00:00005FF4
_KeybdOBuf                       E:00100080
_KeybdTail                       E:00100012
_Keybd_tick                      E:0001001C
_LeadingZero                    00:0000738E
_LessThanDbl                    00:00007328
_MakeBig                        00:0000730C
_PadLeft                        00:000074BE
_PadRight                       00:0000750E
_SpitOutDigits                  00:0000739E
_SpitOutE                       00:00007460
_TrimDotZero                    00:00007438
_TrimTrailingPoint              00:0000741A
_TrimTrailingZeros              00:00007454
_canary                          E:00040098
_dasmbuf                         E:00040800
_dfMil                          00:00007268
_dfOne                          00:00007250
_dfTen                          00:0000725C
_digits_before_decpt             E:00040510
_fpBuf                           E:00040520
_fpTextIncr                      E:00040094
_fpWork                          E:00040600
_keybdControlCodes              00:0000676A
_keybdExtendedCodes             00:000067EA
_msgInf                         00:00007278
_msgNan                         00:00007274
_precision                       E:00040514
_shiftedScanCodes               00:0000666A
_unshiftedScanCodes             00:0000656A
_width                           E:00040508
addr_err                        00:000083FA
bkColor                          E:00040088
brdisp_trap                     00:00008410
bus_err                         00:00008008
chk_exception                   00:000007CE
clear_screen                    00:000059CA
cmdBreakpoint                   00:000069F6
cmdClearScreen                  00:00006A2E
cmdClock                        00:00006B20
cmdCore                         00:00006A3A
cmdDisassemble                  00:00007006
cmdDispatch                     00:00006970
cmdDumpMemory                   00:00007056
cmdDumpRegs                     00:00007120
cmdEditMemory                   00:00006FA0
cmdFMTK                         00:00006A5E
cmdFillB                        00:00006E4C
cmdFillL                        00:00006EF4
cmdFillW                        00:00006EA0
cmdHelp                         00:00006B90
cmdJump                         00:00006FF6
cmdLoadS19                      00:000078FC
cmdMonitor                      00:00006920
cmdReceiveSerial                00:00006E18
cmdReset                        00:00006B3E
cmdSendSerial                   00:00006DE8
cmdString                       00:0000686A
cmdTable                        00:000068A4
cmdTestCPU                      00:00006A1E
cmdTestFP                       00:00006A66
cmdTestGF                       00:00006AF2
cmdTestRAM                      00:0000783A
cmdTestSerialReceive            00:000071CA
cmdTinyBasic                    00:00006A1A
cmdVideoMode                    00:000069B6
con_dcb                          E:00040A80
console_cmdproc                 00:000005C8
console_getbuf                  00:00000602
console_getchar                 00:000005FA
console_init                    00:0000052A
console_putbuf                  00:00000602
console_putchar                 00:000005F2
console_set_inpos               00:00000602
console_set_outpos              00:00000602
console_stat                    00:000005EE
cpu_test                        00:00000822
dccr                            00:00005A80
dclf                            00:00005B44
dcx10                           00:00005AE8
dcx11                           00:00005B0A
dcx12                           00:00005B00
dcx14                           00:00005A76
dcx16                           00:00005B48
dcx4                            00:00005B4C
dcx6                            00:00005A9E
dcx7                            00:00005A7A
dcx8                            00:00005AB4
dcx9                            00:00005ACA
dly3s1                          00:000007F2
dly3s2                          00:000007F0
doBackspace                     00:00005B56
doCtrlX                         00:00005B9A
doDelete                        00:00005B64
do_nothing                      00:000004F4
dspj1                           00:00005CBC
dspmem1                         00:000070B8
dspspc1                         00:000077B4
dsret                           00:00005CC8
edtmem1                         00:00006FAA
fgColor                          E:00040084
fpBuf                            E:000402C0
get_screen_address              00:000059C2
get_screen_color                00:000059B0
gthx3                           00:000077A6
gthx5                           00:00007782
gthx6                           00:00007794
i2c_setup                       00:00007E8A
i2c_wait_rx_nack                00:00007ED8
i2c_wait_tip                    00:00007E9A
i2c_wr_cmd                      00:00007EAA
i2c_xmit1                       00:00007EBA
icc1                            00:00005C10
ignBlanks                       00:00006F40
illegal_trap                    00:00008448
init_framebuf                   00:00000606
init_i2c                        00:00007E8A
init_plic                       00:00005E84
io_irq                          00:0000845E
io_trap                         00:000082C2
irq3_rout                       00:000083B4
irq6_rout                       00:000083B4
irq_list_tbl                     A:00000400
irq_proc_generic                00:000083C8
irq_rout                        00:000083B4
kbdi0002                        00:00006020
kbdi0004                        00:00006098
kbdi0005                        00:000060B4
kbdiTryAgain                    00:0000608A
kbdiXmitBusy                    00:000060CE
keybd_cmdproc                   00:00005F48
keybd_dcb                        E:00040A40
keybd_getbuf                    00:00005F86
keybd_getchar                   00:00005F7E
keybd_init                      00:00005EBA
keybd_putbuf                    00:00005F86
keybd_putchar                   00:00005F76
keybd_set_inpos                 00:00005F86
keybd_set_outpos                00:00005F86
keybd_stat                      00:00005F6E
kgid1                           00:00005FBC
kgnotKbd                        00:00005FC4
leds                             E:FD0FFF00
ledxit                          00:000060B8
loop1                           00:000004C2
loop2                           00:000004C0
loop3                           00:000059F4
memend                           E:00100004
msgAddrErr                      00:000084AA
msgBadKeybd                     00:000060DC
msgBusErr                       00:00007FF7
msgChk                          00:00008506
msgHello                        00:00006D32
msgRtcReadFail                  00:00007FDE
msgStackCanary                  00:00008514
msgUnknownCmd                   00:00006D22
msgXmitBusy                     00:000060EB
msg_bad_branch_disp             00:000084C9
msg_core_start                  00:00008499
msg_illegal                     00:000084B7
msg_io_access                   00:000084EB
msg_reglist                     00:000071A4
msg_regs                        00:000071A0
msg_start                       00:00008472
msg_test_done                   00:000084DB
nd1                             00:0000062C
nd2                             00:0000062C
nd3                             00:0000062C
nd4                             00:0000062C
net_delay                       00:0000062C
nmeSerial                       00:00007E82
nmi_rout                        00:000083E8
notRxInt                        00:00007E22
notTxInt                        00:00007E70
null_cmdproc                    00:00000528
null_dcb                         E:00040A00
null_init                       00:000004FA
null_ret                        00:00000526
numBreakpoints                   E:00000008
op_ABCD                         00:00002B7C
op_ADD                          00:00003512
op_ADDA                         00:000036E6
op_ADDQ                         00:00002F12
op_ADDX                         00:0000377E
op_ADD_I                        00:00001BFA
op_AND                          00:00003230
op_ANDI_TO_CCR                  00:000009AA
op_ANDI_TO_SR                   00:000009D0
op_BCC                          00:00002E3C
op_BCHG                         00:00000DA0
op_BCLR                         00:00001108
op_BOOL_I                       00:0000182A
op_BSET                         00:00001456
op_BSR                          00:000019DC
op_BTST                         00:000009F6
op_BTST0                        00:00000B80
op_BTST1                        00:00000B8C
op_BTST10                       00:00000BD4
op_BTST11                       00:00000BDC
op_BTST12                       00:00000BE2
op_BTST2                        00:00000B94
op_BTST20                       00:00000D3A
op_BTST21                       00:00000D44
op_BTST22                       00:00000D4A
op_BTST23                       00:00000D50
op_BTST24                       00:00000D56
op_BTST25                       00:00000D5C
op_BTST26                       00:00000D62
op_BTST27                       00:00000D68
op_BTST28                       00:00000D6E
op_BTST29                       00:00000D74
op_BTST3                        00:00000B9C
op_BTST30                       00:00000D7A
op_BTST31                       00:00000D80
op_BTST32                       00:00000D84
op_BTST4                        00:00000BA4
op_BTST5                        00:00000BAC
op_BTST6                        00:00000BB4
op_BTST7                        00:00000BBC
op_BTST8                        00:00000BC4
op_BTST9                        00:00000BCC
op_CHK                          00:00002486
op_CMP                          00:00003390
op_CMPA                         00:00003406
op_CMPM                         00:0000346C
op_CMP_I                        00:00001A12
op_DBCC                         00:00002EBC
op_DIVS                         00:000030F4
op_DIVU                         00:000030A2
op_EOR                          00:0000331A
op_EORI_TO_CCR                  00:0000095E
op_EORI_TO_SR                   00:00000984
op_EXG                          00:00003A36
op_EXT                          00:00002306
op_LEAPEA                       00:00002348
op_LINKS                        00:00002458
op_MOVE                         00:00001F06
op_MOVEM                        00:0000285E
op_MOVEP                        00:0000179E
op_MOVEQ                        00:00003086
op_MOVE_USP                     00:00002476
op_MOVE_xxx_FLAGS               00:00002112
op_MULS                         00:000039EA
op_MULU                         00:0000399E
op_NBCD                         00:00002D6C
op_NEGS                         00:000024D0
op_OR                           00:00003146
op_ORI_TO_CCR                   00:0000091A
op_ORI_TO_SR                    00:0000093C
op_ROXx                         00:00003CDA
op_ROx                          00:00003AA4
op_RTR                          00:00002E1A
op_SBCD                         00:00002C74
op_SCC                          00:00002EE2
op_SHIFTS                       00:00003F10
op_SHIFTS2                      00:00004152
op_SUB                          00:000035FC
op_SUBA                         00:00003732
op_SUBQ                         00:00002FCC
op_SUBX                         00:0000388E
op_SUB_I                        00:00001D80
op_SWAP                         00:00002332
op_TAS                          00:000023F4
op_TRAPV                        00:00002DFE
op_TST                          00:0000241A
pcssxa                          00:000079AA
prtflt                          00:00008248
ramtest                         00:0000783A
ramtest0                        00:00007884
ramtest1                        00:0000788C
ramtest2                        00:000078B8
ramtest3                        00:000078FA
ramtest6                        00:000078A8
rbo                             00:00007B14
readyQ                           E:00100320
rmtst1                          00:0000789C
rmtst2                          00:000078CE
rmtst3                          00:000078D6
rmtst5                          00:00007854
rotate_iofocus                  00:00005E54
rtc_read                        00:00007EE8
rtc_write                       00:00007F74
sGetChar                        00:00007AE0
select_focus1                   00:00005E66
select_iofocus                  00:00005E42
semamem                          E:FD050000
serial_cmdproc                  00:00007B9C
serial_dcb                       E:00040B40
serial_getbuf                   00:00007BF4
serial_getchar                  00:00007BCE
serial_getchar_direct           00:00007BD4
serial_init                     00:00007B1C
serial_peek_char                00:00007BDC
serial_peek_char_direct         00:00007BE4
serial_putbuf                   00:00007BF4
serial_putchar                  00:00007BC6
serial_putchar_direct           00:00007BEC
serial_set_inpos                00:00007BF4
serial_set_outpos               00:00007BF4
serial_stat                     00:00007BC2
set_graphics_mode               00:00005986
set_text_mode                   00:0000595C
setup_console                   00:0000052A
setup_keybd                     00:00005EBA
setup_null                      00:000004FA
setup_serial                    00:00007B1C
sirq0001                        00:00007DD2
sirq0002                        00:00007E70
sirqNxtByte                     00:00007DC0
sirqRxFull                      00:00007E22
sirqTxEmpty                     00:00007E70
sirqXmitOff                     00:00007E70
start                           00:000003B8
start_other                     00:000004D4
tblPow2                         00:00006B70
tcbs                             E:20010000
trap3                           00:00008022

Symbols by value:
FD050000 semamem
FD060000 ACIA
FD069000 I2C2
FD080000 TEXTREG
FD090000 PLIC
FD0FFC00 RST_REG
FD0FFD00 RAND_NUM
FD0FFD00 RAND
FD0FFD04 RAND_STRM
FD0FFD08 RAND_MZ
FD0FFD0C RAND_MW
FD0FFE00 KEYBD
FD0FFF00 leds
FD200000 FRAMEBUF
FDC00000 MMU
FFFFFFF0 DDATA
FFFFFFFC HISPC
00000000 ACIA_TX
00000000 E_Ok
00000000 DCB_MAGIC
00000000 TCBInit
00000000 ACIA_RX
00000000 I2C_PREL
00000000 HAS_MMU
00000001 SCREEN_FORMAT
00000001 DT_NUMERIC
00000001 I2C_PREH
00000002 E_Func
00000002 SERIAL_SEMA
00000002 DT_STRING
00000002 DEV_PUTCHAR
00000002 I2C_CTRL
00000003 I2C_RXR
00000003 KEYBD_SEMA
00000003 I2C_TXR
00000003 CTRLC
00000004 TCBRegs
00000004 NCORES
00000004 I2C_STAT
00000004 I2C_CMD
00000004 RAND_SEMA
00000004 ACIA_STAT
00000004 EOT
00000004 DCB_NAME
00000005 SCREEN_SEMA
00000006 MEMORY_SEMA
00000008 numBreakpoints
00000008 FMTK_SEMA
00000008 ACIA_CMD
00000008 CTRLH
00000009 E_NotAlloc
0000000A LF
0000000A E_NotSupported
0000000A FDATA
0000000C ACIA_CTRL
0000000D CR
0000000D SC_TAB
00000010 LOCVARSZ
00000011 XON
00000011 SC_ALT
00000012 SC_LSHIFT
00000013 CTRLS
00000013 XOFF
00000014 SC_CTRL
00000018 DCB_CMDPROC
00000018 CTRLX
0000001A CTRLZ
0000001F FOC
00000020 TS_PREEMPT
00000020 BLANK
00000020 E_BadDevNum
00000027 FOP
00000028 TCBHandleToPointer
00000028 DCB_INBUFPTR
0000002C DCB_OUTBUFPTR
00000030 DCB_INBUFSIZE
00000034 DCB_OUTBUFSIZE
00000038 DCB_INROWS
00000039 DCB_INCOLS
0000003A DCB_OUTROWS
0000003B DCB_OUTCOLS
0000003F BUFSIZE
00000040 TCBPointerToHandle
00000040 DCB_SIZE
00000044 TCBUSP
00000048 TCBSSP
0000004C TCBSR
00000050 TCBPC
00000050 TCBIAlloc
00000050 BUFLEN
00000054 TCBStatus
00000055 TCBPriority
00000058 SC_CAPSLOCK
00000059 SC_RSHIFT
0000006C TCBStartTick
0000006E TCBAlloc
00000070 TCBEndTick
00000074 TCBTicks
00000077 SC_NUMLOCK
0000007C TCBNext
0000007C TCBIFree
0000007E SC_SCROLLLOCK
00000080 TCBPrev
00000080 TS_RUNNING
00000082 TCBAffinityBase
00000084 TCBAffinity
00000092 TCBFree
000000A0 TCBAffineChose
000000D8 TCBInsertIntoReadyQueue
000000E0 SC_EXTEND
000000F0 SC_KEYUP
00000100 IRQ_trampolines
00000100 TCB_SIZE
00000150 TCBRemoveFromReadyQueue
00000172 StartQ
0000017A TCBPopReadyQueue
00000220 FemtikiInit
00000230 FemtikiInitIRQ
0000023E OSCallTable
00000240 CallOS
000002AA GetRunningTCBPointer
000002C2 SelectThreadToRun
000002EC UpdateIRQLive
0000030E FemtikiTimerIRQ
00000396 LockSysSemaphore
000003A6 UnlockSysSemaphore
000003B8 start
00000400 irq_list_tbl
000004C0 loop2
000004C2 loop1
000004D4 start_other
000004F4 do_nothing
000004FA null_init
000004FA setup_null
00000526 null_ret
00000528 null_cmdproc
0000052A setup_console
0000052A console_init
000005A8 CON_CMDTBL
000005C8 console_cmdproc
000005EE console_stat
000005F2 console_putchar
000005FA console_getchar
00000602 console_putbuf
00000602 console_set_outpos
00000602 console_set_inpos
00000602 console_getbuf
00000606 init_framebuf
00000622 GlobalReadLong
00000628 GlobalWriteLong
0000062C net_delay
0000062C nd4
0000062C nd2
0000062C nd3
0000062C nd1
00000630 InitIOPBitmap
00000680 RandInit
00000680 InitRand
000006C0 RandGetNum
000006EE _GetRand
00000710 RandWait
00000726 InitSemaphores
0000074C LockSemaphore
0000076E ForceUnlockSemaphore
00000788 UnlockSemaphore
000007A4 T15LockSemaphore
000007AA T15UnlockSemaphore
000007B0 T15GetFloat
000007BE T15Abort
000007CE chk_exception
000007E2 Delay3s
000007F0 dly3s2
000007F2 dly3s1
00000800 STRAREASIZE
00000806 Delay3s2
00000822 cpu_test
00000900 ALL_DONE
00000902 BSR_FAR1
0000090A EXCEPTION_6
00000912 EXCEPTION_7
0000091A op_ORI_TO_CCR
0000093C op_ORI_TO_SR
0000095E op_EORI_TO_CCR
00000984 op_EORI_TO_SR
000009AA op_ANDI_TO_CCR
000009D0 op_ANDI_TO_SR
000009F6 op_BTST
00000B80 op_BTST0
00000B8C op_BTST1
00000B94 op_BTST2
00000B9C op_BTST3
00000BA4 op_BTST4
00000BAC op_BTST5
00000BB4 op_BTST6
00000BBC op_BTST7
00000BC4 op_BTST8
00000BCC op_BTST9
00000BD4 op_BTST10
00000BDC op_BTST11
00000BE2 op_BTST12
00000D3A op_BTST20
00000D44 op_BTST21
00000D4A op_BTST22
00000D50 op_BTST23
00000D56 op_BTST24
00000D5C op_BTST25
00000D62 op_BTST26
00000D68 op_BTST27
00000D6E op_BTST28
00000D74 op_BTST29
00000D7A op_BTST30
00000D80 op_BTST31
00000D84 op_BTST32
00000DA0 op_BCHG
00000FFF MAX_TID
00001000 NR_TCB
00001108 op_BCLR
00001456 op_BSET
0000179E op_MOVEP
0000182A op_BOOL_I
000019D4 BSR_CLOSE1
000019DC op_BSR
00001A0A BSR_CLOSE2
00001A12 op_CMP_I
00001BFA op_ADD_I
00001D80 op_SUB_I
00001F06 op_MOVE
00001FD2 MOVE2
0000204E MOVE1
000020CE MOVE3
00002112 op_MOVE_xxx_FLAGS
00002228 MOVE4
00002306 op_EXT
00002332 op_SWAP
00002348 op_LEAPEA
000023E0 LEA1
000023F4 op_TAS
0000241A op_TST
00002458 op_LINKS
00002476 op_MOVE_USP
00002486 op_CHK
000024D0 op_NEGS
0000285E op_MOVEM
00002B7C op_ABCD
00002B9C ABCD_OUTER1
00002B9E ABCD_INNER1
00002BBA ABCD_NO_C1
00002BC2 ABCD_NO_C2
00002C0A ABCD_OUTER2
00002C0C ABCD_INNER2
00002C28 ABCD_NO_C3
00002C30 ABCD_NO_C4
00002C74 op_SBCD
00002C94 SBCD_OUTER1
00002C96 SBCD_INNER1
00002CB2 SBCD_NO_C1
00002CBA SBCD_NO_C2
00002D02 SBCD_OUTER2
00002D04 SBCD_INNER2
00002D20 SBCD_NO_C3
00002D28 SBCD_NO_C4
00002D6C op_NBCD
00002D84 NBCD_LOOP
00002D90 NBCD_NO_C
00002D94 NBCD_NO_Z
00002DCA NBCD_LOOP1
00002DDE NBCD_NO_C1
00002DE2 NBCD_NO_Z1
00002DFE op_TRAPV
00002E1A op_RTR
00002E26 RTR_DONE
00002E34 BSR_FAR2
00002E3C op_BCC
00002E44 BCC1
00002E4E BCC2
00002E56 BCC3
00002E60 BCC4
00002E68 BCC5
00002E72 BCC6
00002E7A BCC7
00002E84 BCC8
00002E8C BCC9
00002E96 BCC10
00002E9E BCC11
00002EA8 BCC12
00002EB0 BCC13
00002EBA BCC14
00002EBC op_DBCC
00002EC4 DBCC_LOOP1
00002ED2 DBCC_LOOP2
00002EE2 op_SCC
00002F12 op_ADDQ
00002F26 ADDQ_LOOP1
00002F64 ADDQ_LOOP2
00002F9A ADDQ_LOOP3
00002FCC op_SUBQ
00002FE4 SUBQ_LOOP1
0000301E SUBQ_LOOP2
00003054 SUBQ_LOOP3
00003086 op_MOVEQ
000030A2 op_DIVU
000030BE DIVU_OUTER1
000030F4 op_DIVS
00003110 DIVS_OUTER1
00003146 op_OR
00003166 OR_OUTER1
000031DA OR_OUTER2
00003230 op_AND
00003250 AND_OUTER1
000032C4 AND_OUTER2
0000331A op_EOR
0000333A EOR_OUTER2
00003390 op_CMP
000033B0 CMP_OUTER1
00003406 op_CMPA
00003426 CMPA_OUTER1
0000346C op_CMPM
000034B4 CMPM_LOOP1
000034CE CMPM_LOOP2
000034E8 CMPM_LOOP3
00003512 op_ADD
00003532 ADD_OUTER1
000035A6 ADD_OUTER2
000035FC op_SUB
0000361C SUB_OUTER1
00003690 SUB_OUTER2
000036E6 op_ADDA
0000370C ADDA_OUTER1
00003732 op_SUBA
00003758 SUBA_OUTER1
0000377E op_ADDX
0000379E ADDX_OUTER1
00003832 ADDX_LOOP3
0000384E ADDX_LOOP4
0000386A ADDX_LOOP5
0000388E op_SUBX
000038AE SUBX_OUTER1
00003942 SUBX_LOOP3
0000395E SUBX_LOOP4
0000397A SUBX_LOOP5
0000399E op_MULU
000039BA MULU_OUTER1
000039EA op_MULS
00003A06 MULS_OUTER1
00003A36 op_EXG
00003A98 ROx_FLAGS
00003AA4 op_ROx
00003AAE ROx_LOOP1
00003ACE ROx_LOOP2
00003AEE ROx_LOOP3
00003B0E ROx_LOOP4
00003B2E ROx_LOOP5
00003B50 ROx_LOOP6
00003CCE ROXx_FLAGS
00003CDA op_ROXx
00003CE4 ROXx_LOOP1
00003D04 ROXx_LOOP2
00003D24 ROXx_LOOP3
00003D44 ROXx_LOOP4
00003D64 ROXx_LOOP5
00003D86 ROXx_LOOP6
00003F04 SHIFTS_FLAGS
00003F10 op_SHIFTS
00003F1A SHIFTS_LOOP1
00003F3A SHIFTS_LOOP2
00003F5A SHIFTS_LOOP3
00003F7A SHIFTS_LOOP4
00003F9A SHIFTS_LOOP5
00003FBC SHIFTS_LOOP6
00004146 SHIFTS2_FLAGS
00004152 op_SHIFTS2
0000415C SHIFTS2_LOOP1
00004178 SHIFTS2_LOOP2
00004194 SHIFTS2_LOOP3
000041B0 SHIFTS2_LOOP4
000041CC SHIFTS2_LOOP5
000041EA SHIFTS2_LOOP6
00004370 START
00004372 GOWARM
00004376 GOOUT
0000437A GOIN
0000437E GOAUXO
00004382 GOAUXI
00004386 GOBYE
0000438A TXTBGN
0000438E ENDMEM
00004392 CSTART
000043FC WSTART
00004430 ST3
00004482 ST4
000044BC ClearStringArea
000044DC ClearStringStack
000044F0 TAB1
0000451F TAB2
0000455C TAB4
0000458E TAB5
00004591 TAB6
00004596 TAB8
000045A1 TAB9
000045A5 TAB10
000045A8 TAB11
000045B0 TAB1_1
000045E0 TAB2_1
00004620 TAB4_1
00004654 TAB5_1
0000465C TAB6_1
00004664 TAB8_1
00004680 TAB9_1
00004688 TAB10_1
00004690 TAB11_1
00004698 DIRECT
000046A8 EXEC
000046B0 EXLP
000046BA EXNGO
000046D2 EX1
000046D8 EXMAT
000046DE EXGO
000046E2 INCON
000046F0 INCOM
000046FE IOCOM
00004708 OUTCOM
00004714 IOCON
0000471E OUTCON
0000472A NEW
0000473E STOP
00004746 RUN
0000475A RUNNXL
0000479A RUN1
000047A6 RUNTSL
000047B0 RUNSML
000047C0 GOTO
000047D4 ONIRQ
000047EE ONIRQ1
000047F8 WAITIRQ
00004808 LIST
00004814 LS1
00004828 LS2
0000482E LS3
00004834 PRINT
00004844 PR2
00004852 PR0
00004860 PR1
0000486E PR3
0000487A PR6
00004880 PR8
0000489C PR9
000048B6 FINISH
000048BE GOSUB
000048F8 RETURN
00004924 FOR
0000493E FR1
00004956 FR2
0000495C FR3
00004962 FR4
0000496A FR5
0000497C FR6
00004988 FR7
000049A0 FR8
000049A4 NEXT
000049AE NX0
000049C0 NX3
000049EE NX1
00004A06 NX2
00004A0E REM
00004A10 IF
00004A14 IF1
00004A1A IF2
00004A2A INPERR
00004A38 INPUT
00004A5C IP7
00004A66 IP6
00004A6A IP2
00004A84 IP3
00004ABE IP4
00004ACA IP5
00004ACE DEFLT
00004AD6 LET
00004AE2 LT1
00004AE6 LOAD
00004AF2 LOD1
00004B0C LOD2
00004B1C LODEND
00004B26 GBYTE
00004B2A GBYTE1
00004B38 GBYTE2
00004B46 SAVE
00004B4E SAVE1
00004B72 SAVE2
00004B80 SAVEND
00004BA4 PBYTE
00004BA6 PBYTE1
00004BBA PBYTE2
00004BC4 POKE
00004C3A PKER
00004C3E CALL
00004C52 XP_PUSH
00004C68 XP_POP
00004C7E XP_POP1
00004C94 NUM_EXPR
00004CA2 INT_EXPR
00004CB4 EXPR_OR
00004CB4 EXPR
00004CC4 XP_OR
00004CDA EXPR_AND
00004CEC XP_AND
00004D02 XP_ANDX
00004D02 XP_ORX
00004D08 CheckNumeric
00004D1A EXPR_REL
00004D2E XP11
00004D3A XP12
00004D46 XP13
00004D52 XP14
00004D5E XP15
00004D6A XP15RT
00004D6C XP16
00004D7A XPRT0
00004D82 XPRT1
00004D8A XP17
00004D90 XP18
00004DA4 EXPR2
00004DB2 XP21
00004DB8 XP22
00004DBC XP23
00004DCA XP24
00004DF8 XP25
00004DFE XP26
00004E12 XP27
00004E14 ConcatString
00004E82 EXPR3
00004E84 XP36
00004E88 XP30
00004E94 XP31
00004EAA XP34
00004EC4 XP35
00004ECA XP_MOD
00004EEC EXPR4
00004EF8 XP40
00004F08 EXP4RT
00004F0A XP41
00004F1A XPSTNG
00004F24 XP45
00004F76 XP44
00004F82 PARN
00004F92 XP42
00004F94 XP43
00004F98 AllocateString
00004FF6 GarbageCollectStrings
00005032 NextString
00005048 StringInVar
00005066 SIV1
0000508E PointsIntoStringArea
000050B2 StringOnStack
000050E2 UpdateStringPointers
0000510E USP1
00005130 TSTV
00005178 TV1
000051A8 TV2
000051B0 TSTVRT
000051B2 DIV32
000051C4 DIV1
000051CA DIV2
000051D0 DIV3
000051DE DIV4
000051EC DIVRT
000051EE PEEK
00005256 RND
00005280 ABS
0000528C SIZE
0000529C TICK
000052A8 CORENO
000052B4 LorRArgs
000052EC LorR1
000052F0 MID
00005338 MID2
00005350 MID5
00005358 DOMID
00005384 MID4
000053B6 MID1
000053BA LEFT
000053C6 RIGHT
000053EE LEN
00005414 INT
0000542A CHR
00005462 SETVAL
00005480 SV1
00005482 FIN
0000548E FI1
0000549A FI2
0000549C ENDCHK
000054AC ENDCHK1
000054AE QWHAT
000054B0 AWHAT
000054B4 ERROR
000054EE QSORRY
000054F0 ASORRY
000054F6 QHOW
000054F8 AHOW
000054FE ETYPE
00005504 GETLN
00005514 GL1
00005532 GL2
00005546 GL3
0000556A GL4
00005576 GL5
00005592 GL6
0000559A GL7
000055A2 FNDLN
000055B0 FNDLNP
000055C6 FNDRET
000055C8 FNDNXT
000055CA FNDSKP
000055D8 MVUP
000055E0 MVRET
000055E2 MVUPW
000055EC MVDOWN
000055F4 POPA
00005630 PUSHA
00005666 PRTSTG
00005668 PS1
00005680 PRTRET
00005682 PRTSTR2a
00005688 PRTSTR2
0000568E PRTNUM
000056D8 PRTLN
000056F6 TSTC
00005708 TC1
0000570E TSTNUM
0000575A IGNBLK
00005764 TOUPBUF
0000576A TOUPB1
0000578A TOUPBRT
0000578C DOQUO
00005794 DOQUO1
0000579C TOUPPER
000057AC TOUPRET
000057AE CHKIO
000057BE CHKRET
000057C0 PRMESG
000057CA PRMRET
000057CC CLS
000057D8 OUTC
000057E8 INC
000057F4 INC1
00005808 AUXOUT
0000581C AUXIN
0000583A AXIRET
0000583C BYEBYE
0000584A INITMSG
0000586E OKMSG
00005875 HOWMSG
0000587C WHTMSG
00005884 TYPMSG
0000588C NOSTRING
0000589E SRYMSG
000058A4 CLMSG
000058A8 LSTROM
000058A8 RANPNT
000058AC INPPTR
000058B0 OUTPTR
000058B4 CURRNT
000058B8 STKFP
000058BC STKGOS
000058C0 STKINP
000058C4 LOPVAR
000058C8 LOPINC
000058D4 LOPLMT
000058E0 LOPLN
000058E4 LOPPT
000058E8 IRQROUT
000058EC STRSTK
000058F0 StrSp
000058F4 StrArea
000058F8 LastStr
000058FC TXTUNF
00005900 VARBGN
00005904 STKLMT
00005908 DIRFLG
0000590C BUFFER
0000595C TXT
0000595C set_text_mode
00005986 set_graphics_mode
000059B0 get_screen_color
000059C2 get_screen_address
000059CA clear_screen
000059F4 loop3
00005A06 CRLF
00005A20 UpdateTextPos
00005A4A CalcScreenLoc
00005A58 DisplayChar
00005A76 dcx14
00005A7A dcx7
00005A80 dccr
00005A9E dcx6
00005AB4 dcx8
00005ACA dcx9
00005AE8 dcx10
00005B00 dcx12
00005B0A dcx11
00005B44 dclf
00005B48 dcx16
00005B4C dcx4
00005B56 doBackspace
00005B64 doDelete
00005B9A doCtrlX
00005BBE IncCursorPos
00005BDE IncCursorRow
00005C10 icc1
00005C12 ScrollUp
00005C5A BlankLastLine
00005CB8 DisplayString
00005CBC dspj1
00005CC8 dsret
00005CCE DisplayStringCRLF
00005CD4 DisplayStringLimited
00005CF4 DisplayStringLimitedCRLF
00005CFA HomeCursor
00005D0C SyncCursor
00005D40 TRAP15
00005D58 T15DispatchTable
00005E08 Cursor1
00005E40 StubRout
00005E42 select_iofocus
00005E54 rotate_iofocus
00005E66 select_focus1
00005E84 init_plic
00005EBA keybd_init
00005EBA setup_keybd
00005F28 KBD_CMDTBL
00005F48 keybd_cmdproc
00005F6E keybd_stat
00005F76 keybd_putchar
00005F7E keybd_getchar
00005F86 keybd_getbuf
00005F86 keybd_putbuf
00005F86 keybd_set_inpos
00005F86 keybd_set_outpos
00005F8A KeybdGetID
00005FBC kgid1
00005FC4 kgnotKbd
00005FC8 KeybdSetLED
00005FF4 KeybdInit
00005FF4 _KeybdInit
00006020 kbdi0002
0000608A kbdiTryAgain
00006098 kbdi0004
000060B4 kbdi0005
000060B8 ledxit
000060CE kbdiXmitBusy
000060DC msgBadKeybd
000060EB msgXmitBusy
00006106 _KeybdGetStatus
00006124 _KeybdGetScancode
00006142 _KeybdClearIRQ
00006158 KeybdRecvByte
0000617A KeybdWaitTx
000061A0 SetKeyboardEcho
000061A8 CheckForKey
000061B4 GetKey
000061EC CheckForCtrlC
000061F8 KeybdGetCharNoWait
00006200 KeybdGetCharWait
00006208 KeybdGetChar
00006424 KeybdSetLEDStatus
00006474 KeybdSendByte
0000647C Wait10ms
00006498 Wait300ms
000064B4 KeybdIRQ
0000656A _unshiftedScanCodes
0000666A _shiftedScanCodes
0000676A _keybdControlCodes
000067EA _keybdExtendedCodes
0000686A cmdString
000068A4 cmdTable
0000690C FromScreen
00006916 StartMon
00006920 Monitor
00006920 cmdMonitor
0000693C PromptLn
00006948 Prompt3
0000695E Prompt1
00006970 cmdDispatch
000069B6 cmdVideoMode
000069F6 cmdBreakpoint
00006A1A cmdTinyBasic
00006A1E cmdTestCPU
00006A2E cmdClearScreen
00006A3A cmdCore
00006A5E cmdFMTK
00006A66 cmdTestFP
00006AF2 cmdTestGF
00006B20 cmdClock
00006B3E cmdReset
00006B70 tblPow2
00006B90 DisplayHelp
00006B90 cmdHelp
00006B9C HelpMsg
00006D22 msgUnknownCmd
00006D32 msgHello
00006D44 GetCmdLine
00006DE8 cmdSendSerial
00006E18 cmdReceiveSerial
00006E4C cmdFillB
00006EA0 cmdFillW
00006EF4 cmdFillL
00006F40 ignBlanks
00006F52 PeekScreenChar
00006F58 GetSzChar
00006F7E EditMemHelper
00006FA0 cmdEditMemory
00006FAA edtmem1
00006FF6 ExecuteCode
00006FF6 cmdJump
00007006 cmdDisassemble
00007056 cmdDumpMemory
0000707A DumpMem1
0000708C DisplayMem
000070B8 dspmem1
00007120 cmdDumpRegs
000071A0 msg_regs
000071A4 msg_reglist
000071CA cmdTestSerialReceive
000071EA GetHexNumber
00007218 GetDecNumber
00007250 _dfOne
0000725C _dfTen
00007268 _dfMil
00007274 _msgNan
00007278 _msgInf
0000727C _CheckNan
000072E0 _CheckZero
000072FA _CheckNegative
0000730C _MakeBig
00007328 _LessThanDbl
00007354 _ComputeDigitsBeforeDecpt
0000738E _LeadingZero
0000739E _SpitOutDigits
0000741A _TrimTrailingPoint
00007438 _TrimDotZero
00007454 _TrimTrailingZeros
00007460 _SpitOutE
00007478 _ExtExpDigit
00007496 _ExtExpDigits
000074BE _PadLeft
0000750E _PadRight
00007540 _FloatToString
00007582 _GetFloatGetChar
00007588 _GetFloatIgnBlanks
00007590 _GetFloatBackupChar
00007594 _GetFraction
000075F8 _GetExponent
00007682 _GetInteger
000076F8 _GetFloat
00007770 AsciiToHexNybble
00007782 gthx5
00007794 gthx6
000077A6 gthx3
000077AA DisplayTwoSpaces
000077B4 dspspc1
000077BC DisplaySpace
000077C4 DisplayTetra
000077CA DisplayWyde
000077D0 DisplayByte
000077D6 DisplayNybble
000077F0 BufTetra
000077F6 BufWyde
000077FC BufByte
00007802 BufNybble
0000781A DisplayAddr
0000783A ramtest
0000783A cmdTestRAM
00007854 rmtst5
00007884 ramtest0
0000788C ramtest1
0000789C rmtst1
000078A8 ramtest6
000078B8 ramtest2
000078CE rmtst2
000078D6 rmtst3
000078FA ramtest3
000078FC cmdLoadS19
00007902 NextRec
00007914 ProcessRec
000079AA pcssxa
00007A16 ProcessS1
00007A1A ProcessS2
00007A1E ProcessS3
00007A22 ProcessS7
00007A32 ProcessS8
00007A42 ProcessS9
00007A52 S19Get16BitAddress
00007A60 S19Get24BitAddress
00007A6C S19Get32BitAddress
00007A8A S1932a
00007A9E S1932b
00007AE0 sGetChar
00007B08 AudioInputTest
00007B0A BouncingBalls
00007B0C GraphicsDemo
00007B0E ClearScreen
00007B14 rbo
00007B1C serial_init
00007B1C setup_serial
00007B6C COM_CMDTBL
00007B9C serial_cmdproc
00007BC2 serial_stat
00007BC6 serial_putchar
00007BCE serial_getchar
00007BD4 serial_getchar_direct
00007BDC serial_peek_char
00007BE4 serial_peek_char_direct
00007BEC serial_putchar_direct
00007BF4 serial_getbuf
00007BF4 serial_set_inpos
00007BF4 serial_set_outpos
00007BF4 serial_putbuf
00007BF8 SerialInit
00007C36 SerialGetChar
00007CAE SerialPeekChar
00007CEA SerialPeekCharDirect
00007D04 SerialPutChar
00007D68 SerialPutCharDirect
00007D84 SerialRbo
00007D8C SerialRcvCount
00007DAC SerialIRQ
00007DC0 sirqNxtByte
00007DD2 sirq0001
00007E22 notRxInt
00007E22 sirqRxFull
00007E70 sirq0002
00007E70 sirqTxEmpty
00007E70 notTxInt
00007E70 sirqXmitOff
00007E82 nmeSerial
00007E8A i2c_setup
00007E8A init_i2c
00007E9A i2c_wait_tip
00007EAA i2c_wr_cmd
00007EBA i2c_xmit1
00007ED8 i2c_wait_rx_nack
00007EE8 rtc_read
00007F74 rtc_write
00007FDE msgRtcReadFail
00007FF7 msgBusErr
00008008 bus_err
00008022 trap3
00008060 ProcessBreakpoint
00008066 DisarmAllBreakpoints
00008092 ArmAllBreakpoints
000080C2 ArmBreakpoint
00008140 DisarmBreakpoint
00008194 ListBreakpoints
000081B4 ClearBreakpointList
000081C6 SendMsg
00008204 ReceiveMsg
00008246 DispatchMsg
00008248 prtflt
0000828E T15FloatToString
000082C2 io_trap
000082EA OutputChar
00008320 InitIRQ
00008334 InstallIRQ
00008378 TickIRQ
000083B4 irq6_rout
000083B4 irq_rout
000083B4 irq3_rout
000083C8 irq_proc_generic
000083E6 SpuriousIRQ
000083E8 nmi_rout
000083FA addr_err
00008410 brdisp_trap
00008448 illegal_trap
0000845E io_irq
00008472 msg_start
00008499 msg_core_start
000084AA msgAddrErr
000084B7 msg_illegal
000084C9 msg_bad_branch_disp
000084DB msg_test_done
000084EB msg_io_access
00008506 msgChk
00008514 msgStackCanary
0000852E ShiftBuf
00008548 HEX2DEC2
00008596 HEX2DEC
000085A6 HX2DC
000085AA HX2DC0
000085B2 HX2DC1
000085CC HX2DC2
000085CE HX2DC22
000085D8 HX2DC3
000085E0 HX2DC4
000085E8 HX2DC5
000085F0 HX2DC57
000085F4 HX2DC6
000085FA PNT4HEX
000085FA PNT4HX
000085FE PNT6HX
0000860A PNT8HX
0000860E FRELADDR
0000861C FREL10
0000862E FREL15
00008648 FREL20
0000865A FREL25
00008664 FREL30
0000866C IMOVEMFR
0000866C X
00008680 IM7788
00008684 IM7799
0000869A IMOVEMTR
000086B4 CS16
000086B6 ISTOP
000086CA IMMED
000086F0 IMMED45
00008722 CS15
00008724 IMMED55
0000872A IMMED65
0000873A IMMED75
0000873E IMOVE
00008742 ILINK
00008758 FORM1
0000875C FORM1A
00008760 CS14
00008762 FORM3
00008766 FORM4
00008778 FORM5
0000877C FORM6A
0000878C FORM6D
0000879C FORMREGA
000087A0 FORMREG5
000087AC FORMREGD
000087B2 FORM7
000087BE FORM8
000087C2 FORM815
000087CA CS13
000087CC FORM9
000087D2 EEA10
000087D6 FORM10EX
000087F8 FORM10E3
00008800 FORM10E4
0000880C FORM10E6
00008814 FORM10
0000881A FORM103
0000881E FORM104
0000882E FORM105
00008844 CS12
00008848 FORM11
00008850 FORM11SL
00008864 FORM112
00008872 FORM114
00008874 FORM12
0000888E FORM125
000088B0 FORM12A
000088D4 CS11
000088D8 IQUICK
000088DC IMOVEQ
000088F4 SCHR
000088FC IMVFSR
0000890A IMVFUSP
00008918 IMVTSR
00008926 IMVT44
0000892A IMVTUSP
00008936 IMVTCCR
00008946 IMOVEP
00008956 IMOVEP11
0000896E CS20
00008972 IMOVEP35
00008980 IMOVEP66
0000899C SCOMMON
000089A0 ISCC
000089AA IDBCC
000089BC ICC
000089C0 IBSR
000089D2 ICC35
000089E8 ICC55
000089F8 ISETD
000089FE ISETD12
00008A06 CS18
00008A08 ISETS
00008A22 ISHIFT
00008A2E ISHIFT13
00008A52 ISHIFT23
00008A5E ISHIFT33
00008A62 ISHIFT44
00008A6A CS17
00008A6C ISHIFTM1
00008A86 ICCCC
00008A9C ICCCC9
00008A9E BRTBL
00008ABE IMOVEA1
00008AE4 IMOVE19
00008AEA IQUICKA
00008AFC IQUICK21
00008B12 IQUICK31
00008B16 CS19
00008B1A FORMSIZE
00008B2E FORM91
00008B42 FORM93
00008B44 FORM95
00008B46 EA000
00008B52 EA001
00008B5E EA010
00008B72 EA011
00008B88 EA011RTS
00008B8A EA100
00008BA0 FE10
00008BA4 EEA
00008C08 EA1105
00008C0C EA1107
00008C22 EA1109
00008C2C EA101
00008C42 EA111
00008C60 EA1112
00008C7C EA1113
00008C88 FE11
00008C8C EA1113A
00008CAE EA1114
00008CF6 EAF25
00008CFA EAF27
00008D0E EAF35
00008D18 EA1115
00008D50 EA11153
00008D5A EA11155
00008D66 MOVEMS
00008D76 MOVEMS2
00008D7A MOVEMR
00008D8A MOVEMR11
00008D92 MOVEMR33
00008DA4 MOVEMR44
00008DBE MOVEMR77
00008DD0 MOVEMR79
00008DD2 MOVEMR88
00008DEA MOVEMR94
00008DF6 DCODE68K
00008E0A DEC311
00008E28 DEC404
00008E38 DEC411
00008E46 FE12
00008E48 DEC425
00008E54 DEC510
00008E58 DEC515
00008E60 DEC530
00008E66 DEC535
00008E72 DEC537
00008E8E COMMON4
00008E90 COMMON
00008E9E COMMON35
00008EB8 FERROR
00008EC2 FERROR35
00008ECE FERROR39
00008ED8 MSG111
00008EE2 KI
00008EE4 KIEND
00008EE4 TBL
0000919C OPCTBL
0000919C TBLE
0001001C _Keybd_tick
00040000 CursorRow
00040001 CursorCol
00040002 TextPos
00040002 TextCurpos
00040004 TextScr
00040008 S19StartAddress
0004000C KeybdEcho
0004000D KeybdWaitFlag
00040040 CmdBuf
00040080 CmdBufEnd
00040084 fgColor
00040088 bkColor
0004008C TextRows
0004008D TextCols
00040094 _fpTextIncr
00040098 _canary
000400A0 IRQFlag
000400A4 InputDevice
000400A8 OutputDevice
00040100 Regsave
00040202 NumSetBreakpoints
00040220 Breakpoints
00040280 BreakpointWords
000402C0 fpBuf
00040508 _width
0004050C _E
00040510 _digits_before_decpt
00040514 _precision
00040520 _fpBuf
00040600 _fpWork
00040800 _dasmbuf
00040880 OFFSET
00040A00 null_dcb
00040A40 keybd_dcb
00040A80 con_dcb
00040B40 serial_dcb
00040BFC TimerStack
00100000 IOFocus
00100004 memend
0010000E KeybdLEDs
0010000F _KeyState1
00100010 _KeyState2
00100011 _KeybdHead
00100012 _KeybdTail
00100013 _KeybdCnt
00100018 KeybdID
00100020 _KeybdBuf
00100080 _KeybdOBuf
00100150 S19Checksum
00100160 SerTailRcv
00100162 SerHeadRcv
00100164 SerRcvXon
00100165 SerRcvXoff
00100166 SerTailXmit
00100168 SerHeadXmit
0010016A SerXmitXoff
00100200 RTCBuf
00100224 RunningTCB
0010030C FreeTCB
0010031C QueueCycle
00100320 readyQ
00101000 SerRcvBuf
00102000 SerXmitBuf
20010000 tcbs

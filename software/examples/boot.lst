Sections:
00: "DATA" (0-218)
01: "seg500" (500-500)
02: "CODE" (0-6D5B)


Source: "boot.asm"
                            	     1: ;-------------------------------------------------------------------------------
                            	     2: ;
                            	     3: ; system memory map
                            	     4: ;
                            	     5: ;
                            	     6: ; 00000000 +----------------+      <+
                            	     7: ;          | startup sp,pc  | 8 B   |
                            	     8: ; 00000008 +----------------+       |
                            	     9: ;					 |    vectors     | pair shared+
                            	    10: ; 00000400 +----------------+       |
                            	    11: ;					 |   bios mem     |       |
                            	    12: ; 00001000 +----------------+       |
                            	    13: ;					 |   bios code    |       |
                            	    14: ; 00008000 +----------------+      <+
                            	    15: ;					 |    unused      |
                            	    16: ; 00040000 +----------------+
                            	    17: ;					 |   local ram    |
                            	    18: ; 00042000 +----------------+
                            	    19: ;					 |    unused      |
                            	    20: ; 00100000 +----------------+
                            	    21: ;					 |   global ram   |
                            	    22: ; 00101000 +----------------+
                            	    23: ;					 | serial rcvbuf  |
                            	    24: ; 00102000 +----------------+
                            	    25: ;					 |    unused      |
                            	    26: ; 20000000 +----------------+
                            	    27: ;          |                |
                            	    28: ;          |                |
                            	    29: ;          |                |
                            	    30: ;          :  dram memory   : 512 MB
                            	    31: ;          |                |
                            	    32: ;          |                |
                            	    33: ;          |                |
                            	    34: ; 40000000 +----------------+
                            	    35: ;          |                |
                            	    36: ;          :     unused     :
                            	    37: ;          |                |
                            	    38: ; FD000000 +----------------+
                            	    39: ;          |                |
                            	    40: ;          :    I/O area    : 1.0 M
                            	    41: ;          |                |
                            	    42: ; FFE00000 +----------------+
                            	    43: ;          |                |
                            	    44: ;          :     unused     :
                            	    45: ;          |                |
                            	    46: ; FFFFFFFF +----------------+
                            	    47: ;
                            	    48: ;-------------------------------------------------------------------------------
                            	    49: ;
                            	    50: HAS_MMU equ 0
                            	    51: 
                            	    52: CTRLC	EQU		$03
                            	    53: CTRLH	EQU		$08
                            	    54: CTRLS	EQU		$13
                            	    55: CTRLX	EQU		$18
                            	    56: CTRLZ	EQU		$1A
                            	    57: LF		EQU		$0A
                            	    58: CR		EQU		$0D
                            	    59: XON		EQU		$11
                            	    60: XOFF	EQU		$13
                            	    61: 
                            	    62: SC_F12  EQU    $07
                            	    63: SC_C    EQU    $21
                            	    64: SC_T    EQU    $2C
                            	    65: SC_Z    EQU    $1A
                            	    66: SC_KEYUP	EQU		$F0
                            	    67: SC_EXTEND   EQU		$E0
                            	    68: SC_CTRL		EQU		$14
                            	    69: SC_RSHIFT	EQU		$59
                            	    70: SC_NUMLOCK	EQU		$77
                            	    71: SC_SCROLLLOCK	EQU	$7E
                            	    72: SC_CAPSLOCK		EQU	$58
                            	    73: SC_ALT		EQU		$11
                            	    74: SC_LSHIFT	EQU		$12
                            	    75: SC_DEL		EQU		$71		; extend
                            	    76: SC_LCTRL	EQU		$58
                            	    77: SC_TAB      EQU		$0D
                            	    78: 
                            	    79: 	if HAS_MMU
                            	    80: TEXTREG		EQU	$1E3FF00	; virtual addresses
                            	    81: txtscreen	EQU	$1E00000
                            	    82: semamem		EQU	$1E50000
                            	    83: ACIA			EQU	$1E60000
                            	    84: ACIA_RX		EQU	0
                            	    85: ACIA_TX		EQU	0
                            	    86: ACIA_STAT	EQU	4
                            	    87: ACIA_CMD	EQU	8
                            	    88: ACIA_CTRL	EQU	12
                            	    89: I2C2 			equ $01E69000
                            	    90: I2C_PREL 	equ 0
                            	    91: I2C_PREH 	equ 1
                            	    92: I2C_CTRL 	equ 2
                            	    93: I2C_RXR 	equ 3
                            	    94: I2C_TXR 	equ 3
                            	    95: I2C_CMD 	equ 4
                            	    96: I2C_STAT 	equ 4
                            	    97: PLIC			EQU	$1E90000
                            	    98: MMU				EQU $FDC00000	; physical address
                            	    99: leds			EQU	$1EFFF00	; virtual addresses
                            	   100: keybd			EQU	$1EFFE00
                            	   101: KEYBD			EQU	$1EFFE00
                            	   102: RAND			EQU	$1EFFD00
                            	   103: RAND_NUM	EQU	$1EFFD00
                            	   104: RAND_STRM	EQU	$1EFFD04
                            	   105: RAND_MZ		EQU $1EFFD08
                            	   106: RAND_MW		EQU	$1EFFD0C
                            	   107: RST_REG		EQU	$1EFFC00
                            	   108: IO_BITMAP	EQU $1F00000
                            	   109: 	else
                            	   110: TEXTREG		EQU	$FD03FF00	; virtual addresses
                            	   111: txtscreen	EQU	$FD000000
                            	   112: semamem		EQU	$FD050000
                            	   113: ACIA			EQU	$FD060000
                            	   114: ACIA_RX		EQU	0
                            	   115: ACIA_TX		EQU	0
                            	   116: ACIA_STAT	EQU	4
                            	   117: ACIA_CMD	EQU	8
                            	   118: ACIA_CTRL	EQU	12
                            	   119: I2C2 			equ $FD069000
                            	   120: I2C_PREL 	equ 0
                            	   121: I2C_PREH 	equ 1
                            	   122: I2C_CTRL 	equ 2
                            	   123: I2C_RXR 	equ 3
                            	   124: I2C_TXR 	equ 3
                            	   125: I2C_CMD 	equ 4
                            	   126: I2C_STAT 	equ 4
                            	   127: PLIC			EQU	$FD090000
                            	   128: MMU				EQU $FDC00000	; physical address
                            	   129: leds			EQU	$FD0FFF00	; virtual addresses
                            	   130: keybd			EQU	$FD0FFE00
                            	   131: KEYBD			EQU	$FD0FFE00
                            	   132: RAND			EQU	$FD0FFD00
                            	   133: RAND_NUM	EQU	$FD0FFD00
                            	   134: RAND_STRM	EQU	$FD0FFD04
                            	   135: RAND_MZ		EQU $FD0FFD08
                            	   136: RAND_MW		EQU	$FD0FFD0C
                            	   137: RST_REG		EQU	$FD0FFC00
                            	   138: IO_BITMAP	EQU $FD000000
                            	   139: 	endif
                            	   140: 
                            	   141: SERIAL_SEMA	EQU	2
                            	   142: KEYBD_SEMA	EQU	3
                            	   143: RAND_SEMA		EQU	4
                            	   144: SCREEN_SEMA	EQU	5
                            	   145: MEMORY_SEMA EQU 6
                            	   146: TCB_SEMA 		EQU	7
                            	   147: 
                            	   148: 	data
00:00000000 00040FFC        	   149: 	dc.l		$00040FFC
00:00000004 00000000        	   150: 	dc.l		start
00:00000008 00006984        	   151: 	dc.l		bus_err
00:0000000C 00000000        	   152: 	dc.l		0
00:00000010 00006CAA        	   153: 	dc.l		illegal_trap		* ILLEGAL instruction
00:00000014 00000000        	   154: 	dc.l		0
00:00000018 0000042E        	   155: 	dc.l		EXCEPTION_6			* CHK
00:0000001C 00000436        	   156: 	dc.l		EXCEPTION_7			* TRAPV
00:00000020 00000000        	   157: 	dc.l		0
00:00000024 00000000        	   158: 	dc.l		0
                            	   159: 	
                            	   160: 	; 10
00:00000028 00000000        	   161: 	dc.l		0
00:0000002C 00000000        	   162: 	dc.l		0
00:00000030 00000000        	   163: 	dc.l		0
00:00000034 00000000        	   164: 	dc.l		0
00:00000038 00000000        	   165: 	dc.l		0
00:0000003C 00000000        	   166: 	dc.l		0
00:00000040 00000000        	   167: 	dc.l		0
00:00000044 00000000        	   168: 	dc.l		0
00:00000048 00000000        	   169: 	dc.l		0
00:0000004C 00000000        	   170: 	dc.l		0
                            	   171: 	
                            	   172: 	; 20
00:00000050 00000000        	   173: 	dc.l		0
00:00000054 00000000        	   174: 	dc.l		0
00:00000058 00000000        	   175: 	dc.l		0
00:0000005C 00000000        	   176: 	dc.l		0
00:00000060 00006C5E        	   177: 	dc.l		SpuriousIRQ
00:00000064 00000000        	   178: 	dc.l		0
00:00000068 00000000        	   179: 	dc.l		0
00:0000006C 00006C38        	   180: 	dc.l		irq3_rout
00:00000070 00000000        	   181: 	dc.l		0
00:00000074 00000000        	   182: 	dc.l		0
                            	   183: 	
                            	   184: 	; 30
00:00000078 00006BF2        	   185: 	dc.l		TickIRQ						; IRQ 30 - timer / keyboard
00:0000007C 00006C60        	   186: 	dc.l		nmi_rout
00:00000080 00000000        	   187: 	dc.l		0
00:00000084 00000000        	   188: 	dc.l		0
00:00000088 00000000        	   189: 	dc.l		0
00:0000008C 00006988        	   190: 	dc.l		trap3							; breakpoint
00:00000090 00000000        	   191: 	dc.l		0
00:00000094 00000000        	   192: 	dc.l		0
00:00000098 00000000        	   193: 	dc.l		0
00:0000009C 00000000        	   194: 	dc.l		0
                            	   195: 
                            	   196: 	; 40
00:000000A0 00000000        	   197: 	dc.l		0
00:000000A4 00000000        	   198: 	dc.l		0
00:000000A8 00000000        	   199: 	dc.l		0
00:000000AC 00000000        	   200: 	dc.l		0
00:000000B0 00000000        	   201: 	dc.l		0
00:000000B4 00000000        	   202: 	dc.l		0
00:000000B8 00000000        	   203: 	dc.l		0
00:000000BC 0000522A        	   204: 	dc.l		TRAP15
00:000000C0 00000000        	   205: 	dc.l		0
00:000000C4 00000000        	   206: 	dc.l		0
                            	   207: 
                            	   208: 	; 50	
00:000000C8 00000000        	   209: 	dc.l		0
00:000000CC 00000000        	   210: 	dc.l		0
00:000000D0 00000000        	   211: 	dc.l		0
00:000000D4 00000000        	   212: 	dc.l		0
00:000000D8 00000000        	   213: 	dc.l		0
00:000000DC 00000000        	   214: 	dc.l		0
00:000000E0 00000000        	   215: 	dc.l		0
00:000000E4 00000000        	   216: 	dc.l		0
00:000000E8 00000000        	   217: 	dc.l		0
00:000000EC 00006CC0        	   218: 	dc.l		io_irq
                            	   219: 
                            	   220: 	; 60
00:000000F0 00005866        	   221: 	dc.l		KeybdIRQ
00:000000F4 00006786        	   222: 	dc.l		SerialIRQ
00:000000F8 00000000        	   223: 	dc.l		0
00:000000FC 00006C72        	   224: 	dc.l		brdisp_trap
00:00000100 00000000        	   225: 	dc.l		0
00:00000104 00000000        	   226: 	dc.l		0
00:00000108 00000000        	   227: 	dc.l		0
00:0000010C 00000000        	   228: 	dc.l		0
00:00000110 00000000        	   229: 	dc.l		0
00:00000114 00000000        	   230: 	dc.l		0
                            	   231: 
                            	   232: 	org			$400
                            	   233: 
                            	   234: InstalledIRQ:
00:00000400 00000000        	   235: 	dc.l		0
00:00000404 00000000        	   236: 	dc.l		0
00:00000408 00000000        	   237: 	dc.l		0
00:0000040C 00000000        	   238: 	dc.l		0
00:00000410 00000000        	   239: 	dc.l		0
00:00000414 00000000        	   240: 	dc.l		0
00:00000418 00000000        	   241: 	dc.l		0
00:0000041C 00000000        	   242: 	dc.l		0
                            	   243: 
00:00000420 00000000        	   244: 	dc.l		0
00:00000424 00000000        	   245: 	dc.l		0
00:00000428 00000000        	   246: 	dc.l		0
00:0000042C 00000000        	   247: 	dc.l		0
00:00000430 00000000        	   248: 	dc.l		0
00:00000434 00000000        	   249: 	dc.l		0
00:00000438 00000000        	   250: 	dc.l		0
00:0000043C 00000000        	   251: 	dc.l		0
                            	   252: 
00:00000440 00000000        	   253: 	dc.l		0
00:00000444 00000000        	   254: 	dc.l		0
00:00000448 00000000        	   255: 	dc.l		0
00:0000044C 00000000        	   256: 	dc.l		0
00:00000450 00000000        	   257: 	dc.l		0
00:00000454 00000000        	   258: 	dc.l		0
00:00000458 00000000        	   259: 	dc.l		0
00:0000045C 00000000        	   260: 	dc.l		0
                            	   261: 
00:00000460 00000000        	   262: 	dc.l		0
00:00000464 00000000        	   263: 	dc.l		0
00:00000468 00000000        	   264: 	dc.l		0
00:0000046C 00000000        	   265: 	dc.l		0
00:00000470 00000000        	   266: 	dc.l		0
00:00000474 00000000        	   267: 	dc.l		0
00:00000478 00000000        	   268: 	dc.l		0
00:0000047C 00000000        	   269: 	dc.l		0
                            	   270: 
00:00000480 00000000        	   271: 	dc.l		0
00:00000484 00000000        	   272: 	dc.l		0
00:00000488 00000000        	   273: 	dc.l		0
00:0000048C 00000000        	   274: 	dc.l		0
00:00000490 00000000        	   275: 	dc.l		0
00:00000494 00000000        	   276: 	dc.l		0
00:00000498 00000000        	   277: 	dc.l		0
00:0000049C 00000000        	   278: 	dc.l		0
                            	   279: 
00:000004A0 00000000        	   280: 	dc.l		0
00:000004A4 00000000        	   281: 	dc.l		0
00:000004A8 00000000        	   282: 	dc.l		0
00:000004AC 00000000        	   283: 	dc.l		0
00:000004B0 00000000        	   284: 	dc.l		0
00:000004B4 00000000        	   285: 	dc.l		0
00:000004B8 00000000        	   286: 	dc.l		0
00:000004BC 00000000        	   287: 	dc.l		0
                            	   288: 
00:000004C0 00000000        	   289: 	dc.l		0
00:000004C4 00000000        	   290: 	dc.l		0
00:000004C8 00000000        	   291: 	dc.l		0
00:000004CC 00000000        	   292: 	dc.l		0
00:000004D0 00000000        	   293: 	dc.l		0
00:000004D4 00000000        	   294: 	dc.l		0
00:000004D8 00000000        	   295: 	dc.l		0
00:000004DC 00000000        	   296: 	dc.l		0
                            	   297: 
00:000004E0 00000000        	   298: 	dc.l		0
00:000004E4 00000000        	   299: 	dc.l		0
00:000004E8 00000000        	   300: 	dc.l		0
00:000004EC 00000000        	   301: 	dc.l		0
00:000004F0 00000000        	   302: 	dc.l		0
00:000004F4 00000000        	   303: 	dc.l		0
00:000004F8 00000000        	   304: 	dc.l		0
00:000004FC 00000000        	   305: 	dc.l		0
                            	   306: 
                            	   307: 	org			$500
                            	   308: 
                            	   309: ;-------------------------------------------------------------------------------
                            	   310: ;-------------------------------------------------------------------------------
                            	   311: 
                            	   312: ; BIOS variables which must be local (not shared) to each core
                            	   313: 
                            	   314: CursorRow	equ		$40000
                            	   315: CursorCol	equ		$40001
                            	   316: TextPos		equ		$40002
                            	   317: TextCurpos	equ	$40002
                            	   318: TextScr			equ	$40004
                            	   319: S19StartAddress	equ	$40008
                            	   320: KeybdEcho		equ	$4000C
                            	   321: KeybdWaitFlag	equ	$4000D
                            	   322: CmdBuf			equ $40040
                            	   323: CmdBufEnd		equ	$40080
                            	   324: fgColor			equ	$40084
                            	   325: bkColor			equ	$40088
                            	   326: TextRows		equ	$4008C
                            	   327: TextCols		equ	$4008D
                            	   328: Regsave			equ	$40100
                            	   329: numBreakpoints	equ		8
                            	   330: BreakpointFlag	equ		$40200
                            	   331: NumSetBreakpoints	equ	$40202	; to $40203
                            	   332: Breakpoints			equ		$40220	; to $40240
                            	   333: BreakpointWords	equ		$40280	; to $402A0
                            	   334: ;RunningTCB  equ $40300
                            	   335: TimerStack	equ	$40BFC
                            	   336: 
                            	   337: ; Keyboard buffer is in shared memory
                            	   338: IOFocus			EQU	$00100000
                            	   339: memend			equ $00100004
                            	   340: KeybdLEDs		equ	$0010000E
                            	   341: _KeyState1	equ	$0010000F
                            	   342: _KeyState2	equ	$00100010
                            	   343: _KeybdHead	equ	$00100011
                            	   344: _KeybdTail	equ	$00100012
                            	   345: _KeybdCnt		equ	$00100013
                            	   346: KeybdID			equ	$00100016
                            	   347: _KeybdBuf		equ	$00100020
                            	   348: S19Checksum	equ	$00100150
                            	   349: SerTailRcv	equ	$00100160
                            	   350: SerHeadRcv	equ	$00100162
                            	   351: SerRcvXon		equ	$00100164
                            	   352: SerRcvXoff	equ	$00100165
                            	   353: SerRcvBuf		equ	$00101000
                            	   354: RTCBuf			equ $00100200	; to $0010023F
                            	   355: 
                            	   356: 	include "..\Femtiki\source\kernel\Femtiki_vars.x68"

Source: "..\Femtiki\source\kernel\Femtiki_vars.x68"
                            	     1: 
                            	     2: PAMShareCounts	EQU	$20000000	; one byte for each physical page of memory
                            	     3: tcbs						EQU	$20010000	; 4095*256 = 1MB
                            	     4: tcbs_end				EQU	$20020000
                            	     5: messages				EQU	$20020000	; 32*8192 (680*16=21760 messages)
                            	     6: messages_end		EQU	$20060000
                            	     7: mailboxes				EQU	$20060000
                            	     8: mailboxes_end		EQU	$20078000	;	12*8192 (816*12=9792 mailboxes)
                            	     9: acbs						EQU	$20080000	; 32*2*8192 =512kB
                            	    10: acbs_end				EQU	$20100000
                            	    11: 
                            	    12: 
                            	    13: sys_stacks			EQU	$DF0000
                            	    14: 
                            	    15: FemtikiVars			EQU	$00100200
                            	    16: PAMLastAllocate2	EQU		$00100218
                            	    17: RunningAID		EQU		$00100220
                            	    18: RunningTCB			EQU		$00100224
                            	    19: ACBPtrs				EQU		$00100228
                            	    20: MidStackBottoms	EQU		$00100264
                            	    21: FemtikiInited	EQU		$00100284
                            	    22: missed_ticks	EQU		$00100288
                            	    23: IOFocusList		EQU		$0010028C
                            	    24: IOFocusID			EQU		$001002AC
                            	    25: iof_switch		EQU		$001002AD
                            	    26: nMessage			EQU		$001002AE
                            	    27: nMailbox			EQU		$001002B0
                            	    28: hKeybdMbx			EQU		$001002BA
                            	    29: hFocusSwitchMbx		EQU		$001002BC
                            	    30: BIOS_RespMbx	EQU		$001002BE
                            	    31: hasUltraHighPriorityTasks	EQU		$001002C0
                            	    32: im_save				EQU		$001002C2
                            	    33: sp_tmp				EQU		$001002C4
                            	    34: startQNdx			EQU		$001002C6
                            	    35: NPAGES				EQU		$001002D8
                            	    36: syspages			EQU		$001002DA
                            	    37: mmu_FreeMaps	EQU		$001002E0
                            	    38: mmu_entries		EQU		$00100300
                            	    39: freelist			EQU		$00100302
                            	    40: hSearchMap		EQU		$00100304
                            	    41: OSActive			EQU		$00100305
                            	    42: FreeACB				EQU		$00100308
                            	    43: FreeTCB				EQU		$0010030C
                            	    44: FreeMSG				EQU		$00100310
                            	    45: FreeMBX				EQU		$00100314
                            	    46: TimeoutList		EQU		$00100318
                            	    47: QueueCycle    EQU   $0010031C
                            	    48: readyQ				EQU		$00100320
                            	    49: readyQTail		EQU		$00100340
                            	    50: FemtikiVars_end	EQU	$00100400
                            	    51: 
                            	    52: ;gc_stack		rmb		512
                            	    53: ;gc_pc				fcdw		0
                            	    54: ;gc_omapno		fcw			0
                            	    55: ;gc_mapno		fcw			0
                            	    56: ;gc_dl				fcw			0
                            	    57: 

Source: "boot.asm"
                            	   357: 
                            	   358: 	code
                            	   359: 	align		2
                            	   360: start:
02:00000000 46FC2700        	   361: 	move.w #$2700,sr					; enable level 6 and higher interrupts
02:00000004 7000            	   362: 	moveq #0,d0								; set address space zero
02:00000006 4E7B0003        	   363: 	movec d0,asid
                            	   364: 	if HAS_MMU
                            	   365: 		move.l #$01F00000,d0			; set virtual address for iop bitmap
                            	   366: 		movec d0,iops
                            	   367: 		move.l #$01E00000,d0			; set virtual address for io block
                            	   368: 		movec d0,ios
                            	   369: 	else
02:0000000A 203CFD100000    	   370: 		move.l #$FD100000,d0			; set virtual address for iop bitmap
02:00000010 4E7B0016        	   371: 		movec d0,iops
02:00000014 203CFD000000    	   372: 		move.l #$FD000000,d0			; set virtual address for io block
02:0000001A 4E7B0015        	   373: 		movec d0,ios
                            	   374: 	endif
                            	   375: 	; Prepare local variable storage
02:0000001E 303C03FF        	   376: 	move.w #1023,d0						; 1024 longs to clear
02:00000022 41F900040000    	   377: 	lea	$40000,a0							; non shared local memory address
                            	   378: .0111:
02:00000028 4298            	   379: 	clr.l	(a0)+								; clear the memory area
02:0000002A 51C8FFFC        	   380: 	dbra d0,.0111
02:0000002E 23FC001FFFFF0004	   381: 	move.l #$1fffff,fgColor		; set foreground / background color
02:00000036 0084
02:00000038 23FC0000003F0004	   382: 	move.l #$00003f,bkColor
02:00000040 0088
02:00000042 4E7A0FE0        	   383: 	movec.l	coreno,d0					; get core number (2 to 9)
02:00000046 5500            	   384: 	subi.b #2,d0							; adjust (0 to 7)
02:00000048 C0FC4000        	   385: 	mulu #16384,d0						; compute screen location
02:0000004C 068001E00000    	   386: 	addi.l #$01E00000,d0
02:00000052 23C000040004    	   387: 	move.l d0,TextScr
02:00000058 13FC00400004008D	   388: 	move.b #64,TextCols				; set rows and columns
02:00000060 13FC00200004008C	   389: 	move.b #32,TextRows
02:00000068 4E7A0FE0        	   390: 	movec.l	coreno,d0					; get core number
02:0000006C 0C000002        	   391: 	cmpi.b #2,d0
02:00000070 6670            	   392: 	bne	start_other
02:00000072 13C000100000    	   393: 	move.b d0,IOFocus					; Set the IO focus in global memory
02:00000078 610000E2        	   394: 	bsr InitMMU								; Can't access anything till this is done
02:0000007C 61000118        	   395: 	bsr	InitIOBitmap					; not going to get far without this
02:00000080 610001EE        	   396: 	bsr	InitSemaphores
02:00000084 61000156        	   397: 	bsr	InitRand
02:00000088 61000278        	   398: 	bsr	Delay3s						; give devices time to reset
02:0000008C 61004E0A        	   399: 	bsr	clear_screen
                            	   400: 
02:00000090 61005364        	   401: 	bsr	_KeybdInit
                            	   402: ;	bsr	InitIRQ
02:00000094 610065B0        	   403: 	bsr	SerialInit
02:00000098 6100677C        	   404: 	bsr init_i2c
02:0000009C 610067D6        	   405: 	bsr rtc_read
                            	   406: 
                            	   407: 	; Write startup message to screen
                            	   408: 
02:000000A0 43FA6C32        	   409: 	lea	msg_start,a1
02:000000A4 61005106        	   410: 	bsr	DisplayString
                            	   411: ;	bsr	FemtikiInit
02:000000A8 4E7A0FE0        	   412: 	movec	coreno,d0
02:000000AC 4840            	   413: 	swap d0
02:000000AE 7201            	   414: 	moveq	#1,d1
02:000000B0 6100021E        	   415: 	bsr	UnlockSemaphore	; allow another cpu access
02:000000B4 7200            	   416: 	moveq	#0,d1
02:000000B6 61000218        	   417: 	bsr	UnlockSemaphore	; allow other cpus to proceed
02:000000BA 33FCA4A4FD0FFF00	   418: 	move.w #$A4A4,leds			; diagnostics
02:000000C2 61005292        	   419: 	bsr	init_plic				; initialize platform level interrupt controller
02:000000C6 60005B90        	   420: 	bra	StartMon
02:000000CA 61000276        	   421: 	bsr	cpu_test
                            	   422: ;	lea	brdisp_trap,a0	; set brdisp trap vector
                            	   423: ;	move.l	a0,64*4
                            	   424: 
                            	   425: loop2:
02:000000CE 70FF            	   426: 	move.l	#-1,d0
                            	   427: loop1:
02:000000D0 2200            	   428: 	move.l	d0,d1
02:000000D2 E089            	   429: 	lsr.l		#8,d1
02:000000D4 E089            	   430: 	lsr.l		#8,d1
02:000000D6 13C1FD0FFF00    	   431: 	move.b	d1,leds
02:000000DC 51C8FFF2        	   432: 	dbra		d0,loop1
02:000000E0 60EC            	   433: 	bra			loop2
                            	   434: 
                            	   435: start_other:
02:000000E2 61000242        	   436: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
02:000000E6 6100023E        	   437: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
02:000000EA 61004DAC        	   438: 	bsr			clear_screen
02:000000EE 4E7A1FE0        	   439: 	movec		coreno,d1
02:000000F2 61006236        	   440: 	bsr			DisplayByte
02:000000F6 43FA6C03        	   441: 	lea			msg_core_start,a1
02:000000FA 610050B0        	   442: 	bsr			DisplayString
                            	   443: ;	bsr			FemtikiInitIRQ
                            	   444: do_nothing:	
02:000000FE 60005B58        	   445: 	bra			StartMon
02:00000102 60FA            	   446: 	bra			do_nothing
                            	   447: 
                            	   448: ;------------------------------------------------------------------------------
                            	   449: ; Initialize the MMU to allow thread #0 access to IO
                            	   450: ;------------------------------------------------------------------------------
                            	   451: 	align 2
                            	   452: mmu_adrtbl:	; virtual address[24:16], physical address[31:16] bytes reversed!
02:00000104 00000010        	   453: 	dc.l	$0010,$10000300	; global scratch pad
02:00000108 10000300
02:0000010C 000001E0        	   454: 	dc.l	$01E0,$00FD0300	
02:00000110 00FD0300
02:00000114 000001E1        	   455: 	dc.l	$01E1,$01FD0300
02:00000118 01FD0300
02:0000011C 000001E2        	   456: 	dc.l	$01E2,$02FD0300
02:00000120 02FD0300
02:00000124 000001E3        	   457: 	dc.l  $01E3,$03FD0300
02:00000128 03FD0300
02:0000012C 000001E5        	   458: 	dc.l	$01E5,$05FD0300
02:00000130 05FD0300
02:00000134 000001E6        	   459: 	dc.l	$01E6,$06FD0300
02:00000138 06FD0300
02:0000013C 000001E9        	   460: 	dc.l	$01E9,$09FD0300
02:00000140 09FD0300
02:00000144 000001EF        	   461: 	dc.l	$01EF,$0FFD0300
02:00000148 0FFD0300
02:0000014C 000001F0        	   462: 	dc.l	$01F0,$10FD0300
02:00000150 10FD0300
02:00000154 000001FF        	   463: 	dc.l  $01FF,$FFFF0300	; all ones output for IRQ ack needed
02:00000158 FFFF0300
                            	   464: 
                            	   465: 	even
                            	   466: InitMMU:
02:0000015C 41F9FDC00008    	   467: 	lea MMU+8,a0				; first 128kB is local RAM
02:00000162 243C00032000    	   468: 	move.l #$32000,d2		; map all pages to DRAM
02:00000168 203C000001FE    	   469: 	move.l #510,d0			; then override for IO later
                            	   470: .0002
02:0000016E 2202            	   471: 	move.l d2,d1
02:00000170 610064CC        	   472: 	bsr rbo
02:00000174 20C1            	   473: 	move.l d1,(a0)+
02:00000176 5242            	   474: 	addi.w #1,d2				; increment DRAM page number
02:00000178 51C8FFF4        	   475: 	dbra d0,.0002
02:0000017C 41F9FDC00000    	   476: 	lea MMU,a0					; now program IO access
02:00000182 43FAFF80        	   477: 	lea mmu_adrtbl,a1
02:00000186 700A            	   478: 	moveq #10,d0
                            	   479: .0001
02:00000188 2419            	   480: 	move.l (a1)+,d2
02:0000018A E58A            	   481: 	lsl.l #2,d2
02:0000018C 21992000        	   482: 	move.l (a1)+,(a0,d2.w)
02:00000190 51C8FFF6        	   483: 	dbra d0,.0001
02:00000194 4E75            	   484: 	rts	
                            	   485: 
                            	   486: ;------------------------------------------------------------------------------
                            	   487: ; The IO bitmap needs to be initialized to allow access to IO.
                            	   488: ;------------------------------------------------------------------------------
                            	   489: 
                            	   490: InitIOBitmap:
                            	   491: 	; mark all IO inaccessible
02:00000196 303C1FFF        	   492: 	move.w #8191,d0
02:0000019A 41F9FD000000    	   493: 	lea	IO_BITMAP,a0
                            	   494: .0001
02:000001A0 4298            	   495: 	clr.l (a0)+
02:000001A2 51C8FFFC        	   496: 	dbra d0,.0001
                            	   497: 	; Give the system asid=0 complete access to the IO area
02:000001A6 303C007F        	   498: 	move.w #127,d0
02:000001AA 72FF            	   499: 	moveq	#-1,d1
02:000001AC 41F9FD000000    	   500: 	lea	IO_BITMAP,a0
                            	   501: .0002
02:000001B2 20C1            	   502: 	move.l d1,(a0)+
02:000001B4 51C8FFFC        	   503: 	dbra d0,.0002
                            	   504: 	; Give all cores access to the screen
02:000001B8 41F9FD000080    	   505: 	lea IO_BITMAP+128,a0
02:000001BE 72FF            	   506: 	moveq #-1,d1
02:000001C0 303C003E        	   507: 	move.w #62,d0		; 63 more bitmaps to fill
                            	   508: .0004
02:000001C4 4840            	   509: 	swap d0
02:000001C6 303C001F        	   510: 	move.w #31,d0		; 32 long words for the screen area per bitmap
                            	   511: .0003
02:000001CA 20C1            	   512: 	move.l d1,(a0)+
02:000001CC 51C8FFFC        	   513: 	dbra d0,.0003
02:000001D0 4840            	   514: 	swap d0
02:000001D2 41E80060        	   515: 	lea 96(a0),a0
02:000001D6 51C8FFEC        	   516: 	dbra d0,.0004
02:000001DA 4E75            	   517: 	rts	
                            	   518: 	
                            	   519: ;------------------------------------------------------------------------------
                            	   520: ; RandInit
                            	   521: ; 	Initialize random number generator.
                            	   522: ;
                            	   523: ; Modifies:
                            	   524: ;		none
                            	   525: ; Parameters:
                            	   526: ;		none
                            	   527: ;	Returns:
                            	   528: ;		none
                            	   529: ;------------------------------------------------------------------------------
                            	   530: 
                            	   531: InitRand:
                            	   532: RandInit:
02:000001DC 48E7C000        	   533: 	movem.l	d0/d1,-(a7)
02:000001E0 4E7A0FE0        	   534: 	movec		coreno,d0
02:000001E4 4840            	   535: 	swap		d0
02:000001E6 7204            	   536: 	moveq		#RAND_SEMA,d1
02:000001E8 610000AC        	   537: 	bsr			LockSemaphore
02:000001EC 4840            	   538: 	swap		d0
02:000001EE ED88            	   539: 	lsl.l		#6,d0									; allow 64 streams per core
02:000001F0 23C0FD0FFD04    	   540: 	move.l	d0,RAND_STRM					; select the stream
02:000001F6 23FC12345678FD0F	   541: 	move.l	#$12345678,RAND_MZ		; initialize to some value
02:000001FE FD08
02:00000200 23FC98765432FD0F	   542: 	move.l	#$98765432,RAND_MW
02:00000208 FD0C
02:0000020A 23FC2E5BF271FD0F	   543: 	move.l	#777777777,RAND_NUM		; generate first number
02:00000212 FD00
02:00000214 4E7A0FE0        	   544: 	movec		coreno,d0
02:00000218 4840            	   545: 	swap		d0
02:0000021A 7204            	   546: 	moveq		#RAND_SEMA,d1
02:0000021C 610000B2        	   547: 	bsr			UnlockSemaphore
02:00000220 4CDF0003        	   548: 	movem.l	(a7)+,d0/d1
02:00000224 4E75            	   549: 	rts
                            	   550: 
                            	   551: ;------------------------------------------------------------------------------
                            	   552: ;------------------------------------------------------------------------------
                            	   553: 
                            	   554: RandGetNum:
02:00000226 48E7A000        	   555: 	movem.l	d0/d2,-(a7)
02:0000022A 4E7A0FE0        	   556: 	movec		coreno,d0
02:0000022E 4840            	   557: 	swap		d0
02:00000230 7204            	   558: 	moveq		#RAND_SEMA,d1
02:00000232 6162            	   559: 	bsr			LockSemaphore
02:00000234 ED88            	   560: 	lsl.l		#6,d0
02:00000236 23C0FD0FFD04    	   561: 	move.l	d0,RAND_STRM					; select the stream
02:0000023C 2439FD0FFD00    	   562: 	move.l	RAND_NUM,d2
02:00000242 42B9FD0FFD00    	   563: 	clr.l		RAND_NUM							; generate next number
02:00000248 4E7A0FE0        	   564: 	movec		coreno,d0
02:0000024C 4840            	   565: 	swap		d0
02:0000024E 7204            	   566: 	moveq		#RAND_SEMA,d1
02:00000250 617E            	   567: 	bsr			UnlockSemaphore
02:00000252 2202            	   568: 	move.l	d2,d1
02:00000254 4CDF0005        	   569: 	movem.l	(a7)+,d0/d2
02:00000258 4E75            	   570: 	rts
                            	   571: 
                            	   572: ;------------------------------------------------------------------------------
                            	   573: ; RandWait
                            	   574: ;    Wait some random number of clock cycles before returning.
                            	   575: ;------------------------------------------------------------------------------
                            	   576: 
                            	   577: RandWait:
02:0000025A 48E7C000        	   578: 	movem.l	d0/d1,-(a7)
02:0000025E 61C6            	   579: 	bsr			RandGetNum
02:00000260 0241000F        	   580: 	andi.w	#15,d1
                            	   581: .0001:
02:00000264 4E71            	   582: 	nop
02:00000266 51C9FFFC        	   583: 	dbra		d1,.0001
02:0000026A 4CDF0003        	   584: 	movem.l	(a7)+,d0/d1
02:0000026E 4E75            	   585: 	rts
                            	   586: 
                            	   587: ;------------------------------------------------------------------------------
                            	   588: ; Initialize semaphores
                            	   589: ; - all semaphores are set to unlocked except the first one, which is locked
                            	   590: ; for core #2.
                            	   591: ;
                            	   592: ; Parameters:
                            	   593: ;		<none>
                            	   594: ; Modifies:
                            	   595: ;		<none>
                            	   596: ; Returns:
                            	   597: ;		<none>
                            	   598: ;------------------------------------------------------------------------------
                            	   599: 
                            	   600: InitSemaphores:
02:00000270 48E74080        	   601: 	movem.l	d1/a0,-(a7)
02:00000274 41F9FD050000    	   602: 	lea			semamem,a0
02:0000027A 217C000200002000	   603: 	move.l	#$20000,$2000(a0)	; lock the first semaphore for core #2, thread #0
02:00000282 323C00FE        	   604: 	move.w	#254,d1
                            	   605: .0001:
02:00000286 5888            	   606: 	lea			4(a0),a0
02:00000288 42A82000        	   607: 	clr.l		$2000(a0)					; write zeros to unlock
02:0000028C 51C9FFF8        	   608: 	dbra		d1,.0001
02:00000290 4CDF0102        	   609: 	movem.l	(a7)+,d1/a0
02:00000294 4E75            	   610: 	rts
                            	   611: 
                            	   612: ; -----------------------------------------------------------------------------
                            	   613: ; Parameters:
                            	   614: ;		d1 semaphore number
                            	   615: ;
                            	   616: ; Side Effects:
                            	   617: ;		increments semaphore, saturates at 255
                            	   618: ;
                            	   619: ; Returns:	
                            	   620: ; 	z flag set if semaphore was zero
                            	   621: ; -----------------------------------------------------------------------------
                            	   622: 
                            	   623: ;IncrementSemaphore:
                            	   624: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   625: ;	lea			semamem,a0			; point to semaphore memory
                            	   626: ;	ext.w		d1							; make d1 word value
                            	   627: ;	asl.w		#4,d1						; align to memory
                            	   628: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   629: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   630: ;	rts
                            	   631: 	
                            	   632: ; -----------------------------------------------------------------------------
                            	   633: ; Parameters:
                            	   634: ;		d1 semaphore number
                            	   635: ;
                            	   636: ; Side Effects:
                            	   637: ;		decrements semaphore, saturates at zero
                            	   638: ;
                            	   639: ; Returns:	
                            	   640: ; 	z flag set if semaphore was zero
                            	   641: ; -----------------------------------------------------------------------------
                            	   642: 
                            	   643: ;DecrementSemaphore:
                            	   644: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   645: ;	lea			semamem,a0			; point to semaphore memory
                            	   646: ;	andi.w	#255,d1					; make d1 word value
                            	   647: ;	asl.w		#4,d1						; align to memory
                            	   648: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   649: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   650: ;	rts
                            	   651: 
                            	   652: ; -----------------------------------------------------------------------------
                            	   653: ; Lock a semaphore
                            	   654: ;
                            	   655: ; Parameters:
                            	   656: ;		d0 = key
                            	   657: ;		d1 = semaphore number
                            	   658: ; -----------------------------------------------------------------------------
                            	   659: 
                            	   660: LockSemaphore:
02:00000296 48E74080        	   661: 	movem.l	d1/a0,-(a7)			; save registers
02:0000029A 41F9FD050000    	   662: 	lea			semamem,a0			; point to semaphore memory lock area
02:000002A0 024100FF        	   663: 	andi.w	#255,d1					; make d1 word value
02:000002A4 E549            	   664: 	lsl.w		#2,d1						; align to memory
                            	   665: .0001
02:000002A6 21801000        	   666: 	move.l	d0,(a0,d1.w)		; try and write the semaphore
02:000002AA B0B01000        	   667: 	cmp.l		(a0,d1.w),d0		; did it lock?
02:000002AE 66F6            	   668: 	bne.s		.0001						; no, try again
02:000002B0 4CDF0102        	   669: 	movem.l	(a7)+,a0/d1			; restore regs
02:000002B4 4E75            	   670: 	rts
                            	   671: 	
                            	   672: ; -----------------------------------------------------------------------------
                            	   673: ; Unlocks a semaphore even if not the owner.
                            	   674: ;
                            	   675: ; Parameters:
                            	   676: ;		d1 semaphore number
                            	   677: ; -----------------------------------------------------------------------------
                            	   678: 
                            	   679: ForceUnlockSemaphore:
02:000002B6 48E74080        	   680: 	movem.l	d1/a0,-(a7)				; save registers
02:000002BA 41F9FD053000    	   681: 	lea			semamem+$3000,a0	; point to semaphore memory read/write area
02:000002C0 024100FF        	   682: 	andi.w	#255,d1						; make d1 word value
02:000002C4 E549            	   683: 	lsl.w		#2,d1							; align to memory
02:000002C6 42B01000        	   684: 	clr.l		(a0,d1.w)					; write zero to unlock
02:000002CA 4CDF0102        	   685: 	movem.l	(a7)+,a0/d1				; restore regs
02:000002CE 4E75            	   686: 	rts
                            	   687: 
                            	   688: ; -----------------------------------------------------------------------------
                            	   689: ; Unlocks a semaphore. Must be the owner to have effect.
                            	   690: ; Three cases:
                            	   691: ;	1) the owner, the semaphore will be reset to zero
                            	   692: ;	2) not the owner, the write will be ignored
                            	   693: ; 3) already unlocked, the write will be ignored
                            	   694: ;
                            	   695: ; Parameters:
                            	   696: ;		d0 = key
                            	   697: ;		d1 = semaphore number
                            	   698: ; -----------------------------------------------------------------------------
                            	   699: 
                            	   700: UnlockSemaphore:
02:000002D0 48E74080        	   701: 	movem.l	d1/a0,-(a7)				; save registers
02:000002D4 41F9FD051000    	   702: 	lea			semamem+$1000,a0	; point to semaphore memory unlock area
02:000002DA 024100FF        	   703: 	andi.w	#255,d1						; make d1 word value
02:000002DE E549            	   704: 	lsl.w		#2,d1							; align to memory
02:000002E0 21801000        	   705: 	move.l	d0,(a0,d1.w)			; write matching value to unlock
02:000002E4 4CDF0102        	   706: 	movem.l	(a7)+,a0/d1				; restore regs
02:000002E8 4E75            	   707: 	rts
                            	   708: 
                            	   709: ; -----------------------------------------------------------------------------
                            	   710: ; Parameters:
                            	   711: ;		d1 = semaphore to lock / unlock
                            	   712: ; -----------------------------------------------------------------------------
                            	   713: 
                            	   714: T15LockSemaphore:	
02:000002EA 4E7A0FE0        	   715: 	movec coreno,d0
02:000002EE 80B900100224    	   716: 	or.l RunningTCB,d0
02:000002F4 60A0            	   717: 	bra LockSemaphore
                            	   718: 
                            	   719: T15UnlockSemaphore:
02:000002F6 4E7A0FE0        	   720: 	movec coreno,d0
02:000002FA 80B900100224    	   721: 	or.l RunningTCB,d0
02:00000300 60CE            	   722: 	bra UnlockSemaphore
                            	   723: 
                            	   724: ; -----------------------------------------------------------------------------
                            	   725: ; Delay for a few seconds to allow some I/O reset operations to take place.
                            	   726: ; -----------------------------------------------------------------------------
                            	   727: 
                            	   728: Delay3s:
02:00000302 203C002DC6C0    	   729: 	move.l	#3000000,d0		; this should take a few seconds to loop
02:00000308 41F9FD0FFF00    	   730: 	lea			leds,a0				; a0 = address of LED output register
02:0000030E 6002            	   731: 	bra			dly3s1				; branch to the loop
                            	   732: dly3s2:	
02:00000310 4840            	   733: 	swap		d0						; loop is larger than 16-bits
                            	   734: dly3s1:
02:00000312 2200            	   735: 	move.l	d0,d1					; the counter cycles fast, so use upper bits for display
02:00000314 E199            	   736: 	rol.l		#8,d1					; could use swap here, but lets test rol
02:00000316 E199            	   737: 	rol.l		#8,d1
02:00000318 1081            	   738: 	move.b	d1,(a0)				; set the LEDs
02:0000031A 51C8FFF6        	   739: 	dbra		d0,dly3s1			; decrement and branch back
02:0000031E 4840            	   740: 	swap		d0
02:00000320 51C8FFEE        	   741: 	dbra		d0,dly3s2
02:00000324 4E75            	   742: 	rts
                            	   743: 
                            	   744: Delay3s2:
02:00000326 4E7A0FE0        	   745: 	movec		coreno,d0			; vary delay by core to stagger startup
02:0000032A E188            	   746: 	lsl.l		#8,d0
02:0000032C 0680002DC6C0    	   747: 	addi.l	#3000000,d0		; this should take a few seconds to loop
02:00000332 6002            	   748: 	bra			.0001					; branch to the loop
                            	   749: .0002	
02:00000334 4840            	   750: 	swap		d0						; loop is larger than 16-bits
                            	   751: .0001
02:00000336 51C8FFFE        	   752: 	dbra		d0,.0001			; decrement and branch back
02:0000033A 4840            	   753: 	swap		d0
02:0000033C 51C8FFF6        	   754: 	dbra		d0,.0002
02:00000340 4E75            	   755: 	rts
                            	   756: 
                            	   757: 	include "cputest.asm"

Source: "cputest.asm"
                            	     1: ** @name cputest.s Tests 68000 cpu
                            	     2: *
                            	     3: * Based on https://github.com/MicroCoreLabs/Projects/blob/master/MCL68/MC68000_Test_Code/MC68000_test_all_opcodes.X68
                            	     4: *
                            	     5: * Converted into a CD-i system ROM image by CD-i Fan:
                            	     6: * - comment lines must start in first column
                            	     7: * - replaced org instructions by suitable rept
                            	     8: * - copy vectors to low memory at startup
                            	     9: * - replaced jsr/jmp by bsr/bra for position independence
                            	    10: * - replaced move.l by moveq whenever possible
                            	    11: * - converted branches to short form whenever possible (e.g. beq => beq.s)
                            	    12: * - added immediate suffix to opcodes where required (e.g. and => andi)
                            	    13: * The last three modifications are required to make the test work;
                            	    14: * apparently the original assembler was somewhat smarter then
                            	    15: * the Microware OS-9 assembler and did this automatically.
                            	    16: *
                            	    17: * In some cases the opcodes of the test are used as test data!
                            	    18: *
                            	    19: * Original file header follows.
                            	    20: *
                            	    21: *  File Name   :  MCL68 Opcode Tests
                            	    22: *  Used on     :
                            	    23: *  Author      :  Ted Fried, MicroCore Labs
                            	    24: *  Creation    :  7/14/2020
                            	    25: *
                            	    26: *   Description:
                            	    27: *   ============
                            	    28: *
                            	    29: *  Program to test all of the Motorola 68000's opcodes.
                            	    30: *
                            	    31: *  If failures are detected, the code will immediately loop on itself.
                            	    32: *  All addressing modes, data sizes, and opcode combinations are tested.
                            	    33: *
                            	    34: *  This code was developed using the Easy68K simulator where all tests passed!
                            	    35: *
                            	    36: *------------------------------------------------------------------------
                            	    37: *
                            	    38: * Modification History:
                            	    39: * =====================
                            	    40: *
                            	    41: * Revision 1 7/14/2020
                            	    42: * Initial revision
                            	    43: *
                            	    44: *
                            	    45: *------------------------------------------------------------------------
                            	    46: *
                            	    47: * Copyright (c) 2020 Ted Fried
                            	    48: *
                            	    49: * Permission is hereby granted, free of charge, to any person obtaining a copy
                            	    50: * of this software and associated documentation files (the "Software"), to deal
                            	    51: * in the Software without restriction, including without limitation the rights
                            	    52: * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                            	    53: * copies of the Software, and to permit persons to whom the Software is
                            	    54: * furnished to do so, subject to the following conditions:
                            	    55: *
                            	    56: * The above copyright notice and this permission notice shall be included in all
                            	    57: * copies or substantial portions of the Software.
                            	    58: *
                            	    59: * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            	    60: * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            	    61: * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            	    62: * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            	    63: * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                            	    64: * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                            	    65: * SOFTWARE.
                            	    66: 
                            	    67: * Modified for rf68000 project (c) 2022 Robert Finch
                            	    68: 
                            	    69: *	data
                            	    70: *	dc.l		$0001FFFC						; top of local ram area
                            	    71: *	dc.l		start
                            	    72: 
                            	    73: *    org $1000												; code starts at $400 in local ram
                            	    74: *start:
                            	    75: *	move.l	$FFFFFFE0,d0		; get core number
                            	    76: *	cmpi.b	#2,d0
                            	    77: *	bne			do_nothing
                            	    78: 
                            	    79: *	lea			EXCEPTION_6,a0	* check exception vector
                            	    80: *	move.l	a0,6*4
                            	    81: *	lea			EXCEPTION_7,a0	* TRAPV exception vector
                            	    82: *	move.l	a0,7*4
                            	    83: 
                            	    84: cpu_test:
02:00000342 610000FA        	    85: 	bsr	op_ORI_TO_CCR
02:00000346 61000118        	    86: 	bsr	op_ORI_TO_SR
02:0000034A 61000136        	    87: 	bsr	op_EORI_TO_CCR
02:0000034E 61000158        	    88: 	bsr	op_EORI_TO_SR
02:00000352 6100017A        	    89: 	bsr	op_ANDI_TO_CCR
02:00000356 6100019C        	    90: 	bsr	op_ANDI_TO_SR
02:0000035A 610001BE        	    91: 	bsr	op_BTST
02:0000035E 61000564        	    92: 	bsr	op_BCHG
02:00000362 610008C8        	    93: 	bsr	op_BCLR
02:00000366 61000C12        	    94: 	bsr	op_BSET
02:0000036A 61000F56        	    95: 	bsr op_MOVEP
02:0000036E 61000FDE        	    96: 	bsr op_BOOL_I
02:00000372 610011C2        	    97: 	bsr op_CMP_I
02:00000376 610013A6        	    98: 	bsr op_ADD_I
02:0000037A 61001528        	    99: 	bsr op_SUB_I
02:0000037E 610016AA        	   100: 	bsr op_MOVE
02:00000382 610018B2        	   101: 	bsr op_MOVE_xxx_FLAGS
02:00000386 61001AA2        	   102: 	bsr op_EXT
02:0000038A 61001ACA        	   103: 	bsr op_SWAP
02:0000038E 61001ADC        	   104: 	bsr op_LEAPEA
02:00000392 61001B84        	   105: 	bsr op_TAS
02:00000396 61001BA6        	   106: 	bsr op_TST
02:0000039A 61001BE0        	   107: 	bsr op_LINKS
02:0000039E 61001BFA        	   108: 	bsr op_MOVE_USP
02:000003A2 61001C06        	   109: 	bsr op_CHK
02:000003A6 61001C3C        	   110: 	bsr op_NEGS
02:000003AA 61001FC6        	   111: 	bsr op_MOVEM
                            	   112: *	bsr op_ABCD
                            	   113: *	bsr op_SBCD
                            	   114: *	bsr op_NBCD
02:000003AE 61002562        	   115: 	bsr op_TRAPV
02:000003B2 6100257A        	   116: 	bsr op_RTR
02:000003B6 61001148        	   117: 	bsr op_BSR
02:000003BA 61002594        	   118: 	bsr op_BCC
02:000003BE 61002610        	   119: 	bsr op_DBCC
02:000003C2 61002632        	   120: 	bsr op_SCC
02:000003C6 61002656        	   121: 	bsr op_ADDQ
02:000003CA 6100270C        	   122: 	bsr op_SUBQ
02:000003CE 610027C2        	   123: 	bsr op_MOVEQ
02:000003D2 610027DA        	   124: 	bsr op_DIVU
                            	   125: *	bsr op_DIVS
02:000003D6 6100287A        	   126: 	bsr op_OR
02:000003DA 61002960        	   127: 	bsr op_AND
02:000003DE 61002A46        	   128: 	bsr op_EOR
02:000003E2 61002AB8        	   129: 	bsr op_CMP
02:000003E6 61002B2A        	   130: 	bsr op_CMPA
02:000003EA 61002B8C        	   131: 	bsr op_CMPM
02:000003EE 61002C2E        	   132: 	bsr op_ADD
02:000003F2 61002D14        	   133: 	bsr op_SUB
02:000003F6 61002DFA        	   134: 	bsr op_ADDA
02:000003FA 61002E42        	   135: 	bsr op_SUBA
02:000003FE 61002E8A        	   136: 	bsr op_ADDX	
02:00000402 61002F96        	   137: 	bsr op_SUBX
02:00000406 610030A2        	   138: 	bsr op_MULU
02:0000040A 610030EA        	   139: 	bsr op_MULS
02:0000040E 61003132        	   140: 	bsr op_EXG
02:00000412 6100319C        	   141: 	bsr op_ROx
02:00000416 610033CE        	   142: 	bsr op_ROXx
02:0000041A 61003600        	   143: 	bsr op_SHIFTS
02:0000041E 6100383E        	   144: 	bsr op_SHIFTS2
                            	   145: 
02:00000422 4E75            	   146: 	rts
                            	   147: 	bra ALL_DONE
                            	   148: 
                            	   149: * Loop here when all tests pass
                            	   150: *
                            	   151: 
02:00000424 60FE            	   152: ALL_DONE: bra.s ALL_DONE
                            	   153: 
02:00000426 263C33333333    	   154: BSR_FAR1:       move.l #$33333333,d3
02:0000042C 4E75            	   155:                 rts
                            	   156: 
                            	   157: ;	moveq		#-1,d0
                            	   158: ;	move.l	d0,$FD0FFF00
                            	   159: ;do_nothing:
                            	   160: ;	bra			*		
                            	   161: 
                            	   162: 
                            	   163: * Exception Vector = 6   CHK Instruction
                            	   164: *
                            	   165: *	align	4
                            	   166: EXCEPTION_6:
02:0000042E 2C3CEEEE0006    	   167: 	move.l #$EEEE0006,d6      * Set d6 to the exception vector
02:00000434 4E73            	   168: 	rte
                            	   169: 
                            	   170: * Exception Vector = 7   TRAPV Instruction
                            	   171: *
                            	   172: *	align	4
                            	   173: EXCEPTION_7:
02:00000436 203C12345678    	   174: 	move.l #$12345678,d0      * Set d6 to the exception vector
02:0000043C 4E73            	   175: 	rte
                            	   176: 
                            	   177: ;-----------------------------------------------------------
                            	   178: ;-----------------------------------------------------------
                            	   179: ; OPCODE : ORI_TO_CCR
                            	   180: ;-----------------------------------------------------------
                            	   181: ;-----------------------------------------------------------
                            	   182: op_ORI_TO_CCR:
                            	   183: 
02:0000043E 003C00FF        	   184:     ori.b #$FF,CCR
02:00000442 6AFE            	   185:     bpl.s *                   ; branch if Z clear
02:00000444 66FE            	   186:     bne.s *                   ; branch if N clear
02:00000446 68FE            	   187:     bvc.s *                   ; branch if V clear
02:00000448 64FE            	   188:     bcc.s *                   ; branch if C clear
                            	   189: 
02:0000044A 44FC0000        	   190:     move #$00,CCR
02:0000044E 003C0000        	   191:     ori.b #$00,CCR
02:00000452 67FE            	   192:     beq.s *                   ; branch if Z set
02:00000454 6BFE            	   193:     bmi.s *                   ; branch if N set
02:00000456 69FE            	   194:     bvs.s *                   ; branch if V set
02:00000458 65FE            	   195:     bcs.s *                   ; branch if C set
                            	   196: 
02:0000045A 46FC2700        	   197:     move.w #$2700,SR          ; Put flags back to initial value
                            	   198: 
02:0000045E 4E75            	   199:     rts
                            	   200: 
                            	   201: ;-----------------------------------------------------------
                            	   202: ;-----------------------------------------------------------
                            	   203: ; OPCODE : ORI_TO_SR
                            	   204: ;-----------------------------------------------------------
                            	   205: ;-----------------------------------------------------------
                            	   206: 
                            	   207: op_ORI_TO_SR:
                            	   208: 
02:00000460 007C2FFF        	   209:     ori.w #$2FFF,SR
02:00000464 6AFE            	   210:     bpl.s *                   * branch if Z clear
02:00000466 66FE            	   211:     bne.s *                   * branch if N clear
02:00000468 68FE            	   212:     bvc.s *                   * branch if V clear
02:0000046A 64FE            	   213:     bcc.s *                   * branch if C clear
                            	   214: 
02:0000046C 46FC2000        	   215:     move.w #$2000,SR
02:00000470 007C0000        	   216:     ori.w #$0000,SR
02:00000474 67FE            	   217:     beq.s *                   * branch if Z set
02:00000476 6BFE            	   218:     bmi.s *                   * branch if N set
02:00000478 69FE            	   219:     bvs.s *                   * branch if V set
02:0000047A 65FE            	   220:     bcs.s *                   * branch if C set
                            	   221: 
02:0000047C 46FC2700        	   222:     move.w #$2700,sr         * Put flags back to initial value
                            	   223: 
02:00000480 4E75            	   224:     rts
                            	   225: ; 
                            	   226: ;-----------------------------------------------------------
                            	   227: ;-----------------------------------------------------------
                            	   228: ; OPCODE : EORI_TO_CCR
                            	   229: ;-----------------------------------------------------------
                            	   230: ;-----------------------------------------------------------
                            	   231: op_EORI_TO_CCR:
                            	   232: 
02:00000482 44FC0000        	   233:     move #$00,CCR
02:00000486 0A3C00FF        	   234:     eori.b #$FF,CCR
02:0000048A 6AFE            	   235:     bpl.s *                   ; branch if Z clear
02:0000048C 66FE            	   236:     bne.s *                   ; branch if N clear
02:0000048E 68FE            	   237:     bvc.s *                   ; branch if V clear
02:00000490 64FE            	   238:     bcc.s *                   ; branch if C clear
                            	   239: 
02:00000492 44FC0000        	   240:     move #$00,CCR
02:00000496 0A3C0000        	   241:     eori.b #$00,CCR
02:0000049A 67FE            	   242:     beq.s *                   ; branch if Z set
02:0000049C 6BFE            	   243:     bmi.s *                   ; branch if N set
02:0000049E 69FE            	   244:     bvs.s *                   ; branch if V set
02:000004A0 65FE            	   245:     bcs.s *                   ; branch if C set
                            	   246: 
02:000004A2 46FC2700        	   247:     move.w #$2700,sr           ; Put flags back to initial value
                            	   248: 
02:000004A6 4E75            	   249:     rts
                            	   250: 
                            	   251: 
                            	   252: 
                            	   253: *-----------------------------------------------------------
                            	   254: *-----------------------------------------------------------
                            	   255: * OPCODE : EORI_TO_SR
                            	   256: *-----------------------------------------------------------
                            	   257: *-----------------------------------------------------------
                            	   258: op_EORI_TO_SR:
                            	   259: 
02:000004A8 46FC2000        	   260:     move.w #$2000,SR
02:000004AC 0A7C0FFF        	   261:     eori.w #$0FFF,SR
02:000004B0 6AFE            	   262:     bpl.s *                   * branch if Z clear
02:000004B2 66FE            	   263:     bne.s *                   * branch if N clear
02:000004B4 68FE            	   264:     bvc.s *                   * branch if V clear
02:000004B6 64FE            	   265:     bcc.s *                   * branch if C clear
                            	   266: 
02:000004B8 46FC2000        	   267:     move.w #$2000,SR
02:000004BC 0A7C0000        	   268:     eori.w #$0000,SR
02:000004C0 67FE            	   269:     beq.s *                   * branch if Z set
02:000004C2 6BFE            	   270:     bmi.s *                   * branch if N set
02:000004C4 69FE            	   271:     bvs.s *                   * branch if V set
02:000004C6 65FE            	   272:     bcs.s *                   * branch if C set
                            	   273: 
02:000004C8 46FC2700        	   274:     move.w #$2700,sr          * Put flags back to initial value
                            	   275: 
02:000004CC 4E75            	   276:     rts
                            	   277: 
                            	   278: 
                            	   279: 
                            	   280: *-----------------------------------------------------------
                            	   281: *-----------------------------------------------------------
                            	   282: * OPCODE : ANDI_TO_CCR
                            	   283: *-----------------------------------------------------------
                            	   284: *-----------------------------------------------------------
                            	   285: op_ANDI_TO_CCR:
                            	   286: 
02:000004CE 44FC00FF        	   287:     move #$FF,CCR
02:000004D2 023C00FF        	   288:     andi.b #$FF,CCR
02:000004D6 6AFE            	   289:     bpl.s *                   * branch if Z clear
02:000004D8 66FE            	   290:     bne.s *                   * branch if N clear
02:000004DA 68FE            	   291:     bvc.s *                   * branch if V clear
02:000004DC 64FE            	   292:     bcc.s *                   * branch if C clear
                            	   293: 
02:000004DE 44FC00FF        	   294:     move #$FF,CCR
02:000004E2 023C0000        	   295:     andi.b #$00,CCR
02:000004E6 67FE            	   296:     beq.s *                   * branch if Z set
02:000004E8 6BFE            	   297:     bmi.s *                   * branch if N set
02:000004EA 69FE            	   298:     bvs.s *                   * branch if V set
02:000004EC 65FE            	   299:     bcs.s *                   * branch if C set
                            	   300: 
02:000004EE 46FC2700        	   301:     move #$2700,SR           * Put flags back to initial value
                            	   302: 
02:000004F2 4E75            	   303:     rts
                            	   304: 
                            	   305: 
                            	   306: 
                            	   307: *-----------------------------------------------------------
                            	   308: *-----------------------------------------------------------
                            	   309: * OPCODE : ANDI_TO_SR
                            	   310: *-----------------------------------------------------------
                            	   311: *-----------------------------------------------------------
                            	   312: op_ANDI_TO_SR:
02:000004F4 46FC20FF        	   313:     move.w #$20FF,SR
02:000004F8 027CFFFF        	   314:     andi.w #$FFFF,SR
02:000004FC 6AFE            	   315:     bpl.s *                   * branch if Z clear
02:000004FE 66FE            	   316:     bne.s *                   * branch if N clear
02:00000500 68FE            	   317:     bvc.s *                   * branch if V clear
02:00000502 64FE            	   318:     bcc.s *                   * branch if C clear
                            	   319: 
02:00000504 46FC20FF        	   320:     move.w #$20FF,SR
02:00000508 027CFF00        	   321:     andi.w #$FF00,SR
02:0000050C 67FE            	   322:     beq.s *                   * branch if Z set
02:0000050E 6BFE            	   323:     bmi.s *                   * branch if N set
02:00000510 69FE            	   324:     bvs.s *                   * branch if V set
02:00000512 65FE            	   325:     bcs.s *                   * branch if C set
                            	   326: 
02:00000514 46FC2700        	   327:     move.w #$2700,sr           * Put flags back to initial value
                            	   328: 
02:00000518 4E75            	   329:     rts
                            	   330: 
                            	   331: 
                            	   332: *-----------------------------------------------------------
                            	   333: *-----------------------------------------------------------
                            	   334: * OPCODE : BTST
                            	   335: *-----------------------------------------------------------
                            	   336: *-----------------------------------------------------------
                            	   337: op_BTST:
                            	   338: 
                            	   339: *  Bit Number.s Static
                            	   340: 
                            	   341: *             EA = Dn  - LONG only
02:0000051A 203C80000001    	   342:             move.l #$80000001,d0      * populate test data
02:00000520 08000000        	   343:             btst.l #0,d0
02:00000524 67FE            	   344:             beq.s *               * branch if Z set
02:00000526 08000001        	   345:             btst.l #1,d0              *
02:0000052A 66FE            	   346:             bne.s *               * branch if Z clear
02:0000052C 0800001F        	   347:             btst.l #31,d0             *
02:00000530 67FE            	   348:             beq.s *               * branch if Z set
                            	   349: 
                            	   350: 
                            	   351: *             EA = (An)  - BYTE only
02:00000532 307C0100        	   352:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000536 10BC0081        	   353:             move.b #$81,(a0)          * populate test data
02:0000053A 1210            	   354:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:0000053C 08100000        	   355:             btst.b #0,(a0)
02:00000540 67FE            	   356:             beq.s *               * branch if Z set
02:00000542 08100001        	   357:             btst.b #1,(a0)            *
02:00000546 66FE            	   358:             bne.s *               * branch if Z clear
02:00000548 08100007        	   359:             btst.b #7,(a0)            *
02:0000054C 67FE            	   360:             beq.s *               * branch if Z set
                            	   361: 
                            	   362: 
                            	   363: *             EA = (An)+  - BYTE only
02:0000054E 307C0100        	   364:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000552 10FC0001        	   365:             move.b #$01,(a0)+         * populate test data
02:00000556 10FC00FC        	   366:             move.b #$FC,(a0)+         * populate test data
02:0000055A 10FC0080        	   367:             move.b #$80,(a0)+         * populate test data
02:0000055E 307C0100        	   368:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000562 08180000        	   369:             btst.b #0,(a0)+
02:00000566 67FE            	   370:             beq.s *               * branch if Z set
02:00000568 08180001        	   371:             btst.b #1,(a0)+           *
02:0000056C 66FE            	   372:             bne.s *               * branch if Z clear
02:0000056E 08180007        	   373:             btst.b #7,(a0)+           *
02:00000572 67FE            	   374:             beq.s *               * branch if Z set
                            	   375: 
                            	   376: 
                            	   377: *             EA = -(An)  - BYTE only
02:00000574 307C0100        	   378:             move.l #$00000100,a0      * point to memory to address
02:00000578 10FC0080        	   379:             move.b #$80,(a0)+         * populate test data
02:0000057C 10FC00FC        	   380:             move.b #$FC,(a0)+         * populate test data
02:00000580 10FC0001        	   381:             move.b #$01,(a0)+         * populate test data
02:00000584 307C0103        	   382:             move.l #$00000103,a0      * point to memory to address
02:00000588 08200000        	   383:             btst.b #0,-(a0)
02:0000058C 67FE            	   384:             beq.s *               * branch if Z set
02:0000058E 08200001        	   385:             btst.b #1,-(a0)           *
02:00000592 66FE            	   386:             bne.s *               * branch if Z clear
02:00000594 08200007        	   387:             btst.b #7,-(a0)           *
02:00000598 67FE            	   388:             beq.s *               * branch if Z set
                            	   389: 
                            	   390: 
                            	   391: *             EA = n(An)  - BYTE only
02:0000059A 307C0100        	   392:             move.l #$00000100,a0      * point to memory to address
02:0000059E 10FC0001        	   393:             move.b #$01,(a0)+         * populate test data
02:000005A2 10FC00FC        	   394:             move.b #$FC,(a0)+         * populate test data
02:000005A6 10FC0080        	   395:             move.b #$80,(a0)+         * populate test data
02:000005AA 307C0100        	   396:             move.l #$00000100,a0      * point to memory to address
02:000005AE 08100000        	   397:             btst.b #0,0(a0)
02:000005B2 67FE            	   398:             beq.s *               * branch if Z set
02:000005B4 082800010001    	   399:             btst.b #1,1(a0)           *
02:000005BA 66FE            	   400:             bne.s *               * branch if Z clear
02:000005BC 082800070002    	   401:             btst.b #7,2(a0)           *
02:000005C2 67FE            	   402:             beq.s *               * branch if Z set
                            	   403: 
                            	   404: 
                            	   405: *             EA = n(An,R.W)  - BYTE only
02:000005C4 307C0100        	   406:             move.l #$00000100,a0      * point to memory to address
02:000005C8 93C9            	   407:             move.l #$00000000,a1      * point to memory to address
02:000005CA 347C0001        	   408:             move.l #$00000001,a2      * point to memory to address
02:000005CE 7000            	   409:             moveq  #$00000000,d0      * point to memory to address
02:000005D0 7201            	   410:             moveq  #$00000001,d1      * point to memory to address
02:000005D2 083000000000    	   411:             btst.b #0,0(a0,d0.w)
02:000005D8 67FE            	   412:             beq.s *               * branch if Z set
02:000005DA 083000011000    	   413:             btst.b #1,0(a0,d1.w)      *
02:000005E0 66FE            	   414:             bne.s *               * branch if Z clear
02:000005E2 083000071001    	   415:             btst.b #7,1(a0,d1.w)      *
02:000005E8 67FE            	   416:             beq.s *               * branch if Z set
                            	   417: *             EA = n(An,R.L)  - BYTE only
02:000005EA 083000000800    	   418:             btst.b #0,0(a0,d0.l)
02:000005F0 67FE            	   419:             beq.s *               * branch if Z set
02:000005F2 083000011800    	   420:             btst.b #1,0(a0,d1.l)      *
02:000005F8 66FE            	   421:             bne.s *               * branch if Z clear
02:000005FA 083000071801    	   422:             btst.b #7,1(a0,d1.l)      *
02:00000600 67FE            	   423:             beq.s *               * branch if Z set
                            	   424: *             EA = n(An,A.W)  - BYTE only
02:00000602 083000009000    	   425:             btst.b #0,0(a0,a1.w)
02:00000608 67FE            	   426:             beq.s *               * branch if Z set
02:0000060A 08300001A000    	   427:             btst.b #1,0(a0,a2.w)      *
02:00000610 66FE            	   428:             bne.s *               * branch if Z clear
02:00000612 08300007A001    	   429:             btst.b #7,1(a0,a2.w)      *
02:00000618 67FE            	   430:             beq.s *               * branch if Z set
                            	   431: *             EA = n(An,A.L)  - BYTE only
02:0000061A 083000009800    	   432:             btst.b #0,0(a0,a1.l)
02:00000620 67FE            	   433:             beq.s *               * branch if Z set
02:00000622 08300001A800    	   434:             btst.b #1,0(a0,a2.l)      *
02:00000628 66FE            	   435:             bne.s *               * branch if Z clear
02:0000062A 08300007A801    	   436:             btst.b #7,1(a0,a2.l)      *
02:00000630 67FE            	   437:             beq.s *               * branch if Z set
                            	   438: 
                            	   439: 
                            	   440: *             EA = x.W  - BYTE only
02:00000632 083800000100    	   441:             btst.b #0,$0100
02:00000638 67FE            	   442:             beq.s *               * branch if Z set
02:0000063A 083800010101    	   443:             btst.b #1,$0101           *
02:00000640 66FE            	   444:             bne.s *               * branch if Z clear
02:00000642 083800070102    	   445:             btst.b #7,$0102           *
02:00000648 67FE            	   446:             beq.s *               * branch if Z set
                            	   447: 
                            	   448: 
                            	   449: *             EA = x.L  - BYTE only
02:0000064A 207C0000F100    	   450:             move.l #$F100,a0      * point to memory to address 0x100
02:00000650 10FC0001        	   451:             move.b #$01,(a0)+         * populate test data
02:00000654 10FC00FC        	   452:             move.b #$FC,(a0)+         * populate test data
02:00000658 10FC0080        	   453:             move.b #$80,(a0)+         * populate test data
02:0000065C 083900000000F100	   454:             btst.b #0,$F100
02:00000664 67FE            	   455:             beq.s *               * branch if Z set
02:00000666 083900010000F101	   456:             btst.b #1,$F101       *
02:0000066E 66FE            	   457:             bne.s *               * branch if Z clear
02:00000670 083900070000F102	   458:             btst.b #7,$F102       *
02:00000678 67FE            	   459:             beq.s *               * branch if Z set
                            	   460: 
                            	   461: 
                            	   462: *             EA = x(PC)  - BYTE only
02:0000067A 4BFAFE9E        	   463:             lea op_BTST(pc),a5
02:0000067E 083A0000FE98    	   464:             btst.b #0,op_BTST(pc)
02:00000684 66FE            	   465:             bne.s *               * branch if Z clear
02:00000686 083A0003001A    	   466:             btst.b #3,op_BTST0(pc)     *
02:0000068C 67FE            	   467:             beq.s *               * branch if Z set
02:0000068E 083A00060074    	   468:             btst.b #6,op_BTST12(pc)    *
02:00000694 67FE            	   469:             beq.s *               * branch if Z set
                            	   470: 
                            	   471: 
                            	   472: *             EA = n(PC,R.W)  - BYTE only
02:00000696 307C0100        	   473:             move.l #$00000100,a0      * point to memory to address
02:0000069A 93C9            	   474:             move.l #$00000000,a1      * point to memory to address
02:0000069C 347C0001        	   475:             move.l #$00000001,a2      * point to memory to address
02:000006A0 7000            	   476:             moveq  #$00000000,d0      * point to memory to address
02:000006A2 7201            	   477:             moveq  #$00000001,d1      * point to memory to address
                            	   478: 
02:000006A4 083B000000FC    	   479: op_BTST0:   btst.b #0,op_BTST0(pc,d0.w)
02:000006AA 66FE            	   480:             bne.s *               * branch if Z clear
                            	   481: 
02:000006AC 4BFB1002        	   482:             lea op_BTST1(pc,d1.w),a5
02:000006B0 083B000110FC    	   483: op_BTST1:   btst.b #1,op_BTST1(pc,d1.w)      *
02:000006B6 67FE            	   484:             beq.s *               * branch if Z set
02:000006B8 083B000710FC    	   485: op_BTST2:   btst.b #7,op_BTST2(pc,d1.w)      *
02:000006BE 66FE            	   486:             bne.s *               * branch if Z clear
                            	   487: *             EA = n(PC,R.L)  - BYTE only
02:000006C0 083B000008FC    	   488: op_BTST3:   btst.b #0,op_BTST3(pc,d0.l)
02:000006C6 66FE            	   489:             bne.s *               * branch if Z clear
02:000006C8 083B000118FC    	   490: op_BTST4:   btst.b #1,op_BTST4(pc,d1.l)      *
02:000006CE 67FE            	   491:             beq.s *               * branch if Z set
02:000006D0 083B000718FC    	   492: op_BTST5:   btst.b #7,op_BTST5(pc,d1.l)      *
02:000006D6 66FE            	   493:             bne.s *               * branch if Z clear
                            	   494: *             EA = n(PC,A.W)  - BYTE only
02:000006D8 083B000090FC    	   495: op_BTST6    btst.b #0,op_BTST6(pc,a1.w)
02:000006DE 66FE            	   496:             bne.s *               * branch if Z clear
02:000006E0 083B0001A0FC    	   497: op_BTST7:   btst.b #1,op_BTST7(pc,a2.w)      *
02:000006E6 67FE            	   498:             beq.s *               * branch if Z set
02:000006E8 083B0007A0FC    	   499: op_BTST8:   btst.b #7,op_BTST8(pc,a2.w)      *
02:000006EE 66FE            	   500:             bne.s *               * branch if Z clear
                            	   501: *             EA = n(PC,A.L)  - BYTE only
02:000006F0 083B000098FC    	   502: op_BTST9:   btst.b #0,op_BTST9(pc,a1.l)
02:000006F6 66FE            	   503:             bne.s *               * branch if Z clear
02:000006F8 083B0001A8FC    	   504: op_BTST10:  btst.b #1,op_BTST10(pc,a2.l)      *
02:000006FE 67FE            	   505:             beq.s *               * branch if Z set
02:00000700 083B0007A8FC    	   506: op_BTST11:  btst.b #7,op_BTST11(pc,a2.l)      *
02:00000706 66FE            	   507: op_BTST12:  bne.s *               * branch if Z clear
                            	   508: 
                            	   509: 
                            	   510: 
                            	   511: * Bit Number.s Dynamic
                            	   512: 
                            	   513: *             EA = Dn  - LONG only
02:00000708 203C80000001    	   514:             move.l #$80000001,d0      * populate test data
02:0000070E 7A00            	   515:             move.l #0,d5              * populate bit.s number to test
02:00000710 7C01            	   516:             move.l #1,d6              * populate bit.s number to test
02:00000712 7E1F            	   517:             move.l #31,d7              * populate bit.s number to test
                            	   518: 
02:00000714 0B00            	   519:             btst.l d5,d0
02:00000716 67FE            	   520:             beq.s *               * branch if Z set
02:00000718 0D00            	   521:             btst.l d6,d0              *
02:0000071A 66FE            	   522:             bne.s *               * branch if Z clear
02:0000071C 0F00            	   523:             btst.l d7,d0             *
02:0000071E 67FE            	   524:             beq.s *               * branch if Z set
                            	   525: 
                            	   526: 
                            	   527: *             EA = (An)  - BYTE only
02:00000720 7A00            	   528:             move.l #0,d5              * populate bit.s number to test
02:00000722 7C01            	   529:             move.l #1,d6              * populate bit.s number to test
02:00000724 7E07            	   530:             move.l #7,d7              * populate bit.s number to test
02:00000726 307C0100        	   531:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000072A 10BC0081        	   532:             move.b #$81,(a0)          * populate test data
02:0000072E 1210            	   533:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:00000730 0B10            	   534:             btst.b d5,(a0)
02:00000732 67FE            	   535:             beq.s *               * branch if Z set
02:00000734 0D10            	   536:             btst.b d6,(a0)            *
02:00000736 66FE            	   537:             bne.s *               * branch if Z clear
02:00000738 0F10            	   538:             btst.b d7,(a0)            *
02:0000073A 67FE            	   539:             beq.s *               * branch if Z set
                            	   540: 
                            	   541: * ---
                            	   542: 
                            	   543: 
                            	   544: *             EA = (An)+  - BYTE only
02:0000073C 307C0100        	   545:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000740 10FC0001        	   546:             move.b #$01,(a0)+         * populate test data
02:00000744 10FC00FC        	   547:             move.b #$FC,(a0)+         * populate test data
02:00000748 10FC0080        	   548:             move.b #$80,(a0)+         * populate test data
02:0000074C 307C0100        	   549:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000750 0B18            	   550:             btst.b d5,(a0)+
02:00000752 67FE            	   551:             beq.s *               * branch if Z set
02:00000754 0D18            	   552:             btst.b d6,(a0)+           *
02:00000756 66FE            	   553:             bne.s *               * branch if Z clear
02:00000758 0F18            	   554:             btst.b d7,(a0)+           *
02:0000075A 67FE            	   555:             beq.s *               * branch if Z set
                            	   556: 
                            	   557: 
                            	   558: *             EA = -(An)  - BYTE only
02:0000075C 307C0100        	   559:             move.l #$00000100,a0      * point to memory to address
02:00000760 10FC0080        	   560:             move.b #$80,(a0)+         * populate test data
02:00000764 10FC00FC        	   561:             move.b #$FC,(a0)+         * populate test data
02:00000768 10FC0001        	   562:             move.b #$01,(a0)+         * populate test data
02:0000076C 307C0103        	   563:             move.l #$00000103,a0      * point to memory to address
02:00000770 0B20            	   564:             btst.b d5,-(a0)
02:00000772 67FE            	   565:             beq.s *               * branch if Z set
02:00000774 0D20            	   566:             btst.b d6,-(a0)           *
02:00000776 66FE            	   567:             bne.s *               * branch if Z clear
02:00000778 0F20            	   568:             btst.b d7,-(a0)           *
02:0000077A 67FE            	   569:             beq.s *               * branch if Z set
                            	   570: 
                            	   571: 
                            	   572: *             EA = n(An)  - BYTE only
02:0000077C 307C0100        	   573:             move.l #$00000100,a0      * point to memory to address
02:00000780 10FC0001        	   574:             move.b #$01,(a0)+         * populate test data
02:00000784 10FC00FC        	   575:             move.b #$FC,(a0)+         * populate test data
02:00000788 10FC0080        	   576:             move.b #$80,(a0)+         * populate test data
02:0000078C 307C0100        	   577:             move.l #$00000100,a0      * point to memory to address
02:00000790 0B10            	   578:             btst.b d5,0(a0)
02:00000792 67FE            	   579:             beq.s *               * branch if Z set
02:00000794 0D280001        	   580:             btst.b d6,1(a0)           *
02:00000798 66FE            	   581:             bne.s *               * branch if Z clear
02:0000079A 0F280002        	   582:             btst.b d7,2(a0)           *
02:0000079E 67FE            	   583:             beq.s *               * branch if Z set
                            	   584: 
                            	   585: 
                            	   586: *             EA = n(An,R.W)  - BYTE only
02:000007A0 307C0100        	   587:             move.l #$00000100,a0      * point to memory to address
02:000007A4 93C9            	   588:             move.l #$00000000,a1      * point to memory to address
02:000007A6 347C0001        	   589:             move.l #$00000001,a2      * point to memory to address
02:000007AA 7000            	   590:             moveq  #$00000000,d0      * point to memory to address
02:000007AC 7201            	   591:             moveq  #$00000001,d1      * point to memory to address
02:000007AE 0B300000        	   592:             btst.b d5,0(a0,d0.w)
02:000007B2 67FE            	   593:             beq.s *               * branch if Z set
02:000007B4 0D301000        	   594:             btst.b d6,0(a0,d1.w)      *
02:000007B8 66FE            	   595:             bne.s *               * branch if Z clear
02:000007BA 0F301001        	   596:             btst.b d7,1(a0,d1.w)      *
02:000007BE 67FE            	   597:             beq.s *               * branch if Z set
                            	   598: *             EA = n(An,R.L)  - BYTE only
02:000007C0 0B300800        	   599:             btst.b d5,0(a0,d0.l)
02:000007C4 67FE            	   600:             beq.s *               * branch if Z set
02:000007C6 0D301800        	   601:             btst.b d6,0(a0,d1.l)      *
02:000007CA 66FE            	   602:             bne.s *               * branch if Z clear
02:000007CC 0F301801        	   603:             btst.b d7,1(a0,d1.l)      *
02:000007D0 67FE            	   604:             beq.s *               * branch if Z set
                            	   605: *             EA = n(An,A.W)  - BYTE only
02:000007D2 0B309000        	   606:             btst.b d5,0(a0,a1.w)
02:000007D6 67FE            	   607:             beq.s *               * branch if Z set
02:000007D8 0D30A000        	   608:             btst.b d6,0(a0,a2.w)      *
02:000007DC 66FE            	   609:             bne.s *               * branch if Z clear
02:000007DE 0F30A001        	   610:             btst.b d7,1(a0,a2.w)      *
02:000007E2 67FE            	   611:             beq.s *               * branch if Z set
                            	   612: *             EA = n(An,A.L)  - BYTE only
02:000007E4 0B309800        	   613:             btst.b d5,0(a0,a1.l)
02:000007E8 67FE            	   614:             beq.s *               * branch if Z set
02:000007EA 0D30A800        	   615:             btst.b d6,0(a0,a2.l)      *
02:000007EE 66FE            	   616:             bne.s *               * branch if Z clear
02:000007F0 0F30A801        	   617:             btst.b d7,1(a0,a2.l)      *
02:000007F4 67FE            	   618:             beq.s *               * branch if Z set
                            	   619: 
                            	   620: 
                            	   621: *             EA = x.W  - BYTE only
02:000007F6 0B380100        	   622:             btst.b d5,$0100
02:000007FA 67FE            	   623:             beq.s *               * branch if Z set
02:000007FC 0D380101        	   624:             btst.b d6,$0101           *
02:00000800 66FE            	   625:             bne.s *               * branch if Z clear
02:00000802 0F380102        	   626:             btst.b d7,$0102           *
02:00000806 67FE            	   627:             beq.s *               * branch if Z set
                            	   628: 
                            	   629: 
                            	   630: *             EA = x.L  - BYTE only
02:00000808 207C0000F100    	   631:             move.l #$F100,a0      * point to memory to address 0x100
02:0000080E 10FC0001        	   632:             move.b #$01,(a0)+         * populate test data
02:00000812 10FC00FC        	   633:             move.b #$FC,(a0)+         * populate test data
02:00000816 10FC0080        	   634:             move.b #$80,(a0)+         * populate test data
02:0000081A 0B390000F100    	   635:             btst.b d5,$F100
02:00000820 67FE            	   636:             beq.s *               * branch if Z set
02:00000822 0D390000F101    	   637:             btst.b d6,$F101       *
02:00000828 66FE            	   638:             bne.s *               * branch if Z clear
02:0000082A 0F390000F102    	   639:             btst.b d7,$F102       *
02:00000830 67FE            	   640:             beq.s *               * branch if Z set
                            	   641: 
                            	   642: 
                            	   643: *             EA = x(PC)  - BYTE only
02:00000832 7C03            	   644:             move.l #3,d6              * populate bit.s number to test
02:00000834 7E06            	   645:             move.l #6,d7              * populate bit.s number to test
02:00000836 4BFAFCE2        	   646:             lea op_BTST(pc),a5
02:0000083A 0B3AFCDE        	   647:             btst.b d5,op_BTST(pc)
02:0000083E 66FE            	   648:             bne.s *               * branch if Z clear
02:00000840 0D3AFE62        	   649:             btst.b d6,op_BTST0(pc)     *
02:00000844 67FE            	   650:             beq.s *               * branch if Z set
02:00000846 0F3AFEBE        	   651:             btst.b d7,op_BTST12(pc)    *
02:0000084A 67FE            	   652:             beq.s *               * branch if Z set
                            	   653: 
                            	   654: 
                            	   655: *             EA = n(PC,R.W)  - BYTE only
02:0000084C 307C0100        	   656:             move.l #$00000100,a0      * point to memory to address
02:00000850 93C9            	   657:             move.l #$00000000,a1      * point to memory to address
02:00000852 347C0001        	   658:             move.l #$00000001,a2      * point to memory to address
02:00000856 7000            	   659:             moveq  #$00000000,d0      * point to memory to address
02:00000858 7201            	   660:             moveq  #$00000001,d1      * point to memory to address
02:0000085A 7C01            	   661:             move.l #1,d6              * populate bit.s number to test
02:0000085C 7E07            	   662:             move.l #7,d7              * populate bit.s number to test
                            	   663: 
02:0000085E 0B3B00FE        	   664: op_BTST20:  btst.b d5,op_BTST20(pc,d0.w)
02:00000862 67FE            	   665:             beq.s *               * branch if Z set
02:00000864 4BFB1002        	   666:             lea op_BTST21(pc,d1.w),a5
02:00000868 0D3B10FE        	   667: op_BTST21:  btst.b d6,op_BTST21(pc,d1.w)      *
02:0000086C 67FE            	   668:             beq.s *               * branch if Z set
02:0000086E 0F3B10FE        	   669: op_BTST22:  btst.b d7,op_BTST22(pc,d1.w)      *
02:00000872 66FE            	   670:             bne.s *               * branch if Z clear
                            	   671: *             EA = n(PC,R.L)  - BYTE only
02:00000874 0B3B08FE        	   672: op_BTST23:  btst.b d5,op_BTST23(pc,d0.l)
02:00000878 67FE            	   673:             beq.s *               * branch if Z set
02:0000087A 0D3B18FE        	   674: op_BTST24: btst.b d6,op_BTST24(pc,d1.l)      *
02:0000087E 67FE            	   675:             beq.s *               * branch if Z set
02:00000880 0F3B18FE        	   676: op_BTST25  btst.b d7,op_BTST25(pc,d1.l)      *
02:00000884 66FE            	   677:             bne.s *               * branch if Z clear
                            	   678: *             EA = n(PC,A.W)  - BYTE only
02:00000886 0B3B90FE        	   679: op_BTST26   btst.b d5,op_BTST26(pc,a1.w)
02:0000088A 67FE            	   680:             beq.s *               * branch if Z set
02:0000088C 0D3BA0FE        	   681: op_BTST27:  btst.b d6,op_BTST27(pc,a2.w)      *
02:00000890 67FE            	   682:             beq.s *               * branch if Z set
02:00000892 0F3BA0FE        	   683: op_BTST28:  btst.b d7,op_BTST28(pc,a2.w)      *
02:00000896 66FE            	   684:             bne.s *               * branch if Z clear
                            	   685: *             EA = n(PC,A.L)  - BYTE only
02:00000898 0B3B98FE        	   686: op_BTST29:  btst.b d5,op_BTST29(pc,a1.l)
02:0000089C 67FE            	   687:             beq.s *               * branch if Z set
02:0000089E 0D3BA8FE        	   688: op_BTST30:  btst.b d6,op_BTST30(pc,a2.l)      *
02:000008A2 67FE            	   689:             beq.s *               * branch if Z set
02:000008A4 0F3BA8FE        	   690: op_BTST31:  btst.b d7,op_BTST31(pc,a2.l)      *
02:000008A8 66FE            	   691: op_BTST32:  bne.s *               * branch if Z clear
                            	   692: 
                            	   693: *             EA = #x  - BYTE only
                            	   694: 
02:000008AA 7A00            	   695:             move.l #0,d5              * populate bit.s number to test
02:000008AC 7C03            	   696:             move.l #3,d6              * populate bit.s number to test
02:000008AE 7E07            	   697:             move.l #7,d7              * populate bit.s number to test
                            	   698: 
02:000008B0 0B3C0088        	   699:             btst.b d5,#$88
02:000008B4 66FE            	   700:             bne.s *               * branch if Z clear
02:000008B6 0D3C0088        	   701:             btst.b d6,#$88
02:000008BA 67FE            	   702:             beq.s *               * branch if Z set
02:000008BC 0F3C0088        	   703:             btst.b d7,#$88
02:000008C0 67FE            	   704:             beq.s *               * branch if Z set
                            	   705: 
                            	   706: 
02:000008C2 4E75            	   707:     rts
                            	   708: 
                            	   709: *-----------------------------------------------------------
                            	   710: *-----------------------------------------------------------
                            	   711: * OPCODE : BCHG
                            	   712: *-----------------------------------------------------------
                            	   713: *-----------------------------------------------------------
                            	   714: op_BCHG:
                            	   715: 
                            	   716: 
                            	   717: *  Bit Number.s Static
                            	   718: 
                            	   719: *             EA = Dn  - LONG only
02:000008C4 203C80000001    	   720:             move.l #$80000001,d0      * populate test data
02:000008CA 08400000        	   721:             bchg.l #0,d0
02:000008CE 67FE            	   722:             beq.s *               * branch if Z set
02:000008D0 08400001        	   723:             bchg.l #1,d0              *
02:000008D4 66FE            	   724:             bne.s *               * branch if Z clear
02:000008D6 0840001F        	   725:             bchg.l #31,d0             *
02:000008DA 67FE            	   726:             beq.s *               * branch if Z set
02:000008DC 0C8000000002    	   727:             cmpi.l #$00000002,d0
02:000008E2 66FE            	   728:             bne.s *               * branch if Z clear
                            	   729: 
                            	   730: 
                            	   731: *             EA = (An)  - BYTE only
02:000008E4 307C0100        	   732:             move.l #$00000100,a0      * point to memory to address 0x100
02:000008E8 10BC0081        	   733:             move.b #$81,(a0)          * populate test data
02:000008EC 1210            	   734:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:000008EE 08500000        	   735:             bchg.b #0,(a0)
02:000008F2 67FE            	   736:             beq.s *               * branch if Z set
02:000008F4 08500001        	   737:             bchg.b #1,(a0)            *
02:000008F8 66FE            	   738:             bne.s *               * branch if Z clear
02:000008FA 08500007        	   739:             bchg.b #7,(a0)            *
02:000008FE 67FE            	   740:             beq.s *               * branch if Z set
02:00000900 0C100002        	   741:             cmpi.b #$02,(a0)
02:00000904 66FE            	   742:             bne.s *               * branch if Z clear
                            	   743: 
                            	   744: *             EA = (An)+  - BYTE only
02:00000906 307C0100        	   745:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000090A 10FC0001        	   746:             move.b #$01,(a0)+         * populate test data
02:0000090E 10FC00FC        	   747:             move.b #$FC,(a0)+         * populate test data
02:00000912 10FC0080        	   748:             move.b #$80,(a0)+         * populate test data
02:00000916 307C0100        	   749:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000091A 08580000        	   750:             bchg.b #0,(a0)+
02:0000091E 67FE            	   751:             beq.s *               * branch if Z set
02:00000920 08580001        	   752:             bchg.b #1,(a0)+           *
02:00000924 66FE            	   753:             bne.s *               * branch if Z clear
02:00000926 08580007        	   754:             bchg.b #7,(a0)+           *
02:0000092A 67FE            	   755:             beq.s *               * branch if Z set
02:0000092C 307C0100        	   756:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000930 4A18            	   757:             cmpi.b #$00,(a0)+
02:00000932 66FE            	   758:             bne.s *               * branch if Z clear
02:00000934 0C1800FE        	   759:             cmpi.b #$FE,(a0)+
02:00000938 66FE            	   760:             bne.s *               * branch if Z clear
02:0000093A 4A18            	   761:             cmpi.b #$00,(a0)+
02:0000093C 66FE            	   762:             bne.s *               * branch if Z clear
                            	   763: 
                            	   764: *             EA = -(An)  - BYTE only
02:0000093E 307C0100        	   765:             move.l #$00000100,a0      * point to memory to address
02:00000942 10FC0080        	   766:             move.b #$80,(a0)+         * populate test data
02:00000946 10FC00FC        	   767:             move.b #$FC,(a0)+         * populate test data
02:0000094A 10FC0001        	   768:             move.b #$01,(a0)+         * populate test data
02:0000094E 307C0103        	   769:             move.l #$00000103,a0      * point to memory to address
02:00000952 08600000        	   770:             bchg.b #0,-(a0)
02:00000956 67FE            	   771:             beq.s *               * branch if Z set
02:00000958 08600001        	   772:             bchg.b #1,-(a0)           *
02:0000095C 66FE            	   773:             bne.s *               * branch if Z clear
02:0000095E 08600007        	   774:             bchg.b #7,-(a0)           *
02:00000962 67FE            	   775:             beq.s *               * branch if Z set
02:00000964 307C0103        	   776:             move.l #$00000103,a0      * point to memory to address 0x100
02:00000968 4A20            	   777:             cmpi.b #$00,-(a0)
02:0000096A 66FE            	   778:             bne.s *               * branch if Z clear
02:0000096C 0C2000FE        	   779:             cmpi.b #$FE,-(a0)
02:00000970 66FE            	   780:             bne.s *               * branch if Z clear
02:00000972 4A20            	   781:             cmpi.b #$00,-(a0)
02:00000974 66FE            	   782:             bne.s *               * branch if Z clear
                            	   783: 
                            	   784: 
                            	   785: *             EA = n(An)  - BYTE only
02:00000976 307C0100        	   786:             move.l #$00000100,a0      * point to memory to address
02:0000097A 10FC0001        	   787:             move.b #$01,(a0)+         * populate test data
02:0000097E 10FC00FC        	   788:             move.b #$FC,(a0)+         * populate test data
02:00000982 10FC0080        	   789:             move.b #$80,(a0)+         * populate test data
02:00000986 307C0100        	   790:             move.l #$00000100,a0      * point to memory to address
02:0000098A 08500000        	   791:             bchg.b #0,0(a0)
02:0000098E 67FE            	   792:             beq.s *               * branch if Z set
02:00000990 086800010001    	   793:             bchg.b #1,1(a0)           *
02:00000996 66FE            	   794:             bne.s *               * branch if Z clear
02:00000998 086800070002    	   795:             bchg.b #7,2(a0)           *
02:0000099E 67FE            	   796:             beq.s *               * branch if Z set
02:000009A0 307C0100        	   797:             move.l #$00000100,a0      * point to memory to address 0x100
02:000009A4 4A18            	   798:             cmpi.b #$00,(a0)+
02:000009A6 66FE            	   799:             bne.s *               * branch if Z clear
02:000009A8 0C1800FE        	   800:             cmpi.b #$FE,(a0)+
02:000009AC 66FE            	   801:             bne.s *               * branch if Z clear
02:000009AE 4A18            	   802:             cmpi.b #$00,(a0)+
02:000009B0 66FE            	   803:             bne.s *               * branch if Z clear
                            	   804: 
                            	   805: 
                            	   806: *             EA = n(An,D.W)  - BYTE only
02:000009B2 307C0100        	   807:             move.l #$00000100,a0      * point to memory to address
02:000009B6 93C9            	   808:             move.l #$00000000,a1      * point to memory to address
02:000009B8 347C0001        	   809:             move.l #$00000001,a2      * point to memory to address
02:000009BC 7000            	   810:             moveq  #$00000000,d0      * point to memory to address
02:000009BE 7201            	   811:             moveq  #$00000001,d1      * point to memory to address
02:000009C0 087000000000    	   812:             bchg.b #0,0(a0,d0.w)
02:000009C6 66FE            	   813:             bne.s *               * branch if Z clear
02:000009C8 087000011000    	   814:             bchg.b #1,0(a0,d1.w)      *
02:000009CE 67FE            	   815:             beq.s *               * branch if Z set
02:000009D0 087000071001    	   816:             bchg.b #7,1(a0,d1.w)      *
02:000009D6 66FE            	   817:             bne.s *               * branch if Z clear
                            	   818: *             EA = n(An,D.L)  - BYTE only
02:000009D8 087000000800    	   819:             bchg.b #0,0(a0,d0.l)
02:000009DE 67FE            	   820:             beq.s *               * branch if Z set
02:000009E0 087000011800    	   821:             bchg.b #1,0(a0,d1.l)      *
02:000009E6 66FE            	   822:             bne.s *               * branch if Z clear
02:000009E8 087000071801    	   823:             bchg.b #7,1(a0,d1.l)      *
02:000009EE 67FE            	   824:             beq.s *               * branch if Z set
                            	   825: *             EA = n(An,A.W)  - BYTE only
02:000009F0 087000009000    	   826:             bchg.b #0,0(a0,a1.w)
02:000009F6 66FE            	   827:             bne.s *               * branch if Z clear
02:000009F8 08700001A000    	   828:             bchg.b #1,0(a0,a2.w)      *
02:000009FE 67FE            	   829:             beq.s *               * branch if Z set
02:00000A00 08700007A001    	   830:             bchg.b #7,1(a0,a2.w)      *
02:00000A06 66FE            	   831:             bne.s *               * branch if Z clear
                            	   832: *             EA = n(An,A.L)  - BYTE only
02:00000A08 087000009800    	   833:             bchg.b #0,0(a0,a1.l)
02:00000A0E 67FE            	   834:             beq.s *               * branch if Z set
02:00000A10 08700001A800    	   835:             bchg.b #1,0(a0,a2.l)      *
02:00000A16 66FE            	   836:             bne.s *               * branch if Z clear
02:00000A18 08700007A801    	   837:             bchg.b #7,1(a0,a2.l)      *
02:00000A1E 67FE            	   838:             beq.s *               * branch if Z set
02:00000A20 307C0100        	   839:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A24 4A18            	   840:             cmpi.b #$00,(a0)+
02:00000A26 66FE            	   841:             bne.s *               * branch if Z clear
02:00000A28 0C1800FE        	   842:             cmpi.b #$FE,(a0)+
02:00000A2C 66FE            	   843:             bne.s *               * branch if Z clear
02:00000A2E 4A18            	   844:             cmpi.b #$00,(a0)+
02:00000A30 66FE            	   845:             bne.s *               * branch if Z clear
                            	   846: 
                            	   847: 
                            	   848: *             EA = x.W  - BYTE only
02:00000A32 087800000100    	   849:             bchg.b #0,$0100
02:00000A38 66FE            	   850:             bne.s *               * branch if Z clear
02:00000A3A 087800010101    	   851:             bchg.b #1,$0101           *
02:00000A40 67FE            	   852:             beq.s *               * branch if Z set
02:00000A42 087800070102    	   853:             bchg.b #7,$0102           *
02:00000A48 66FE            	   854:             bne.s *               * branch if Z clear
02:00000A4A 307C0100        	   855:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A4E 0C180001        	   856:             cmpi.b #$01,(a0)+
02:00000A52 66FE            	   857:             bne.s *               * branch if Z clear
02:00000A54 0C1800FC        	   858:             cmpi.b #$FC,(a0)+
02:00000A58 66FE            	   859:             bne.s *               * branch if Z clear
02:00000A5A 0C180080        	   860:             cmpi.b #$80,(a0)+
02:00000A5E 66FE            	   861:             bne.s *               * branch if Z clear
                            	   862: 
                            	   863: *             EA = x.L  - BYTE only
02:00000A60 207C0000F100    	   864:             move.l #$F100,a0      * point to memory to address 0x100
02:00000A66 10FC0001        	   865:             move.b #$01,(a0)+         * populate test data
02:00000A6A 10FC00FC        	   866:             move.b #$FC,(a0)+         * populate test data
02:00000A6E 10FC0080        	   867:             move.b #$80,(a0)+         * populate test data
02:00000A72 087900000000F100	   868:             bchg.b #0,$F100
02:00000A7A 67FE            	   869:             beq.s *               * branch if Z set
02:00000A7C 087900010000F101	   870:             bchg.b #1,$F101       *
02:00000A84 66FE            	   871:             bne.s *               * branch if Z clear
02:00000A86 087900070000F102	   872:             bchg.b #7,$F102       *
02:00000A8E 67FE            	   873:             beq.s *               * branch if Z set
02:00000A90 307C0100        	   874:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A94 0C180001        	   875:             cmpi.b #$01,(a0)+
02:00000A98 66FE            	   876:             bne.s *               * branch if Z clear
02:00000A9A 0C1800FC        	   877:             cmpi.b #$FC,(a0)+
02:00000A9E 66FE            	   878:             bne.s *               * branch if Z clear
02:00000AA0 0C180080        	   879:             cmpi.b #$80,(a0)+
02:00000AA4 66FE            	   880:             bne.s *               * branch if Z clear
                            	   881: 
                            	   882: 
                            	   883: * Bit Number.s Dynamic
                            	   884: 
                            	   885: *             EA = Dn  - LONG only
02:00000AA6 203C80000001    	   886:             move.l #$80000001,d0      * populate test data
02:00000AAC 7A00            	   887:             move.l #0,d5              * populate bit.s number to test
02:00000AAE 7C01            	   888:             move.l #1,d6              * populate bit.s number to test
02:00000AB0 7E1F            	   889:             move.l #31,d7              * populate bit.s number to test
                            	   890: 
02:00000AB2 0B40            	   891:             bchg.l d5,d0
02:00000AB4 67FE            	   892:             beq.s *               * branch if Z set
02:00000AB6 0D40            	   893:             bchg.l d6,d0              *
02:00000AB8 66FE            	   894:             bne.s *               * branch if Z clear
02:00000ABA 0F40            	   895:             bchg.l d7,d0             *
02:00000ABC 67FE            	   896:             beq.s *               * branch if Z set
02:00000ABE 0C8000000002    	   897:             cmpi.l #$00000002,d0
02:00000AC4 66FE            	   898:             bne.s *               * branch if Z clear
                            	   899: 
                            	   900: 
                            	   901: *             EA = (An)  - BYTE only
02:00000AC6 7A00            	   902:             move.l #0,d5              * populate bit.s number to test
02:00000AC8 7C01            	   903:             move.l #1,d6              * populate bit.s number to test
02:00000ACA 7E07            	   904:             move.l #7,d7              * populate bit.s number to test
02:00000ACC 307C0100        	   905:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000AD0 10BC0081        	   906:             move.b #$81,(a0)          * populate test data
02:00000AD4 1210            	   907:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:00000AD6 0B50            	   908:             bchg.b d5,(a0)
02:00000AD8 67FE            	   909:             beq.s *               * branch if Z set
02:00000ADA 0D50            	   910:             bchg.b d6,(a0)            *
02:00000ADC 66FE            	   911:             bne.s *               * branch if Z clear
02:00000ADE 0F50            	   912:             bchg.b d7,(a0)            *
02:00000AE0 67FE            	   913:             beq.s *               * branch if Z set
02:00000AE2 0C100002        	   914:             cmpi.b #$02,(a0)
02:00000AE6 66FE            	   915:             bne.s *               * branch if Z clear
                            	   916: 
                            	   917: 
                            	   918: *             EA = (An)+  - BYTE only
02:00000AE8 307C0100        	   919:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000AEC 10FC0001        	   920:             move.b #$01,(a0)+         * populate test data
02:00000AF0 10FC00FC        	   921:             move.b #$FC,(a0)+         * populate test data
02:00000AF4 10FC0080        	   922:             move.b #$80,(a0)+         * populate test data
02:00000AF8 307C0100        	   923:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000AFC 0B58            	   924:             bchg.b d5,(a0)+
02:00000AFE 67FE            	   925:             beq.s *               * branch if Z set
02:00000B00 0D58            	   926:             bchg.b d6,(a0)+           *
02:00000B02 66FE            	   927:             bne.s *               * branch if Z clear
02:00000B04 0F58            	   928:             bchg.b d7,(a0)+           *
02:00000B06 67FE            	   929:             beq.s *               * branch if Z set
02:00000B08 307C0100        	   930:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000B0C 4A18            	   931:             cmpi.b #$00,(a0)+
02:00000B0E 66FE            	   932:             bne.s *               * branch if Z clear
02:00000B10 0C1800FE        	   933:             cmpi.b #$FE,(a0)+
02:00000B14 66FE            	   934:             bne.s *               * branch if Z clear
02:00000B16 4A18            	   935:             cmpi.b #$00,(a0)+
02:00000B18 66FE            	   936:             bne.s *               * branch if Z clear
                            	   937: 
                            	   938: *             EA = -(An)  - BYTE only
02:00000B1A 307C0100        	   939:             move.l #$00000100,a0      * point to memory to address
02:00000B1E 10FC0080        	   940:             move.b #$80,(a0)+         * populate test data
02:00000B22 10FC00FC        	   941:             move.b #$FC,(a0)+         * populate test data
02:00000B26 10FC0001        	   942:             move.b #$01,(a0)+         * populate test data
02:00000B2A 307C0103        	   943:             move.l #$00000103,a0      * point to memory to address
02:00000B2E 0B60            	   944:             bchg.b d5,-(a0)
02:00000B30 67FE            	   945:             beq.s *               * branch if Z set
02:00000B32 0D60            	   946:             bchg.b d6,-(a0)           *
02:00000B34 66FE            	   947:             bne.s *               * branch if Z clear
02:00000B36 0F60            	   948:             bchg.b d7,-(a0)           *
02:00000B38 67FE            	   949:             beq.s *               * branch if Z set
02:00000B3A 307C0103        	   950:             move.l #$00000103,a0      * point to memory to address 0x100
02:00000B3E 4A20            	   951:             cmpi.b #$00,-(a0)
02:00000B40 66FE            	   952:             bne.s *               * branch if Z clear
02:00000B42 0C2000FE        	   953:             cmpi.b #$FE,-(a0)
02:00000B46 66FE            	   954:             bne.s *               * branch if Z clear
02:00000B48 4A20            	   955:             cmpi.b #$00,-(a0)
02:00000B4A 66FE            	   956:             bne.s *               * branch if Z clear
                            	   957: 
                            	   958: *             EA = n(An)  - BYTE only
02:00000B4C 307C0100        	   959:             move.l #$00000100,a0      * point to memory to address
02:00000B50 10FC0001        	   960:             move.b #$01,(a0)+         * populate test data
02:00000B54 10FC00FC        	   961:             move.b #$FC,(a0)+         * populate test data
02:00000B58 10FC0080        	   962:             move.b #$80,(a0)+         * populate test data
02:00000B5C 307C0100        	   963:             move.l #$00000100,a0      * point to memory to address
02:00000B60 0B50            	   964:             bchg.b d5,0(a0)
02:00000B62 67FE            	   965:             beq.s *               * branch if Z set
02:00000B64 0D680001        	   966:             bchg.b d6,1(a0)           *
02:00000B68 66FE            	   967:             bne.s *               * branch if Z clear
02:00000B6A 0F680002        	   968:             bchg.b d7,2(a0)           *
02:00000B6E 67FE            	   969:             beq.s *               * branch if Z set
02:00000B70 307C0100        	   970:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000B74 4A18            	   971:             cmpi.b #$00,(a0)+
02:00000B76 66FE            	   972:             bne.s *               * branch if Z clear
02:00000B78 0C1800FE        	   973:             cmpi.b #$FE,(a0)+
02:00000B7C 66FE            	   974:             bne.s *               * branch if Z clear
02:00000B7E 4A18            	   975:             cmpi.b #$00,(a0)+
02:00000B80 66FE            	   976:             bne.s *               * branch if Z clear
                            	   977: 
                            	   978: *             EA = n(An,R.W)  - BYTE only
02:00000B82 307C0100        	   979:             move.l #$00000100,a0      * point to memory to address
02:00000B86 93C9            	   980:             move.l #$00000000,a1      * point to memory to address
02:00000B88 347C0001        	   981:             move.l #$00000001,a2      * point to memory to address
02:00000B8C 7000            	   982:             moveq  #$00000000,d0      * point to memory to address
02:00000B8E 7201            	   983:             moveq  #$00000001,d1      * point to memory to address
02:00000B90 0B700000        	   984:             bchg.b d5,0(a0,d0.w)
02:00000B94 66FE            	   985:             bne.s *               * branch if Z clear
02:00000B96 0D701000        	   986:             bchg.b d6,0(a0,d1.w)      *
02:00000B9A 67FE            	   987:             beq.s *               * branch if Z set
02:00000B9C 0F701001        	   988:             bchg.b d7,1(a0,d1.w)      *
02:00000BA0 66FE            	   989:             bne.s *               * branch if Z clear
                            	   990: *             EA = n(An,R.L)  - BYTE only
02:00000BA2 0B700800        	   991:             bchg.b d5,0(a0,d0.l)
02:00000BA6 67FE            	   992:             beq.s *               * branch if Z set
02:00000BA8 0D701800        	   993:             bchg.b d6,0(a0,d1.l)      *
02:00000BAC 66FE            	   994:             bne.s *               * branch if Z clear
02:00000BAE 0F701801        	   995:             bchg.b d7,1(a0,d1.l)      *
02:00000BB2 67FE            	   996:             beq.s *               * branch if Z set
                            	   997: *             EA = n(An,A.W)  - BYTE only
02:00000BB4 0B709000        	   998:             bchg.b d5,0(a0,a1.w)
02:00000BB8 66FE            	   999:             bne.s *               * branch if Z clear
02:00000BBA 0D70A000        	  1000:             bchg.b d6,0(a0,a2.w)      *
02:00000BBE 67FE            	  1001:             beq.s *               * branch if Z set
02:00000BC0 0F70A001        	  1002:             bchg.b d7,1(a0,a2.w)      *
02:00000BC4 66FE            	  1003:             bne.s *               * branch if Z clear
                            	  1004: *             EA = n(An,A.L)  - BYTE only
02:00000BC6 0B709800        	  1005:             bchg.b d5,0(a0,a1.l)
02:00000BCA 67FE            	  1006:             beq.s *               * branch if Z set
02:00000BCC 0D70A800        	  1007:             bchg.b d6,0(a0,a2.l)      *
02:00000BD0 66FE            	  1008:             bne.s *               * branch if Z clear
02:00000BD2 0F70A801        	  1009:             bchg.b d7,1(a0,a2.l)      *
02:00000BD6 67FE            	  1010:             beq.s *               * branch if Z set
02:00000BD8 4A18            	  1011:             cmpi.b #$00,(a0)+
02:00000BDA 66FE            	  1012:             bne.s *               * branch if Z clear
                            	  1013: 
                            	  1014: *             EA = x.W  - BYTE only
02:00000BDC 0B780100        	  1015:             bchg.b d5,$0100
02:00000BE0 66FE            	  1016:             bne.s *               * branch if Z clear
02:00000BE2 0D780101        	  1017:             bchg.b d6,$0101           *
02:00000BE6 67FE            	  1018:             beq.s *               * branch if Z set
02:00000BE8 0F780102        	  1019:             bchg.b d7,$0102           *
02:00000BEC 66FE            	  1020:             bne.s *               * branch if Z clear
02:00000BEE 0C1800FC        	  1021:             cmpi.b #$FC,(a0)+
02:00000BF2 66FE            	  1022:             bne.s *               * branch if Z clear
                            	  1023: 
                            	  1024: *             EA = x.L  - BYTE only
02:00000BF4 207C0000F100    	  1025:             move.l #$F100,a0      * point to memory to address 0x100
02:00000BFA 10FC0001        	  1026:             move.b #$01,(a0)+         * populate test data
02:00000BFE 10FC00FC        	  1027:             move.b #$FC,(a0)+         * populate test data
02:00000C02 10FC0080        	  1028:             move.b #$80,(a0)+         * populate test data
02:00000C06 0B790000F100    	  1029:             bchg.b d5,$F100
02:00000C0C 67FE            	  1030:             beq.s *               * branch if Z set
02:00000C0E 0D790000F101    	  1031:             bchg.b d6,$F101       *
02:00000C14 66FE            	  1032:             bne.s *               * branch if Z clear
02:00000C16 0F790000F102    	  1033:             bchg.b d7,$F102       *
02:00000C1C 67FE            	  1034:             beq.s *               * branch if Z set
02:00000C1E 207C0000F101    	  1035:             move.l #$F101,a0      * point to memory to address 0x100
02:00000C24 0C1000FE        	  1036:             cmpi.b #$FE,(a0)
02:00000C28 66FE            	  1037:             bne.s *               * branch if Z clear
                            	  1038: 
                            	  1039: 
02:00000C2A 4E75            	  1040:     rts
                            	  1041: 
                            	  1042: *-----------------------------------------------------------
                            	  1043: *-----------------------------------------------------------
                            	  1044: * OPCODE : BCLR
                            	  1045: *-----------------------------------------------------------
                            	  1046: *-----------------------------------------------------------
                            	  1047: op_BCLR:
                            	  1048: 
                            	  1049: 
                            	  1050: *  Bit Number.s Static
                            	  1051: 
                            	  1052: *             EA = Dn  - LONG only
02:00000C2C 203CFF0000FF    	  1053:             move.l #$FF0000FF,d0      * populate test data
02:00000C32 08800000        	  1054:             bclr.l #0,d0
02:00000C36 67FE            	  1055:             beq.s *               * branch if Z set
02:00000C38 08800001        	  1056:             bclr.l #1,d0              *
02:00000C3C 67FE            	  1057:             beq.s *               * branch if Z set
02:00000C3E 0880000F        	  1058:             bclr.l #15,d0             *
02:00000C42 66FE            	  1059:             bne.s *               * branch if Z clear
02:00000C44 0880001F        	  1060:             bclr.l #31,d0             *
02:00000C48 67FE            	  1061:             beq.s *               * branch if Z set
02:00000C4A 0C807F0000FC    	  1062:             cmpi.l #$7F0000FC,d0
02:00000C50 66FE            	  1063:             bne.s *               * branch if Z clear
                            	  1064: 
                            	  1065: 
                            	  1066: *             EA = (An)  - BYTE only
02:00000C52 307C0100        	  1067:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C56 10BC000F        	  1068:             move.b #$0F,(a0)          * populate test data
02:00000C5A 08900000        	  1069:             bclr.b #0,(a0)
02:00000C5E 67FE            	  1070:             beq.s *               * branch if Z set
02:00000C60 08900007        	  1071:             bclr.b #7,(a0)            *
02:00000C64 66FE            	  1072:             bne.s *               * branch if Z clear
02:00000C66 0C10000E        	  1073:             cmpi.b #$0E,(a0)
02:00000C6A 66FE            	  1074:             bne.s *               * branch if Z clear
                            	  1075: 
                            	  1076: *             EA = (An)+  - BYTE only
02:00000C6C 307C0100        	  1077:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C70 10FC0001        	  1078:             move.b #$01,(a0)+         * populate test data
02:00000C74 4218            	  1079:             move.b #$00,(a0)+         * populate test data
02:00000C76 307C0100        	  1080:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C7A 08980000        	  1081:             bclr.b #0,(a0)+
02:00000C7E 67FE            	  1082:             beq.s *               * branch if Z set
02:00000C80 08980001        	  1083:             bclr.b #1,(a0)+           *
02:00000C84 66FE            	  1084:             bne.s *               * branch if Z clear
02:00000C86 307C0100        	  1085:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C8A 4A18            	  1086:             cmpi.b #$00,(a0)+
02:00000C8C 66FE            	  1087:             bne.s *               * branch if Z clear
02:00000C8E 4A18            	  1088:             cmpi.b #$00,(a0)+
02:00000C90 66FE            	  1089:             bne.s *               * branch if Z clear
                            	  1090: 
                            	  1091: 
                            	  1092: *             EA = -(An)  - BYTE only
02:00000C92 307C0100        	  1093:             move.l #$00000100,a0      * point to memory to address
02:00000C96 10FC0001        	  1094:             move.b #$01,(a0)+         * populate test data
02:00000C9A 10FC0080        	  1095:             move.b #$80,(a0)+         * populate test data
02:00000C9E 08A00007        	  1096:             bclr.b #7,-(a0)
02:00000CA2 67FE            	  1097:             beq.s *               * branch if Z set
02:00000CA4 08A00000        	  1098:             bclr.b #0,-(a0)           *
02:00000CA8 67FE            	  1099:             beq.s *               * branch if Z set
02:00000CAA 307C0102        	  1100:             move.l #$00000102,a0      * point to memory to address 0x100
02:00000CAE 4A20            	  1101:             cmpi.b #$00,-(a0)
02:00000CB0 66FE            	  1102:             bne.s *               * branch if Z clear
02:00000CB2 4A20            	  1103:             cmpi.b #$00,-(a0)
02:00000CB4 66FE            	  1104:             bne.s *               * branch if Z clear
                            	  1105: 
                            	  1106: 
                            	  1107: *             EA = n(An)  - BYTE only
02:00000CB6 307C0100        	  1108:             move.l #$00000100,a0      * point to memory to address
02:00000CBA 10FC00FF        	  1109:             move.b #$FF,(a0)+         * populate test data
02:00000CBE 10FC00FF        	  1110:             move.b #$FF,(a0)+         * populate test data
02:00000CC2 307C0100        	  1111:             move.l #$00000100,a0      * point to memory to address
02:00000CC6 08900000        	  1112:             bclr.b #0,0(a0)
02:00000CCA 67FE            	  1113:             beq.s *               * branch if Z set
02:00000CCC 08A800040001    	  1114:             bclr.b #4,1(a0)           *
02:00000CD2 67FE            	  1115:             beq.s *               * branch if Z set
02:00000CD4 307C0100        	  1116:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000CD8 0C1800FE        	  1117:             cmpi.b #$FE,(a0)+
02:00000CDC 66FE            	  1118:             bne.s *               * branch if Z clear
02:00000CDE 0C1800EF        	  1119:             cmpi.b #$EF,(a0)+
02:00000CE2 66FE            	  1120:             bne.s *               * branch if Z clear
                            	  1121: 
                            	  1122: 
                            	  1123: *             EA = n(An,D.W)  - BYTE only
02:00000CE4 307C0100        	  1124:             move.l #$00000100,a0      * point to memory to address
02:00000CE8 93C9            	  1125:             move.l #$00000000,a1      * point to memory to address
02:00000CEA 347C0001        	  1126:             move.l #$00000001,a2      * point to memory to address
02:00000CEE 7000            	  1127:             moveq  #$00000000,d0      * point to memory to address
02:00000CF0 7201            	  1128:             moveq  #$00000001,d1      * point to memory to address
02:00000CF2 10FC00FF        	  1129:             move.b #$FF,(a0)+         * populate test data
02:00000CF6 10FC00FF        	  1130:             move.b #$FF,(a0)+         * populate test data
02:00000CFA 307C0100        	  1131:             move.l #$00000100,a0      * point to memory to address
02:00000CFE 08B000000000    	  1132:             bclr.b #0,0(a0,d0.w)
02:00000D04 67FE            	  1133:             beq.s *               * branch if Z set
02:00000D06 08B000011000    	  1134:             bclr.b #1,0(a0,d1.w)      *
02:00000D0C 67FE            	  1135:             beq.s *               * branch if Z set
02:00000D0E 08B000021001    	  1136:             bclr.b #2,1(a0,d1.w)      *
02:00000D14 66FE            	  1137:             bne.s *               * branch if Z clear
                            	  1138: *             EA = n(An,D.L)  - BYTE only
02:00000D16 08B000030800    	  1139:             bclr.b #3,0(a0,d0.l)
02:00000D1C 67FE            	  1140:             beq.s *               * branch if Z set
02:00000D1E 08B000041800    	  1141:             bclr.b #4,0(a0,d1.l)      *
02:00000D24 67FE            	  1142:             beq.s *               * branch if Z set
02:00000D26 08B000051801    	  1143:             bclr.b #5,1(a0,d1.l)      *
02:00000D2C 66FE            	  1144:             bne.s *               * branch if Z clear
                            	  1145: *             EA = n(An,A.W)  - BYTE only
02:00000D2E 08B000069000    	  1146:             bclr.b #6,0(a0,a1.w)
02:00000D34 67FE            	  1147:             beq.s *               * branch if Z set
02:00000D36 08B00001A000    	  1148:             bclr.b #1,0(a0,a2.w)      *
02:00000D3C 66FE            	  1149:             bne.s *               * branch if Z clear
02:00000D3E 08B00007A001    	  1150:             bclr.b #7,1(a0,a2.w)      *
02:00000D44 67FE            	  1151:             beq.s *               * branch if Z set
                            	  1152: *             EA = n(An,A.L)  - BYTE only
02:00000D46 08B000009800    	  1153:             bclr.b #0,0(a0,a1.l)
02:00000D4C 66FE            	  1154:             bne.s *               * branch if Z clear
02:00000D4E 08B00000A800    	  1155:             bclr.b #0,0(a0,a2.l)      *
02:00000D54 67FE            	  1156:             beq.s *               * branch if Z set
02:00000D56 08B00001A801    	  1157:             bclr.b #1,1(a0,a2.l)      *
02:00000D5C 66FE            	  1158:             bne.s *               * branch if Z clear
02:00000D5E 307C0100        	  1159:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000D62 0C1800B6        	  1160:             cmpi.b #$B6,(a0)+
02:00000D66 66FE            	  1161:             bne.s *               * branch if Z clear
02:00000D68 0C1800EC        	  1162:             cmpi.b #$EC,(a0)+
02:00000D6C 66FE            	  1163:             bne.s *               * branch if Z clear
02:00000D6E 0C180059        	  1164:             cmpi.b #$59,(a0)+
02:00000D72 67FE            	  1165:             beq.s *               * branch if Z set
                            	  1166: 
                            	  1167: 
                            	  1168: *             EA = x.W  - BYTE only
02:00000D74 307C0100        	  1169:             move.l #$00000100,a0      * point to memory to address
02:00000D78 10FC00FF        	  1170:             move.b #$FF,(a0)+         * populate test data
02:00000D7C 08B800000100    	  1171:             bclr.b #0,$0100
02:00000D82 67FE            	  1172:             beq.s *               * branch if Z set
02:00000D84 08B800010100    	  1173:             bclr.b #1,$0100           *
02:00000D8A 67FE            	  1174:             beq.s *               * branch if Z set
02:00000D8C 307C0100        	  1175:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000D90 0C1800FC        	  1176:             cmpi.b #$FC,(a0)+
02:00000D94 66FE            	  1177:             bne.s *               * branch if Z clear
                            	  1178: 
                            	  1179: 
                            	  1180: *             EA = x.L  - BYTE only
02:00000D96 207C0000F100    	  1181:             move.l #$F100,a0      * point to memory to address 0x100
02:00000D9C 10BC00FF        	  1182:             move.b #$FF,(a0)          * populate test data
02:00000DA0 08B900000000F100	  1183:             bclr.b #0,$F100
02:00000DA8 67FE            	  1184:             beq.s *               * branch if Z set
02:00000DAA 08B900010000F100	  1185:             bclr.b #1,$F100       *
02:00000DB2 67FE            	  1186:             beq.s *               * branch if Z set
02:00000DB4 08B900020000F100	  1187:             bclr.b #2,$F100       *
02:00000DBC 67FE            	  1188:             beq.s *               * branch if Z set
02:00000DBE 207C0000F100    	  1189:             move.l #$F100,a0      * point to memory to address 0x100
02:00000DC4 0C1800F8        	  1190:             cmpi.b #$F8,(a0)+
02:00000DC8 66FE            	  1191:             bne.s *               * branch if Z clear
                            	  1192: 
                            	  1193: 
                            	  1194: * Bit Number.s Dynamic
                            	  1195: 
                            	  1196: *             EA = Dn  - LONG only
02:00000DCA 203CFF00FF00    	  1197:             move.l #$FF00FF00,d0      * populate test data
02:00000DD0 7A00            	  1198:             move.l #0,d5              * populate bit.s number to test
02:00000DD2 7C01            	  1199:             move.l #1,d6              * populate bit.s number to test
02:00000DD4 7E1F            	  1200:             move.l #31,d7              * populate bit.s number to test
                            	  1201: 
02:00000DD6 0B80            	  1202:             bclr.l d5,d0
02:00000DD8 66FE            	  1203:             bne.s *               * branch if Z clear
02:00000DDA 0D80            	  1204:             bclr.l d6,d0              *
02:00000DDC 66FE            	  1205:             bne.s *               * branch if Z clear
02:00000DDE 0F80            	  1206:             bclr.l d7,d0             *
02:00000DE0 67FE            	  1207:             beq.s *               * branch if Z set
02:00000DE2 0C807F00FF00    	  1208:             cmpi.l #$7F00FF00,d0
02:00000DE8 66FE            	  1209:             bne.s *               * branch if Z clear
                            	  1210: 
                            	  1211: 
                            	  1212: *             EA = (An)  - BYTE only
02:00000DEA 7A00            	  1213:             move.l #0,d5              * populate bit.s number to test
02:00000DEC 7C01            	  1214:             move.l #1,d6              * populate bit.s number to test
02:00000DEE 7E07            	  1215:             move.l #7,d7              * populate bit.s number to test
02:00000DF0 307C0100        	  1216:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000DF4 10BC0081        	  1217:             move.b #$81,(a0)          * populate test data
02:00000DF8 0B90            	  1218:             bclr.b d5,(a0)
02:00000DFA 67FE            	  1219:             beq.s *               * branch if Z set
02:00000DFC 0D90            	  1220:             bclr.b d6,(a0)            *
02:00000DFE 66FE            	  1221:             bne.s *               * branch if Z clear
02:00000E00 0F90            	  1222:             bclr.b d7,(a0)            *
02:00000E02 67FE            	  1223:             beq.s *               * branch if Z set
02:00000E04 4A10            	  1224:             cmpi.b #$00,(a0)
02:00000E06 66FE            	  1225:             bne.s *               * branch if Z clear
                            	  1226: 
                            	  1227: 
                            	  1228: *             EA = (An)+  - BYTE only
02:00000E08 307C0100        	  1229:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000E0C 10FC0001        	  1230:             move.b #$01,(a0)+         * populate test data
02:00000E10 10FC00FC        	  1231:             move.b #$FC,(a0)+         * populate test data
02:00000E14 10FC0080        	  1232:             move.b #$80,(a0)+         * populate test data
02:00000E18 307C0100        	  1233:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000E1C 0B98            	  1234:             bclr.b d5,(a0)+
02:00000E1E 67FE            	  1235:             beq.s *               * branch if Z set
02:00000E20 0D98            	  1236:             bclr.b d6,(a0)+           *
02:00000E22 66FE            	  1237:             bne.s *               * branch if Z clear
02:00000E24 0F98            	  1238:             bclr.b d7,(a0)+           *
02:00000E26 67FE            	  1239:             beq.s *               * branch if Z set
02:00000E28 307C0100        	  1240:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000E2C 4A18            	  1241:             cmpi.b #$00,(a0)+
02:00000E2E 66FE            	  1242:             bne.s *               * branch if Z clear
02:00000E30 0C1800FC        	  1243:             cmpi.b #$FC,(a0)+
02:00000E34 66FE            	  1244:             bne.s *               * branch if Z clear
02:00000E36 4A18            	  1245:             cmpi.b #$00,(a0)+
02:00000E38 66FE            	  1246:             bne.s *               * branch if Z clear
                            	  1247: 
                            	  1248: *             EA = -(An)  - BYTE only
02:00000E3A 307C0100        	  1249:             move.l #$00000100,a0      * point to memory to address
02:00000E3E 10FC0080        	  1250:             move.b #$80,(a0)+         * populate test data
02:00000E42 10FC00FC        	  1251:             move.b #$FC,(a0)+         * populate test data
02:00000E46 10FC0001        	  1252:             move.b #$01,(a0)+         * populate test data
02:00000E4A 307C0103        	  1253:             move.l #$00000103,a0      * point to memory to address
02:00000E4E 0BA0            	  1254:             bclr.b d5,-(a0)
02:00000E50 67FE            	  1255:             beq.s *               * branch if Z set
02:00000E52 0DA0            	  1256:             bclr.b d6,-(a0)           *
02:00000E54 66FE            	  1257:             bne.s *               * branch if Z clear
02:00000E56 0FA0            	  1258:             bclr.b d7,-(a0)           *
02:00000E58 67FE            	  1259:             beq.s *               * branch if Z set
02:00000E5A 307C0103        	  1260:             move.l #$00000103,a0      * point to memory to address 0x100
02:00000E5E 4A20            	  1261:             cmpi.b #$00,-(a0)
02:00000E60 66FE            	  1262:             bne.s *               * branch if Z clear
02:00000E62 0C2000FC        	  1263:             cmpi.b #$FC,-(a0)
02:00000E66 66FE            	  1264:             bne.s *               * branch if Z clear
02:00000E68 4A20            	  1265:             cmpi.b #$00,-(a0)
02:00000E6A 66FE            	  1266:             bne.s *               * branch if Z clear
                            	  1267: 
                            	  1268: *             EA = n(An)  - BYTE only
02:00000E6C 307C0100        	  1269:             move.l #$00000100,a0      * point to memory to address
02:00000E70 10FC0001        	  1270:             move.b #$01,(a0)+         * populate test data
02:00000E74 10FC00FC        	  1271:             move.b #$FC,(a0)+         * populate test data
02:00000E78 10FC0080        	  1272:             move.b #$80,(a0)+         * populate test data
02:00000E7C 307C0100        	  1273:             move.l #$00000100,a0      * point to memory to address
02:00000E80 0B90            	  1274:             bclr.b d5,0(a0)
02:00000E82 67FE            	  1275:             beq.s *               * branch if Z set
02:00000E84 0DA80001        	  1276:             bclr.b d6,1(a0)           *
02:00000E88 66FE            	  1277:             bne.s *               * branch if Z clear
02:00000E8A 0FA80002        	  1278:             bclr.b d7,2(a0)           *
02:00000E8E 67FE            	  1279:             beq.s *               * branch if Z set
02:00000E90 307C0100        	  1280:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000E94 4A18            	  1281:             cmpi.b #$00,(a0)+
02:00000E96 66FE            	  1282:             bne.s *               * branch if Z clear
02:00000E98 0C1800FC        	  1283:             cmpi.b #$FC,(a0)+
02:00000E9C 66FE            	  1284:             bne.s *               * branch if Z clear
02:00000E9E 4A18            	  1285:             cmpi.b #$00,(a0)+
02:00000EA0 66FE            	  1286:             bne.s *               * branch if Z clear
                            	  1287: 
                            	  1288: *             EA = n(An,R.W)  - BYTE only
02:00000EA2 307C0100        	  1289:             move.l #$00000100,a0      * point to memory to address
02:00000EA6 10FC00FF        	  1290:             move.b #$FF,(a0)+         * populate test data
02:00000EAA 10FC00FF        	  1291:             move.b #$FF,(a0)+         * populate test data
02:00000EAE 10FC00FF        	  1292:             move.b #$FF,(a0)+         * populate test data
02:00000EB2 307C0103        	  1293:             move.l #$00000103,a0      * point to memory to address
02:00000EB6 307C0100        	  1294:             move.l #$00000100,a0      * point to memory to address
02:00000EBA 93C9            	  1295:             move.l #$00000000,a1      * point to memory to address
02:00000EBC 347C0001        	  1296:             move.l #$00000001,a2      * point to memory to address
02:00000EC0 7000            	  1297:             moveq  #$00000000,d0      * point to memory to address
02:00000EC2 7201            	  1298:             moveq  #$00000001,d1      * point to memory to address
02:00000EC4 0BB00000        	  1299:             bclr.b d5,0(a0,d0.w)
02:00000EC8 67FE            	  1300:             beq.s *               * branch if Z set
02:00000ECA 0DB01000        	  1301:             bclr.b d6,0(a0,d1.w)      *
02:00000ECE 67FE            	  1302:             beq.s *               * branch if Z set
02:00000ED0 0FB01001        	  1303:             bclr.b d7,1(a0,d1.w)      *
02:00000ED4 67FE            	  1304:             beq.s *               * branch if Z set
                            	  1305: *             EA = n(An,R.L)  - BYTE only
02:00000ED6 0BB00800        	  1306:             bclr.b d5,0(a0,d0.l)
02:00000EDA 66FE            	  1307:             bne.s *               * branch if Z clear
02:00000EDC 0DB01800        	  1308:             bclr.b d6,0(a0,d1.l)      *
02:00000EE0 66FE            	  1309:             bne.s *               * branch if Z clear
02:00000EE2 0FB01801        	  1310:             bclr.b d7,1(a0,d1.l)      *
02:00000EE6 66FE            	  1311:             bne.s *               * branch if Z clear
                            	  1312: *             EA = n(An,A.W)  - BYTE only
02:00000EE8 0BB09000        	  1313:             bclr.b d5,0(a0,a1.w)
02:00000EEC 66FE            	  1314:             bne.s *               * branch if Z clear
02:00000EEE 0DB0A000        	  1315:             bclr.b d6,0(a0,a2.w)      *
02:00000EF2 66FE            	  1316:             bne.s *               * branch if Z clear
02:00000EF4 0FB0A001        	  1317:             bclr.b d7,1(a0,a2.w)      *
02:00000EF8 66FE            	  1318:             bne.s *               * branch if Z clear
                            	  1319: *             EA = n(An,A.L)  - BYTE only
02:00000EFA 0BB09800        	  1320:             bclr.b d5,0(a0,a1.l)
02:00000EFE 66FE            	  1321:             bne.s *               * branch if Z clear
02:00000F00 0DB0A800        	  1322:             bclr.b d6,0(a0,a2.l)      *
02:00000F04 66FE            	  1323:             bne.s *               * branch if Z clear
02:00000F06 0FB0A801        	  1324:             bclr.b d7,1(a0,a2.l)      *
02:00000F0A 66FE            	  1325:             bne.s *               * branch if Z clear
02:00000F0C 307C0100        	  1326:             move.l #$00000100,a0      * point to memory to address
02:00000F10 0C1000FE        	  1327:             cmpi.b #$FE,(a0)
02:00000F14 66FE            	  1328:             bne.s *               * branch if Z clear
                            	  1329: 
                            	  1330: *             EA = x.W  - BYTE only
02:00000F16 307C0100        	  1331:             move.l #$00000100,a0      * point to memory to address
02:00000F1A 10FC00FF        	  1332:             move.b #$FF,(a0)+         * populate test data
02:00000F1E 10FC00FF        	  1333:             move.b #$FF,(a0)+         * populate test data
02:00000F22 10FC00FF        	  1334:             move.b #$FF,(a0)+         * populate test data
02:00000F26 0BB80100        	  1335:             bclr.b d5,$0100
02:00000F2A 67FE            	  1336:             beq.s *               * branch if Z set
02:00000F2C 0DB80101        	  1337:             bclr.b d6,$0101           *
02:00000F30 67FE            	  1338:             beq.s *               * branch if Z set
02:00000F32 0FB80102        	  1339:             bclr.b d7,$0102           *
02:00000F36 67FE            	  1340:             beq.s *               * branch if Z set
02:00000F38 307C0100        	  1341:             move.l #$00000100,a0      * point to memory to address
02:00000F3C 0C1800FE        	  1342:             cmpi.b #$FE,(a0)+
02:00000F40 66FE            	  1343:             bne.s *               * branch if Z clear
                            	  1344: 
                            	  1345: *             EA = x.L  - BYTE only
02:00000F42 207C0000F100    	  1346:             move.l #$F100,a0      * point to memory to address 0x100
02:00000F48 10FC0001        	  1347:             move.b #$01,(a0)+         * populate test data
02:00000F4C 10FC00FC        	  1348:             move.b #$FC,(a0)+         * populate test data
02:00000F50 10FC0080        	  1349:             move.b #$80,(a0)+         * populate test data
02:00000F54 0BB90000F100    	  1350:             bclr.b d5,$F100
02:00000F5A 67FE            	  1351:             beq.s *               * branch if Z set
02:00000F5C 0DB90000F101    	  1352:             bclr.b d6,$F101       *
02:00000F62 66FE            	  1353:             bne.s *               * branch if Z clear
02:00000F64 0FB90000F102    	  1354:             bclr.b d7,$F102       *
02:00000F6A 67FE            	  1355:             beq.s *               * branch if Z set
02:00000F6C 207C0000F101    	  1356:             move.l #$F101,a0      * point to memory to address 0x100
02:00000F72 0C1000FC        	  1357:             cmpi.b #$FC,(a0)
02:00000F76 66FE            	  1358:             bne.s *               * branch if Z clear
                            	  1359: 
                            	  1360: 
                            	  1361: 
02:00000F78 4E75            	  1362:     rts
                            	  1363: 
                            	  1364: *-----------------------------------------------------------
                            	  1365: *-----------------------------------------------------------
                            	  1366: * OPCODE : BSET
                            	  1367: *-----------------------------------------------------------
                            	  1368: *-----------------------------------------------------------
                            	  1369: op_BSET:
                            	  1370: 
                            	  1371: 
                            	  1372: *  Bit Number.s Static
                            	  1373: 
                            	  1374: *             EA = Dn  - LONG only
02:00000F7A 7000            	  1375:             moveq  #$00000000,d0      * populate test data
02:00000F7C 08C00000        	  1376:             bset.l #0,d0
02:00000F80 66FE            	  1377:             bne.s *               * branch if Z clear
02:00000F82 08C00001        	  1378:             bset.l #1,d0              *
02:00000F86 66FE            	  1379:             bne.s *               * branch if Z clear
02:00000F88 08C0000F        	  1380:             bset.l #15,d0             *
02:00000F8C 66FE            	  1381:             bne.s *               * branch if Z clear
02:00000F8E 08C0001F        	  1382:             bset.l #31,d0             *
02:00000F92 66FE            	  1383:             bne.s *               * branch if Z clear
02:00000F94 0C8080008003    	  1384:             cmpi.l #$80008003,d0
02:00000F9A 66FE            	  1385:             bne.s *               * branch if Z clear
                            	  1386: 
                            	  1387: 
                            	  1388: *             EA = (An)  - BYTE only
02:00000F9C 307C0100        	  1389:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000FA0 4210            	  1390:             move.b #$00,(a0)          * populate test data
02:00000FA2 08D00000        	  1391:             bset.b #0,(a0)
02:00000FA6 66FE            	  1392:             bne.s *               * branch if Z clear
02:00000FA8 08D00007        	  1393:             bset.b #7,(a0)            *
02:00000FAC 66FE            	  1394:             bne.s *               * branch if Z clear
02:00000FAE 0C100081        	  1395:             cmpi.b #$81,(a0)
02:00000FB2 66FE            	  1396:             bne.s *               * branch if Z clear
                            	  1397: 
                            	  1398: *             EA = (An)+  - BYTE only
02:00000FB4 307C0100        	  1399:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000FB8 4218            	  1400:             move.b #$00,(a0)+         * populate test data
02:00000FBA 4218            	  1401:             move.b #$00,(a0)+         * populate test data
02:00000FBC 307C0100        	  1402:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000FC0 08D80000        	  1403:             bset.b #0,(a0)+
02:00000FC4 66FE            	  1404:             bne.s *               * branch if Z clear
02:00000FC6 08D80001        	  1405:             bset.b #1,(a0)+           *
02:00000FCA 66FE            	  1406:             bne.s *               * branch if Z clear
02:00000FCC 307C0100        	  1407:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000FD0 0C180001        	  1408:             cmpi.b #$01,(a0)+
02:00000FD4 66FE            	  1409:             bne.s *               * branch if Z clear
02:00000FD6 0C180002        	  1410:             cmpi.b #$02,(a0)+
02:00000FDA 66FE            	  1411:             bne.s *               * branch if Z clear
                            	  1412: 
                            	  1413: 
                            	  1414: *             EA = -(An)  - BYTE only
02:00000FDC 307C0100        	  1415:             move.l #$00000100,a0      * point to memory to address
02:00000FE0 4218            	  1416:             move.b #$00,(a0)+         * populate test data
02:00000FE2 4218            	  1417:             move.b #$00,(a0)+         * populate test data
02:00000FE4 08E00007        	  1418:             bset.b #7,-(a0)
02:00000FE8 66FE            	  1419:             bne.s *               * branch if Z clear
02:00000FEA 08E00000        	  1420:             bset.b #0,-(a0)           *
02:00000FEE 66FE            	  1421:             bne.s *               * branch if Z clear
02:00000FF0 307C0102        	  1422:             move.l #$00000102,a0      * point to memory to address 0x100
02:00000FF4 0C200080        	  1423:             cmpi.b #$80,-(a0)
02:00000FF8 66FE            	  1424:             bne.s *               * branch if Z clear
02:00000FFA 0C200001        	  1425:             cmpi.b #$01,-(a0)
02:00000FFE 66FE            	  1426:             bne.s *               * branch if Z clear
                            	  1427: 
                            	  1428: 
                            	  1429: *             EA = n(An)  - BYTE only
02:00001000 307C0100        	  1430:             move.l #$00000100,a0      * point to memory to address
02:00001004 4218            	  1431:             move.b #$00,(a0)+         * populate test data
02:00001006 4218            	  1432:             move.b #$00,(a0)+         * populate test data
02:00001008 307C0100        	  1433:             move.l #$00000100,a0      * point to memory to address
02:0000100C 08D00000        	  1434:             bset.b #0,0(a0)
02:00001010 66FE            	  1435:             bne.s *               * branch if Z clear
02:00001012 08E800040001    	  1436:             bset.b #4,1(a0)           *
02:00001018 66FE            	  1437:             bne.s *               * branch if Z clear
02:0000101A 307C0100        	  1438:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000101E 0C180001        	  1439:             cmpi.b #$01,(a0)+
02:00001022 66FE            	  1440:             bne.s *               * branch if Z clear
02:00001024 0C180010        	  1441:             cmpi.b #$10,(a0)+
02:00001028 66FE            	  1442:             bne.s *               * branch if Z clear
                            	  1443: 
                            	  1444: 
                            	  1445: *             EA = n(An,D.W)  - BYTE only
02:0000102A 307C0100        	  1446:             move.l #$00000100,a0      * point to memory to address
02:0000102E 93C9            	  1447:             move.l #$00000000,a1      * point to memory to address
02:00001030 347C0004        	  1448:             move.l #$00000004,a2      * point to memory to address
02:00001034 7000            	  1449:             moveq  #$00000000,d0      * point to memory to address
02:00001036 7201            	  1450:             moveq  #$00000001,d1      * point to memory to address
02:00001038 4218            	  1451:             move.b #$00,(a0)+         * populate test data
02:0000103A 4218            	  1452:             move.b #$00,(a0)+         * populate test data
02:0000103C 4218            	  1453:             move.b #$00,(a0)+         * populate test data
02:0000103E 4218            	  1454:             move.b #$00,(a0)+         * populate test data
02:00001040 4218            	  1455:             move.b #$00,(a0)+         * populate test data
02:00001042 4218            	  1456:             move.b #$00,(a0)+         * populate test data
02:00001044 4218            	  1457:             move.b #$00,(a0)+         * populate test data
02:00001046 4218            	  1458:             move.b #$00,(a0)+         * populate test data
02:00001048 4218            	  1459:             move.b #$00,(a0)+         * populate test data
02:0000104A 4218            	  1460:             move.b #$00,(a0)+         * populate test data
02:0000104C 307C0100        	  1461:             move.l #$00000100,a0      * point to memory to address
02:00001050 08F000000000    	  1462:             bset.b #0,0(a0,d0.w)
02:00001056 66FE            	  1463:             bne.s *               * branch if Z clear
02:00001058 08F000011000    	  1464:             bset.b #1,0(a0,d1.w)      *
02:0000105E 66FE            	  1465:             bne.s *               * branch if Z clear
02:00001060 08F000021001    	  1466:             bset.b #2,1(a0,d1.w)      *
02:00001066 66FE            	  1467:             bne.s *               * branch if Z clear
                            	  1468: *             EA = n(An,D.L)  - BYTE only
02:00001068 08F000030802    	  1469:             bset.b #3,2(a0,d0.l)
02:0000106E 66FE            	  1470:             bne.s *               * branch if Z clear
02:00001070 08F000041800    	  1471:             bset.b #4,0(a0,d1.l)      *
02:00001076 66FE            	  1472:             bne.s *               * branch if Z clear
02:00001078 08F000051801    	  1473:             bset.b #5,1(a0,d1.l)      *
02:0000107E 66FE            	  1474:             bne.s *               * branch if Z clear
                            	  1475: *             EA = n(An,A.W)  - BYTE only
02:00001080 08F000069000    	  1476:             bset.b #6,0(a0,a1.w)
02:00001086 66FE            	  1477:             bne.s *               * branch if Z clear
02:00001088 08F00001A000    	  1478:             bset.b #1,0(a0,a2.w)      *
02:0000108E 66FE            	  1479:             bne.s *               * branch if Z clear
02:00001090 08F00007A001    	  1480:             bset.b #7,1(a0,a2.w)      *
02:00001096 66FE            	  1481:             bne.s *               * branch if Z clear
                            	  1482: *             EA = n(An,A.L)  - BYTE only
02:00001098 08F00000A802    	  1483:             bset.b #0,2(a0,a2.l)
02:0000109E 66FE            	  1484:             bne.s *               * branch if Z clear
02:000010A0 08F00000A803    	  1485:             bset.b #0,3(a0,a2.l)      *
02:000010A6 66FE            	  1486:             bne.s *               * branch if Z clear
02:000010A8 08F00001A804    	  1487:             bset.b #1,4(a0,a2.l)      *
02:000010AE 66FE            	  1488:             bne.s *               * branch if Z clear
02:000010B0 307C0100        	  1489:             move.l #$00000100,a0      * point to memory to address 0x100
02:000010B4 0C9841122C00    	  1490:             cmpi.l #$41122C00,(a0)+
02:000010BA 66FE            	  1491:             bne.s *               * branch if Z clear
02:000010BC 0C9802800101    	  1492:             cmpi.l #$02800101,(a0)+
02:000010C2 66FE            	  1493:             bne.s *
                            	  1494: 
                            	  1495: 
                            	  1496: 
                            	  1497: *             EA = x.W  - BYTE only
02:000010C4 307C0100        	  1498:             move.l #$00000100,a0      * point to memory to address
02:000010C8 4218            	  1499:             move.b #$00,(a0)+         * populate test data
02:000010CA 08F800000100    	  1500:             bset.b #0,$0100
02:000010D0 66FE            	  1501:             bne.s *               * branch if Z clear
02:000010D2 08F800010100    	  1502:             bset.b #1,$0100           *
02:000010D8 66FE            	  1503:             bne.s *               * branch if Z clear
02:000010DA 307C0100        	  1504:             move.l #$00000100,a0      * point to memory to address 0x100
02:000010DE 0C180003        	  1505:             cmpi.b #$03,(a0)+
02:000010E2 66FE            	  1506:             bne.s *
                            	  1507: 
                            	  1508: 
                            	  1509: *             EA = x.L  - BYTE only
02:000010E4 207C0000F100    	  1510:             move.l #$F100,a0      * point to memory to address 0x100
02:000010EA 4210            	  1511:             move.b #$00,(a0)          * populate test data
02:000010EC 08F900000000F100	  1512:             bset.b #0,$F100
02:000010F4 66FE            	  1513:             bne.s *               * branch if Z clear
02:000010F6 08F900010000F100	  1514:             bset.b #1,$F100       *
02:000010FE 66FE            	  1515:             bne.s *               * branch if Z clear
02:00001100 08F900020000F100	  1516:             bset.b #2,$F100       *
02:00001108 66FE            	  1517:             bne.s *               * branch if Z clear
02:0000110A 207C0000F100    	  1518:             move.l #$F100,a0      * point to memory to address 0x100
02:00001110 0C180007        	  1519:             cmpi.b #$07,(a0)+
02:00001114 66FE            	  1520:             bne.s *
                            	  1521: 
                            	  1522: 
                            	  1523: * Bit Number.s Dynamic
                            	  1524: 
                            	  1525: *             EA = Dn  - LONG only
02:00001116 7000            	  1526:             moveq  #$00000000,d0      * populate test data
02:00001118 7A00            	  1527:             move.l #0,d5              * populate bit.s number to test
02:0000111A 7C01            	  1528:             move.l #1,d6              * populate bit.s number to test
02:0000111C 7E1F            	  1529:             move.l #31,d7              * populate bit.s number to test
                            	  1530: 
02:0000111E 0BC0            	  1531:             bset.l d5,d0
02:00001120 66FE            	  1532:             bne.s *               * branch if Z clear
02:00001122 0DC0            	  1533:             bset.l d6,d0              *
02:00001124 66FE            	  1534:             bne.s *               * branch if Z clear
02:00001126 0FC0            	  1535:             bset.l d7,d0             *
02:00001128 66FE            	  1536:             bne.s *               * branch if Z clear
02:0000112A 0C8080000003    	  1537:             cmpi.l #$80000003,d0
02:00001130 66FE            	  1538:             bne.s *               * branch if Z clear
                            	  1539: 
                            	  1540: 
                            	  1541: *             EA = (An)  - BYTE only
02:00001132 7A00            	  1542:             move.l #0,d5              * populate bit.s number to test
02:00001134 7C01            	  1543:             move.l #1,d6              * populate bit.s number to test
02:00001136 7E07            	  1544:             move.l #7,d7              * populate bit.s number to test
02:00001138 307C0100        	  1545:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000113C 4210            	  1546:             move.b #$00,(a0)          * populate test data
02:0000113E 0BD0            	  1547:             bset.b d5,(a0)
02:00001140 66FE            	  1548:             bne.s *               * branch if Z clear
02:00001142 0DD0            	  1549:             bset.b d6,(a0)            *
02:00001144 66FE            	  1550:             bne.s *               * branch if Z clear
02:00001146 0FD0            	  1551:             bset.b d7,(a0)            *
02:00001148 66FE            	  1552:             bne.s *               * branch if Z clear
02:0000114A 0C100083        	  1553:             cmpi.b #$83,(a0)
02:0000114E 66FE            	  1554:             bne.s *               * branch if Z clear
                            	  1555: 
                            	  1556: 
                            	  1557: *             EA = (An)+  - BYTE only
02:00001150 307C0100        	  1558:             move.l #$00000100,a0      * point to memory to address 0x100
02:00001154 4218            	  1559:             move.b #$00,(a0)+         * populate test data
02:00001156 4218            	  1560:             move.b #$00,(a0)+         * populate test data
02:00001158 4218            	  1561:             move.b #$00,(a0)+         * populate test data
02:0000115A 307C0100        	  1562:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000115E 0BD8            	  1563:             bset.b d5,(a0)+
02:00001160 66FE            	  1564:             bne.s *               * branch if Z clear
02:00001162 0DD8            	  1565:             bset.b d6,(a0)+           *
02:00001164 66FE            	  1566:             bne.s *               * branch if Z clear
02:00001166 0FD8            	  1567:             bset.b d7,(a0)+           *
02:00001168 66FE            	  1568:             bne.s *               * branch if Z clear
02:0000116A 307C0100        	  1569:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000116E 0C180001        	  1570:             cmpi.b #$01,(a0)+
02:00001172 66FE            	  1571:             bne.s *               * branch if Z clear
02:00001174 0C180002        	  1572:             cmpi.b #$02,(a0)+
02:00001178 66FE            	  1573:             bne.s *               * branch if Z clear
02:0000117A 0C180080        	  1574:             cmpi.b #$80,(a0)+
02:0000117E 66FE            	  1575:             bne.s *               * branch if Z clear
                            	  1576: 
                            	  1577: *             EA = -(An)  - BYTE only
02:00001180 307C0100        	  1578:             move.l #$00000100,a0      * point to memory to address
02:00001184 4218            	  1579:             move.b #$00,(a0)+         * populate test data
02:00001186 4218            	  1580:             move.b #$00,(a0)+         * populate test data
02:00001188 4218            	  1581:             move.b #$00,(a0)+         * populate test data
02:0000118A 307C0103        	  1582:             move.l #$00000103,a0      * point to memory to address
02:0000118E 0BE0            	  1583:             bset.b d5,-(a0)
02:00001190 66FE            	  1584:             bne.s *               * branch if Z clear
02:00001192 0DE0            	  1585:             bset.b d6,-(a0)           *
02:00001194 66FE            	  1586:             bne.s *               * branch if Z clear
02:00001196 0FE0            	  1587:             bset.b d7,-(a0)           *
02:00001198 66FE            	  1588:             bne.s *               * branch if Z clear
02:0000119A 307C0103        	  1589:             move.l #$00000103,a0      * point to memory to address 0x100
02:0000119E 0C200001        	  1590:             cmpi.b #$01,-(a0)
02:000011A2 66FE            	  1591:             bne.s *               * branch if Z clear
02:000011A4 0C200002        	  1592:             cmpi.b #$02,-(a0)
02:000011A8 66FE            	  1593:             bne.s *               * branch if Z clear
02:000011AA 0C200080        	  1594:             cmpi.b #$80,-(a0)
02:000011AE 66FE            	  1595:             bne.s *               * branch if Z clear
                            	  1596: 
                            	  1597: *             EA = n(An)  - BYTE only
02:000011B0 307C0100        	  1598:             move.l #$00000100,a0      * point to memory to address
02:000011B4 4218            	  1599:             move.b #$00,(a0)+         * populate test data
02:000011B6 4218            	  1600:             move.b #$00,(a0)+         * populate test data
02:000011B8 4218            	  1601:             move.b #$00,(a0)+         * populate test data
02:000011BA 307C0100        	  1602:             move.l #$00000100,a0      * point to memory to address
02:000011BE 0BD0            	  1603:             bset.b d5,0(a0)
02:000011C0 66FE            	  1604:             bne.s *               * branch if Z clear
02:000011C2 0DE80001        	  1605:             bset.b d6,1(a0)           *
02:000011C6 66FE            	  1606:             bne.s *               * branch if Z clear
02:000011C8 0FE80002        	  1607:             bset.b d7,2(a0)           *
02:000011CC 66FE            	  1608:             bne.s *               * branch if Z clear
02:000011CE 307C0100        	  1609:             move.l #$00000100,a0      * point to memory to address 0x100
02:000011D2 0C180001        	  1610:             cmpi.b #$01,(a0)+
02:000011D6 66FE            	  1611:             bne.s *               * branch if Z clear
02:000011D8 0C180002        	  1612:             cmpi.b #$02,(a0)+
02:000011DC 66FE            	  1613:             bne.s *               * branch if Z clear
02:000011DE 0C180080        	  1614:             cmpi.b #$80,(a0)+
02:000011E2 66FE            	  1615:             bne.s *               * branch if Z clear
                            	  1616: 
                            	  1617: *             EA = n(An,R.W)  - BYTE only
02:000011E4 307C0100        	  1618:             move.l #$00000100,a0      * point to memory to address
02:000011E8 4218            	  1619:             move.b #$00,(a0)+         * populate test data
02:000011EA 4218            	  1620:             move.b #$00,(a0)+         * populate test data
02:000011EC 4218            	  1621:             move.b #$00,(a0)+         * populate test data
02:000011EE 4218            	  1622:             move.b #$00,(a0)+         * populate test data
02:000011F0 4218            	  1623:             move.b #$00,(a0)+         * populate test data
02:000011F2 4218            	  1624:             move.b #$00,(a0)+         * populate test data
02:000011F4 4218            	  1625:             move.b #$00,(a0)+         * populate test data
02:000011F6 4218            	  1626:             move.b #$00,(a0)+         * populate test data
02:000011F8 4218            	  1627:             move.b #$00,(a0)+         * populate test data
02:000011FA 4218            	  1628:             move.b #$00,(a0)+         * populate test data
02:000011FC 4218            	  1629:             move.b #$00,(a0)+         * populate test data
02:000011FE 4218            	  1630:             move.b #$00,(a0)+         * populate test data
02:00001200 307C0100        	  1631:             move.l #$00000100,a0      * point to memory to address
02:00001204 93C9            	  1632:             move.l #$00000000,a1      * point to memory to address
02:00001206 347C0001        	  1633:             move.l #$00000001,a2      * point to memory to address
02:0000120A 7000            	  1634:             moveq  #$00000000,d0      * point to memory to address
02:0000120C 7201            	  1635:             moveq  #$00000001,d1      * point to memory to address
02:0000120E 0BF00000        	  1636:             bset.b d5,0(a0,d0.w)
02:00001212 66FE            	  1637:             bne.s *               * branch if Z clear
02:00001214 0DF01000        	  1638:             bset.b d6,0(a0,d1.w)      *
02:00001218 66FE            	  1639:             bne.s *               * branch if Z clear
02:0000121A 0FF01001        	  1640:             bset.b d7,1(a0,d1.w)      *
02:0000121E 66FE            	  1641:             bne.s *               * branch if Z clear
                            	  1642: *             EA = n(An,R.L)  - BYTE only
02:00001220 0BF00802        	  1643:             bset.b d5,2(a0,d0.l)
02:00001224 66FE            	  1644:             bne.s *               * branch if Z clear
02:00001226 0DF01803        	  1645:             bset.b d6,3(a0,d1.l)      *
02:0000122A 66FE            	  1646:             bne.s *               * branch if Z clear
02:0000122C 0FF01804        	  1647:             bset.b d7,4(a0,d1.l)      *
02:00001230 66FE            	  1648:             bne.s *               * branch if Z clear
                            	  1649: *             EA = n(An,A.W)  - BYTE only
02:00001232 0BF09005        	  1650:             bset.b d5,5(a0,a1.w)
02:00001236 66FE            	  1651:             bne.s *               * branch if Z clear
02:00001238 0DF0A006        	  1652:             bset.b d6,6(a0,a2.w)      *
02:0000123C 66FE            	  1653:             bne.s *               * branch if Z clear
02:0000123E 0FF0A007        	  1654:             bset.b d7,7(a0,a2.w)      *
02:00001242 66FE            	  1655:             bne.s *               * branch if Z clear
                            	  1656: *             EA = n(An,A.L)  - BYTE only
02:00001244 0BF09808        	  1657:             bset.b d5,8(a0,a1.l)
02:00001248 66FE            	  1658:             bne.s *               * branch if Z clear
02:0000124A 0DF0A809        	  1659:             bset.b d6,9(a0,a2.l)      *
02:0000124E 66FE            	  1660:             bne.s *               * branch if Z clear
02:00001250 0FF0A80A        	  1661:             bset.b d7,10(a0,a2.l)      *
02:00001254 66FE            	  1662:             bne.s *               * branch if Z clear
02:00001256 307C0100        	  1663:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000125A 0C9801028100    	  1664:             cmpi.l #$01028100,(a0)+
02:00001260 66FE            	  1665:             bne.s *               * branch if Z clear
02:00001262 0C9802810002    	  1666:             cmpi.l #$02810002,(a0)+
02:00001268 66FE            	  1667:             bne.s *
                            	  1668: 
                            	  1669: 
                            	  1670: *             EA = x.W  - BYTE only
02:0000126A 307C0100        	  1671:             move.l #$00000100,a0      * point to memory to address
02:0000126E 4218            	  1672:             move.b #$00,(a0)+         * populate test data
02:00001270 4218            	  1673:             move.b #$00,(a0)+         * populate test data
02:00001272 4218            	  1674:             move.b #$00,(a0)+         * populate test data
02:00001274 0BF80100        	  1675:             bset.b d5,$0100
02:00001278 66FE            	  1676:             bne.s *               * branch if Z clear
02:0000127A 0DF80100        	  1677:             bset.b d6,$0100           *
02:0000127E 66FE            	  1678:             bne.s *               * branch if Z clear
02:00001280 0FF80100        	  1679:             bset.b d7,$0100           *
02:00001284 66FE            	  1680:             bne.s *               * branch if Z clear
02:00001286 307C0100        	  1681:             move.l #$00000100,a0      * point to memory to address
02:0000128A 0C180083        	  1682:             cmpi.b #$83,(a0)+
02:0000128E 66FE            	  1683:             bne.s *               * branch if Z clear
                            	  1684: 
                            	  1685: *             EA = x.L  - BYTE only
02:00001290 207C0000F100    	  1686:             move.l #$F100,a0      * point to memory to address 0x100
02:00001296 4218            	  1687:             move.b #$00,(a0)+         * populate test data
02:00001298 4218            	  1688:             move.b #$00,(a0)+         * populate test data
02:0000129A 4218            	  1689:             move.b #$00,(a0)+         * populate test data
02:0000129C 0BF90000F100    	  1690:             bset.b d5,$F100
02:000012A2 66FE            	  1691:             bne.s *               * branch if Z clear
02:000012A4 0DF90000F100    	  1692:             bset.b d6,$F100       *
02:000012AA 66FE            	  1693:             bne.s *               * branch if Z clear
02:000012AC 0FF90000F100    	  1694:             bset.b d7,$F100       *
02:000012B2 66FE            	  1695:             bne.s *               * branch if Z clear
02:000012B4 207C0000F100    	  1696:             move.l #$F100,a0      * point to memory to address 0x100
02:000012BA 0C100083        	  1697:             cmpi.b #$83,(a0)
02:000012BE 66FE            	  1698:             bne.s *               * branch if Z clear
                            	  1699: 
                            	  1700: 
02:000012C0 4E75            	  1701:     rts
                            	  1702: 
                            	  1703: *-----------------------------------------------------------
                            	  1704: *-----------------------------------------------------------
                            	  1705: * OPCODE : MOVEP
                            	  1706: *-----------------------------------------------------------
                            	  1707: *-----------------------------------------------------------
                            	  1708: op_MOVEP:
                            	  1709: 
                            	  1710: * Dn --> x(An)
02:000012C2 307C0100        	  1711:             move.l #$00000100,a0
02:000012C6 203C12345678    	  1712:             move.l #$12345678,d0
02:000012CC 223CAABBCCDD    	  1713:             move.l #$AABBCCDD,d1
02:000012D2 4290            	  1714:             move.l #0,(a0)
02:000012D4 42A80004        	  1715:             move.l #0,4(a0)
                            	  1716: 
02:000012D8 01880000        	  1717:             movep.w d0,0(a0)      * even offset
02:000012DC 03880001        	  1718:             movep.w d1,1(a0)      * odd offset
                            	  1719: 
02:000012E0 01C80004        	  1720:             movep.l d0,4(a0)      * even offset
02:000012E4 03C80005        	  1721:             movep.l d1,5(a0)      * odd offset
                            	  1722: 
02:000012E8 0C9056CC78DD    	  1723:             cmpi.l #$56CC78DD,(a0)
02:000012EE 66FE            	  1724:             bne.s *
02:000012F0 0CA812AA34BB0004	  1725:             cmpi.l #$12AA34BB,4(a0)
02:000012F8 66FE            	  1726:             bne.s *
02:000012FA 0CA856CC78DD0008	  1727:             cmpi.l #$56CC78DD,8(a0)
02:00001302 66FE            	  1728:             bne.s *
                            	  1729: 
                            	  1730: 
                            	  1731: * x(An)--> Dn
02:00001304 203C5A5A5A5A    	  1732:             move.l #$5a5a5a5a,d0
02:0000130A 223C5A5A5A5A    	  1733:             move.l #$5a5a5a5a,d1
02:00001310 243C5A5A5A5A    	  1734:             move.l #$5a5a5a5a,d2
02:00001316 263C5A5A5A5A    	  1735:             move.l #$5a5a5a5a,d3
                            	  1736: 
02:0000131C 01080000        	  1737:             movep.w 0(a0),d0      * even offset
02:00001320 03080001        	  1738:             movep.w 1(a0),d1      * odd offset
                            	  1739: 
02:00001324 05480004        	  1740:             movep.l 4(a0),d2      * even offset
02:00001328 07480005        	  1741:             movep.l 5(a0),d3      * odd offset
                            	  1742: 
02:0000132C 0C805A5A5678    	  1743:             cmpi.l #$5a5a5678,d0
02:00001332 66FE            	  1744:             bne.s *
02:00001334 0C815A5ACCDD    	  1745:             cmpi.l #$5a5aCCDD,d1
02:0000133A 66FE            	  1746:             bne.s *
02:0000133C 0C8212345678    	  1747:             cmpi.l #$12345678,d2
02:00001342 66FE            	  1748:             bne.s *
02:00001344 0C83AABBCCDD    	  1749:             cmpi.l #$AABBCCDD,d3
02:0000134A 66FE            	  1750:             bne.s *
                            	  1751: 
02:0000134C 4E75            	  1752:             rts
                            	  1753: 
                            	  1754: 
                            	  1755: 
                            	  1756: *-----------------------------------------------------------
                            	  1757: *-----------------------------------------------------------
                            	  1758: * OPCODE : BOOL_I
                            	  1759: *-----------------------------------------------------------
                            	  1760: *-----------------------------------------------------------
                            	  1761: op_BOOL_I:
                            	  1762: 
                            	  1763: *     Dn -- BYTE
02:0000134E 203C12345678    	  1764:             move.l #$12345678,d0
02:00001354 44FC000F        	  1765:             move.w #$000F,CCR          * pre-set Flags
02:00001358 000000FF        	  1766:             ori.b  #$FF,d0
02:0000135C 0A00005A        	  1767:             eori.b #$5A,d0
02:00001360 020000F0        	  1768:             andi.b #$F0,d0
02:00001364 69FE            	  1769:             bvs.s *                       * Check V,C are cleared
02:00001366 65FE            	  1770:             bcs.s *
02:00001368 6AFE            	  1771:             bpl.s *                       * Verify if N flag is set
02:0000136A 4200            	  1772:             andi.b #$00,d0
02:0000136C 6BFE            	  1773:             bmi.s *                       * Verify if N flag is cleared
02:0000136E 66FE            	  1774:             bne.s *                       * Verify if Z flag is set
                            	  1775: 
                            	  1776: *     Dn -- WORD
02:00001370 223C12345678    	  1777:             move.l #$12345678,d1
02:00001376 44FC000F        	  1778:             move.w #$000F,CCR          * pre-set Flags
02:0000137A 0041FFFF        	  1779:             ori.w  #$FFFF,d1
02:0000137E 0A415A5A        	  1780:             eori.w #$5A5A,d1
02:00001382 0241F0F0        	  1781:             andi.w #$F0F0,d1
02:00001386 69FE            	  1782:             bvs.s *                       * Check V,C are cleared
02:00001388 65FE            	  1783:             bcs.s *
02:0000138A 6AFE            	  1784:             bpl.s *                       * Verify if N flag is set
02:0000138C 4241            	  1785:             andi.w #$0000,d1
02:0000138E 6BFE            	  1786:             bmi.s *                       * Verify if N flag is cleared
02:00001390 66FE            	  1787:             bne.s *                       * Verify if Z flag is set
                            	  1788: 
                            	  1789: *     Dn -- LONG
02:00001392 243C12345678    	  1790:             move.l #$12345678,d2
02:00001398 44FC000F        	  1791:             move.w #$000F,CCR          * pre-set Flags
02:0000139C 0082FFFFFFFF    	  1792:             ori.l  #$FFFFFFFF,d2
02:000013A2 0A825A5A5A5A    	  1793:             eori.l #$5A5A5A5A,d2
02:000013A8 0282F0F0F0F0    	  1794:             andi.l #$F0F0F0F0,d2
02:000013AE 69FE            	  1795:             bvs.s *                       * Check V,C are cleared
02:000013B0 65FE            	  1796:             bcs.s *
02:000013B2 6AFE            	  1797:             bpl.s *                       * Verify if N flag is set
02:000013B4 4282            	  1798:             andi.l #$00000000,d2
02:000013B6 6BFE            	  1799:             bmi.s *                       * Verify if N flag is cleared
02:000013B8 66FE            	  1800:             bne.s *                       * Verify if Z flag is set
                            	  1801: 
                            	  1802: 
                            	  1803: *     (An) -- BYTE
02:000013BA 307C0100        	  1804:             move.l #$00000100,a0
02:000013BE 20BC12345678    	  1805:             move.l #$12345678,(a0)
02:000013C4 44FC000F        	  1806:             move.w #$000F,CCR          * pre-set Flags
02:000013C8 001000FF        	  1807:             ori.b  #$FF,(a0)
02:000013CC 0A10005A        	  1808:             eori.b #$5A,(a0)
02:000013D0 021000F0        	  1809:             andi.b #$F0,(a0)
02:000013D4 69FE            	  1810:             bvs.s *                       * Check V,C are cleared
02:000013D6 65FE            	  1811:             bcs.s *
02:000013D8 6AFE            	  1812:             bpl.s *                       * Verify if N flag is set
02:000013DA 4210            	  1813:             andi.b #$00,(a0)
02:000013DC 6BFE            	  1814:             bmi.s *                       * Verify if N flag is cleared
02:000013DE 66FE            	  1815:             bne.s *                       * Verify if Z flag is set
02:000013E0 4A10            	  1816:             cmpi.b #$00,(a0)
02:000013E2 66FE            	  1817:             bne.s *                       * Verify if Z flag is set
                            	  1818: 
                            	  1819: *     (An) -- WORD
02:000013E4 20BC12345678    	  1820:             move.l #$12345678,(a0)
02:000013EA 44FC000F        	  1821:             move.w #$000F,CCR          * pre-set Flags
02:000013EE 0050FFFF        	  1822:             ori.w  #$FFFF,(a0)
02:000013F2 0A505A5A        	  1823:             eori.w #$5A5A,(a0)
02:000013F6 0250F0F0        	  1824:             andi.w #$F0F0,(a0)
02:000013FA 69FE            	  1825:             bvs.s *                       * Check V,C are cleared
02:000013FC 65FE            	  1826:             bcs.s *
02:000013FE 6AFE            	  1827:             bpl.s *                       * Verify if N flag is set
02:00001400 4250            	  1828:             andi.w #$0000,(a0)
02:00001402 6BFE            	  1829:             bmi.s *                       * Verify if N flag is cleared
02:00001404 66FE            	  1830:             bne.s *                       * Verify if Z flag is set
02:00001406 4A50            	  1831:             cmpi.w #$00,(a0)
02:00001408 66FE            	  1832:             bne.s *                       * Verify if Z flag is set
                            	  1833: 
                            	  1834: *     (An) -- LONG
02:0000140A 20BC12345678    	  1835:             move.l #$12345678,(a0)
02:00001410 44FC000F        	  1836:             move.w #$000F,CCR          * pre-set Flags
02:00001414 0090FFFFFFFF    	  1837:             ori.l  #$FFFFFFFF,(a0)
02:0000141A 0A905A5A5A5A    	  1838:             eori.l #$5A5A5A5A,(a0)
02:00001420 0290F0F0F0F0    	  1839:             andi.l #$F0F0F0F0,(a0)
02:00001426 69FE            	  1840:             bvs.s *                       * Check V,C are cleared
02:00001428 65FE            	  1841:             bcs.s *
02:0000142A 6AFE            	  1842:             bpl.s *                       * Verify if N flag is set
02:0000142C 4290            	  1843:             andi.l #$00000000,(a0)
02:0000142E 6BFE            	  1844:             bmi.s *                       * Verify if N flag is cleared
02:00001430 66FE            	  1845:             bne.s *                       * Verify if Z flag is set
02:00001432 4A90            	  1846:             cmpi.l #$00,(a0)
02:00001434 66FE            	  1847:             bne.s *                       * Verify if Z flag is set
                            	  1848: 
                            	  1849: 
                            	  1850: 
                            	  1851: *     (An)+ -- BYTE
02:00001436 307C0100        	  1852:             move.l #$00000100,a0
02:0000143A 20BC00A5FF88    	  1853:             move.l #$00A5FF88,(a0)
02:00001440 44FC000F        	  1854:             move.w #$000F,CCR          * pre-set Flags
                            	  1855: 
02:00001444 001800F5        	  1856:             ori.b  #$F5,(a0)+
02:00001448 6AFE            	  1857:             bpl.s *                       * Verify if N flag is set
02:0000144A 67FE            	  1858:             beq.s *                       * Verify if Z flag is cleared
                            	  1859: 
02:0000144C 4618            	  1860:             eori.b #$FF,(a0)+
02:0000144E 6BFE            	  1861:             bmi.s *                       * Verify if N flag is cleared
02:00001450 67FE            	  1862:             beq.s *                       * Verify if Z flag is cleared
                            	  1863: 
02:00001452 021800AA        	  1864:             andi.b #$AA,(a0)+
02:00001456 6AFE            	  1865:             bpl.s *                       * Verify if N flag is set
02:00001458 67FE            	  1866:             beq.s *                       * Verify if Z flag is cleared
                            	  1867: 
02:0000145A 307C0100        	  1868:             move.l #$00000100,a0
02:0000145E 0C90F55AAA88    	  1869:             cmpi.l #$F55AAA88,(a0)
02:00001464 66FE            	  1870:             bne.s *                       * Verify if Z flag is set
                            	  1871: 
                            	  1872: 
                            	  1873: *     (An)+ -- WORD
02:00001466 307C0100        	  1874:             move.l #$00000100,a0
02:0000146A 327C0104        	  1875:             move.l #$00000104,a1
02:0000146E 20BC00005A5A    	  1876:             move.l #$00005a5a,(a0)
02:00001474 22BC12345678    	  1877:             move.l #$12345678,(a1)
02:0000147A 44FC000F        	  1878:             move.w #$000F,CCR          * pre-set Flags
                            	  1879: 
02:0000147E 00585678        	  1880:             ori.w  #$5678,(a0)+
02:00001482 6BFE            	  1881:             bmi.s *                       * Verify if N flag is cleared
02:00001484 67FE            	  1882:             beq.s *                       * Verify if Z flag is cleared
                            	  1883: 
02:00001486 4658            	  1884:             eori.w #$FFFF,(a0)+
02:00001488 6AFE            	  1885:             bpl.s *                       * Verify if N flag is set
02:0000148A 67FE            	  1886:             beq.s *                       * Verify if Z flag is cleared
                            	  1887: 
02:0000148C 0258A55A        	  1888:             andi.w #$A55A,(a0)+
02:00001490 6BFE            	  1889:             bmi.s *                       * Verify if N flag is cleared
02:00001492 67FE            	  1890:             beq.s *                       * Verify if Z flag is cleared
                            	  1891: 
02:00001494 307C0100        	  1892:             move.l #$00000100,a0
02:00001498 0C905678A5A5    	  1893:             cmpi.l #$5678a5a5,(a0)
02:0000149E 307C0104        	  1894:             move.l #$00000104,a0
02:000014A2 0C9000105678    	  1895:             cmpi.l #$00105678,(a0)
02:000014A8 66FE            	  1896:             bne.s *                       * Verify if Z flag is set
                            	  1897: 
                            	  1898: *     (An)+ -- LONG
02:000014AA 307C0100        	  1899:             move.l #$00000100,a0
02:000014AE 4298            	  1900:             move.l #$00000000,(a0)+
02:000014B0 20FC5A5A5A5A    	  1901:             move.l #$5a5a5a5a,(a0)+
02:000014B6 20FCFFFFFFFF    	  1902:             move.l #$FFFFFFFF,(a0)+
02:000014BC 307C0100        	  1903:             move.l #$00000100,a0
02:000014C0 44FC000F        	  1904:             move.w #$000F,CCR          * pre-set Flags
                            	  1905: 
02:000014C4 009812345678    	  1906:             ori.l  #$12345678,(a0)+
02:000014CA 6BFE            	  1907:             bmi.s *                       * Verify if N flag is cleared
02:000014CC 67FE            	  1908:             beq.s *                       * Verify if Z flag is cleared
                            	  1909: 
02:000014CE 4698            	  1910:             eori.l #$FFFFFFFF,(a0)+
02:000014D0 6AFE            	  1911:             bpl.s *                       * Verify if N flag is set
02:000014D2 67FE            	  1912:             beq.s *                       * Verify if Z flag is cleared
                            	  1913: 
02:000014D4 0298A5A5A55A    	  1914:             andi.l #$A5A5A55A,(a0)+
02:000014DA 6AFE            	  1915:             bpl.s *                       * Verify if N flag is set
02:000014DC 67FE            	  1916:             beq.s *                       * Verify if Z flag is cleared
                            	  1917: 
02:000014DE 307C0100        	  1918:             move.l #$00000100,a0
02:000014E2 0C9812345678    	  1919:             cmpi.l #$12345678,(a0)+
02:000014E8 0C98A5A5A5A5    	  1920:             cmpi.l #$a5a5a5a5,(a0)+
02:000014EE 0C98A5A5A55A    	  1921:             cmpi.l #$a5a5a55a,(a0)+
02:000014F4 66FE            	  1922:             bne.s *                       * Verify if Z flag is set
                            	  1923: 
02:000014F6 4E75            	  1924:             rts
                            	  1925: 
                            	  1926: 
                            	  1927: *-----------------------------------------------------------
                            	  1928: *-----------------------------------------------------------
                            	  1929: * OPCODE : BSR
                            	  1930: *-----------------------------------------------------------
                            	  1931: *-----------------------------------------------------------
                            	  1932: 
                            	  1933: 
02:000014F8 223C11111111    	  1934: BSR_CLOSE1:     move.l #$11111111,d1
02:000014FE 4E75            	  1935:                 rts
                            	  1936: 
                            	  1937: 
                            	  1938: 
02:00001500 61F6            	  1939: op_BSR:         bsr BSR_CLOSE1        * Negative 8-bit.s displacement
02:00001502 612A            	  1940:                 bsr BSR_CLOSE2        * Positive 8-bit.s displacement
02:00001504 6100EF20        	  1941:                 bsr.w BSR_FAR1          * Negative 16-bit.s displacement
02:00001508 6100143E        	  1942:                 bsr.w BSR_FAR2          * Positive 16-bit.s displacement
                            	  1943: 
02:0000150C 0C8111111111    	  1944:                 cmpi.l #$11111111,d1
02:00001512 66FE            	  1945:                 bne.s *
02:00001514 0C8222222222    	  1946:                 cmpi.l #$22222222,d2
02:0000151A 66FE            	  1947:                 bne.s *
02:0000151C 0C8333333333    	  1948:                 cmpi.l #$33333333,d3
02:00001522 66FE            	  1949:                 bne.s *
02:00001524 0C8444444444    	  1950:                 cmpi.l #$44444444,d4
02:0000152A 66FE            	  1951:                 bne.s *
                            	  1952: 
02:0000152C 4E75            	  1953:                 rts
                            	  1954: 
                            	  1955: 
02:0000152E 243C22222222    	  1956: BSR_CLOSE2:     move.l #$22222222,d2
02:00001534 4E75            	  1957:                 rts
                            	  1958: 
                            	  1959: *-----------------------------------------------------------
                            	  1960: *-----------------------------------------------------------
                            	  1961: * OPCODE : op_CMP_I
                            	  1962: *-----------------------------------------------------------
                            	  1963: *-----------------------------------------------------------
                            	  1964: op_CMP_I:
                            	  1965: 
02:00001536 307C0100        	  1966:             move.l #$00000100,a0
02:0000153A 20BC00000100    	  1967:             move.l #$00000100,(a0)
                            	  1968: 
                            	  1969: *     REGISTER - BYTE
02:00001540 7080            	  1970:             move.l #$FFFFFF80,d0
02:00001542 0C000080        	  1971:             cmpi.b #$80,d0
02:00001546 66FE            	  1972:             bne.s *                       * Check Z Flag  beq/bne
02:00001548 6BFE            	  1973:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000154A 65FE            	  1974:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000154C 69FE            	  1975:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1976: 
02:0000154E 223CFFFFF000    	  1977:             move.l #$FFFFF000,d1
02:00001554 4A01            	  1978:             cmpi.b #$00,d1
02:00001556 66FE            	  1979:             bne.s *                       * Check Z Flag  beq/bne
02:00001558 6BFE            	  1980:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000155A 65FE            	  1981:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000155C 69FE            	  1982:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1983: 
02:0000155E 7481D442        	  1984:             move.l #$FFFFFF02,d2
02:00001562 0C0200FF        	  1985:             cmpi.b #$FF,d2
02:00001566 67FE            	  1986:             beq.s *                       * Check Z Flag  beq/bne
02:00001568 6BFE            	  1987:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000156A 64FE            	  1988:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000156C 69FE            	  1989:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1990: 
02:0000156E 263CFFFFFF7F    	  1991:             move.l #$FFFFFF7F,d3
02:00001574 0C0300FF        	  1992:             cmpi.b #$FF,d3
02:00001578 67FE            	  1993:             beq.s *                       * Check Z Flag  beq/bne
02:0000157A 6AFE            	  1994:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000157C 64FE            	  1995:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000157E 68FE            	  1996:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  1997: 
                            	  1998: 
                            	  1999: *     REGISTER - WORD
02:00001580 203CFFFF8000    	  2000:             move.l #$FFFF8000,d0
02:00001586 0C408000        	  2001:             cmpi.w #$8000,d0
02:0000158A 66FE            	  2002:             bne.s *                       * Check Z Flag  beq/bne
02:0000158C 6BFE            	  2003:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000158E 65FE            	  2004:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001590 69FE            	  2005:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2006: 
02:00001592 223CFFF00000    	  2007:             move.l #$FFF00000,d1
02:00001598 4A41            	  2008:             cmpi.w #$0000,d1
02:0000159A 66FE            	  2009:             bne.s *                       * Check Z Flag  beq/bne
02:0000159C 6BFE            	  2010:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000159E 65FE            	  2011:             bcs.s *                       * Check C Flag  bcc/bcs
02:000015A0 69FE            	  2012:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2013: 
02:000015A2 243CFFFF0002    	  2014:             move.l #$FFFF0002,d2
02:000015A8 0C42FFFF        	  2015:             cmpi.w #$FFFF,d2
02:000015AC 67FE            	  2016:             beq.s *                       * Check Z Flag  beq/bne
02:000015AE 6BFE            	  2017:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015B0 64FE            	  2018:             bcc.s *                       * Check C Flag  bcc/bcs
02:000015B2 69FE            	  2019:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2020: 
02:000015B4 263CFFFF7FFF    	  2021:             move.l #$FFFF7FFF,d3
02:000015BA 0C43FFFF        	  2022:             cmpi.w #$FFFF,d3
02:000015BE 67FE            	  2023:             beq.s *                       * Check Z Flag  beq/bne
02:000015C0 6AFE            	  2024:             bpl.s *                       * Check N Flag  bmi/bpl
02:000015C2 64FE            	  2025:             bcc.s *                       * Check C Flag  bcc/bcs
02:000015C4 68FE            	  2026:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2027: 
                            	  2028: *     REGISTER - LONG
02:000015C6 203C80000000    	  2029:             move.l #$80000000,d0
02:000015CC 0C8080000000    	  2030:             cmpi.l #$80000000,d0
02:000015D2 66FE            	  2031:             bne.s *                       * Check Z Flag  beq/bne
02:000015D4 6BFE            	  2032:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015D6 65FE            	  2033:             bcs.s *                       * Check C Flag  bcc/bcs
02:000015D8 69FE            	  2034:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2035: 
02:000015DA 7200            	  2036:             moveq  #$00000000,d1
02:000015DC 4A81            	  2037:             cmpi.l #$00000000,d1
02:000015DE 66FE            	  2038:             bne.s *                       * Check Z Flag  beq/bne
02:000015E0 6BFE            	  2039:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015E2 65FE            	  2040:             bcs.s *                       * Check C Flag  bcc/bcs
02:000015E4 69FE            	  2041:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2042: 
02:000015E6 7402            	  2043:             moveq  #$00000002,d2
02:000015E8 0C82FFFFFFFF    	  2044:             cmpi.l #$FFFFFFFF,d2
02:000015EE 67FE            	  2045:             beq.s *                       * Check Z Flag  beq/bne
02:000015F0 6BFE            	  2046:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015F2 64FE            	  2047:             bcc.s *                       * Check C Flag  bcc/bcs
02:000015F4 69FE            	  2048:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2049: 
02:000015F6 263C7FFFFFFF    	  2050:             move.l #$7FFFFFFF,d3
02:000015FC 0C83FFFFFFFF    	  2051:             cmpi.l #$FFFFFFFF,d3
02:00001602 67FE            	  2052:             beq.s *                       * Check Z Flag  beq/bne
02:00001604 6AFE            	  2053:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001606 64FE            	  2054:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001608 68FE            	  2055:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2056: 
                            	  2057: 
                            	  2058: 
                            	  2059: 
                            	  2060: *     EA=x(An,Dn) - BYTE
02:0000160A 307C0100        	  2061:             move.l #$00000100,a0
02:0000160E 7E04            	  2062:             moveq  #$00000004,d7
                            	  2063: 
02:00001610 21BCFFFFFF80700C	  2064:             move.l #$FFFFFF80,12(a0,d7)
02:00001618 21BCFFFFFF80700C	  2065:             move.l #$FFFFFF80,12(a0,d7)
02:00001620 0C300080700F    	  2066:             cmpi.b #$80,15(a0,d7)
02:00001626 66FE            	  2067:             bne.s *                       * Check Z Flag  beq/bne
02:00001628 6BFE            	  2068:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000162A 65FE            	  2069:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000162C 69FE            	  2070:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2071: 
02:0000162E 21BCFFFFF000700C	  2072:             move.l #$FFFFF000,12(a0,d7)
02:00001636 4A30700F        	  2073:             cmpi.b #$00,15(a0,d7)
02:0000163A 66FE            	  2074:             bne.s *                       * Check Z Flag  beq/bne
02:0000163C 6BFE            	  2075:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000163E 65FE            	  2076:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001640 69FE            	  2077:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2078: 
02:00001642 21BCFFFFFF02700C	  2079:             move.l #$FFFFFF02,12(a0,d7)
02:0000164A 0C3000FF700F    	  2080:             cmpi.b #$FF,15(a0,d7)
02:00001650 67FE            	  2081:             beq.s *                       * Check Z Flag  beq/bne
02:00001652 6BFE            	  2082:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001654 64FE            	  2083:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001656 69FE            	  2084:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2085: 
02:00001658 21BCFFFFFF7F700C	  2086:             move.l #$FFFFFF7F,12(a0,d7)
02:00001660 0C3000FF700F    	  2087:             cmpi.b #$FF,15(a0,d7)
02:00001666 67FE            	  2088:             beq.s *                       * Check Z Flag  beq/bne
02:00001668 6AFE            	  2089:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000166A 64FE            	  2090:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000166C 68FE            	  2091:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2092: 
                            	  2093: 
                            	  2094: *     EA=x(An,Dn) - WORD
02:0000166E 21BCFFFF8000700C	  2095:             move.l #$FFFF8000,12(a0,d7)
02:00001676 0C708000700E    	  2096:             cmpi.w #$8000,14(a0,d7)
02:0000167C 66FE            	  2097:             bne.s *                       * Check Z Flag  beq/bne
02:0000167E 6BFE            	  2098:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001680 65FE            	  2099:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001682 69FE            	  2100:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2101: 
02:00001684 21BCFFF00000700C	  2102:             move.l #$FFF00000,12(a0,d7)
02:0000168C 4A70700E        	  2103:             cmpi.w #$0000,14(a0,d7)
02:00001690 66FE            	  2104:             bne.s *                       * Check Z Flag  beq/bne
02:00001692 6BFE            	  2105:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001694 65FE            	  2106:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001696 69FE            	  2107:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2108: 
02:00001698 21BCFFFF0002700C	  2109:             move.l #$FFFF0002,12(a0,d7)
02:000016A0 0C70FFFF700E    	  2110:             cmpi.w #$FFFF,14(a0,d7)
02:000016A6 67FE            	  2111:             beq.s *                       * Check Z Flag  beq/bne
02:000016A8 6BFE            	  2112:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016AA 64FE            	  2113:             bcc.s *                       * Check C Flag  bcc/bcs
02:000016AC 69FE            	  2114:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2115: 
02:000016AE 21BCFFFF7FFF700C	  2116:             move.l #$FFFF7FFF,12(a0,d7)
02:000016B6 0C70FFFF700E    	  2117:             cmpi.w #$FFFF,14(a0,d7)
02:000016BC 67FE            	  2118:             beq.s *                       * Check Z Flag  beq/bne
02:000016BE 6AFE            	  2119:             bpl.s *                       * Check N Flag  bmi/bpl
02:000016C0 64FE            	  2120:             bcc.s *                       * Check C Flag  bcc/bcs
02:000016C2 68FE            	  2121:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2122: 
                            	  2123: *     EA=x(An,Dn) - LONG
02:000016C4 21BC80000000700C	  2124:             move.l #$80000000,12(a0,d7)
02:000016CC 0CB080000000700C	  2125:             cmpi.l #$80000000,12(a0,d7)
02:000016D4 66FE            	  2126:             bne.s *                       * Check Z Flag  beq/bne
02:000016D6 6BFE            	  2127:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016D8 65FE            	  2128:             bcs.s *                       * Check C Flag  bcc/bcs
02:000016DA 69FE            	  2129:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2130: 
02:000016DC 42B0700C        	  2131:             move.l #$00000000,12(a0,d7)
02:000016E0 4AB0700C        	  2132:             cmpi.l #$00000000,12(a0,d7)
02:000016E4 66FE            	  2133:             bne.s *                       * Check Z Flag  beq/bne
02:000016E6 6BFE            	  2134:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016E8 65FE            	  2135:             bcs.s *                       * Check C Flag  bcc/bcs
02:000016EA 69FE            	  2136:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2137: 
02:000016EC 21BC00000002700C	  2138:             move.l #$00000002,12(a0,d7)
02:000016F4 0CB0FFFFFFFF700C	  2139:             cmpi.l #$FFFFFFFF,12(a0,d7)
02:000016FC 67FE            	  2140:             beq.s *                       * Check Z Flag  beq/bne
02:000016FE 6BFE            	  2141:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001700 64FE            	  2142:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001702 69FE            	  2143:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2144: 
02:00001704 21BC7FFFFFFF700C	  2145:             move.l #$7FFFFFFF,12(a0,d7)
02:0000170C 0CB0FFFFFFFF700C	  2146:             cmpi.l #$FFFFFFFF,12(a0,d7)
02:00001714 67FE            	  2147:             beq.s *                       * Check Z Flag  beq/bne
02:00001716 6AFE            	  2148:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001718 64FE            	  2149:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000171A 68FE            	  2150:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2151: 
                            	  2152: 
                            	  2153: 
                            	  2154: 
02:0000171C 4E75            	  2155:             rts
                            	  2156: 
                            	  2157: 
                            	  2158: 
                            	  2159: *-----------------------------------------------------------
                            	  2160: *-----------------------------------------------------------
                            	  2161: * OPCODE : ADD_I
                            	  2162: *-----------------------------------------------------------
                            	  2163: *-----------------------------------------------------------
                            	  2164: op_ADD_I:
                            	  2165: 
                            	  2166: *     EA = Dn  - Byte
02:0000171E 203C12345678    	  2167:             move.l #$12345678,d0      * populate test data
02:00001724 06000000        	  2168:             addi.b #0,d0
02:00001728 67FE            	  2169:             beq.s *                       * Check Z Flag  beq/bne
02:0000172A 6BFE            	  2170:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000172C 65FE            	  2171:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000172E 69FE            	  2172:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001730 06000010        	  2173:             addi.b #$10,d0
02:00001734 67FE            	  2174:             beq.s *                       * Check Z Flag  beq/bne
02:00001736 6AFE            	  2175:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001738 65FE            	  2176:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000173A 68FE            	  2177:             bvc.s *                       * Check V Flag  bvc/bvs
02:0000173C 060000A5        	  2178:             addi.b #$A5,d0
02:00001740 67FE            	  2179:             beq.s *                       * Check Z Flag  beq/bne
02:00001742 6BFE            	  2180:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001744 64FE            	  2181:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001746 68FE            	  2182:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001748 0C00002D        	  2183:             cmpi.b #$2D,d0
02:0000174C 66FE            	  2184:             bne.s *                       * Check Z Flag  beq/bne
                            	  2185: 
                            	  2186: *     EA = Dn  - WORD
02:0000174E 203C12345678    	  2187:             move.l #$12345678,d0      * populate test data
02:00001754 06400000        	  2188:             addi.w #0,d0
02:00001758 67FE            	  2189:             beq.s *                       * Check Z Flag  beq/bne
02:0000175A 6BFE            	  2190:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000175C 65FE            	  2191:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000175E 69FE            	  2192:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001760 06407000        	  2193:             addi.w #$7000,d0
02:00001764 67FE            	  2194:             beq.s *                       * Check Z Flag  beq/bne
02:00001766 6AFE            	  2195:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001768 65FE            	  2196:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000176A 68FE            	  2197:             bvc.s *                       * Check V Flag  bvc/bvs
02:0000176C 0640A55A        	  2198:             addi.w #$A55A,d0
02:00001770 67FE            	  2199:             beq.s *                       * Check Z Flag  beq/bne
02:00001772 6BFE            	  2200:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001774 64FE            	  2201:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001776 68FE            	  2202:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001778 0C406BD2        	  2203:             cmpi.w #$6BD2,d0
02:0000177C 66FE            	  2204:             bne.s *                       * Check Z Flag  beq/bne
                            	  2205: 
                            	  2206: *     EA = Dn  - LONG
02:0000177E 203C12345678    	  2207:             move.l #$12345678,d0      * populate test data
02:00001784 068000000000    	  2208:             addi.l #0,d0
02:0000178A 67FE            	  2209:             beq.s *                       * Check Z Flag  beq/bne
02:0000178C 6BFE            	  2210:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000178E 65FE            	  2211:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001790 69FE            	  2212:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001792 0680F0000000    	  2213:             addi.l #$F0000000,d0
02:00001798 67FE            	  2214:             beq.s *                       * Check Z Flag  beq/bne
02:0000179A 6BFE            	  2215:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000179C 64FE            	  2216:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000179E 69FE            	  2217:             bvs.s *                       * Check V Flag  bvc/bvs
02:000017A0 0680855AA55A    	  2218:             addi.l #$855AA55A,d0
02:000017A6 67FE            	  2219:             beq.s *                       * Check Z Flag  beq/bne
02:000017A8 6AFE            	  2220:             bpl.s *                       * Check N Flag  bmi/bpl
02:000017AA 65FE            	  2221:             bcs.s *                       * Check C Flag  bcc/bcs
02:000017AC 69FE            	  2222:             bvs.s *                       * Check V Flag  bvc/bvs
02:000017AE 0680A0000000    	  2223:             addi.l #$A0000000,d0
02:000017B4 68FE            	  2224:             bvc.s *                       * Check V Flag  bvc/bvs
02:000017B6 0C80278EFBD2    	  2225:             cmpi.l #$278EFBD2,d0
02:000017BC 66FE            	  2226:             bne.s *                       * Check Z Flag  beq/bne
                            	  2227: 
                            	  2228: 
                            	  2229: 
                            	  2230: *     EA = x.L  - Byte
02:000017BE 207C0000F100    	  2231:             move.l #$F100,a0      * populate test data
02:000017C4 20BC12345678    	  2232:             move.l #$12345678,(a0)     * populate test data
02:000017CA 063900000000F103	  2233:             addi.b #0,$F103
02:000017D2 67FE            	  2234:             beq.s *                       * Check Z Flag  beq/bne
02:000017D4 6BFE            	  2235:             bmi.s *                       * Check N Flag  bmi/bpl
02:000017D6 65FE            	  2236:             bcs.s *                       * Check C Flag  bcc/bcs
02:000017D8 69FE            	  2237:             bvs.s *                       * Check V Flag  bvc/bvs
02:000017DA 063900100000F103	  2238:             addi.b #$10,$F103
02:000017E2 67FE            	  2239:             beq.s *                       * Check Z Flag  beq/bne
02:000017E4 6AFE            	  2240:             bpl.s *                       * Check N Flag  bmi/bpl
02:000017E6 65FE            	  2241:             bcs.s *                       * Check C Flag  bcc/bcs
02:000017E8 68FE            	  2242:             bvc.s *                       * Check V Flag  bvc/bvs
02:000017EA 063900A50000F103	  2243:             addi.b #$A5,$F103
02:000017F2 67FE            	  2244:             beq.s *                       * Check Z Flag  beq/bne
02:000017F4 6BFE            	  2245:             bmi.s *                       * Check N Flag  bmi/bpl
02:000017F6 64FE            	  2246:             bcc.s *                       * Check C Flag  bcc/bcs
02:000017F8 68FE            	  2247:             bvc.s *                       * Check V Flag  bvc/bvs
02:000017FA 0C39002D0000F103	  2248:             cmpi.b #$2D,$F103
02:00001802 66FE            	  2249:             bne.s *                       * Check Z Flag  beq/bne
                            	  2250: 
                            	  2251: *     EA = x.L- WORD
02:00001804 207C0000F100    	  2252:             move.l #$F100,a0      * populate test data
02:0000180A 20BC12345678    	  2253:             move.l #$12345678,(a0)     * populate test data
02:00001810 067900000000F100	  2254:             addi.w #0,$F100
02:00001818 67FE            	  2255:             beq.s *                       * Check Z Flag  beq/bne
02:0000181A 6BFE            	  2256:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000181C 65FE            	  2257:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000181E 69FE            	  2258:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001820 067970000000F100	  2259:             addi.w #$7000,$F100
02:00001828 67FE            	  2260:             beq.s *                       * Check Z Flag  beq/bne
02:0000182A 6AFE            	  2261:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000182C 65FE            	  2262:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000182E 68FE            	  2263:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001830 0679A55A0000F100	  2264:             addi.w #$A55A,$F100
02:00001838 67FE            	  2265:             beq.s *                       * Check Z Flag  beq/bne
02:0000183A 6BFE            	  2266:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000183C 64FE            	  2267:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000183E 68FE            	  2268:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001840 0C79278E0000F100	  2269:             cmpi.w #$278E,$F100
02:00001848 66FE            	  2270:             bne.s *                       * Check Z Flag  beq/bne
                            	  2271: 
                            	  2272: *     EA = x.L- LONG
02:0000184A 23FC123456780000	  2273:             move.l #$12345678,$F100  * populate test data
02:00001852 F100
02:00001854 06B9000000000000	  2274:             addi.l #0,$F100
02:0000185C F100
02:0000185E 67FE            	  2275:             beq.s *                       * Check Z Flag  beq/bne
02:00001860 6BFE            	  2276:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001862 65FE            	  2277:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001864 69FE            	  2278:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001866 06B9F00000000000	  2279:             addi.l #$F0000000,$F100
02:0000186E F100
02:00001870 67FE            	  2280:             beq.s *                       * Check Z Flag  beq/bne
02:00001872 6BFE            	  2281:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001874 64FE            	  2282:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001876 69FE            	  2283:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001878 06B9855AA55A0000	  2284:             addi.l #$855AA55A,$F100
02:00001880 F100
02:00001882 67FE            	  2285:             beq.s *                       * Check Z Flag  beq/bne
02:00001884 6AFE            	  2286:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001886 65FE            	  2287:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001888 69FE            	  2288:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000188A 06B9A00000000000	  2289:             addi.l #$A0000000,$F100
02:00001892 F100
02:00001894 68FE            	  2290:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001896 0CB9278EFBD20000	  2291:             cmpi.l #$278EFBD2,$F100
02:0000189E F100
02:000018A0 66FE            	  2292:             bne.s *                       * Check Z Flag  beq/bne
                            	  2293: 
02:000018A2 4E75            	  2294:             rts
                            	  2295: 
                            	  2296: 
                            	  2297: *-----------------------------------------------------------
                            	  2298: *-----------------------------------------------------------
                            	  2299: * OPCODE : SUB_I
                            	  2300: *-----------------------------------------------------------
                            	  2301: *-----------------------------------------------------------
                            	  2302: op_SUB_I:
                            	  2303: 
                            	  2304: *     EA = Dn  - Byte
02:000018A4 203C12345678    	  2305:             move.l #$12345678,d0      * populate test data
02:000018AA 04000000        	  2306:             subi.b #0,d0
02:000018AE 67FE            	  2307:             beq.s *                       * Check Z Flag  beq/bne
02:000018B0 6BFE            	  2308:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018B2 65FE            	  2309:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018B4 69FE            	  2310:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018B6 04000010        	  2311:             subi.b #$10,d0
02:000018BA 67FE            	  2312:             beq.s *                       * Check Z Flag  beq/bne
02:000018BC 6BFE            	  2313:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018BE 65FE            	  2314:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018C0 69FE            	  2315:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018C2 040000A5        	  2316:             subi.b #$A5,d0
02:000018C6 67FE            	  2317:             beq.s *                       * Check Z Flag  beq/bne
02:000018C8 6AFE            	  2318:             bpl.s *                       * Check N Flag  bmi/bpl
02:000018CA 64FE            	  2319:             bcc.s *                       * Check C Flag  bcc/bcs
02:000018CC 68FE            	  2320:             bvc.s *                       * Check V Flag  bvc/bvs
02:000018CE 0C0000C3        	  2321:             cmpi.b #$C3,d0
02:000018D2 66FE            	  2322:             bne.s *                       * Check Z Flag  beq/bne
                            	  2323: 
                            	  2324: *     EA = Dn  - WORD
02:000018D4 203C12345678    	  2325:             move.l #$12345678,d0      * populate test data
02:000018DA 04400000        	  2326:             subi.w #0,d0
02:000018DE 67FE            	  2327:             beq.s *                       * Check Z Flag  beq/bne
02:000018E0 6BFE            	  2328:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018E2 65FE            	  2329:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018E4 69FE            	  2330:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018E6 04407000        	  2331:             subi.w #$7000,d0
02:000018EA 67FE            	  2332:             beq.s *                       * Check Z Flag  beq/bne
02:000018EC 6AFE            	  2333:             bpl.s *                       * Check N Flag  bmi/bpl
02:000018EE 64FE            	  2334:             bcc.s *                       * Check C Flag  bcc/bcs
02:000018F0 69FE            	  2335:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018F2 0440A55A        	  2336:             subi.w #$A55A,d0
02:000018F6 67FE            	  2337:             beq.s *                       * Check Z Flag  beq/bne
02:000018F8 6BFE            	  2338:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018FA 65FE            	  2339:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018FC 69FE            	  2340:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018FE 0C40411E        	  2341:             cmpi.w #$411E,d0
02:00001902 66FE            	  2342:             bne.s *                       * Check Z Flag  beq/bne
                            	  2343: 
                            	  2344: *     EA = Dn  - LONG
02:00001904 203C12345678    	  2345:             move.l #$12345678,d0      * populate test data
02:0000190A 048000000000    	  2346:             subi.l #0,d0
02:00001910 67FE            	  2347:             beq.s *                       * Check Z Flag  beq/bne
02:00001912 6BFE            	  2348:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001914 65FE            	  2349:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001916 69FE            	  2350:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001918 0480F0000000    	  2351:             subi.l #$F0000000,d0
02:0000191E 67FE            	  2352:             beq.s *                       * Check Z Flag  beq/bne
02:00001920 6BFE            	  2353:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001922 64FE            	  2354:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001924 69FE            	  2355:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001926 0480855AA55A    	  2356:             subi.l #$855AA55A,d0
02:0000192C 67FE            	  2357:             beq.s *                       * Check Z Flag  beq/bne
02:0000192E 6AFE            	  2358:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001930 64FE            	  2359:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001932 68FE            	  2360:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001934 0480A0000000    	  2361:             subi.l #$A0000000,d0
02:0000193A 69FE            	  2362:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000193C 0C80FCD9B11E    	  2363:             cmpi.l #$FCD9B11E,d0
02:00001942 66FE            	  2364:             bne.s *                       * Check Z Flag  beq/bne
                            	  2365: 
                            	  2366: 
                            	  2367: 
                            	  2368: *     EA = x.L  - Byte
02:00001944 207C0000F100    	  2369:             move.l #$F100,a0      * populate test data
02:0000194A 20BC12345678    	  2370:             move.l #$12345678,(a0)     * populate test data
02:00001950 043900000000F103	  2371:             subi.b #0,$F103
02:00001958 67FE            	  2372:             beq.s *                       * Check Z Flag  beq/bne
02:0000195A 6BFE            	  2373:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000195C 65FE            	  2374:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000195E 69FE            	  2375:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001960 043900100000F103	  2376:             subi.b #$10,$F103
02:00001968 67FE            	  2377:             beq.s *                       * Check Z Flag  beq/bne
02:0000196A 6BFE            	  2378:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000196C 65FE            	  2379:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000196E 69FE            	  2380:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001970 043900A50000F103	  2381:             subi.b #$A5,$F103
02:00001978 67FE            	  2382:             beq.s *                       * Check Z Flag  beq/bne
02:0000197A 6AFE            	  2383:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000197C 64FE            	  2384:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000197E 68FE            	  2385:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001980 0C3900C30000F103	  2386:             cmpi.b #$C3,$F103
02:00001988 66FE            	  2387:             bne.s *                       * Check Z Flag  beq/bne
                            	  2388: 
                            	  2389: *     EA = x.L- WORD
02:0000198A 207C0000F100    	  2390:             move.l #$F100,a0      * populate test data
02:00001990 20BC12345678    	  2391:             move.l #$12345678,(a0)     * populate test data
02:00001996 047900000000F100	  2392:             subi.w #0,$F100
02:0000199E 67FE            	  2393:             beq.s *                       * Check Z Flag  beq/bne
02:000019A0 6BFE            	  2394:             bmi.s *                       * Check N Flag  bmi/bpl
02:000019A2 65FE            	  2395:             bcs.s *                       * Check C Flag  bcc/bcs
02:000019A4 69FE            	  2396:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019A6 047970000000F100	  2397:             subi.w #$7000,$F100
02:000019AE 67FE            	  2398:             beq.s *                       * Check Z Flag  beq/bne
02:000019B0 6AFE            	  2399:             bpl.s *                       * Check N Flag  bmi/bpl
02:000019B2 64FE            	  2400:             bcc.s *                       * Check C Flag  bcc/bcs
02:000019B4 69FE            	  2401:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019B6 0479A55A0000F100	  2402:             subi.w #$A55A,$F100
02:000019BE 67FE            	  2403:             beq.s *                       * Check Z Flag  beq/bne
02:000019C0 6AFE            	  2404:             bpl.s *                       * Check N Flag  bmi/bpl
02:000019C2 64FE            	  2405:             bcc.s *                       * Check C Flag  bcc/bcs
02:000019C4 69FE            	  2406:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019C6 0C79FCDA0000F100	  2407:             cmpi.w #$FCDA,$F100
02:000019CE 66FE            	  2408:             bne.s *                       * Check Z Flag  beq/bne
                            	  2409: 
                            	  2410: *     EA = x.L- LONG
02:000019D0 23FC123456780000	  2411:             move.l #$12345678,$F100  * populate test data
02:000019D8 F100
02:000019DA 04B9000000000000	  2412:             subi.l #0,$F100
02:000019E2 F100
02:000019E4 67FE            	  2413:             beq.s *                       * Check Z Flag  beq/bne
02:000019E6 6BFE            	  2414:             bmi.s *                       * Check N Flag  bmi/bpl
02:000019E8 65FE            	  2415:             bcs.s *                       * Check C Flag  bcc/bcs
02:000019EA 69FE            	  2416:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019EC 04B9F00000000000	  2417:             subi.l #$F0000000,$F100
02:000019F4 F100
02:000019F6 67FE            	  2418:             beq.s *                       * Check Z Flag  beq/bne
02:000019F8 6BFE            	  2419:             bmi.s *                       * Check N Flag  bmi/bpl
02:000019FA 64FE            	  2420:             bcc.s *                       * Check C Flag  bcc/bcs
02:000019FC 69FE            	  2421:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019FE 04B9855AA55A0000	  2422:             subi.l #$855AA55A,$F100
02:00001A06 F100
02:00001A08 67FE            	  2423:             beq.s *                       * Check Z Flag  beq/bne
02:00001A0A 6AFE            	  2424:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001A0C 64FE            	  2425:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001A0E 68FE            	  2426:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001A10 04B9A00000000000	  2427:             subi.l #$A0000000,$F100
02:00001A18 F100
02:00001A1A 69FE            	  2428:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001A1C 0CB9FCD9B11E0000	  2429:             cmpi.l #$FCD9B11E,$F100
02:00001A24 F100
02:00001A26 66FE            	  2430:             bne.s *                       * Check Z Flag  beq/bne
                            	  2431: 
02:00001A28 4E75            	  2432:             rts
                            	  2433: 
                            	  2434: 
                            	  2435: 
                            	  2436: *-----------------------------------------------------------
                            	  2437: *-----------------------------------------------------------
                            	  2438: * OPCODE : MOVE
                            	  2439: *-----------------------------------------------------------
                            	  2440: *-----------------------------------------------------------
                            	  2441: op_MOVE:
02:00001A2A 203C11223344    	  2442:             move.l #$11223344,d0
02:00001A30 223C55667788    	  2443:             move.l #$55667788,d1
02:00001A36 243C8899AABB    	  2444:             move.l #$8899aabb,d2
02:00001A3C 263CCCDDEEFF    	  2445:             move.l #$ccddeeff,d3
02:00001A42 7800            	  2446:             moveq  #$00000000,d4
02:00001A44 7A00            	  2447:             moveq  #$00000000,d5
02:00001A46 7C00            	  2448:             moveq  #$00000000,d6
02:00001A48 7E00            	  2449:             moveq  #$00000000,d7
02:00001A4A 207C44332211    	  2450:             move.l #$44332211,a0
02:00001A50 227C88776655    	  2451:             move.l #$88776655,a1
02:00001A56 247CBBAA9988    	  2452:             move.l #$bbaa9988,a2
02:00001A5C 267CFFEEDDCC    	  2453:             move.l #$ffeeddcc,a3
                            	  2454: 
02:00001A62 1800            	  2455:             move.b d0,d4              * BYTE - DATA REGISTER
02:00001A64 67FE            	  2456:             beq.s *                       * Check Z Flag  beq/bne
02:00001A66 6BFE            	  2457:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A68 0C8400000044    	  2458:             cmpi.l #$00000044,d4
02:00001A6E 66FE            	  2459:             bne.s *                       * Check Z Flag  beq/bne
                            	  2460: 
02:00001A70 3A01            	  2461:             move.w d1,d5              * WORD - DATA REGISTER
02:00001A72 67FE            	  2462:             beq.s *                       * Check Z Flag  beq/bne
02:00001A74 6BFE            	  2463:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A76 0C8500007788    	  2464:             cmpi.l #$00007788,d5
02:00001A7C 66FE            	  2465:             bne.s *                       * Check Z Flag  beq/bne
                            	  2466: 
02:00001A7E 2C02            	  2467:             move.l d2,d6              * LONG - DATA REGISTER
02:00001A80 67FE            	  2468:             beq.s *                       * Check Z Flag  beq/bne
02:00001A82 6AFE            	  2469:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001A84 0C868899AABB    	  2470:             cmpi.l #$8899aabb,d6
02:00001A8A 66FE            	  2471:             bne.s *                       * Check Z Flag  beq/bne
                            	  2472: 
02:00001A8C 3A09            	  2473:             move.w a1,d5              * WORD - ADDRESS REGISTER
02:00001A8E 67FE            	  2474:             beq.s *                       * Check Z Flag  beq/bne
02:00001A90 6BFE            	  2475:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A92 0C8500006655    	  2476:             cmpi.l #$00006655,d5
02:00001A98 66FE            	  2477:             bne.s *                       * Check Z Flag  beq/bne
                            	  2478: 
02:00001A9A 2C0A            	  2479:             move.l a2,d6              * LONG - ADDRESS REGISTER
02:00001A9C 67FE            	  2480:             beq.s *                       * Check Z Flag  beq/bne
02:00001A9E 6AFE            	  2481:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001AA0 0C86BBAA9988    	  2482:             cmpi.l #$bbaa9988,d6
02:00001AA6 66FE            	  2483:             bne.s *                       * Check Z Flag  beq/bne
                            	  2484: 
                            	  2485: 
02:00001AA8 3842            	  2486:             movea.w d2,a4             * WORD - ADDRESS REGISTER as SOURCE ## MOVEA
02:00001AAA B9C2            	  2487:             cmpa.l d2,a4
02:00001AAC 67FE            	  2488:             beq.s *                       * Check Z Flag  beq/bne ## comopare fails because A4 was sign extended
                            	  2489: 
02:00001AAE 2A41            	  2490:             movea.l d1,a5             * LONG - ADDRESS REGISTER as SOURCE ## MOVEA
02:00001AB0 BBC1            	  2491:             cmpa.l d1,a5
02:00001AB2 66FE            	  2492:             bne.s *                       * Check Z Flag  beq/bne
                            	  2493: 
                            	  2494: 
                            	  2495: 
                            	  2496: *   Too mamy EA combinations to test,so we focus on a few of the more complicted EA's
                            	  2497: 
02:00001AB4 203C11223344    	  2498:             move.l #$11223344,d0
02:00001ABA 223C00010100    	  2499:             move.l #$00010100,d1
02:00001AC0 243C8899AABB    	  2500:             move.l #$8899aabb,d2
02:00001AC6 7601            	  2501:             moveq  #$00000001,d3
02:00001AC8 7800            	  2502:             moveq  #$00000000,d4
02:00001ACA 7A00            	  2503:             moveq  #$00000000,d5
02:00001ACC 7C00            	  2504:             moveq  #$00000000,d6
02:00001ACE 7E00            	  2505:             moveq  #$00000000,d7
02:00001AD0 91C8            	  2506:             move.l #$00000000,a0
02:00001AD2 227C00010100    	  2507:             move.l #$00010100,a1
                            	  2508: 
                            	  2509: *     x(An,AL) --> x.L
02:00001AD8 11BC005A9804    	  2510:             move.b #$5A,4(a0,a1.l)    * BYTE
02:00001ADE 47F09804        	  2511:             lea 4(a0,a1.l),a3
02:00001AE2 13F0980400010105	  2512:             move.b 4(a0,a1.l),$00010105
02:00001AEA 67FE            	  2513:             beq.s *                       * Check Z Flag  beq/bne
02:00001AEC 6BFE            	  2514:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001AEE 0C30005A9805    	  2515:             cmpi.b #$5A,5(a0,a1.l)
02:00001AF4 66FE            	  2516:             bne.s *                       * Check Z Flag  beq/bne
                            	  2517: 
                            	  2518: *     x.L --> n(An,Dw)
02:00001AF6 11B9000101051007	  2519: MOVE2:      move.b  $00010105,7(a0,d1.w)    * BYTE
02:00001AFE 67FE            	  2520:             beq.s *                       * Check Z Flag  beq/bne
02:00001B00 6BFE            	  2521:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B02 0C30005A1007    	  2522:             cmpi.b #$5A,7(a0,d1.w)
02:00001B08 66FE            	  2523:             bne.s *                       * Check Z Flag  beq/bne
                            	  2524: 
                            	  2525: *     x(PC,Ds) --> x.w
02:00001B0A 11FB30660100    	  2526:             move.b  MOVE1(pc,d3.w),$0100 * BYTE
02:00001B10 67FE            	  2527:             beq.s *                       * Check Z Flag  beq/bne
02:00001B12 6AFE            	  2528:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001B14 0C3900B900001AF7	  2529:             cmpi.b #$B9,1+MOVE2
02:00001B1C 66FE            	  2530:             bne.s *                       * Check Z Flag  beq/bne
                            	  2531: 
                            	  2532: *     #x -->    n(An,AL)
02:00001B1E 11BC00781007    	  2533:             move.b  #$78,7(a0,d1.w)    * BYTE
02:00001B24 67FE            	  2534:             beq.s *                       * Check Z Flag  beq/bne
02:00001B26 6BFE            	  2535:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B28 0C3000781007    	  2536:             cmpi.b #$78,7(a0,d1.w)
02:00001B2E 66FE            	  2537:             bne.s *                       * Check Z Flag  beq/bne
                            	  2538: 
02:00001B30 203C11223344    	  2539:             move.l #$11223344,d0
02:00001B36 223C00010100    	  2540:             move.l #$00010100,d1
02:00001B3C 243C8899AABB    	  2541:             move.l #$8899aabb,d2
02:00001B42 7602            	  2542:             moveq  #$00000002,d3
02:00001B44 7800            	  2543:             moveq  #$00000000,d4
02:00001B46 7A00            	  2544:             moveq  #$00000000,d5
02:00001B48 7C00            	  2545:             moveq  #$00000000,d6
02:00001B4A 7E00            	  2546:             moveq  #$00000000,d7
02:00001B4C 91C8            	  2547:             move.l #$00000000,a0
02:00001B4E 227C00010100    	  2548:             move.l #$00010100,a1
                            	  2549: 
                            	  2550: *     x(An,AL) --> x.L
02:00001B54 31BC5A5A9804    	  2551:             move.w #$5A5A,4(a0,a1.l)    * WORD
02:00001B5A 49F09804        	  2552:             lea 4(a0,a1.l),a4
02:00001B5E 33F0980400010104	  2553:             move.w 4(a0,a1.l),$00010104
02:00001B66 67FE            	  2554:             beq.s *                       * Check Z Flag  beq/bne
02:00001B68 6BFE            	  2555:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B6A 0C705A5A9804    	  2556:             cmpi.w #$5A5A,4(a0,a1.l)
02:00001B70 66FE            	  2557:             bne.s *                       * Check Z Flag  beq/bne
                            	  2558: 
                            	  2559: *     x.L --> n(An,Dw)
02:00001B72 31B9000101041006	  2560: MOVE1:      move.w  $00010104,6(a0,d1.w)    * WORD
02:00001B7A 67FE            	  2561:             beq.s *                       * Check Z Flag  beq/bne
02:00001B7C 6BFE            	  2562:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B7E 0C705A5A1006    	  2563:             cmpi.w #$5A5A,6(a0,d1.w)
02:00001B84 66FE            	  2564:             bne.s *                       * Check Z Flag  beq/bne
                            	  2565: 
                            	  2566: *     x(PC,Ds) --> x.w
02:00001B86 31FB30EA0100    	  2567:             move.w  MOVE1(pc,d3),$0100 * WORD
02:00001B8C 67FE            	  2568:             beq.s *                       * Check Z Flag  beq/bne
02:00001B8E 6BFE            	  2569:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B90 0C7967FE00001B7A	  2570:             cmpi.w #$67FE,8+MOVE1
02:00001B98 66FE            	  2571:             bne.s *                       * Check Z Flag  beq/bne
                            	  2572: 
                            	  2573: *     #x -->    n(An,AL)
02:00001B9A 31BC78781006    	  2574:             move.w  #$7878,6(a0,d1.w)    * WORD
02:00001BA0 67FE            	  2575:             beq.s *                       * Check Z Flag  beq/bne
02:00001BA2 6BFE            	  2576:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001BA4 0C7078781006    	  2577:             cmpi.w #$7878,6(a0,d1.w)
02:00001BAA 66FE            	  2578:             bne.s *                       * Check Z Flag  beq/bne
                            	  2579: 
                            	  2580: * ---
                            	  2581: 
02:00001BAC 203C11223344    	  2582:             move.l #$11223344,d0
02:00001BB2 223C00010100    	  2583:             move.l #$00010100,d1
02:00001BB8 243C8899AABB    	  2584:             move.l #$8899aabb,d2
02:00001BBE 7602            	  2585:             moveq  #$00000002,d3
02:00001BC0 7800            	  2586:             moveq  #$00000000,d4
02:00001BC2 7A00            	  2587:             moveq  #$00000000,d5
02:00001BC4 7C00            	  2588:             moveq  #$00000000,d6
02:00001BC6 7E00            	  2589:             moveq  #$00000000,d7
02:00001BC8 91C8            	  2590:             move.l #$00000000,a0
02:00001BCA 227C00010100    	  2591:             move.l #$00010100,a1
                            	  2592: 
                            	  2593: *     x(An,AL) --> x.L
02:00001BD0 21BC5A5A12349804	  2594:             move.l #$5A5A1234,4(a0,a1.l)    * LONG
02:00001BD8 49F09804        	  2595:             lea 4(a0,a1.l),a4
02:00001BDC 23F0980400010104	  2596:             move.l 4(a0,a1.l),$00010104
02:00001BE4 67FE            	  2597:             beq.s *                       * Check Z Flag  beq/bne
02:00001BE6 6BFE            	  2598:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001BE8 0CB05A5A12349804	  2599:             cmpi.l #$5A5A1234,4(a0,a1.l)
02:00001BF0 66FE            	  2600:             bne.s *                       * Check Z Flag  beq/bne
                            	  2601: 
                            	  2602: *     x.L --> n(An,Dw)
02:00001BF2 21B9000101041006	  2603: MOVE3:      move.l  $00010104,6(a0,d1.w)    * LONG
02:00001BFA 67FE            	  2604:             beq.s *                       * Check Z Flag  beq/bne
02:00001BFC 6BFE            	  2605:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001BFE 0CB05A5A12341006	  2606:             cmpi.l #$5A5A1234,6(a0,d1.w)
02:00001C06 66FE            	  2607:             bne.s *                       * Check Z Flag  beq/bne
                            	  2608: 
                            	  2609: *     x(PC,Ds) --> x.w
02:00001C08 21FB30E80100    	  2610:             move.l  MOVE3(pc,d3),$0100 * LONG
02:00001C0E 67FE            	  2611:             beq.s *                       * Check Z Flag  beq/bne
02:00001C10 6BFE            	  2612:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001C12 0CB967FE6BFE0000	  2613:             cmpi.l #$67FE6BFE,8+MOVE3
02:00001C1A 1BFA
02:00001C1C 66FE            	  2614:             bne.s *                       * Check Z Flag  beq/bne
                            	  2615: 
                            	  2616: *     #x -->    n(An,AL)
02:00001C1E 21BC787823231006	  2617:             move.l  #$78782323,6(a0,d1.w)    * LONG
02:00001C26 67FE            	  2618:             beq.s *                       * Check Z Flag  beq/bne
02:00001C28 6BFE            	  2619:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001C2A 0CB0787823231006	  2620:             cmpi.l #$78782323,6(a0,d1.w)
02:00001C32 66FE            	  2621:             bne.s *                       * Check Z Flag  beq/bne
                            	  2622: 
                            	  2623: 
02:00001C34 4E75            	  2624:          rts
                            	  2625: 
                            	  2626: 
                            	  2627: *-----------------------------------------------------------
                            	  2628: *-----------------------------------------------------------
                            	  2629: * OPCODE : MOVE_xxx_FLAGS
                            	  2630: *-----------------------------------------------------------
                            	  2631: *-----------------------------------------------------------
                            	  2632: op_MOVE_xxx_FLAGS:
                            	  2633: 
                            	  2634: *     Move_To_SR
                            	  2635: 
                            	  2636: *     Dn
                            	  2637: 
02:00001C36 303C2FFF        	  2638:             move.w #$2FFF,d0
02:00001C3A 46C0            	  2639:             move.w d0,SR
02:00001C3C 6AFE            	  2640:             bpl.s *           * branch if Z clear
02:00001C3E 66FE            	  2641:             bne.s *           * branch if N clear
02:00001C40 68FE            	  2642:             bvc.s *           * branch if V clear
02:00001C42 64FE            	  2643:             bcc.s *           * branch if C clear
02:00001C44 303C2F00        	  2644:             move.w #$2F00,d0
02:00001C48 44C0            	  2645:             move d0,CCR
02:00001C4A 67FE            	  2646:             beq.s *           * branch if Z set
02:00001C4C 6BFE            	  2647:             bmi.s *           * branch if N set
02:00001C4E 69FE            	  2648:             bvs.s *           * branch if V set
02:00001C50 65FE            	  2649:             bcs.s *           * branch if C set
                            	  2650: 
02:00001C52 303C2000        	  2651:             move.w #$2000,d0
02:00001C56 46C0            	  2652:             move.w d0,SR
02:00001C58 67FE            	  2653:             beq.s *           * branch if Z set
02:00001C5A 6BFE            	  2654:             bmi.s *           * branch if N set
02:00001C5C 69FE            	  2655:             bvs.s *           * branch if V set
02:00001C5E 65FE            	  2656:             bcs.s *           * branch if C set
                            	  2657: 
                            	  2658: *     (An)
02:00001C60 307C0100        	  2659:             move.l #$00000100,a0
02:00001C64 30BC2FFF        	  2660:             move.w #$2FFF,(a0)
02:00001C68 46D0            	  2661:             move.w (a0),SR
02:00001C6A 6AFE            	  2662:             bpl.s *           * branch if Z clear
02:00001C6C 66FE            	  2663:             bne.s *           * branch if N clear
02:00001C6E 68FE            	  2664:             bvc.s *           * branch if V clear
02:00001C70 64FE            	  2665:             bcc.s *           * branch if C clear
                            	  2666: 
02:00001C72 30BC2000        	  2667:             move.w #$2000,(a0)
02:00001C76 46D0            	  2668:             move.w (a0),SR
02:00001C78 67FE            	  2669:             beq.s *           * branch if Z set
02:00001C7A 6BFE            	  2670:             bmi.s *           * branch if N set
02:00001C7C 69FE            	  2671:             bvs.s *           * branch if V set
02:00001C7E 65FE            	  2672:             bcs.s *           * branch if C set
                            	  2673: 
                            	  2674: *     (An)+
02:00001C80 307C0100        	  2675:             move.l #$00000100,a0
02:00001C84 30BC2FFF        	  2676:             move.w #$2FFF,(a0)
02:00001C88 46D8            	  2677:             move.w (a0)+,SR
02:00001C8A 6AFE            	  2678:             bpl.s *           * branch if Z clear
02:00001C8C 66FE            	  2679:             bne.s *           * branch if N clear
02:00001C8E 68FE            	  2680:             bvc.s *           * branch if V clear
02:00001C90 64FE            	  2681:             bcc.s *           * branch if C clear
                            	  2682: 
02:00001C92 30BC2000        	  2683:             move.w #$2000,(a0)
02:00001C96 46D8            	  2684:             move.w (a0)+,SR
02:00001C98 67FE            	  2685:             beq.s *           * branch if Z set
02:00001C9A 6BFE            	  2686:             bmi.s *           * branch if N set
02:00001C9C 69FE            	  2687:             bvs.s *           * branch if V set
02:00001C9E 65FE            	  2688:             bcs.s *           * branch if C set
                            	  2689: 
                            	  2690: *     -(An)
02:00001CA0 307C0102        	  2691:             move.l #$00000102,a0
02:00001CA4 30BC2FFF        	  2692:             move.w #$2FFF,(a0)
02:00001CA8 46D8            	  2693:             move.w (a0)+,SR
02:00001CAA 6AFE            	  2694:             bpl.s *           * branch if Z clear
02:00001CAC 66FE            	  2695:             bne.s *           * branch if N clear
02:00001CAE 68FE            	  2696:             bvc.s *           * branch if V clear
02:00001CB0 64FE            	  2697:             bcc.s *           * branch if C clear
                            	  2698: 
02:00001CB2 30BC2000        	  2699:             move.w #$2000,(a0)
02:00001CB6 46D8            	  2700:             move.w (a0)+,SR
02:00001CB8 67FE            	  2701:             beq.s *           * branch if Z set
02:00001CBA 6BFE            	  2702:             bmi.s *           * branch if N set
02:00001CBC 69FE            	  2703:             bvs.s *           * branch if V set
02:00001CBE 65FE            	  2704:             bcs.s *           * branch if C set
                            	  2705: 
                            	  2706: *     n(An)
02:00001CC0 307C0102        	  2707:             move.l #$00000102,a0
02:00001CC4 317C2FFF0002    	  2708:             move.w #$2FFF,2(a0)
02:00001CCA 46E80002        	  2709:             move.w 2(a0),SR
02:00001CCE 6AFE            	  2710:             bpl.s *           * branch if Z clear
02:00001CD0 66FE            	  2711:             bne.s *           * branch if N clear
02:00001CD2 68FE            	  2712:             bvc.s *           * branch if V clear
02:00001CD4 64FE            	  2713:             bcc.s *           * branch if C clear
                            	  2714: 
02:00001CD6 317C20000002    	  2715:             move.w #$2000,2(a0)
02:00001CDC 46E80002        	  2716:             move.w 2(a0),SR
02:00001CE0 67FE            	  2717:             beq.s *           * branch if Z set
02:00001CE2 6BFE            	  2718:             bmi.s *           * branch if N set
02:00001CE4 69FE            	  2719:             bvs.s *           * branch if V set
02:00001CE6 65FE            	  2720:             bcs.s *           * branch if C set
                            	  2721: 
                            	  2722: *     n(An,Rn.l)
02:00001CE8 307C0100        	  2723:             move.l #$00000100,a0
02:00001CEC 7002            	  2724:             moveq  #$00000002,d0
02:00001CEE 31BC2FFF0802    	  2725:             move.w #$2FFF,2(a0,d0.l)
02:00001CF4 46F00802        	  2726:             move.w 2(a0,d0.l),SR
02:00001CF8 6AFE            	  2727:             bpl.s *           * branch if Z clear
02:00001CFA 66FE            	  2728:             bne.s *           * branch if N clear
02:00001CFC 68FE            	  2729:             bvc.s *           * branch if V clear
02:00001CFE 64FE            	  2730:             bcc.s *           * branch if C clear
                            	  2731: 
02:00001D00 31BC20000802    	  2732:             move.w #$2000,2(a0,d0.l)
02:00001D06 46F00802        	  2733:             move.w 2(a0,d0.l),SR
02:00001D0A 67FE            	  2734:             beq.s *           * branch if Z set
02:00001D0C 6BFE            	  2735:             bmi.s *           * branch if N set
02:00001D0E 69FE            	  2736:             bvs.s *           * branch if V set
02:00001D10 65FE            	  2737:             bcs.s *           * branch if C set
                            	  2738: 
                            	  2739: *     x.W
02:00001D12 31FC2FFF0100    	  2740:             move.w #$2FFF,$0100
02:00001D18 46F80100        	  2741:             move.w $0100,SR
02:00001D1C 6AFE            	  2742:             bpl.s *           * branch if Z clear
02:00001D1E 66FE            	  2743:             bne.s *           * branch if N clear
02:00001D20 68FE            	  2744:             bvc.s *           * branch if V clear
02:00001D22 64FE            	  2745:             bcc.s *           * branch if C clear
                            	  2746: 
02:00001D24 31FC20000100    	  2747:             move.w #$2000,$0100
02:00001D2A 46F80100        	  2748:             move.w $0100,SR
02:00001D2E 67FE            	  2749:             beq.s *           * branch if Z set
02:00001D30 6BFE            	  2750:             bmi.s *           * branch if N set
02:00001D32 69FE            	  2751:             bvs.s *           * branch if V set
02:00001D34 65FE            	  2752:             bcs.s *           * branch if C set
                            	  2753: 
                            	  2754: *     x.L
02:00001D36 33FC2FFF00010100	  2755:             move.w #$2FFF,$00010100
02:00001D3E 46F900010100    	  2756:             move.w $00010100,SR
02:00001D44 6AFE            	  2757:             bpl.s *           * branch if Z clear
02:00001D46 66FE            	  2758:             bne.s *           * branch if N clear
02:00001D48 68FE            	  2759:             bvc.s *           * branch if V clear
02:00001D4A 64FE            	  2760:             bcc.s *           * branch if C clear
                            	  2761: 
02:00001D4C 33FC200000010100	  2762: MOVE4:      move.w #$2000,$00010100
02:00001D54 46F900010100    	  2763:             move.w $00010100,SR
02:00001D5A 67FE            	  2764:             beq.s *           * branch if Z set
02:00001D5C 6BFE            	  2765:             bmi.s *           * branch if N set
02:00001D5E 69FE            	  2766:             bvs.s *           * branch if V set
02:00001D60 65FE            	  2767:             bcs.s *           * branch if C set
                            	  2768: 
                            	  2769: *     x(PC)
02:00001D62 46FAFFEA        	  2770:             move.w MOVE4+2(pc),SR
02:00001D66 67FE            	  2771:             beq.s *           * branch if Z set
02:00001D68 6BFE            	  2772:             bmi.s *           * branch if N set
02:00001D6A 69FE            	  2773:             bvs.s *           * branch if V set
02:00001D6C 65FE            	  2774:             bcs.s *           * branch if C set
                            	  2775: 
                            	  2776: *     x(PC,d0.l)
02:00001D6E 7000            	  2777:             moveq  #$00000000,d0
02:00001D70 46FB08DC        	  2778:             move.w MOVE4+2(pc,d0.l),SR
02:00001D74 67FE            	  2779:             beq.s *           * branch if Z set
02:00001D76 6BFE            	  2780:             bmi.s *           * branch if N set
02:00001D78 69FE            	  2781:             bvs.s *           * branch if V set
02:00001D7A 65FE            	  2782:             bcs.s *           * branch if C set
02:00001D7C 44FB08D0        	  2783:             move MOVE4+2(pc,d0.l),CCR
02:00001D80 67FE            	  2784:             beq.s *           * branch if Z set
02:00001D82 6BFE            	  2785:             bmi.s *           * branch if N set
02:00001D84 69FE            	  2786:             bvs.s *           * branch if V set
02:00001D86 65FE            	  2787:             bcs.s *           * branch if C set
                            	  2788: 
                            	  2789: *     #x
02:00001D88 46FC2FFF        	  2790:             move.w #$2FFF,SR
02:00001D8C 66FE            	  2791:             bne.s *           * branch if Z clear
02:00001D8E 6AFE            	  2792:             bpl.s *           * branch if N clear
02:00001D90 68FE            	  2793:             bvc.s *           * branch if V clear
02:00001D92 64FE            	  2794:             bcc.s *           * branch if C clear
                            	  2795: 
                            	  2796: 
                            	  2797: 
                            	  2798: *  MOVE_From_SR
                            	  2799: 
                            	  2800: 
                            	  2801: 
                            	  2802: *     Dn
02:00001D94 46FC275A        	  2803:             move.w #$275A,SR          * Initial value
02:00001D98 40C0            	  2804:             move.w SR,d0
02:00001D9A 0C40271A        	  2805:             cmpi.w #$271A,d0
                            	  2806: * The following fails because sr bits are implemented and non-zero so later code works.           
                            	  2807: *            bne.s *                   * branch if Z set
                            	  2808: 
                            	  2809: *     (An)
02:00001D9E 307C0100        	  2810:             move.l #$00000100,a0
02:00001DA2 46FC275A        	  2811:             move.w #$275A,SR          * Initial value
02:00001DA6 40D0            	  2812:             move.w SR,(a0)
02:00001DA8 0C50275A        	  2813:             cmpi.w #$275A,(a0)
02:00001DAC 66FE            	  2814:             bne.s *                   * branch if Z set
                            	  2815: 
                            	  2816: *     (An)+
02:00001DAE 307C0100        	  2817:             move.l #$00000100,a0
02:00001DB2 46FC257A        	  2818:             move.w #$257A,SR          * Initial value
02:00001DB6 40D8            	  2819:             move.w SR,(a0)+
02:00001DB8 307C0100        	  2820:             move.l #$00000100,a0
02:00001DBC 0C58257A        	  2821:             cmpi.w #$257A,(a0)+
02:00001DC0 66FE            	  2822:             bne.s *                   * branch if Z set
                            	  2823: 
                            	  2824: *     -(An)
02:00001DC2 307C0102        	  2825:             move.l #$00000102,a0
02:00001DC6 46FC2766        	  2826:             move.w #$2766,SR          * Initial value
02:00001DCA 40E0            	  2827:             move.w SR,-(a0)
02:00001DCC 307C0100        	  2828:             move.l #$00000100,a0
02:00001DD0 0C502766        	  2829:             cmpi.w #$2766,(a0)
02:00001DD4 66FE            	  2830:             bne.s *                   * branch if Z set
                            	  2831: 
                            	  2832: *     x(An)
02:00001DD6 307C0102        	  2833:             move.l #$00000102,a0
02:00001DDA 46FC2733        	  2834:             move.w #$2733,SR          * Initial value
02:00001DDE 40E80004        	  2835:             move.w SR,4(a0)
02:00001DE2 0C6827330004    	  2836:             cmpi.w #$2733,4(a0)
02:00001DE8 66FE            	  2837:             bne.s *                   * branch if Z set
                            	  2838: 
                            	  2839: *     x(An,rn)
02:00001DEA 307C0102        	  2840:             move.l #$00000102,a0
02:00001DEE 7004            	  2841:             moveq  #$00000004,d0
02:00001DF0 46FC275A        	  2842:             move.w #$275a,SR          * Initial value
02:00001DF4 40F00804        	  2843:             move.w SR,4(a0,d0.l)
02:00001DF8 0C70275A0804    	  2844:             cmpi.w #$275a,4(a0,d0.l)
02:00001DFE 66FE            	  2845:             bne.s *                   * branch if Z set
                            	  2846: 
                            	  2847: *     x.W
02:00001E00 46FC2777        	  2848:             move.w #$2777,SR          * Initial value
02:00001E04 40F80102        	  2849:             move.w SR,$0102
02:00001E08 0C7827770102    	  2850:             cmpi.w #$2777,$0102
02:00001E0E 66FE            	  2851:             bne.s *                   * branch if Z set
                            	  2852: 
                            	  2853: *     x.L
02:00001E10 46FC2777        	  2854:             move.w #$2777,SR          * Initial value
02:00001E14 40F900010102    	  2855:             move.w SR,$10102
02:00001E1A 0C79277700010102	  2856:             cmpi.w #$2777,$10102
02:00001E22 66FE            	  2857:             bne.s *                   * branch if Z set
                            	  2858: 
                            	  2859: 
                            	  2860: 
02:00001E24 46FC2700        	  2861:             move.w #$2700,SR          * Put flags back to initial value
                            	  2862: 
02:00001E28 4E75            	  2863:             rts
                            	  2864: 
                            	  2865: 
                            	  2866: *-----------------------------------------------------------
                            	  2867: *-----------------------------------------------------------
                            	  2868: * OPCODE : EXT
                            	  2869: *-----------------------------------------------------------
                            	  2870: *-----------------------------------------------------------
                            	  2871: op_EXT:
                            	  2872: 
02:00001E2A 707F            	  2873:             move.l #$0000007F,d0
02:00001E2C 223C00008FFF    	  2874:             move.l #$00008FFF,d1
02:00001E32 7400            	  2875:             moveq  #$00000000,d2
                            	  2876: 
02:00001E34 4880            	  2877:             ext.w d0
02:00001E36 6BFE            	  2878:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001E38 67FE            	  2879:             beq.s *                   * Check Z Flag  beq/bne
02:00001E3A 0C800000007F    	  2880:             cmpi.l #$0000007F,d0
02:00001E40 66FE            	  2881:             bne.s *                   * branch if Z set
                            	  2882: 
02:00001E42 48C1            	  2883:             ext.l d1
02:00001E44 6AFE            	  2884:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001E46 67FE            	  2885:             beq.s *                   * Check Z Flag  beq/bne
02:00001E48 0C81FFFF8FFF    	  2886:             cmpi.l #$FFFF8FFF,d1
02:00001E4E 66FE            	  2887:             bne.s *                   * branch if Z set
                            	  2888: 
02:00001E50 48C2            	  2889:             ext.l d2
02:00001E52 66FE            	  2890:             bne.s *                   * Check Z Flag  beq/bne
                            	  2891: 
                            	  2892: 
                            	  2893: 
02:00001E54 4E75            	  2894:             rts
                            	  2895: 
                            	  2896: 
                            	  2897: *-----------------------------------------------------------
                            	  2898: *-----------------------------------------------------------
                            	  2899: * OPCODE : SWAP
                            	  2900: *-----------------------------------------------------------
                            	  2901: *-----------------------------------------------------------
                            	  2902: op_SWAP:
                            	  2903: 
02:00001E56 203C12345678    	  2904:             move.l #$12345678,d0
                            	  2905: 
02:00001E5C 4840            	  2906:             swap d0
02:00001E5E 6BFE            	  2907:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001E60 67FE            	  2908:             beq.s *                   * Check Z Flag  beq/bne
02:00001E62 0C8056781234    	  2909:             cmpi.l #$56781234,d0
02:00001E68 66FE            	  2910:             bne.s *                   * branch if Z set
                            	  2911: 
                            	  2912: 
                            	  2913: 
02:00001E6A 4E75            	  2914:             rts
                            	  2915: 
                            	  2916: 
                            	  2917: *-----------------------------------------------------------
                            	  2918: *-----------------------------------------------------------
                            	  2919: * OPCODE : LEA_PEA
                            	  2920: *-----------------------------------------------------------
                            	  2921: *-----------------------------------------------------------
                            	  2922: op_LEAPEA:
                            	  2923: 
02:00001E6C 207C00345678    	  2924:             move.l #$00345678,a0
02:00001E72 7800            	  2925:             moveq  #$00000000,d4
                            	  2926: 
                            	  2927: *     (An)
02:00001E74 4DD0            	  2928:             lea (a0),a6
02:00001E76 200E            	  2929:             move.l a6,d0
02:00001E78 0C8000345678    	  2930:             cmpi.l #$00345678,d0
02:00001E7E 66FE            	  2931:             bne.s *                   * branch if Z set
02:00001E80 4850            	  2932:             pea (a0)
02:00001E82 0C9700345678    	  2933:             cmpi.l #$00345678,(a7)
02:00001E88 66FE            	  2934:             bne.s *                   * branch if Z set
                            	  2935:             * This was without a specifier which the assembler defaulted to .w
02:00001E8A 588F            	  2936:             addq.l #4,a7            * Restore Stack Pointer
                            	  2937: 
                            	  2938: *     x(An)
02:00001E8C 4DE80004        	  2939:             lea 4(a0),a6
02:00001E90 200E            	  2940:             move.l a6,d0
02:00001E92 0C800034567C    	  2941:             cmpi.l #$0034567C,d0
02:00001E98 66FE            	  2942:             bne.s *                   * branch if Z set
02:00001E9A 48680004        	  2943:             pea 4(a0)
02:00001E9E 0C970034567C    	  2944:             cmpi.l #$0034567C,(a7)
02:00001EA4 66FE            	  2945:             bne.s *                   * branch if Z set
                            	  2946:             * This was without a specifier which the assembler defaulted to .w
02:00001EA6 588F            	  2947:             addq.l #4,a7            * Restore Stack Pointer
                            	  2948: 
                            	  2949: *     x(An,Dn.l)
02:00001EA8 4DF04004        	  2950:             lea 4(a0,d4),a6
02:00001EAC 200E            	  2951:             move.l a6,d0
02:00001EAE 0C800034567C    	  2952:             cmpi.l #$0034567C,d0
02:00001EB4 66FE            	  2953:             bne.s *                   * branch if Z set
02:00001EB6 48704804        	  2954:             pea 4(a0,d4.l)
02:00001EBA 0C970034567C    	  2955:             cmpi.l #$0034567C,(a7)
02:00001EC0 66FE            	  2956:             bne.s *                   * branch if Z set
                            	  2957:             * This was without a specifier which the assembler defaulted to .w
02:00001EC2 588F            	  2958:             addq.l #4,a7            * Restore Stack Pointer
                            	  2959: 
                            	  2960: *     x.W
02:00001EC4 4DF81234        	  2961:             lea $1234,a6
02:00001EC8 200E            	  2962:             move.l a6,d0
02:00001ECA 0C401234        	  2963:             cmpi.w #$1234,d0
02:00001ECE 66FE            	  2964:             bne.s *                   * branch if Z set
02:00001ED0 48781234        	  2965:             pea $1234
02:00001ED4 0C9700001234    	  2966:             cmpi.l #$00001234,(a7)
02:00001EDA 66FE            	  2967:             bne.s *                   * branch if Z set
                            	  2968:             * This was without a specifier which the assembler defaulted to .w
02:00001EDC 588F            	  2969:             addq.l #4,a7            * Restore Stack Pointer
                            	  2970: 
                            	  2971: *     x.L
02:00001EDE 4DF900345678    	  2972:             lea $00345678,a6
02:00001EE4 200E            	  2973:             move.l a6,d0
02:00001EE6 B08E            	  2974:             cmp.l a6,d0
02:00001EE8 66FE            	  2975:             bne.s *                   * branch if Z set
02:00001EEA 487900345678    	  2976:             pea $00345678
02:00001EF0 0C9700345678    	  2977:             cmpi.l #$00345678,(a7)
02:00001EF6 66FE            	  2978:             bne.s *                   * branch if Z set
                            	  2979:             * This was without a specifier which the assembler defaulted to .w
02:00001EF8 588F            	  2980:             addq.l #4,a7            * Restore Stack Pointer
                            	  2981: 
                            	  2982: *     x(PC)
02:00001EFA 4DFA0008        	  2983:             lea LEA1(pc),a6
02:00001EFE 200E            	  2984:             move.l a6,d0
02:00001F00 B08E            	  2985:             cmp.l a6,d0
02:00001F02 66FE            	  2986:             bne.s *                   * branch if Z set
02:00001F04 487AFFFE        	  2987: LEA1:       pea LEA1(pc)
02:00001F08 0C970000241E    	  2988:             cmpi.l #$0000241E,(a7)
02:00001F0E 67FE            	  2989:             beq.s *                   * branch if Z clear
                            	  2990:             * This was without a specifier which the assembler defaulted to .w
02:00001F10 588F            	  2991:             addq.l #4,a7              * Restore Stack Pointer
                            	  2992: 
                            	  2993: 
                            	  2994: 
                            	  2995: 
02:00001F12 46FC2700        	  2996:             move.w #$2700,sr          * Put flags back to initial value
                            	  2997: 
02:00001F16 4E75            	  2998:             rts
                            	  2999:  	
                            	  3000: 
                            	  3001: 
                            	  3002: *-----------------------------------------------------------
                            	  3003: *-----------------------------------------------------------
                            	  3004: * OPCODE : LEA_TAS
                            	  3005: *-----------------------------------------------------------
                            	  3006: *-----------------------------------------------------------
                            	  3007: op_TAS:
                            	  3008: 
                            	  3009: *     Test just one addressing mode
                            	  3010: 
02:00001F18 307C0100        	  3011:             move.l #$00000100,a0
                            	  3012: 
                            	  3013: *     (An)
02:00001F1C 4210            	  3014:             move.b #$00,(a0)
02:00001F1E 6BFE            	  3015:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F20 66FE            	  3016:             bne.s *                   * Check Z Flag  beq/bne
02:00001F22 4AD0            	  3017:             tas (a0)
02:00001F24 0C100080        	  3018:             cmpi.b #$80,(a0)
02:00001F28 66FE            	  3019:             bne.s *                   * branch if Z set
02:00001F2A 10BC00F5        	  3020:             move.b #$F5,(a0)
02:00001F2E 4AD0            	  3021:             tas (a0)
02:00001F30 6AFE            	  3022:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F32 67FE            	  3023:             beq.s *                   * Check Z Flag  beq/bne
02:00001F34 4AD0            	  3024:             tas (a0)
02:00001F36 0C1000F5        	  3025:             cmpi.b #$F5,(a0)
02:00001F3A 66FE            	  3026:             bne.s *                   * branch if Z set
                            	  3027: 
02:00001F3C 4E75            	  3028:             rts
                            	  3029: 
                            	  3030: 
                            	  3031: *-----------------------------------------------------------
                            	  3032: *-----------------------------------------------------------
                            	  3033: * OPCODE : LEA_TST
                            	  3034: *-----------------------------------------------------------
                            	  3035: *-----------------------------------------------------------
                            	  3036: op_TST:
                            	  3037: 
                            	  3038: *     Test just one addressing mode
                            	  3039: 
02:00001F3E 307C0100        	  3040:             move.l #$00000100,a0
                            	  3041: 
                            	  3042: *     (An) - BYTE
02:00001F42 4210            	  3043:             move.b #$00,(a0)
02:00001F44 4A10            	  3044:             tst.b (a0)
02:00001F46 6BFE            	  3045:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F48 66FE            	  3046:             bne.s *                   * Check Z Flag  beq/bne
02:00001F4A 10BC00F5        	  3047:             move.b #$F5,(a0)
02:00001F4E 4A10            	  3048:             tst.b (a0)
02:00001F50 6AFE            	  3049:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F52 67FE            	  3050:             beq.s *                   * Check Z Flag  beq/bne
                            	  3051: 
                            	  3052: *     (An) - WORD
02:00001F54 4250            	  3053:             move.w #$0000,(a0)
02:00001F56 4A50            	  3054:             tst.w (a0)
02:00001F58 6BFE            	  3055:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F5A 66FE            	  3056:             bne.s *                   * Check Z Flag  beq/bne
02:00001F5C 30BCF567        	  3057:             move.w #$F567,(a0)
02:00001F60 4A50            	  3058:             tst.w (a0)
02:00001F62 6AFE            	  3059:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F64 67FE            	  3060:             beq.s *                   * Check Z Flag  beq/bne
                            	  3061: 
                            	  3062: *     (An) - LONG
02:00001F66 4290            	  3063:             move.l #$00000000,(a0)
02:00001F68 4A90            	  3064:             tst.l (a0)
02:00001F6A 6BFE            	  3065:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F6C 66FE            	  3066:             bne.s *                   * Check Z Flag  beq/bne
02:00001F6E 20BCF56789AB    	  3067:             move.l #$F56789ab,(a0)
02:00001F74 4A90            	  3068:             tst.l (a0)
02:00001F76 6AFE            	  3069:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F78 67FE            	  3070:             beq.s *                   * Check Z Flag  beq/bne
                            	  3071: 
                            	  3072: 
02:00001F7A 4E75            	  3073:             rts
                            	  3074: 
                            	  3075: 
                            	  3076: *-----------------------------------------------------------
                            	  3077: *-----------------------------------------------------------
                            	  3078: * OPCODE : LINKS
                            	  3079: *-----------------------------------------------------------
                            	  3080: *-----------------------------------------------------------
                            	  3081: op_LINKS:
                            	  3082: 
02:00001F7C 207C11223344    	  3083:             move.l #$11223344,a0
02:00001F82 203C11223344    	  3084:             move.l #$11223344,d0
02:00001F88 4E500000        	  3085:             link a0,#$0
02:00001F8C 0C9711223344    	  3086:             cmpi.l #$11223344,(a7)
                            	  3087: 
02:00001F92 4E58            	  3088:             unlk a0
02:00001F94 B1C0            	  3089:             cmp.l d0,a0
02:00001F96 66FE            	  3090:             bne.s *                   * branch if Z set
                            	  3091: 
02:00001F98 4E75            	  3092:             rts
                            	  3093: 
                            	  3094: *-----------------------------------------------------------
                            	  3095: *-----------------------------------------------------------
                            	  3096: * OPCODE : MOVE_USP
                            	  3097: *-----------------------------------------------------------
                            	  3098: *-----------------------------------------------------------
                            	  3099: op_MOVE_USP:
                            	  3100: 
02:00001F9A 207C11223344    	  3101:             move.l #$11223344,a0
02:00001FA0 4E60            	  3102:             move a0,USP
02:00001FA2 4E69            	  3103:             move USP,a1
02:00001FA4 B3C8            	  3104:             cmp.l a0,a1
02:00001FA6 66FE            	  3105:             bne.s *                   * branch if Z set
                            	  3106: 
02:00001FA8 4E75            	  3107:             rts
                            	  3108: 
                            	  3109: 
                            	  3110: *-----------------------------------------------------------
                            	  3111: *-----------------------------------------------------------
                            	  3112: * OPCODE : CHK
                            	  3113: *-----------------------------------------------------------
                            	  3114: *-----------------------------------------------------------
                            	  3115: op_CHK:
02:00001FAA 303C1122        	  3116:             move.w #$1122,d0
02:00001FAE 323C1122        	  3117:             move.w #$1122,d1
02:00001FB2 4380            	  3118:             chk d0,d1
                            	  3119: 
02:00001FB4 4E71            	  3120:             nop
02:00001FB6 4E71            	  3121:             nop
                            	  3122: 
02:00001FB8 323C1122        	  3123:             move.w #$1122,d1
02:00001FBC 43BC1122        	  3124:             chk #$1122,d1
                            	  3125: 
02:00001FC0 323C1122        	  3126:             move.w #$1122,d1
02:00001FC4 43BC007A        	  3127:             chk #00122,d1
02:00001FC8 BCBCEEEE0006    	  3128:             cmp.l #$EEEE0006,d6
02:00001FCE 66FE            	  3129:             bne.s *                   * branch if Z set
                            	  3130: 
02:00001FD0 303C1122        	  3131:             move.w #$1122,d0
02:00001FD4 323C8000        	  3132:             move.w #$8000,d1
02:00001FD8 4380            	  3133:             chk d0,d1
02:00001FDA BCBCEEEE0006    	  3134:             cmp.l #$EEEE0006,d6
02:00001FE0 66FE            	  3135:             bne.s *                   * branch if Z set
                            	  3136: 
02:00001FE2 4E75            	  3137:             rts
                            	  3138: 
                            	  3139: 
                            	  3140: *-----------------------------------------------------------
                            	  3141: *-----------------------------------------------------------
                            	  3142: * OPCODE : NEGS
                            	  3143: *-----------------------------------------------------------
                            	  3144: *-----------------------------------------------------------
                            	  3145: op_NEGS:
                            	  3146: 
                            	  3147: *     NOT - BYTE
02:00001FE4 307C0100        	  3148:             move.l #$00000100,a0
02:00001FE8 7000            	  3149:             moveq  #$00000000,d0
02:00001FEA 4600            	  3150:             not.b d0
02:00001FEC 6AFE            	  3151:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001FEE 67FE            	  3152:             beq.s *                   * Check Z Flag  beq/bne
02:00001FF0 4600            	  3153:             not.b d0
02:00001FF2 6BFE            	  3154:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001FF4 66FE            	  3155:             bne.s *                   * Check Z Flag  beq/bne
02:00001FF6 4A00            	  3156:             cmpi.b #$00,d0
02:00001FF8 66FE            	  3157:             bne.s *                   * Check Z Flag  beq/bne
02:00001FFA 10BC0080        	  3158:             move.b #$80,(a0)
02:00001FFE 4610            	  3159:             not.b (a0)
02:00002000 6BFE            	  3160:             bmi.s *                   * Check N Flag  bmi/bpl
02:00002002 67FE            	  3161:             beq.s *                   * Check Z Flag  beq/bne
02:00002004 4610            	  3162:             not.b (a0)
02:00002006 6AFE            	  3163:             bpl.s *                   * Check N Flag  bmi/bpl
02:00002008 67FE            	  3164:             beq.s *                   * Check Z Flag  beq/bne
02:0000200A 0C100080        	  3165:             cmpi.b #$80,(a0)
02:0000200E 66FE            	  3166:             bne.s *                   * Check Z Flag  beq/bne
                            	  3167: 
                            	  3168: *     NOT - WORD
02:00002010 307C0100        	  3169:             move.l #$00000100,a0
02:00002014 7000            	  3170:             moveq  #$00000000,d0
02:00002016 4640            	  3171:             not.w d0
02:00002018 6AFE            	  3172:             bpl.s *                   * Check N Flag  bmi/bpl
02:0000201A 67FE            	  3173:             beq.s *                   * Check Z Flag  beq/bne
02:0000201C 4640            	  3174:             not.w d0
02:0000201E 6BFE            	  3175:             bmi.s *                   * Check N Flag  bmi/bpl
02:00002020 66FE            	  3176:             bne.s *                   * Check Z Flag  beq/bne
02:00002022 4A40            	  3177:             cmpi.w #$0000,d0
02:00002024 66FE            	  3178:             bne.s *                   * Check Z Flag  beq/bne
02:00002026 30BC5A5A        	  3179:             move.w #$5a5a,(a0)
02:0000202A 4650            	  3180:             not.w (a0)
02:0000202C 6AFE            	  3181:             bpl.s *                   * Check N Flag  bmi/bpl
02:0000202E 67FE            	  3182:             beq.s *                   * Check Z Flag  beq/bne
02:00002030 4650            	  3183:             not.w (a0)
02:00002032 6BFE            	  3184:             bmi.s *                   * Check N Flag  bmi/bpl
02:00002034 67FE            	  3185:             beq.s *                   * Check Z Flag  beq/bne
02:00002036 0C505A5A        	  3186:             cmpi.w #$5a5a,(a0)
02:0000203A 66FE            	  3187:             bne.s *                   * Check Z Flag  beq/bne
                            	  3188: 
                            	  3189: *     NOT - LONG
02:0000203C 307C0100        	  3190:             move.l #$00000100,a0
02:00002040 7000            	  3191:             moveq  #$00000000,d0
02:00002042 4680            	  3192:             not.l d0
02:00002044 6AFE            	  3193:             bpl.s *                   * Check N Flag  bmi/bpl
02:00002046 67FE            	  3194:             beq.s *                   * Check Z Flag  beq/bne
02:00002048 4680            	  3195:             not.l d0
02:0000204A 6BFE            	  3196:             bmi.s *                   * Check N Flag  bmi/bpl
02:0000204C 66FE            	  3197:             bne.s *                   * Check Z Flag  beq/bne
02:0000204E 4A80            	  3198:             cmpi.l #$00000000,d0
02:00002050 66FE            	  3199:             bne.s *                   * Check Z Flag  beq/bne
02:00002052 20BC5A5A1234    	  3200:             move.l #$5a5a1234,(a0)
02:00002058 4690            	  3201:             not.l (a0)
02:0000205A 6AFE            	  3202:             bpl.s *                   * Check N Flag  bmi/bpl
02:0000205C 67FE            	  3203:             beq.s *                   * Check Z Flag  beq/bne
02:0000205E 4690            	  3204:             not.l (a0)
02:00002060 6BFE            	  3205:             bmi.s *                   * Check N Flag  bmi/bpl
02:00002062 67FE            	  3206:             beq.s *                   * Check Z Flag  beq/bne
02:00002064 0C905A5A1234    	  3207:             cmpi.l #$5a5a1234,(a0)
02:0000206A 66FE            	  3208:             bne.s *                   * Check Z Flag  beq/bne
                            	  3209: 
                            	  3210: * -----
                            	  3211: 
                            	  3212: *     NEG - BYTE
02:0000206C 307C0100        	  3213:             move.l #$00000100,a0
02:00002070 7000            	  3214:             moveq  #$00000000,d0
02:00002072 7240D241        	  3215:             move.l #$00000080,d1
02:00002076 4400            	  3216:             neg.b d0
02:00002078 6BFE            	  3217:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000207A 66FE            	  3218:             bne.s *                   * Check Z Flag  beq/bne 1
02:0000207C 65FE            	  3219:             bcs.s *                   * Check C Flag  bcc/bcs 1
02:0000207E 69FE            	  3220:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002080 4401            	  3221:             neg.b d1
02:00002082 6AFE            	  3222:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002084 67FE            	  3223:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002086 64FE            	  3224:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002088 68FE            	  3225:             bvc.s *                   * Check V Flag  bvc/bvs 0
02:0000208A 0C010080        	  3226:             cmpi.b #$80,d1
02:0000208E 66FE            	  3227:             bne.s *                   * Check Z Flag  beq/bne
02:00002090 10BC007F        	  3228:             move.b #$7F,(a0)
02:00002094 4410            	  3229:             neg.b (a0)
02:00002096 6AFE            	  3230:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002098 67FE            	  3231:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000209A 64FE            	  3232:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000209C 69FE            	  3233:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000209E 10BC00F5        	  3234:             move.b #$F5,(a0)
02:000020A2 4410            	  3235:             neg.b (a0)
02:000020A4 6BFE            	  3236:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000020A6 67FE            	  3237:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020A8 64FE            	  3238:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020AA 69FE            	  3239:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020AC 0C10000B        	  3240:             cmpi.b #$0B,(a0)
02:000020B0 66FE            	  3241:             bne.s *                   * Check Z Flag  beq/bne
                            	  3242: 
                            	  3243: * -----
                            	  3244: 
                            	  3245: *     NEG - WORD
02:000020B2 307C0100        	  3246:             move.l #$00000100,a0
02:000020B6 7000            	  3247:             moveq  #$00000000,d0
02:000020B8 223C00008000    	  3248:             move.l #$00008000,d1
02:000020BE 4440            	  3249:             neg.w d0
02:000020C0 6BFE            	  3250:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000020C2 66FE            	  3251:             bne.s *                   * Check Z Flag  beq/bne 1
02:000020C4 65FE            	  3252:             bcs.s *                   * Check C Flag  bcc/bcs 1
02:000020C6 69FE            	  3253:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020C8 4441            	  3254:             neg.w d1
02:000020CA 6AFE            	  3255:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000020CC 67FE            	  3256:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020CE 64FE            	  3257:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020D0 68FE            	  3258:             bvc.s *                   * Check V Flag  bvc/bvs 0
02:000020D2 0C418000        	  3259:             cmpi.w #$8000,d1
02:000020D6 66FE            	  3260:             bne.s *                   * Check Z Flag  beq/bne
02:000020D8 30BC7FFF        	  3261:             move.w #$7FFF,(a0)
02:000020DC 4450            	  3262:             neg.w (a0)
02:000020DE 6AFE            	  3263:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000020E0 67FE            	  3264:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020E2 64FE            	  3265:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020E4 69FE            	  3266:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020E6 30BCF578        	  3267:             move.w #$F578,(a0)
02:000020EA 4450            	  3268:             neg.w (a0)
02:000020EC 6BFE            	  3269:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000020EE 67FE            	  3270:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020F0 64FE            	  3271:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020F2 69FE            	  3272:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020F4 0C500A88        	  3273:             cmpi.w #$0A88,(a0)
02:000020F8 66FE            	  3274:             bne.s *                   * Check Z Flag  beq/bne
                            	  3275: 
                            	  3276: * -----
                            	  3277: 
                            	  3278: *     NEG - LONG
02:000020FA 307C0100        	  3279:             move.l #$00000100,a0
02:000020FE 7000            	  3280:             moveq  #$00000000,d0
02:00002100 223C80000000    	  3281:             move.l #$80000000,d1
02:00002106 4480            	  3282:             neg.l d0
02:00002108 6BFE            	  3283:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000210A 66FE            	  3284:             bne.s *                   * Check Z Flag  beq/bne 1
02:0000210C 65FE            	  3285:             bcs.s *                   * Check C Flag  bcc/bcs 1
02:0000210E 69FE            	  3286:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002110 4481            	  3287:             neg.l d1
02:00002112 6AFE            	  3288:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002114 67FE            	  3289:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002116 64FE            	  3290:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002118 68FE            	  3291:             bvc.s *                   * Check V Flag  bvc/bvs 0
02:0000211A 0C8180000000    	  3292:             cmpi.l #$80000000,d1
02:00002120 66FE            	  3293:             bne.s *                   * Check Z Flag  beq/bne
02:00002122 20BC7FFFFFFF    	  3294:             move.l #$7FFFFFFF,(a0)
02:00002128 4490            	  3295:             neg.l (a0)
02:0000212A 6AFE            	  3296:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:0000212C 67FE            	  3297:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000212E 64FE            	  3298:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002130 69FE            	  3299:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002132 20BCF5781234    	  3300:             move.l #$F5781234,(a0)
02:00002138 4490            	  3301:             neg.l (a0)
02:0000213A 6BFE            	  3302:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000213C 67FE            	  3303:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000213E 64FE            	  3304:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002140 69FE            	  3305:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002142 0C900A87EDCC    	  3306:             cmpi.l #$0A87EDCC,(a0)
02:00002148 66FE            	  3307:             bne.s *                   * Check Z Flag  beq/bne
                            	  3308: 
                            	  3309: 
                            	  3310: * -----
                            	  3311: 
                            	  3312: *     NEGX - BYTE
02:0000214A 307C0100        	  3313:             move.l #$00000100,a0
02:0000214E 7000            	  3314:             moveq  #$00000000,d0
02:00002150 7240D241        	  3315:             move.l #$00000080,d1
02:00002154 003C0010        	  3316:             ori.b #$10,CCR        * Set X Flag
02:00002158 4000            	  3317:             negx.b d0
02:0000215A 6AFE            	  3318:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:0000215C 67FE            	  3319:             beq.s *                   * Check Z Flag  beq/bne 1
02:0000215E 64FE            	  3320:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:00002160 69FE            	  3321:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002162 023C00EF        	  3322:             andi.b #$EF,CCR       * Clear X Flag
02:00002166 4000            	  3323:             negx.b d0
02:00002168 6BFE            	  3324:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000216A 67FE            	  3325:             beq.s *                   * Check Z Flag  beq/bne 1
02:0000216C 64FE            	  3326:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:0000216E 69FE            	  3327:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002170 003C0010        	  3328:             ori.b #$10,CCR        * Set X Flag
02:00002174 4001            	  3329:             negx.b d1
02:00002176 6BFE            	  3330:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:00002178 67FE            	  3331:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000217A 64FE            	  3332:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000217C 69FE            	  3333:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:0000217E 0C01007F        	  3334:             cmpi.b #$7F,d1
02:00002182 66FE            	  3335:             bne.s *                   * Check Z Flag  beq/bne
02:00002184 023C00EF        	  3336:             andi.b #$EF,CCR       * Clear X Flag
02:00002188 4001            	  3337:             negx.b d1
02:0000218A 6AFE            	  3338:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:0000218C 67FE            	  3339:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000218E 64FE            	  3340:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002190 69FE            	  3341:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:00002192 0C010081        	  3342:             cmpi.b #$81,d1
02:00002196 66FE            	  3343:             bne.s *                   * Check Z Flag  beq/bne
02:00002198 10BC007F        	  3344:             move.b #$7F,(a0)
02:0000219C 003C0010        	  3345:             ori.b #$10,CCR        * Set X Flag
02:000021A0 4010            	  3346:             negx.b (a0)
02:000021A2 6AFE            	  3347:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000021A4 67FE            	  3348:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021A6 64FE            	  3349:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3350:             * I think overflow should happen here.
                            	  3351: *            bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021A8 10BC007F        	  3352:             move.b #$7F,(a0)
02:000021AC 023C00EF        	  3353:             andi.b #$EF,CCR       * Clear X Flag
02:000021B0 4010            	  3354:             negx.b (a0)
02:000021B2 6AFE            	  3355:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000021B4 67FE            	  3356:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021B6 64FE            	  3357:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000021B8 69FE            	  3358:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021BA 10BC00F5        	  3359:             move.b #$F5,(a0)
02:000021BE 003C0010        	  3360:             ori.b #$10,CCR        * Set X Flag
02:000021C2 4010            	  3361:             negx.b (a0)
02:000021C4 6BFE            	  3362:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000021C6 67FE            	  3363:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021C8 64FE            	  3364:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000021CA 69FE            	  3365:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021CC 0C10000A        	  3366:             cmpi.b #$0A,(a0)
02:000021D0 66FE            	  3367:             bne.s *                   * Check Z Flag  beq/bne
02:000021D2 023C00EF        	  3368:             andi.b #$EF,CCR       * Clear X Flag
02:000021D6 4010            	  3369:             negx.b (a0)
02:000021D8 6AFE            	  3370:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:000021DA 67FE            	  3371:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021DC 64FE            	  3372:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000021DE 69FE            	  3373:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021E0 0C1000F6        	  3374:             cmpi.b #$F6,(a0)
02:000021E4 66FE            	  3375:             bne.s *                   * Check Z Flag  beq/bne
                            	  3376: 
                            	  3377: 
                            	  3378: 
                            	  3379: * -----
                            	  3380: 
                            	  3381: *     NEGX - WORD
02:000021E6 307C0100        	  3382:             move.l #$00000100,a0
02:000021EA 7000            	  3383:             moveq  #$00000000,d0
02:000021EC 223C00008000    	  3384:             move.l #$00008000,d1
02:000021F2 003C0010        	  3385:             ori.b #$10,CCR        * Set X Flag
02:000021F6 4040            	  3386:             negx.w d0
02:000021F8 6AFE            	  3387:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:000021FA 67FE            	  3388:             beq.s *                   * Check Z Flag  beq/bne 1
02:000021FC 64FE            	  3389:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:000021FE 69FE            	  3390:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002200 023C00EF        	  3391:             andi.b #$EF,CCR       * Clear X Flag
02:00002204 4040            	  3392:             negx.w d0
02:00002206 6BFE            	  3393:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002208 67FE            	  3394:             beq.s *                   * Check Z Flag  beq/bne 1
02:0000220A 64FE            	  3395:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:0000220C 69FE            	  3396:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000220E 003C0010        	  3397:             ori.b #$10,CCR        * Set X Flag
02:00002212 4041            	  3398:             negx.w d1
02:00002214 6BFE            	  3399:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:00002216 67FE            	  3400:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002218 64FE            	  3401:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000221A 69FE            	  3402:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:0000221C 0C417FFF        	  3403:             cmpi.w #$7FFF,d1
02:00002220 66FE            	  3404:             bne.s *                   * Check Z Flag  beq/bne
02:00002222 023C00EF        	  3405:             andi.b #$EF,CCR       * Clear X Flag
02:00002226 4041            	  3406:             negx.w d1
02:00002228 6AFE            	  3407:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:0000222A 67FE            	  3408:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000222C 64FE            	  3409:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000222E 69FE            	  3410:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:00002230 0C418001        	  3411:             cmpi.w #$8001,d1
02:00002234 66FE            	  3412:             bne.s *                   * Check Z Flag  beq/bne
02:00002236 30BC7FFF        	  3413:             move.w #$7FFF,(a0)
02:0000223A 003C0010        	  3414:             ori.b #$10,CCR        * Set X Flag
02:0000223E 4050            	  3415:             negx.w (a0)
02:00002240 6AFE            	  3416:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002242 67FE            	  3417:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002244 64FE            	  3418:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3419: ***            
                            	  3420: *            bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002246 30BCF567        	  3421:             move.w #$F567,(a0)
02:0000224A 023C00EF        	  3422:             andi.b #$EF,CCR       * Clear X Flag
02:0000224E 4050            	  3423:             negx.w (a0)
02:00002250 6BFE            	  3424:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:00002252 67FE            	  3425:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002254 64FE            	  3426:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002256 69FE            	  3427:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002258 30BCF567        	  3428:             move.w #$F567,(a0)
02:0000225C 003C0010        	  3429:             ori.b #$10,CCR        * Set X Flag
02:00002260 4050            	  3430:             negx.w (a0)
02:00002262 6BFE            	  3431:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002264 67FE            	  3432:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002266 64FE            	  3433:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002268 69FE            	  3434:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000226A 0C500A98        	  3435:             cmpi.w #$0A98,(a0)
02:0000226E 66FE            	  3436:             bne.s *                   * Check Z Flag  beq/bne
02:00002270 023C00EF        	  3437:             andi.b #$EF,CCR       * Clear X Flag
02:00002274 4050            	  3438:             negx.w (a0)
02:00002276 6AFE            	  3439:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:00002278 67FE            	  3440:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000227A 64FE            	  3441:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000227C 69FE            	  3442:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000227E 0C50F568        	  3443:             cmpi.w #$F568,(a0)
02:00002282 66FE            	  3444:             bne.s *                   * Check Z Flag  beq/bne
                            	  3445: 
                            	  3446: 
                            	  3447: * -----
                            	  3448: 
                            	  3449: *     NEGX - LONG
02:00002284 307C0100        	  3450:             move.l #$00000100,a0
02:00002288 7000            	  3451:             moveq  #$00000000,d0
02:0000228A 223C80000000    	  3452:             move.l #$80000000,d1
02:00002290 003C0010        	  3453:             ori.b #$10,CCR        * Set X Flag
02:00002294 4080            	  3454:             negx.l d0
02:00002296 6AFE            	  3455:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:00002298 67FE            	  3456:             beq.s *                   * Check Z Flag  beq/bne 1
02:0000229A 64FE            	  3457:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:0000229C 69FE            	  3458:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000229E 023C00EF        	  3459:             andi.b #$EF,CCR       * Clear X Flag
02:000022A2 4080            	  3460:             negx.l d0
02:000022A4 6BFE            	  3461:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000022A6 67FE            	  3462:             beq.s *                   * Check Z Flag  beq/bne 1
02:000022A8 64FE            	  3463:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:000022AA 69FE            	  3464:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000022AC 003C0010        	  3465:             ori.b #$10,CCR        * Set X Flag
02:000022B0 4081            	  3466:             negx.l d1
02:000022B2 6BFE            	  3467:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:000022B4 67FE            	  3468:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022B6 64FE            	  3469:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000022B8 69FE            	  3470:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:000022BA 0C817FFFFFFF    	  3471:             cmpi.l #$7FFFFFFF,d1
02:000022C0 66FE            	  3472:             bne.s *                   * Check Z Flag  beq/bne
02:000022C2 023C00EF        	  3473:             andi.b #$EF,CCR       * Clear X Flag
02:000022C6 4081            	  3474:             negx.l d1
02:000022C8 6AFE            	  3475:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000022CA 67FE            	  3476:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022CC 64FE            	  3477:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3478: ****            
                            	  3479: *            bvs.s *                   * Check V Flag  bvc/bvs 0
02:000022CE 0C8180000001    	  3480:             cmpi.l #$80000001,d1
02:000022D4 66FE            	  3481:             bne.s *                   * Check Z Flag  beq/bne
02:000022D6 20BC00007FFF    	  3482:             move.l #$7FFF,(a0)
02:000022DC 003C0010        	  3483:             ori.b #$10,CCR        * Set X Flag
02:000022E0 4090            	  3484:             negx.l (a0)
02:000022E2 6AFE            	  3485:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000022E4 67FE            	  3486:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022E6 64FE            	  3487:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3488: ****            
                            	  3489: *            bvs.s *                   * Check V Flag  bvc/bvs 1
02:000022E8 20BCF5671234    	  3490:             move.l #$F5671234,(a0)
02:000022EE 023C00EF        	  3491:             andi.b #$EF,CCR       * Clear X Flag
02:000022F2 4090            	  3492:             negx.l (a0)
02:000022F4 6BFE            	  3493:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:000022F6 67FE            	  3494:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022F8 64FE            	  3495:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000022FA 69FE            	  3496:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000022FC 20BCF5675678    	  3497:             move.l #$F5675678,(a0)
02:00002302 003C0010        	  3498:             ori.b #$10,CCR        * Set X Flag
02:00002306 4090            	  3499:             negx.l (a0)
02:00002308 6BFE            	  3500:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000230A 67FE            	  3501:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000230C 64FE            	  3502:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000230E 69FE            	  3503:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002310 0C900A98A987    	  3504:             cmpi.l #$0A98A987,(a0)
02:00002316 66FE            	  3505:             bne.s *                   * Check Z Flag  beq/bne
02:00002318 023C00EF        	  3506:             andi.b #$EF,CCR       * Clear X Flag
02:0000231C 4090            	  3507:             negx.l (a0)
02:0000231E 6AFE            	  3508:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:00002320 67FE            	  3509:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002322 64FE            	  3510:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002324 69FE            	  3511:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002326 0C90F5675679    	  3512:             cmpi.l #$F5675679,(a0)
02:0000232C 66FE            	  3513:             bne.s *                   * Check Z Flag  beq/bne
                            	  3514: 
                            	  3515: 
                            	  3516: * -----
                            	  3517: 
                            	  3518: *     CLR - BYTE
02:0000232E 307C0100        	  3519:             move.l #$00000100,a0
02:00002332 203C12345678    	  3520:             move.l #$12345678,d0
02:00002338 223C12345678    	  3521:             move.l #$12345678,d1
02:0000233E 243C12345678    	  3522:             move.l #$12345678,d2
02:00002344 283C12345600    	  3523:             move.l #$12345600,d4
02:0000234A 2A3C12340000    	  3524:             move.l #$12340000,d5
02:00002350 7C00            	  3525:             moveq  #$00000000,d6
                            	  3526: 
02:00002352 4200            	  3527:             clr.b d0
02:00002354 66FE            	  3528:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002356 6BFE            	  3529:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002358 B880            	  3530:             cmp.l d0,d4
02:0000235A 66FE            	  3531:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3532: 
02:0000235C 4241            	  3533:             clr.w d1
02:0000235E 66FE            	  3534:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002360 6BFE            	  3535:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002362 BA81            	  3536:             cmp.l d1,d5
02:00002364 66FE            	  3537:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3538: 
02:00002366 7400            	  3539:             clr.l d2
02:00002368 66FE            	  3540:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000236A 6BFE            	  3541:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000236C BC82            	  3542:             cmp.l d2,d6
02:0000236E 66FE            	  3543:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3544: 
02:00002370 4E75            	  3545:             rts
                            	  3546: 
                            	  3547: 
                            	  3548: 
                            	  3549: *-----------------------------------------------------------
                            	  3550: *-----------------------------------------------------------
                            	  3551: * OPCODE : MOVEM
                            	  3552: *-----------------------------------------------------------
                            	  3553: *-----------------------------------------------------------
                            	  3554: op_MOVEM:
                            	  3555: 
                            	  3556: *     WORD  Registers --> Memory
02:00002372 203C0000D0D0    	  3557:             move.l #$0000d0d0,d0
02:00002378 223C0000D1D1    	  3558:             move.l #$0000d1d1,d1
02:0000237E 243C0000D2D2    	  3559:             move.l #$0000d2d2,d2
02:00002384 263C0000D3D3    	  3560:             move.l #$0000d3d3,d3
02:0000238A 283C0000D4D4    	  3561:             move.l #$0000d4d4,d4
02:00002390 2A3C0000D5D5    	  3562:             move.l #$0000d5d5,d5
02:00002396 2C3C0000D6D6    	  3563:             move.l #$0000d6d6,d6
02:0000239C 2E3C0000D7D7    	  3564:             move.l #$0000d7d7,d7
02:000023A2 307C0A0A        	  3565:             move.l #$00000a0a,a0
02:000023A6 327C1A1A        	  3566:             move.l #$00001a1a,a1
02:000023AA 347C2A2A        	  3567:             move.l #$00002a2a,a2
02:000023AE 367C3A3A        	  3568:             move.l #$00003a3a,a3
02:000023B2 387C4A4A        	  3569:             move.l #$00004a4a,a4
02:000023B6 3A7C5A5A        	  3570:             move.l #$00005a5a,a5
02:000023BA 3C7C6A6A        	  3571:             move.l #$00006a6a,a6
                            	  3572: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3573: 
02:000023BE 48B8FFFF0100    	  3574:             movem.w D0-D7/A0-A7,$00000100
                            	  3575: 
02:000023C4 307C0100        	  3576:             move.l #$00000100,a0
                            	  3577: 
02:000023C8 B058            	  3578:             cmp.w (a0)+,d0
02:000023CA 66FE            	  3579:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023CC B258            	  3580:             cmp.w (a0)+,d1
02:000023CE 66FE            	  3581:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023D0 B458            	  3582:             cmp.w (a0)+,d2
02:000023D2 66FE            	  3583:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023D4 B658            	  3584:             cmp.w (a0)+,d3
02:000023D6 66FE            	  3585:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023D8 B858            	  3586:             cmp.w (a0)+,d4
02:000023DA 66FE            	  3587:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023DC BA58            	  3588:             cmp.w (a0)+,d5
02:000023DE 66FE            	  3589:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023E0 BC58            	  3590:             cmp.w (a0)+,d6
02:000023E2 66FE            	  3591:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023E4 BE58            	  3592:             cmp.w (a0)+,d7
02:000023E6 66FE            	  3593:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3594: 
02:000023E8 0C580A0A        	  3595:             cmpi.w #$0A0A,(a0)+    * Because we are using a0 as a pointer
02:000023EC 66FE            	  3596:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3597: 
02:000023EE B2D8            	  3598:             cmp.w (a0)+,a1
02:000023F0 66FE            	  3599:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023F2 B4D8            	  3600:             cmp.w (a0)+,a2
02:000023F4 66FE            	  3601:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023F6 B6D8            	  3602:             cmp.w (a0)+,a3
02:000023F8 66FE            	  3603:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023FA B8D8            	  3604:             cmp.w (a0)+,a4
02:000023FC 66FE            	  3605:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023FE BAD8            	  3606:             cmp.w (a0)+,a5
02:00002400 66FE            	  3607:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002402 BCD8            	  3608:             cmp.w (a0)+,a6
02:00002404 66FE            	  3609:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3610: 
                            	  3611: 
                            	  3612: 
                            	  3613: 
                            	  3614: *     LONG  Registers --> Memory
02:00002406 203CD0D0D0D0    	  3615:             move.l #$d0d0d0d0,d0
02:0000240C 223CD1D1D1D1    	  3616:             move.l #$d1d1d1d1,d1
02:00002412 243CD2D2D2D2    	  3617:             move.l #$d2d2d2d2,d2
02:00002418 263CD3D3D3D3    	  3618:             move.l #$d3d3d3d3,d3
02:0000241E 283CD4D4D4D4    	  3619:             move.l #$d4d4d4d4,d4
02:00002424 2A3CD5D5D5D5    	  3620:             move.l #$d5d5d5d5,d5
02:0000242A 2C3CD6D6D6D6    	  3621:             move.l #$d6d6d6d6,d6
02:00002430 2E3CD7D7D7D7    	  3622:             move.l #$d7d7d7d7,d7
02:00002436 207C0A0A0A0A    	  3623:             move.l #$0a0a0a0a,a0
02:0000243C 227C1A1A1A1A    	  3624:             move.l #$1a1a1a1a,a1
02:00002442 247C2A2A2A2A    	  3625:             move.l #$2a2a2a2a,a2
02:00002448 267C3A3A3A3A    	  3626:             move.l #$3a3a3a3a,a3
02:0000244E 287C4A4A4A4A    	  3627:             move.l #$4a4a4a4a,a4
02:00002454 2A7C5A5A5A5A    	  3628:             move.l #$5a5a5a5a,a5
02:0000245A 2C7C6A6A6A6A    	  3629:             move.l #$6a6a6a6a,a6
                            	  3630: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3631: 
                            	  3632: 
02:00002460 48F8FFFF0120    	  3633:             movem.l D0-D7/A0-A7,$00000120
                            	  3634: 
02:00002466 307C0120        	  3635:             move.l #$00000120,a0
                            	  3636: 
02:0000246A B098            	  3637:             cmp.l (a0)+,d0
02:0000246C 66FE            	  3638:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000246E B298            	  3639:             cmp.l (a0)+,d1
02:00002470 66FE            	  3640:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002472 B498            	  3641:             cmp.l (a0)+,d2
02:00002474 66FE            	  3642:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002476 B698            	  3643:             cmp.l (a0)+,d3
02:00002478 66FE            	  3644:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000247A B898            	  3645:             cmp.l (a0)+,d4
02:0000247C 66FE            	  3646:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000247E BA98            	  3647:             cmp.l (a0)+,d5
02:00002480 66FE            	  3648:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002482 BC98            	  3649:             cmp.l (a0)+,d6
02:00002484 66FE            	  3650:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002486 BE98            	  3651:             cmp.l (a0)+,d7
02:00002488 66FE            	  3652:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3653: 
02:0000248A 0C980A0A0A0A    	  3654:             cmpi.l #$0A0A0A0A,(a0)+    * Because we are using a0 as a pointer
02:00002490 66FE            	  3655:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3656: 
02:00002492 B3D8            	  3657:             cmp.l (a0)+,a1
02:00002494 66FE            	  3658:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002496 B5D8            	  3659:             cmp.l (a0)+,a2
02:00002498 66FE            	  3660:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000249A B7D8            	  3661:             cmp.l (a0)+,a3
02:0000249C 66FE            	  3662:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000249E B9D8            	  3663:             cmp.l (a0)+,a4
02:000024A0 66FE            	  3664:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024A2 BBD8            	  3665:             cmp.l (a0)+,a5
02:000024A4 66FE            	  3666:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024A6 BDD8            	  3667:             cmp.l (a0)+,a6
02:000024A8 66FE            	  3668:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3669: *      ----
                            	  3670: 
                            	  3671: 
                            	  3672: *     WORD  Registers --> Memory  -(An) EA Mode
02:000024AA 203C0000D0D0    	  3673:             move.l #$0000d0d0,d0
02:000024B0 223C0000D1D1    	  3674:             move.l #$0000d1d1,d1
02:000024B6 243C0000D2D2    	  3675:             move.l #$0000d2d2,d2
02:000024BC 263C0000D3D3    	  3676:             move.l #$0000d3d3,d3
02:000024C2 283C0000D4D4    	  3677:             move.l #$0000d4d4,d4
02:000024C8 2A3C0000D5D5    	  3678:             move.l #$0000d5d5,d5
02:000024CE 2C3C0000D6D6    	  3679:             move.l #$0000d6d6,d6
02:000024D4 2E3C0000D7D7    	  3680:             move.l #$0000d7d7,d7
02:000024DA 307C0A0A        	  3681:             move.l #$00000a0a,a0
02:000024DE 327C1A1A        	  3682:             move.l #$00001a1a,a1
02:000024E2 347C2A2A        	  3683:             move.l #$00002a2a,a2
02:000024E6 367C3A3A        	  3684:             move.l #$00003a3a,a3
02:000024EA 387C4A4A        	  3685:             move.l #$00004a4a,a4
02:000024EE 3A7C5A5A        	  3686:             move.l #$00005a5a,a5
02:000024F2 3C7C6A6A        	  3687:             move.l #$00006a6a,a6
                            	  3688: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3689: 
02:000024F6 307C01A0        	  3690:             move.l #$000001A0,a0
02:000024FA 48A0FFFF        	  3691:             movem.w D0-D7/A0-A7,-(a0)
                            	  3692: 
02:000024FE 307C019E        	  3693:             move.l #$0000019E,a0
                            	  3694: 
02:00002502 BCE0            	  3695:             cmp.w -(a0),a6
02:00002504 66FE            	  3696:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002506 BAE0            	  3697:             cmp.w -(a0),a5
02:00002508 66FE            	  3698:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000250A B8E0            	  3699:             cmp.w -(a0),a4
02:0000250C 66FE            	  3700:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000250E B6E0            	  3701:             cmp.w -(a0),a3
02:00002510 66FE            	  3702:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002512 B4E0            	  3703:             cmp.w -(a0),a2
02:00002514 66FE            	  3704:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002516 B2E0            	  3705:             cmp.w -(a0),a1
02:00002518 66FE            	  3706:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000251A B0E0            	  3707:             cmp.w -(a0),a0
                            	  3708: *            bne.s *                   * Check Z Flag  beq/bne 0
02:0000251C BE60            	  3709:             cmp.w -(a0),d7
02:0000251E 66FE            	  3710:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002520 BC60            	  3711:             cmp.w -(a0),d6
02:00002522 66FE            	  3712:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002524 BA60            	  3713:             cmp.w -(a0),d5
02:00002526 66FE            	  3714:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002528 B860            	  3715:             cmp.w -(a0),d4
02:0000252A 66FE            	  3716:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000252C B660            	  3717:             cmp.w -(a0),d3
02:0000252E 66FE            	  3718:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002530 B460            	  3719:             cmp.w -(a0),d2
02:00002532 66FE            	  3720:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002534 B260            	  3721:             cmp.w -(a0),d1
02:00002536 66FE            	  3722:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002538 B060            	  3723:             cmp.w -(a0),d0
02:0000253A 66FE            	  3724:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3725: 
                            	  3726: 
                            	  3727: 
                            	  3728: 
                            	  3729: *     LONG  Registers --> Memory   -(An) EA Mode
02:0000253C 203CD0D0D0D0    	  3730:             move.l #$d0d0d0d0,d0
02:00002542 223CD1D1D1D1    	  3731:             move.l #$d1d1d1d1,d1
02:00002548 243CD2D2D2D2    	  3732:             move.l #$d2d2d2d2,d2
02:0000254E 263CD3D3D3D3    	  3733:             move.l #$d3d3d3d3,d3
02:00002554 283CD4D4D4D4    	  3734:             move.l #$d4d4d4d4,d4
02:0000255A 2A3CD5D5D5D5    	  3735:             move.l #$d5d5d5d5,d5
02:00002560 2C3CD6D6D6D6    	  3736:             move.l #$d6d6d6d6,d6
02:00002566 2E3CD7D7D7D7    	  3737:             move.l #$d7d7d7d7,d7
02:0000256C 207C0A0A0A0A    	  3738:             move.l #$0a0a0a0a,a0
02:00002572 227C1A1A1A1A    	  3739:             move.l #$1a1a1a1a,a1
02:00002578 247C2A2A2A2A    	  3740:             move.l #$2a2a2a2a,a2
02:0000257E 267C3A3A3A3A    	  3741:             move.l #$3a3a3a3a,a3
02:00002584 287C4A4A4A4A    	  3742:             move.l #$4a4a4a4a,a4
02:0000258A 2A7C5A5A5A5A    	  3743:             move.l #$5a5a5a5a,a5
02:00002590 2C7C6A6A6A6A    	  3744:             move.l #$6a6a6a6a,a6
                            	  3745: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3746: 
                            	  3747: 
02:00002596 307C01A0        	  3748:             move.l #$000001A0,a0
02:0000259A 48E0FFFF        	  3749:             movem.l D0-D7/A0-A7,-(a0)
                            	  3750: 
02:0000259E 307C019C        	  3751:             move.l #$0000019C,a0
                            	  3752: 
02:000025A2 BDE0            	  3753:             cmp.l -(a0),a6
02:000025A4 66FE            	  3754:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025A6 BBE0            	  3755:             cmp.l -(a0),a5
02:000025A8 66FE            	  3756:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025AA B9E0            	  3757:             cmp.l -(a0),a4
02:000025AC 66FE            	  3758:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025AE B7E0            	  3759:             cmp.l -(a0),a3
02:000025B0 66FE            	  3760:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025B2 B5E0            	  3761:             cmp.l -(a0),a2
02:000025B4 66FE            	  3762:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025B6 B3E0            	  3763:             cmp.l -(a0),a1
02:000025B8 66FE            	  3764:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025BA B1E0            	  3765:             cmp.l -(a0),a0
                            	  3766: *            bne.s *                   * Check Z Flag  beq/bne 0
02:000025BC BEA0            	  3767:             cmp.l -(a0),d7
02:000025BE 66FE            	  3768:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025C0 BCA0            	  3769:             cmp.l -(a0),d6
02:000025C2 66FE            	  3770:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025C4 BAA0            	  3771:             cmp.l -(a0),d5
02:000025C6 66FE            	  3772:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025C8 B8A0            	  3773:             cmp.l -(a0),d4
02:000025CA 66FE            	  3774:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025CC B6A0            	  3775:             cmp.l -(a0),d3
02:000025CE 66FE            	  3776:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025D0 B4A0            	  3777:             cmp.l -(a0),d2
02:000025D2 66FE            	  3778:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025D4 B2A0            	  3779:             cmp.l -(a0),d1
02:000025D6 66FE            	  3780:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025D8 B0A0            	  3781:             cmp.l -(a0),d0
02:000025DA 66FE            	  3782:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3783: 
                            	  3784: 
                            	  3785: 
                            	  3786: *     ----
                            	  3787: 
                            	  3788: *     WORD - Memory --> Registers
02:000025DC 7000            	  3789:             moveq  #$00000000,d0
02:000025DE 7200            	  3790:             moveq  #$00000000,d1
02:000025E0 7400            	  3791:             moveq  #$00000000,d2
02:000025E2 7600            	  3792:             moveq  #$00000000,d3
02:000025E4 7800            	  3793:             moveq  #$00000000,d4
02:000025E6 7A00            	  3794:             moveq  #$00000000,d5
02:000025E8 7C00            	  3795:             moveq  #$00000000,d6
02:000025EA 7E00            	  3796:             moveq  #$00000000,d7
02:000025EC 91C8            	  3797:             move.l #$00000000,a0
02:000025EE 93C9            	  3798:             move.l #$00000000,a1
02:000025F0 95CA            	  3799:             move.l #$00000000,a2
02:000025F2 97CB            	  3800:             move.l #$00000000,a3
02:000025F4 99CC            	  3801:             move.l #$00000000,a4
02:000025F6 9BCD            	  3802:             move.l #$00000000,a5
02:000025F8 9DCE            	  3803:             move.l #$00000000,a6
                            	  3804: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3805: 
02:000025FA 4CB82A550100    	  3806:             movem.w $00000100,D0/D2/D4/D6/A1/A3/A5
                            	  3807: 
02:00002600 B0BCFFFFD0D0    	  3808:             cmp.l #$FFFFD0D0,d0
02:00002606 66FE            	  3809:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002608 B4BCFFFFD1D1    	  3810:             cmp.l #$FFFFD1D1,d2
02:0000260E 66FE            	  3811:             bne.s *                  * Check Z Flag  beq/bne 0
02:00002610 B8BCFFFFD2D2    	  3812:             cmp.l #$FFFFD2D2,d4
02:00002616 66FE            	  3813:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002618 BCBCFFFFD3D3    	  3814:             cmp.l #$FFFFD3D3,d6
02:0000261E 66FE            	  3815:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002620 B2FCD4D4        	  3816:             cmp.l #$FFFFD4D4,a1
02:00002624 66FE            	  3817:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002626 B6FCD5D5        	  3818:             cmp.l #$FFFFD5D5,a3
02:0000262A 66FE            	  3819:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000262C BAFCD6D6        	  3820:             cmp.l #$FFFFD6D6,a5
02:00002630 66FE            	  3821:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3822: 
                            	  3823: 
                            	  3824: *     LONG - Memory --> Registers
02:00002632 7000            	  3825:             moveq  #$00000000,d0
02:00002634 7200            	  3826:             moveq  #$00000000,d1
02:00002636 7400            	  3827:             moveq  #$00000000,d2
02:00002638 7600            	  3828:             moveq  #$00000000,d3
02:0000263A 7800            	  3829:             moveq  #$00000000,d4
02:0000263C 7A00            	  3830:             moveq  #$00000000,d5
02:0000263E 7C00            	  3831:             moveq  #$00000000,d6
02:00002640 7E00            	  3832:             moveq  #$00000000,d7
02:00002642 91C8            	  3833:             move.l #$00000000,a0
02:00002644 93C9            	  3834:             move.l #$00000000,a1
02:00002646 95CA            	  3835:             move.l #$00000000,a2
02:00002648 97CB            	  3836:             move.l #$00000000,a3
02:0000264A 99CC            	  3837:             move.l #$00000000,a4
02:0000264C 9BCD            	  3838:             move.l #$00000000,a5
02:0000264E 9DCE            	  3839:             move.l #$00000000,a6
                            	  3840: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3841: 
02:00002650 4CF82A550120    	  3842:             movem.l $00000120,D0/D2/D4/D6/A1/A3/A5
                            	  3843: 
02:00002656 B0BCD0D0D0D0    	  3844:             cmp.l #$D0D0D0D0,d0
02:0000265C 66FE            	  3845:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000265E B4BCD1D1D1D1    	  3846:             cmp.l #$D1D1D1D1,d2
02:00002664 66FE            	  3847:             bne.s *                  * Check Z Flag  beq/bne 0
02:00002666 B8BCD2D2D2D2    	  3848:             cmp.l #$D2D2D2D2,d4
02:0000266C 66FE            	  3849:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000266E BCBCD3D3D3D3    	  3850:             cmp.l #$D3D3D3D3,d6
02:00002674 66FE            	  3851:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002676 B3FCD4D4D4D4    	  3852:             cmp.l #$D4D4D4D4,a1
02:0000267C 66FE            	  3853:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000267E B7FCD5D5D5D5    	  3854:             cmp.l #$D5D5D5D5,a3
02:00002684 66FE            	  3855:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002686 BBFCD6D6D6D6    	  3856:             cmp.l #$D6D6D6D6,a5
02:0000268C 66FE            	  3857:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3858: 
02:0000268E 4E75            	  3859:             rts
                            	  3860: 
                            	  3861: 
                            	  3862: *-----------------------------------------------------------
                            	  3863: *-----------------------------------------------------------
                            	  3864: * OPCODE : ABCD
                            	  3865: *-----------------------------------------------------------
                            	  3866: *-----------------------------------------------------------
                            	  3867: op_ABCD:
                            	  3868: 
                            	  3869: *     Test with X Flag CLEARED
02:00002690 307C0110        	  3870:                 move.l #$00000110,a0 * Address pointer-X
02:00002694 327C0120        	  3871:                 move.l #$00000120,a1 * Address pointer-Y
02:00002698 7000            	  3872:                 moveq  #$00000000,d0 * BCD byte-X
02:0000269A 7200            	  3873:                 moveq  #$00000000,d1 * BCD byte-Y
02:0000269C 7400            	  3874:                 moveq  #$00000000,d2
02:0000269E 7600            	  3875:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:000026A0 7800            	  3876:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:000026A2 7A00            	  3877:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:000026A4 2C3C00000099    	  3878:                 move.l #$00000099,d6 * Inner loop counter
02:000026AA 2E3C00000099    	  3879:                 move.l #$00000099,d7 * Outer loop counter
                            	  3880: 
02:000026B0 2007            	  3881: ABCD_OUTER1:    move.l d7,d0
02:000026B2 2206            	  3882: ABCD_INNER1:    move.l d6,d1
02:000026B4 023C00EF        	  3883:                 andi.b #$EF,CCR     * Clear X Flag
02:000026B8 307C0110        	  3884:                 move.l #$00000110,a0 * Address pointer-X
02:000026BC 327C0120        	  3885:                 move.l #$00000120,a1 * Address pointer-Y
02:000026C0 1140FFFF        	  3886:                 move.b d0,-1(a0)
02:000026C4 1341FFFF        	  3887:                 move.b d1,-1(a1)
                            	  3888: 
02:000026C8 C300            	  3889:                 abcd d0,d1
02:000026CA 6402            	  3890:                 bcc.s ABCD_NO_C1          * Check C Flag  bcc/bcs 0
02:000026CC 5284            	  3891:                 add.l #1,d4
02:000026CE DA81            	  3892: ABCD_NO_C1:     add.l d1,d5
                            	  3893: 
02:000026D0 C308            	  3894:                 abcd -(a0),-(a1)
02:000026D2 6402            	  3895:                 bcc.s ABCD_NO_C2          * Check C Flag  bcc/bcs 0
02:000026D4 5284            	  3896:                 add.l #1,d4
02:000026D6 D611            	  3897: ABCD_NO_C2:     add.b (a1),d3
                            	  3898: 
                            	  3899: 
02:000026D8 51CEFFD8        	  3900:                 dbf d6,ABCD_INNER1
02:000026DC 2C3C00000099    	  3901:                 move.l #$00000099,d6
02:000026E2 51CFFFCC        	  3902:                 dbf d7,ABCD_OUTER1
02:000026E6 0C8400005AFC    	  3903:                 cmpi.l #$00005AFC,d4  * Check the cumulative results
02:000026EC 66FE            	  3904:                 bne.s *
02:000026EE 0C85001C9A34    	  3905:                 cmpi.l #$001C9A34,d5
02:000026F4 66FE            	  3906:                 bne.s *
02:000026F6 0C8300000034    	  3907:                 cmpi.l #$00000034,d3
02:000026FC 66FE            	  3908:                 bne.s *
                            	  3909: 
                            	  3910: *     Test with X Flag SET
02:000026FE 307C0110        	  3911:                 move.l #$00000110,a0 * Address pointer-X
02:00002702 327C0120        	  3912:                 move.l #$00000120,a1 * Address pointer-Y
02:00002706 7000            	  3913:                 moveq  #$00000000,d0 * BCD byte-X
02:00002708 7200            	  3914:                 moveq  #$00000000,d1 * BCD byte-Y
02:0000270A 7400            	  3915:                 moveq  #$00000000,d2
02:0000270C 7600            	  3916:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:0000270E 7800            	  3917:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:00002710 7A00            	  3918:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:00002712 2C3C00000099    	  3919:                 move.l #$00000099,d6 * Inner loop counter
02:00002718 2E3C00000099    	  3920:                 move.l #$00000099,d7 * Outer loop counter
                            	  3921: 
02:0000271E 2007            	  3922: ABCD_OUTER2:    move.l d7,d0
02:00002720 2206            	  3923: ABCD_INNER2:    move.l d6,d1
02:00002722 003C0010        	  3924:                 ori.b #$10,CCR      * Set X Flag
02:00002726 307C0110        	  3925:                 move.l #$00000110,a0 * Address pointer-X
02:0000272A 327C0120        	  3926:                 move.l #$00000120,a1 * Address pointer-Y
02:0000272E 1140FFFF        	  3927:                 move.b d0,-1(a0)
02:00002732 1341FFFF        	  3928:                 move.b d1,-1(a1)
                            	  3929: 
02:00002736 C300            	  3930:                 abcd d0,d1
02:00002738 6402            	  3931:                 bcc.s ABCD_NO_C3          * Check C Flag  bcc/bcs 0
02:0000273A 5284            	  3932:                 add.l #1,d4
02:0000273C DA81            	  3933: ABCD_NO_C3:     add.l d1,d5
                            	  3934: 
02:0000273E C308            	  3935:                 abcd -(a0),-(a1)
02:00002740 6402            	  3936:                 bcc.s ABCD_NO_C4          * Check C Flag  bcc/bcs 0
02:00002742 5284            	  3937:                 add.l #1,d4
02:00002744 D611            	  3938: ABCD_NO_C4:     add.b (a1),d3
                            	  3939: 
                            	  3940: 
02:00002746 51CEFFD8        	  3941:                 dbf d6,ABCD_INNER2
02:0000274A 2C3C00000099    	  3942:                 move.l #$00000099,d6
02:00002750 51CFFFCC        	  3943:                 dbf d7,ABCD_OUTER2
02:00002754 0C8400005B60    	  3944:                 cmpi.l #$00005B60,d4  * Check the cumulative results
02:0000275A 66FE            	  3945:                 bne.s *
02:0000275C 0C85001CCFC8    	  3946:                 cmpi.l #$001CCFC8,d5
02:00002762 66FE            	  3947:                 bne.s *
02:00002764 0C8300000034    	  3948:                 cmpi.l #$00000034,d3
02:0000276A 66FE            	  3949:                 bne.s *
                            	  3950: 
                            	  3951: *             Quick check of Z Flag
02:0000276C 4200            	  3952:                 move.b #$00,d0
02:0000276E 4201            	  3953:                 move.b #$00,d1
02:00002770 44FC0000        	  3954:                 move #$00,CCR              * Set Z flag to 0
02:00002774 C101            	  3955:                 abcd d1,d0                  * Should NOT set Z Flag to 1
02:00002776 67FE            	  3956:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3957: 
02:00002778 103C0001        	  3958:                 move.b #$01,d0
02:0000277C 4201            	  3959:                 move.b #$00,d1
02:0000277E 44FC0004        	  3960:                 move #$04,CCR              * Set Z flag to 0
02:00002782 C101            	  3961:                 abcd d1,d0                  * Should NOT set Z Flag to 1
02:00002784 67FE            	  3962:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3963: 
02:00002786 4E75            	  3964:                 rts
                            	  3965: 
                            	  3966: *-----------------------------------------------------------
                            	  3967: *-----------------------------------------------------------
                            	  3968: * OPCODE : SBCD
                            	  3969: *-----------------------------------------------------------
                            	  3970: *-----------------------------------------------------------
                            	  3971: op_SBCD:
                            	  3972: 
                            	  3973: *     Test with X Flag CLEARED
02:00002788 307C0110        	  3974:                 move.l #$00000110,a0 * Address pointer-X
02:0000278C 327C0120        	  3975:                 move.l #$00000120,a1 * Address pointer-Y
02:00002790 7000            	  3976:                 moveq  #$00000000,d0 * BCD byte-X
02:00002792 7200            	  3977:                 moveq  #$00000000,d1 * BCD byte-Y
02:00002794 7400            	  3978:                 moveq  #$00000000,d2
02:00002796 7600            	  3979:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:00002798 7800            	  3980:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:0000279A 7A00            	  3981:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:0000279C 2C3C00000099    	  3982:                 move.l #$00000099,d6 * Inner loop counter
02:000027A2 2E3C00000099    	  3983:                 move.l #$00000099,d7 * Outer loop counter
                            	  3984: 
02:000027A8 2007            	  3985: SBCD_OUTER1:    move.l d7,d0
02:000027AA 2206            	  3986: SBCD_INNER1:    move.l d6,d1
02:000027AC 023C00EF        	  3987:                 andi.b #$EF,CCR     * Clear X Flag
02:000027B0 307C0110        	  3988:                 move.l #$00000110,a0 * Address pointer-X
02:000027B4 327C0120        	  3989:                 move.l #$00000120,a1 * Address pointer-Y
02:000027B8 1140FFFF        	  3990:                 move.b d0,-1(a0)
02:000027BC 1341FFFF        	  3991:                 move.b d1,-1(a1)
                            	  3992: 
02:000027C0 8300            	  3993:                 sbcd d0,d1
02:000027C2 6402            	  3994:                 bcc.s SBCD_NO_C1          * Check C Flag  bcc/bcs 0
02:000027C4 5284            	  3995:                 add.l #1,d4
02:000027C6 DA81            	  3996: SBCD_NO_C1:     add.l d1,d5
                            	  3997: 
02:000027C8 8308            	  3998:                 sbcd -(a0),-(a1)
02:000027CA 6402            	  3999:                 bcc.s SBCD_NO_C2          * Check C Flag  bcc/bcs 0
02:000027CC 5284            	  4000:                 add.l #1,d4
02:000027CE D611            	  4001: SBCD_NO_C2:     add.b (a1),d3
                            	  4002: 
                            	  4003: 
02:000027D0 51CEFFD8        	  4004:                 dbf d6,SBCD_INNER1
02:000027D4 2C3C00000099    	  4005:                 move.l #$00000099,d6
02:000027DA 51CFFFCC        	  4006:                 dbf d7,SBCD_OUTER1
02:000027DE 0C8400005C0A    	  4007:                 cmpi.l #$00005C0A,d4  * Check the cumulative results
02:000027E4 66FE            	  4008:                 bne.s *
02:000027E6 0C85001C459E    	  4009:                 cmpi.l #$001C459E,d5
02:000027EC 66FE            	  4010:                 bne.s *
02:000027EE 0C830000009E    	  4011:                 cmpi.l #$0000009E,d3
02:000027F4 66FE            	  4012:                 bne.s *
                            	  4013: 
                            	  4014: *     Test with X Flag SET
02:000027F6 307C0110        	  4015:                 move.l #$00000110,a0 * Address pointer-X
02:000027FA 327C0120        	  4016:                 move.l #$00000120,a1 * Address pointer-Y
02:000027FE 7000            	  4017:                 moveq  #$00000000,d0 * BCD byte-X
02:00002800 7200            	  4018:                 moveq  #$00000000,d1 * BCD byte-Y
02:00002802 7400            	  4019:                 moveq  #$00000000,d2
02:00002804 7600            	  4020:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:00002806 7800            	  4021:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:00002808 7A00            	  4022:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:0000280A 2C3C00000099    	  4023:                 move.l #$00000099,d6 * Inner loop counter
02:00002810 2E3C00000099    	  4024:                 move.l #$00000099,d7 * Outer loop counter
                            	  4025: 
02:00002816 2007            	  4026: SBCD_OUTER2:    move.l d7,d0
02:00002818 2206            	  4027: SBCD_INNER2:    move.l d6,d1
02:0000281A 003C0010        	  4028:                 ori.b #$10,CCR      * Set X Flag
02:0000281E 307C0110        	  4029:                 move.l #$00000110,a0 * Address pointer-X
02:00002822 327C0120        	  4030:                 move.l #$00000120,a1 * Address pointer-Y
02:00002826 1140FFFF        	  4031:                 move.b d0,-1(a0)
02:0000282A 1341FFFF        	  4032:                 move.b d1,-1(a1)
                            	  4033: 
02:0000282E 8300            	  4034:                 sbcd d0,d1
02:00002830 6402            	  4035:                 bcc.s SBCD_NO_C3          * Check C Flag  bcc/bcs 0
02:00002832 5284            	  4036:                 add.l #1,d4
02:00002834 DA81            	  4037: SBCD_NO_C3:     add.l d1,d5
                            	  4038: 
02:00002836 8308            	  4039:                 sbcd -(a0),-(a1)
02:00002838 6402            	  4040:                 bcc.s SBCD_NO_C4          * Check C Flag  bcc/bcs 0
02:0000283A 5284            	  4041:                 add.l #1,d4
02:0000283C D611            	  4042: SBCD_NO_C4:     add.b (a1),d3
                            	  4043: 
02:0000283E 51CEFFD8        	  4044:                 dbf d6,SBCD_INNER2
02:00002842 2C3C00000099    	  4045:                 move.l #$00000099,d6
02:00002848 51CFFFCC        	  4046:                 dbf d7,SBCD_OUTER2
02:0000284C 0C8400005CA4    	  4047:                 cmpi.l #$00005CA4,d4  * Check the cumulative results
02:00002852 66FE            	  4048:                 bne.s *
02:00002854 0C85001C5C66    	  4049:                 cmpi.l #$001C5C66,d5
02:0000285A 66FE            	  4050:                 bne.s *
02:0000285C 0C830000009E    	  4051:                 cmpi.l #$0000009E,d3
02:00002862 66FE            	  4052:                 bne.s *
                            	  4053: 
                            	  4054: 
                            	  4055: *             Quick check of Z Flag
02:00002864 4200            	  4056:                 move.b #$00,d0
02:00002866 4201            	  4057:                 move.b #$00,d1
02:00002868 44FC0000        	  4058:                 move #$00,CCR              * Set Z flag to 0
02:0000286C 8101            	  4059:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
02:0000286E 67FE            	  4060:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4061: 
02:00002870 103C0001        	  4062:                 move.b #$01,d0
02:00002874 4201            	  4063:                 move.b #$00,d1
02:00002876 44FC0004        	  4064:                 move #$04,CCR              * Set Z flag to 0
02:0000287A 8101            	  4065:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
02:0000287C 67FE            	  4066:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4067: 
02:0000287E 4E75            	  4068:                 rts
                            	  4069: 
                            	  4070: *-----------------------------------------------------------
                            	  4071: *-----------------------------------------------------------
                            	  4072: * OPCODE : NBCD
                            	  4073: *-----------------------------------------------------------
                            	  4074: *-----------------------------------------------------------
                            	  4075: op_NBCD:
                            	  4076: 
                            	  4077: *        NBCD to a  Register
                            	  4078: 
02:00002880 7000            	  4079:                 moveq  #$00000000,d0 * BCD byte
02:00002882 7200            	  4080:                 moveq  #$00000000,d1
02:00002884 7400            	  4081:                 moveq  #$00000000,d2
02:00002886 7600            	  4082:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
02:00002888 7800            	  4083:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:0000288A 7A00            	  4084:                 moveq  #$00000000,d5 * Cumulative BCD results
02:0000288C 2C3C00000099    	  4085:                 move.l #$00000099,d6
02:00002892 2E3C00000099    	  4086:                 move.l #$00000099,d7 * Loop counter
                            	  4087: 
02:00002898 2007            	  4088: NBCD_LOOP:      move.l d7,d0
02:0000289A 44FC0004        	  4089:                 move #$04,CCR        * Set Z flag to 0
                            	  4090: 
02:0000289E 4800            	  4091:                 nbcd d0
                            	  4092: 
02:000028A0 6402            	  4093:                 bcc.s NBCD_NO_C         * Check C Flag
02:000028A2 5284            	  4094:                 add.l #1,d4
02:000028A4 6602            	  4095: NBCD_NO_C:      bne.s NBCD_NO_Z         * Check Z Flag
02:000028A6 5283            	  4096:                 add.l #1,d3
02:000028A8 DA80            	  4097: NBCD_NO_Z:      add.l d0,d5         * Add results into d5
                            	  4098: 
02:000028AA 51CFFFEC        	  4099:                 dbf d7,NBCD_LOOP
                            	  4100: 
02:000028AE 0C8300000001    	  4101:                 cmpi.l #$00000001,d3  * Check the cumulative results
02:000028B4 66FE            	  4102:                 bne.s *
02:000028B6 0C8400000099    	  4103:                 cmpi.l #$00000099,d4
02:000028BC 66FE            	  4104:                 bne.s *
02:000028BE 0C8500002E3B    	  4105:                 cmpi.l #$00002E3B,d5
02:000028C4 66FE            	  4106:                 bne.s *
                            	  4107: 
                            	  4108: 
                            	  4109: *        NBCD to a memory location
                            	  4110: 
02:000028C6 7000            	  4111:                 moveq  #$00000000,d0 * BCD byte
02:000028C8 7200            	  4112:                 moveq  #$00000000,d1
02:000028CA 7400            	  4113:                 moveq  #$00000000,d2
02:000028CC 7600            	  4114:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
02:000028CE 7800            	  4115:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:000028D0 7A00            	  4116:                 moveq  #$00000000,d5 * Cumulative BCD results
02:000028D2 2C3C00000099    	  4117:                 move.l #$00000099,d6
02:000028D8 2E3C00000099    	  4118:                 move.l #$00000099,d7 * Loop counter
                            	  4119: 
02:000028DE 11C70100        	  4120: NBCD_LOOP1:     move.b d7,$00000100
02:000028E2 44FC0004        	  4121:                 move #$04,CCR        * Set Z flag to 0
                            	  4122: 
02:000028E6 48380100        	  4123:                 nbcd $00000100
02:000028EA 10380100        	  4124:                 move.b $00000100,d0
                            	  4125: 
02:000028EE 6402            	  4126:                 bcc.s NBCD_NO_C1        * Check C Flag
02:000028F0 5284            	  4127:                 add.l #1,d4
02:000028F2 6602            	  4128: NBCD_NO_C1:     bne.s NBCD_NO_Z1        * Check Z Flag
02:000028F4 5283            	  4129:                 add.l #1,d3
02:000028F6 DA80            	  4130: NBCD_NO_Z1:     add.l d0,d5         * Add results into d5
                            	  4131: 
02:000028F8 51CFFFE4        	  4132:                 dbf d7,NBCD_LOOP1
                            	  4133: 
02:000028FC 0C8300000001    	  4134:                 cmpi.l #$00000001,d3  * Check the cumulative results
02:00002902 66FE            	  4135:                 bne.s *
02:00002904 4A84            	  4136:                 cmpi.l #$00000000,d4
02:00002906 66FE            	  4137:                 bne.s *
02:00002908 0C8500002E3B    	  4138:                 cmpi.l #$00002E3B,d5
02:0000290E 66FE            	  4139:                 bne.s *
                            	  4140: 
                            	  4141: 
02:00002910 4E75            	  4142:                 rts
                            	  4143: 
                            	  4144: 
                            	  4145: 
                            	  4146: *-----------------------------------------------------------
                            	  4147: *-----------------------------------------------------------
                            	  4148: * OPCODE : TRAPV
                            	  4149: *-----------------------------------------------------------
                            	  4150: *-----------------------------------------------------------
                            	  4151: op_TRAPV:
                            	  4152: 
                            	  4153: *     TRAPV will set d0 to 12345678 if V flag is set
                            	  4154: 
02:00002912 7000            	  4155:                 moveq  #$00000000,d0 * Clear d0
                            	  4156: 
02:00002914 44FC0000        	  4157:                 move #$00,CCR        * Clear V flag
02:00002918 4E76            	  4158:                 trapv
02:0000291A 4A80            	  4159:                 cmpi.l #$00000000,d0  * Check of d0 was updated (should not be_)
02:0000291C 66FE            	  4160:                 bne.s *
                            	  4161: 
02:0000291E 44FC0002        	  4162:                 move #$02,CCR        * Set V flag
02:00002922 4E76            	  4163:                 trapv
02:00002924 0C8012345678    	  4164:                 cmpi.l #$12345678,d0  * Check of d0 was updated (should not be_)
02:0000292A 66FE            	  4165:                 bne.s *
                            	  4166: 
                            	  4167: 
02:0000292C 4E75            	  4168:                 rts
                            	  4169: 
                            	  4170: 
                            	  4171: 
                            	  4172: *-----------------------------------------------------------
                            	  4173: *-----------------------------------------------------------
                            	  4174: * OPCODE : RTR
                            	  4175: *-----------------------------------------------------------
                            	  4176: *-----------------------------------------------------------
                            	  4177: 
                            	  4178: op_RTR:
                            	  4179: 
                            	  4180: *     Leventhal claims only 5 LSB's are popped from the stack to the CCR
                            	  4181: 
02:0000292E 41FA000A        	  4182:                 lea 		RTR_DONE,a0
02:00002932 2F08            	  4183:                 move.l 	a0,-(a7)     * push destination PC to the stack
02:00002934 3F3CFF15        	  4184:                 move.w 	#$FF15,-(a7)       * push flags=0xFFFF to the stack
02:00002938 4E77            	  4185:                 rtr
                            	  4186: 
02:0000293A 40C0            	  4187: RTR_DONE:       move.w SR,d0
02:0000293C 0240001F        	  4188:                 andi.w #$1F,d0
02:00002940 0C400015        	  4189:                 cmpi.w #$15,d0
02:00002944 66FE            	  4190:                 bne.s *
                            	  4191: 
02:00002946 4E75            	  4192:                 rts
                            	  4193: 
                            	  4194: 
02:00002948 283C44444444    	  4195: BSR_FAR2:       move.l #$44444444,d4
02:0000294E 4E75            	  4196:                 rts
                            	  4197: 
                            	  4198: 
                            	  4199: *-----------------------------------------------------------
                            	  4200: *-----------------------------------------------------------
                            	  4201: * OPCODE : BCC
                            	  4202: *-----------------------------------------------------------
                            	  4203: *-----------------------------------------------------------
                            	  4204: 
02:00002950 44FC0000        	  4205: op_BCC:         move #$00,CCR
02:00002954 6202            	  4206:                 bhi.s BCC1            * Higher Than         C=0 AND Z=0
02:00002956 60FE            	  4207:                 bra.s *
                            	  4208: 
02:00002958 44FC0001        	  4209: BCC1:           move #$01,CCR
02:0000295C 63000004        	  4210:                 bls.w BCC2            * Lower or Same       C=1 OR Z=1
02:00002960 60FE            	  4211:                 bra.s *
                            	  4212: 
02:00002962 44FC0000        	  4213: BCC2:           move #$00,CCR
02:00002966 6402            	  4214:                 bcc.s BCC3            * Carry Clear         C=0
02:00002968 60FE            	  4215:                 bra.s *
                            	  4216: 
02:0000296A 44FC0001        	  4217: BCC3:           move #$01,CCR
02:0000296E 65000004        	  4218:                 bcs.w BCC4            * Carry Set           C=1
02:00002972 60FE            	  4219:                 bra.s *
                            	  4220: 
02:00002974 44FC0000        	  4221: BCC4:           move #$00,CCR
02:00002978 6602            	  4222:                 bne.s BCC5            * Not Equal           Z=0
02:0000297A 60FE            	  4223:                 bra.s *
                            	  4224: 
02:0000297C 44FC0004        	  4225: BCC5:           move #$04,CCR
02:00002980 67000004        	  4226:                 beq.w BCC6            * Equal               Z=1
02:00002984 60FE            	  4227:                 bra.s *
                            	  4228: 
02:00002986 44FC0000        	  4229: BCC6:           move #$00,CCR
02:0000298A 6802            	  4230:                 bvc.s BCC7            * V Clear             V=0
02:0000298C 60FE            	  4231:                 bra.s *
                            	  4232: 
02:0000298E 44FC0002        	  4233: BCC7:           move #$02,CCR
02:00002992 69000004        	  4234:                 bvs.w BCC8            * V Set               V=1
02:00002996 60FE            	  4235:                 bra.s *
                            	  4236: 
02:00002998 44FC0000        	  4237: BCC8:           move #$00,CCR
02:0000299C 6A02            	  4238:                 bpl.s BCC9            * Plus                N=0
02:0000299E 60FE            	  4239:                 bra.s *
                            	  4240: 
02:000029A0 44FC0008        	  4241: BCC9:           move #$08,CCR
02:000029A4 6B000004        	  4242:                 bmi.w BCC10           * Minus               N=1
02:000029A8 60FE            	  4243:                 bra.s *
                            	  4244: 
02:000029AA 44FC0000        	  4245: BCC10:          move #$00,CCR
02:000029AE 6C02            	  4246:                 bge.s BCC11           * Greater or Equal    N=V
02:000029B0 60FE            	  4247:                 bra.s *
                            	  4248: 
02:000029B2 44FC0002        	  4249: BCC11:          move #$02,CCR
02:000029B6 6D000004        	  4250:                 blt.w BCC12           * Less Than           N!=V
02:000029BA 60FE            	  4251:                 bra.s *
                            	  4252: 
02:000029BC 44FC000A        	  4253: BCC12:          move #$0A,CCR
02:000029C0 6E02            	  4254:                 bgt.s BCC13           * Greater Than        N=V  AND Z=0
02:000029C2 60FE            	  4255:                 bra.s *
                            	  4256: 
02:000029C4 44FC0006        	  4257: BCC13:          move #$06,CCR
02:000029C8 6F000004        	  4258:                 ble.w BCC14           * Less Than or Equal  N!=V AND Z=1
02:000029CC 60FE            	  4259:                 bra.s *
                            	  4260: 
                            	  4261: 
02:000029CE 4E75            	  4262: BCC14:          rts
                            	  4263: 
                            	  4264: 
                            	  4265: *-----------------------------------------------------------
                            	  4266: *-----------------------------------------------------------
                            	  4267: * OPCODE : DBCC
                            	  4268: *-----------------------------------------------------------
                            	  4269: *-----------------------------------------------------------
                            	  4270: 
02:000029D0 7003            	  4271: op_DBCC:        moveq  #$00000003,d0    * Loop counter
02:000029D2 7200            	  4272:                 moveq  #$00000000,d1    * Accumulator
02:000029D4 44FC0000        	  4273:                 move #$00,CCR
                            	  4274: 
02:000029D8 5201            	  4275: DBCC_LOOP1:     addi.b #$1,d1
02:000029DA 51C8FFFC        	  4276:                 dbf d0,DBCC_LOOP1
                            	  4277: 
02:000029DE 0C8100000004    	  4278:                 cmpi.l #$00000004,d1  * Check Accumulator results
02:000029E4 66FE            	  4279:                 bne.s *
                            	  4280: 
02:000029E6 5201            	  4281: DBCC_LOOP2:     addi.b #$1,d1
02:000029E8 54C8FFFC        	  4282:                 dbcc d0,DBCC_LOOP2    * Dont loop
                            	  4283: 
02:000029EC 0C8100000005    	  4284:                 cmpi.l #$00000005,d1  * Check Accumulator results
02:000029F2 66FE            	  4285:                 bne.s *
                            	  4286: 
02:000029F4 4E75            	  4287:                 rts
                            	  4288: 
                            	  4289: 
                            	  4290: *-----------------------------------------------------------
                            	  4291: *-----------------------------------------------------------
                            	  4292: * OPCODE : SCC
                            	  4293: *-----------------------------------------------------------
                            	  4294: *-----------------------------------------------------------
                            	  4295: 
02:000029F6 44FC0001        	  4296: op_SCC:         move #$01,CCR
02:000029FA 54F900010000    	  4297:                 scc $00010000                   * Clear the EA byte
02:00002A00 4A3900010000    	  4298:                 cmpi.b #$00,$00010000
02:00002A06 66FE            	  4299:                 bne.s *
                            	  4300: 
02:00002A08 44FC0000        	  4301:                 move #$00,CCR
02:00002A0C 54F900010000    	  4302:                 scc $00010000                   * Set the EA byte to 0xFF
02:00002A12 0C3900FF00010000	  4303:                 cmpi.b #$FF,$00010000
02:00002A1A 66FE            	  4304:                 bne.s *
                            	  4305: 
02:00002A1C 4E75            	  4306:                 rts
                            	  4307: 
                            	  4308: 
                            	  4309: 
                            	  4310: *-----------------------------------------------------------
                            	  4311: *-----------------------------------------------------------
                            	  4312: * OPCODE : ADDQ
                            	  4313: *-----------------------------------------------------------
                            	  4314: *-----------------------------------------------------------
                            	  4315: 
                            	  4316: op_ADDQ:
                            	  4317: 
                            	  4318: *     BYTE
02:00002A1E 203C000000FF    	  4319:                 move.l #$000000FF,d0    * Loop counter
02:00002A24 7200            	  4320:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002A26 7400            	  4321:                 moveq  #$00000000,d2    * Data results accumulator
02:00002A28 7600            	  4322:                 moveq  #$00000000,d3
02:00002A2A 7800            	  4323:                 moveq  #$00000000,d4
02:00002A2C 7A00            	  4324:                 moveq  #$00000000,d5
02:00002A2E 7C00            	  4325:                 moveq  #$00000000,d6
02:00002A30 7E00            	  4326:                 moveq  #$00000000,d7
                            	  4327: 
02:00002A32 5605            	  4328: ADDQ_LOOP1:     addq.b #3,d5
02:00002A34 40C6            	  4329:                 move.w SR,d6
02:00002A36 02860000001F    	  4330:                 andi.l #$1F,d6        * Isolate flags
02:00002A3C D286            	  4331:                 add.l d6,d1           * Copy flag results into accumulator
02:00002A3E D485            	  4332:                 add.l d5,d2           * Copy data results into data accumulator
02:00002A40 51C8FFF0        	  4333:                 dbf d0,ADDQ_LOOP1
                            	  4334: 
02:00002A44 0C810000043D    	  4335:                 cmpi.l #$0000043D,d1
02:00002A4A 66FE            	  4336:                 bne.s *
02:00002A4C 0C8200007F80    	  4337:                 cmpi.l #$00007F80,d2
02:00002A52 66FE            	  4338:                 bne.s *
                            	  4339: 
                            	  4340: 
                            	  4341: *     WORD
02:00002A54 203C000000FF    	  4342:                 move.l #$000000FF,d0    * Loop counter
02:00002A5A 7200            	  4343:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002A5C 7400            	  4344:                 moveq  #$00000000,d2    * Data results accumulator
02:00002A5E 7600            	  4345:                 moveq  #$00000000,d3
02:00002A60 7800            	  4346:                 moveq  #$00000000,d4
02:00002A62 2A3C0000FFF0    	  4347:                 move.l #$0000FFF0,d5
02:00002A68 7C00            	  4348:                 moveq  #$00000000,d6
02:00002A6A 7E00            	  4349:                 moveq  #$00000000,d7
02:00002A6C 307C0100        	  4350:                 move.l #$00000100,a0
                            	  4351: 
02:00002A70 5A45            	  4352: ADDQ_LOOP2:     addq.w #5,d5
02:00002A72 40C6            	  4353:                 move.w SR,d6
02:00002A74 02860000001F    	  4354:                 andi.l #$1F,d6        * Isolate flags
02:00002A7A D286            	  4355:                 add.l d6,d1           * Copy flag results into accumulator
02:00002A7C D485            	  4356:                 add.l d5,d2           * Copy data results into data accumulator
02:00002A7E 51C8FFF0        	  4357:                 dbf d0,ADDQ_LOOP2
                            	  4358: 
02:00002A82 0C8100000029    	  4359:                 cmpi.l #$00000029,d1
02:00002A88 66FE            	  4360:                 bne.s *
02:00002A8A 0C8200057280    	  4361:                 cmpi.l #$00057280,d2
02:00002A90 66FE            	  4362:                 bne.s *
                            	  4363: 
                            	  4364: 
                            	  4365: *     LONG
02:00002A92 203C000000FF    	  4366:                 move.l #$000000FF,d0    * Loop counter
02:00002A98 7200            	  4367:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002A9A 7400            	  4368:                 moveq  #$00000000,d2    * Data results accumulator
02:00002A9C 7600            	  4369:                 moveq  #$00000000,d3
02:00002A9E 7800            	  4370:                 moveq  #$00000000,d4
02:00002AA0 7AF0            	  4371:                 move.l #$FFFFFFF0,d5
02:00002AA2 7C00            	  4372:                 moveq  #$00000000,d6
02:00002AA4 7E00            	  4373:                 moveq  #$00000000,d7
                            	  4374: 
02:00002AA6 5285            	  4375: ADDQ_LOOP3:     addq.l #1,d5
02:00002AA8 40C6            	  4376:                 move.w SR,d6
02:00002AAA 02860000001F    	  4377:                 andi.l #$1F,d6        * Isolate flags
02:00002AB0 D286            	  4378:                 add.l d6,d1           * Copy flag results into accumulator
02:00002AB2 D485            	  4379:                 add.l d5,d2           * Copy data results into data accumulator
02:00002AB4 51C8FFF0        	  4380:                 dbf d0,ADDQ_LOOP3
                            	  4381: 
02:00002AB8 0C810000008D    	  4382:                 cmpi.l #$0000008D,d1
02:00002ABE 66FE            	  4383:                 bne.s *
02:00002AC0 0C8200007080    	  4384:                 cmpi.l #$00007080,d2
02:00002AC6 66FE            	  4385:                 bne.s *
                            	  4386: 
                            	  4387: *     Check that Flags are not updated for Address registers
02:00002AC8 207C0000FFFF    	  4388:                 move.l #$0000FFFF,a0
02:00002ACE 44FC0000        	  4389:                 move #$00,CCR         * Clear flags
02:00002AD2 5E48            	  4390:                 addq.w #$7,a0
02:00002AD4 65FE            	  4391:                 bcs.s *
                            	  4392: 
02:00002AD6 4E75            	  4393:                 rts
                            	  4394: 
                            	  4395: 
                            	  4396: 
                            	  4397: *-----------------------------------------------------------
                            	  4398: *-----------------------------------------------------------
                            	  4399: * OPCODE : SUBQ
                            	  4400: *-----------------------------------------------------------
                            	  4401: *-----------------------------------------------------------
                            	  4402: 
                            	  4403: op_SUBQ:
                            	  4404: 
                            	  4405: *     BYTE
02:00002AD8 203C000000FF    	  4406:                 move.l #$000000FF,d0    * Loop counter
02:00002ADE 7200            	  4407:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002AE0 243C00001234    	  4408:                 move.l #$00001234,d2    * Data results accumulator
02:00002AE6 7600            	  4409:                 moveq  #$00000000,d3
02:00002AE8 7800            	  4410:                 moveq  #$00000000,d4
02:00002AEA 7A12            	  4411:                 moveq  #$00000012,d5
02:00002AEC 7C00            	  4412:                 moveq  #$00000000,d6
02:00002AEE 7E00            	  4413:                 moveq  #$00000000,d7
                            	  4414: 
02:00002AF0 5305            	  4415: SUBQ_LOOP1:     subq.b #1,d5
02:00002AF2 40C6            	  4416:                 move.w SR,d6
02:00002AF4 02860000001F    	  4417:                 andi.l #$1F,d6        * Isolate flags
02:00002AFA D286            	  4418:                 add.l d6,d1           * Copy flag results into accumulator
02:00002AFC D485            	  4419:                 add.l d5,d2           * Copy data results into data accumulator
02:00002AFE 51C8FFF0        	  4420:                 dbf d0,SUBQ_LOOP1
                            	  4421: 
02:00002B02 0C8100000417    	  4422:                 cmpi.l #$00000417,d1
02:00002B08 66FE            	  4423:                 bne.s *
02:00002B0A 0C82000091B4    	  4424:                 cmpi.l #$000091B4,d2
02:00002B10 66FE            	  4425:                 bne.s *
                            	  4426: 
                            	  4427: 
                            	  4428: *     WORD
02:00002B12 203C000000FF    	  4429:                 move.l #$000000FF,d0    * Loop counter
02:00002B18 7200            	  4430:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002B1A 7400            	  4431:                 moveq  #$00000000,d2    * Data results accumulator
02:00002B1C 7600            	  4432:                 moveq  #$00000000,d3
02:00002B1E 7800            	  4433:                 moveq  #$00000000,d4
02:00002B20 7A02            	  4434:                 moveq  #$00000002,d5
02:00002B22 7C00            	  4435:                 moveq  #$00000000,d6
02:00002B24 7E00            	  4436:                 moveq  #$00000000,d7
02:00002B26 307C0100        	  4437:                 move.l #$00000100,a0
                            	  4438: 
02:00002B2A 5B45            	  4439: SUBQ_LOOP2:     subq.w #5,d5
02:00002B2C 40C6            	  4440:                 move.w SR,d6
02:00002B2E 02860000001F    	  4441:                 andi.l #$1F,d6        * Isolate flags
02:00002B34 D286            	  4442:                 add.l d6,d1           * Copy flag results into accumulator
02:00002B36 D485            	  4443:                 add.l d5,d2           * Copy data results into data accumulator
02:00002B38 51C8FFF0        	  4444:                 dbf d0,SUBQ_LOOP2
                            	  4445: 
02:00002B3C 0C8100000811    	  4446:                 cmpi.l #$00000811,d1
02:00002B42 66FE            	  4447:                 bne.s *
02:00002B44 0C8200FD7F80    	  4448:                 cmpi.l #$00FD7F80,d2
02:00002B4A 66FE            	  4449:                 bne.s *
                            	  4450: 
                            	  4451: 
                            	  4452: *     LONG
02:00002B4C 203C000000FF    	  4453:                 move.l #$000000FF,d0    * Loop counter
02:00002B52 7200            	  4454:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002B54 7400            	  4455:                 moveq  #$00000000,d2    * Data results accumulator
02:00002B56 7600            	  4456:                 moveq  #$00000000,d3
02:00002B58 7800            	  4457:                 moveq  #$00000000,d4
02:00002B5A 7A07            	  4458:                 moveq  #$00000007,d5
02:00002B5C 7C00            	  4459:                 moveq  #$00000000,d6
02:00002B5E 7E00            	  4460:                 moveq  #$00000000,d7
                            	  4461: 
02:00002B60 5385            	  4462: SUBQ_LOOP3:     subq.l #1,d5
02:00002B62 40C6            	  4463:                 move.w SR,d6
02:00002B64 02860000001F    	  4464:                 andi.l #$1F,d6        * Isolate flags
02:00002B6A D286            	  4465:                 add.l d6,d1           * Copy flag results into accumulator
02:00002B6C D485            	  4466:                 add.l d5,d2           * Copy data results into data accumulator
02:00002B6E 51C8FFF0        	  4467:                 dbf d0,SUBQ_LOOP3
                            	  4468: 
02:00002B72 0C81000007DD    	  4469:                 cmpi.l #$000007DD,d1
02:00002B78 66FE            	  4470:                 bne.s *
02:00002B7A 0C82FFFF8680    	  4471:                 cmpi.l #$FFFF8680,d2
02:00002B80 66FE            	  4472:                 bne.s *
                            	  4473: 
                            	  4474: *     Check that Flags are not updated for Address registers
02:00002B82 207C0001FFFF    	  4475:                 move.l #$0001FFFF,a0
02:00002B88 44FC0000        	  4476:                 move #$00,CCR         * Clear flags
02:00002B8C 5F48            	  4477:                 subq.w #$7,a0
02:00002B8E 65FE            	  4478:                 bcs.s *
                            	  4479: 
02:00002B90 4E75            	  4480:                 rts
                            	  4481: 
                            	  4482: 
                            	  4483: 
                            	  4484: 
                            	  4485: *-----------------------------------------------------------
                            	  4486: *-----------------------------------------------------------
                            	  4487: * OPCODE : MOVEQ
                            	  4488: *-----------------------------------------------------------
                            	  4489: *-----------------------------------------------------------
                            	  4490: 
                            	  4491: op_MOVEQ:
02:00002B92 7000            	  4492:                 moveq  #$00000000,d0
02:00002B94 7000            	  4493:                 moveq #$0,d0
02:00002B96 66FE            	  4494:                 bne.s *
02:00002B98 4A80            	  4495:                 cmpi.l #$00000000,d0
02:00002B9A 66FE            	  4496:                 bne.s *
                            	  4497: 
02:00002B9C 7000            	  4498:                 moveq  #$00000000,d0
02:00002B9E 7080            	  4499:                 moveq #-128,d0
02:00002BA0 67FE            	  4500:                 beq.s *
02:00002BA2 6AFE            	  4501:                 bpl.s *
02:00002BA4 0C80FFFFFF80    	  4502:                 cmpi.l #$FFFFFF80,d0
02:00002BAA 66FE            	  4503:                 bne.s *
                            	  4504: 
                            	  4505: 
02:00002BAC 4E75            	  4506:                 rts
                            	  4507: 
                            	  4508: 
                            	  4509: *-----------------------------------------------------------
                            	  4510: *-----------------------------------------------------------
                            	  4511: * OPCODE : DIVU
                            	  4512: *-----------------------------------------------------------
                            	  4513: *-----------------------------------------------------------
                            	  4514: 
                            	  4515: op_DIVU:
                            	  4516: 
02:00002BAE 203CA5A5A5A5    	  4517:                 move.l #$a5a5a5a5,d0        * Initial Numerator
02:00002BB4 223C00005A5A    	  4518:                 move.l #$00005a5a,d1        * Initial Divisor
02:00002BBA 243CA5A5A5A5    	  4519:                 move.l #$a5a5a5a5,d2
02:00002BC0 7600            	  4520:                 moveq  #$00000000,d3
02:00002BC2 7800            	  4521:                 moveq  #$00000000,d4        * Cumulative data results
02:00002BC4 7A00            	  4522:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002BC6 7C0E            	  4523:                 move.l #$0000000E,d6       * Inner loop counter
02:00002BC8 7E1E            	  4524:                 move.l #$0000001E,d7       * Outer loop counter
                            	  4525: 
                            	  4526: 
02:00002BCA 80C1            	  4527: DIVU_OUTER1:    divu d1,d0               * !! Easy68K C not always cleared
02:00002BCC 40C3            	  4528:                 move.w SR,d3
02:00002BCE 02830000000C    	  4529:                 andi.l #$0C,d3            * Isolate flags
02:00002BD4 DA83            	  4530:                 add.l d3,d5               * Copy flag results into accumulator
02:00002BD6 D880            	  4531:                 add.l d0,d4               * Copy data results into data accumulator
02:00002BD8 E289            	  4532:                 lsr.l #$1,d1
                            	  4533: 
02:00002BDA 51CEFFEE        	  4534:                 dbf d6,DIVU_OUTER1
02:00002BDE E28A            	  4535:                 lsr.l #$1,d2
02:00002BE0 2002            	  4536:                 move.l d2,d0
02:00002BE2 223C00005A5A    	  4537:                 move.l #$00005a5a,d1       * Initial Divisor
02:00002BE8 7C0E            	  4538:                 move.l #$0000000E,d6       * Inner loop counter
02:00002BEA 51CFFFDE        	  4539:                 dbf d7,DIVU_OUTER1
                            	  4540: 
02:00002BEE 0C8492FEDB89    	  4541:                 cmpi.l #$92FEDB89,d4      * Check the data results
02:00002BF4 66FE            	  4542:                 bne.s *
                            	  4543: 
02:00002BF6 0C8500000110    	  4544:                 cmpi.l #$00000110,d5      * Check the Flag results
02:00002BFC 66FE            	  4545:                 bne.s *
                            	  4546: 
                            	  4547: 
02:00002BFE 4E75            	  4548:                 rts
                            	  4549: 
                            	  4550: 
                            	  4551: 
                            	  4552: *-----------------------------------------------------------
                            	  4553: *-----------------------------------------------------------
                            	  4554: * OPCODE : DIVS
                            	  4555: *-----------------------------------------------------------
                            	  4556: *-----------------------------------------------------------
                            	  4557: 
                            	  4558: op_DIVS:
                            	  4559: 
02:00002C00 203CA5A5A5A5    	  4560:                 move.l #$a5a5a5a5,d0        * Initial Numerator
02:00002C06 223C00005A5A    	  4561:                 move.l #$00005a5a,d1        * Initial Divisor
02:00002C0C 243CA5A5A5A5    	  4562:                 move.l #$a5a5a5a5,d2
02:00002C12 7600            	  4563:                 moveq  #$00000000,d3
02:00002C14 7800            	  4564:                 moveq  #$00000000,d4        * Cumulative data results
02:00002C16 7A00            	  4565:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002C18 7C0E            	  4566:                 move.l #$0000000E,d6       * Inner loop counter
02:00002C1A 7E1E            	  4567:                 move.l #$0000001E,d7       * Outer loop counter
                            	  4568: 
                            	  4569: 
02:00002C1C 81C1            	  4570: DIVS_OUTER1:    divs d1,d0               * !! Easy68K C not always cleared
02:00002C1E 40C3            	  4571:                 move.w SR,d3
02:00002C20 02830000000C    	  4572:                 andi.l #$0C,d3            * Isolate flags
02:00002C26 DA83            	  4573:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C28 D880            	  4574:                 add.l d0,d4               * Copy data results into data accumulator
02:00002C2A E289            	  4575:                 lsr.l #$1,d1
                            	  4576: 
02:00002C2C 51CEFFEE        	  4577:                 dbf d6,DIVS_OUTER1
02:00002C30 E28A            	  4578:                 lsr.l #$1,d2
02:00002C32 2002            	  4579:                 move.l d2,d0
02:00002C34 223C00005A5A    	  4580:                 move.l #$00005a5a,d1       * Initial Divisor
02:00002C3A 7C0E            	  4581:                 move.l #$0000000E,d6       * Inner loop counter
02:00002C3C 51CFFFDE        	  4582:                 dbf d7,DIVS_OUTER1
                            	  4583: 
02:00002C40 0C844EC5D057    	  4584:                 cmpi.l #$4EC5D057,d4      * Check the data results
02:00002C46 66FE            	  4585:                 bne.s *
                            	  4586: 
02:00002C48 0C8500000038    	  4587:                 cmpi.l #$00000038,d5      * Check the Flag results
02:00002C4E 66FE            	  4588:                 bne.s *
                            	  4589: 
                            	  4590: 
02:00002C50 4E75            	  4591:                 rts
                            	  4592: 
                            	  4593: 
                            	  4594: 
                            	  4595: *-----------------------------------------------------------
                            	  4596: *-----------------------------------------------------------
                            	  4597: * OPCODE : OR
                            	  4598: *-----------------------------------------------------------
                            	  4599: *-----------------------------------------------------------
                            	  4600: 
                            	  4601: op_OR:
                            	  4602: 
                            	  4603: *  * <EA> to Register
                            	  4604: 
02:00002C52 203CA5A5A5A5    	  4605:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002C58 223C8167E123    	  4606:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002C5E 243CA5A5A5A5    	  4607:                 move.l #$a5a5a5a5,d2
02:00002C64 7600            	  4608:                 moveq  #$00000000,d3
02:00002C66 7800            	  4609:                 moveq  #$00000000,d4       * Cumulative data results
02:00002C68 7A00            	  4610:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002C6A 7C1E            	  4611:                 move.l #$0000001E,d6       * Inner loop counter
02:00002C6C 7E1E            	  4612:                 move.l #$0000001E,d7       * Outer loop counter
02:00002C6E 307C0100        	  4613:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4614: 
                            	  4615: 
                            	  4616: OR_OUTER1:
                            	  4617: 
                            	  4618: *     BYTE
02:00002C72 2081            	  4619:                 move.l d1,(a0)
02:00002C74 8010            	  4620:                 or.b (a0),d0
02:00002C76 40C3            	  4621:                 move.w SR,d3
02:00002C78 02830000000C    	  4622:                 andi.l #$0C,d3            * Isolate flags
02:00002C7E DA83            	  4623:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C80 D880            	  4624:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4625: 
                            	  4626: *     WORD
02:00002C82 2081            	  4627:                 move.l d1,(a0)
02:00002C84 8050            	  4628:                 or.w (a0),d0
02:00002C86 40C3            	  4629:                 move.w SR,d3
02:00002C88 02830000000C    	  4630:                 andi.l #$0C,d3            * Isolate flags
02:00002C8E DA83            	  4631:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C90 D880            	  4632:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4633: 
                            	  4634: *     LONG
02:00002C92 2081            	  4635:                 move.l d1,(a0)
02:00002C94 8090            	  4636:                 or.l (a0),d0
02:00002C96 40C3            	  4637:                 move.w SR,d3
02:00002C98 02830000000F    	  4638:                 andi.l #$0F,d3            * Isolate flags
02:00002C9E DA83            	  4639:                 add.l d3,d5               * Copy flag results into accumulator
02:00002CA0 D880            	  4640:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4641: 
                            	  4642: 
02:00002CA2 E289            	  4643:                 lsr.l #$1,d1
02:00002CA4 51CEFFCC        	  4644:                 dbf d6,OR_OUTER1
02:00002CA8 E28A            	  4645:                 lsr.l #$1,d2
02:00002CAA 223C8167E123    	  4646:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002CB0 7C1E            	  4647:                 move.l #$0000001E,d6       * Inner loop counter
02:00002CB2 51CFFFBE        	  4648:                 dbf d7,OR_OUTER1
                            	  4649: 
02:00002CB6 0C8476EAC803    	  4650:                 cmpi.l #$76EAC803,d4      * Check the data results
02:00002CBC 66FE            	  4651:                 bne.s *
02:00002CBE 0C8500005A18    	  4652:                 cmpi.l #$00005A18,d5      * Check the Flag results
02:00002CC4 66FE            	  4653:                 bne.s *
                            	  4654: 
                            	  4655: 
                            	  4656: *  * Register to <EA>
                            	  4657: 
02:00002CC6 203C86738374    	  4658:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00002CCC 223CFC55F2FE    	  4659:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00002CD2 243C86738374    	  4660:                 move.l #$86738374,d2
02:00002CD8 7600            	  4661:                 moveq  #$00000000,d3
02:00002CDA 7800            	  4662:                 moveq  #$00000000,d4       * Cumulative data results
02:00002CDC 7A00            	  4663:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002CDE 7C1E            	  4664:                 move.l #$0000001E,d6       * Inner loop counter
02:00002CE0 7E1D            	  4665:                 move.l #$0000001D,d7       * Outer loop counter
02:00002CE2 307C0100        	  4666:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4667: 
                            	  4668: 
                            	  4669: OR_OUTER2:
                            	  4670: 
                            	  4671: *     BYTE
02:00002CE6 2080            	  4672:                 move.l d0,(a0)
02:00002CE8 8310            	  4673:                 or.b d1,(a0)
02:00002CEA 40C3            	  4674:                 move.w SR,d3
02:00002CEC 02830000000C    	  4675:                 andi.l #$0C,d3            * Isolate flags
02:00002CF2 DA83            	  4676:                 add.l d3,d5               * Copy flag results into accumulator
02:00002CF4 D890            	  4677:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4678: 
                            	  4679: *     WORD
02:00002CF6 2080            	  4680:                 move.l d0,(a0)
02:00002CF8 8350            	  4681:                 or.w d1,(a0)
02:00002CFA 40C3            	  4682:                 move.w SR,d3
02:00002CFC 02830000000C    	  4683:                 andi.l #$0C,d3            * Isolate flags
02:00002D02 DA83            	  4684:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D04 D890            	  4685:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4686: 
                            	  4687: *     LONG
02:00002D06 2080            	  4688:                 move.l d0,(a0)
02:00002D08 8390            	  4689:                 or.l d1,(a0)
02:00002D0A 40C3            	  4690:                 move.w SR,d3
02:00002D0C 02830000000F    	  4691:                 andi.l #$0F,d3            * Isolate flags
02:00002D12 DA83            	  4692:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D14 D890            	  4693:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4694: 
                            	  4695: 
02:00002D16 E289            	  4696:                 lsr.l #$1,d1
02:00002D18 51CEFFCC        	  4697:                 dbf d6,OR_OUTER2
02:00002D1C E28A            	  4698:                 lsr.l #$1,d2
02:00002D1E 223C8167E123    	  4699:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002D24 7C1E            	  4700:                 move.l #$0000001E,d6       * Inner loop counter
02:00002D26 51CFFFBE        	  4701:                 dbf d7,OR_OUTER2
                            	  4702: 
02:00002D2A 0C84FA82B9E4    	  4703:                 cmpi.l #$FA82B9E4,d4      * Check the data results
02:00002D30 66FE            	  4704:                 bne.s *
02:00002D32 0C8500005730    	  4705:                 cmpi.l #$00005730,d5      * Check the Flag results
02:00002D38 66FE            	  4706:                 bne.s *
                            	  4707: 
                            	  4708: 
02:00002D3A 4E75            	  4709:                 rts
                            	  4710: 
                            	  4711: 
                            	  4712: 
                            	  4713: *-----------------------------------------------------------
                            	  4714: *-----------------------------------------------------------
                            	  4715: * OPCODE : AND
                            	  4716: *-----------------------------------------------------------
                            	  4717: *-----------------------------------------------------------
                            	  4718: 
                            	  4719: op_AND:
                            	  4720: 
                            	  4721: *  * <EA> to Register
                            	  4722: 
02:00002D3C 203CA5A5A5A5    	  4723:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002D42 223C8167E123    	  4724:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002D48 243CA5A5A5A5    	  4725:                 move.l #$a5a5a5a5,d2
02:00002D4E 7600            	  4726:                 moveq  #$00000000,d3
02:00002D50 7800            	  4727:                 moveq  #$00000000,d4       * Cumulative data results
02:00002D52 7A00            	  4728:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002D54 7C1E            	  4729:                 move.l #$0000001E,d6       * Inner loop counter
02:00002D56 7E1E            	  4730:                 move.l #$0000001E,d7       * Outer loop counter
02:00002D58 307C0100        	  4731:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4732: 
                            	  4733: 
                            	  4734: AND_OUTER1:
                            	  4735: 
                            	  4736: *     BYTE
02:00002D5C 2081            	  4737:                 move.l d1,(a0)
02:00002D5E C010            	  4738:                 and.b (a0),d0
02:00002D60 40C3            	  4739:                 move.w sr,d3
02:00002D62 02830000000C    	  4740:                 andi.l #$0C,d3            * Isolate flags
02:00002D68 DA83            	  4741:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D6A D880            	  4742:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4743: 
                            	  4744: *     WORD
02:00002D6C 2081            	  4745:                 move.l d1,(a0)
02:00002D6E C050            	  4746:                 and.w (a0),d0
02:00002D70 40C3            	  4747:                 move.w sr,d3
02:00002D72 02830000000C    	  4748:                 andi.l #$0C,d3            * Isolate flags
02:00002D78 DA83            	  4749:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D7A D880            	  4750:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4751: 
                            	  4752: *     LONG
02:00002D7C 2081            	  4753:                 move.l d1,(a0)
02:00002D7E C090            	  4754:                 and.l (a0),d0
02:00002D80 40C3            	  4755:                 move.w sr,d3
02:00002D82 02830000000F    	  4756:                 andi.l #$0F,d3            * Isolate flags
02:00002D88 DA83            	  4757:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D8A D880            	  4758:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4759: 
                            	  4760: 
02:00002D8C E289            	  4761:                 lsr.l #$1,d1
02:00002D8E 51CEFFCC        	  4762:                 dbf d6,AND_OUTER1
02:00002D92 E28A            	  4763:                 lsr.l #$1,d2
02:00002D94 223C8167E123    	  4764:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002D9A 7C1E            	  4765:                 move.l #$0000001E,d6       * Inner loop counter
02:00002D9C 51CFFFBE        	  4766:                 dbf d7,AND_OUTER1
                            	  4767: 
02:00002DA0 0C84CF212883    	  4768:                 cmpi.l #$CF212883,d4      * Check the data results
02:00002DA6 66FE            	  4769:                 bne.s *
02:00002DA8 0C8500002D10    	  4770:                 cmpi.l #$00002D10,d5      * Check the Flag results
02:00002DAE 66FE            	  4771:                 bne.s *
                            	  4772: 
                            	  4773: 
                            	  4774: *  * Register to <EA>
                            	  4775: 
02:00002DB0 203C86738374    	  4776:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00002DB6 223CFC55F2FE    	  4777:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00002DBC 243C86738374    	  4778:                 move.l #$86738374,d2
02:00002DC2 7600            	  4779:                 moveq  #$00000000,d3
02:00002DC4 7800            	  4780:                 moveq  #$00000000,d4       * Cumulative data results
02:00002DC6 7A00            	  4781:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002DC8 7C1E            	  4782:                 move.l #$0000001E,d6       * Inner loop counter
02:00002DCA 7E1D            	  4783:                 move.l #$0000001D,d7       * Outer loop counter
02:00002DCC 307C0100        	  4784:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4785: 
                            	  4786: 
                            	  4787: AND_OUTER2:
                            	  4788: 
                            	  4789: *     BYTE
02:00002DD0 2080            	  4790:                 move.l d0,(a0)
02:00002DD2 C310            	  4791:                 and.b d1,(a0)
02:00002DD4 40C3            	  4792:                 move.w sr,d3
02:00002DD6 02830000000C    	  4793:                 andi.l #$0C,d3            * Isolate flags
02:00002DDC DA83            	  4794:                 add.l d3,d5               * Copy flag results into accumulator
02:00002DDE D890            	  4795:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4796: 
                            	  4797: *     WORD
02:00002DE0 2080            	  4798:                 move.l d0,(a0)
02:00002DE2 C350            	  4799:                 and.w d1,(a0)
02:00002DE4 40C3            	  4800:                 move.w sr,d3
02:00002DE6 02830000000C    	  4801:                 andi.l #$0C,d3            * Isolate flags
02:00002DEC DA83            	  4802:                 add.l d3,d5               * Copy flag results into accumulator
02:00002DEE D890            	  4803:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4804: 
                            	  4805: *     LONG
02:00002DF0 2080            	  4806:                 move.l d0,(a0)
02:00002DF2 C390            	  4807:                 and.l d1,(a0)
02:00002DF4 40C3            	  4808:                 move.w sr,d3
02:00002DF6 02830000000F    	  4809:                 andi.l #$0F,d3            * Isolate flags
02:00002DFC DA83            	  4810:                 add.l d3,d5               * Copy flag results into accumulator
02:00002DFE D890            	  4811:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4812: 
                            	  4813: 
02:00002E00 E289            	  4814:                 lsr.l #$1,d1
02:00002E02 51CEFFCC        	  4815:                 dbf d6,AND_OUTER2
02:00002E06 E28A            	  4816:                 lsr.l #$1,d2
02:00002E08 223C8167E123    	  4817:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002E0E 7C1E            	  4818:                 move.l #$0000001E,d6       * Inner loop counter
02:00002E10 51CFFFBE        	  4819:                 dbf d7,AND_OUTER2
                            	  4820: 
02:00002E14 0C844A3DE544    	  4821:                 cmpi.l #$4A3DE544,d4      * Check the data results
02:00002E1A 66FE            	  4822:                 bne.s *
02:00002E1C 0C85000018E8    	  4823:                 cmpi.l #$000018E8,d5      * Check the Flag results
02:00002E22 66FE            	  4824:                 bne.s *
                            	  4825: 
                            	  4826: 
02:00002E24 4E75            	  4827:                 rts
                            	  4828: 
                            	  4829: 
                            	  4830: 
                            	  4831: *-----------------------------------------------------------
                            	  4832: *-----------------------------------------------------------
                            	  4833: * OPCODE : EOR
                            	  4834: *-----------------------------------------------------------
                            	  4835: *-----------------------------------------------------------
                            	  4836: 
                            	  4837: op_EOR:
                            	  4838: 
                            	  4839: *  * Register to <EA>
                            	  4840: 
02:00002E26 203C86738374    	  4841:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00002E2C 223CFC55F2FE    	  4842:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00002E32 243C86738374    	  4843:                 move.l #$86738374,d2
02:00002E38 7600            	  4844:                 moveq  #$00000000,d3
02:00002E3A 7800            	  4845:                 moveq  #$00000000,d4       * Cumulative data results
02:00002E3C 7A00            	  4846:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002E3E 7C1E            	  4847:                 move.l #$0000001E,d6       * Inner loop counter
02:00002E40 7E1D            	  4848:                 move.l #$0000001D,d7       * Outer loop counter
02:00002E42 307C0100        	  4849:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4850: 
                            	  4851: 
                            	  4852: EOR_OUTER2:
                            	  4853: 
                            	  4854: *     BYTE
02:00002E46 2080            	  4855:                 move.l d0,(a0)
02:00002E48 B310            	  4856:                 eor.b d1,(a0)
02:00002E4A 40C3            	  4857:                 move.w sr,d3
02:00002E4C 02830000000C    	  4858:                 andi.l #$0C,d3            * Isolate flags
02:00002E52 DA83            	  4859:                 add.l d3,d5               * Copy flag results into accumulator
02:00002E54 D890            	  4860:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4861: 
                            	  4862: *     WORD
02:00002E56 2080            	  4863:                 move.l d0,(a0)
02:00002E58 B350            	  4864:                 eor.w d1,(a0)
02:00002E5A 40C3            	  4865:                 move.w sr,d3
02:00002E5C 02830000000C    	  4866:                 andi.l #$0C,d3            * Isolate flags
02:00002E62 DA83            	  4867:                 add.l d3,d5               * Copy flag results into accumulator
02:00002E64 D890            	  4868:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4869: 
                            	  4870: *     LONG
02:00002E66 2080            	  4871:                 move.l d0,(a0)
02:00002E68 B390            	  4872:                 eor.l d1,(a0)
02:00002E6A 40C3            	  4873:                 move.w sr,d3
02:00002E6C 02830000000F    	  4874:                 andi.l #$0F,d3            * Isolate flags
02:00002E72 DA83            	  4875:                 add.l d3,d5               * Copy flag results into accumulator
02:00002E74 D890            	  4876:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4877: 
                            	  4878: 
02:00002E76 E289            	  4879:                 lsr.l #$1,d1
02:00002E78 51CEFFCC        	  4880:                 dbf d6,EOR_OUTER2
02:00002E7C E28A            	  4881:                 lsr.l #$1,d2
02:00002E7E 223C8167E123    	  4882:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002E84 7C1E            	  4883:                 move.l #$0000001E,d6       * Inner loop counter
02:00002E86 51CFFFBE        	  4884:                 dbf d7,EOR_OUTER2
                            	  4885: 
02:00002E8A 0C8455C5EB70    	  4886:                 cmpi.l #$55C5EB70,d4      * Check the data results
02:00002E90 66FE            	  4887:                 bne.s *
02:00002E92 0C8500004430    	  4888:                 cmpi.l #$00004430,d5      * Check the Flag results
02:00002E98 66FE            	  4889:                 bne.s *
                            	  4890: 
                            	  4891: 
02:00002E9A 4E75            	  4892:                 rts
                            	  4893: 
                            	  4894: 
                            	  4895: *-----------------------------------------------------------
                            	  4896: *-----------------------------------------------------------
                            	  4897: * OPCODE : CMP
                            	  4898: *-----------------------------------------------------------
                            	  4899: *-----------------------------------------------------------
                            	  4900: 
                            	  4901: op_CMP:
                            	  4902: 
                            	  4903: 
                            	  4904: *  * <EA> to Register
                            	  4905: 
02:00002E9C 203CA5A5A5A5    	  4906:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002EA2 223C8167E123    	  4907:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002EA8 243CA5A5A5A5    	  4908:                 move.l #$a5a5a5a5,d2
02:00002EAE 7600            	  4909:                 moveq  #$00000000,d3
02:00002EB0 7800            	  4910:                 moveq  #$00000000,d4       * Cumulative data results
02:00002EB2 7A00            	  4911:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002EB4 7C1E            	  4912:                 move.l #$0000001E,d6       * Inner loop counter
02:00002EB6 7E1E            	  4913:                 move.l #$0000001E,d7       * Outer loop counter
02:00002EB8 307C0100        	  4914:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4915: 
                            	  4916: 
                            	  4917: CMP_OUTER1:
                            	  4918: 
                            	  4919: *     BYTE
02:00002EBC 2081            	  4920:                 move.l d1,(a0)
02:00002EBE B010            	  4921:                 cmp.b (a0),d0
02:00002EC0 40C3            	  4922:                 move.w sr,d3
02:00002EC2 02830000000F    	  4923:                 andi.l #$0F,d3            * Isolate flags
02:00002EC8 DA83            	  4924:                 add.l d3,d5               * Copy flag results into accumulator
02:00002ECA D880            	  4925:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4926: 
                            	  4927: *     WORD
02:00002ECC 2081            	  4928:                 move.l d1,(a0)
02:00002ECE B050            	  4929:                 cmp.w (a0),d0
02:00002ED0 40C3            	  4930:                 move.w sr,d3
02:00002ED2 02830000000F    	  4931:                 andi.l #$0F,d3            * Isolate flags
02:00002ED8 DA83            	  4932:                 add.l d3,d5               * Copy flag results into accumulator
02:00002EDA D880            	  4933:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4934: 
                            	  4935: *     LONG
02:00002EDC 2081            	  4936:                 move.l d1,(a0)
02:00002EDE B090            	  4937:                 cmp.l (a0),d0
02:00002EE0 40C3            	  4938:                 move.w sr,d3
02:00002EE2 02830000000F    	  4939:                 andi.l #$0F,d3            * Isolate flags
02:00002EE8 DA83            	  4940:                 add.l d3,d5               * Copy flag results into accumulator
02:00002EEA D880            	  4941:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4942: 
                            	  4943: 
02:00002EEC E289            	  4944:                 lsr.l #$1,d1
02:00002EEE 51CEFFCC        	  4945:                 dbf d6,CMP_OUTER1
02:00002EF2 E28A            	  4946:                 lsr.l #$1,d2
02:00002EF4 223C8167E123    	  4947:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002EFA 7C1E            	  4948:                 move.l #$0000001E,d6       * Inner loop counter
02:00002EFC 51CFFFBE        	  4949:                 dbf d7,CMP_OUTER1
                            	  4950: 
02:00002F00 0C847878712F    	  4951:                 cmpi.l #$7878712F,d4      * Check the data results
02:00002F06 66FE            	  4952:                 bne.s *
02:00002F08 0C8500005502    	  4953:                 cmpi.l #$00005502,d5      * Check the Flag results
02:00002F0E 66FE            	  4954:                 bne.s *
                            	  4955: 
                            	  4956: 
                            	  4957: 
02:00002F10 4E75            	  4958:                 rts
                            	  4959: 
                            	  4960: 
                            	  4961: *-----------------------------------------------------------
                            	  4962: *-----------------------------------------------------------
                            	  4963: * OPCODE : CMPA
                            	  4964: *-----------------------------------------------------------
                            	  4965: *-----------------------------------------------------------
                            	  4966: 
                            	  4967: op_CMPA:
                            	  4968: 
                            	  4969: 
                            	  4970: *  * <EA> to Register
                            	  4971: 
02:00002F12 207CA5A5A5A5    	  4972:                 move.l #$a5a5a5a5,a0       * Initial Data-X  Inner loop
02:00002F18 223C8167E123    	  4973:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002F1E 243CA5A5A5A5    	  4974:                 move.l #$a5a5a5a5,d2
02:00002F24 7600            	  4975:                 moveq  #$00000000,d3
02:00002F26 7800            	  4976:                 moveq  #$00000000,d4       * Cumulative data results
02:00002F28 7A00            	  4977:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002F2A 7C1E            	  4978:                 move.l #$0000001E,d6       * Inner loop counter
02:00002F2C 7E1E            	  4979:                 move.l #$0000001E,d7       * Outer loop counter
02:00002F2E 327C0100        	  4980:                 move.l #$00000100,a1       * Address for memory EA operations
                            	  4981: 
                            	  4982: 
                            	  4983: CMPA_OUTER1:
                            	  4984: 
                            	  4985: 
                            	  4986: *     WORD
02:00002F32 2281            	  4987:                 move.l d1,(a1)
02:00002F34 B0D1            	  4988:                 cmpa.w (a1),a0
02:00002F36 40C3            	  4989:                 move.w sr,d3
02:00002F38 02830000000F    	  4990:                 andi.l #$0F,d3            * Isolate flags
02:00002F3E DA83            	  4991:                 add.l d3,d5               * Copy flag results into accumulator
02:00002F40 D888            	  4992:                 add.l a0,d4               * Copy data results into data accumulator
                            	  4993: 
                            	  4994: *     LONG
02:00002F42 2281            	  4995:                 move.l d1,(a1)
02:00002F44 B1D1            	  4996:                 cmpa.l (a1),a0
02:00002F46 40C3            	  4997:                 move.w sr,d3
02:00002F48 02830000000F    	  4998:                 andi.l #$0F,d3            * Isolate flags
02:00002F4E DA83            	  4999:                 add.l d3,d5               * Copy flag results into accumulator
02:00002F50 D888            	  5000:                 add.l a0,d4               * Copy data results into data accumulator
                            	  5001: 
                            	  5002: 
02:00002F52 E289            	  5003:                 lsr.l #$1,d1
02:00002F54 51CEFFDC        	  5004:                 dbf d6,CMPA_OUTER1
02:00002F58 E28A            	  5005:                 lsr.l #$1,d2
02:00002F5A 223C8167E123    	  5006:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002F60 7C1E            	  5007:                 move.l #$0000001E,d6       * Inner loop counter
02:00002F62 51CFFFCE        	  5008:                 dbf d7,CMPA_OUTER1
                            	  5009: 
02:00002F66 0C84A5A5A0CA    	  5010:                 cmpi.l #$a5a5a0ca,d4      * Check the data results
02:00002F6C 66FE            	  5011:                 bne.s *
02:00002F6E 0C8500003A7D    	  5012:                 cmpi.l #$00003A7D,d5      * Check the Flag results
02:00002F74 66FE            	  5013:                 bne.s *
                            	  5014: 
                            	  5015: 
02:00002F76 4E75            	  5016:                 rts
                            	  5017: 
                            	  5018: 
                            	  5019: 
                            	  5020: *-----------------------------------------------------------
                            	  5021: *-----------------------------------------------------------
                            	  5022: * OPCODE : CMPM
                            	  5023: *-----------------------------------------------------------
                            	  5024: *-----------------------------------------------------------
                            	  5025: 
                            	  5026: op_CMPM:
                            	  5027: 
02:00002F78 307C0100        	  5028:                 move.l #$00000100,a0       * Address for Data-X
02:00002F7C 327C0200        	  5029:                 move.l #$00000200,a1       * Address for Data-Y
02:00002F80 7000            	  5030:                 moveq  #$00000000,d0
02:00002F82 7200            	  5031:                 moveq  #$00000000,d1
02:00002F84 7400            	  5032:                 moveq  #$00000000,d2
                            	  5033: 
02:00002F86 20FC11FF5580    	  5034:                 move.l #$11FF5580,(a0)+   * Populate test data
02:00002F8C 20FC1111FFFF    	  5035:                 move.l #$1111FFFF,(a0)+   * Populate test data
02:00002F92 20FC33333333    	  5036:                 move.l #$33333333,(a0)+   * Populate test data
02:00002F98 20FC44444444    	  5037:                 move.l #$44444444,(a0)+   * Populate test data
                            	  5038: 
02:00002F9E 22FC80FF337F    	  5039:                 move.l #$80FF337F,(a1)+   * Populate test data
02:00002FA4 22FCFFFF1111    	  5040:                 move.l #$FFFF1111,(a1)+   * Populate test data
02:00002FAA 22FC33333333    	  5041:                 move.l #$33333333,(a1)+   * Populate test data
02:00002FB0 22FC44444444    	  5042:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5043: 
02:00002FB6 307C0100        	  5044:                 move.l #$00000100,a0       * Address for Data-X
02:00002FBA 327C0200        	  5045:                 move.l #$00000200,a1       * Address for Data-Y
02:00002FBE 7C0F            	  5046:                 move.l #$0000000F,d6       * Loop counter
                            	  5047: 
02:00002FC0 B308            	  5048: CMPM_LOOP1:     cmpm.b (a0)+,(a1)+
02:00002FC2 40C3            	  5049:                 move.w sr,d3
02:00002FC4 02830000000F    	  5050:                 andi.l #$0F,d3            * Isolate flags
02:00002FCA D083            	  5051:                 add.l d3,d0               * Copy flag results into accumulator
02:00002FCC 51CEFFF2        	  5052:                 dbf d6,CMPM_LOOP1
                            	  5053: 
                            	  5054: 
02:00002FD0 307C0100        	  5055:                 move.l #$00000100,a0       * Address for Data-X
02:00002FD4 327C0200        	  5056:                 move.l #$00000200,a1       * Address for Data-Y
02:00002FD8 7C07            	  5057:                 moveq  #$00000007,d6       * Loop counter
                            	  5058: 
02:00002FDA B348            	  5059: CMPM_LOOP2:     cmpm.w (a0)+,(a1)+
02:00002FDC 40C3            	  5060:                 move.w sr,d3
02:00002FDE 02830000000F    	  5061:                 andi.l #$0F,d3            * Isolate flags
02:00002FE4 D283            	  5062:                 add.l d3,d1               * Copy flag results into accumulator
02:00002FE6 51CEFFF2        	  5063:                 dbf d6,CMPM_LOOP2
                            	  5064: 
                            	  5065: 
02:00002FEA 307C0100        	  5066:                 move.l #$00000100,a0       * Address for Data-X
02:00002FEE 327C0200        	  5067:                 move.l #$00000200,a1       * Address for Data-Y
02:00002FF2 7C03            	  5068:                 moveq  #$00000003,d6       * Loop counter
                            	  5069: 
02:00002FF4 B388            	  5070: CMPM_LOOP3:     cmpm.l (a0)+,(a1)+
02:00002FF6 40C3            	  5071:                 move.w sr,d3
02:00002FF8 02830000000F    	  5072:                 andi.l #$0F,d3            * Isolate flags
02:00002FFE D483            	  5073:                 add.l d3,d2               * Copy flag results into accumulator
02:00003000 51CEFFF2        	  5074:                 dbf d6,CMPM_LOOP3
                            	  5075: 
                            	  5076: 
02:00003004 0C800000004C    	  5077:                 cmpi.l #$0000004C,d0      * Check the data results
02:0000300A 66FE            	  5078:                 bne.s *
02:0000300C 0C8100000024    	  5079:                 cmpi.l #$00000024,d1
02:00003012 66FE            	  5080:                 bne.s *
02:00003014 0C8200000012    	  5081:                 cmpi.l #$00000012,d2
02:0000301A 66FE            	  5082:                 bne.s *
                            	  5083: 
02:0000301C 4E75            	  5084:                 rts
                            	  5085: 
                            	  5086: 
                            	  5087: *-----------------------------------------------------------
                            	  5088: *-----------------------------------------------------------
                            	  5089: * OPCODE : ADD
                            	  5090: *-----------------------------------------------------------
                            	  5091: *-----------------------------------------------------------
                            	  5092: 
                            	  5093: op_ADD:
                            	  5094: 
                            	  5095: 
                            	  5096: *  * <EA> to Register
02:0000301E 203CA5A5A5A5    	  5097:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003024 223C8167E123    	  5098:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:0000302A 243CA5A5A5A5    	  5099:                 move.l #$a5a5a5a5,d2
02:00003030 7600            	  5100:                 moveq  #$00000000,d3
02:00003032 7800            	  5101:                 moveq  #$00000000,d4       * Cumulative data results
02:00003034 7A00            	  5102:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003036 7C1E            	  5103:                 move.l #$0000001E,d6       * Inner loop counter
02:00003038 7E1E            	  5104:                 move.l #$0000001E,d7       * Outer loop counter
02:0000303A 307C0100        	  5105:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5106: 
                            	  5107: 
                            	  5108: ADD_OUTER1:
                            	  5109: 
                            	  5110: *     BYTE
02:0000303E 2081            	  5111:                 move.l d1,(a0)
02:00003040 D010            	  5112:                 add.b (a0),d0
02:00003042 40C3            	  5113:                 move.w sr,d3
02:00003044 02830000001F    	  5114:                 andi.l #$1F,d3            * Isolate flags
02:0000304A DA83            	  5115:                 add.l d3,d5               * Copy flag results into accumulator
02:0000304C D880            	  5116:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5117: 
                            	  5118: *     WORD
02:0000304E 2081            	  5119:                 move.l d1,(a0)
02:00003050 D050            	  5120:                 add.w (a0),d0
02:00003052 40C3            	  5121:                 move.w sr,d3
02:00003054 02830000000C    	  5122:                 andi.l #$0C,d3            * Isolate flags
02:0000305A DA83            	  5123:                 add.l d3,d5               * Copy flag results into accumulator
02:0000305C D880            	  5124:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5125: 
                            	  5126: *     LONG
02:0000305E 2081            	  5127:                 move.l d1,(a0)
02:00003060 D090            	  5128:                 add.l (a0),d0
02:00003062 40C3            	  5129:                 move.w sr,d3
02:00003064 02830000000F    	  5130:                 andi.l #$0F,d3            * Isolate flags
02:0000306A DA83            	  5131:                 add.l d3,d5               * Copy flag results into accumulator
02:0000306C D880            	  5132:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5133: 
                            	  5134: 
02:0000306E E299            	  5135:                 ror.l #$1,d1
02:00003070 51CEFFCC        	  5136:                 dbf d6,ADD_OUTER1
02:00003074 E29A            	  5137:                 ror.l #$1,d2
02:00003076 223C8167E123    	  5138:                 move.l #$8167E123,d1       * Initial Data-Y
02:0000307C 7C1E            	  5139:                 move.l #$0000001E,d6       * Inner loop counter
02:0000307E 51CFFFBE        	  5140:                 dbf d7,ADD_OUTER1
                            	  5141: 
02:00003082 0C8423ED428F    	  5142:                 cmpi.l #$23ED428F,d4      * Check the data results
02:00003088 66FE            	  5143:                 bne.s *
02:0000308A 0C8500004C96    	  5144:                 cmpi.l #$00004C96,d5      * Check the Flag results
02:00003090 66FE            	  5145:                 bne.s *
                            	  5146: 
                            	  5147: 
                            	  5148: *  * Register to <EA>
02:00003092 203C86738374    	  5149:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00003098 223CFC55F2FE    	  5150:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:0000309E 243C86738374    	  5151:                 move.l #$86738374,d2
02:000030A4 7600            	  5152:                 moveq  #$00000000,d3
02:000030A6 7800            	  5153:                 moveq  #$00000000,d4       * Cumulative data results
02:000030A8 7A00            	  5154:                 moveq  #$00000000,d5       * Cumulative flag results
02:000030AA 7C1E            	  5155:                 move.l #$0000001E,d6       * Inner loop counter
02:000030AC 7E1D            	  5156:                 move.l #$0000001D,d7       * Outer loop counter
02:000030AE 307C0100        	  5157:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5158: 
                            	  5159: 
                            	  5160: ADD_OUTER2:
                            	  5161: 
                            	  5162: *     BYTE
02:000030B2 2080            	  5163:                 move.l d0,(a0)
02:000030B4 D310            	  5164:                 add.b d1,(a0)
02:000030B6 40C3            	  5165:                 move.w sr,d3
02:000030B8 02830000000C    	  5166:                 andi.l #$0C,d3            * Isolate flags
02:000030BE DA83            	  5167:                 add.l d3,d5               * Copy flag results into accumulator
02:000030C0 D890            	  5168:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5169: 
                            	  5170: *     WORD
02:000030C2 2080            	  5171:                 move.l d0,(a0)
02:000030C4 D350            	  5172:                 add.w d1,(a0)
02:000030C6 40C3            	  5173:                 move.w sr,d3
02:000030C8 02830000001F    	  5174:                 andi.l #$1F,d3            * Isolate flags
02:000030CE DA83            	  5175:                 add.l d3,d5               * Copy flag results into accumulator
02:000030D0 D890            	  5176:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5177: 
                            	  5178: *     LONG
02:000030D2 2080            	  5179:                 move.l d0,(a0)
02:000030D4 D390            	  5180:                 add.l d1,(a0)
02:000030D6 40C3            	  5181:                 move.w sr,d3
02:000030D8 02830000000F    	  5182:                 andi.l #$0F,d3            * Isolate flags
02:000030DE DA83            	  5183:                 add.l d3,d5               * Copy flag results into accumulator
02:000030E0 D890            	  5184:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5185: 
                            	  5186: 
02:000030E2 E299            	  5187:                 ror.l #$1,d1
02:000030E4 51CEFFCC        	  5188:                 dbf d6,ADD_OUTER2
02:000030E8 E29A            	  5189:                 ror.l #$1,d2
02:000030EA 223C8167E123    	  5190:                 move.l #$8167E123,d1       * Initial Data-Y
02:000030F0 7C1E            	  5191:                 move.l #$0000001E,d6       * Inner loop counter
02:000030F2 51CFFFBE        	  5192:                 dbf d7,ADD_OUTER2
                            	  5193: 
02:000030F6 0C846701B884    	  5194:                 cmpi.l #$6701B884,d4      * Check the data results
02:000030FC 66FE            	  5195:                 bne.s *
02:000030FE 0C8500005467    	  5196:                 cmpi.l #$00005467,d5      * Check the Flag results
02:00003104 66FE            	  5197:                 bne.s *
                            	  5198: 
02:00003106 4E75            	  5199:                 rts
                            	  5200: 
                            	  5201: *-----------------------------------------------------------
                            	  5202: *-----------------------------------------------------------
                            	  5203: * OPCODE : SUB
                            	  5204: *-----------------------------------------------------------
                            	  5205: *-----------------------------------------------------------
                            	  5206: 
                            	  5207: op_SUB:
                            	  5208: 
                            	  5209: *  * <EA> to Register
02:00003108 203CA5A5A5A5    	  5210:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:0000310E 223C8167E123    	  5211:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00003114 243CA5A5A5A5    	  5212:                 move.l #$a5a5a5a5,d2
02:0000311A 7600            	  5213:                 moveq  #$00000000,d3
02:0000311C 7800            	  5214:                 moveq  #$00000000,d4       * Cumulative data results
02:0000311E 7A00            	  5215:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003120 7C1E            	  5216:                 move.l #$0000001E,d6       * Inner loop counter
02:00003122 7E1E            	  5217:                 move.l #$0000001E,d7       * Outer loop counter
02:00003124 307C0100        	  5218:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5219: 
                            	  5220: 
                            	  5221: SUB_OUTER1:
                            	  5222: 
                            	  5223: *     BYTE
02:00003128 2081            	  5224:                 move.l d1,(a0)
02:0000312A 9010            	  5225:                 sub.b (a0),d0
02:0000312C 40C3            	  5226:                 move.w sr,d3
02:0000312E 02830000001F    	  5227:                 andi.l #$1F,d3            * Isolate flags
02:00003134 DA83            	  5228:                 add.l d3,d5               * Copy flag results into accumulator
02:00003136 D880            	  5229:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5230: 
                            	  5231: *     WORD
02:00003138 2081            	  5232:                 move.l d1,(a0)
02:0000313A 9050            	  5233:                 sub.w (a0),d0
02:0000313C 40C3            	  5234:                 move.w sr,d3
02:0000313E 02830000000C    	  5235:                 andi.l #$0C,d3            * Isolate flags
02:00003144 DA83            	  5236:                 add.l d3,d5               * Copy flag results into accumulator
02:00003146 D880            	  5237:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5238: 
                            	  5239: *     LONG
02:00003148 2081            	  5240:                 move.l d1,(a0)
02:0000314A 9090            	  5241:                 sub.l (a0),d0
02:0000314C 40C3            	  5242:                 move.w sr,d3
02:0000314E 02830000000F    	  5243:                 andi.l #$0F,d3            * Isolate flags
02:00003154 DA83            	  5244:                 add.l d3,d5               * Copy flag results into accumulator
02:00003156 D880            	  5245:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5246: 
                            	  5247: 
02:00003158 E299            	  5248:                 ror.l #$1,d1
02:0000315A 51CEFFCC        	  5249:                 dbf d6,SUB_OUTER1
02:0000315E E29A            	  5250:                 ror.l #$1,d2
02:00003160 223C8167E123    	  5251:                 move.l #$8167E123,d1       * Initial Data-Y
02:00003166 7C1E            	  5252:                 move.l #$0000001E,d6       * Inner loop counter
02:00003168 51CFFFBE        	  5253:                 dbf d7,SUB_OUTER1
                            	  5254: 
02:0000316C 0C841A8D14CF    	  5255:                 cmpi.l #$1A8D14CF,d4      * Check the data results
02:00003172 66FE            	  5256:                 bne.s *
02:00003174 0C8500004FC4    	  5257:                 cmpi.l #$00004FC4,d5      * Check the Flag results
02:0000317A 66FE            	  5258:                 bne.s *
                            	  5259: 
                            	  5260: 
                            	  5261: *  * Register to <EA>
02:0000317C 203C86738374    	  5262:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00003182 223CFC55F2FE    	  5263:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00003188 243C86738374    	  5264:                 move.l #$86738374,d2
02:0000318E 7600            	  5265:                 moveq  #$00000000,d3
02:00003190 7800            	  5266:                 moveq  #$00000000,d4       * Cumulative data results
02:00003192 7A00            	  5267:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003194 7C1E            	  5268:                 move.l #$0000001E,d6       * Inner loop counter
02:00003196 7E1D            	  5269:                 move.l #$0000001D,d7       * Outer loop counter
02:00003198 307C0100        	  5270:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5271: 
                            	  5272: 
                            	  5273: SUB_OUTER2:
                            	  5274: 
                            	  5275: *     BYTE
02:0000319C 2080            	  5276:                 move.l d0,(a0)
02:0000319E 9310            	  5277:                 sub.b d1,(a0)
02:000031A0 40C3            	  5278:                 move.w sr,d3
02:000031A2 02830000000C    	  5279:                 andi.l #$0C,d3            * Isolate flags
02:000031A8 DA83            	  5280:                 add.l d3,d5               * Copy flag results into accumulator
02:000031AA D890            	  5281:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5282: 
                            	  5283: *     WORD
02:000031AC 2080            	  5284:                 move.l d0,(a0)
02:000031AE 9350            	  5285:                 sub.w d1,(a0)
02:000031B0 40C3            	  5286:                 move.w sr,d3
02:000031B2 02830000001F    	  5287:                 andi.l #$1F,d3            * Isolate flags
02:000031B8 DA83            	  5288:                 add.l d3,d5               * Copy flag results into accumulator
02:000031BA D890            	  5289:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5290: 
                            	  5291: *     LONG
02:000031BC 2080            	  5292:                 move.l d0,(a0)
02:000031BE 9390            	  5293:                 sub.l d1,(a0)
02:000031C0 40C3            	  5294:                 move.w sr,d3
02:000031C2 02830000000F    	  5295:                 andi.l #$0F,d3            * Isolate flags
02:000031C8 DA83            	  5296:                 add.l d3,d5               * Copy flag results into accumulator
02:000031CA D890            	  5297:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5298: 
                            	  5299: 
02:000031CC E299            	  5300:                 ror.l #$1,d1
02:000031CE 51CEFFCC        	  5301:                 dbf d6,SUB_OUTER2
02:000031D2 E29A            	  5302:                 ror.l #$1,d2
02:000031D4 223C8167E123    	  5303:                 move.l #$8167E123,d1       * Initial Data-Y
02:000031DA 7C1E            	  5304:                 move.l #$0000001E,d6       * Inner loop counter
02:000031DC 51CFFFBE        	  5305:                 dbf d7,SUB_OUTER2
                            	  5306: 
02:000031E0 0C8436D38BEC    	  5307:                 cmpi.l #$36D38BEC,d4      * Check the data results
02:000031E6 66FE            	  5308:                 bne.s *
02:000031E8 0C85000045A5    	  5309:                 cmpi.l #$000045A5,d5      * Check the Flag results
02:000031EE 66FE            	  5310:                 bne.s *
                            	  5311: 
                            	  5312: 
                            	  5313: 
                            	  5314: 
02:000031F0 4E75            	  5315:                 rts
                            	  5316: 
                            	  5317: 
                            	  5318: 
                            	  5319: *-----------------------------------------------------------
                            	  5320: *-----------------------------------------------------------
                            	  5321: * OPCODE : ADDA
                            	  5322: *-----------------------------------------------------------
                            	  5323: *-----------------------------------------------------------
                            	  5324: 
                            	  5325: op_ADDA:
                            	  5326: 
                            	  5327: *  * <EA> to Register
02:000031F2 203CA5A5A5A5    	  5328:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:000031F8 223C8167E123    	  5329:                 move.l #$8167E123,d1
02:000031FE 243CA5A5A5A5    	  5330:                 move.l #$a5a5a5a5,d2
02:00003204 7600            	  5331:                 moveq  #$00000000,d3
02:00003206 7800            	  5332:                 moveq  #$00000000,d4       * Cumulative data results
02:00003208 7A00            	  5333:                 moveq  #$00000000,d5       * Cumulative flag results
02:0000320A 7C1E            	  5334:                 move.l #$0000001E,d6       * Inner loop counter
02:0000320C 7E1E            	  5335:                 move.l #$0000001E,d7       * Outer loop counter
02:0000320E 307C0100        	  5336:                 move.l #$00000100,a0       * Address for memory EA operations
02:00003212 227C8167E123    	  5337:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5338: 
                            	  5339: ADDA_OUTER1:
                            	  5340: 
                            	  5341: *     WORD
                            	  5342: *                move.l d1,(a0)       * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5343: *                adda.w (a0),a1
                            	  5344: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5345: 
                            	  5346: *     LONG
02:00003218 2081            	  5347:                 move.l d1,(a0)
02:0000321A D3D0            	  5348:                 adda.l (a0),a1
02:0000321C D889            	  5349:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5350: 
02:0000321E E299            	  5351:                 ror.l #$1,d1
02:00003220 51CEFFF6        	  5352:                 dbf d6,ADDA_OUTER1
02:00003224 E299            	  5353:                 ror.l #$1,d1
02:00003226 2241            	  5354:                 move.l d1,a1
02:00003228 223C8167E123    	  5355:                 move.l #$8167E123,d1       * Initial Data-Y
02:0000322E 7C1E            	  5356:                 move.l #$0000001E,d6       * Inner loop counter
02:00003230 51CFFFE6        	  5357:                 dbf d7,ADDA_OUTER1
                            	  5358: 
02:00003234 0C84AC04DB4C    	  5359:                 cmpi.l #$AC04DB4C,d4      * Check the data results
02:0000323A 66FE            	  5360:                 bne.s *
                            	  5361: 
                            	  5362: 
02:0000323C 4E75            	  5363:                 rts
                            	  5364: 
                            	  5365: 
                            	  5366: *-----------------------------------------------------------
                            	  5367: *-----------------------------------------------------------
                            	  5368: * OPCODE : SUBA
                            	  5369: *-----------------------------------------------------------
                            	  5370: *-----------------------------------------------------------
                            	  5371: 
                            	  5372: op_SUBA:
                            	  5373: 
                            	  5374: *  * <EA> to Register
02:0000323E 203CA5A5A5A5    	  5375:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003244 223C8167E123    	  5376:                 move.l #$8167E123,d1
02:0000324A 243CA5A5A5A5    	  5377:                 move.l #$a5a5a5a5,d2
02:00003250 7600            	  5378:                 moveq  #$00000000,d3
02:00003252 7800            	  5379:                 moveq  #$00000000,d4       * Cumulative data results
02:00003254 7A00            	  5380:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003256 7C1E            	  5381:                 move.l #$0000001E,d6       * Inner loop counter
02:00003258 7E1E            	  5382:                 move.l #$0000001E,d7       * Outer loop counter
02:0000325A 307C0100        	  5383:                 move.l #$00000100,a0       * Address for memory EA operations
02:0000325E 227C8167E123    	  5384:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5385: 
                            	  5386: SUBA_OUTER1:
                            	  5387: 
                            	  5388: *     WORD
                            	  5389: *                move.l d1,(a0) * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5390: *                suba.w (a0),a1
                            	  5391: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5392: 
                            	  5393: *     LONG
02:00003264 2081            	  5394:                 move.l d1,(a0)
02:00003266 93D0            	  5395:                 suba.l (a0),a1
02:00003268 D889            	  5396:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5397: 
02:0000326A E299            	  5398:                 ror.l #$1,d1
02:0000326C 51CEFFF6        	  5399:                 dbf d6,SUBA_OUTER1
02:00003270 E299            	  5400:                 ror.l #$1,d1
02:00003272 2241            	  5401:                 move.l d1,a1
02:00003274 223C8167E123    	  5402:                 move.l #$8167E123,d1       * Initial Data-Y
02:0000327A 7C1E            	  5403:                 move.l #$0000001E,d6       * Inner loop counter
02:0000327C 51CFFFE6        	  5404:                 dbf d7,SUBA_OUTER1
                            	  5405: 
02:00003280 0C84E1E36D7A    	  5406:                 cmpi.l #$E1E36D7A,d4      * Check the data results
02:00003286 66FE            	  5407:                 bne.s *
                            	  5408: 
                            	  5409: 
02:00003288 4E75            	  5410:                 rts
                            	  5411: 
                            	  5412: 
                            	  5413: 
                            	  5414: *-----------------------------------------------------------
                            	  5415: *-----------------------------------------------------------
                            	  5416: * OPCODE : ADDX
                            	  5417: *-----------------------------------------------------------
                            	  5418: *-----------------------------------------------------------
                            	  5419: 
                            	  5420: op_ADDX:
                            	  5421: 
                            	  5422: 
                            	  5423: *  * Register to Register
02:0000328A 203CA5A5A5A5    	  5424:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003290 223C8167E123    	  5425:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00003296 243CA5A5A5A5    	  5426:                 move.l #$a5a5a5a5,d2
02:0000329C 7600            	  5427:                 moveq  #$00000000,d3
02:0000329E 7800            	  5428:                 moveq  #$00000000,d4       * Cumulative data results
02:000032A0 7A00            	  5429:                 moveq  #$00000000,d5       * Cumulative flag results
02:000032A2 7C1E            	  5430:                 move.l #$0000001E,d6       * Inner loop counter
02:000032A4 7E1E            	  5431:                 move.l #$0000001E,d7       * Outer loop counter
02:000032A6 307C0100        	  5432:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5433: 
                            	  5434: 
                            	  5435: ADDX_OUTER1:
                            	  5436: 
                            	  5437: *     BYTE
02:000032AA 2002            	  5438:                 move.l d2,d0
02:000032AC D101            	  5439:                 addx.b d1,d0
02:000032AE 40C3            	  5440:                 move.w sr,d3
02:000032B0 02830000001F    	  5441:                 andi.l #$1F,d3            * Isolate flags
02:000032B6 DA83            	  5442:                 add.l d3,d5               * Copy flag results into accumulator
02:000032B8 D880            	  5443:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5444: 
                            	  5445: *     WORD
02:000032BA 2002            	  5446:                 move.l d2,d0
02:000032BC D141            	  5447:                 addx.w d1,d0
02:000032BE 40C3            	  5448:                 move.w sr,d3
02:000032C0 02830000001F    	  5449:                 andi.l #$1F,d3            * Isolate flags
02:000032C6 DA83            	  5450:                 add.l d3,d5               * Copy flag results into accumulator
02:000032C8 D880            	  5451:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5452: 
                            	  5453: *     LONG
02:000032CA 2002            	  5454:                 move.l d2,d0
02:000032CC D181            	  5455:                 addx.l d1,d0
02:000032CE 40C3            	  5456:                 move.w sr,d3
02:000032D0 02830000001F    	  5457:                 andi.l #$1F,d3            * Isolate flags
02:000032D6 DA83            	  5458:                 add.l d3,d5               * Copy flag results into accumulator
02:000032D8 D880            	  5459:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5460: 
02:000032DA E299            	  5461:                 ror.l #$1,d1
02:000032DC 51CEFFCC        	  5462:                 dbf d6,ADDX_OUTER1
02:000032E0 E29A            	  5463:                 ror.l #$1,d2
02:000032E2 223C8167E123    	  5464:                 move.l #$8167E123,d1       * Initial Data-Y
02:000032E8 7C1E            	  5465:                 move.l #$0000001E,d6       * Inner loop counter
02:000032EA 51CFFFBE        	  5466:                 dbf d7,ADDX_OUTER1
                            	  5467: 
02:000032EE 0C844E96A4D9    	  5468:                 cmpi.l #$4E96A4D9,d4      * Check the data results
02:000032F4 66FE            	  5469:                 bne.s *
02:000032F6 0C85000085CD    	  5470:                 cmpi.l #$000085CD,d5      * Check the Flag results
02:000032FC 66FE            	  5471:                 bne.s *
                            	  5472: 
                            	  5473: 
                            	  5474: 
                            	  5475: *     -(An),-(An)
                            	  5476: 
02:000032FE 7000            	  5477:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
02:00003300 7200            	  5478:                 moveq  #$00000000,d1
02:00003302 7400            	  5479:                 moveq  #$00000000,d2
02:00003304 307C0100        	  5480:                 move.l #$00000100,a0       * Address for Data-X
02:00003308 327C0200        	  5481:                 move.l #$00000200,a1       * Address for Data-Y
02:0000330C 20FC11FF5580    	  5482:                 move.l #$11FF5580,(a0)+   * Populate test data
02:00003312 20FC1111FFFF    	  5483:                 move.l #$1111FFFF,(a0)+   * Populate test data
02:00003318 20FC33333333    	  5484:                 move.l #$33333333,(a0)+   * Populate test data
02:0000331E 20FC44444444    	  5485:                 move.l #$44444444,(a0)+   * Populate test data
02:00003324 22FC80FF337F    	  5486:                 move.l #$80FF337F,(a1)+   * Populate test data
02:0000332A 22FCFFFF1111    	  5487:                 move.l #$FFFF1111,(a1)+   * Populate test data
02:00003330 22FC33333333    	  5488:                 move.l #$33333333,(a1)+   * Populate test data
02:00003336 22FC44444444    	  5489:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5490: 
                            	  5491: 
02:0000333C 7C0F            	  5492:                 move.l #$0000000F,d6       * Loop counter
                            	  5493: 
02:0000333E D308            	  5494: ADDX_LOOP3:     addx.b -(a0),-(a1)
02:00003340 40C3            	  5495:                 move.w sr,d3
02:00003342 02830000000F    	  5496:                 andi.l #$0F,d3            * Isolate flags
02:00003348 D083            	  5497:                 add.l d3,d0               * Copy flag results into accumulator
02:0000334A D211            	  5498:                 add.b (a1),d1
02:0000334C 51CEFFF0        	  5499:                 dbf d6,ADDX_LOOP3
                            	  5500: 
                            	  5501: 
02:00003350 307C0110        	  5502:                 move.l #$00000110,a0       * Address for Data-X
02:00003354 327C0210        	  5503:                 move.l #$00000210,a1       * Address for Data-Y
02:00003358 7C07            	  5504:                 moveq  #$00000007,d6       * Loop counter
                            	  5505: 
02:0000335A D348            	  5506: ADDX_LOOP4:     addx.w -(a0),-(a1)
02:0000335C 40C3            	  5507:                 move.w sr,d3
02:0000335E 02830000000F    	  5508:                 andi.l #$0F,d3            * Isolate flags
02:00003364 D083            	  5509:                 add.l d3,d0               * Copy flag results into accumulator
02:00003366 D251            	  5510:                 add.w (a1),d1
02:00003368 51CEFFF0        	  5511:                 dbf d6,ADDX_LOOP4
                            	  5512: 
                            	  5513: 
02:0000336C 307C0110        	  5514:                 move.l #$00000110,a0       * Address for Data-X
02:00003370 327C0210        	  5515:                 move.l #$00000210,a1       * Address for Data-Y
02:00003374 7C03            	  5516:                 moveq  #$00000003,d6       * Loop counter
                            	  5517: 
02:00003376 D388            	  5518: ADDX_LOOP5:     addx.l -(a0),-(a1)
02:00003378 40C3            	  5519:                 move.w sr,d3
02:0000337A 02830000000F    	  5520:                 andi.l #$0F,d3            * Isolate flags
02:00003380 D083            	  5521:                 add.l d3,d0               * Copy flag results into accumulator
02:00003382 D291            	  5522:                 add.l (a1),d1
02:00003384 51CEFFF0        	  5523:                 dbf d6,ADDX_LOOP5
                            	  5524: 
                            	  5525: 
02:00003388 0C8000000095    	  5526:                 cmpi.l #$00000095,d0      * Check the flag results
02:0000338E 66FE            	  5527:                 bne.s *
02:00003390 0C81C812A682    	  5528:                 cmpi.l #$C812A682,d1      * Check the data results
02:00003396 66FE            	  5529:                 bne.s *
                            	  5530: 
02:00003398 4E75            	  5531:                 rts
                            	  5532: 
                            	  5533: 
                            	  5534: 
                            	  5535: 
                            	  5536: *-----------------------------------------------------------
                            	  5537: *-----------------------------------------------------------
                            	  5538: * OPCODE : SUBX
                            	  5539: *-----------------------------------------------------------
                            	  5540: *-----------------------------------------------------------
                            	  5541: 
                            	  5542: op_SUBX:
                            	  5543: 
                            	  5544: 
                            	  5545: *  * Register to Register
02:0000339A 203CA5A5A5A5    	  5546:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:000033A0 223C8167E123    	  5547:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:000033A6 243CA5A5A5A5    	  5548:                 move.l #$a5a5a5a5,d2
02:000033AC 7600            	  5549:                 moveq  #$00000000,d3
02:000033AE 7800            	  5550:                 moveq  #$00000000,d4       * Cumulative data results
02:000033B0 7A00            	  5551:                 moveq  #$00000000,d5       * Cumulative flag results
02:000033B2 7C1E            	  5552:                 move.l #$0000001E,d6       * Inner loop counter
02:000033B4 7E1E            	  5553:                 move.l #$0000001E,d7       * Outer loop counter
02:000033B6 307C0100        	  5554:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5555: 
                            	  5556: 
                            	  5557: SUBX_OUTER1:
                            	  5558: 
                            	  5559: *     BYTE
02:000033BA 2002            	  5560:                 move.l d2,d0
02:000033BC 9101            	  5561:                 subx.b d1,d0
02:000033BE 40C3            	  5562:                 move.w sr,d3
02:000033C0 02830000001F    	  5563:                 andi.l #$1F,d3            * Isolate flags
02:000033C6 DA83            	  5564:                 add.l d3,d5               * Copy flag results into accumulator
02:000033C8 D880            	  5565:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5566: 
                            	  5567: *     WORD
02:000033CA 2002            	  5568:                 move.l d2,d0
02:000033CC 9141            	  5569:                 subx.w d1,d0
02:000033CE 40C3            	  5570:                 move.w sr,d3
02:000033D0 02830000001F    	  5571:                 andi.l #$1F,d3            * Isolate flags
02:000033D6 DA83            	  5572:                 add.l d3,d5               * Copy flag results into accumulator
02:000033D8 D880            	  5573:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5574: 
                            	  5575: *     LONG
02:000033DA 2002            	  5576:                 move.l d2,d0
02:000033DC 9181            	  5577:                 subx.l d1,d0
02:000033DE 40C3            	  5578:                 move.w sr,d3
02:000033E0 02830000001F    	  5579:                 andi.l #$1F,d3            * Isolate flags
02:000033E6 DA83            	  5580:                 add.l d3,d5               * Copy flag results into accumulator
02:000033E8 D880            	  5581:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5582: 
02:000033EA E299            	  5583:                 ror.l #$1,d1
02:000033EC 51CEFFCC        	  5584:                 dbf d6,SUBX_OUTER1
02:000033F0 E29A            	  5585:                 ror.l #$1,d2
02:000033F2 223C8167E123    	  5586:                 move.l #$8167E123,d1       * Initial Data-Y
02:000033F8 7C1E            	  5587:                 move.l #$0000001E,d6       * Inner loop counter
02:000033FA 51CFFFBE        	  5588:                 dbf d7,SUBX_OUTER1
                            	  5589: 
02:000033FE 0C84FCAA913E    	  5590:                 cmpi.l #$FCAA913E,d4      * Check the data results
02:00003404 66FE            	  5591:                 bne.s *
02:00003406 0C8500007E89    	  5592:                 cmpi.l #$00007E89,d5      * Check the Flag results
02:0000340C 66FE            	  5593:                 bne.s *
                            	  5594: 
                            	  5595: 
                            	  5596: 
                            	  5597: *     -(An),-(An)
                            	  5598: 
02:0000340E 7000            	  5599:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
02:00003410 7200            	  5600:                 moveq  #$00000000,d1
02:00003412 7400            	  5601:                 moveq  #$00000000,d2
02:00003414 307C0100        	  5602:                 move.l #$00000100,a0       * Address for Data-X
02:00003418 327C0200        	  5603:                 move.l #$00000200,a1       * Address for Data-Y
02:0000341C 20FC11FF5580    	  5604:                 move.l #$11FF5580,(a0)+   * Populate test data
02:00003422 20FC1111FFFF    	  5605:                 move.l #$1111FFFF,(a0)+   * Populate test data
02:00003428 20FC80FF337F    	  5606:                 move.l #$80FF337F,(a0)+   * Populate test data
02:0000342E 20FC44444444    	  5607:                 move.l #$44444444,(a0)+   * Populate test data
02:00003434 22FC80FF337F    	  5608:                 move.l #$80FF337F,(a1)+   * Populate test data
02:0000343A 22FC1111FFFF    	  5609:                 move.l #$1111FFFF,(a1)+   * Populate test data
02:00003440 22FC33333333    	  5610:                 move.l #$33333333,(a1)+   * Populate test data
02:00003446 22FC5580EECC    	  5611:                 move.l #$5580EECC,(a1)+   * Populate test data
                            	  5612: 
                            	  5613: 
02:0000344C 7C0F            	  5614:                 move.l #$0000000F,d6       * Loop counter
                            	  5615: 
02:0000344E 9308            	  5616: SUBX_LOOP3:     subx.b -(a0),-(a1)
02:00003450 40C3            	  5617:                 move.w sr,d3
02:00003452 02830000000F    	  5618:                 andi.l #$0F,d3            * Isolate flags
02:00003458 D083            	  5619:                 add.l d3,d0               * Copy flag results into accumulator
02:0000345A D211            	  5620:                 add.b (a1),d1
02:0000345C 51CEFFF0        	  5621:                 dbf d6,SUBX_LOOP3
                            	  5622: 
                            	  5623: 
02:00003460 307C0110        	  5624:                 move.l #$00000110,a0       * Address for Data-X
02:00003464 327C0210        	  5625:                 move.l #$00000210,a1       * Address for Data-Y
02:00003468 7C07            	  5626:                 moveq  #$00000007,d6       * Loop counter
                            	  5627: 
02:0000346A 9348            	  5628: SUBX_LOOP4:     subx.w -(a0),-(a1)
02:0000346C 40C3            	  5629:                 move.w sr,d3
02:0000346E 02830000000F    	  5630:                 andi.l #$0F,d3            * Isolate flags
02:00003474 D083            	  5631:                 add.l d3,d0               * Copy flag results into accumulator
02:00003476 D251            	  5632:                 add.w (a1),d1
02:00003478 51CEFFF0        	  5633:                 dbf d6,SUBX_LOOP4
                            	  5634: 
                            	  5635: 
02:0000347C 307C0110        	  5636:                 move.l #$00000110,a0       * Address for Data-X
02:00003480 327C0210        	  5637:                 move.l #$00000210,a1       * Address for Data-Y
02:00003484 7C03            	  5638:                 moveq  #$00000003,d6       * Loop counter
                            	  5639: 
02:00003486 9388            	  5640: SUBX_LOOP5:     subx.l -(a0),-(a1)
02:00003488 40C3            	  5641:                 move.w sr,d3
02:0000348A 02830000000F    	  5642:                 andi.l #$0F,d3            * Isolate flags
02:00003490 D083            	  5643:                 add.l d3,d0               * Copy flag results into accumulator
02:00003492 D291            	  5644:                 add.l (a1),d1
02:00003494 51CEFFF0        	  5645:                 dbf d6,SUBX_LOOP5
                            	  5646: 
                            	  5647: 
02:00003498 0C80000000B1    	  5648:                 cmpi.l #$000000B1,d0      * Check the flag results
02:0000349E 66FE            	  5649:                 bne.s *
02:000034A0 0C8162C6F417    	  5650:                 cmpi.l #$62C6F417,d1      * Check the data results
02:000034A6 66FE            	  5651:                 bne.s *
                            	  5652: 
02:000034A8 4E75            	  5653:                 rts
                            	  5654: 
                            	  5655: 
                            	  5656: *-----------------------------------------------------------
                            	  5657: *-----------------------------------------------------------
                            	  5658: * OPCODE : MULU
                            	  5659: *-----------------------------------------------------------
                            	  5660: *-----------------------------------------------------------
                            	  5661: 
                            	  5662: op_MULU:
                            	  5663: 
02:000034AA 203CFE805501    	  5664:                 move.l #$FE805501,d0        * Initial
02:000034B0 223C5697EDB6    	  5665:                 move.l #$5697EDB6,d1        * Initial Y
02:000034B6 243CFE805501    	  5666:                 move.l #$FE805501,d2
02:000034BC 7600            	  5667:                 moveq  #$00000000,d3
02:000034BE 7800            	  5668:                 moveq  #$00000000,d4        * Cumulative data results
02:000034C0 7A00            	  5669:                 moveq  #$00000000,d5       * Cumulative flag results
02:000034C2 7C0E            	  5670:                 move.l #$0000000E,d6       * Inner loop counter
02:000034C4 7E0E            	  5671:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5672: 
                            	  5673: 
02:000034C6 C0C1            	  5674: MULU_OUTER1:    mulu d1,d0
02:000034C8 40C3            	  5675:                 move.w sr,d3
02:000034CA 02830000000C    	  5676:                 andi.l #$0C,d3            * Isolate flags
02:000034D0 DA83            	  5677:                 add.l d3,d5               * Copy flag results into accumulator
02:000034D2 D880            	  5678:                 add.l d0,d4               * Copy data results into data accumulator
02:000034D4 E299            	  5679:                 ror.l #$1,d1
                            	  5680: 
02:000034D6 51CEFFEE        	  5681:                 dbf d6,MULU_OUTER1
02:000034DA E29A            	  5682:                 ror.l #$1,d2
02:000034DC 2002            	  5683:                 move.l d2,d0
02:000034DE 7C0E            	  5684:                 move.l #$0000000E,d6       * Inner loop counter
02:000034E0 51CFFFE4        	  5685:                 dbf d7,MULU_OUTER1
                            	  5686: 
02:000034E4 0C8476FB988C    	  5687:                 cmpi.l #$76FB988C,d4      * Check the data results
02:000034EA 66FE            	  5688:                 bne.s *
                            	  5689: 
02:000034EC 0C8500000170    	  5690:                 cmpi.l #$00000170,d5      * Check the Flag results
02:000034F2 66FE            	  5691:                 bne.s *
                            	  5692: 
                            	  5693: 
02:000034F4 4E75            	  5694:                 rts
                            	  5695: 
                            	  5696: 
                            	  5697: *-----------------------------------------------------------
                            	  5698: *-----------------------------------------------------------
                            	  5699: * OPCODE : MULS
                            	  5700: *-----------------------------------------------------------
                            	  5701: *-----------------------------------------------------------
                            	  5702: 
                            	  5703: op_MULS:
                            	  5704: 
02:000034F6 203CFE805501    	  5705:                 move.l #$FE805501,d0        * Initial
02:000034FC 223C5697EDB6    	  5706:                 move.l #$5697EDB6,d1        * Initial Y
02:00003502 243CFE805501    	  5707:                 move.l #$FE805501,d2
02:00003508 7600            	  5708:                 moveq  #$00000000,d3
02:0000350A 7800            	  5709:                 moveq  #$00000000,d4        * Cumulative data results
02:0000350C 7A00            	  5710:                 moveq  #$00000000,d5       * Cumulative flag results
02:0000350E 7C0E            	  5711:                 move.l #$0000000E,d6       * Inner loop counter
02:00003510 7E0E            	  5712:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5713: 
                            	  5714: 
02:00003512 C1C1            	  5715: MULS_OUTER1:    muls d1,d0
02:00003514 40C3            	  5716:                 move.w sr,d3
02:00003516 02830000000C    	  5717:                 andi.l #$0C,d3            * Isolate flags
02:0000351C DA83            	  5718:                 add.l d3,d5               * Copy flag results into accumulator
02:0000351E D880            	  5719:                 add.l d0,d4               * Copy data results into data accumulator
02:00003520 E299            	  5720:                 ror.l #$1,d1
                            	  5721: 
02:00003522 51CEFFEE        	  5722:                 dbf d6,MULS_OUTER1
02:00003526 E29A            	  5723:                 ror.l #$1,d2
02:00003528 2002            	  5724:                 move.l d2,d0
02:0000352A 7C0E            	  5725:                 move.l #$0000000E,d6       * Inner loop counter
02:0000352C 51CFFFE4        	  5726:                 dbf d7,MULS_OUTER1
                            	  5727: 
02:00003530 0C84D4E2988C    	  5728:                 cmpi.l #$D4E2988C,d4      * Check the data results
02:00003536 66FE            	  5729:                 bne.s *
                            	  5730: 
02:00003538 0C85000003E0    	  5731:                 cmpi.l #$000003E0,d5      * Check the Flag results
02:0000353E 66FE            	  5732:                 bne.s *
                            	  5733: 
                            	  5734: 
02:00003540 4E75            	  5735:                 rts
                            	  5736: 
                            	  5737: 
                            	  5738: 
                            	  5739: *-----------------------------------------------------------
                            	  5740: *-----------------------------------------------------------
                            	  5741: * OPCODE : EXG
                            	  5742: *-----------------------------------------------------------
                            	  5743: *-----------------------------------------------------------
                            	  5744: 
                            	  5745: op_EXG:
02:00003542 223CD1D1D1D1    	  5746:                 move.l #$d1d1d1d1,d1
02:00003548 243CD2D2D2D2    	  5747:                 move.l #$d2d2d2d2,d2
02:0000354E 263CD3D3D3D3    	  5748:                 move.l #$d3d3d3d3,d3
02:00003554 227CA1A1A1A1    	  5749:                 move.l #$a1a1a1a1,a1
02:0000355A 247CA2A2A2A2    	  5750:                 move.l #$a2a2a2a2,a2
02:00003560 267CA3A3A3A3    	  5751:                 move.l #$a3a3a3a3,a3
                            	  5752: 
02:00003566 C342            	  5753:                 exg d1,d2
02:00003568 C34A            	  5754:                 exg a1,a2
02:0000356A C78B            	  5755:                 exg d3,a3
                            	  5756: 
02:0000356C 0C81D2D2D2D2    	  5757:                 cmpi.l #$d2d2d2d2,d1      * Check the results
02:00003572 66FE            	  5758:                 bne.s *
02:00003574 0C82D1D1D1D1    	  5759:                 cmpi.l #$d1d1d1d1,d2
02:0000357A 66FE            	  5760:                 bne.s *
02:0000357C 0C83A3A3A3A3    	  5761:                 cmpi.l #$a3a3a3a3,d3
02:00003582 66FE            	  5762:                 bne.s *
                            	  5763: 
02:00003584 2209            	  5764:                 move.l a1,d1
02:00003586 240A            	  5765:                 move.l a2,d2
02:00003588 260B            	  5766:                 move.l a3,d3
                            	  5767: 
02:0000358A 0C81A2A2A2A2    	  5768:                 cmpi.l #$a2a2a2a2,d1
02:00003590 66FE            	  5769:                 bne.s *
02:00003592 0C82A1A1A1A1    	  5770:                 cmpi.l #$a1a1a1a1,d2
02:00003598 66FE            	  5771:                 bne.s *
02:0000359A 0C83D3D3D3D3    	  5772:                 cmpi.l #$d3d3d3d3,d3
02:000035A0 66FE            	  5773:                 bne.s *
                            	  5774: 
02:000035A2 4E75            	  5775:                 rts
                            	  5776: 
                            	  5777: 
                            	  5778: *-----------------------------------------------------------
                            	  5779: *-----------------------------------------------------------
                            	  5780: * OPCODE : ROx
                            	  5781: *-----------------------------------------------------------
                            	  5782: *-----------------------------------------------------------
                            	  5783: 
                            	  5784: *     Subroutine to check and accumulate the flags
02:000035A4 40C3            	  5785: ROx_FLAGS:      move.w sr,d3
02:000035A6 02830000000F    	  5786:                 andi.l #$0F,d3            * Isolate flags
02:000035AC DA83            	  5787:                 add.l d3,d5               * Copy flag results into accumulator
02:000035AE 4E75            	  5788:                 rts
                            	  5789: 
                            	  5790: op_ROx:
                            	  5791: 
                            	  5792: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  5793: 
                            	  5794: *        BYTE LEFT
02:000035B0 203C80018FF1    	  5795:                 move.l #$80018FF1,d0
02:000035B6 7A00            	  5796:                 moveq  #$00000000,d5
02:000035B8 7C11            	  5797:                 moveq  #$00000011,d6
                            	  5798: ROx_LOOP1:
02:000035BA ED38            	  5799:                 rol.b d6,d0
02:000035BC 61E6            	  5800:                 bsr ROx_FLAGS
02:000035BE 51CEFFFA        	  5801:                 dbf d6,ROx_LOOP1
02:000035C2 0C8080018FE3    	  5802:                 cmpi.l #$80018FE3,d0
02:000035C8 66FE            	  5803:                 bne.s *
02:000035CA 0C850000006B    	  5804:                 cmpi.l #$0000006B,d5
02:000035D0 66FE            	  5805:                 bne.s *
                            	  5806: 
                            	  5807: *        BYTE RIGHT
02:000035D2 203C80018FF1    	  5808:                 move.l #$80018FF1,d0
02:000035D8 7C12            	  5809:                 moveq  #$00000012,d6
                            	  5810: ROx_LOOP2:
02:000035DA EC38            	  5811:                 ror.b d6,d0
02:000035DC 61C6            	  5812:                 bsr ROx_FLAGS
02:000035DE 51CEFFFA        	  5813:                 dbf d6,ROx_LOOP2
02:000035E2 0C8080018F3E    	  5814:                 cmpi.l #$80018F3E,d0
02:000035E8 66FE            	  5815:                 bne.s *
02:000035EA 0C85000000C5    	  5816:                 cmpi.l #$000000C5,d5
02:000035F0 66FE            	  5817:                 bne.s *
                            	  5818: 
                            	  5819: 
                            	  5820: *        WORD LEFT
02:000035F2 203C80018FF1    	  5821:                 move.l #$80018FF1,d0
02:000035F8 7C13            	  5822:                 moveq  #$00000013,d6
                            	  5823: ROx_LOOP3:
02:000035FA ED78            	  5824:                 rol.w d6,d0
02:000035FC 61A6            	  5825:                 bsr ROx_FLAGS
02:000035FE 51CEFFFA        	  5826:                 dbf d6,ROx_LOOP3
02:00003602 0C80800163FC    	  5827:                 cmpi.l #$800163FC,d0
02:00003608 66FE            	  5828:                 bne.s *
02:0000360A 0C8500000131    	  5829:                 cmpi.l #$00000131,d5
02:00003610 66FE            	  5830:                 bne.s *
                            	  5831: 
                            	  5832: *        WORD RIGHT
02:00003612 203C80018FF1    	  5833:                 move.l #$80018FF1,d0
02:00003618 7C1E            	  5834:                 move.l #$0000001E,d6
                            	  5835: ROx_LOOP4:
02:0000361A EC78            	  5836:                 ror.w d6,d0
02:0000361C 6186            	  5837:                 bsr ROx_FLAGS
02:0000361E 51CEFFFA        	  5838:                 dbf d6,ROx_LOOP4
02:00003622 0C808001C7F8    	  5839:                 cmpi.l #$8001C7F8,d0
02:00003628 66FE            	  5840:                 bne.s *
02:0000362A 0C85000001DB    	  5841:                 cmpi.l #$000001DB,d5
02:00003630 66FE            	  5842:                 bne.s *
                            	  5843: 
                            	  5844: 
                            	  5845: *        LONG LEFT
02:00003632 203C80018FF1    	  5846:                 move.l #$80018FF1,d0
02:00003638 7C15            	  5847:                 moveq  #$00000015,d6
                            	  5848: ROx_LOOP5:
02:0000363A EDB8            	  5849:                 rol.l d6,d0
02:0000363C 6100FF66        	  5850:                 bsr ROx_FLAGS
02:00003640 51CEFFF8        	  5851:                 dbf d6,ROx_LOOP5
02:00003644 0C8000C7F8C0    	  5852:                 cmpi.l #$00C7F8C0,d0
02:0000364A 66FE            	  5853:                 bne.s *
02:0000364C 0C850000021A    	  5854:                 cmpi.l #$0000021A,d5
02:00003652 66FE            	  5855:                 bne.s *
                            	  5856: 
                            	  5857: *        LONG RIGHT
02:00003654 203C80018FF1    	  5858:                 move.l #$80018FF1,d0
02:0000365A 7C16            	  5859:                 moveq  #$00000016,d6
                            	  5860: ROx_LOOP6:
02:0000365C ECB8            	  5861:                 ror.l d6,d0
02:0000365E 6100FF44        	  5862:                 bsr ROx_FLAGS
02:00003662 51CEFFF8        	  5863:                 dbf d6,ROx_LOOP6
02:00003666 0C80000C7F8C    	  5864:                 cmpi.l #$000C7F8C,d0
02:0000366C 66FE            	  5865:                 bne.s *
02:0000366E 0C8500000250    	  5866:                 cmpi.l #$00000250,d5
02:00003674 66FE            	  5867:                 bne.s *
                            	  5868: 
                            	  5869: 
                            	  5870: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  5871: 
02:00003676 203C80018FF1    	  5872:                 move.l #$80018FF1,d0
02:0000367C 7A00            	  5873:                 moveq  #$00000000,d5
                            	  5874: 
                            	  5875: *        BYTE LEFT
02:0000367E E318            	  5876:                 rol.b #1,d0
02:00003680 6100FF22        	  5877:                 bsr ROx_FLAGS
02:00003684 EB18            	  5878:                 rol.b #5,d0
02:00003686 6100FF1C        	  5879:                 bsr ROx_FLAGS
02:0000368A EF18            	  5880:                 rol.b #7,d0
02:0000368C 6100FF16        	  5881:                 bsr ROx_FLAGS
02:00003690 E118            	  5882:                 rol.b #8,d0
02:00003692 6100FF10        	  5883:                 bsr ROx_FLAGS
02:00003696 0C8080018F3E    	  5884:                 cmpi.l #$80018F3E,d0
02:0000369C 66FE            	  5885:                 bne.s *
02:0000369E 0C8500000009    	  5886:                 cmpi.l #$00000009,d5
02:000036A4 66FE            	  5887:                 bne.s *
                            	  5888: 
                            	  5889: *        BYTE RIGHT
02:000036A6 E218            	  5890:                 ror.b #1,d0
02:000036A8 6100FEFA        	  5891:                 bsr ROx_FLAGS
02:000036AC EA18            	  5892:                 ror.b #5,d0
02:000036AE 6100FEF4        	  5893:                 bsr ROx_FLAGS
02:000036B2 EE18            	  5894:                 ror.b #7,d0
02:000036B4 6100FEEE        	  5895:                 bsr ROx_FLAGS
02:000036B8 E018            	  5896:                 ror.b #8,d0
02:000036BA 6100FEE8        	  5897:                 bsr ROx_FLAGS
02:000036BE 0C8080018FF1    	  5898:                 cmpi.l #$80018FF1,d0
02:000036C4 66FE            	  5899:                 bne.s *
02:000036C6 0C8500000024    	  5900:                 cmpi.l #$00000024,d5
02:000036CC 66FE            	  5901:                 bne.s *
                            	  5902: 
                            	  5903: *        WORD LEFT
02:000036CE E358            	  5904:                 rol.w #1,d0
02:000036D0 6100FED2        	  5905:                 bsr ROx_FLAGS
02:000036D4 EB58            	  5906:                 rol.w #5,d0
02:000036D6 6100FECC        	  5907:                 bsr ROx_FLAGS
02:000036DA EF58            	  5908:                 rol.w #7,d0
02:000036DC 6100FEC6        	  5909:                 bsr ROx_FLAGS
02:000036E0 E158            	  5910:                 rol.w #8,d0
02:000036E2 6100FEC0        	  5911:                 bsr ROx_FLAGS
02:000036E6 0C808001FE31    	  5912:                 cmpi.l #$8001FE31,d0
02:000036EC 66FE            	  5913:                 bne.s *
02:000036EE 0C8500000037    	  5914:                 cmpi.l #$00000037,d5
02:000036F4 66FE            	  5915:                 bne.s *
                            	  5916: 
                            	  5917: *        WORD RIGHT
02:000036F6 E258            	  5918:                 ror.w #1,d0
02:000036F8 6100FEAA        	  5919:                 bsr ROx_FLAGS
02:000036FC EA58            	  5920:                 ror.w #5,d0
02:000036FE 6100FEA4        	  5921:                 bsr ROx_FLAGS
02:00003702 EE58            	  5922:                 ror.w #7,d0
02:00003704 6100FE9E        	  5923:                 bsr ROx_FLAGS
02:00003708 E058            	  5924:                 ror.w #8,d0
02:0000370A 6100FE98        	  5925:                 bsr ROx_FLAGS
02:0000370E 0C8080018FF1    	  5926:                 cmpi.l #$80018FF1,d0
02:00003714 66FE            	  5927:                 bne.s *
02:00003716 0C850000005B    	  5928:                 cmpi.l #$0000005B,d5
02:0000371C 66FE            	  5929:                 bne.s *
                            	  5930: 
                            	  5931: *        LONG LEFT
02:0000371E E398            	  5932:                 rol.l #1,d0
02:00003720 6100FE82        	  5933:                 bsr ROx_FLAGS
02:00003724 EB98            	  5934:                 rol.l #5,d0
02:00003726 6100FE7C        	  5935:                 bsr ROx_FLAGS
02:0000372A EF98            	  5936:                 rol.l #7,d0
02:0000372C 6100FE76        	  5937:                 bsr ROx_FLAGS
02:00003730 E198            	  5938:                 rol.l #8,d0
02:00003732 6100FE70        	  5939:                 bsr ROx_FLAGS
02:00003736 0C80FE300031    	  5940:                 cmpi.l #$FE300031,d0
02:0000373C 66FE            	  5941:                 bne.s *
02:0000373E 0C8500000065    	  5942:                 cmpi.l #$00000065,d5
02:00003744 66FE            	  5943:                 bne.s *
                            	  5944: 
                            	  5945: *        LONG RIGHT
02:00003746 E298            	  5946:                 ror.l #1,d0
02:00003748 6100FE5A        	  5947:                 bsr ROx_FLAGS
02:0000374C EA98            	  5948:                 ror.l #5,d0
02:0000374E 6100FE54        	  5949:                 bsr ROx_FLAGS
02:00003752 EE98            	  5950:                 ror.l #7,d0
02:00003754 6100FE4E        	  5951:                 bsr ROx_FLAGS
02:00003758 E098            	  5952:                 ror.l #8,d0
02:0000375A 6100FE48        	  5953:                 bsr ROx_FLAGS
02:0000375E 0C8080018FF1    	  5954:                 cmpi.l #$80018FF1,d0
02:00003764 66FE            	  5955:                 bne.s *
02:00003766 0C8500000080    	  5956:                 cmpi.l #$00000080,d5
02:0000376C 66FE            	  5957:                 bne.s *
                            	  5958: 
                            	  5959: 
                            	  5960: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  5961: 
02:0000376E 7A00            	  5962:                 moveq  #$00000000,d5
02:00003770 307C0100        	  5963:                 move.l #$00000100,a0
02:00003774 30BC8FF1        	  5964:                 move.w #$8FF1,(a0)
                            	  5965: 
                            	  5966: *        WORD LEFT
02:00003778 E7D0            	  5967:                 rol (a0)
02:0000377A 6100FE28        	  5968:                 bsr ROx_FLAGS
02:0000377E E7D0            	  5969:                 rol (a0)
02:00003780 6100FE22        	  5970:                 bsr ROx_FLAGS
02:00003784 E7D0            	  5971:                 rol (a0)
02:00003786 6100FE1C        	  5972:                 bsr ROx_FLAGS
02:0000378A E7D0            	  5973:                 rol (a0)
02:0000378C 6100FE16        	  5974:                 bsr ROx_FLAGS
02:00003790 3010            	  5975:                 move.w (a0),d0
02:00003792 0C808001FF18    	  5976:                 cmpi.l #$8001FF18,d0
02:00003798 66FE            	  5977:                 bne.s *
02:0000379A 0C8500000009    	  5978:                 cmpi.l #$00000009,d5
02:000037A0 66FE            	  5979:                 bne.s *
                            	  5980: 
                            	  5981: *        WORD RIGHT
02:000037A2 E6D0            	  5982:                 ror (a0)
02:000037A4 6100FDFE        	  5983:                 bsr ROx_FLAGS
02:000037A8 E6D0            	  5984:                 ror (a0)
02:000037AA 6100FDF8        	  5985:                 bsr ROx_FLAGS
02:000037AE E6D0            	  5986:                 ror (a0)
02:000037B0 6100FDF2        	  5987:                 bsr ROx_FLAGS
02:000037B4 E6D0            	  5988:                 ror (a0)
02:000037B6 6100FDEC        	  5989:                 bsr ROx_FLAGS
02:000037BA E6D0            	  5990:                 ror (a0)
02:000037BC 6100FDE6        	  5991:                 bsr ROx_FLAGS
02:000037C0 E6D0            	  5992:                 ror (a0)
02:000037C2 6100FDE0        	  5993:                 bsr ROx_FLAGS
02:000037C6 3010            	  5994:                 move.w (a0),d0
02:000037C8 0C80800163FC    	  5995:                 cmpi.l #$800163FC,d0
02:000037CE 66FE            	  5996:                 bne.s *
02:000037D0 0C850000001B    	  5997:                 cmpi.l #$0000001B,d5
02:000037D6 66FE            	  5998:                 bne.s *
                            	  5999: 
02:000037D8 4E75            	  6000:                 rts
                            	  6001: 
                            	  6002: 
                            	  6003: 
                            	  6004: *-----------------------------------------------------------
                            	  6005: *-----------------------------------------------------------
                            	  6006: * OPCODE : ROXx
                            	  6007: *-----------------------------------------------------------
                            	  6008: *-----------------------------------------------------------
                            	  6009: 
                            	  6010: *     Subroutine to check and accumulate the flags
02:000037DA 40C3            	  6011: ROXx_FLAGS:     move.w sr,d3
02:000037DC 02830000000F    	  6012:                 andi.l #$0F,d3            * Isolate flags
02:000037E2 DA83            	  6013:                 add.l d3,d5               * Copy flag results into accumulator
02:000037E4 4E75            	  6014:                 rts
                            	  6015: 
                            	  6016: op_ROXx:
                            	  6017: 
                            	  6018: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6019: 
                            	  6020: *        BYTE LEFT
02:000037E6 203C80018FF1    	  6021:                 move.l #$80018FF1,d0
02:000037EC 7A00            	  6022:                 moveq  #$00000000,d5
02:000037EE 7C11            	  6023:                 moveq  #$00000011,d6
                            	  6024: ROXx_LOOP1:
02:000037F0 ED30            	  6025:                 roxl.b d6,d0
02:000037F2 61E6            	  6026:                 bsr ROXx_FLAGS
02:000037F4 51CEFFFA        	  6027:                 dbf d6,ROXx_LOOP1
02:000037F8 0C8080018FD0    	  6028:                 cmpi.l #$80018FD0,d0
02:000037FE 66FE            	  6029:                 bne.s *
02:00003800 0C8500000042    	  6030:                 cmpi.l #$00000042,d5
02:00003806 66FE            	  6031:                 bne.s *
                            	  6032: 
                            	  6033: *        BYTE RIGHT
02:00003808 203C80018FF1    	  6034:                 move.l #$80018FF1,d0
02:0000380E 7C12            	  6035:                 moveq  #$00000012,d6
                            	  6036: ROXx_LOOP2:
02:00003810 EC30            	  6037:                 roxr.b d6,d0
02:00003812 61C6            	  6038:                 bsr ROXx_FLAGS
02:00003814 51CEFFFA        	  6039:                 dbf d6,ROXx_LOOP2
02:00003818 0C8080018F51    	  6040:                 cmpi.l #$80018F51,d0
02:0000381E 66FE            	  6041:                 bne.s *
02:00003820 0C850000009C    	  6042:                 cmpi.l #$0000009C,d5
02:00003826 66FE            	  6043:                 bne.s *
                            	  6044: 
                            	  6045: 
                            	  6046: *        WORD LEFT
02:00003828 203C80018FF1    	  6047:                 move.l #$80018FF1,d0
02:0000382E 7C13            	  6048:                 moveq  #$00000013,d6
                            	  6049: ROXx_LOOP3:
02:00003830 ED70            	  6050:                 roxl.w d6,d0
02:00003832 61A6            	  6051:                 bsr ROXx_FLAGS
02:00003834 51CEFFFA        	  6052:                 dbf d6,ROXx_LOOP3
02:00003838 0C8080013980    	  6053:                 cmpi.l #$80013980,d0
02:0000383E 66FE            	  6054:                 bne.s *
02:00003840 0C85000000C9    	  6055:                 cmpi.l #$000000C9,d5
02:00003846 66FE            	  6056:                 bne.s *
                            	  6057: 
                            	  6058: *        WORD RIGHT
02:00003848 203C80018FF1    	  6059:                 move.l #$80018FF1,d0
02:0000384E 7C1E            	  6060:                 move.l #$0000001E,d6
                            	  6061: ROXx_LOOP4:
02:00003850 EC70            	  6062:                 roxr.w d6,d0
02:00003852 6186            	  6063:                 bsr ROXx_FLAGS
02:00003854 51CEFFFA        	  6064:                 dbf d6,ROXx_LOOP4
02:00003858 0C8080010A1D    	  6065:                 cmpi.l #$80010A1D,d0
02:0000385E 66FE            	  6066:                 bne.s *
02:00003860 0C850000014D    	  6067:                 cmpi.l #$0000014D,d5
02:00003866 66FE            	  6068:                 bne.s *
                            	  6069: 
                            	  6070: 
                            	  6071: *        LONG LEFT
02:00003868 203C80018FF1    	  6072:                 move.l #$80018FF1,d0
02:0000386E 7C15            	  6073:                 moveq  #$00000015,d6
                            	  6074: ROXx_LOOP5:
02:00003870 EDB0            	  6075:                 roxl.l d6,d0
02:00003872 6100FF66        	  6076:                 bsr ROXx_FLAGS
02:00003876 51CEFFF8        	  6077:                 dbf d6,ROXx_LOOP5
02:0000387A 0C80800185D0    	  6078:                 cmpi.l #$800185D0,d0
02:00003880 66FE            	  6079:                 bne.s *
02:00003882 0C85000001A1    	  6080:                 cmpi.l #$000001A1,d5
02:00003888 66FE            	  6081:                 bne.s *
                            	  6082: 
                            	  6083: *        LONG RIGHT
02:0000388A 203C80018FF1    	  6084:                 move.l #$80018FF1,d0
02:00003890 7C16            	  6085:                 moveq  #$00000016,d6
                            	  6086: ROXx_LOOP6:
02:00003892 ECB0            	  6087:                 roxr.l d6,d0
02:00003894 6100FF44        	  6088:                 bsr ROXx_FLAGS
02:00003898 51CEFFF8        	  6089:                 dbf d6,ROXx_LOOP6
02:0000389C 0C80082D8200    	  6090:                 cmpi.l #$082D8200,d0
02:000038A2 66FE            	  6091:                 bne.s *
02:000038A4 0C85000001DE    	  6092:                 cmpi.l #$000001DE,d5
02:000038AA 66FE            	  6093:                 bne.s *
                            	  6094: 
                            	  6095: 
                            	  6096: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6097: 
02:000038AC 203C80018FF1    	  6098:                 move.l #$80018FF1,d0
02:000038B2 7A00            	  6099:                 moveq  #$00000000,d5
                            	  6100: 
                            	  6101: *        BYTE LEFT
02:000038B4 E310            	  6102:                 roxl.b #1,d0
02:000038B6 6100FF22        	  6103:                 bsr ROXx_FLAGS
02:000038BA EB10            	  6104:                 roxl.b #5,d0
02:000038BC 6100FF1C        	  6105:                 bsr ROXx_FLAGS
02:000038C0 EF10            	  6106:                 roxl.b #7,d0
02:000038C2 6100FF16        	  6107:                 bsr ROXx_FLAGS
02:000038C6 E110            	  6108:                 roxl.b #8,d0
02:000038C8 6100FF10        	  6109:                 bsr ROXx_FLAGS
02:000038CC 0C8080018F09    	  6110:                 cmpi.l #$80018F09,d0
02:000038D2 66FE            	  6111:                 bne.s *
02:000038D4 0C850000000B    	  6112:                 cmpi.l #$0000000B,d5
02:000038DA 66FE            	  6113:                 bne.s *
                            	  6114: 
                            	  6115: *        BYTE RIGHT
02:000038DC E210            	  6116:                 roxr.b #1,d0
02:000038DE 6100FEFA        	  6117:                 bsr ROXx_FLAGS
02:000038E2 EA10            	  6118:                 roxr.b #5,d0
02:000038E4 6100FEF4        	  6119:                 bsr ROXx_FLAGS
02:000038E8 EE10            	  6120:                 roxr.b #7,d0
02:000038EA 6100FEEE        	  6121:                 bsr ROXx_FLAGS
02:000038EE E010            	  6122:                 roxr.b #8,d0
02:000038F0 6100FEE8        	  6123:                 bsr ROXx_FLAGS
02:000038F4 0C8080018F00    	  6124:                 cmpi.l #$80018F00,d0
02:000038FA 66FE            	  6125:                 bne.s *
02:000038FC 0C8500000015    	  6126:                 cmpi.l #$00000015,d5
02:00003902 66FE            	  6127:                 bne.s *
                            	  6128: 
                            	  6129: *        WORD LEFT
02:00003904 E350            	  6130:                 roxl.w #1,d0
02:00003906 6100FED2        	  6131:                 bsr ROXx_FLAGS
02:0000390A EB50            	  6132:                 roxl.w #5,d0
02:0000390C 6100FECC        	  6133:                 bsr ROXx_FLAGS
02:00003910 EF50            	  6134:                 roxl.w #7,d0
02:00003912 6100FEC6        	  6135:                 bsr ROXx_FLAGS
02:00003916 E150            	  6136:                 roxl.w #8,d0
02:00003918 6100FEC0        	  6137:                 bsr ROXx_FLAGS
02:0000391C 0C808001B000    	  6138:                 cmpi.l #$8001B000,d0
02:00003922 66FE            	  6139:                 bne.s *
02:00003924 0C8500000027    	  6140:                 cmpi.l #$00000027,d5
02:0000392A 66FE            	  6141:                 bne.s *
                            	  6142: 
                            	  6143: *        WORD RIGHT
02:0000392C E250            	  6144:                 roxr.w #1,d0
02:0000392E 6100FEAA        	  6145:                 bsr ROXx_FLAGS
02:00003932 EA50            	  6146:                 roxr.w #5,d0
02:00003934 6100FEA4        	  6147:                 bsr ROXx_FLAGS
02:00003938 EE50            	  6148:                 roxr.w #7,d0
02:0000393A 6100FE9E        	  6149:                 bsr ROXx_FLAGS
02:0000393E E050            	  6150:                 roxr.w #8,d0
02:00003940 6100FE98        	  6151:                 bsr ROXx_FLAGS
02:00003944 0C8080010A00    	  6152:                 cmpi.l #$80010A00,d0
02:0000394A 66FE            	  6153:                 bne.s *
02:0000394C 0C8500000028    	  6154:                 cmpi.l #$00000028,d5
02:00003952 66FE            	  6155:                 bne.s *
                            	  6156: 
                            	  6157: *        LONG LEFT
02:00003954 E390            	  6158:                 roxl.l #1,d0
02:00003956 6100FE82        	  6159:                 bsr ROXx_FLAGS
02:0000395A EB90            	  6160:                 roxl.l #5,d0
02:0000395C 6100FE7C        	  6161:                 bsr ROXx_FLAGS
02:00003960 EF90            	  6162:                 roxl.l #7,d0
02:00003962 6100FE76        	  6163:                 bsr ROXx_FLAGS
02:00003966 E190            	  6164:                 roxl.l #8,d0
02:00003968 6100FE70        	  6165:                 bsr ROXx_FLAGS
02:0000396C 0C8040000010    	  6166:                 cmpi.l #$40000010,d0
02:00003972 66FE            	  6167:                 bne.s *
02:00003974 0C850000002A    	  6168:                 cmpi.l #$0000002A,d5
02:0000397A 66FE            	  6169:                 bne.s *
                            	  6170: 
                            	  6171: *        LONG RIGHT
02:0000397C E290            	  6172:                 roxr.l #1,d0
02:0000397E 6100FE5A        	  6173:                 bsr ROXx_FLAGS
02:00003982 EA90            	  6174:                 roxr.l #5,d0
02:00003984 6100FE54        	  6175:                 bsr ROXx_FLAGS
02:00003988 EE90            	  6176:                 roxr.l #7,d0
02:0000398A 6100FE4E        	  6177:                 bsr ROXx_FLAGS
02:0000398E E090            	  6178:                 roxr.l #8,d0
02:00003990 6100FE48        	  6179:                 bsr ROXx_FLAGS
02:00003994 0C8000010200    	  6180:                 cmpi.l #$00010200,d0
02:0000399A 66FE            	  6181:                 bne.s *
02:0000399C 0C8500000032    	  6182:                 cmpi.l #$00000032,d5
02:000039A2 66FE            	  6183:                 bne.s *
                            	  6184: 
                            	  6185: 
                            	  6186: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6187: 
02:000039A4 7A00            	  6188:                 moveq  #$00000000,d5
02:000039A6 307C0100        	  6189:                 move.l #$00000100,a0
02:000039AA 30BC8FF1        	  6190:                 move.w #$8FF1,(a0)
                            	  6191: 
                            	  6192: *        WORD LEFT
02:000039AE E5D0            	  6193:                 roxl (a0)
02:000039B0 6100FE28        	  6194:                 bsr ROXx_FLAGS
02:000039B4 E5D0            	  6195:                 roxl (a0)
02:000039B6 6100FE22        	  6196:                 bsr ROXx_FLAGS
02:000039BA E5D0            	  6197:                 roxl (a0)
02:000039BC 6100FE1C        	  6198:                 bsr ROXx_FLAGS
02:000039C0 E5D0            	  6199:                 roxl (a0)
02:000039C2 6100FE16        	  6200:                 bsr ROXx_FLAGS
02:000039C6 3010            	  6201:                 move.w (a0),d0
02:000039C8 0C800001FF10    	  6202:                 cmpi.l #$0001FF10,d0
02:000039CE 66FE            	  6203:                 bne.s *
02:000039D0 0C8500000009    	  6204:                 cmpi.l #$00000009,d5
02:000039D6 66FE            	  6205:                 bne.s *
                            	  6206: 
                            	  6207: *        WORD RIGHT
02:000039D8 E4D0            	  6208:                 roxr (a0)
02:000039DA 6100FDFE        	  6209:                 bsr ROXx_FLAGS
02:000039DE E4D0            	  6210:                 roxr (a0)
02:000039E0 6100FDF8        	  6211:                 bsr ROXx_FLAGS
02:000039E4 E4D0            	  6212:                 roxr (a0)
02:000039E6 6100FDF2        	  6213:                 bsr ROXx_FLAGS
02:000039EA E4D0            	  6214:                 roxr (a0)
02:000039EC 6100FDEC        	  6215:                 bsr ROXx_FLAGS
02:000039F0 E4D0            	  6216:                 roxr (a0)
02:000039F2 6100FDE6        	  6217:                 bsr ROXx_FLAGS
02:000039F6 E4D0            	  6218:                 roxr (a0)
02:000039F8 6100FDE0        	  6219:                 bsr ROXx_FLAGS
02:000039FC 3010            	  6220:                 move.w (a0),d0
02:000039FE 0C80000103FC    	  6221:                 cmpi.l #$000103FC,d0
02:00003A04 66FE            	  6222:                 bne.s *
02:00003A06 0C850000000A    	  6223:                 cmpi.l #$0000000A,d5
02:00003A0C 66FE            	  6224:                 bne.s *
                            	  6225: 
02:00003A0E 4E75            	  6226:                 rts
                            	  6227: 
                            	  6228: 
                            	  6229: 
                            	  6230: 
                            	  6231: *-----------------------------------------------------------
                            	  6232: *-----------------------------------------------------------
                            	  6233: * OPCODE : SHIFTS
                            	  6234: *-----------------------------------------------------------
                            	  6235: *-----------------------------------------------------------
                            	  6236: 
                            	  6237: *     Subroutine to check and accumulate the flags
02:00003A10 40C3            	  6238: SHIFTS_FLAGS:   move.w sr,d3
02:00003A12 02830000000F    	  6239:                 andi.l #$0F,d3            * Isolate flags
02:00003A18 DA83            	  6240:                 add.l d3,d5               * Copy flag results into accumulator
02:00003A1A 4E75            	  6241:                 rts
                            	  6242: 
                            	  6243: op_SHIFTS:
                            	  6244: 
                            	  6245: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6246: 
                            	  6247: *        BYTE LEFT
02:00003A1C 203C80018F81    	  6248:                 move.l #$80018F81,d0
02:00003A22 7A00            	  6249:                 moveq  #$00000000,d5
02:00003A24 7C02            	  6250:                 moveq  #$00000002,d6
                            	  6251: SHIFTS_LOOP1:
02:00003A26 ED20            	  6252:                 asl.b d6,d0
02:00003A28 61E6            	  6253:                 bsr SHIFTS_FLAGS
02:00003A2A 51CEFFFA        	  6254:                 dbf d6,SHIFTS_LOOP1
02:00003A2E 0C8080018F08    	  6255:                 cmpi.l #$80018F08,d0
02:00003A34 66FE            	  6256:                 bne.s *
02:00003A36 0C8500000002    	  6257:                 cmpi.l #$00000002,d5
02:00003A3C 66FE            	  6258:                 bne.s *
                            	  6259: 
                            	  6260: *        BYTE RIGHT
02:00003A3E 203C80018F81    	  6261:                 move.l #$80018F81,d0
02:00003A44 7C02            	  6262:                 moveq  #$00000002,d6
                            	  6263: SHIFTS_LOOP2:
02:00003A46 EC20            	  6264:                 asr.b d6,d0
02:00003A48 61C6            	  6265:                 bsr SHIFTS_FLAGS
02:00003A4A 51CEFFFA        	  6266:                 dbf d6,SHIFTS_LOOP2
02:00003A4E 0C8080018FF0    	  6267:                 cmpi.l #$80018FF0,d0
02:00003A54 66FE            	  6268:                 bne.s *
02:00003A56 0C850000001A    	  6269:                 cmpi.l #$0000001A,d5
02:00003A5C 66FE            	  6270:                 bne.s *
                            	  6271: 
                            	  6272: 
                            	  6273: *        WORD LEFT
02:00003A5E 203C80018FF1    	  6274:                 move.l #$80018FF1,d0
02:00003A64 7C02            	  6275:                 moveq  #$00000002,d6
                            	  6276: SHIFTS_LOOP3:
02:00003A66 ED60            	  6277:                 asl.w d6,d0
02:00003A68 61A6            	  6278:                 bsr SHIFTS_FLAGS
02:00003A6A 51CEFFFA        	  6279:                 dbf d6,SHIFTS_LOOP3
02:00003A6E 0C8080017F88    	  6280:                 cmpi.l #$80017F88,d0
02:00003A74 66FE            	  6281:                 bne.s *
02:00003A76 0C850000001C    	  6282:                 cmpi.l #$0000001C,d5
02:00003A7C 66FE            	  6283:                 bne.s *
                            	  6284: 
                            	  6285: *        WORD RIGHT
02:00003A7E 203C80018FF1    	  6286:                 move.l #$80018FF1,d0
02:00003A84 7C02            	  6287:                 moveq  #$00000002,d6
                            	  6288: SHIFTS_LOOP4:
02:00003A86 EC60            	  6289:                 asr.w d6,d0
02:00003A88 6186            	  6290:                 bsr SHIFTS_FLAGS
02:00003A8A 51CEFFFA        	  6291:                 dbf d6,SHIFTS_LOOP4
02:00003A8E 0C808001F1FE    	  6292:                 cmpi.l #$8001F1FE,d0
02:00003A94 66FE            	  6293:                 bne.s *
02:00003A96 0C8500000034    	  6294:                 cmpi.l #$00000034,d5
02:00003A9C 66FE            	  6295:                 bne.s *
                            	  6296: 
                            	  6297: 
                            	  6298: *        LONG LEFT
02:00003A9E 203C80018FF1    	  6299:                 move.l #$80018FF1,d0
02:00003AA4 7C02            	  6300:                 moveq  #$00000002,d6
                            	  6301: SHIFTS_LOOP5:
02:00003AA6 EDA0            	  6302:                 asl.l d6,d0
02:00003AA8 6100FF66        	  6303:                 bsr SHIFTS_FLAGS
02:00003AAC 51CEFFF8        	  6304:                 dbf d6,SHIFTS_LOOP5
02:00003AB0 0C80000C7F88    	  6305:                 cmpi.l #$000C7F88,d0
02:00003AB6 66FE            	  6306:                 bne.s *
02:00003AB8 0C8500000036    	  6307:                 cmpi.l #$00000036,d5
02:00003ABE 66FE            	  6308:                 bne.s *
                            	  6309: 
                            	  6310: *        LONG RIGHT
02:00003AC0 203C80018FF1    	  6311:                 move.l #$80018FF1,d0
02:00003AC6 7C02            	  6312:                 moveq  #$00000002,d6
                            	  6313: SHIFTS_LOOP6:
02:00003AC8 ECA0            	  6314:                 asr.l d6,d0
02:00003ACA 6100FF44        	  6315:                 bsr SHIFTS_FLAGS
02:00003ACE 51CEFFF8        	  6316:                 dbf d6,SHIFTS_LOOP6
02:00003AD2 0C80F00031FE    	  6317:                 cmpi.l #$F00031FE,d0
02:00003AD8 66FE            	  6318:                 bne.s *
02:00003ADA 0C850000004E    	  6319:                 cmpi.l #$0000004E,d5
02:00003AE0 66FE            	  6320:                 bne.s *
                            	  6321: 
                            	  6322: 
                            	  6323: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6324: 
02:00003AE2 203C80018FF1    	  6325:                 move.l #$80018FF1,d0
02:00003AE8 7A00            	  6326:                 moveq  #$00000000,d5
                            	  6327: 
                            	  6328: *        BYTE LEFT
02:00003AEA D000            	  6329:                 asl.b #1,d0
02:00003AEC 6100FF22        	  6330:                 bsr SHIFTS_FLAGS
02:00003AF0 E500            	  6331:                 asl.b #2,d0
02:00003AF2 6100FF1C        	  6332:                 bsr SHIFTS_FLAGS
02:00003AF6 D000            	  6333:                 asl.b #1,d0
02:00003AF8 6100FF16        	  6334:                 bsr SHIFTS_FLAGS
02:00003AFC E700            	  6335:                 asl.b #3,d0
02:00003AFE 6100FF10        	  6336:                 bsr SHIFTS_FLAGS
02:00003B02 0C8080018F80    	  6337:                 cmpi.l #$80018F80,d0
02:00003B08 66FE            	  6338:                 bne.s *
02:00003B0A 0C850000001F    	  6339:                 cmpi.l #$0000001F,d5
02:00003B10 66FE            	  6340:                 bne.s *
                            	  6341: 
                            	  6342: *        BYTE RIGHT
02:00003B12 E200            	  6343:                 asr.b #1,d0
02:00003B14 6100FEFA        	  6344:                 bsr SHIFTS_FLAGS
02:00003B18 E400            	  6345:                 asr.b #2,d0
02:00003B1A 6100FEF4        	  6346:                 bsr SHIFTS_FLAGS
02:00003B1E E600            	  6347:                 asr.b #3,d0
02:00003B20 6100FEEE        	  6348:                 bsr SHIFTS_FLAGS
02:00003B24 E200            	  6349:                 asr.b #1,d0
02:00003B26 6100FEE8        	  6350:                 bsr SHIFTS_FLAGS
02:00003B2A 0C8080018FFF    	  6351:                 cmpi.l #$80018FFF,d0
02:00003B30 66FE            	  6352:                 bne.s *
02:00003B32 0C850000003F    	  6353:                 cmpi.l #$0000003F,d5
02:00003B38 66FE            	  6354:                 bne.s *
                            	  6355: 
                            	  6356: *        WORD LEFT
02:00003B3A D040            	  6357:                 asl.w #1,d0
02:00003B3C 6100FED2        	  6358:                 bsr SHIFTS_FLAGS
02:00003B40 E540            	  6359:                 asl.w #2,d0
02:00003B42 6100FECC        	  6360:                 bsr SHIFTS_FLAGS
02:00003B46 E740            	  6361:                 asl.w #3,d0
02:00003B48 6100FEC6        	  6362:                 bsr SHIFTS_FLAGS
02:00003B4C EB40            	  6363:                 asl.w #5,d0
02:00003B4E 6100FEC0        	  6364:                 bsr SHIFTS_FLAGS
02:00003B52 0C808001F800    	  6365:                 cmpi.l #$8001F800,d0
02:00003B58 66FE            	  6366:                 bne.s *
02:00003B5A 0C8500000056    	  6367:                 cmpi.l #$00000056,d5
02:00003B60 66FE            	  6368:                 bne.s *
                            	  6369: 
                            	  6370: *        WORD RIGHT
02:00003B62 EA40            	  6371:                 asr.w #5,d0
02:00003B64 6100FEAA        	  6372:                 bsr SHIFTS_FLAGS
02:00003B68 E240            	  6373:                 asr.w #1,d0
02:00003B6A 6100FEA4        	  6374:                 bsr SHIFTS_FLAGS
02:00003B6E E440            	  6375:                 asr.w #2,d0
02:00003B70 6100FE9E        	  6376:                 bsr SHIFTS_FLAGS
02:00003B74 E840            	  6377:                 asr.w #4,d0
02:00003B76 6100FE98        	  6378:                 bsr SHIFTS_FLAGS
02:00003B7A 0C808001FFFF    	  6379:                 cmpi.l #$8001FFFF,d0
02:00003B80 66FE            	  6380:                 bne.s *
02:00003B82 0C8500000077    	  6381:                 cmpi.l #$00000077,d5
02:00003B88 66FE            	  6382:                 bne.s *
                            	  6383: 
                            	  6384: *        LONG LEFT
02:00003B8A 203C80018FF1    	  6385:                 move.l #$80018FF1,d0
02:00003B90 D080            	  6386:                 asl.l #1,d0
02:00003B92 6100FE7C        	  6387:                 bsr SHIFTS_FLAGS
02:00003B96 E580            	  6388:                 asl.l #2,d0
02:00003B98 6100FE76        	  6389:                 bsr SHIFTS_FLAGS
02:00003B9C EF80            	  6390:                 asl.l #7,d0
02:00003B9E 6100FE70        	  6391:                 bsr SHIFTS_FLAGS
02:00003BA2 E980            	  6392:                 asl.l #4,d0
02:00003BA4 6100FE6A        	  6393:                 bsr SHIFTS_FLAGS
02:00003BA8 0C8063FC4000    	  6394:                 cmpi.l #$63FC4000,d0
02:00003BAE 66FE            	  6395:                 bne.s *
02:00003BB0 0C850000007A    	  6396:                 cmpi.l #$0000007A,d5
02:00003BB6 66FE            	  6397:                 bne.s *
                            	  6398: 
                            	  6399: *        LONG RIGHT
02:00003BB8 203C80018FF1    	  6400:                 move.l #$80018FF1,d0
02:00003BBE E280            	  6401:                 asr.l #1,d0
02:00003BC0 6100FE4E        	  6402:                 bsr SHIFTS_FLAGS
02:00003BC4 EA80            	  6403:                 asr.l #5,d0
02:00003BC6 6100FE48        	  6404:                 bsr SHIFTS_FLAGS
02:00003BCA EE80            	  6405:                 asr.l #7,d0
02:00003BCC 6100FE42        	  6406:                 bsr SHIFTS_FLAGS
02:00003BD0 E080            	  6407:                 asr.l #8,d0
02:00003BD2 6100FE3C        	  6408:                 bsr SHIFTS_FLAGS
02:00003BD6 0C80FFFFFC00    	  6409:                 cmpi.l #$FFFFFC00,d0
02:00003BDC 66FE            	  6410:                 bne.s *
02:00003BDE 0C850000009C    	  6411:                 cmpi.l #$0000009C,d5
02:00003BE4 66FE            	  6412:                 bne.s *
                            	  6413: 
                            	  6414: 
                            	  6415: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6416: 
02:00003BE6 7A00            	  6417:                 moveq  #$00000000,d5
02:00003BE8 307C0100        	  6418:                 move.l #$00000100,a0
02:00003BEC 30BC8FF1        	  6419:                 move.w #$8FF1,(a0)
                            	  6420: 
                            	  6421: *        WORD LEFT
02:00003BF0 E1D0            	  6422:                 asl  (a0)
02:00003BF2 6100FE1C        	  6423:                 bsr SHIFTS_FLAGS
02:00003BF6 E1D0            	  6424:                 asl  (a0)
02:00003BF8 6100FE16        	  6425:                 bsr SHIFTS_FLAGS
02:00003BFC E1D0            	  6426:                 asl  (a0)
02:00003BFE 6100FE10        	  6427:                 bsr SHIFTS_FLAGS
02:00003C02 E1D0            	  6428:                 asl  (a0)
02:00003C04 6100FE0A        	  6429:                 bsr SHIFTS_FLAGS
02:00003C08 3010            	  6430:                 move.w (a0),d0
02:00003C0A 0C80FFFFFF10    	  6431:                 cmpi.l #$FFFFFF10,d0
02:00003C10 66FE            	  6432:                 bne.s *
02:00003C12 0C850000000D    	  6433:                 cmpi.l #$0000000D,d5
02:00003C18 66FE            	  6434:                 bne.s *
                            	  6435: 
                            	  6436: *        WORD RIGHT
02:00003C1A E0D0            	  6437:                 asr (a0)
02:00003C1C 6100FDF2        	  6438:                 bsr SHIFTS_FLAGS
02:00003C20 E0D0            	  6439:                 asr (a0)
02:00003C22 6100FDEC        	  6440:                 bsr SHIFTS_FLAGS
02:00003C26 E0D0            	  6441:                 asr (a0)
02:00003C28 6100FDE6        	  6442:                 bsr SHIFTS_FLAGS
02:00003C2C E0D0            	  6443:                 asr (a0)
02:00003C2E 6100FDE0        	  6444:                 bsr SHIFTS_FLAGS
02:00003C32 E0D0            	  6445:                 asr (a0)
02:00003C34 6100FDDA        	  6446:                 bsr SHIFTS_FLAGS
02:00003C38 E0D0            	  6447:                 asr (a0)
02:00003C3A 6100FDD4        	  6448:                 bsr SHIFTS_FLAGS
02:00003C3E 3010            	  6449:                 move.w (a0),d0
02:00003C40 0C80FFFFFFFC    	  6450:                 cmpi.l #$FFFFFFFC,d0
02:00003C46 66FE            	  6451:                 bne.s *
02:00003C48 0C850000003E    	  6452:                 cmpi.l #$0000003E,d5
02:00003C4E 66FE            	  6453:                 bne.s *
                            	  6454: 
02:00003C50 4E75            	  6455:                 rts
                            	  6456: 
                            	  6457: 
                            	  6458: 
                            	  6459: *-----------------------------------------------------------
                            	  6460: *-----------------------------------------------------------
                            	  6461: * OPCODE : SHIFTS2
                            	  6462: *-----------------------------------------------------------
                            	  6463: *-----------------------------------------------------------
                            	  6464: 
                            	  6465: *     Subroutine to check and accumulate the flags
02:00003C52 40C3            	  6466: SHIFTS2_FLAGS:  move.w sr,d3
02:00003C54 02830000000F    	  6467:                 andi.l #$0F,d3            * Isolate flags
02:00003C5A DA83            	  6468:                 add.l d3,d5               * Copy flag results into accumulator
02:00003C5C 4E75            	  6469:                 rts
                            	  6470: 
                            	  6471: op_SHIFTS2:
                            	  6472: 
                            	  6473: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6474: 
                            	  6475: *        BYTE LEFT
02:00003C5E 203C80018F81    	  6476:                 move.l #$80018F81,d0
02:00003C64 7A00            	  6477:                 moveq  #$00000000,d5
02:00003C66 7C02            	  6478:                 moveq  #$00000002,d6
                            	  6479: SHIFTS2_LOOP1:
02:00003C68 ED28            	  6480:                 lsl.b d6,d0
02:00003C6A 61E6            	  6481:                 bsr SHIFTS2_FLAGS
02:00003C6C 51CEFFFA        	  6482:                 dbf d6,SHIFTS2_LOOP1
02:00003C70 0C8080018F08    	  6483:                 cmpi.l #$80018F08,d0
02:00003C76 66FE            	  6484:                 bne.s *
02:00003C78 4A85            	  6485:                 cmpi.l #$00000000,d5
02:00003C7A 66FE            	  6486:                 bne.s *
                            	  6487: 
                            	  6488: *        BYTE RIGHT
02:00003C7C 203C80018F81    	  6489:                 move.l #$80018F81,d0
02:00003C82 7C02            	  6490:                 moveq  #$00000002,d6
                            	  6491: SHIFTS2_LOOP2:
02:00003C84 EC28            	  6492:                 lsr.b d6,d0
02:00003C86 61CA            	  6493:                 bsr SHIFTS2_FLAGS
02:00003C88 51CEFFFA        	  6494:                 dbf d6,SHIFTS2_LOOP2
02:00003C8C 0C8080018F10    	  6495:                 cmpi.l #$80018F10,d0
02:00003C92 66FE            	  6496:                 bne.s *
02:00003C94 4A85            	  6497:                 cmpi.l #$00000000,d5
02:00003C96 66FE            	  6498:                 bne.s *
                            	  6499: 
                            	  6500: 
                            	  6501: *        WORD LEFT
02:00003C98 203C80018FF1    	  6502:                 move.l #$80018FF1,d0
02:00003C9E 7C02            	  6503:                 moveq  #$00000002,d6
                            	  6504: SHIFTS2_LOOP3:
02:00003CA0 ED68            	  6505:                 lsl.w d6,d0
02:00003CA2 61AE            	  6506:                 bsr SHIFTS2_FLAGS
02:00003CA4 51CEFFFA        	  6507:                 dbf d6,SHIFTS2_LOOP3
02:00003CA8 0C8080017F88    	  6508:                 cmpi.l #$80017F88,d0
02:00003CAE 66FE            	  6509:                 bne.s *
02:00003CB0 4A85            	  6510:                 cmpi.l #$00000000,d5
02:00003CB2 66FE            	  6511:                 bne.s *
                            	  6512: 
                            	  6513: *        WORD RIGHT
02:00003CB4 203C80018FF1    	  6514:                 move.l #$80018FF1,d0
02:00003CBA 7C02            	  6515:                 moveq  #$00000002,d6
                            	  6516: SHIFTS2_LOOP4:
02:00003CBC EC68            	  6517:                 lsr.w d6,d0
02:00003CBE 6192            	  6518:                 bsr SHIFTS2_FLAGS
02:00003CC0 51CEFFFA        	  6519:                 dbf d6,SHIFTS2_LOOP4
02:00003CC4 0C80800111FE    	  6520:                 cmpi.l #$800111FE,d0
02:00003CCA 66FE            	  6521:                 bne.s *
02:00003CCC 4A85            	  6522:                 cmpi.l #$00000000,d5
02:00003CCE 66FE            	  6523:                 bne.s *
                            	  6524: 
                            	  6525: 
                            	  6526: *        LONG LEFT
02:00003CD0 203C80018FF1    	  6527:                 move.l #$80018FF1,d0
02:00003CD6 7C02            	  6528:                 moveq  #$00000002,d6
                            	  6529: SHIFTS2_LOOP5:
02:00003CD8 EDA8            	  6530:                 lsl.l d6,d0
02:00003CDA 6100FF76        	  6531:                 bsr SHIFTS2_FLAGS
02:00003CDE 51CEFFF8        	  6532:                 dbf d6,SHIFTS2_LOOP5
02:00003CE2 0C80000C7F88    	  6533:                 cmpi.l #$000C7F88,d0
02:00003CE8 66FE            	  6534:                 bne.s *
02:00003CEA 4A85            	  6535:                 cmpi.l #$00000000,d5
02:00003CEC 66FE            	  6536:                 bne.s *
                            	  6537: 
                            	  6538: *        LONG RIGHT
02:00003CEE 203C80018FF1    	  6539:                 move.l #$80018FF1,d0
02:00003CF4 7C02            	  6540:                 moveq  #$00000002,d6
                            	  6541: SHIFTS2_LOOP6:
02:00003CF6 ECA8            	  6542:                 lsr.l d6,d0
02:00003CF8 6100FF58        	  6543:                 bsr SHIFTS2_FLAGS
02:00003CFC 51CEFFF8        	  6544:                 dbf d6,SHIFTS2_LOOP6
02:00003D00 0C80100031FE    	  6545:                 cmpi.l #$100031FE,d0
02:00003D06 66FE            	  6546:                 bne.s *
02:00003D08 4A85            	  6547:                 cmpi.l #$00000000,d5
02:00003D0A 66FE            	  6548:                 bne.s *
                            	  6549: 
                            	  6550: 
                            	  6551: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6552: 
02:00003D0C 203C80018FF1    	  6553:                 move.l #$80018FF1,d0
02:00003D12 7A00            	  6554:                 moveq  #$00000000,d5
                            	  6555: 
                            	  6556: *        BYTE LEFT
02:00003D14 E308            	  6557:                 lsl.b #1,d0
02:00003D16 6100FF3A        	  6558:                 bsr SHIFTS2_FLAGS
02:00003D1A E508            	  6559:                 lsl.b #2,d0
02:00003D1C 6100FF34        	  6560:                 bsr SHIFTS2_FLAGS
02:00003D20 E308            	  6561:                 lsl.b #1,d0
02:00003D22 6100FF2E        	  6562:                 bsr SHIFTS2_FLAGS
02:00003D26 E708            	  6563:                 lsl.b #3,d0
02:00003D28 6100FF28        	  6564:                 bsr SHIFTS2_FLAGS
02:00003D2C 0C8080018F80    	  6565:                 cmpi.l #$80018F80,d0
02:00003D32 66FE            	  6566:                 bne.s *
02:00003D34 0C850000001B    	  6567:                 cmpi.l #$0000001B,d5
02:00003D3A 66FE            	  6568:                 bne.s *
                            	  6569: 
                            	  6570: *        BYTE RIGHT
02:00003D3C E208            	  6571:                 lsr.b #1,d0
02:00003D3E 6100FF12        	  6572:                 bsr SHIFTS2_FLAGS
02:00003D42 E408            	  6573:                 lsr.b #2,d0
02:00003D44 6100FF0C        	  6574:                 bsr SHIFTS2_FLAGS
02:00003D48 E608            	  6575:                 lsr.b #3,d0
02:00003D4A 6100FF06        	  6576:                 bsr SHIFTS2_FLAGS
02:00003D4E E208            	  6577:                 lsr.b #1,d0
02:00003D50 6100FF00        	  6578:                 bsr SHIFTS2_FLAGS
02:00003D54 0C8080018F01    	  6579:                 cmpi.l #$80018F01,d0
02:00003D5A 66FE            	  6580:                 bne.s *
02:00003D5C 0C850000001B    	  6581:                 cmpi.l #$0000001B,d5
02:00003D62 66FE            	  6582:                 bne.s *
                            	  6583: 
                            	  6584: *        WORD LEFT
02:00003D64 E348            	  6585:                 lsl.w #1,d0
02:00003D66 6100FEEA        	  6586:                 bsr SHIFTS2_FLAGS
02:00003D6A E548            	  6587:                 lsl.w #2,d0
02:00003D6C 6100FEE4        	  6588:                 bsr SHIFTS2_FLAGS
02:00003D70 E748            	  6589:                 lsl.w #3,d0
02:00003D72 6100FEDE        	  6590:                 bsr SHIFTS2_FLAGS
02:00003D76 EB48            	  6591:                 lsl.w #5,d0
02:00003D78 6100FED8        	  6592:                 bsr SHIFTS2_FLAGS
02:00003D7C 0C8080010800    	  6593:                 cmpi.l #$80010800,d0
02:00003D82 66FE            	  6594:                 bne.s *
02:00003D84 0C8500000025    	  6595:                 cmpi.l #$00000025,d5
02:00003D8A 66FE            	  6596:                 bne.s *
                            	  6597: 
                            	  6598: *        WORD RIGHT
02:00003D8C EA48            	  6599:                 lsr.w #5,d0
02:00003D8E 6100FEC2        	  6600:                 bsr SHIFTS2_FLAGS
02:00003D92 E248            	  6601:                 lsr.w #1,d0
02:00003D94 6100FEBC        	  6602:                 bsr SHIFTS2_FLAGS
02:00003D98 E448            	  6603:                 lsr.w #2,d0
02:00003D9A 6100FEB6        	  6604:                 bsr SHIFTS2_FLAGS
02:00003D9E E848            	  6605:                 lsr.w #4,d0
02:00003DA0 6100FEB0        	  6606:                 bsr SHIFTS2_FLAGS
02:00003DA4 0C8080010000    	  6607:                 cmpi.l #$80010000,d0
02:00003DAA 66FE            	  6608:                 bne.s *
02:00003DAC 0C850000002A    	  6609:                 cmpi.l #$0000002A,d5
02:00003DB2 66FE            	  6610:                 bne.s *
                            	  6611: 
                            	  6612: *        LONG LEFT
02:00003DB4 203C80018FF1    	  6613:                 move.l #$80018FF1,d0
02:00003DBA E388            	  6614:                 lsl.l #1,d0
02:00003DBC 6100FE94        	  6615:                 bsr SHIFTS2_FLAGS
02:00003DC0 E588            	  6616:                 lsl.l #2,d0
02:00003DC2 6100FE8E        	  6617:                 bsr SHIFTS2_FLAGS
02:00003DC6 EF88            	  6618:                 lsl.l #7,d0
02:00003DC8 6100FE88        	  6619:                 bsr SHIFTS2_FLAGS
02:00003DCC E988            	  6620:                 lsl.l #4,d0
02:00003DCE 6100FE82        	  6621:                 bsr SHIFTS2_FLAGS
02:00003DD2 0C8063FC4000    	  6622:                 cmpi.l #$63FC4000,d0
02:00003DD8 66FE            	  6623:                 bne.s *
02:00003DDA 0C850000002B    	  6624:                 cmpi.l #$0000002B,d5
02:00003DE0 66FE            	  6625:                 bne.s *
                            	  6626: 
                            	  6627: *        LONG RIGHT
02:00003DE2 203C80018FF1    	  6628:                 move.l #$80018FF1,d0
02:00003DE8 E288            	  6629:                 lsr.l #1,d0
02:00003DEA 6100FE66        	  6630:                 bsr SHIFTS2_FLAGS
02:00003DEE EA88            	  6631:                 lsr.l #5,d0
02:00003DF0 6100FE60        	  6632:                 bsr SHIFTS2_FLAGS
02:00003DF4 EE88            	  6633:                 lsr.l #7,d0
02:00003DF6 6100FE5A        	  6634:                 bsr SHIFTS2_FLAGS
02:00003DFA E088            	  6635:                 lsr.l #8,d0
02:00003DFC 6100FE54        	  6636:                 bsr SHIFTS2_FLAGS
02:00003E00 0C8000000400    	  6637:                 cmpi.l #$00000400,d0
02:00003E06 66FE            	  6638:                 bne.s *
02:00003E08 0C850000002D    	  6639:                 cmpi.l #$0000002D,d5
02:00003E0E 66FE            	  6640:                 bne.s *
                            	  6641: 
                            	  6642: 
                            	  6643: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6644: 
02:00003E10 7A00            	  6645:                 moveq  #$00000000,d5
02:00003E12 307C0100        	  6646:                 move.l #$00000100,a0
02:00003E16 30BC8FF1        	  6647:                 move.w #$8FF1,(a0)
                            	  6648: 
                            	  6649: *        WORD LEFT
02:00003E1A E3D0            	  6650:                 lsl  (a0)
02:00003E1C 6100FE34        	  6651:                 bsr SHIFTS2_FLAGS
02:00003E20 E3D0            	  6652:                 lsl  (a0)
02:00003E22 6100FE2E        	  6653:                 bsr SHIFTS2_FLAGS
02:00003E26 E3D0            	  6654:                 lsl  (a0)
02:00003E28 6100FE28        	  6655:                 bsr SHIFTS2_FLAGS
02:00003E2C E3D0            	  6656:                 lsl  (a0)
02:00003E2E 6100FE22        	  6657:                 bsr SHIFTS2_FLAGS
02:00003E32 3010            	  6658:                 move.w (a0),d0
02:00003E34 0C800000FF10    	  6659:                 cmpi.l #$0000FF10,d0
02:00003E3A 66FE            	  6660:                 bne.s *
02:00003E3C 0C8500000009    	  6661:                 cmpi.l #$00000009,d5
02:00003E42 66FE            	  6662:                 bne.s *
                            	  6663: 
                            	  6664: *        WORD RIGHT
02:00003E44 E2D0            	  6665:                 lsr (a0)
02:00003E46 6100FE0A        	  6666:                 bsr SHIFTS2_FLAGS
02:00003E4A E2D0            	  6667:                 lsr (a0)
02:00003E4C 6100FE04        	  6668:                 bsr SHIFTS2_FLAGS
02:00003E50 E2D0            	  6669:                 lsr (a0)
02:00003E52 6100FDFE        	  6670:                 bsr SHIFTS2_FLAGS
02:00003E56 E2D0            	  6671:                 lsr (a0)
02:00003E58 6100FDF8        	  6672:                 bsr SHIFTS2_FLAGS
02:00003E5C E2D0            	  6673:                 lsr (a0)
02:00003E5E 6100FDF2        	  6674:                 bsr SHIFTS2_FLAGS
02:00003E62 E2D0            	  6675:                 lsr (a0)
02:00003E64 6100FDEC        	  6676:                 bsr SHIFTS2_FLAGS
02:00003E68 3010            	  6677:                 move.w (a0),d0
02:00003E6A 0C80000003FC    	  6678:                 cmpi.l #$000003FC,d0
02:00003E70 66FE            	  6679:                 bne.s *
02:00003E72 0C850000000A    	  6680:                 cmpi.l #$0000000A,d5
02:00003E78 66FE            	  6681:                 bne.s *
                            	  6682: 
02:00003E7A 4E75            	  6683:                 rts
                            	  6684: 
                            	  6685: ;-----------------------------------------------------------
                            	  6686: ;-----------------------------------------------------------
                            	  6687: ; OPCODE : BSR / RTS
                            	  6688: ;-----------------------------------------------------------
                            	  6689: ;-----------------------------------------------------------
                            	  6690: 
                            	  6691: ;t3_bsr:
                            	  6692: ;	moveq	#3,d3
                            	  6693: ;	rts
                            	  6694: 
                            	  6695: ;t1_bsr:
                            	  6696: ;	moveq	#1,d1
                            	  6697: ;	rts
                            	  6698: 
                            	  6699: ;op_bsr:
                            	  6700: ;	bsr			t1_bsr
                            	  6701: ;	bsr			t2_bsr
                            	  6702: ;	bsr.w		t3_bsr
                            	  6703: ;	bsr.w		t4_bsr
                            	  6704: ;	cmpi.l	#1,d1
                            	  6705: ;	bne			*
                            	  6706: ;	cmpi.l	#2,d2
                            	  6707: ;	bne			*
                            	  6708: ;	cmpi.l	#3,d3
                            	  6709: ;	bne			*
                            	  6710: ;	cmpi.l	#4,d4
                            	  6711: ;	bne			*
                            	  6712: ;	rts
                            	  6713: 
                            	  6714: ;t2_bsr:
                            	  6715: ;	moveq	#2,d2
                            	  6716: ;	rts
                            	  6717: 	
                            	  6718: ;t4_bsr:
                            	  6719: ;	moveq	#4,d4
                            	  6720: ;	rts
                            	  6721: *    END
                            	  6722:     
                            	  6723: 

Source: "boot.asm"
                            	   758: 	include "TinyBasic.asm"

Source: "TinyBasic.asm"
                            	     1: ******************************************************************
                            	     2: *								 *
                            	     3: *		Tiny BASIC for the Motorola MC68000		 *
                            	     4: *								 *
                            	     5: * Derived from Palo Alto Tiny BASIC as published in the May 1976 *
                            	     6: * issue of Dr. Dobb's Journal.  Adapted to the 68000 by:         *
                            	     7: *	Gordon Brandly						 *
                            	     8: *	12147 - 51 Street					 *
                            	     9: *	Edmonton AB  T5W 3G8					 *
                            	    10: *	Canada							 *
                            	    11: *	(updated mailing address for 1996)			 *
                            	    12: *								 *
                            	    13: * This version is for MEX68KECB Educational Computer Board I/O.  *
                            	    14: *								 *
                            	    15: ******************************************************************
                            	    16: *    Copyright (C) 1984 by Gordon Brandly. This program may be	 *
                            	    17: *    freely distributed for personal use only. All commercial	 *
                            	    18: *		       rights are reserved.			 *
                            	    19: ******************************************************************
                            	    20: 
                            	    21: * Vers. 1.0  1984/7/17	- Original version by Gordon Brandly
                            	    22: *	1.1  1984/12/9	- Addition of '$' print term by Marvin Lipford
                            	    23: *	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                            	    24: 
                            	    25: *	OPT	FRS,BRS 	forward ref.'s & branches default to short
                            	    26: 
                            	    27: ;CR	EQU	$0D		ASCII equates
                            	    28: ;LF	EQU	$0A
                            	    29: ;TAB	EQU	$09
                            	    30: ;CTRLC	EQU	$03
                            	    31: ;CTRLH	EQU	$08
                            	    32: ;CTRLS	EQU	$13
                            	    33: ;CTRLX	EQU	$18
                            	    34: 
                            	    35: BUFLEN	EQU	80		length of keyboard input buffer
                            	    36: 	CODE
                            	    37: *	ORG	$10000		first free address using Tutor
                            	    38: *
                            	    39: * Standard jump table. You can change these addresses if you are
                            	    40: * customizing this interpreter for a different environment.
                            	    41: *
02:00003E7C 601E            	    42: START	BRA	CSTART		Cold Start entry point
02:00003E7E 6060            	    43: GOWARM	BRA	WSTART		Warm Start entry point
02:00003E80 60000C0A        	    44: GOOUT	BRA OUTC		Jump to character-out routine
02:00003E84 60000C22        	    45: GOIN	BRA INC		Jump to character-in routine
02:00003E88 60000C3E        	    46: GOAUXO	BRA	AUXOUT		Jump to auxiliary-out routine
02:00003E8C 60000C4A        	    47: GOAUXI	BRA	AUXIN		Jump to auxiliary-in routine
02:00003E90 60000C66        	    48: GOBYE	BRA	BYEBYE		Jump to monitor, DOS, etc.
                            	    49: *
                            	    50: * Modifiable system constants:
                            	    51: *
02:00003E94 00041000        	    52: TXTBGN	DC.L	$41000		beginning of program memory
02:00003E98 00041FF0        	    53: ENDMEM	DC.L	$41FF0		end of available memory
                            	    54: *
                            	    55: * The main interpreter starts here:
                            	    56: *
02:00003E9C 2E7AFFFA        	    57: CSTART	MOVE.L	ENDMEM,SP	initialize stack pointer
02:00003EA0 23FC00004A980000	    58: 	move.l	#OUTC1,OUTPTR
02:00003EA8 4B4A
02:00003EAA 23FC00004AB40000	    59: 	move.l	#INC1,INPPTR
02:00003EB2 4B46
02:00003EB4 4DFA0C46        	    60: 	LEA	INITMSG,A6	tell who we are
02:00003EB8 61000BC6        	    61: 	BSR	PRMESG
02:00003EBC 23FAFFD600004B6E	    62: 	MOVE.L	TXTBGN,TXTUNF	init. end-of-program pointer
02:00003EC4 203AFFD2        	    63: 	MOVE.L	ENDMEM,D0	get address of end of memory
02:00003EC8 90BC00000800    	    64: 	SUB.L	#2048,D0	reserve 2K for the stack
02:00003ECE 23C000004B76    	    65: 	MOVE.L	D0,STKLMT
02:00003ED4 90BC0000006C    	    66: 	SUB.L	#108,D0 	reserve variable area (27 long words)
02:00003EDA 23C000004B72    	    67: 	MOVE.L	D0,VARBGN
02:00003EE0 7000            	    68: WSTART	CLR.L	D0		initialize internal variables
02:00003EE2 23C000004B5A    	    69: 	MOVE.L	D0,LOPVAR
02:00003EE8 23C000004B52    	    70: 	MOVE.L	D0,STKGOS
02:00003EEE 23C000004B4E    	    71: 	MOVE.L	D0,CURRNT	current line number pointer = 0
02:00003EF4 2E7AFFA2        	    72: 	MOVE.L	ENDMEM,SP	init S.P. again, just in case
02:00003EF8 4DFA0C28        	    73: 	LEA	OKMSG,A6	display "OK"
02:00003EFC 61000B82        	    74: 	bsr	PRMESG
02:00003F00 103C003E        	    75: ST3	MOVE.B	#'>',D0         Prompt with a '>' and
02:00003F04 610008AC        	    76: 	bsr	GETLN		read a line.
02:00003F08 61000B1A        	    77: 	bsr	TOUPBUF 	convert to upper case
02:00003F0C 2848            	    78: 	MOVE.L	A0,A4		save pointer to end of line
02:00003F0E 41FA0C6A        	    79: 	LEA	BUFFER,A0	point to the beginning of line
02:00003F12 61000ACE        	    80: 	bsr	TSTNUM		is there a number there?
02:00003F16 61000B00        	    81: 	bsr	IGNBLK		skip trailing blanks
02:00003F1A 4A41            	    82: 	TST	D1		does line no. exist? (or nonzero?)
02:00003F1C 67000198        	    83: 	BEQ	DIRECT		if not, it's a direct statement
02:00003F20 B2BC0000FFFF    	    84: 	CMP.L	#$FFFF,D1	see if line no. is <= 16 bits
02:00003F26 64000882        	    85: 	BCC	QHOW		if not, we've overflowed
02:00003F2A 1101            	    86: 	MOVE.B	D1,-(A0)	store the binary line no.
02:00003F2C E059            	    87: 	ROR	#8,D1		(Kludge to store a word on a
02:00003F2E 1101            	    88: 	MOVE.B	D1,-(A0)	possible byte boundary)
02:00003F30 E159            	    89: 	ROL	#8,D1
02:00003F32 6100091C        	    90: 	bsr	FNDLN		find this line in save area
02:00003F36 2A49            	    91: 	MOVE.L	A1,A5		save possible line pointer
02:00003F38 6614            	    92: 	BNE	ST4		if not found, insert
02:00003F3A 6100093A        	    93: 	bsr	FNDNXT		find the next line (into A1)
02:00003F3E 244D            	    94: 	MOVE.L	A5,A2		pointer to line to be deleted
02:00003F40 267A0C2C        	    95: 	MOVE.L	TXTUNF,A3	points to top of save area
02:00003F44 61000940        	    96: 	bsr	MVUP		move up to delete
02:00003F48 23CA00004B6E    	    97: 	MOVE.L	A2,TXTUNF	update the end pointer
02:00003F4E 200C            	    98: ST4	MOVE.L	A4,D0		calculate the length of new line
02:00003F50 9088            	    99: 	SUB.L	A0,D0
02:00003F52 B0BC00000003    	   100: 	CMP.L	#3,D0		is it just a line no. & CR?
02:00003F58 67A6            	   101: 	BEQ	ST3		if so, it was just a delete
02:00003F5A 267A0C12        	   102: 	MOVE.L	TXTUNF,A3	compute new end
02:00003F5E 2C4B            	   103: 	MOVE.L	A3,A6
02:00003F60 D7C0            	   104: 	ADD.L	D0,A3
02:00003F62 203A0C0E        	   105: 	MOVE.L	VARBGN,D0	see if there's enough room
02:00003F66 B08B            	   106: 	CMP.L	A3,D0
02:00003F68 63000838        	   107: 	BLS	QSORRY		if not, say so
02:00003F6C 23CB00004B6E    	   108: 	MOVE.L	A3,TXTUNF	if so, store new end position
02:00003F72 224E            	   109: 	MOVE.L	A6,A1		points to old unfilled area
02:00003F74 244D            	   110: 	MOVE.L	A5,A2		points to beginning of move area
02:00003F76 61000918        	   111: 	bsr	MVDOWN		move things out of the way
02:00003F7A 2248            	   112: 	MOVE.L	A0,A1		set up to do the insertion
02:00003F7C 244D            	   113: 	MOVE.L	A5,A2
02:00003F7E 264C            	   114: 	MOVE.L	A4,A3
02:00003F80 61000904        	   115: 	bsr	MVUP		do it
02:00003F84 6000FF7A        	   116: 	BRA	ST3		go back and get another line
                            	   117: 
                            	   118: *
                            	   119: *******************************************************************
                            	   120: *
                            	   121: * *** Tables *** DIRECT *** EXEC ***
                            	   122: *
                            	   123: * This section of the code tests a string against a table. When
                            	   124: * a match is found, control is transferred to the section of
                            	   125: * code according to the table.
                            	   126: *
                            	   127: * At 'EXEC', A0 should point to the string, A1 should point to
                            	   128: * the character table, and A2 should point to the execution
                            	   129: * table. At 'DIRECT', A0 should point to the string, A1 and
                            	   130: * A2 will be set up to point to TAB1 and TAB1_1, which are
                            	   131: * the tables of all direct and statement commands.
                            	   132: *
                            	   133: * A '.' in the string will terminate the test and the partial
                            	   134: * match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                            	   135: * 'PRIN.', or 'PRINT' will all match 'PRINT'.
                            	   136: *
                            	   137: * There are two tables: the character table and the execution
                            	   138: * table. The character table consists of any number of text items.
                            	   139: * Each item is a string of characters with the last character's
                            	   140: * high bit set to one. The execution table holds a 16-bit
                            	   141: * execution addresses that correspond to each entry in the
                            	   142: * character table.
                            	   143: *
                            	   144: * The end of the character table is a 0 byte which corresponds
                            	   145: * to the default routine in the execution table, which is
                            	   146: * executed if none of the other table items are matched.
                            	   147: *
                            	   148: * Character-matching tables:
                            	   149: TAB1
02:00003F88 3C434F          	   150: 	DC.B	'<CO',('M'+$80)
02:00003F8B CD
02:00003F8C 3C434F          	   151: 	DC.B	'<CO',('N'+$80)
02:00003F8F CE
02:00003F90 3E434F          	   152: 	DC.B	'>CO',('M'+$80)
02:00003F93 CD
02:00003F94 3E434F          	   153: 	DC.B	'>CO',('N'+$80)
02:00003F97 CE
02:00003F98 3C3E434F        	   154: 	DC.B	'<>CO',('M'+$80)
02:00003F9C CD
02:00003F9D 3C3E434F        	   155: 	DC.B	'<>CO',('N'+$80)
02:00003FA1 CE
02:00003FA2 4C4953          	   156: 	DC.B	'LIS',('T'+$80)         Direct commands
02:00003FA5 D4
02:00003FA6 4C4F41          	   157: 	DC.B	'LOA',('D'+$80)
02:00003FA9 C4
02:00003FAA 4E45            	   158: 	DC.B	'NE',('W'+$80)
02:00003FAC D7
02:00003FAD 5255            	   159: 	DC.B	'RU',('N'+$80)
02:00003FAF CE
02:00003FB0 534156          	   160: 	DC.B	'SAV',('E'+$80)
02:00003FB3 C5
02:00003FB4 4E4558          	   161: TAB2	DC.B	'NEX',('T'+$80)         Direct / statement
02:00003FB7 D4
02:00003FB8 4C45            	   162: 	DC.B	'LE',('T'+$80)
02:00003FBA D4
02:00003FBB 49              	   163: 	DC.B	'I',('F'+$80)
02:00003FBC C6
02:00003FBD 474F54          	   164: 	DC.B	'GOT',('O'+$80)
02:00003FC0 CF
02:00003FC1 474F5355        	   165: 	DC.B	'GOSU',('B'+$80)
02:00003FC5 C2
02:00003FC6 5245545552      	   166: 	DC.B	'RETUR',('N'+$80)
02:00003FCB CE
02:00003FCC 5245            	   167: 	DC.B	'RE',('M'+$80)
02:00003FCE CD
02:00003FCF 464F            	   168: 	DC.B	'FO',('R'+$80)
02:00003FD1 D2
02:00003FD2 494E5055        	   169: 	DC.B	'INPU',('T'+$80)
02:00003FD6 D4
02:00003FD7 5052494E        	   170: 	DC.B	'PRIN',('T'+$80)
02:00003FDB D4
02:00003FDC 504F4B          	   171: 	DC.B	'POK',('E'+$80)
02:00003FDF C5
02:00003FE0 53544F          	   172: 	DC.B	'STO',('P'+$80)
02:00003FE3 D0
02:00003FE4 4259            	   173: 	DC.B	'BY',('E'+$80)
02:00003FE6 C5
02:00003FE7 43414C          	   174: 	DC.B	'CAL',('L'+$80)
02:00003FEA CC
02:00003FEB 00              	   175: 	DC.B	0
02:00003FEC 504545          	   176: TAB4	DC.B	'PEE',('K'+$80)         Functions
02:00003FEF CB
02:00003FF0 524E            	   177: 	DC.B	'RN',('D'+$80)
02:00003FF2 C4
02:00003FF3 4142            	   178: 	DC.B	'AB',('S'+$80)
02:00003FF5 D3
02:00003FF6 53495A          	   179: 	DC.B	'SIZ',('E'+$80)
02:00003FF9 C5
02:00003FFA 00              	   180: 	DC.B	0
02:00003FFB 54              	   181: TAB5	DC.B	'T',('O'+$80)           "TO" in "FOR"
02:00003FFC CF
02:00003FFD 00              	   182: 	DC.B	0
02:00003FFE 535445          	   183: TAB6	DC.B	'STE',('P'+$80)         "STEP" in "FOR"
02:00004001 D0
02:00004002 00              	   184: 	DC.B	0
02:00004003 3E              	   185: TAB8	DC.B	'>',('='+$80)           Relational operators
02:00004004 BD
02:00004005 3C              	   186: 	DC.B	'<',('>'+$80)
02:00004006 BE
02:00004007 BE              	   187: 	DC.B	('>'+$80)
02:00004008 BD              	   188: 	DC.B	('='+$80)
02:00004009 3C              	   189: 	DC.B	'<',('='+$80)
02:0000400A BD
02:0000400B BC              	   190: 	DC.B	('<'+$80)
02:0000400C 00              	   191: 	DC.B	0
02:0000400D 00              	   192: 	DC.B	0	<- for aligning on a word boundary
                            	   193: 
                            	   194: * Execution address tables:
                            	   195: TAB1_1	
02:0000400E 00004108        	   196: 	DC.L	INCOM
02:00004012 000040FA        	   197: 	DC.L	INCON
02:00004016 00004120        	   198: 	DC.L	OUTCOM
02:0000401A 00004138        	   199: 	DC.L	OUTCON
02:0000401E 00004116        	   200: 	DC.L	IOCOM
02:00004022 0000412E        	   201: 	DC.L	IOCON
02:00004026 000041AC        	   202: 	DC.L	LIST			Direct commands
02:0000402A 00004404        	   203: 	DC.L	LOAD
02:0000402E 00004146        	   204: 	DC.L	NEW
02:00004032 0000415A        	   205: 	DC.L	RUN
02:00004036 00004464        	   206: 	DC.L	SAVE
02:0000403A 00004304        	   207: TAB2_1	DC.L	NEXT			Direct / statement
02:0000403E 000043F4        	   208: 	DC.L	LET
02:00004042 00004358        	   209: 	DC.L	IF
02:00004046 00004198        	   210: 	DC.L	GOTO
02:0000404A 00004244        	   211: 	DC.L	GOSUB
02:0000404E 00004270        	   212: 	DC.L	RETURN
02:00004052 00004356        	   213: 	DC.L	REM
02:00004056 00004292        	   214: 	DC.L	FOR
02:0000405A 00004380        	   215: 	DC.L	INPUT
02:0000405E 000041D8        	   216: 	DC.L	PRINT
02:00004062 000044E2        	   217: 	DC.L	POKE
02:00004066 00004152        	   218: 	DC.L	STOP
02:0000406A 00003E90        	   219: 	DC.L	GOBYE
02:0000406E 000044FA        	   220: 	DC.L	CALL
02:00004072 000043EE        	   221: 	DC.L	DEFLT
02:00004076 000046C2        	   222: TAB4_1	DC.L	PEEK			Functions
02:0000407A 000046CE        	   223: 	DC.L	RND
02:0000407E 00004702        	   224: 	DC.L	ABS
02:00004082 00004712        	   225: 	DC.L	SIZE
02:00004086 000045CA        	   226: 	DC.L	XP40
02:0000408A 000042AC        	   227: TAB5_1	DC.L	FR1			"TO" in "FOR"
02:0000408E 00004762        	   228: 	DC.L	QWHAT
02:00004092 000042C2        	   229: TAB6_1	DC.L	FR2			"STEP" in "FOR"
02:00004096 000042C8        	   230: 	DC.L	FR3
02:0000409A 0000451E        	   231: TAB8_1	DC.L	XP11	>=		Relational operators
02:0000409E 00004524        	   232: 	DC.L	XP12	<>
02:000040A2 0000452A        	   233: 	DC.L	XP13	>
02:000040A6 00004536        	   234: 	DC.L	XP15	=
02:000040AA 00004530        	   235: 	DC.L	XP14	<=
02:000040AE 0000453E        	   236: 	DC.L	XP16	<
02:000040B2 0000454E        	   237: 	DC.L	XP17
                            	   238: *
02:000040B6 43FAFED0        	   239: DIRECT	LEA	TAB1,A1
02:000040BA 45FAFF52        	   240: 	LEA	TAB1_1,A2
02:000040BE 61000958        	   241: EXEC	bsr	IGNBLK		ignore leading blanks
02:000040C2 2648            	   242: 	MOVE.L	A0,A3		save the pointer
02:000040C4 4202            	   243: 	CLR.B	D2		clear match flag
02:000040C6 1018            	   244: EXLP	MOVE.B	(A0)+,D0	get the program character
02:000040C8 1211            	   245: 	MOVE.B	(A1),D1 	get the table character
02:000040CA 6604            	   246: 	BNE	EXNGO		If end of table,
02:000040CC 204B            	   247: 	MOVE.L	A3,A0		restore the text pointer and...
02:000040CE 6024            	   248: 	BRA	EXGO		execute the default.
02:000040D0 1600            	   249: EXNGO	MOVE.B	D0,D3		Else check for period...
02:000040D2 C602            	   250: 	AND.B	D2,D3		and a match.
02:000040D4 B63C002E        	   251: 	CMP.B	#'.',D3
02:000040D8 671A            	   252: 	BEQ	EXGO		if so, execute
02:000040DA C23C007F        	   253: 	AND.B	#$7F,D1 	ignore the table's high bit
02:000040DE B200            	   254: 	CMP.B	D0,D1		is there a match?
02:000040E0 670C            	   255: 	BEQ	EXMAT
02:000040E2 588A            	   256: 	ADDQ.L	#4,A2		if not, try the next entry
02:000040E4 204B            	   257: 	MOVE.L	A3,A0		reset the program pointer
02:000040E6 4202            	   258: 	CLR.B	D2		sorry, no match
02:000040E8 4A19            	   259: EX1	TST.B	(A1)+		get to the end of the entry
02:000040EA 6AFC            	   260: 	BPL	EX1
02:000040EC 60D8            	   261: 	BRA	EXLP		back for more matching
02:000040EE 74FF            	   262: EXMAT	MOVEQ	#-1,D2		we've got a match so far
02:000040F0 4A19            	   263: 	TST.B	(A1)+		end of table entry?
02:000040F2 6AD2            	   264: 	BPL	EXLP		if not, go back for more
02:000040F4 97CB            	   265: EXGO	LEA	0,A3		execute the appropriate routine
02:000040F6 2652            	   266: 	MOVE.L	(A2),A3
02:000040F8 4ED3            	   267: 	JMP	(A3)
                            	   268: *
                            	   269: *******************************************************************
                            	   270: * Console redirection
                            	   271: * <COM will redirect input to the COM port
                            	   272: * >COM will redirect output to the COM port
                            	   273: * <CON will redirect input to the console
                            	   274: * >CON will redirect output to the console
                            	   275: * <>COM will redirect input and output to the COM port
                            	   276: * <>CON will redirect input and output to the console
                            	   277: *******************************************************************
                            	   278: INCON
02:000040FA 23FC00004AB40000	   279: 	move.l	#INC1,INPPTR
02:00004102 4B46
02:00004104 60000136        	   280: 	bra			FINISH
                            	   281: INCOM
02:00004108 23FC00004AD80000	   282: 	move.l	#AUXIN,INPPTR
02:00004110 4B46
02:00004112 60000128        	   283: 	bra			FINISH
                            	   284: IOCOM
02:00004116 23FC00004AD80000	   285: 	move.l	#AUXIN,INPPTR
02:0000411E 4B46
                            	   286: OUTCOM
02:00004120 23FC00004AC80000	   287: 	move.l	#AUXOUT,OUTPTR
02:00004128 4B4A
02:0000412A 60000110        	   288: 	bra			FINISH
                            	   289: IOCON
02:0000412E 23FC00004AB40000	   290: 	move.l	#INC1,INPPTR
02:00004136 4B46
                            	   291: OUTCON
02:00004138 23FC00004A980000	   292: 	move.l	#OUTC1,OUTPTR
02:00004140 4B4A
02:00004142 600000F8        	   293: 	bra			FINISH
                            	   294: 
                            	   295: *******************************************************************
                            	   296: *
                            	   297: * What follows is the code to execute direct and statement
                            	   298: * commands. Control is transferred to these points via the command
                            	   299: * table lookup code of 'DIRECT' and 'EXEC' in the last section.
                            	   300: * After the command is executed, control is transferred to other
                            	   301: * sections as follows:
                            	   302: *
                            	   303: * For 'LIST', 'NEW', and 'STOP': go back to the warm start point.
                            	   304: * For 'RUN': go execute the first stored line if any; else go
                            	   305: * back to the warm start point.
                            	   306: * For 'GOTO' and 'GOSUB': go execute the target line.
                            	   307: * For 'RETURN' and 'NEXT'; go back to saved return line.
                            	   308: * For all others: if 'CURRNT' is 0, go to warm start; else go
                            	   309: * execute next command. (This is done in 'FINISH'.)
                            	   310: *
                            	   311: *******************************************************************
                            	   312: *
                            	   313: * *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                            	   314: *
                            	   315: * 'NEW<CR>' sets TXTUNF to point to TXTBGN
                            	   316: *
                            	   317: * 'STOP<CR>' goes back to WSTART
                            	   318: *
                            	   319: * 'RUN<CR>' finds the first stored line, stores its address
                            	   320: * in CURRNT, and starts executing it. Note that only those
                            	   321: * commands in TAB2 are legal for a stored program.
                            	   322: *
                            	   323: * There are 3 more entries in 'RUN':
                            	   324: * 'RUNNXL' finds next line, stores it's address and executes it.
                            	   325: * 'RUNTSL' stores the address of this line and executes it.
                            	   326: * 'RUNSML' continues the execution on same line.
                            	   327: *
                            	   328: * 'GOTO expr<CR>' evaluates the expression, finds the target
                            	   329: * line, and jumps to 'RUNTSL' to do it.
                            	   330: *
02:00004146 61000608        	   331: NEW	bsr	ENDCHK
02:0000414A 23FAFD4800004B6E	   332: 	MOVE.L	TXTBGN,TXTUNF	set the end pointer
                            	   333: 
02:00004152 610005FC        	   334: STOP	bsr	ENDCHK
02:00004156 6000FD88        	   335: 	BRA	WSTART
                            	   336: 
02:0000415A 610005F4        	   337: RUN	bsr	ENDCHK
02:0000415E 207AFD34        	   338: 	MOVE.L	TXTBGN,A0	set pointer to beginning
02:00004162 23C800004B4E    	   339: 	MOVE.L	A0,CURRNT
                            	   340: 
02:00004168 4AB900004B4E    	   341: RUNNXL	TST.L	CURRNT		executing a program?
02:0000416E 6700FD70        	   342: 	beq	WSTART		if not, we've finished a direct stat.
02:00004172 7200            	   343: 	CLR.L	D1		else find the next line number
02:00004174 2248            	   344: 	MOVE.L	A0,A1
02:00004176 610006E6        	   345: 	bsr	FNDLNP
02:0000417A 6500FD64        	   346: 	BCS	WSTART		if we've fallen off the end, stop
                            	   347: 
02:0000417E 23C900004B4E    	   348: RUNTSL	MOVE.L	A1,CURRNT	set CURRNT to point to the line no.
02:00004184 2049            	   349: 	MOVE.L	A1,A0		set the text pointer to
02:00004186 5488            	   350: 	ADDQ.L	#2,A0		the start of the line text
                            	   351: 
02:00004188 610008E4        	   352: RUNSML	bsr	CHKIO		see if a control-C was pressed
02:0000418C 43FAFE26        	   353: 	LEA	TAB2,A1 	find command in TAB2
02:00004190 45FAFEA8        	   354: 	LEA	TAB2_1,A2
02:00004194 6000FF28        	   355: 	BRA	EXEC		and execute it
                            	   356: 
02:00004198 61000374        	   357: GOTO	bsr	EXPR		evaluate the following expression
02:0000419C 610005B2        	   358: 	bsr	ENDCHK		must find end of line
02:000041A0 2200            	   359: 	MOVE.L	D0,D1
02:000041A2 610006AC        	   360: 	bsr	FNDLN		find the target line
02:000041A6 66000602        	   361: 	bne	QHOW		no such line no.
02:000041AA 60D2            	   362: 	BRA	RUNTSL		go do it
                            	   363: 
                            	   364: *
                            	   365: *******************************************************************
                            	   366: *
                            	   367: * *** LIST *** PRINT ***
                            	   368: *
                            	   369: * LIST has two forms:
                            	   370: * 'LIST<CR>' lists all saved lines
                            	   371: * 'LIST #<CR>' starts listing at the line #
                            	   372: * Control-S pauses the listing, control-C stops it.
                            	   373: *
                            	   374: * PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                            	   375: * where '....' is a list of expressions, formats, back-arrows,
                            	   376: * and strings.	These items a separated by commas.
                            	   377: *
                            	   378: * A format is a pound sign followed by a number.  It controls
                            	   379: * the number of spaces the value of an expression is going to
                            	   380: * be printed in.  It stays effective for the rest of the print
                            	   381: * command unless changed by another format.  If no format is
                            	   382: * specified, 11 positions will be used.
                            	   383: *
                            	   384: * A string is quoted in a pair of single- or double-quotes.
                            	   385: *
                            	   386: * An underline (back-arrow) means generate a <CR> without a <LF>
                            	   387: *
                            	   388: * A <CR LF> is generated after the entire list has been printed
                            	   389: * or if the list is empty.  If the list ends with a semicolon,
                            	   390: * however, no <CR LF> is generated.
                            	   391: *
                            	   392: 
02:000041AC 61000834        	   393: LIST	bsr	TSTNUM		see if there's a line no.
02:000041B0 6100059E        	   394: 	bsr	ENDCHK		if not, we get a zero
02:000041B4 6100069A        	   395: 	bsr	FNDLN		find this or next line
02:000041B8 65000082        	   396: LS1	BCS	FINISH		warm start if we passed the end
02:000041BC 610007F2        	   397: 	bsr	PRTLN		print the line
02:000041C0 610008AC        	   398: 	bsr	CHKIO		check for listing halt request
02:000041C4 670C            	   399: 	BEQ	LS3
02:000041C6 B03C0013        	   400: 	CMP.B	#CTRLS,D0	pause the listing?
02:000041CA 6606            	   401: 	BNE	LS3
02:000041CC 610008A0        	   402: LS2	bsr	CHKIO		if so, wait for another keypress
02:000041D0 67FA            	   403: 	BEQ	LS2
02:000041D2 6100068A        	   404: LS3	bsr	FNDLNP		find the next line
02:000041D6 60E0            	   405: 	BRA	LS1
                            	   406: 
02:000041D8 383C000B        	   407: PRINT	MOVE	#11,D4		D4 = number of print spaces
02:000041DC 610007EC        	   408: 	bsr	TSTC		if null list and ":"
02:000041E0 3A              	   409: 	DC.B	':',PR2-*
02:000041E1 07
02:000041E2 61000D04        	   410: 	bsr	CRLF		give CR-LF and continue
02:000041E6 60A0            	   411: 	BRA	RUNSML		execution on the same line
02:000041E8 610007E0        	   412: PR2	bsr	TSTC		if null list and <CR>
02:000041EC 0D              	   413: 	DC.B	CR,PR0-*
02:000041ED 09
02:000041EE 61000CF8        	   414: 	bsr	CRLF		also give CR-LF and
02:000041F2 6000FF74        	   415: 	BRA	RUNNXL		execute the next line
02:000041F6 610007D2        	   416: PR0	bsr	TSTC		else is it a format?
02:000041FA 23              	   417: 	DC.B	'#',PR1-*
02:000041FB 09
02:000041FC 61000310        	   418: 	bsr	EXPR		yes, evaluate expression
02:00004200 3800            	   419: 	MOVE	D0,D4		and save it as print width
02:00004202 6016            	   420: 	BRA	PR3		look for more to print
02:00004204 610007C4        	   421: PR1	bsr	TSTC		is character expression? (MRL)
02:00004208 24              	   422: 	DC.B	'$',PR4-*
02:00004209 0B
02:0000420A 61000302        	   423: 	bsr	EXPR		yep. Evaluate expression (MRL)
02:0000420E 6100FC70        	   424: 	BSR	GOOUT		print low byte (MRL)
02:00004212 6006            	   425: 	BRA	PR3		look for more. (MRL)
02:00004214 610006E8        	   426: PR4	bsr	QTSTG		is it a string?
02:00004218 6012            	   427: 	BRA.S	PR8		if not, must be an expression
02:0000421A 610007AE        	   428: PR3	bsr	TSTC		if ",", go find next
02:0000421E 2C              	   429: 	DC.B	',',PR6-*
02:0000421F 07
02:00004220 61000514        	   430: 	bsr	FIN		in the list.
02:00004224 60D0            	   431: 	BRA	PR0
02:00004226 61000CC0        	   432: PR6	bsr	CRLF		list ends here
02:0000422A 6010            	   433: 	BRA	FINISH
02:0000422C 3F04            	   434: PR8	MOVE	D4,-(SP)	save the width value
02:0000422E 610002DE        	   435: 	bsr	EXPR		evaluate the expression
02:00004232 381F            	   436: 	MOVE	(SP)+,D4	restore the width
02:00004234 2200            	   437: 	MOVE.L	D0,D1
02:00004236 61000704        	   438: 	bsr	PRTNUM		print its value
02:0000423A 60DE            	   439: 	BRA	PR3		more to print?
                            	   440: 
02:0000423C 610004F8        	   441: FINISH	bsr	FIN		Check end of command
02:00004240 60000520        	   442: 	BRA	QWHAT		print "What?" if wrong
                            	   443: 
                            	   444: *
                            	   445: *******************************************************************
                            	   446: *
                            	   447: * *** GOSUB *** & RETURN ***
                            	   448: *
                            	   449: * 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                            	   450: * except that the current text pointer, stack pointer, etc. are
                            	   451: * saved so that execution can be continued after the subroutine
                            	   452: * 'RETURN's.  In order that 'GOSUB' can be nested (and even
                            	   453: * recursive), the save area must be stacked.  The stack pointer
                            	   454: * is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                            	   455: * If we are in the main routine, 'STKGOS' is zero (this was done
                            	   456: * in the initialization section of the interpreter), but we still
                            	   457: * save it as a flag for no further 'RETURN's.
                            	   458: *
                            	   459: * 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                            	   460: * returns the execution to the command after the most recent
                            	   461: * 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                            	   462: * a 'GOSUB' and is thus an error.
                            	   463: *
02:00004244 61000676        	   464: GOSUB	bsr	PUSHA		save the current 'FOR' parameters
02:00004248 610002C4        	   465: 	bsr	EXPR		get line number
02:0000424C 2F08            	   466: 	MOVE.L	A0,-(SP)	save text pointer
02:0000424E 2200            	   467: 	MOVE.L	D0,D1
02:00004250 610005FE        	   468: 	bsr	FNDLN		find the target line
02:00004254 66000556        	   469: 	BNE	AHOW		if not there, say "How?"
02:00004258 2F3A08F4        	   470: 	MOVE.L	CURRNT,-(SP)	found it, save old 'CURRNT'...
02:0000425C 2F3A08F4        	   471: 	MOVE.L	STKGOS,-(SP)	and 'STKGOS'
02:00004260 42B900004B5A    	   472: 	CLR.L	LOPVAR		load new values
02:00004266 23CF00004B52    	   473: 	MOVE.L	SP,STKGOS
02:0000426C 6000FF10        	   474: 	BRA	RUNTSL
                            	   475: 
02:00004270 610004DE        	   476: RETURN	bsr	ENDCHK		there should be just a <CR>
02:00004274 223A08DC        	   477: 	MOVE.L	STKGOS,D1	get old stack pointer
02:00004278 670004E8        	   478: 	BEQ	QWHAT		if zero, it doesn't exist
02:0000427C 2E41            	   479: 	MOVE.L	D1,SP		else restore it
02:0000427E 23DF00004B52    	   480: 	MOVE.L	(SP)+,STKGOS	and the old 'STKGOS'
02:00004284 23DF00004B4E    	   481: 	MOVE.L	(SP)+,CURRNT	and the old 'CURRNT'
02:0000428A 205F            	   482: 	MOVE.L	(SP)+,A0	and the old text pointer
02:0000428C 6100060A        	   483: 	bsr	POPA		and the old 'FOR' parameters
02:00004290 60AA            	   484: 	BRA	FINISH		and we are back home
                            	   485: 
                            	   486: *
                            	   487: *******************************************************************
                            	   488: *
                            	   489: * *** FOR *** & NEXT ***
                            	   490: *
                            	   491: * 'FOR' has two forms:
                            	   492: * 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                            	   493: * The second form means the same thing as the first form with a
                            	   494: * STEP of positive 1.  The interpreter will find the variable 'var'
                            	   495: * and set its value to the current value of 'exp1'.  It also
                            	   496: * evaluates 'exp2' and 'exp1' and saves all these together with
                            	   497: * the text pointer, etc. in the 'FOR' save area, which consisits of
                            	   498: * 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                            	   499: * already something in the save area (indicated by a non-zero
                            	   500: * 'LOPVAR'), then the old save area is saved on the stack before
                            	   501: * the new values are stored.  The interpreter will then dig in the
                            	   502: * stack and find out if this same variable was used in another
                            	   503: * currently active 'FOR' loop.  If that is the case, then the old
                            	   504: * 'FOR' loop is deactivated. (i.e. purged from the stack)
                            	   505: *
                            	   506: * 'NEXT var' serves as the logical (not necessarily physical) end
                            	   507: * of the 'FOR' loop.  The control variable 'var' is checked with
                            	   508: * the 'LOPVAR'.  If they are not the same, the interpreter digs in
                            	   509: * the stack to find the right one and purges all those that didn't
                            	   510: * match.  Either way, it then adds the 'STEP' to that variable and
                            	   511: * checks the result with against the limit value.  If it is within
                            	   512: * the limit, control loops back to the command following the
                            	   513: * 'FOR'.  If it's outside the limit, the save area is purged and
                            	   514: * execution continues.
                            	   515: *
02:00004292 61000628        	   516: FOR	bsr	PUSHA		save the old 'FOR' save area
02:00004296 61000484        	   517: 	bsr	SETVAL		set the control variable
02:0000429A 23CE00004B5A    	   518: 	MOVE.L	A6,LOPVAR	save its address
02:000042A0 43FAFD59        	   519: 	LEA	TAB5,A1 	use 'EXEC' to test for 'TO'
02:000042A4 45FAFDE4        	   520: 	LEA	TAB5_1,A2
02:000042A8 6000FE14        	   521: 	BRA	EXEC
02:000042AC 61000260        	   522: FR1	bsr	EXPR		evaluate the limit
02:000042B0 23C000004B62    	   523: 	MOVE.L	D0,LOPLMT	save that
02:000042B6 43FAFD46        	   524: 	LEA	TAB6,A1 	use 'EXEC' to look for the
02:000042BA 45FAFDD6        	   525: 	LEA	TAB6_1,A2	word 'STEP'
02:000042BE 6000FDFE        	   526: 	BRA	EXEC
02:000042C2 6100024A        	   527: FR2	bsr	EXPR		found it, get the step value
02:000042C6 6002            	   528: 	BRA	FR4
02:000042C8 7001            	   529: FR3	MOVEQ	#1,D0		not found, step defaults to 1
02:000042CA 23C000004B5E    	   530: FR4	MOVE.L	D0,LOPINC	save that too
02:000042D0 23FA087C00004B66	   531: FR5	MOVE.L	CURRNT,LOPLN	save address of current line number
02:000042D8 23C800004B6A    	   532: 	MOVE.L	A0,LOPPT	and text pointer
02:000042DE 2C4F            	   533: 	MOVE.L	SP,A6		dig into the stack to find 'LOPVAR'
02:000042E0 6004            	   534: 	BRA	FR7
02:000042E2 4DEE0014        	   535: FR6	ADD.L	#20,A6		look at next stack frame
02:000042E6 2016            	   536: FR7	MOVE.L	(A6),D0 	is it zero?
02:000042E8 6716            	   537: 	BEQ	FR8		if so, we're done
02:000042EA B0BA086E        	   538: 	CMP.L	LOPVAR,D0	same as current LOPVAR?
02:000042EE 66F2            	   539: 	BNE	FR6		nope, look some more
02:000042F0 244F            	   540: 	MOVE.L	SP,A2		Else remove 5 long words from...
02:000042F2 224E            	   541: 	MOVE.L	A6,A1		inside the stack.
02:000042F4 47F80014        	   542: 	LEA	20,A3
02:000042F8 D7C9            	   543: 	ADD.L	A1,A3
02:000042FA 61000594        	   544: 	bsr	MVDOWN
02:000042FE 2E4B            	   545: 	MOVE.L	A3,SP		set the SP 5 long words up
02:00004300 6000FF3A        	   546: FR8	BRA	FINISH		and continue execution
                            	   547: 
02:00004304 610002F0        	   548: NEXT	bsr	TSTV		get address of variable
02:00004308 65000458        	   549: 	BCS	QWHAT		if no variable, say "What?"
02:0000430C 2240            	   550: 	MOVE.L	D0,A1		save variable's address
02:0000430E 203A084A        	   551: NX0	MOVE.L	LOPVAR,D0	If 'LOPVAR' is zero, we never...
02:00004312 6700044E        	   552: 	BEQ	QWHAT		had a FOR loop, so say "What?"
02:00004316 B3C0            	   553: 	CMP.L	D0,A1		else we check them
02:00004318 6706            	   554: 	BEQ	NX3		OK, they agree
02:0000431A 6100057C        	   555: 	bsr	POPA		nope, let's see the next frame
02:0000431E 60EE            	   556: 	BRA	NX0
02:00004320 2011            	   557: NX3	MOVE.L	(A1),D0 	get control variable's value
02:00004322 D0BA083A        	   558: 	ADD.L	LOPINC,D0	add in loop increment
02:00004326 69000482        	   559: 	BVS	QHOW		say "How?" for 32-bit overflow
02:0000432A 2280            	   560: 	MOVE.L	D0,(A1) 	save control variable's new value
02:0000432C 223A0834        	   561: 	MOVE.L	LOPLMT,D1	get loop's limit value
02:00004330 4AB900004B5E    	   562: 	TST.L	LOPINC
02:00004336 6A02            	   563: 	BPL	NX1		branch if loop increment is positive
02:00004338 C141            	   564: 	EXG	D0,D1
02:0000433A B280            	   565: NX1	CMP.L	D0,D1		test against limit
02:0000433C 6D10            	   566: 	BLT	NX2		branch if outside limit
02:0000433E 23FA082600004B4E	   567: 	MOVE.L	LOPLN,CURRNT	Within limit, go back to the...
02:00004346 207A0822        	   568: 	MOVE.L	LOPPT,A0	saved 'CURRNT' and text pointer.
02:0000434A 6000FEF0        	   569: 	BRA	FINISH
02:0000434E 61000548        	   570: NX2	bsr	POPA		purge this loop
02:00004352 6000FEE8        	   571: 	BRA	FINISH
                            	   572: 
                            	   573: *
                            	   574: *******************************************************************
                            	   575: *
                            	   576: * *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                            	   577: *
                            	   578: * 'REM' can be followed by anything and is ignored by the
                            	   579: * interpreter.
                            	   580: *
                            	   581: * 'IF' is followed by an expression, as a condition and one or
                            	   582: * more commands (including other 'IF's) separated by colons.
                            	   583: * Note that the word 'THEN' is not used.  The interpreter evaluates
                            	   584: * the expression.  If it is non-zero, execution continues.  If it
                            	   585: * is zero, the commands that follow are ignored and execution
                            	   586: * continues on the next line.
                            	   587: *
                            	   588: * 'INPUT' is like the 'PRINT' command, and is followed by a list
                            	   589: * of items.  If the item is a string in single or double quotes,
                            	   590: * or is an underline (back arrow), it has the same effect as in
                            	   591: * 'PRINT'.  If an item is a variable, this variable name is
                            	   592: * printed out followed by a colon, then the interpreter waits for
                            	   593: * an expression to be typed in.  The variable is then set to the
                            	   594: * value of this expression.  If the variable is preceeded by a
                            	   595: * string (again in single or double quotes), the string will be
                            	   596: * displayed followed by a colon.  The interpreter the waits for an
                            	   597: * expression to be entered and sets the variable equal to the
                            	   598: * expression's value.  If the input expression is invalid, the
                            	   599: * interpreter will print "What?", "How?", or "Sorry" and reprint
                            	   600: * the prompt and redo the input.  The execution will not terminate
                            	   601: * unless you press control-C.  This is handled in 'INPERR'.
                            	   602: *
                            	   603: * 'LET' is followed by a list of items separated by commas.
                            	   604: * Each item consists of a variable, an equals sign, and an
                            	   605: * expression.  The interpreter evaluates the expression and sets
                            	   606: * the variable to that value.  The interpreter will also handle
                            	   607: * 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                            	   608: *
02:00004356 600A            	   609: REM	BRA	IF2		skip the rest of the line
                            	   610: 
02:00004358 610001B4        	   611: IF	bsr	EXPR		evaluate the expression
02:0000435C 4A80            	   612: IF1	TST.L	D0		is it zero?
02:0000435E 6600FE28        	   613: 	BNE	RUNSML		if not, continue
02:00004362 2248            	   614: IF2	MOVE.L	A0,A1
02:00004364 7200            	   615: 	CLR.L	D1
02:00004366 61000510        	   616: 	bsr	FNDSKP		if so, skip the rest of the line
02:0000436A 6400FE12        	   617: 	BCC	RUNTSL		and run the next line
02:0000436E 6000FB70        	   618: 	BRA	WSTART		if no next line, do a warm start
                            	   619: 
02:00004372 2E7A07E2        	   620: INPERR	MOVE.L	STKINP,SP	restore the old stack pointer
02:00004376 23DF00004B4E    	   621: 	MOVE.L	(SP)+,CURRNT	and old 'CURRNT'
02:0000437C 588F            	   622: 	ADDQ.L	#4,SP
02:0000437E 205F            	   623: 	MOVE.L	(SP)+,A0	and old text pointer
                            	   624: 
02:00004380 2F08            	   625: INPUT	MOVE.L	A0,-(SP)	save in case of error
02:00004382 6100057A        	   626: 	bsr	QTSTG		is next item a string?
02:00004386 600A            	   627: 	BRA.S	IP2		nope
02:00004388 6100026C        	   628: 	bsr	TSTV		yes, but is it followed by a variable?
02:0000438C 6552            	   629: 	BCS	IP4		if not, branch
02:0000438E 2440            	   630: 	MOVE.L	D0,A2		put away the variable's address
02:00004390 601A            	   631: 	BRA	IP3		if so, input to variable
02:00004392 2F08            	   632: IP2	MOVE.L	A0,-(SP)	save for 'PRTSTG'
02:00004394 61000260        	   633: 	bsr	TSTV		must be a variable now
02:00004398 650003C8        	   634: 	BCS	QWHAT		"What?" it isn't?
02:0000439C 2440            	   635: 	MOVE.L	D0,A2		put away the variable's address
02:0000439E 1410            	   636: 	MOVE.B	(A0),D2 	get ready for 'PRTSTG'
02:000043A0 4200            	   637: 	CLR.B	D0
02:000043A2 1080            	   638: 	MOVE.B	D0,(A0)
02:000043A4 225F            	   639: 	MOVE.L	(SP)+,A1
02:000043A6 6100053A        	   640: 	bsr	PRTSTG		print string as prompt
02:000043AA 1082            	   641: 	MOVE.B	D2,(A0) 	restore text
02:000043AC 2F08            	   642: IP3	MOVE.L	A0,-(SP)	save in case of error
02:000043AE 2F3A079E        	   643: 	MOVE.L	CURRNT,-(SP)	also save 'CURRNT'
02:000043B2 23FCFFFFFFFF0000	   644: 	MOVE.L	#-1,CURRNT	flag that we are in INPUT
02:000043BA 4B4E
02:000043BC 23CF00004B56    	   645: 	MOVE.L	SP,STKINP	save the stack pointer too
02:000043C2 2F0A            	   646: 	MOVE.L	A2,-(SP)	save the variable address
02:000043C4 103C003A        	   647: 	MOVE.B	#':',D0         print a colon first
02:000043C8 610003E8        	   648: 	bsr	GETLN		then get an input line
02:000043CC 41FA07AC        	   649: 	LEA	BUFFER,A0	point to the buffer
02:000043D0 6100013C        	   650: 	bsr	EXPR		evaluate the input
02:000043D4 245F            	   651: 	MOVE.L	(SP)+,A2	restore the variable address
02:000043D6 2480            	   652: 	MOVE.L	D0,(A2) 	save value in variable
02:000043D8 23DF00004B4E    	   653: 	MOVE.L	(SP)+,CURRNT	restore old 'CURRNT'
02:000043DE 205F            	   654: 	MOVE.L	(SP)+,A0	and the old text pointer
02:000043E0 588F            	   655: IP4	ADDQ.L	#4,SP		clean up the stack
02:000043E2 610005E6        	   656: 	bsr	TSTC		is the next thing a comma?
02:000043E6 2C              	   657: 	DC.B	',',IP5-*
02:000043E7 03
02:000043E8 6096            	   658: 	BRA	INPUT		yes, more items
02:000043EA 6000FE50        	   659: IP5	BRA	FINISH
                            	   660: 
02:000043EE 0C10000D        	   661: DEFLT	CMP.B	#CR,(A0)	empty line is OK
02:000043F2 670C            	   662: 	BEQ	LT1		else it is 'LET'
                            	   663: 
02:000043F4 61000326        	   664: LET	bsr	SETVAL		do the assignment
02:000043F8 610005D0        	   665: 	bsr	TSTC		check for more 'LET' items
02:000043FC 2C              	   666: 	DC.B	',',LT1-*
02:000043FD 03
02:000043FE 60F4            	   667: 	BRA	LET
02:00004400 6000FE3A        	   668: LT1	BRA	FINISH		until we are finished.
                            	   669: 
                            	   670: *
                            	   671: *******************************************************************
                            	   672: *
                            	   673: * *** LOAD *** & SAVE ***
                            	   674: *
                            	   675: * These two commands transfer a program to/from an auxiliary
                            	   676: * device such as a cassette, another computer, etc.  The program
                            	   677: * is converted to an easily-stored format: each line starts with
                            	   678: * a colon, the line no. as 4 hex digits, and the rest of the line.
                            	   679: * At the end, a line starting with an '@' sign is sent.  This
                            	   680: * format can be read back with a minimum of processing time by
                            	   681: * the 68000.
                            	   682: *
02:00004404 207AFA8E        	   683: LOAD	MOVE.L	TXTBGN,A0	set pointer to start of prog. area
02:00004408 103C000D        	   684: 	MOVE.B	#CR,D0		For a CP/M host, tell it we're ready...
02:0000440C 6100FA7A        	   685: 	BSR	GOAUXO		by sending a CR to finish PIP command.
                            	   686: LOD1	
02:00004410 6100FA7A        	   687: 	BSR	GOAUXI		look for start of line
02:00004414 67FA            	   688: 	BEQ	LOD1
02:00004416 B03C0040        	   689: 	CMP.B	#'@',D0         end of program?
02:0000441A 671E            	   690: 	BEQ	LODEND
02:0000441C B03C003A        	   691: 	CMP.B	#':',D0         if not, is it start of line?
02:00004420 66EE            	   692: 	BNE	LOD1		if not, wait for it
02:00004422 6120            	   693: 	BSR	GBYTE		get first byte of line no.
02:00004424 10C1            	   694: 	MOVE.B	D1,(A0)+	store it
02:00004426 611C            	   695: 	BSR	GBYTE		get 2nd bye of line no.
02:00004428 10C1            	   696: 	MOVE.B	D1,(A0)+	store that, too
                            	   697: LOD2
02:0000442A 6100FA60        	   698: 	BSR	GOAUXI		get another text char.
02:0000442E 67FA            	   699: 	BEQ	LOD2
02:00004430 10C0            	   700: 	MOVE.B	D0,(A0)+	store it
02:00004432 B03C000D        	   701: 	CMP.B	#CR,D0		is it the end of the line?
02:00004436 66F2            	   702: 	BNE	LOD2		if not, go back for more
02:00004438 60D6            	   703: 	BRA	LOD1		if so, start a new line
                            	   704: LODEND
02:0000443A 23C800004B6E    	   705: 	MOVE.L	A0,TXTUNF	set end-of program pointer
02:00004440 6000FA9E        	   706: 	BRA	WSTART		back to direct mode
                            	   707: 
                            	   708: GBYTE
02:00004444 7401            	   709: 	MOVEQ	#1,D2		get two hex characters from auxiliary
02:00004446 7200            	   710: 	CLR.L	D1		and store them as a byte in D1
                            	   711: GBYTE1	
02:00004448 6100FA42        	   712: 	BSR	GOAUXI		get a char.
02:0000444C 67FA            	   713: 	BEQ	GBYTE1
02:0000444E B03C0041        	   714: 	CMP.B	#'A',D0
02:00004452 6502            	   715: 	BCS	GBYTE2
02:00004454 5F00            	   716: 	SUBQ.B	#7,D0		if greater than 9, adjust
                            	   717: GBYTE2
02:00004456 C03C000F        	   718: 	AND.B	#$F,D0		strip ASCII
02:0000445A E909            	   719: 	LSL.B	#4,D1		put nybble into the result
02:0000445C 8200            	   720: 	OR.B	D0,D1
02:0000445E 51CAFFE8        	   721: 	DBRA	D2,GBYTE1	get another char.
02:00004462 4E75            	   722: 	RTS
                            	   723: 
                            	   724: SAVE
02:00004464 207AFA2E        	   725: 	MOVE.L	TXTBGN,A0	set pointer to start of prog. area
02:00004468 227A0704        	   726: 	MOVE.L	TXTUNF,A1	set pointer to end of prog. area
                            	   727: SAVE1	
02:0000446C 103C000D        	   728: 	MOVE.B	#CR,D0		send out a CR & LF (CP/M likes this)
02:00004470 6100FA16        	   729: 	BSR	GOAUXO
02:00004474 103C000A        	   730: 	MOVE.B	#LF,D0
02:00004478 6100FA0E        	   731: 	BSR	GOAUXO
02:0000447C B3C8            	   732: 	CMP.L	A0,A1		are we finished?
02:0000447E 631E            	   733: 	BLS	SAVEND
02:00004480 103C003A        	   734: 	MOVE.B	#':',D0         if not, start a line
02:00004484 6100FA02        	   735: 	BSR	GOAUXO
02:00004488 1218            	   736: 	MOVE.B	(A0)+,D1	send first half of line no.
02:0000448A 6136            	   737: 	BSR	PBYTE
02:0000448C 1218            	   738: 	MOVE.B	(A0)+,D1	and send 2nd half
02:0000448E 6132            	   739: 	BSR	PBYTE
                            	   740: SAVE2
02:00004490 1018            	   741: 	MOVE.B	(A0)+,D0	get a text char.
02:00004492 B03C000D        	   742: 	CMP.B	#CR,D0		is it the end of the line?
02:00004496 67D4            	   743: 	BEQ	SAVE1		if so, send CR & LF and start new line
02:00004498 6100F9EE        	   744: 	BSR	GOAUXO		send it out
02:0000449C 60F2            	   745: 	BRA	SAVE2		go back for more text
                            	   746: SAVEND
02:0000449E 103C0040        	   747: 	MOVE.B	#'@',D0         send end-of-program indicator
02:000044A2 6100F9E4        	   748: 	BSR	GOAUXO
02:000044A6 103C000D        	   749: 	MOVE.B	#CR,D0		followed by a CR & LF
02:000044AA 6100F9DC        	   750: 	BSR	GOAUXO
02:000044AE 103C000A        	   751: 	MOVE.B	#LF,D0
02:000044B2 6100F9D4        	   752: 	BSR	GOAUXO
02:000044B6 103C001A        	   753: 	MOVE.B	#$1A,D0 	and a control-Z to end the CP/M file
02:000044BA 6100F9CC        	   754: 	BSR	GOAUXO
02:000044BE 6000FA20        	   755: 	BRA	WSTART		then go do a warm start
                            	   756: 
02:000044C2 7401            	   757: PBYTE	MOVEQ	#1,D2		send two hex characters from D1's low byte
02:000044C4 E919            	   758: PBYTE1	ROL.B	#4,D1		get the next nybble
02:000044C6 1001            	   759: 	MOVE.B	D1,D0
02:000044C8 C03C000F        	   760: 	AND.B	#$F,D0		strip off garbage
02:000044CC D03C0030        	   761: 	ADD.B	#'0',D0         make it into ASCII
02:000044D0 B03C0039        	   762: 	CMP.B	#'9',D0
02:000044D4 6302            	   763: 	BLS	PBYTE2
02:000044D6 5E00            	   764: 	ADDQ.B	#7,D0		adjust if greater than 9
02:000044D8 6100F9AE        	   765: PBYTE2	BSR	GOAUXO		send it out
02:000044DC 51CAFFE6        	   766: 	DBRA	D2,PBYTE1	then send the next nybble
02:000044E0 4E75            	   767: 	RTS
                            	   768: 
                            	   769: *
                            	   770: *******************************************************************
                            	   771: *
                            	   772: * *** POKE *** & CALL ***
                            	   773: *
                            	   774: * 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                            	   775: * address specified by 'expr1'.
                            	   776: *
                            	   777: * 'CALL expr' jumps to the machine language subroutine whose
                            	   778: * starting address is specified by 'expr'.  The subroutine can use
                            	   779: * all registers but must leave the stack the way it found it.
                            	   780: * The subroutine returns to the interpreter by executing an RTS.
                            	   781: *
02:000044E2 612A            	   782: POKE	BSR	EXPR		get the memory address
02:000044E4 610004E4        	   783: 	bsr	TSTC		it must be followed by a comma
02:000044E8 2C              	   784: 	DC.B	',',PKER-*
02:000044E9 0D
02:000044EA 2F00            	   785: 	MOVE.L	D0,-(SP)	save the address
02:000044EC 6120            	   786: 	BSR	EXPR		get the byte to be POKE'd
02:000044EE 225F            	   787: 	MOVE.L	(SP)+,A1	get the address back
02:000044F0 1280            	   788: 	MOVE.B	D0,(A1) 	store the byte in memory
02:000044F2 6000FD48        	   789: 	BRA	FINISH
02:000044F6 6000026A        	   790: PKER	BRA	QWHAT		if no comma, say "What?"
                            	   791: 
02:000044FA 6112            	   792: CALL	BSR	EXPR		get the subroutine's address
02:000044FC 4A80            	   793: 	TST.L	D0		make sure we got a valid address
02:000044FE 670002AA        	   794: 	BEQ	QHOW		if not, say "How?"
02:00004502 2F08            	   795: 	MOVE.L	A0,-(SP)	save the text pointer
02:00004504 2240            	   796: 	MOVE.L	D0,A1
02:00004506 4E91            	   797: 	JSR	(A1)		jump to the subroutine
02:00004508 205F            	   798: 	MOVE.L	(SP)+,A0	restore the text pointer
02:0000450A 6000FD30        	   799: 	BRA	FINISH
                            	   800: *
                            	   801: *******************************************************************
                            	   802: *
                            	   803: * *** EXPR ***
                            	   804: *
                            	   805: * 'EXPR' evaluates arithmetical or logical expressions.
                            	   806: * <EXPR>::=<EXPR2>
                            	   807: *	   <EXPR2><rel.op.><EXPR2>
                            	   808: * where <rel.op.> is one of the operators in TAB8 and the result
                            	   809: * of these operations is 1 if true and 0 if false.
                            	   810: * <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                            	   811: * where () are optional and (... are optional repeats.
                            	   812: * <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                            	   813: * <EXPR4>::=<variable>
                            	   814: *	    <function>
                            	   815: *	    (<EXPR>)
                            	   816: * <EXPR> is recursive so that the variable '@' can have an <EXPR>
                            	   817: * as an index, functions can have an <EXPR> as arguments, and
                            	   818: * <EXPR4> can be an <EXPR> in parenthesis.
                            	   819: *
02:0000450E 6152            	   820: EXPR	BSR	EXPR2
02:00004510 2F00            	   821: 	MOVE.L	D0,-(SP)	save <EXPR2> value
02:00004512 43FAFAEF        	   822: 	LEA	TAB8,A1 	look up a relational operator
02:00004516 45FAFB82        	   823: 	LEA	TAB8_1,A2
02:0000451A 6000FBA2        	   824: 	BRA	EXEC		go do it
                            	   825: 
02:0000451E 6132            	   826: XP11	BSR	XP18		is it ">="?
02:00004520 6D24            	   827: 	BLT	XPRT0		no, return D0=0
02:00004522 6026            	   828: 	BRA	XPRT1		else return D0=1
                            	   829: 
02:00004524 612C            	   830: XP12	BSR	XP18		is it "<>"?
02:00004526 671E            	   831: 	BEQ	XPRT0		no, return D0=0
02:00004528 6020            	   832: 	BRA	XPRT1		else return D0=1
                            	   833: 
02:0000452A 6126            	   834: XP13	BSR	XP18		is it ">"?
02:0000452C 6F18            	   835: 	BLE	XPRT0		no, return D0=0
02:0000452E 601A            	   836: 	BRA	XPRT1		else return D0=1
                            	   837: 
02:00004530 6120            	   838: XP14	BSR	XP18		is it "<="?
02:00004532 6E12            	   839: 	BGT	XPRT0		no, return D0=0
02:00004534 6014            	   840: 	BRA	XPRT1		else return D0=1
                            	   841: 
02:00004536 611A            	   842: XP15	BSR	XP18		is it "="?
02:00004538 660C            	   843: 	BNE	XPRT0		if not, return D0=0
02:0000453A 600E            	   844: 	BRA	XPRT1		else return D0=1
02:0000453C 4E75            	   845: XP15RT	RTS
                            	   846: 
02:0000453E 6112            	   847: XP16	BSR	XP18		is it "<"?
02:00004540 6C04            	   848: 	BGE	XPRT0		if not, return D0=0
02:00004542 6006            	   849: 	BRA	XPRT1		else return D0=1
02:00004544 4E75            	   850: XP16RT	RTS
                            	   851: 
02:00004546 7000            	   852: XPRT0	CLR.L	D0		return D0=0 (false)
02:00004548 4E75            	   853: 	RTS
                            	   854: 
02:0000454A 7001            	   855: XPRT1	MOVEQ	#1,D0		return D0=1 (true)
02:0000454C 4E75            	   856: 	RTS
                            	   857: 
02:0000454E 201F            	   858: XP17	MOVE.L	(SP)+,D0	it's not a rel. operator
02:00004550 4E75            	   859: 	RTS			return D0=<EXPR2>
                            	   860: 
02:00004552 201F            	   861: XP18	MOVE.L	(SP)+,D0	reverse the top two stack items
02:00004554 221F            	   862: 	MOVE.L	(SP)+,D1
02:00004556 2F00            	   863: 	MOVE.L	D0,-(SP)
02:00004558 2F01            	   864: 	MOVE.L	D1,-(SP)
02:0000455A 6106            	   865: 	BSR	EXPR2		do second <EXPR2>
02:0000455C 221F            	   866: 	MOVE.L	(SP)+,D1
02:0000455E B280            	   867: 	CMP.L	D0,D1		compare with the first result
02:00004560 4E75            	   868: 	RTS			return the result
                            	   869: 
02:00004562 61000466        	   870: EXPR2	bsr	TSTC		negative sign?
02:00004566 2D              	   871: 	DC.B	'-',XP21-*
02:00004567 05
02:00004568 7000            	   872: 	CLR.L	D0		yes, fake '0-'
02:0000456A 6022            	   873: 	BRA	XP26
02:0000456C 6100045C        	   874: XP21	bsr	TSTC		positive sign? ignore it
02:00004570 2B              	   875: 	DC.B	'+',XP22-*
02:00004571 01
02:00004572 6122            	   876: XP22	BSR	EXPR3		first <EXPR3>
02:00004574 61000454        	   877: XP23	bsr	TSTC		add?
02:00004578 2B              	   878: 	DC.B	'+',XP25-*
02:00004579 0F
02:0000457A 2F00            	   879: 	MOVE.L	D0,-(SP)	yes, save the value
02:0000457C 6118            	   880: 	BSR	EXPR3		get the second <EXPR3>
02:0000457E 221F            	   881: XP24	MOVE.L	(SP)+,D1
02:00004580 D081            	   882: 	ADD.L	D1,D0		add it to the first <EXPR3>
02:00004582 69000226        	   883: 	BVS	QHOW		branch if there's an overflow
02:00004586 60EC            	   884: 	BRA	XP23		else go back for more operations
02:00004588 61000440        	   885: XP25	bsr	TSTC		subtract?
02:0000458C 2D              	   886: 	DC.B	'-',XP42-*
02:0000458D 63
02:0000458E 2F00            	   887: XP26	MOVE.L	D0,-(SP)	yes, save the result of 1st <EXPR3>
02:00004590 6104            	   888: 	BSR	EXPR3		get second <EXPR3>
02:00004592 4480            	   889: 	NEG.L	D0		change its sign
02:00004594 60E8            	   890: 	JMP	XP24		and do an addition
                            	   891: 
02:00004596 6126            	   892: EXPR3	BSR	EXPR4		get first <EXPR4>
02:00004598 61000430        	   893: XP31	bsr	TSTC		multiply?
02:0000459C 2A              	   894: 	DC.B	'*',XP34-*
02:0000459D 0D
02:0000459E 2F00            	   895: 	MOVE.L	D0,-(SP)	yes, save that first result
02:000045A0 611C            	   896: 	BSR	EXPR4		get second <EXPR4>
02:000045A2 221F            	   897: 	MOVE.L	(SP)+,D1
02:000045A4 6100009E        	   898: 	bsr	MULT32		multiply the two
02:000045A8 60EE            	   899: 	BRA	XP31		then look for more terms
02:000045AA 6100041E        	   900: XP34	bsr	TSTC		divide?
02:000045AE 2F              	   901: 	DC.B	'/',XP42-*
02:000045AF 41
02:000045B0 2F00            	   902: 	MOVE.L	D0,-(SP)	save result of 1st <EXPR4>
02:000045B2 610A            	   903: 	BSR	EXPR4		get second <EXPR4>
02:000045B4 221F            	   904: 	MOVE.L	(SP)+,D1
02:000045B6 C141            	   905: 	EXG	D0,D1
02:000045B8 610000CC        	   906: 	bsr	DIV32		do the division
02:000045BC 60DA            	   907: 	BRA	XP31		go back for any more terms
                            	   908: 
02:000045BE 43FAFA2C        	   909: EXPR4	LEA	TAB4,A1 	find possible function
02:000045C2 45FAFAB2        	   910: 	LEA	TAB4_1,A2
02:000045C6 6000FAF6        	   911: 	BRA	EXEC
02:000045CA 612A            	   912: XP40	BSR	TSTV		nope, not a function
02:000045CC 6508            	   913: 	BCS	XP41		nor a variable
02:000045CE 2240            	   914: 	MOVE.L	D0,A1
02:000045D0 7000            	   915: 	CLR.L	D0
02:000045D2 2011            	   916: 	MOVE.L	(A1),D0 	if a variable, return its value in D0
02:000045D4 4E75            	   917: EXP4RT	RTS
02:000045D6 6100040A        	   918: XP41	bsr	TSTNUM		or is it a number?
02:000045DA 2001            	   919: 	MOVE.L	D1,D0
02:000045DC 4A42            	   920: 	TST	D2		(if not, # of digits will be zero)
02:000045DE 66F4            	   921: 	BNE	EXP4RT		if so, return it in D0
02:000045E0 610003E8        	   922: PARN	bsr	TSTC		else look for ( EXPR )
02:000045E4 28              	   923: 	DC.B	'(',XP43-*
02:000045E5 0D
02:000045E6 6100FF26        	   924: 	BSR	EXPR
02:000045EA 610003DE        	   925: 	bsr	TSTC
02:000045EE 29              	   926: 	DC.B	')',XP43-*
02:000045EF 03
02:000045F0 4E75            	   927: XP42	RTS
02:000045F2 6000016E        	   928: XP43	BRA	QWHAT		else say "What?"
                            	   929: 
                            	   930: *
                            	   931: * ===== Test for a valid variable name.  Returns Carry=1 if not
                            	   932: *	found, else returns Carry=0 and the address of the
                            	   933: *	variable in D0.
                            	   934: 
02:000045F6 61000420        	   935: TSTV	bsr	IGNBLK
02:000045FA 7000            	   936: 	CLR.L	D0
02:000045FC 1010            	   937: 	MOVE.B	(A0),D0 	look at the program text
02:000045FE 903C0040        	   938: 	SUB.B	#'@',D0
02:00004602 653E            	   939: 	BCS	TSTVRT		C=1: not a variable
02:00004604 6626            	   940: 	BNE	TV1		branch if not "@" array
02:00004606 5248            	   941: 	ADDQ	#1,A0		If it is, it should be
02:00004608 61D6            	   942: 	BSR	PARN		followed by (EXPR) as its index.
02:0000460A D080            	   943: 	ADD.L	D0,D0
02:0000460C 6500019C        	   944: 	BCS	QHOW		say "How?" if index is too big
02:00004610 D080            	   945: 	ADD.L	D0,D0
02:00004612 65000196        	   946: 	BCS	QHOW
02:00004616 2F00            	   947: 	MOVE.L	D0,-(SP)	save the index
02:00004618 610000F8        	   948: 	bsr	SIZE		get amount of free memory
02:0000461C 221F            	   949: 	MOVE.L	(SP)+,D1	get back the index
02:0000461E B081            	   950: 	CMP.L	D1,D0		see if there's enough memory
02:00004620 63000180        	   951: 	BLS	QSORRY		if not, say "Sorry"
02:00004624 203A054C        	   952: 	MOVE.L	VARBGN,D0	put address of array element...
02:00004628 9081            	   953: 	SUB.L	D1,D0		into D0
02:0000462A 4E75            	   954: 	RTS
02:0000462C B03C001B        	   955: TV1	CMP.B	#27,D0		if not @, is it A through Z?
02:00004630 0A3C0001        	   956: 	EOR	#1,CCR
02:00004634 650C            	   957: 	BCS	TSTVRT		if not, set Carry and return
02:00004636 5248            	   958: 	ADDQ	#1,A0		else bump the text pointer
02:00004638 D040            	   959: 	ADD	D0,D0		compute the variable's address
02:0000463A D040            	   960: 	ADD	D0,D0
02:0000463C 223A0534        	   961: 	MOVE.L	VARBGN,D1
02:00004640 D041            	   962: 	ADD	D1,D0		and return it in D0 with Carry=0
02:00004642 4E75            	   963: TSTVRT	RTS
                            	   964: 
                            	   965: *
                            	   966: * ===== Multiplies the 32 bit values in D0 and D1, returning
                            	   967: *	the 32 bit result in D0.
                            	   968: *
02:00004644 2801            	   969: MULT32	MOVE.L	D1,D4
02:00004646 B184            	   970: 	EOR.L	D0,D4		see if the signs are the same
02:00004648 4A80            	   971: 	TST.L	D0		take absolute value of D0
02:0000464A 6A02            	   972: 	BPL	MLT1
02:0000464C 4480            	   973: 	NEG.L	D0
02:0000464E 4A81            	   974: MLT1	TST.L	D1		take absolute value of D1
02:00004650 6A02            	   975: 	BPL	MLT2
02:00004652 4481            	   976: 	NEG.L	D1
02:00004654 B2BC0000FFFF    	   977: MLT2	CMP.L	#$FFFF,D1	is second argument <= 16 bits?
02:0000465A 630C            	   978: 	BLS	MLT3		OK, let it through
02:0000465C C141            	   979: 	EXG	D0,D1		else swap the two arguments
02:0000465E B2BC0000FFFF    	   980: 	CMP.L	#$FFFF,D1	and check 2nd argument again
02:00004664 62000144        	   981: 	BHI	QHOW		one of them MUST be 16 bits
02:00004668 3400            	   982: MLT3	MOVE	D0,D2		prepare for 32 bit X 16 bit multiply
02:0000466A C4C1            	   983: 	MULU	D1,D2		multiply low word
02:0000466C 4840            	   984: 	SWAP	D0
02:0000466E C0C1            	   985: 	MULU	D1,D0		multiply high word
02:00004670 4840            	   986: 	SWAP	D0
                            	   987: *** Rick Murray's bug correction follows:
02:00004672 4A40            	   988: 	TST	D0		if lower word not 0, then overflow
02:00004674 66000134        	   989: 	BNE	QHOW		if overflow, say "How?"
02:00004678 D082            	   990: 	ADD.L	D2,D0		D0 now holds the product
02:0000467A 6B00012E        	   991: 	BMI	QHOW		if sign bit set, it's an overflow
02:0000467E 4A84            	   992: 	TST.L	D4		were the signs the same?
02:00004680 6A02            	   993: 	BPL	MLTRET
02:00004682 4480            	   994: 	NEG.L	D0		if not, make the result negative
02:00004684 4E75            	   995: MLTRET	RTS
                            	   996: 
                            	   997: *
                            	   998: * ===== Divide the 32 bit value in D0 by the 32 bit value in D1.
                            	   999: *	Returns the 32 bit quotient in D0, remainder in D1.
                            	  1000: *
02:00004686 4A81            	  1001: DIV32	TST.L	D1		check for divide-by-zero
02:00004688 67000120        	  1002: 	BEQ	QHOW		if so, say "How?"
02:0000468C 2401            	  1003: 	MOVE.L	D1,D2
02:0000468E 2801            	  1004: 	MOVE.L	D1,D4
02:00004690 B184            	  1005: 	EOR.L	D0,D4		see if the signs are the same
02:00004692 4A80            	  1006: 	TST.L	D0		take absolute value of D0
02:00004694 6A02            	  1007: 	BPL	DIV1
02:00004696 4480            	  1008: 	NEG.L	D0
02:00004698 4A81            	  1009: DIV1	TST.L	D1		take absolute value of D1
02:0000469A 6A02            	  1010: 	BPL	DIV2
02:0000469C 4481            	  1011: 	NEG.L	D1
02:0000469E 761F            	  1012: DIV2	MOVEQ	#31,D3		iteration count for 32 bits
02:000046A0 2200            	  1013: 	MOVE.L	D0,D1
02:000046A2 7000            	  1014: 	CLR.L	D0
02:000046A4 D281            	  1015: DIV3	ADD.L	D1,D1		(This algorithm was translated from
02:000046A6 D180            	  1016: 	ADDX.L	D0,D0		the divide routine in Ron Cain's
02:000046A8 6708            	  1017: 	BEQ	DIV4		Small-C run time library.)
02:000046AA B082            	  1018: 	CMP.L	D2,D0
02:000046AC 6B04            	  1019: 	BMI	DIV4
02:000046AE 5281            	  1020: 	ADDQ.L	#1,D1
02:000046B0 9082            	  1021: 	SUB.L	D2,D0
02:000046B2 51CBFFF0        	  1022: DIV4	DBRA	D3,DIV3
02:000046B6 C141            	  1023: 	EXG	D0,D1		put rem. & quot. in proper registers
02:000046B8 4A84            	  1024: 	TST.L	D4		were the signs the same?
02:000046BA 6A04            	  1025: 	BPL	DIVRT
02:000046BC 4480            	  1026: 	NEG.L	D0		if not, results are negative
02:000046BE 4481            	  1027: 	NEG.L	D1
02:000046C0 4E75            	  1028: DIVRT	RTS
                            	  1029: 
                            	  1030: *
                            	  1031: * ===== The PEEK function returns the byte stored at the address
                            	  1032: *	contained in the following expression.
                            	  1033: *
02:000046C2 6100FF1C        	  1034: PEEK	BSR	PARN		get the memory address
02:000046C6 2240            	  1035: 	MOVE.L	D0,A1
02:000046C8 7000            	  1036: 	CLR.L	D0		upper 3 bytes will be zero
02:000046CA 1011            	  1037: 	MOVE.B	(A1),D0 	get the addressed byte
02:000046CC 4E75            	  1038: 	RTS			and return it
                            	  1039: 
                            	  1040: *
                            	  1041: * ===== The RND function returns a random number from 1 to
                            	  1042: *	the value of the following expression in D0.
                            	  1043: *
02:000046CE 6100FF10        	  1044: RND	BSR	PARN		get the upper limit
02:000046D2 4A80            	  1045: 	TST.L	D0		it must be positive and non-zero
02:000046D4 670000D4        	  1046: 	BEQ	QHOW
02:000046D8 6B0000D0        	  1047: 	BMI	QHOW
02:000046DC 2200            	  1048: 	MOVE.L	D0,D1
02:000046DE 227A0462        	  1049: 	MOVE.L	RANPNT,A1	get memory as a random number
02:000046E2 B3FC00004B42    	  1050: 	CMP.L	#LSTROM,A1
02:000046E8 6504            	  1051: 	BCS	RA1
02:000046EA 43FAF790        	  1052: 	LEA	START,A1	wrap around if end of program
02:000046EE 2019            	  1053: RA1	MOVE.L	(A1)+,D0	get the slightly random number
02:000046F0 0880001F        	  1054: 	BCLR	#31,D0		make sure it's positive
02:000046F4 23C900004B42    	  1055: 	MOVE.L	A1,RANPNT	(even I can do better than this!)
02:000046FA 618A            	  1056: 	BSR	DIV32		RND(n)=MOD(number,n)+1
02:000046FC 2001            	  1057: 	MOVE.L	D1,D0		MOD is the remainder of the div.
02:000046FE 5280            	  1058: 	ADDQ.L	#1,D0
02:00004700 4E75            	  1059: 	RTS
                            	  1060: 
                            	  1061: *
                            	  1062: * ===== The ABS function returns an absolute value in D0.
                            	  1063: *
02:00004702 6100FEDC        	  1064: ABS	BSR	PARN		get the following expr.'s value
02:00004706 4A80            	  1065: 	TST.L	D0
02:00004708 6A06            	  1066: 	BPL	ABSRT
02:0000470A 4480            	  1067: 	NEG.L	D0		if negative, complement it
02:0000470C 6B00009C        	  1068: 	BMI	QHOW		if still negative, it was too big
02:00004710 4E75            	  1069: ABSRT	RTS
                            	  1070: 
                            	  1071: *
                            	  1072: * ===== The SIZE function returns the size of free memory in D0.
                            	  1073: *
02:00004712 203A045E        	  1074: SIZE	MOVE.L	VARBGN,D0	get the number of free bytes...
02:00004716 90BA0456        	  1075: 	SUB.L	TXTUNF,D0	between 'TXTUNF' and 'VARBGN'
02:0000471A 4E75            	  1076: 	RTS			return the number in D0
                            	  1077: 
                            	  1078: *
                            	  1079: *******************************************************************
                            	  1080: *
                            	  1081: * *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                            	  1082: *
                            	  1083: * 'SETVAL' expects a variable, followed by an equal sign and then
                            	  1084: * an expression.  It evaluates the expression and sets the variable
                            	  1085: * to that value.
                            	  1086: *
                            	  1087: * 'FIN' checks the end of a command.  If it ended with ":",
                            	  1088: * execution continues.	If it ended with a CR, it finds the
                            	  1089: * the next line and continues from there.
                            	  1090: *
                            	  1091: * 'ENDCHK' checks if a command is ended with a CR. This is
                            	  1092: * required in certain commands, such as GOTO, RETURN, STOP, etc.
                            	  1093: *
                            	  1094: * 'ERROR' prints the string pointed to by A0. It then prints the
                            	  1095: * line pointed to by CURRNT with a "?" inserted at where the
                            	  1096: * old text pointer (should be on top of the stack) points to.
                            	  1097: * Execution of Tiny BASIC is stopped and a warm start is done.
                            	  1098: * If CURRNT is zero (indicating a direct command), the direct
                            	  1099: * command is not printed. If CURRNT is -1 (indicating
                            	  1100: * 'INPUT' command in progress), the input line is not printed
                            	  1101: * and execution is not terminated but continues at 'INPERR'.
                            	  1102: *
                            	  1103: * Related to 'ERROR' are the following:
                            	  1104: * 'QWHAT' saves text pointer on stack and gets "What?" message.
                            	  1105: * 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                            	  1106: * 'QSORRY' and 'ASORRY' do the same kind of thing.
                            	  1107: * 'QHOW' and 'AHOW' also do this for "How?".
                            	  1108: *
02:0000471C 6100FED8        	  1109: SETVAL	BSR	TSTV		variable name?
02:00004720 6540            	  1110: 	BCS	QWHAT		if not, say "What?"
02:00004722 2F00            	  1111: 	MOVE.L	D0,-(SP)	save the variable's address
02:00004724 610002A4        	  1112: 	bsr	TSTC		get past the "=" sign
02:00004728 3D              	  1113: 	DC.B	'=',SV1-*
02:00004729 0B
02:0000472A 6100FDE2        	  1114: 	BSR	EXPR		evaluate the expression
02:0000472E 2C5F            	  1115: 	MOVE.L	(SP)+,A6
02:00004730 2C80            	  1116: 	MOVE.L	D0,(A6) 	and save its value in the variable
02:00004732 4E75            	  1117: 	RTS
02:00004734 602C            	  1118: SV1	BRA	QWHAT		if no "=" sign
                            	  1119: 
02:00004736 61000292        	  1120: FIN	bsr	TSTC		*** FIN ***
02:0000473A 3A              	  1121: 	DC.B	':',FI1-*
02:0000473B 07
02:0000473C 588F            	  1122: 	ADDQ.L	#4,SP		if ":", discard return address
02:0000473E 6000FA48        	  1123: 	BRA	RUNSML		continue on the same line
02:00004742 61000286        	  1124: FI1	bsr	TSTC		not ":", is it a CR?
02:00004746 0D              	  1125: 	DC.B	CR,FI2-*
02:00004747 07
02:00004748 588F            	  1126: 	ADDQ.L	#4,SP		yes, purge return address
02:0000474A 6000FA1C        	  1127: 	BRA	RUNNXL		execute the next line
02:0000474E 4E75            	  1128: FI2	RTS			else return to the caller
                            	  1129: 
02:00004750 610002C6        	  1130: ENDCHK	bsr	IGNBLK
02:00004754 0C10003A        	  1131: 	CMP.B #':',(a0)
02:00004758 6706            	  1132: 	BEQ ENDCHK1
02:0000475A 0C10000D        	  1133: 	CMP.B	#CR,(A0)	does it end with a CR?
02:0000475E 6602            	  1134: 	BNE	QWHAT		if not, say "WHAT?"
                            	  1135: ENDCHK1:
02:00004760 4E75            	  1136: 	RTS
                            	  1137: 
02:00004762 2F08            	  1138: QWHAT	MOVE.L	A0,-(SP)
02:00004764 4DFA03CA        	  1139: AWHAT	LEA	WHTMSG,A6
02:00004768 61000316        	  1140: ERROR	bsr	PRMESG		display the error message
02:0000476C 205F            	  1141: 	MOVE.L	(SP)+,A0	restore the text pointer
02:0000476E 203A03DE        	  1142: 	MOVE.L	CURRNT,D0	get the current line number
02:00004772 6700F76C        	  1143: 	BEQ	WSTART		if zero, do a warm start
02:00004776 B0BCFFFFFFFF    	  1144: 	CMP.L	#-1,D0		is the line no. pointer = -1?
02:0000477C 6700FBF4        	  1145: 	BEQ	INPERR		if so, redo input
02:00004780 1F10            	  1146: 	MOVE.B	(A0),-(SP)	save the char. pointed to
02:00004782 4210            	  1147: 	CLR.B	(A0)		put a zero where the error is
02:00004784 227A03C8        	  1148: 	MOVE.L	CURRNT,A1	point to start of current line
02:00004788 61000226        	  1149: 	bsr	PRTLN		display the line in error up to the 0
02:0000478C 109F            	  1150: 	MOVE.B	(SP)+,(A0)	restore the character
02:0000478E 103C003F        	  1151: 	MOVE.B	#'?',D0         display a "?"
02:00004792 6100F6EC        	  1152: 	BSR	GOOUT
02:00004796 4240            	  1153: 	CLR	D0
02:00004798 5389            	  1154: 	SUBQ.L	#1,A1		point back to the error char.
02:0000479A 61000146        	  1155: 	bsr	PRTSTG		display the rest of the line
02:0000479E 6000F740        	  1156: 	BRA	WSTART		and do a warm start
02:000047A2 2F08            	  1157: QSORRY	MOVE.L	A0,-(SP)
02:000047A4 4DFA0392        	  1158: ASORRY	LEA	SRYMSG,A6
02:000047A8 60BE            	  1159: 	BRA	ERROR
02:000047AA 2F08            	  1160: QHOW	MOVE.L	A0,-(SP)	Error: "How?"
02:000047AC 4DFA037B        	  1161: AHOW	LEA	HOWMSG,A6
02:000047B0 60B6            	  1162: 	BRA	ERROR
                            	  1163: *
                            	  1164: *******************************************************************
                            	  1165: *
                            	  1166: * *** GETLN *** FNDLN (& friends) ***
                            	  1167: *
                            	  1168: * 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                            	  1169: * the character in D0 (given by the caller), then it fills the
                            	  1170: * buffer and echos. It ignores LF's but still echos
                            	  1171: * them back. Control-H is used to delete the last character
                            	  1172: * entered (if there is one), and control-X is used to delete the
                            	  1173: * whole line and start over again. CR signals the end of a line,
                            	  1174: * and causes 'GETLN' to return.
                            	  1175: *
                            	  1176: * 'FNDLN' finds a line with a given line no. (in D1) in the
                            	  1177: * text save area.  A1 is used as the text pointer. If the line
                            	  1178: * is found, A1 will point to the beginning of that line
                            	  1179: * (i.e. the high byte of the line no.), and flags are NC & Z.
                            	  1180: * If that line is not there and a line with a higher line no.
                            	  1181: * is found, A1 points there and flags are NC & NZ. If we reached
                            	  1182: * the end of the text save area and cannot find the line, flags
                            	  1183: * are C & NZ.
                            	  1184: * 'FNDLN' will initialize A1 to the beginning of the text save
                            	  1185: * area to start the search. Some other entries of this routine
                            	  1186: * will not initialize A1 and do the search.
                            	  1187: * 'FNDLNP' will start with A1 and search for the line no.
                            	  1188: * 'FNDNXT' will bump A1 by 2, find a CR and then start search.
                            	  1189: * 'FNDSKP' uses A1 to find a CR, and then starts the search.
                            	  1190: *
02:000047B2 6100F6CC        	  1191: GETLN	BSR	GOOUT		display the prompt
02:000047B6 103C0020        	  1192: 	MOVE.B	#' ',D0         and a space
02:000047BA 6100F6C4        	  1193: 	BSR	GOOUT
02:000047BE 41FA03BA        	  1194: 	LEA	BUFFER,A0	A0 is the buffer pointer
02:000047C2 610002AA        	  1195: GL1	bsr	CHKIO		check keyboard
02:000047C6 67FA            	  1196: 	BEQ	GL1		wait for a char. to come in
02:000047C8 B03C0008        	  1197: 	CMP.B	#CTRLH,D0	delete last character?
02:000047CC 6726            	  1198: 	BEQ	GL3		if so
02:000047CE B03C0018        	  1199: 	CMP.B	#CTRLX,D0	delete the whole line?
02:000047D2 6744            	  1200: 	BEQ	GL4		if so
02:000047D4 B03C000D        	  1201: 	CMP.B	#CR,D0		accept a CR
02:000047D8 6706            	  1202: 	BEQ	GL2
02:000047DA B03C0020        	  1203: 	CMP.B	#' ',D0         if other control char., discard it
02:000047DE 65E2            	  1204: 	BCS	GL1
02:000047E0 10C0            	  1205: GL2	MOVE.B	D0,(A0)+	save the char.
02:000047E2 6100F69C        	  1206: 	BSR	GOOUT		echo the char back out
02:000047E6 B03C000D        	  1207: 	CMP.B	#CR,D0		if it's a CR, end the line
02:000047EA 675C            	  1208: 	BEQ	GL7
02:000047EC B1FC00004BC9    	  1209: 	CMP.L	#(BUFFER+BUFLEN-1),A0	any more room?
02:000047F2 65CE            	  1210: 	BCS	GL1		yes: get some more, else delete last char.
02:000047F4 103C0008        	  1211: GL3	MOVE.B	#CTRLH,D0	delete a char. if possible
02:000047F8 6100F686        	  1212: 	BSR	GOOUT
02:000047FC 103C0020        	  1213: 	MOVE.B	#' ',D0
02:00004800 6100F67E        	  1214: 	BSR	GOOUT
02:00004804 B1FC00004B7A    	  1215: 	CMP.L	#BUFFER,A0	any char.'s left?
02:0000480A 63B6            	  1216: 	BLS	GL1		if not
02:0000480C 103C0008        	  1217: 	MOVE.B	#CTRLH,D0	if so, finish the BS-space-BS sequence
02:00004810 6100F66E        	  1218: 	BSR	GOOUT
02:00004814 5388            	  1219: 	SUBQ.L	#1,A0		decrement the text pointer
02:00004816 60AA            	  1220: 	BRA	GL1		back for more
02:00004818 2208            	  1221: GL4	MOVE.L	A0,D1		delete the whole line
02:0000481A 92BC00004B7A    	  1222: 	SUB.L	#BUFFER,D1	figure out how many backspaces we need
02:00004820 671E            	  1223: 	BEQ	GL6		if none needed, branch
02:00004822 5341            	  1224: 	SUBQ	#1,D1		adjust for DBRA
02:00004824 103C0008        	  1225: GL5	MOVE.B	#CTRLH,D0	and display BS-space-BS sequences
02:00004828 6100F656        	  1226: 	BSR	GOOUT
02:0000482C 103C0020        	  1227: 	MOVE.B	#' ',D0
02:00004830 6100F64E        	  1228: 	BSR	GOOUT
02:00004834 103C0008        	  1229: 	MOVE.B	#CTRLH,D0
02:00004838 6100F646        	  1230: 	BSR	GOOUT
02:0000483C 51C9FFE6        	  1231: 	DBRA	D1,GL5
02:00004840 41FA0338        	  1232: GL6	LEA	BUFFER,A0	reinitialize the text pointer
02:00004844 6000FF7C        	  1233: 	BRA	GL1		and go back for more
02:00004848 103C000A        	  1234: GL7	MOVE.B	#LF,D0		echo a LF for the CR
02:0000484C 6000F632        	  1235: 	BRA	GOOUT
                            	  1236: 
02:00004850 B2BC0000FFFF    	  1237: FNDLN	CMP.L	#$FFFF,D1	line no. must be < 65535
02:00004856 6400FF52        	  1238: 	BCC	QHOW
02:0000485A 227AF638        	  1239: 	MOVE.L	TXTBGN,A1	init. the text save pointer
                            	  1240: 
02:0000485E 247A030E        	  1241: FNDLNP	MOVE.L	TXTUNF,A2	check if we passed the end
02:00004862 538A            	  1242: 	SUBQ.L	#1,A2
02:00004864 B5C9            	  1243: 	CMP.L	A1,A2
02:00004866 650C            	  1244: 	BCS	FNDRET		if so, return with Z=0 & C=1
02:00004868 1411            	  1245: 	MOVE.B	(A1),D2	if not, get a line no.
02:0000486A E14A            	  1246: 	LSL	#8,D2
02:0000486C 14290001        	  1247: 	MOVE.B	1(A1),D2
02:00004870 B441            	  1248: 	CMP.W	D1,D2		is this the line we want?
02:00004872 6502            	  1249: 	BCS	FNDNXT		no, not there yet
02:00004874 4E75            	  1250: FNDRET	RTS			return the cond. codes
                            	  1251: 
02:00004876 5489            	  1252: FNDNXT	ADDQ.L	#2,A1		find the next line
                            	  1253: 
                            	  1254: FNDSKP	
02:00004878 0C19000D        	  1255: 	CMP.B	#CR,(A1)+	try to find a CR
02:0000487C 67E0            	  1256: 	BEQ		FNDLNP
02:0000487E B3FA02EE        	  1257: 	CMP.L	TXTUNF,A1
02:00004882 65F4            	  1258: 	BLO		FNDSKP
02:00004884 60D8            	  1259: 	BRA		FNDLNP		check if end of text
                            	  1260: 
                            	  1261: *
                            	  1262: *******************************************************************
                            	  1263: *
                            	  1264: * *** MVUP *** MVDOWN *** POPA *** PUSHA ***
                            	  1265: *
                            	  1266: * 'MVUP' moves a block up from where A1 points to where A2 points
                            	  1267: * until A1=A3
                            	  1268: *
                            	  1269: * 'MVDOWN' moves a block down from where A1 points to where A3
                            	  1270: * points until A1=A2
                            	  1271: *
                            	  1272: * 'POPA' restores the 'FOR' loop variable save area from the stack
                            	  1273: *
                            	  1274: * 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                            	  1275: *
02:00004886 B7C9            	  1276: MVUP	CMP.L	A1,A3		see the above description
02:00004888 6704            	  1277: 	BEQ	MVRET
02:0000488A 14D9            	  1278: 	MOVE.B	(A1)+,(A2)+
02:0000488C 60F8            	  1279: 	BRA	MVUP
02:0000488E 4E75            	  1280: MVRET	RTS
                            	  1281: 
02:00004890 B5C9            	  1282: MVDOWN	CMP.L	A1,A2		see the above description
02:00004892 67FA            	  1283: 	BEQ	MVRET
02:00004894 1721            	  1284: 	MOVE.B	-(A1),-(A3)
02:00004896 60F8            	  1285: 	BRA	MVDOWN
                            	  1286: 
02:00004898 2C5F            	  1287: POPA	MOVE.L	(SP)+,A6	A6 = return address
02:0000489A 23DF00004B5A    	  1288: 	MOVE.L	(SP)+,LOPVAR	restore LOPVAR, but zero means no more
02:000048A0 6718            	  1289: 	BEQ	PP1
02:000048A2 23DF00004B5E    	  1290: 	MOVE.L	(SP)+,LOPINC	if not zero, restore the rest
02:000048A8 23DF00004B62    	  1291: 	MOVE.L	(SP)+,LOPLMT
02:000048AE 23DF00004B66    	  1292: 	MOVE.L	(SP)+,LOPLN
02:000048B4 23DF00004B6A    	  1293: 	MOVE.L	(SP)+,LOPPT
02:000048BA 4ED6            	  1294: PP1	JMP	(A6)		return
                            	  1295: 
02:000048BC 223A02B8        	  1296: PUSHA	MOVE.L	STKLMT,D1	Are we running out of stack room?
02:000048C0 928F            	  1297: 	SUB.L	SP,D1
02:000048C2 6400FEDE        	  1298: 	BCC	QSORRY		if so, say we're sorry
02:000048C6 2C5F            	  1299: 	MOVE.L	(SP)+,A6	else get the return address
02:000048C8 223A0290        	  1300: 	MOVE.L	LOPVAR,D1	save loop variables
02:000048CC 6710            	  1301: 	BEQ	PU1		if LOPVAR is zero, that's all
02:000048CE 2F3A029A        	  1302: 	MOVE.L	LOPPT,-(SP)	else save all the others
02:000048D2 2F3A0292        	  1303: 	MOVE.L	LOPLN,-(SP)
02:000048D6 2F3A028A        	  1304: 	MOVE.L	LOPLMT,-(SP)
02:000048DA 2F3A0282        	  1305: 	MOVE.L	LOPINC,-(SP)
02:000048DE 2F01            	  1306: PU1	MOVE.L	D1,-(SP)
02:000048E0 4ED6            	  1307: 	JMP	(A6)		return
                            	  1308: 
                            	  1309: *
                            	  1310: *******************************************************************
                            	  1311: *
                            	  1312: * *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                            	  1313: *
                            	  1314: * 'PRTSTG' prints a string pointed to by A1. It stops printing
                            	  1315: * and returns to the caller when either a CR is printed or when
                            	  1316: * the next byte is the same as what was passed in D0 by the
                            	  1317: * caller.
                            	  1318: *
                            	  1319: * 'QTSTG' looks for an underline (back-arrow on some systems),
                            	  1320: * single-quote, or double-quote.  If none of these are found, returns
                            	  1321: * to the caller.  If underline, outputs a CR without a LF.  If single
                            	  1322: * or double quote, prints the quoted string and demands a matching
                            	  1323: * end quote.  After the printing, the next 2 bytes of the caller are
                            	  1324: * skipped over (usually a short branch instruction).
                            	  1325: *
                            	  1326: * 'PRTNUM' prints the 32 bit number in D1, leading blanks are added if
                            	  1327: * needed to pad the number of spaces to the number in D4.
                            	  1328: * However, if the number of digits is larger than the no. in
                            	  1329: * D4, all digits are printed anyway. Negative sign is also
                            	  1330: * printed and counted in, positive sign is not.
                            	  1331: *
                            	  1332: * 'PRTLN' prints the saved text line pointed to by A1
                            	  1333: * with line no. and all.
                            	  1334: *
02:000048E2 1200            	  1335: PRTSTG	MOVE.B	D0,D1		save the stop character
02:000048E4 1019            	  1336: PS1	MOVE.B	(A1)+,D0	get a text character
02:000048E6 B200            	  1337: 	CMP.B	D0,D1		same as stop character?
02:000048E8 6712            	  1338: 	BEQ	PRTRET		if so, return
02:000048EA 6100F594        	  1339: 	BSR	GOOUT		display the char.
02:000048EE B03C000D        	  1340: 	CMP.B	#CR,D0		is it a C.R.?
02:000048F2 66F0            	  1341: 	BNE	PS1		no, go back for more
02:000048F4 103C000A        	  1342: 	MOVE.B	#LF,D0		yes, add a L.F.
02:000048F8 6100F586        	  1343: 	BSR	GOOUT
02:000048FC 4E75            	  1344: PRTRET	RTS			then return
                            	  1345: 
02:000048FE 610000CA        	  1346: QTSTG	bsr	TSTC		*** QTSTG ***
02:00004902 22              	  1347: 	DC.B	'"',QT3-*
02:00004903 19
02:00004904 103C0022        	  1348: 	MOVE.B	#'"',D0         it is a "
02:00004908 2248            	  1349: QT1	MOVE.L	A0,A1
02:0000490A 61D6            	  1350: 	BSR	PRTSTG		print until another
02:0000490C 2049            	  1351: 	MOVE.L	A1,A0
02:0000490E 225F            	  1352: 	MOVE.L	(SP)+,A1	pop return address
02:00004910 B03C000A        	  1353: 	CMP.B	#LF,D0		was last one a CR?
02:00004914 6700F852        	  1354: 	BEQ	RUNNXL		if so, run next line
02:00004918 5489            	  1355: QT2	ADDQ.L	#2,A1		skip 2 bytes on return
02:0000491A 4ED1            	  1356: 	JMP	(A1)		return
02:0000491C 610000AC        	  1357: QT3	bsr	TSTC		is it a single quote?
02:00004920 27              	  1358: 	DC.B	'''',QT4-*
02:00004921 07
02:00004922 103C0027        	  1359: 	MOVE.B	#'''',D0        if so, do same as above
02:00004926 60E0            	  1360: 	BRA	QT1
02:00004928 610000A0        	  1361: QT4	bsr	TSTC		is it an underline?
02:0000492C 5F              	  1362: 	DC.B	'_',QT5-*
02:0000492D 0D
02:0000492E 103C000D        	  1363: 	MOVE.B	#CR,D0		if so, output a CR without LF
02:00004932 6100F54C        	  1364: 	bsr	GOOUT
02:00004936 225F            	  1365: 	MOVE.L	(SP)+,A1	pop return address
02:00004938 60DE            	  1366: 	BRA	QT2
02:0000493A 4E75            	  1367: QT5	RTS			none of the above
                            	  1368: 
02:0000493C 2601            	  1369: PRTNUM	MOVE.L	D1,D3		save the number for later
02:0000493E 3F04            	  1370: 	MOVE	D4,-(SP)	save the width value
02:00004940 1F3C00FF        	  1371: 	MOVE.B	#$FF,-(SP)	flag for end of digit string
02:00004944 4A81            	  1372: 	TST.L	D1		is it negative?
02:00004946 6A04            	  1373: 	BPL	PN1		if not
02:00004948 4481            	  1374: 	NEG.L	D1		else make it positive
02:0000494A 5344            	  1375: 	SUBQ	#1,D4		one less for width count
02:0000494C 82FC000A        	  1376: PN1	DIVU	#10,D1		get the next digit
02:00004950 690A            	  1377: 	BVS	PNOV		overflow flag set?
02:00004952 2001            	  1378: 	MOVE.L	D1,D0		if not, save remainder
02:00004954 C2BC0000FFFF    	  1379: 	AND.L	#$FFFF,D1	strip the remainder
02:0000495A 601A            	  1380: 	BRA	TOASCII 	skip the overflow stuff
02:0000495C 3001            	  1381: PNOV	MOVE	D1,D0		prepare for long word division
02:0000495E 4241            	  1382: 	CLR.W	D1		zero out low word
02:00004960 4841            	  1383: 	SWAP	D1		high word into low
02:00004962 82FC000A        	  1384: 	DIVU	#10,D1		divide high word
02:00004966 3401            	  1385: 	MOVE	D1,D2		save quotient
02:00004968 3200            	  1386: 	MOVE	D0,D1		low word into low
02:0000496A 82FC000A        	  1387: 	DIVU	#10,D1		divide low word
02:0000496E 2001            	  1388: 	MOVE.L	D1,D0		D0 = remainder
02:00004970 4841            	  1389: 	SWAP	D1		R/Q becomes Q/R
02:00004972 3202            	  1390: 	MOVE	D2,D1		D1 is low/high
02:00004974 4841            	  1391: 	SWAP	D1		D1 is finally high/low
02:00004976 4840            	  1392: TOASCII SWAP	D0		get remainder
02:00004978 1F00            	  1393: 	MOVE.B	D0,-(SP)	stack it as a digit
02:0000497A 4840            	  1394: 	SWAP	D0
02:0000497C 5344            	  1395: 	SUBQ	#1,D4		decrement width count
02:0000497E 4A81            	  1396: 	TST.L	D1		if quotient is zero, we're done
02:00004980 66CA            	  1397: 	BNE	PN1
02:00004982 5344            	  1398: 	SUBQ	#1,D4		adjust padding count for DBRA
02:00004984 6B0C            	  1399: 	BMI	PN4		skip padding if not needed
02:00004986 103C0020        	  1400: PN3	MOVE.B	#' ',D0         display the required leading spaces
02:0000498A 6100F4F4        	  1401: 	BSR	GOOUT
02:0000498E 51CCFFF6        	  1402: 	DBRA	D4,PN3
02:00004992 4A83            	  1403: PN4	TST.L	D3		is number negative?
02:00004994 6A08            	  1404: 	BPL	PN5
02:00004996 103C002D        	  1405: 	MOVE.B	#'-',D0         if so, display the sign
02:0000499A 6100F4E4        	  1406: 	BSR	GOOUT
02:0000499E 101F            	  1407: PN5	MOVE.B	(SP)+,D0	now unstack the digits and display
02:000049A0 6B0A            	  1408: 	BMI	PNRET		until the flag code is reached
02:000049A2 D03C0030        	  1409: 	ADD.B	#'0',D0         make into ASCII
02:000049A6 6100F4D8        	  1410: 	BSR	GOOUT
02:000049AA 60F2            	  1411: 	BRA	PN5
02:000049AC 381F            	  1412: PNRET	MOVE	(SP)+,D4	restore width value
02:000049AE 4E75            	  1413: 	RTS
                            	  1414: 
02:000049B0 7200            	  1415: PRTLN	CLR.L	D1
02:000049B2 1219            	  1416: 	MOVE.B	(A1)+,D1	get the binary line number
02:000049B4 E149            	  1417: 	LSL	#8,D1
02:000049B6 1219            	  1418: 	MOVE.B	(A1)+,D1
02:000049B8 7805            	  1419: 	MOVEQ	#5,D4		display a 5 digit line no.
02:000049BA 6180            	  1420: 	BSR	PRTNUM
02:000049BC 103C0020        	  1421: 	MOVE.B	#' ',D0         followed by a blank
02:000049C0 6100F4BE        	  1422: 	BSR	GOOUT
02:000049C4 4240            	  1423: 	CLR	D0		stop char. is a zero
02:000049C6 6000FF1A        	  1424: 	BRA	PRTSTG		display the rest of the line
                            	  1425: 
                            	  1426: *
                            	  1427: * ===== Test text byte following the call to this subroutine. If it
                            	  1428: *	equals the byte pointed to by A0, return to the code following
                            	  1429: *	the call. If they are not equal, branch to the point
                            	  1430: *	indicated by the offset byte following the text byte.
                            	  1431: *
02:000049CA 614C            	  1432: TSTC	BSR	IGNBLK		ignore leading blanks
02:000049CC 225F            	  1433: 	MOVE.L	(SP)+,A1	get the return address
02:000049CE 1219            	  1434: 	MOVE.B	(A1)+,D1	get the byte to compare
02:000049D0 B210            	  1435: 	CMP.B	(A0),D1 	is it = to what A0 points to?
02:000049D2 6708            	  1436: 	BEQ	TC1		if so
02:000049D4 7200            	  1437: 	CLR.L	D1		If not, add the second
02:000049D6 1211            	  1438: 	MOVE.B	(A1),D1 	byte following the call to
02:000049D8 D3C1            	  1439: 	ADD.L	D1,A1		the return address.
02:000049DA 4ED1            	  1440: 	JMP	(A1)		jump to the routine
02:000049DC 5288            	  1441: TC1	ADDQ.L	#1,A0		if equal, bump text pointer
02:000049DE 5289            	  1442: 	ADDQ.L	#1,A1		Skip the 2 bytes following
02:000049E0 4ED1            	  1443: 	JMP	(A1)		the call and continue.
                            	  1444: 
                            	  1445: *
                            	  1446: * ===== See if the text pointed to by A0 is a number. If so,
                            	  1447: *	return the number in D1 and the number of digits in D2,
                            	  1448: *	else return zero in D1 and D2.
                            	  1449: *
02:000049E2 7200            	  1450: TSTNUM	CLR.L	D1		initialize return parameters
02:000049E4 4242            	  1451: 	CLR	D2
02:000049E6 6130            	  1452: 	BSR	IGNBLK		skip over blanks
02:000049E8 0C100030        	  1453: TN1	CMP.B	#'0',(A0)       is it less than zero?
02:000049EC 6528            	  1454: 	BCS	TSNMRET 	if so, that's all
02:000049EE 0C100039        	  1455: 	CMP.B	#'9',(A0)       is it greater than nine?
02:000049F2 6222            	  1456: 	BHI	TSNMRET 	if so, return
02:000049F4 B2BC0CCCCCCC    	  1457: 	CMP.L	#214748364,D1	see if there's room for new digit
02:000049FA 6400FDAE        	  1458: 	BCC	QHOW		if not, we've overflowd
02:000049FE 2001            	  1459: 	MOVE.L	D1,D0		quickly multiply result by 10
02:00004A00 D281            	  1460: 	ADD.L	D1,D1
02:00004A02 D281            	  1461: 	ADD.L	D1,D1
02:00004A04 D280            	  1462: 	ADD.L	D0,D1
02:00004A06 D281            	  1463: 	ADD.L	D1,D1
02:00004A08 1018            	  1464: 	MOVE.B	(A0)+,D0	add in the new digit
02:00004A0A C0BC0000000F    	  1465: 	AND.L	#$F,D0
02:00004A10 D280            	  1466: 	ADD.L	D0,D1
02:00004A12 5242            	  1467: 	ADDQ	#1,D2		increment the no. of digits
02:00004A14 60D2            	  1468: 	BRA	TN1
02:00004A16 4E75            	  1469: TSNMRET RTS
                            	  1470: 
                            	  1471: *
                            	  1472: * ===== Skip over blanks in the text pointed to by A0.
                            	  1473: *
02:00004A18 0C100020        	  1474: IGNBLK	CMP.B	#' ',(A0)       see if it's a space
02:00004A1C 6604            	  1475: 	BNE	IGBRET		if so, swallow it
02:00004A1E 5288            	  1476: IGB1	ADDQ.L	#1,A0		increment the text pointer
02:00004A20 60F6            	  1477: 	BRA	IGNBLK
02:00004A22 4E75            	  1478: IGBRET	RTS
                            	  1479: 
                            	  1480: *
                            	  1481: * ===== Convert the line of text in the input buffer to upper
                            	  1482: *	case (except for stuff between quotes).
                            	  1483: *
02:00004A24 41FA0154        	  1484: TOUPBUF LEA	BUFFER,A0	set up text pointer
02:00004A28 4201            	  1485: 	CLR.B	D1		clear quote flag
                            	  1486: TOUPB1	
02:00004A2A 1018            	  1487: 	MOVE.B	(A0)+,D0	get the next text char.
02:00004A2C B03C000D        	  1488: 	CMP.B	#CR,D0		is it end of line?
02:00004A30 6718            	  1489: 	BEQ	TOUPBRT 	if so, return
02:00004A32 B03C0022        	  1490: 	CMP.B	#'"',D0         a double quote?
02:00004A36 6714            	  1491: 	BEQ	DOQUO
02:00004A38 B03C0027        	  1492: 	CMP.B	#'''',D0        or a single quote?
02:00004A3C 670E            	  1493: 	BEQ	DOQUO
02:00004A3E 4A01            	  1494: 	TST.B	D1		inside quotes?
02:00004A40 66E8            	  1495: 	BNE	TOUPB1		if so, do the next one
02:00004A42 6118            	  1496: 	BSR	TOUPPER 	convert to upper case
02:00004A44 1100            	  1497: 	MOVE.B	D0,-(A0)	store it
02:00004A46 5288            	  1498: 	ADDQ.L	#1,A0
02:00004A48 60E0            	  1499: 	BRA	TOUPB1		and go back for more
                            	  1500: TOUPBRT
02:00004A4A 4E75            	  1501: 	RTS
                            	  1502: 
02:00004A4C 4A01            	  1503: DOQUO	TST.B	D1		are we inside quotes?
02:00004A4E 6604            	  1504: 	BNE	DOQUO1
02:00004A50 1200            	  1505: 	MOVE.B	D0,D1		if not, toggle inside-quotes flag
02:00004A52 60D6            	  1506: 	BRA	TOUPB1
02:00004A54 B200            	  1507: DOQUO1	CMP.B	D0,D1		make sure we're ending proper quote
02:00004A56 66D2            	  1508: 	BNE	TOUPB1		if not, ignore it
02:00004A58 4201            	  1509: 	CLR.B	D1		else clear quote flag
02:00004A5A 60CE            	  1510: 	BRA	TOUPB1
                            	  1511: 
                            	  1512: *
                            	  1513: * ===== Convert the character in D0 to upper case
                            	  1514: *
02:00004A5C B03C0061        	  1515: TOUPPER CMP.B	#'a',D0         is it < 'a'?
02:00004A60 650A            	  1516: 	BCS	TOUPRET
02:00004A62 B03C007A        	  1517: 	CMP.B	#'z',D0         or > 'z'?
02:00004A66 6204            	  1518: 	BHI	TOUPRET
02:00004A68 903C0020        	  1519: 	SUB.B	#32,D0		if not, make it upper case
02:00004A6C 4E75            	  1520: TOUPRET RTS
                            	  1521: 
                            	  1522: *
                            	  1523: * 'CHKIO' checks the input. If there's no input, it will return
                            	  1524: * to the caller with the Z flag set. If there is input, the Z
                            	  1525: * flag is cleared and the input byte is in D0. However, if a
                            	  1526: * control-C is read, 'CHKIO' will warm-start BASIC and will not
                            	  1527: * return to the caller.
                            	  1528: *
02:00004A6E 6100F414        	  1529: CHKIO	bsr	GOIN		get input if possible
02:00004A72 670A            	  1530: 	BEQ	CHKRET		if Zero, no input
02:00004A74 B03C0003        	  1531: 	CMP.B	#CTRLC,D0	is it control-C?
02:00004A78 6604            	  1532: 	BNE	CHKRET		if not
02:00004A7A 6000F464        	  1533: 	BRA	WSTART		if so, do a warm start
02:00004A7E 4E75            	  1534: CHKRET	RTS
                            	  1535: 
                            	  1536: *
                            	  1537: * ===== Display a CR-LF sequence
                            	  1538: *
                            	  1539: ;CRLF	LEA	CLMSG,A6
                            	  1540: 
                            	  1541: *
                            	  1542: * ===== Display a zero-ended string pointed to by register A6
                            	  1543: *
02:00004A80 101E            	  1544: PRMESG	MOVE.B	(A6)+,D0	get the char.
02:00004A82 6706            	  1545: 	BEQ	PRMRET		if it's zero, we're done
02:00004A84 6100F3FA        	  1546: 	BSR	GOOUT		else display it
02:00004A88 60F6            	  1547: 	BRA	PRMESG
02:00004A8A 4E75            	  1548: PRMRET	RTS
                            	  1549: 
                            	  1550: ******************************************************
                            	  1551: * The following routines are the only ones that need *
                            	  1552: * to be changed for a different I/O environment.     *
                            	  1553: ******************************************************
                            	  1554: 
                            	  1555: *
                            	  1556: * ===== Output character to the console (Port 1) from register D0
                            	  1557: *	(Preserves all registers.)
                            	  1558: *
                            	  1559: OUTC
02:00004A8C 2F0E            	  1560: 	move.l	a6,-(a7)
02:00004A8E 2C7A00BA        	  1561: 	move.l	OUTPTR,a6
02:00004A92 4E96            	  1562: 	jsr			(a6)
02:00004A94 2C5F            	  1563: 	move.l	(a7)+,a6
02:00004A96 4E75            	  1564: 	rts
                            	  1565: 
                            	  1566: OUTC1
02:00004A98 48E7C000        	  1567: 	movem.l		d0/d1,-(a7)
02:00004A9C 2200            	  1568: 	move.l		d0,d1
02:00004A9E 7006            	  1569: 	moveq.l		#6,d0
02:00004AA0 4E4F            	  1570: 	trap			#15
02:00004AA2 4CDF0003        	  1571: 	movem.l		(a7)+,d0/d1
02:00004AA6 4E75            	  1572: 	rts
                            	  1573: 
                            	  1574: *OUTC	BTST	#1,$10040	is port 1 ready for a character?
                            	  1575: *	BEQ	OUTC		if not, wait for it
                            	  1576: *	MOVE.B	D0,$10042	out it goes.
                            	  1577: *	RTS
                            	  1578: 
                            	  1579: *
                            	  1580: * ===== Input a character from the console into register D0 (or
                            	  1581: *	return Zero status if there's no character available).
                            	  1582: *
                            	  1583: INC
02:00004AA8 2F0E            	  1584: 	move.l	a6,-(a7)
02:00004AAA 2C7A009A        	  1585: 	move.l	INPPTR,a6
02:00004AAE 4E96            	  1586: 	jsr			(a6)
02:00004AB0 2C5F            	  1587: 	move.l	(a7)+,a6
02:00004AB2 4E75            	  1588: 	rts
                            	  1589: 
                            	  1590: INC1
02:00004AB4 2F01            	  1591: 	move.l	d1,-(a7)
02:00004AB6 7005            	  1592: 	moveq.l	#5,d0			* function 5 GetKey
02:00004AB8 4E4F            	  1593: 	trap		#15
02:00004ABA 2001            	  1594: 	move.l	d1,d0
02:00004ABC 221F            	  1595: 	move.l	(a7)+,d1
02:00004ABE 0C0000FF        	  1596: 	cmpi.b	#-1,d0
02:00004AC2 6602            	  1597: 	bne			.0001
02:00004AC4 4200            	  1598: 	clr.b		d0
                            	  1599: .0001:
02:00004AC6 4E75            	  1600: 	rts
                            	  1601: 
                            	  1602: *INC	BTST	#0,$10040	is character ready?
                            	  1603: *	BEQ	INCRET		if not, return Zero status
                            	  1604: *	MOVE.B	$10042,D0	else get the character
                            	  1605: *	AND.B	#$7F,D0 	zero out the high bit
                            	  1606: *INCRET	RTS
                            	  1607: 
                            	  1608: *
                            	  1609: * ===== Output character to the host (Port 2) from register D0
                            	  1610: *	(Preserves all registers.)
                            	  1611: *
                            	  1612: AUXOUT:
02:00004AC8 48E7C000        	  1613: 	movem.l	d0/d1,-(a7)
02:00004ACC 2200            	  1614: 	move.l	d0,d1
02:00004ACE 7022            	  1615: 	moveq		#34,d0
02:00004AD0 4E4F            	  1616: 	trap		#15
02:00004AD2 4CDF0003        	  1617: 	movem.l	(a7)+,d0/d1
02:00004AD6 4E75            	  1618: 	rts
                            	  1619: 
                            	  1620: *AUXOUT	BTST	#1,$10041	is port 2 ready for a character?
                            	  1621: *	BEQ	AUXOUT		if not, wait for it
                            	  1622: *	MOVE.B	D0,$10043	out it goes.
                            	  1623: *	RTS
                            	  1624: 
                            	  1625: *
                            	  1626: * ===== Input a character from the host into register D0 (or
                            	  1627: *	return Zero status if there's no character available).
                            	  1628: *
                            	  1629: AUXIN:
02:00004AD8 2F01            	  1630: 	move.l	d1,-(a7)
02:00004ADA 7024            	  1631: 	moveq		#36,d0				; serial get char from buffer
02:00004ADC 4E4F            	  1632: 	trap		#15
02:00004ADE 2001            	  1633: 	move.l	d1,d0
02:00004AE0 221F            	  1634: 	move.l	(a7)+,d1
02:00004AE2 0C40FFFF        	  1635: 	cmpi.w	#-1,d0
02:00004AE6 670A            	  1636: 	beq			.0001
02:00004AE8 0200007F        	  1637: 	andi.b	#$7F,d0				; clear high bit
02:00004AEC 4880            	  1638: 	ext.w		d0						; return character in d0
02:00004AEE 48C0            	  1639: 	ext.l		d0
02:00004AF0 4E75            	  1640: 	rts
                            	  1641: .0001:
02:00004AF2 7000            	  1642: 	moveq		#0,d0					; return zf=1 if no character available
02:00004AF4 4E75            	  1643: 	rts
                            	  1644: 
                            	  1645: ;AUXIN
                            	  1646: *AUXIN	BTST	#0,$10041	is character ready?
                            	  1647: *	BEQ	AXIRET		if not, return Zero status
                            	  1648: *	MOVE.B	$10043,D0	else get the character
                            	  1649: *	AND.B	#$7F,D0 	zero out the high bit
02:00004AF6 4E75            	  1650: AXIRET	RTS
                            	  1651: 
                            	  1652: *
                            	  1653: * ===== Return to the resident monitor, operating system, etc.
                            	  1654: *
                            	  1655: BYEBYE	
02:00004AF8 60001168        	  1656: 	bra		Monitor
                            	  1657: ;	MOVE.B	#228,D7 	return to Tutor
                            	  1658: ;	TRAP	#14
                            	  1659: 
02:00004AFC 0D              	  1660: INITMSG DC.B	CR,LF,'Gordo''s MC68000 Tiny BASIC, v1.2',CR,LF,LF,0
02:00004AFD 0A
02:00004AFE 476F72646F277320
02:00004B06 4D43363830303020
02:00004B0E 54696E7920424153
02:00004B16 49432C2076312E32
02:00004B1E 0D
02:00004B1F 0A
02:00004B20 0A
02:00004B21 00
02:00004B22 0D              	  1661: OKMSG	DC.B	CR,LF,'OK',CR,LF,0
02:00004B23 0A
02:00004B24 4F4B
02:00004B26 0D
02:00004B27 0A
02:00004B28 00
02:00004B29 486F773F        	  1662: HOWMSG	DC.B	'How?',CR,LF,0
02:00004B2D 0D
02:00004B2E 0A
02:00004B2F 00
02:00004B30 576861743F      	  1663: WHTMSG	DC.B	'What?',CR,LF,0
02:00004B35 0D
02:00004B36 0A
02:00004B37 00
02:00004B38 536F7272792E    	  1664: SRYMSG	DC.B	'Sorry.'
02:00004B3E 0D              	  1665: CLMSG	DC.B	CR,LF,0
02:00004B3F 0A
02:00004B40 00
02:00004B41 00              	  1666: 	DC.B	0	<- for aligning on a word boundary
                            	  1667: LSTROM	EQU	*		end of possible ROM area
                            	  1668: *
                            	  1669: * Internal variables follow:
                            	  1670: *
02:00004B42 00003E7C        	  1671: RANPNT	DC.L	START		random number pointer
02:00004B46 00000000        	  1672: INPPTR	DS.L	1		input pointer
02:00004B4A 00000000        	  1673: OUTPTR	DS.L	1 	output pointer
02:00004B4E 00000000        	  1674: CURRNT	DS.L	1		Current line pointer
02:00004B52 00000000        	  1675: STKGOS	DS.L	1		Saves stack pointer in 'GOSUB'
02:00004B56 00000000        	  1676: STKINP	DS.L	1		Saves stack pointer during 'INPUT'
02:00004B5A 00000000        	  1677: LOPVAR	DS.L	1		'FOR' loop save area
02:00004B5E 00000000        	  1678: LOPINC	DS.L	1		increment
02:00004B62 00000000        	  1679: LOPLMT	DS.L	1		limit
02:00004B66 00000000        	  1680: LOPLN	DS.L	1		line number
02:00004B6A 00000000        	  1681: LOPPT	DS.L	1		text pointer
02:00004B6E 00000000        	  1682: TXTUNF	DS.L	1		points to unfilled text area
02:00004B72 00000000        	  1683: VARBGN	DS.L	1		points to variable area
02:00004B76 00000000        	  1684: STKLMT	DS.L	1		holds lower limit for stack growth
02:00004B7A 00              	  1685: BUFFER	DS.B	BUFLEN		Keyboard input buffer
02:00004B7B *
                            	  1686: TXT	EQU	*		Beginning of program area
                            	  1687: ;	END
                            	  1688: 

Source: "boot.asm"
                            	   759: 	include "..\Femtiki\source\kernel\Femtiki.x68"

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     1: 	include "..\Femtiki\const.x68"

Source: "..\Femtiki\const.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2020-2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: TS_NONE			EQU		0
                            	    38: TS_READY		EQU		1
                            	    39: TS_DEAD			EQU		2
                            	    40: TS_MSGRDY		EQU		4
                            	    41: TS_WAITMSG	EQU		8
                            	    42: TS_TIMEOUT	EQU		16
                            	    43: TS_PREEMPT	EQU		32
                            	    44: TS_RUNNING	EQU		128
                            	    45: 
                            	    46: ; error codes
                            	    47: E_Ok		EQU		$00
                            	    48: E_Arg		EQU		$01
                            	    49: E_Func  EQU    $02
                            	    50: E_BadMbx	EQU		$04
                            	    51: E_QueFull	EQU		$05
                            	    52: E_NoThread	EQU		$06
                            	    53: E_NotAlloc	EQU		$09
                            	    54: E_NoMsg		EQU		$0b
                            	    55: E_Timeout	EQU		$10
                            	    56: E_BadAlarm	EQU		$11
                            	    57: E_NotOwner	EQU		$12
                            	    58: E_QueStrategy EQU		$13
                            	    59: E_DCBInUse	EQU		$19
                            	    60: ; Device driver errors
                            	    61: E_BadDevNum	EQU		$20
                            	    62: E_NoDev		EQU		$21
                            	    63: E_BadDevOp	EQU		$22
                            	    64: E_ReadError	EQU		$23
                            	    65: E_WriteError EQU		$24
                            	    66: E_BadBlockNum	EQU	$25
                            	    67: E_TooManyBlocks	EQU	$26
                            	    68: 
                            	    69: ; resource errors
                            	    70: E_NoMoreMbx	EQU		$40
                            	    71: E_NoMoreMsgBlks	EQU	$41
                            	    72: E_NoMoreAlarmBlks	EQU $44
                            	    73: E_NoMoreTCBs	EQU	$45
                            	    74: E_NoMem		EQU 12
                            	    75: 
                            	    76: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     2: 	include "..\Femtiki\config.x68"

Source: "..\Femtiki\config.x68"
                            	     1: MAX_TID		EQU		4095
                            	     2: NR_TCB		EQU		4096
                            	     3: NTASK     EQU   4096    ; number of threads allowed
                            	     4: LOG_TCBSZ	EQU		8
                            	     5: LOG_PGSZ	EQU		10
                            	     6: LOG_ACBSZ EQU   12
                            	     7: OSPAGES		EQU		16			; pages of memory dedicated to OS
                            	     8: PAGESZ    EQU   16384  	; size of a page of memory
                            	     9: MEMSZ     EQU   32768   ; pages
                            	    10: MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                            	    11: NR_MSG		EQU		21842		; number of messages available
                            	    12: NR_MBX		EQU		9792
                            	    13: 
                            	    14: 
                            	    15: 
                            	    16: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     3: 	include "..\Femtiki\types.x68"

Source: "..\Femtiki\types.x68"
                            	     1: ; Thread Control Block
                            	     2: TCBMagic    EQU		$0000
                            	     3: TCBRegs  		EQU   $0004		; register set storage area
                            	     4: TCBUSP			EQU		$0044
                            	     5: TCBSSP			EQU		$0048
                            	     6: TCBSR				EQU		$004C
                            	     7: TCBPC				EQU		$0050
                            	     8: TCBStatus		EQU		$0054
                            	     9: TCBPriority	EQU		$0055
                            	    10: TCBWaitMbx	EQU		$0056
                            	    11: TCBHasFocus EQU   $005A
                            	    12: TCBStackBot	EQU		$005C
                            	    13: TCBMsgD1		EQU		$0060
                            	    14: TCBMsgD2		EQU		$0064
                            	    15: TCBMsgD3		EQU		$0068
                            	    16: TCBStartTick	EQU	$006C
                            	    17: TCBEndTick	EQU		$0070
                            	    18: TCBTicks		EQU		$0074
                            	    19: TCBException	EQU	$0078
                            	    20: TCBNext			EQU		$007C
                            	    21: TCBPrev			EQU		$0080
                            	    22: TCBAffinity	EQU		$0084
                            	    23: TCBTimeout	EQU		$0088
                            	    24: TCBtid      EQU   $008C
                            	    25: TCBmid      EQU   $0090
                            	    26: TCBappid    EQU   $0094
                            	    27: TCBOpMode   EQU   $0098
                            	    28: TCBMbxNext  EQU   $009C
                            	    29: TCBMbxPrev  EQU   $00A0
                            	    30: TCBThreadNum  EQU   $00A4
                            	    31: TCBAcbNext	EQU		$00A8
                            	    32: TCBAcbPrev	EQU		$00AC
                            	    33: TCBhMailboxes	EQU		$00B0
                            	    34: TCBName			EQU		$00C0
                            	    35: TCB_SIZE		EQU		$0100
                            	    36: 
                            	    37: MBC_MAGIC		equ		0
                            	    38: MBX_OWNER		equ		4		; tid of owning task
                            	    39: MBX_LINK    equ   8
                            	    40: MBX_TQHEAD  equ   12   ; link field for free list shared with task queue head
                            	    41: MBX_TQTAIL  equ   16
                            	    42: MBX_MQHEAD	equ		20
                            	    43: MBX_MQTAIL	equ		24
                            	    44: MBX_SIZE		equ		32
                            	    45: 
                            	    46: MSG_MAGIC   equ   0
                            	    47: MSG_LINK	  equ		4
                            	    48: MSG_RETADR  equ   8
                            	    49: MSG_TGTADR  equ   12
                            	    50: MSG_TYPE    equ   16
                            	    51: MSG_D1		  equ		20
                            	    52: MSG_D2		  equ		24
                            	    53: MSG_D3		  equ		28
                            	    54: MSG_SIZE	  equ		32
                            	    55: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     4: 
                            	     5: 	code
                            	     6: 	even
                            	     7: ;------------------------------------------------------------------------------
                            	     8: ; Initialize the Femtiki OS.
                            	     9: ;------------------------------------------------------------------------------
                            	    10: 
                            	    11: FemtikiInit:
02:00004BCA 203C20010000    	    12: 	move.l #tcbs,d0
02:00004BD0 4E7B0013        	    13: 	movec d0,tcba
02:00004BD4 7000            	    14: 	moveq #0,d0
02:00004BD6 4E7B0012        	    15: 	movec d0,tr
02:00004BDA 7007            	    16: 	moveq #7,d0
02:00004BDC 41F900100320    	    17: 	lea readyQ,a0
                            	    18: .clearReadyQ
02:00004BE2 4298            	    19: 	clr.l (a0)+
02:00004BE4 51C8FFFC        	    20: 	dbra d0,.clearReadyQ
02:00004BE8 42390010031C    	    21: 	clr.b QueueCycle
02:00004BEE 4E7A0013        	    22: 	movec tcba,d0
02:00004BF2 2040            	    23: 	move.l d0,a0
02:00004BF4 203C0003FFFF    	    24: 	move.l #TCB_SIZE*NR_TCB/4-1,d0
                            	    25: .clearTCBs
02:00004BFA 4298            	    26: 	clr.l (a0)+
02:00004BFC 51C8FFFC        	    27: 	dbra d0,.clearTCBs
                            	    28: FemtikiInitIRQ:
02:00004C00 43FA01F2        	    29: 	lea FemtikiTimerIRQ,a1						; Set timer IRQ vector to Femtiki
02:00004C04 4E7A8801        	    30: 	movec vbr,a0
02:00004C08 21490078        	    31: 	move.l a1,30*4(a0)								; vector #30
02:00004C0C 4E75            	    32: 	rts
                            	    33: 
                            	    34: ;------------------------------------------------------------------------------
                            	    35: ; Operating system call dispatcher.
                            	    36: ; On entry, the task state has been saved including the system stack pointer,
                            	    37: ; in the task control block.
                            	    38: ;------------------------------------------------------------------------------
                            	    39: 
                            	    40: OSCallTable
02:00004C0E 0000            	    41: 	dc.w		0
                            	    42: 
                            	    43: 	even
                            	    44: CallOS:
02:00004C10 2F08            	    45: 	move.l	a0,-(a7)
02:00004C12 207900100224    	    46: 	move.l	RunningTCB,a0
02:00004C18 48E8FFFF0004    	    47: 	movem.l d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,TCBRegs(a0)
02:00004C1E 225F            	    48: 	move.l	(a7)+,a1
02:00004C20 21490020        	    49: 	move.l	a1,32(a0)
02:00004C24 4E7A9800        	    50: 	movec		usp,a1
02:00004C28 21490044        	    51: 	move.l	a1,TCBUSP(a0)
02:00004C2C 301F            	    52: 	move.w	(a7)+,d0					; pop the status register
02:00004C2E 3140004C        	    53: 	move.w	d0,TCBSR(a0)			; save in TCB
02:00004C32 225F            	    54: 	move.l	(a7)+,a1					; pop the program counter
02:00004C34 5489            	    55: 	lea	2(a1),a1							; increment past inline callno argument
02:00004C36 21490050        	    56: 	move.l	a1,TCBPC(a0)			; save PC in TCB
02:00004C3A 214F0048        	    57: 	move.l	a7,TCBSSP(a0)			; finally save SSP
02:00004C3E 3029FFFE        	    58: 	move.w	-2(a1),d0					; d0 = call number
02:00004C42 E548            	    59: 	lsl.w		#2,d0							; make into table index
02:00004C44 43FAFFC8        	    60: 	lea			OSCallTable,a1
02:00004C48 22710000        	    61: 	move.l	(a1,d0.w),a1
02:00004C4C 4E91            	    62: 	jsr			(a1)							; call the OS function
                            	    63: 	; Restore the thread context and return
02:00004C4E 207900100224    	    64: 	move.l	RunningTCB,a0
02:00004C54 2E780048        	    65: 	move.l	TCBSSP,a7
02:00004C58 2F280050        	    66: 	move.l	TCBPC(a0),-(a7)		; setup the PC and the SR on the stack
02:00004C5C 3F28004C        	    67: 	move.w	TCBSR(a0),-(a7)		; prep for RTE
02:00004C60 20380044        	    68: 	move.l	TCBUSP,d0					; restore user stack pointer
02:00004C64 4E7B0800        	    69: 	movec		d0,usp
02:00004C68 4CE800FF0004    	    70: 	movem.l	TCBRegs(a0),d0/d1/d2/d3/d4/d5/d6/d7
02:00004C6E 4CE87E00002C    	    71: 	movem.l TCBRegs+40(a0),a1/a2/a3/a4/a5/a6
02:00004C74 20680024        	    72: 	move.l	TCBRegs+32(a0),a0
02:00004C78 4E73            	    73: 	rte
                            	    74: 
                            	    75: ;------------------------------------------------------------------------------
                            	    76: ; Get a pointer to the currently running TCB.
                            	    77: ;------------------------------------------------------------------------------
                            	    78: 
                            	    79: GetRunningTCBPointer:
02:00004C7A 48E7C000        	    80: 	movem.l d0/d1,-(a7)
02:00004C7E 4E7A0012        	    81: 	movec tr,d0
02:00004C82 028000000FFF    	    82: 	andi.l #MAX_TID,d0		; limit to # threads
02:00004C88 4E7A1013        	    83: 	movec tcba,d1
02:00004C8C E188            	    84: 	lsl.l #8,d0
02:00004C8E D081            	    85: 	add.l d1,d0
02:00004C90 2040            	    86: 	move.l d0,a0
02:00004C92 4CDF0003        	    87: 	movem.l (a7)+,d0/d1
02:00004C96 4E75            	    88: 	rts
                            	    89: 
                            	    90: ;------------------------------------------------------------------------------
                            	    91: ; Convert a TCB handle into a pointer.
                            	    92: ;------------------------------------------------------------------------------
                            	    93: 
                            	    94: TCBHandleToPointer:
02:00004C98 2F01            	    95: 	move.l d1,-(a7)
02:00004C9A 028000000FFF    	    96: 	andi.l #MAX_TID,d0		; limit to # threads
02:00004CA0 4E7A1013        	    97: 	movec tcba,d1
02:00004CA4 E188            	    98: 	lsl.l #8,d0
02:00004CA6 D280            	    99: 	add.l d0,d1
02:00004CA8 2041            	   100: 	move.l d1,a0
02:00004CAA E088            	   101: 	lsr.l #8,d0						; restore d0
02:00004CAC 221F            	   102: 	move.l (a7)+,d1
02:00004CAE 4E75            	   103: 	rts
                            	   104: 
                            	   105: ;------------------------------------------------------------------------------
                            	   106: ; Convert a TCB pointer into a handle.
                            	   107: ;------------------------------------------------------------------------------
                            	   108: 
                            	   109: PointerToTCBHandle:
02:00004CB0 2F01            	   110: 	move.l d1,-(a7)				; save d1
02:00004CB2 4E7A1013        	   111: 	movec tcba,d1
02:00004CB6 91C1            	   112: 	sub.l d1,a0
02:00004CB8 2008            	   113: 	move.l a0,d0
02:00004CBA E088            	   114: 	lsr.l #8,d0
02:00004CBC 221F            	   115: 	move.l (a7)+,d1				; restore d1
02:00004CBE 4E75            	   116: 	rts
                            	   117: 
                            	   118: ; ----------------------------------------------------------------------------
                            	   119: ; Select a thread to run. Relatively easy. All that needs to be done is to
                            	   120: ; keep popping the queue until a valid running task is found. There should
                            	   121: ; always be at least one thread in the queue.
                            	   122: ;
                            	   123: ; Modifies:
                            	   124: ;		none
                            	   125: ; Returns:
                            	   126: ;		d0 = handle of the next thread to run
                            	   127: ; ----------------------------------------------------------------------------
                            	   128: 
                            	   129: SelectThreadToRun:
                            	   130: .0001										; keep popping tasks from the readyQ until a valid one
02:00004CC0 61000092        	   131: 	bsr	PopReadyQueue			; is found.
02:00004CC4 2048            	   132: 	move.l a0,a0					; tst.l a0
02:00004CC6 670C            	   133: 	beq	.0002
02:00004CC8 0C2800800054    	   134: 	cmpi.b #TS_RUNNING,TCBStatus(a0)	; ensure the thread is to be running
02:00004CCE 66F0            	   135: 	bne	.0001													; if not, go get the next thread
02:00004CD0 61DE            	   136: 	bsr PointerToTCBHandle
02:00004CD2 6012            	   137: 	bra	InsertIntoReadyQueue					; insert thread back into queue
                            	   138: 	; Nothing in queues? There is supposed to be. Add the OS task to the queue.
                            	   139: .0002
02:00004CD4 4E7A8013        	   140: 	movec tcba,a0
02:00004CD8 117C00800054    	   141: 	move.b #TS_RUNNING,TCBStatus(a0)	; flag as RUNNING
02:00004CDE 117C00040055    	   142: 	move.b #4,TCBPriority(a0)					; OS has normal priority
02:00004CE4 7000            	   143: 	moveq #0,d0												; fast pointer to handle
                            	   144: 	; fall through to insert
                            	   145: 
                            	   146: ; ----------------------------------------------------------------------------
                            	   147: ; Insert thread into ready queue. The thread is added at the tail of the 
                            	   148: ; queue. The queue is a doubly linked list.
                            	   149: ;
                            	   150: ; Parameters:
                            	   151: ;		d0 = TCB handle
                            	   152: ; Returns:
                            	   153: ;		d0 = TCB handle
                            	   154: ; ----------------------------------------------------------------------------
                            	   155: 
                            	   156: InsertIntoReadyQueue:
02:00004CE6 48E7C0F0        	   157: 	movem.l	d0/d1/a0/a1/a2/a3,-(a7)
02:00004CEA 61AC            	   158: 	bsr TCBHandleToPointer
02:00004CEC 7025            	   159: 	moveq #37,d0
02:00004CEE 7207            	   160: 	moveq #TCB_SEMA,d1				; lock semaphore
02:00004CF0 4E4F            	   161: 	trap #15
02:00004CF2 20280055        	   162: 	move.l TCBPriority(a0),d0
02:00004CF6 02400007        	   163: 	andi.w #7,d0
02:00004CFA E548            	   164: 	lsl.w	#2,d0
02:00004CFC 43F900100320    	   165: 	lea	readyQ,a1
02:00004D02 26712000        	   166: 	move.l (a1,d2.w),a3
02:00004D06 6720            	   167: 	beq .qempty
02:00004D08 246B0080        	   168: 	move.l TCBPrev(a3),a2
02:00004D0C 214B007C        	   169: 	move.l a3,TCBNext(a0)
02:00004D10 214A0080        	   170: 	move.l a2,TCBPrev(a0)
02:00004D14 206A007C        	   171: 	move.l TCBNext(a2),a0
02:00004D18 206B0080        	   172: 	move.l TCBPrev(a3),a0
                            	   173: .xit:
02:00004D1C 7026            	   174: 	moveq #38,d0
02:00004D1E 7207            	   175: 	moveq #TCB_SEMA,d1				; unlock semaphore
02:00004D20 4E4F            	   176: 	trap #15
02:00004D22 4CDF0F03        	   177: 	movem.l	(a7)+,d0/d1/a0/a1/a2/a3
02:00004D26 4E75            	   178: 	rts
                            	   179: .qempty
02:00004D28 23880000        	   180: 	move.l a0,(a1,d0.w)
02:00004D2C 2148007C        	   181: 	move.l a0,TCBNext(a0)
02:00004D30 21480080        	   182: 	move.l a0,TCBPrev(a0)
02:00004D34 60E6            	   183: 	bra .xit
                            	   184: 
                            	   185: ; ----------------------------------------------------------------------------
                            	   186: ; Remove a thread from the ready queue. Simple. Just mark the thread as not
                            	   187: ; running and it will be removed automatically the next time it is switched
                            	   188: ; to.
                            	   189: ;
                            	   190: ; Parameters:
                            	   191: ;		d0 = TCB handle
                            	   192: ; Returns:
                            	   193: ;		none
                            	   194: ; ----------------------------------------------------------------------------
                            	   195: 
                            	   196: RemoveFromReadyQueue:
02:00004D36 2F08            	   197: 	move.l a0,-(a7)											; save a0
02:00004D38 C0BC00000FFF    	   198: 	and.l #MAX_TID,d0										; limit to # of threads
02:00004D3E 6100FF58        	   199: 	bsr TCBHandleToPointer							; a0 = pointer to TCB
02:00004D42 0228007F0054    	   200: 	andi.b #$7F,TCBStatus(a0)						; set status no longer running
02:00004D48 205F            	   201: 	move.l (a7)+,a0											; restore a0
02:00004D4A 4E75            	   202: 	rts	
                            	   203: 
                            	   204: ; ----------------------------------------------------------------------------
                            	   205: ; Register Usage
                            	   206: ;		d0 = queue counter
                            	   207: ;		d1 = index into list of queues
                            	   208: ;		a0 = pointer to list of queues
                            	   209: ;		a3 = pointer to TCB at head of queue
                            	   210: ; Parameters:
                            	   211: ;		none
                            	   212: ; Returns:
                            	   213: ;		a0 = pointer to TCB, NULL if none on list
                            	   214: ; ----------------------------------------------------------------------------
                            	   215: 
                            	   216: StartQ
02:00004D4C 01              	   217: 	dc.b 1,2,3,4,1,5,6,7
02:00004D4D 02
02:00004D4E 03
02:00004D4F 04
02:00004D50 01
02:00004D51 05
02:00004D52 06
02:00004D53 07
                            	   218: 
                            	   219: 	even
                            	   220: PopReadyQueue:
02:00004D54 48E7C070        	   221: 	movem.l	d0/d1/a1/a2/a3,-(a7)
02:00004D58 7025            	   222: 	moveq #37,d0
02:00004D5A 7207            	   223: 	moveq #TCB_SEMA,d1			; lock semaphore
02:00004D5C 4E4F            	   224: 	trap #15
02:00004D5E 7007            	   225: 	moveq #7,d0
                            	   226: 	; One in four tries pick a different priority to start searching from. 
02:00004D60 12390010031C    	   227: 	move.b QueueCycle,d1		; increment Queue cycle counter
02:00004D66 5201            	   228: 	addi.b #1,d1
02:00004D68 02010007        	   229: 	andi.b #7,d1
02:00004D6C 13C10010031C    	   230: 	move.b d1,QueueCycle
02:00004D72 6612            	   231: 	bne	.0001
02:00004D74 43FAFFD6        	   232: 	lea StartQ,a1
02:00004D78 4881            	   233: 	ext.w d1
02:00004D7A 12311000        	   234: 	move.b (a1,d1.w),d1
02:00004D7E 02410007        	   235: 	andi.w #7,d1						; limit to number of queues
02:00004D82 E549            	   236: 	lsl.w #2,d1							; make into lword index
02:00004D84 6002            	   237: 	bra .0002
                            	   238: .0001
02:00004D86 7200            	   239: 	moveq #0,d1							; start at Queue #0
                            	   240: .0002
02:00004D88 41F900100320    	   241: 	lea readyQ,a0						; a0 = pointer to list of ready queues
02:00004D8E 26701000        	   242: 	move.l (a0,d1.w),a3			; a3 = head of list
02:00004D92 6732            	   243: 	beq .nextQ							; anything on list?, if not go next queue
02:00004D94 226B007C        	   244: 	move.l TCBNext(a3),a1		; remove head of list from list
02:00004D98 B7C9            	   245: 	cmpa.l a1,a3						; removing last TCB?
02:00004D9A 6726            	   246: 	beq .removeLast
02:00004D9C 246B0080        	   247: 	move.l TCBPrev(a3),a2
02:00004DA0 24690080        	   248: 	move.l TCBPrev(a1),a2
02:00004DA4 226A007C        	   249: 	move.l TCBNext(a2),a1
                            	   250: .0003
02:00004DA8 21891000        	   251: 	move.l	a1,(a0,d1.w)		; reset head of list to next
                            	   252: .0004
02:00004DAC 204B            	   253: 	move.l a3,a0						; a0 = old head of list (returned)
02:00004DAE 2148007C        	   254: 	move.l a0,TCBNext(a0)		; point links back to self
02:00004DB2 21480080        	   255: 	move.l a0,TCBPrev(a0)
02:00004DB6 7026            	   256: 	moveq #38,d0
02:00004DB8 7207            	   257: 	moveq #TCB_SEMA,d1			; unlock semaphore
02:00004DBA 4E4F            	   258: 	trap #15
02:00004DBC 4CDF0E03        	   259: 	movem.l	(a7)+,d0/d1/a1/a2/a3
02:00004DC0 4E75            	   260: 	rts
                            	   261: .removeLast
02:00004DC2 93C9            	   262: 	move.l #0,a1						; set head to zero when removing last
02:00004DC4 60E2            	   263: 	bra .0003
                            	   264: .nextQ
02:00004DC6 5841            	   265: 	addi.w #4,d1						; increment queue number by lword
02:00004DC8 0241001C        	   266: 	andi.w #$1C,d1					; limit to number of queues
02:00004DCC 51C8FFBA        	   267: 	dbra d0,.0002						; go back and check the next queue
02:00004DD0 60DA            	   268: 	bra	.0004								; return NULL pointer if nothing in any queue
                            	   269: 
                            	   270: ; ----------------------------------------------------------------------------
                            	   271: ; Update the IRQ live indicator on screen.
                            	   272: ; ----------------------------------------------------------------------------
                            	   273: 
                            	   274: UpdateIRQLive:
02:00004DD2 227900040004    	   275: 	move.l TextScr,a1					; a1 = screen address
02:00004DD8 2411            	   276: 	move.l (a1),d2
02:00004DDA E15A            	   277: 	rol.w	#8,d2								; reverse byte order of d2
02:00004DDC 4842            	   278: 	swap d2
02:00004DDE E15A            	   279: 	rol.w	#8,d2
02:00004DE0 06010030        	   280: 	addi.b #'0',d1						; binary to ascii core number
02:00004DE4 D202            	   281: 	add.b	d2,d1
02:00004DE6 E159            	   282: 	rol.w	#8,d1								; put bytes back in order
02:00004DE8 4841            	   283: 	swap d1
02:00004DEA E159            	   284: 	rol.w	#8,d1
02:00004DEC 23410004        	   285: 	move.l d1,4(a1)						; update onscreen IRQ flag
02:00004DF0 5291            	   286: 	addi.l #1,(a1)						; flashy colors
02:00004DF2 4E75            	   287: 	rts
                            	   288: 
                            	   289: ; ----------------------------------------------------------------------------
                            	   290: ; Femtiki IRQ service routine. This is where a thread switch can occur so,
                            	   291: ; the thread context is saved and restored.
                            	   292: ; ----------------------------------------------------------------------------
                            	   293: 
                            	   294: FemtikiTimerIRQ:
02:00004DF4 2F00            	   295: 	move.l d0,-(a7)
02:00004DF6 2F08            	   296: 	move.l a0,-(a7)
02:00004DF8 4E7A0012        	   297: 	movec tr,d0
02:00004DFC 6100FE9A        	   298: 	bsr TCBHandleToPointer				; a0 = pointer to TCB
02:00004E00 48D0FFFF        	   299: 	movem.l #$FFFF,(a0)						; save all registers
02:00004E04 201F            	   300: 	move.l (a7)+,d0
02:00004E06 21400020        	   301: 	move.l d0,32(a0)							; save original a0 value
02:00004E0A 201F            	   302: 	move.l (a7)+,d0
02:00004E0C 2080            	   303: 	move.l d0,(a0)								; save original d0 value
02:00004E0E 2E7C00040BFC    	   304: 	move.l #TimerStack,a7					; reset stack pointer
02:00004E14 4E7A1FE0        	   305: 	movec	coreno,d1								; d1 = core number
02:00004E18 0C010002        	   306: 	cmpi.b #2,d1
02:00004E1C 660A            	   307: 	bne.s	.0002
02:00004E1E 23FC1D000000FD09	   308: 	move.l #$1D000000,PLIC+$14		; reset edge sense circuit
02:00004E26 0014
                            	   309: .0002
02:00004E28 61A8            	   310: 	bsr UpdateIRQLive							; Update IRQ live indicator
                            	   311: ;	bsr ReceiveMsg								; Check for RPC
02:00004E2A 6100FE4E        	   312: 	bsr GetRunningTCBPointer			; a0 = pointer to running TCB
02:00004E2E 4E7A0FF0        	   313: 	movec tick,d0									; Update time accounting
02:00004E32 21400070        	   314: 	move.l d0,TCBEndTick(a0)			; compute number of ticks thread was running
02:00004E36 90A8006C        	   315: 	sub.l	TCBStartTick(a0),d0
02:00004E3A D1A80074        	   316: 	add.l	d0,TCBTicks(a0)					; add to cumulative ticks
02:00004E3E 117C00200054    	   317: 	move.b #TS_PREEMPT,TCBStatus(a0)	; set thread status to PREEMPT
02:00004E44 6100FE7A        	   318: 	bsr	SelectThreadToRun					; d0 = TCB handle
02:00004E48 4E7B0012        	   319: 	movec d0,tr										; set running thread number in tr
02:00004E4C 6100FE2C        	   320: 	bsr GetRunningTCBPointer			; a0 = pointer to TCB
02:00004E50 117C00800054    	   321: 	move.b #TS_RUNNING,TCBStatus(a0)	; set thread status to RUNNING
02:00004E56 4E7A0FF0        	   322: 	movec	tick,d0
02:00004E5A 2140006C        	   323: 	move.l d0,TCBStartTick(a0)		; record starting tick
02:00004E5E 4CD0FFFF        	   324: 	movem.l (a0),#$FFFF						; restore all registers
02:00004E62 4E73            	   325: 	rte														; and return
                            	   326: 

Source: "boot.asm"
                            	   760: 
                            	   761: ; -----------------------------------------------------------------------------
                            	   762: ; Gets the screen color in d0 and d1.
                            	   763: ; -----------------------------------------------------------------------------
                            	   764: 
                            	   765: get_screen_color:
02:00004E64 203900040084    	   766: 	move.l	fgColor,d0			; get foreground color
02:00004E6A EB80            	   767: 	asl.l		#5,d0						; shift into position
02:00004E6C 008040000000    	   768: 	ori.l		#$40000000,d0		; set priority
02:00004E72 223900040088    	   769: 	move.l	bkColor,d1
02:00004E78 E089            	   770: 	lsr.l		#8,d1
02:00004E7A E089            	   771: 	lsr.l		#8,d1
02:00004E7C 02810000001F    	   772: 	andi.l	#31,d1					; mask off extra bits
02:00004E82 8081            	   773: 	or.l		d1,d0						; set background color bits in upper long word
02:00004E84 223900040088    	   774: 	move.l	bkColor,d1			; get background color
02:00004E8A E181            	   775: 	asl.l		#8,d1						; shift into position for display ram
02:00004E8C E181            	   776: 	asl.l		#8,d1
02:00004E8E 4E75            	   777: 	rts
                            	   778: 
                            	   779: ; -----------------------------------------------------------------------------
                            	   780: ; -----------------------------------------------------------------------------
                            	   781: 
                            	   782: get_screen_address:
02:00004E90 207900040004    	   783: 	move.l	TextScr,a0
02:00004E96 4E75            	   784: 	rts
                            	   785: 	
                            	   786: ; -----------------------------------------------------------------------------
                            	   787: ; -----------------------------------------------------------------------------
                            	   788: 
                            	   789: clear_screen:
02:00004E98 48E7E080        	   790: 	movem.l	d0/d1/d2/a0,-(a7)
02:00004E9C 4E7A0FE0        	   791: 	movec		coreno,d0
02:00004EA0 4840            	   792: 	swap		d0	
02:00004EA2 7205            	   793: 	moveq		#SCREEN_SEMA,d1
02:00004EA4 6100B3F0        	   794: 	bsr			LockSemaphore
02:00004EA8 61E6            	   795: 	bsr			get_screen_address	; a0 = pointer to screen area
02:00004EAA 10390004008C    	   796: 	move.b	TextRows,d0					; d0 = rows
02:00004EB0 14390004008D    	   797: 	move.b	TextCols,d2					; d2 = cols
02:00004EB6 4880            	   798: 	ext.w		d0									; convert to word
02:00004EB8 4882            	   799: 	ext.w		d2									; convert to word
02:00004EBA C4C0            	   800: 	mulu		d0,d2								; d2 = number of character cells to clear
02:00004EBC 61A6            	   801: 	bsr			get_screen_color		; get the color bits
02:00004EBE 00410020        	   802: 	ori.w		#32,d1							; load space character
02:00004EC2 E159            	   803: 	rol.w		#8,d1								; swap endian, text controller expects little endian
02:00004EC4 4841            	   804: 	swap		d1
02:00004EC6 E159            	   805: 	rol.w		#8,d1
02:00004EC8 E158            	   806: 	rol.w		#8,d0								; swap endian
02:00004ECA 4840            	   807: 	swap		d0
02:00004ECC E158            	   808: 	rol.w		#8,d0
                            	   809: loop3:
02:00004ECE 20C1            	   810: 	move.l	d1,(a0)+						; copy char plus bkcolor to cell
02:00004ED0 20C0            	   811: 	move.l	d0,(a0)+					; copy fgcolor to cell
02:00004ED2 51CAFFFA        	   812: 	dbra		d2,loop3
02:00004ED6 4E7A0FE0        	   813: 	movec		coreno,d0
02:00004EDA 4840            	   814: 	swap		d0	
02:00004EDC 7205            	   815: 	moveq		#SCREEN_SEMA,d1
02:00004EDE 6100B3F0        	   816: 	bsr			UnlockSemaphore
02:00004EE2 4CDF0107        	   817: 	movem.l	(a7)+,d0/d1/d2/a0
02:00004EE6 4E75            	   818: 	rts
                            	   819: 
                            	   820: CRLF:
02:00004EE8 2F01            	   821: 	move.l	d1,-(a7)
02:00004EEA 123C000D        	   822: 	move.b	#13,d1
02:00004EEE 6142            	   823: 	bsr			DisplayChar
02:00004EF0 123C000A        	   824: 	move.b	#10,d1
02:00004EF4 613C            	   825: 	bsr			DisplayChar
02:00004EF6 221F            	   826: 	move.l	(a7)+,d1
02:00004EF8 4E75            	   827: 	rts
                            	   828: 
                            	   829: ;------------------------------------------------------------------------------
                            	   830: ;------------------------------------------------------------------------------
                            	   831: 
                            	   832: UpdateTextPos:
02:00004EFA 103900040000    	   833: 	move.b	CursorRow,d0		; compute screen location
02:00004F00 0240007F        	   834: 	andi.w	#$7f,d0
02:00004F04 14390004008D    	   835: 	move.b	TextCols,d2
02:00004F0A 4882            	   836: 	ext.w		d2
02:00004F0C C0C2            	   837: 	mulu.w	d2,d0
02:00004F0E 2600            	   838: 	move.l	d0,d3
02:00004F10 143900040001    	   839: 	move.b	CursorCol,d2
02:00004F16 024200FF        	   840: 	andi.w	#$ff,d2
02:00004F1A D042            	   841: 	add.w		d2,d0
02:00004F1C 33C000040002    	   842: 	move.w	d0,TextPos			; save cursor pos
02:00004F22 4E75            	   843: 	rts
                            	   844: 
                            	   845: ;------------------------------------------------------------------------------
                            	   846: ; Calculate screen memory location from CursorRow,CursorCol.
                            	   847: ; Destroys d0,d2,a0
                            	   848: ;------------------------------------------------------------------------------
                            	   849: 
                            	   850: CalcScreenLoc:
02:00004F24 61D4            	   851: 	bsr			UpdateTextPos
02:00004F26 48C0            	   852: 	ext.l		d0								; make it into a long
02:00004F28 E780            	   853: 	asl.l		#3,d0							; 8 bytes per char
02:00004F2A 6100FF64        	   854: 	bsr			get_screen_address
02:00004F2E D1C0            	   855: 	add.l		d0,a0							; a0 = screen location
02:00004F30 4E75            	   856: 	rts
                            	   857: 
                            	   858: ;------------------------------------------------------------------------------
                            	   859: ; Display a character on the screen
                            	   860: ; d1.b = char to display
                            	   861: ;------------------------------------------------------------------------------
                            	   862: 
                            	   863: DisplayChar:
02:00004F32 48E77000        	   864: 	movem.l	d1/d2/d3,-(a7)
02:00004F36 4E7A2FE0        	   865: 	movec		coreno,d2
02:00004F3A 0C020002        	   866: 	cmpi.b	#2,d2
                            	   867: ;	bne.s		.0001
                            	   868: ;	bsr			SerialPutChar
                            	   869: .0001:
02:00004F3E 0281000000FF    	   870: 	andi.l	#$ff,d1				; zero out upper bytes of d1
02:00004F44 0C01000D        	   871: 	cmpi.b	#13,d1				; carriage return ?
02:00004F48 6610            	   872: 	bne			dccr
02:00004F4A 423900040001    	   873: 	clr.b		CursorCol			; just set cursor column to zero on a CR
                            	   874: dcx14:
02:00004F50 610002AE        	   875: 	bsr			SyncCursor		; set position in text controller
                            	   876: dcx7:
02:00004F54 4CDF000E        	   877: 	movem.l	(a7)+,d1/d2/d3
02:00004F58 4E75            	   878: 	rts
                            	   879: dccr:
02:00004F5A 0C010091        	   880: 	cmpi.b	#$91,d1			; cursor right ?
02:00004F5E 6618            	   881: 	bne.s   dcx6
02:00004F60 14390004008D    	   882: 	move.b	TextCols,d2
02:00004F66 5302            	   883: 	sub.b		#1,d2
02:00004F68 943900040001    	   884: 	sub.b		CursorCol,d2
02:00004F6E 67E4            	   885: 	beq.s		dcx7
02:00004F70 523900040001    	   886: 	addi.b	#1,CursorCol
02:00004F76 60D8            	   887: 	bra.s		dcx14
                            	   888: dcx6:
02:00004F78 0C010090        	   889: 	cmpi.b	#$90,d1			; cursor up ?
02:00004F7C 6610            	   890: 	bne.s		dcx8
02:00004F7E 4A3900040000    	   891: 	cmpi.b	#0,CursorRow
02:00004F84 67CE            	   892: 	beq.s		dcx7
02:00004F86 533900040000    	   893: 	subi.b	#1,CursorRow
02:00004F8C 60C2            	   894: 	bra.s		dcx14
                            	   895: dcx8:
02:00004F8E 0C010093        	   896: 	cmpi.b	#$93,d1			; cursor left?
02:00004F92 6610            	   897: 	bne.s		dcx9
02:00004F94 4A3900040001    	   898: 	cmpi.b	#0,CursorCol
02:00004F9A 67B8            	   899: 	beq.s		dcx7
02:00004F9C 533900040001    	   900: 	subi.b	#1,CursorCol
02:00004FA2 60AC            	   901: 	bra.s		dcx14
                            	   902: dcx9:
02:00004FA4 0C010092        	   903: 	cmpi.b	#$92,d1			; cursor down ?
02:00004FA8 6618            	   904: 	bne.s		dcx10
02:00004FAA 14390004008C    	   905: 	move.b	TextRows,d2
02:00004FB0 5302            	   906: 	sub.b		#1,d2
02:00004FB2 B43900040000    	   907: 	cmp.b		CursorRow,d2
02:00004FB8 679A            	   908: 	beq.s		dcx7
02:00004FBA 523900040000    	   909: 	addi.b	#1,CursorRow
02:00004FC0 608E            	   910: 	bra.s		dcx14
                            	   911: dcx10:
02:00004FC2 0C010094        	   912: 	cmpi.b	#$94,d1			; cursor home ?
02:00004FC6 661C            	   913: 	bne.s		dcx11
02:00004FC8 4A3900040001    	   914: 	cmpi.b	#0,CursorCol
02:00004FCE 670A            	   915: 	beq.s		dcx12
02:00004FD0 423900040001    	   916: 	clr.b		CursorCol
02:00004FD6 6000FF78        	   917: 	bra			dcx14
                            	   918: dcx12:
02:00004FDA 423900040000    	   919: 	clr.b		CursorRow
02:00004FE0 6000FF6E        	   920: 	bra			dcx14
                            	   921: dcx11:
02:00004FE4 48E7E080        	   922: 	movem.l	d0/d1/d2/a0,-(a7)
02:00004FE8 0C010099        	   923: 	cmpi.b	#$99,d1			; delete ?
02:00004FEC 675C            	   924: 	beq.s		doDelete
02:00004FEE 0C010008        	   925: 	cmpi.b	#CTRLH,d1			; backspace ?
02:00004FF2 6748            	   926: 	beq.s   doBackspace
02:00004FF4 0C010018        	   927: 	cmpi.b	#CTRLX,d1			; delete line ?
02:00004FF8 6700008C        	   928: 	beq			doCtrlX
02:00004FFC 0C01000A        	   929: 	cmpi.b	#10,d1		; linefeed ?
02:00005000 6728            	   930: 	beq.s		dclf
                            	   931: 
                            	   932: 	; regular char
02:00005002 6100FF20        	   933: 	bsr			CalcScreenLoc	; a0 = screen location
02:00005006 2401            	   934: 	move.l	d1,d2					; d2 = char
02:00005008 6100FE5A        	   935: 	bsr			get_screen_color	; d0,d1 = color
02:0000500C 8282            	   936: 	or.l		d2,d1					; d1 = char + color
02:0000500E E159            	   937: 	rol.w		#8,d1					; text controller expects little endian data
02:00005010 4841            	   938: 	swap		d1
02:00005012 E159            	   939: 	rol.w		#8,d1
02:00005014 2081            	   940: 	move.l	d1,(a0)
02:00005016 E158            	   941: 	rol.w		#8,d0					; swap bytes
02:00005018 4840            	   942: 	swap		d0						; swap halfs
02:0000501A E158            	   943: 	rol.w		#8,d0					; swap remaining bytes
02:0000501C 21400004        	   944: 	move.l	d0,4(a0)
02:00005020 61000088        	   945: 	bsr			IncCursorPos
02:00005024 610001DA        	   946: 	bsr			SyncCursor
02:00005028 6008            	   947: 	bra			dcx4
                            	   948: dclf:
02:0000502A 6100009E        	   949: 	bsr			IncCursorRow
                            	   950: dcx16:
02:0000502E 610001D0        	   951: 	bsr			SyncCursor
                            	   952: dcx4:
02:00005032 4CDF0107        	   953: 	movem.l	(a7)+,d0/d1/d2/a0		; get back a0
02:00005036 4CDF000E        	   954: 	movem.l	(a7)+,d1/d2/d3
02:0000503A 4E75            	   955: 	rts
                            	   956: 
                            	   957: 	;---------------------------
                            	   958: 	; CTRL-H: backspace
                            	   959: 	;---------------------------
                            	   960: doBackspace:
02:0000503C 4A3900040001    	   961: 	cmpi.b	#0,CursorCol		; if already at start of line
02:00005042 67EE            	   962: 	beq.s   dcx4						; nothing to do
02:00005044 533900040001    	   963: 	subi.b	#1,CursorCol		; decrement column
                            	   964: 
                            	   965: 	;---------------------------
                            	   966: 	; Delete key
                            	   967: 	;---------------------------
                            	   968: doDelete:
02:0000504A 48E7C080        	   969: 	movem.l	d0/d1/a0,-(a7)	; save off screen location
02:0000504E 6100FED4        	   970: 	bsr		  CalcScreenLoc		; a0 = screen location
02:00005052 103900040001    	   971: 	move.b	CursorCol,d0
                            	   972: .0001:
02:00005058 20A80008        	   973: 	move.l	8(a0),(a0)		; pull remaining characters on line over 1
02:0000505C 2168000C0004    	   974: 	move.l	12(a0),4(a0)	; pull remaining characters on line over 1
02:00005062 5088            	   975: 	lea			8(a0),a0
02:00005064 5200            	   976: 	addi.b	#1,d0
02:00005066 B0390004008D    	   977: 	cmp.b		TextCols,d0
02:0000506C 65EA            	   978: 	blo.s		.0001
02:0000506E 6100FDF4        	   979: 	bsr			get_screen_color
02:00005072 323C0020        	   980: 	move.w	#' ',d1				; terminate line with a space
02:00005076 E159            	   981: 	rol.w		#8,d1
02:00005078 4841            	   982: 	swap		d1
02:0000507A E159            	   983: 	rol.w		#8,d1
02:0000507C 2141FFF8        	   984: 	move.l	d1,-8(a0)
02:00005080 4CDF0103        	   985: 	movem.l	(a7)+,d0/d1/a0
02:00005084 60A8            	   986: 	bra.s		dcx16				; finished
                            	   987: 
                            	   988: 	;---------------------------
                            	   989: 	; CTRL-X: erase line
                            	   990: 	;---------------------------
                            	   991: doCtrlX:
02:00005086 423900040001    	   992: 	clr.b		CursorCol			; Reset cursor to start of line
02:0000508C 10390004008D    	   993: 	move.b	TextCols,d0			; and display TextCols number of spaces
02:00005092 4880            	   994: 	ext.w		d0
02:00005094 48C0            	   995: 	ext.l		d0
02:00005096 123C0020        	   996: 	move.b	#' ',d1				; d1 = space char
                            	   997: .0001:
                            	   998: 	; DisplayChar is called recursively here
                            	   999: 	; It's safe to do because we know it won't recurse again due to the
                            	  1000: 	; fact we know the character being displayed is a space char
02:0000509A 6100FE96        	  1001: 	bsr		DisplayChar			
02:0000509E 5340            	  1002: 	subq	#1,d0
02:000050A0 66F8            	  1003: 	bne.s	.0001
02:000050A2 423900040001    	  1004: 	clr.b	CursorCol			; now really go back to start of line
02:000050A8 6084            	  1005: 	bra.s	dcx16				; we're done
                            	  1006: 
                            	  1007: ;------------------------------------------------------------------------------
                            	  1008: ; Increment the cursor position, scroll the screen if needed.
                            	  1009: ;------------------------------------------------------------------------------
                            	  1010: 
                            	  1011: IncCursorPos:
02:000050AA 527900040002    	  1012: 	addi.w	#1,TextCurpos
02:000050B0 523900040001    	  1013: 	addi.b	#1,CursorCol
02:000050B6 10390004008D    	  1014: 	move.b	TextCols,d0
02:000050BC B03900040001    	  1015: 	cmp.b		CursorCol,d0
02:000050C2 6438            	  1016: 	bhs.s		icc1
02:000050C4 423900040001    	  1017: 	clr.b		CursorCol
                            	  1018: IncCursorRow:
02:000050CA 523900040000    	  1019: 	addi.b	#1,CursorRow
02:000050D0 10390004008C    	  1020: 	move.b	TextRows,d0
02:000050D6 B03900040000    	  1021: 	cmp.b		CursorRow,d0
02:000050DC 621E            	  1022: 	bhi.s		icc1
02:000050DE 10390004008C    	  1023: 	move.b	TextRows,d0
02:000050E4 13C000040000    	  1024: 	move.b	d0,CursorRow		; in case CursorRow is way over
02:000050EA 533900040000    	  1025: 	subi.b	#1,CursorRow
02:000050F0 4880            	  1026: 	ext.w		d0
02:000050F2 D040            	  1027: 	asl.w		#1,d0
02:000050F4 917900040002    	  1028: 	sub.w		d0,TextCurpos
02:000050FA 6102            	  1029: 	bsr			ScrollUp
                            	  1030: icc1:
02:000050FC 4E75            	  1031: 	rts
                            	  1032: 
                            	  1033: ;------------------------------------------------------------------------------
                            	  1034: ; Scroll screen up.
                            	  1035: ;------------------------------------------------------------------------------
                            	  1036: 
                            	  1037: ScrollUp:
02:000050FE 48E7C084        	  1038: 	movem.l	d0/d1/a0/a5,-(a7)		; save off some regs
02:00005102 4E7A0FE0        	  1039: 	movec		coreno,d0
02:00005106 4840            	  1040: 	swap		d0	
02:00005108 7205            	  1041: 	moveq		#SCREEN_SEMA,d1
02:0000510A 6100B18A        	  1042: 	bsr			LockSemaphore
02:0000510E 6100FD80        	  1043: 	bsr			get_screen_address
02:00005112 2A48            	  1044: 	move.l	a0,a5								; a5 = pointer to text screen
                            	  1045: .0003:								
02:00005114 10390004008D    	  1046: 	move.b	TextCols,d0					; d0 = columns
02:0000511A 12390004008C    	  1047: 	move.b	TextRows,d1					; d1 = rows
02:00005120 4880            	  1048: 	ext.w		d0									; make cols into a word value
02:00005122 4881            	  1049: 	ext.w		d1									; make rows into a word value
02:00005124 E740            	  1050: 	asl.w		#3,d0								; make into cell index
02:00005126 41F50000        	  1051: 	lea			0(a5,d0.w),a0				; a0 = pointer to second row of text screen
02:0000512A E648            	  1052: 	lsr.w		#3,d0								; get back d0
02:0000512C 5341            	  1053: 	subq		#1,d1								; number of rows-1
02:0000512E C0C1            	  1054: 	mulu		d1,d0								; d0 = count of characters to move
                            	  1055: .0001:
02:00005130 2AD8            	  1056: 	move.l	(a0)+,(a5)+					; each char is 64 bits
02:00005132 2AD8            	  1057: 	move.l	(a0)+,(a5)+	
02:00005134 51C8FFFA        	  1058: 	dbra		d0,.0001
02:00005138 4E7A0FE0        	  1059: 	movec		coreno,d0
02:0000513C 4840            	  1060: 	swap		d0	
02:0000513E 7205            	  1061: 	moveq		#SCREEN_SEMA,d1
02:00005140 6100B18E        	  1062: 	bsr			UnlockSemaphore
02:00005144 4CDF2103        	  1063: 	movem.l	(a7)+,d0/d1/a0/a5
                            	  1064: 	; Fall through into blanking out last line
                            	  1065: 
                            	  1066: ;------------------------------------------------------------------------------
                            	  1067: ; Blank out the last line on the screen.
                            	  1068: ;------------------------------------------------------------------------------
                            	  1069: 
                            	  1070: BlankLastLine:
02:00005148 48E7E080        	  1071: 	movem.l	d0/d1/d2/a0,-(a7)
02:0000514C 4E7A0FE0        	  1072: 	movec		coreno,d0
02:00005150 4840            	  1073: 	swap		d0	
02:00005152 7205            	  1074: 	moveq		#SCREEN_SEMA,d1
02:00005154 6100B140        	  1075: 	bsr			LockSemaphore
02:00005158 6100FD36        	  1076: 	bsr			get_screen_address
02:0000515C 10390004008C    	  1077: 	move.b	TextRows,d0					; d0 = rows
02:00005162 12390004008D    	  1078: 	move.b	TextCols,d1					; d1 = columns
02:00005168 4880            	  1079: 	ext.w		d0
02:0000516A 4881            	  1080: 	ext.w		d1
02:0000516C 5340            	  1081: 	subq		#1,d0								; last row = #rows-1
02:0000516E C0C1            	  1082: 	mulu		d1,d0								; d0 = index of last line
02:00005170 E748            	  1083: 	lsl.w		#3,d0								; *8 bytes per char
02:00005172 41F00000        	  1084: 	lea			(a0,d0.w),a0				; point a0 to last row
02:00005176 14390004008D    	  1085: 	move.b	TextCols,d2					; number of text cells to clear
02:0000517C 4882            	  1086: 	ext.w		d2
02:0000517E 5342            	  1087: 	subi.w	#1,d2								; count must be one less than desired
02:00005180 6100FCE2        	  1088: 	bsr			get_screen_color		; d0,d1 = screen color
02:00005184 323C0020        	  1089: 	move.w	#32,d1							; set the character for display in low 16 bits
02:00005188 610014B4        	  1090: 	bsr			rbo									; reverse the byte order
02:0000518C E158            	  1091: 	rol.w		#8,d0
02:0000518E 4840            	  1092: 	swap		d0
02:00005190 E158            	  1093: 	rol.w		#8,d0
                            	  1094: .0001:
02:00005192 20C0            	  1095: 	move.l	d0,(a0)+
02:00005194 20C1            	  1096: 	move.l	d1,(a0)+
02:00005196 51CAFFFA        	  1097: 	dbra		d2,.0001
02:0000519A 4E7A0FE0        	  1098: 	movec		coreno,d0
02:0000519E 4840            	  1099: 	swap		d0	
02:000051A0 7205            	  1100: 	moveq		#SCREEN_SEMA,d1
02:000051A2 6100B12C        	  1101: 	bsr			UnlockSemaphore
02:000051A6 4CDF0107        	  1102: 	movem.l	(a7)+,d0/d1/d2/a0
02:000051AA 4E75            	  1103: 	rts
                            	  1104: 
                            	  1105: ;------------------------------------------------------------------------------
                            	  1106: ; Display a string on the screen.
                            	  1107: ;------------------------------------------------------------------------------
                            	  1108: 
                            	  1109: DisplayString:
02:000051AC 48E7C040        	  1110: 	movem.l	d0/d1/a1,-(a7)
                            	  1111: dspj1:
02:000051B0 7200            	  1112: 	clr.l		d1						; clear upper bits of d1
02:000051B2 1219            	  1113: 	move.b	(a1)+,d1			; move string char into d1
02:000051B4 6706            	  1114: 	beq.s		dsret					; is it end of string ?
02:000051B6 6100FD7A        	  1115: 	bsr			DisplayChar		; display character
02:000051BA 60F4            	  1116: 	bra.s		dspj1					; go back for next character
                            	  1117: dsret:
02:000051BC 4CDF0203        	  1118: 	movem.l	(a7)+,d0/d1/a1
02:000051C0 4E75            	  1119: 	rts
                            	  1120: 
                            	  1121: ;------------------------------------------------------------------------------
                            	  1122: ; Display a string on the screen followed by carriage return / linefeed.
                            	  1123: ;------------------------------------------------------------------------------
                            	  1124: 
                            	  1125: DisplayStringCRLF:
02:000051C2 61E8            	  1126: 	bsr		DisplayString
02:000051C4 6000FD22        	  1127: 	bra		CRLF
                            	  1128: 
                            	  1129: ;------------------------------------------------------------------------------
                            	  1130: ; Display a string on the screen limited to 255 chars max.
                            	  1131: ;------------------------------------------------------------------------------
                            	  1132: 
                            	  1133: DisplayStringLimited:
02:000051C8 48E7E040        	  1134: 	movem.l	d0/d1/d2/a1,-(a7)
02:000051CC 3401            	  1135: 	move.w	d1,d2					; d2 = max count
02:000051CE 024200FF        	  1136: 	andi.w	#$00FF,d2			; limit to 255 chars
02:000051D2 600A            	  1137: 	bra.s		.0003					; enter loop at bottom
                            	  1138: .0001:
02:000051D4 7200            	  1139: 	clr.l		d1						; clear upper bits of d1
02:000051D6 1219            	  1140: 	move.b	(a1)+,d1			; move string char into d1
02:000051D8 6708            	  1141: 	beq.s		.0002					; is it end of string ?
02:000051DA 6100FD56        	  1142: 	bsr			DisplayChar		; display character
                            	  1143: .0003:
02:000051DE 51CAFFF4        	  1144: 	dbra		d2,.0001			; go back for next character
                            	  1145: .0002:
02:000051E2 4CDF0207        	  1146: 	movem.l	(a7)+,d0/d1/d2/a1
02:000051E6 4E75            	  1147: 	rts
                            	  1148: 
                            	  1149: DisplayStringLimitedCRLF:
02:000051E8 61DE            	  1150: 	bsr		DisplayStringLimited
02:000051EA 6000FCFC        	  1151: 	bra		CRLF
                            	  1152: 	
                            	  1153: ;------------------------------------------------------------------------------
                            	  1154: ; Set cursor position to top left of screen.
                            	  1155: ;
                            	  1156: ; Parameters:
                            	  1157: ;		<none>
                            	  1158: ; Returns:
                            	  1159: ;		<none>
                            	  1160: ; Registers Affected:
                            	  1161: ;		<none>
                            	  1162: ;------------------------------------------------------------------------------
                            	  1163: 
                            	  1164: HomeCursor:
02:000051EE 423900040000    	  1165: 	clr.b		CursorRow
02:000051F4 423900040001    	  1166: 	clr.b		CursorCol
02:000051FA 427900040002    	  1167: 	clr.w		TextPos
                            	  1168: 	; fall through
                            	  1169: 
                            	  1170: ;------------------------------------------------------------------------------
                            	  1171: ; SyncCursor:
                            	  1172: ;
                            	  1173: ; Sync the hardware cursor's position to the text cursor position but only for
                            	  1174: ; the core with the IO focus.
                            	  1175: ;
                            	  1176: ; Parameters:
                            	  1177: ;		<none>
                            	  1178: ; Returns:
                            	  1179: ;		<none>
                            	  1180: ; Registers Affected:
                            	  1181: ;		<none>
                            	  1182: ;------------------------------------------------------------------------------
                            	  1183: 
                            	  1184: SyncCursor:
02:00005200 48E7A000        	  1185: 	movem.l	d0/d2,-(a7)
02:00005204 6100FCF4        	  1186: 	bsr			UpdateTextPos
02:00005208 4E7A2FE0        	  1187: 	movec		coreno,d2
02:0000520C B43900100000    	  1188: 	cmp.b		IOFocus,d2
02:00005212 6610            	  1189: 	bne.s		.0001
02:00005214 5542            	  1190: 	subi.w	#2,d2						; factor in location of screen in controller
02:00005216 C4FC0800        	  1191: 	mulu		#2048,d2				; 2048 cells per screen
02:0000521A D042            	  1192: 	add.w		d2,d0
02:0000521C E158            	  1193: 	rol.w		#8,d0						; swap byte order
02:0000521E 33C0FD03FF24    	  1194: 	move.w	d0,TEXTREG+$24
                            	  1195: .0001:	
02:00005224 4CDF0005        	  1196: 	movem.l	(a7)+,d0/d2
02:00005228 4E75            	  1197: 	rts
                            	  1198: 
                            	  1199: ;==============================================================================
                            	  1200: ; TRAP #15 handler
                            	  1201: ;
                            	  1202: ; Parameters:
                            	  1203: ;		d0.w = function number to perform
                            	  1204: ;==============================================================================
                            	  1205: 
                            	  1206: TRAP15:
02:0000522A 48E78080        	  1207: 	movem.l	d0/a0,-(a7)
02:0000522E 41FA0010        	  1208: 	lea			T15DispatchTable,a0
02:00005232 E580            	  1209: 	asl.l		#2,d0
02:00005234 20700000        	  1210: 	move.l	(a0,d0.w),a0
02:00005238 4E90            	  1211: 	jsr			(a0)
02:0000523A 4CDF0101        	  1212: 	movem.l	(a7)+,d0/a0
02:0000523E 4E73            	  1213: 	rte
                            	  1214: 
                            	  1215: 		align	2
                            	  1216: T15DispatchTable:
02:00005240 000051E8        	  1217: 	dc.l	DisplayStringLimitedCRLF
02:00005244 000051C8        	  1218: 	dc.l	DisplayStringLimited
02:00005248 00005316        	  1219: 	dc.l	StubRout
02:0000524C 00005316        	  1220: 	dc.l	StubRout
02:00005250 00005316        	  1221: 	dc.l	StubRout
02:00005254 0000556A        	  1222: 	dc.l	GetKey
02:00005258 00004F32        	  1223: 	dc.l	DisplayChar
02:0000525C 0000555E        	  1224: 	dc.l	CheckForKey
02:00005260 00005316        	  1225: 	dc.l	StubRout
02:00005264 00005316        	  1226: 	dc.l	StubRout
                            	  1227: 	; 10
02:00005268 00005316        	  1228: 	dc.l	StubRout
02:0000526C 000052E0        	  1229: 	dc.l	Cursor1
02:00005270 00005556        	  1230: 	dc.l	SetKeyboardEcho
02:00005274 000051C2        	  1231: 	dc.l	DisplayStringCRLF
02:00005278 000051AC        	  1232: 	dc.l	DisplayString
02:0000527C 00005316        	  1233: 	dc.l	StubRout
02:00005280 00005316        	  1234: 	dc.l	StubRout
02:00005284 00005316        	  1235: 	dc.l	StubRout
02:00005288 00005316        	  1236: 	dc.l	StubRout
02:0000528C 00005316        	  1237: 	dc.l	StubRout
                            	  1238: 	; 20
02:00005290 00005316        	  1239: 	dc.l	StubRout
02:00005294 00005316        	  1240: 	dc.l	StubRout
02:00005298 00005316        	  1241: 	dc.l	StubRout
02:0000529C 00005316        	  1242: 	dc.l	StubRout
02:000052A0 00005316        	  1243: 	dc.l	StubRout
02:000052A4 00005316        	  1244: 	dc.l	StubRout
02:000052A8 00005316        	  1245: 	dc.l	StubRout
02:000052AC 00005316        	  1246: 	dc.l	StubRout
02:000052B0 00005316        	  1247: 	dc.l	StubRout
02:000052B4 00005316        	  1248: 	dc.l	StubRout
                            	  1249: 	; 30
02:000052B8 00005316        	  1250: 	dc.l	StubRout
02:000052BC 00005316        	  1251: 	dc.l	StubRout
02:000052C0 0000532A        	  1252: 	dc.l	rotate_iofocus
02:000052C4 00006728        	  1253: 	dc.l	SerialPeekCharDirect
02:000052C8 00006742        	  1254: 	dc.l	SerialPutChar
02:000052CC 000066F0        	  1255: 	dc.l	SerialPeekChar
02:000052D0 00006678        	  1256: 	dc.l	SerialGetChar
02:000052D4 000002EA        	  1257: 	dc.l	T15LockSemaphore
02:000052D8 000002F6        	  1258: 	dc.l	T15UnlockSemaphore
02:000052DC 00005316        	  1259: 	dc.l	StubRout
                            	  1260: 
                            	  1261: ;------------------------------------------------------------------------------
                            	  1262: ; Cursor positioning / Clear screen
                            	  1263: ; - out of range settings are ignored
                            	  1264: ;
                            	  1265: ; Parameters:
                            	  1266: ;		d1.w cursor position, bits 0 to 7 are row, bits 8 to 15 are column.
                            	  1267: ;	Returns:
                            	  1268: ;		none
                            	  1269: ;------------------------------------------------------------------------------
                            	  1270: 
                            	  1271: Cursor1:
02:000052E0 2F01            	  1272: 	move.l		d1,-(a7)
02:000052E2 0C41FF00        	  1273: 	cmpi.w		#$FF00,d1
02:000052E6 6608            	  1274: 	bne.s			.0002
02:000052E8 6100FBAE        	  1275: 	bsr				clear_screen
02:000052EC 6000FF00        	  1276: 	bra				HomeCursor
                            	  1277: .0002:
02:000052F0 B2390004008C    	  1278: 	cmp.b			TextRows,d1		; if cursor pos out of range, ignore setting
02:000052F6 6406            	  1279: 	bhs.s			.0003
02:000052F8 13C100040000    	  1280: 	move.b		d1,CursorRow
                            	  1281: .0003:
02:000052FE E059            	  1282: 	ror.w			#8,d1
02:00005300 B2390004008D    	  1283: 	cmp.b			TextCols,d1
02:00005306 6406            	  1284: 	bhs.s			.0001
02:00005308 13C100040001    	  1285: 	move.b		d1,CursorCol
                            	  1286: .0001:
02:0000530E 6100FEF0        	  1287: 	bsr				SyncCursor		; update hardware cursor
02:00005312 221F            	  1288: 	move.l		(a7)+,d1
02:00005314 4E75            	  1289: 	rts
                            	  1290: 
                            	  1291: ;------------------------------------------------------------------------------
                            	  1292: ; Stub routine for unimplemented functionality.
                            	  1293: ;------------------------------------------------------------------------------
                            	  1294: 
                            	  1295: StubRout:
02:00005316 4E75            	  1296: 	rts
                            	  1297: 
                            	  1298: ;------------------------------------------------------------------------------
                            	  1299: ; Select a specific IO focus.
                            	  1300: ;------------------------------------------------------------------------------
                            	  1301: 
                            	  1302: select_iofocus:
02:00005318 0C010002        	  1303: 	cmpi.b	#2,d1
02:0000531C 650A            	  1304: 	blo.s		.0001
02:0000531E 0C010009        	  1305: 	cmpi.b	#9,d1
02:00005322 6204            	  1306: 	bhi.s		.0001
02:00005324 2001            	  1307: 	move.l	d1,d0
02:00005326 6014            	  1308: 	bra.s		select_focus1
                            	  1309: .0001:
02:00005328 4E75            	  1310: 	rts
                            	  1311: 
                            	  1312: ;------------------------------------------------------------------------------
                            	  1313: ; Rotate the IO focus, done when ALT-Tab is pressed.
                            	  1314: ;
                            	  1315: ; Modifies:
                            	  1316: ;		d0, IOFocus BIOS variable
                            	  1317: ;------------------------------------------------------------------------------
                            	  1318: 
                            	  1319: rotate_iofocus:
02:0000532A 103900100000    	  1320: 	move.b	IOFocus,d0				; d0 = focus, we can trash d0
02:00005330 5200            	  1321: 	add.b		#1,d0							; increment the focus
02:00005332 B03C0009        	  1322: 	cmp.b		#9,d0							; limit to 2 to 9
02:00005336 6304            	  1323: 	bls.s		.0001
02:00005338 103C0002        	  1324: 	move.b	#2,d0
                            	  1325: .0001:
                            	  1326: select_focus1:
02:0000533C 13C000100000    	  1327: 	move.b	d0,IOFocus				; set IO focus
02:00005342 5500            	  1328: 	subi.b	#2,d0							; screen is 0 to 7, focus is 2 to 9
02:00005344 4880            	  1329: 	ext.w		d0								; make into long value
02:00005346 C0FC0800        	  1330: 	mulu		#2048,d0					; * 2048	cells per screen
02:0000534A E158            	  1331: 	rol.w		#8,d0							; swap byte order
02:0000534C 33C0FD03FF28    	  1332: 	move.w	d0,TEXTREG+$28		; update screen address in text controller
02:00005352 6000FEAC        	  1333: 	bra			SyncCursor				; set cursor position
                            	  1334: 
                            	  1335: ;==============================================================================
                            	  1336: ; PLIC - platform level interrupt controller
                            	  1337: ;
                            	  1338: ; Register layout:
                            	  1339: ;   bits 0 to 7  = cause code to issue (vector number)
                            	  1340: ;   bits 8 to 11 = irq level to issue
                            	  1341: ;   bit 16 = irq enable
                            	  1342: ;   bit 17 = edge sensitivity
                            	  1343: ;   bit 18 = 0=vpa, 1=inta
                            	  1344: ;		bit 24 to 29 target core
                            	  1345: ;
                            	  1346: ; Note byte order must be reversed for PLIC.
                            	  1347: ;==============================================================================
                            	  1348: 
                            	  1349: init_plic:
02:00005356 41F9FD090000    	  1350: 	lea		PLIC,a0						; a0 points to PLIC
02:0000535C 43E800F4        	  1351: 	lea		$80+4*29(a0),a1		; point to timer registers (29)
02:00005360 22BC0006033F    	  1352: 	move.l	#$0006033F,(a1)	; initialize, core=63,edge sensitive,enabled,irq6,vpa
02:00005366 5889            	  1353: 	lea			4(a1),a1				; point to keyboard registers (30)
02:00005368 22BC3C060502    	  1354: 	move.l	#$3C060502,(a1)	; core=2,level sensitive,enabled,irq6,inta
02:0000536E 5889            	  1355: 	lea			4(a1),a1				; point to nmi button register (31)
02:00005370 22BC00070302    	  1356: 	move.l	#$00070302,(a1)	; initialize, core=2,edge sensitive,enabled,irq7,vpa
02:00005376 43E800C0        	  1357: 	lea		$80+4*16(a0),a1		; a1 points to ACIA register
02:0000537A 22BC3D030502    	  1358: 	move.l	#$3D030502,(a1)	; core=2,level sensitive,enabled,irq3,inta	
02:00005380 43E80090        	  1359: 	lea		$80+4*4(a0),a1		; a1 points to io_bitmap irq
02:00005384 22BC3B060702    	  1360: 	move.l	#$3B060702,(a1)	; core=2,edge sensitive,enabled,irq6,inta	
02:0000538A 4E75            	  1361: 	rts
                            	  1362: 
                            	  1363: ;==============================================================================
                            	  1364: ; Keyboard stuff
                            	  1365: ;
                            	  1366: ; KeyState2_
                            	  1367: ; 876543210
                            	  1368: ; ||||||||+ = shift
                            	  1369: ; |||||||+- = alt
                            	  1370: ; ||||||+-- = control
                            	  1371: ; |||||+--- = numlock
                            	  1372: ; ||||+---- = capslock
                            	  1373: ; |||+----- = scrolllock
                            	  1374: ; ||+------ =
                            	  1375: ; |+------- = 
                            	  1376: ; +-------- = extended
                            	  1377: ;
                            	  1378: ;==============================================================================
                            	  1379: 
                            	  1380: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1381: ; Get ID - get the keyboards identifier code.
                            	  1382: ;
                            	  1383: ; Parameters: none
                            	  1384: ; Returns: d = $AB83, $00 on fail
                            	  1385: ; Modifies: d, KeybdID updated
                            	  1386: ; Stack Space: 2 words
                            	  1387: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1388: 
                            	  1389: KeybdGetID:
02:0000538C 323C00F2        	  1390: 	move.w	#$F2,d1
02:00005390 61000494        	  1391: 	bsr			KeybdSendByte
02:00005394 6100019A        	  1392: 	bsr			KeybdWaitTx
02:00005398 61000176        	  1393: 	bsr			KeybdRecvByte
02:0000539C 08010007        	  1394: 	btst		#7,d1
02:000053A0 6624            	  1395: 	bne			kgnotKbd
02:000053A2 0C0100AB        	  1396: 	cmpi.b	#$AB,d1
02:000053A6 661E            	  1397: 	bne			kgnotKbd
02:000053A8 61000166        	  1398: 	bsr			KeybdRecvByte
02:000053AC 08010007        	  1399: 	btst		#7,d1
02:000053B0 6614            	  1400: 	bne			kgnotKbd
02:000053B2 0C010083        	  1401: 	cmpi.b	#$83,d1
02:000053B6 660E            	  1402: 	bne			kgnotKbd
02:000053B8 223C0000AB83    	  1403: 	move.l	#$AB83,d1
                            	  1404: kgid1:
02:000053BE 33C100100016    	  1405: 	move.w	d1,KeybdID
02:000053C4 4E75            	  1406: 	rts
                            	  1407: kgnotKbd:
02:000053C6 7200            	  1408: 	moveq		#0,d1
02:000053C8 60F4            	  1409: 	bra			kgid1
                            	  1410: 
                            	  1411: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1412: ; Set the LEDs on the keyboard.
                            	  1413: ;
                            	  1414: ; Parameters:
                            	  1415: ;		d1.b = LED state
                            	  1416: ;	Modifies:
                            	  1417: ;		none
                            	  1418: ; Returns:
                            	  1419: ;		none
                            	  1420: ; Stack Space:
                            	  1421: ;		1 long word
                            	  1422: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1423: 
                            	  1424: KeybdSetLED:
02:000053CA 2F01            	  1425: 	move.l	d1,-(a7)
02:000053CC 123C00ED        	  1426: 	move.b	#$ED,d1
02:000053D0 61000454        	  1427: 	bsr			KeybdSendByte
02:000053D4 6100015A        	  1428: 	bsr			KeybdWaitTx
02:000053D8 61000136        	  1429: 	bsr			KeybdRecvByte
02:000053DC 4A01            	  1430: 	tst.b		d1
02:000053DE 6B12            	  1431: 	bmi			.0001
02:000053E0 0C0100FA        	  1432: 	cmpi.b	#$FA,d1
02:000053E4 2217            	  1433: 	move.l	(a7),d1
02:000053E6 6100043E        	  1434: 	bsr			KeybdSendByte
02:000053EA 61000144        	  1435: 	bsr			KeybdWaitTx
02:000053EE 61000120        	  1436: 	bsr			KeybdRecvByte
                            	  1437: .0001:
02:000053F2 221F            	  1438: 	move.l	(a7)+,d1
02:000053F4 4E75            	  1439: 	rts
                            	  1440: 
                            	  1441: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1442: ; Initialize the keyboard.
                            	  1443: ;
                            	  1444: ; Parameters:
                            	  1445: ;		none
                            	  1446: ;	Modifies:
                            	  1447: ;		none
                            	  1448: ; Returns:
                            	  1449: ;		none
                            	  1450: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1451: 
                            	  1452: _KeybdInit:
                            	  1453: KeybdInit:
                            	  1454: ;	movem.l	d0/d1/d3/a1,-(a7)
02:000053F6 42390010000F    	  1455: 	clr.b	_KeyState1		; records key up/down state
02:000053FC 423900100010    	  1456: 	clr.b	_KeyState2		; records shift,ctrl,alt state
02:00005402 4E75            	  1457: 	rts
                            	  1458: 
02:00005404 61000444        	  1459: 	bsr			Wait300ms
02:00005408 610000EC        	  1460: 	bsr			_KeybdGetStatus	; wait for response from keyboard
02:0000540C 4A01            	  1461: 	tst.b		d1
02:0000540E 6A0C            	  1462: 	bpl			.0001					; is input buffer full ? no, branch
02:00005410 610000EE        	  1463: 	bsr			_KeybdGetScancode
02:00005414 0C0100AA        	  1464: 	cmpi.b	#$AA,d1				; keyboard Okay
02:00005418 6700008A        	  1465: 	beq			kbdi0005
                            	  1466: .0001:
02:0000541C 760A            	  1467: 	moveq		#10,d3
                            	  1468: kbdi0002:
02:0000541E 6100040E        	  1469: 	bsr			Wait10ms
02:00005422 4239FD0FFE01    	  1470: 	clr.b		KEYBD+1				; clear receive register (write $00 to status reg)
02:00005428 72FF            	  1471: 	moveq		#-1,d1				; send reset code to keyboard
02:0000542A 13C1FD0FFE01    	  1472: 	move.b	d1,KEYBD+1		; write $FF to status reg to clear TX state
02:00005430 610003F4        	  1473: 	bsr			KeybdSendByte	; now write ($FF) to transmit register for reset
02:00005434 610000FA        	  1474: 	bsr			KeybdWaitTx		; wait until no longer busy
02:00005438 4A81            	  1475: 	tst.l		d1
02:0000543A 6B000082        	  1476: 	bmi			kbdiXmitBusy
02:0000543E 610000D0        	  1477: 	bsr			KeybdRecvByte	; look for an ACK ($FA)
02:00005442 0C0100FA        	  1478: 	cmpi.b	#$FA,d1
02:00005446 6604            	  1479: 	bne			.0001
02:00005448 610000C6        	  1480: 	bsr			KeybdRecvByte	; look for BAT completion code ($AA)
                            	  1481: .0001:
02:0000544C 0C0100FC        	  1482: 	cmpi.b	#$FC,d1				; reset error ?
02:00005450 672A            	  1483: 	beq			kbdiTryAgain
02:00005452 0C0100AA        	  1484: 	cmpi.b	#$AA,d1				; reset complete okay ?
02:00005456 6624            	  1485: 	bne			kbdiTryAgain
                            	  1486: 
                            	  1487: 	; After a reset, scan code set #2 should be active
                            	  1488: .config:
02:00005458 323C00F0        	  1489: 	move.w	#$F0,d1			; send scan code select
02:0000545C 13C1FD0FFF00    	  1490: 	move.b	d1,leds
02:00005462 610003C2        	  1491: 	bsr			KeybdSendByte
02:00005466 610000C8        	  1492: 	bsr			KeybdWaitTx
02:0000546A 4A81            	  1493: 	tst.l		d1
02:0000546C 6B50            	  1494: 	bmi			kbdiXmitBusy
02:0000546E 610000A0        	  1495: 	bsr			KeybdRecvByte	; wait for response from keyboard
02:00005472 4A41            	  1496: 	tst.w		d1
02:00005474 6B06            	  1497: 	bmi			kbdiTryAgain
02:00005476 0C0100FA        	  1498: 	cmpi.b	#$FA,d1				; ACK
02:0000547A 670E            	  1499: 	beq			kbdi0004
                            	  1500: kbdiTryAgain:
02:0000547C 51CBFFA0        	  1501: 	dbra		d3,kbdi0002
                            	  1502: .keybdErr:
02:00005480 43FA004A        	  1503: 	lea			msgBadKeybd,a1
02:00005484 6100FD3C        	  1504: 	bsr			DisplayStringCRLF
02:00005488 601E            	  1505: 	bra			ledxit
                            	  1506: kbdi0004:
02:0000548A 7202            	  1507: 	moveq		#2,d1			; select scan code set #2
02:0000548C 61000398        	  1508: 	bsr			KeybdSendByte
02:00005490 6100009E        	  1509: 	bsr			KeybdWaitTx
02:00005494 4A81            	  1510: 	tst.l		d1
02:00005496 6B26            	  1511: 	bmi			kbdiXmitBusy
02:00005498 6176            	  1512: 	bsr			KeybdRecvByte	; wait for response from keyboard
02:0000549A 4A41            	  1513: 	tst.w		d1
02:0000549C 6BDE            	  1514: 	bmi			kbdiTryAgain
02:0000549E 0C0100FA        	  1515: 	cmpi.b	#$FA,d1
02:000054A2 66D8            	  1516: 	bne			kbdiTryAgain
                            	  1517: kbdi0005:
02:000054A4 6100FEE6        	  1518: 	bsr			KeybdGetID
                            	  1519: ledxit:
02:000054A8 7207            	  1520: 	moveq		#$07,d1
02:000054AA 6100FF1E        	  1521: 	bsr			KeybdSetLED
02:000054AE 6100039A        	  1522: 	bsr			Wait300ms
02:000054B2 7200            	  1523: 	moveq		#$00,d1
02:000054B4 6100FF14        	  1524: 	bsr			KeybdSetLED
02:000054B8 4CDF020B        	  1525: 	movem.l	(a7)+,d0/d1/d3/a1
02:000054BC 4E75            	  1526: 	rts
                            	  1527: kbdiXmitBusy:
02:000054BE 43FA001B        	  1528: 	lea			msgXmitBusy,a1
02:000054C2 6100FCFE        	  1529: 	bsr			DisplayStringCRLF
02:000054C6 4CDF020B        	  1530: 	movem.l	(a7)+,d0/d1/d3/a1
02:000054CA 4E75            	  1531: 	rts
                            	  1532: 	
                            	  1533: msgBadKeybd:
02:000054CC 4B6579626F617264	  1534: 	dc.b		"Keyboard error",0
02:000054D4 206572726F72
02:000054DA 00
                            	  1535: msgXmitBusy:
02:000054DB 4B6579626F617264	  1536: 	dc.b		"Keyboard transmitter stuck",0
02:000054E3 207472616E736D69
02:000054EB 7474657220737475
02:000054F3 636B
02:000054F5 00
                            	  1537: 
                            	  1538: 	even
                            	  1539: _KeybdGetStatus:
02:000054F6 7200            	  1540: 	moveq		#0,d1
02:000054F8 1239FD0FFE01    	  1541: 	move.b	KEYBD+1,d1
02:000054FE 4E75            	  1542: 	rts
                            	  1543: 
                            	  1544: ; Get the scancode from the keyboard port
                            	  1545: 
                            	  1546: _KeybdGetScancode:
02:00005500 7200            	  1547: 	moveq		#0,d1
02:00005502 1239FD0FFE00    	  1548: 	move.b	KEYBD,d1				; get the scan code
02:00005508 4239FD0FFE01    	  1549: 	move.b	#0,KEYBD+1			; clear receive register
02:0000550E 4E75            	  1550: 	rts
                            	  1551: 
                            	  1552: ; Recieve a byte from the keyboard, used after a command is sent to the
                            	  1553: ; keyboard in order to wait for a response.
                            	  1554: ;
                            	  1555: KeybdRecvByte:
02:00005510 2F03            	  1556: 	move.l	d3,-(a7)
02:00005512 363C0064        	  1557: 	move.w	#100,d3		; wait up to 1s
                            	  1558: .0003:
02:00005516 61DE            	  1559: 	bsr			_KeybdGetStatus	; wait for response from keyboard
02:00005518 4A01            	  1560: 	tst.b		d1
02:0000551A 6B0E            	  1561: 	bmi			.0004			; is input buffer full ? yes, branch
02:0000551C 61000310        	  1562: 	bsr			Wait10ms	; wait a bit
02:00005520 51CBFFF4        	  1563: 	dbra		d3,.0003	; go back and try again
02:00005524 261F            	  1564: 	move.l	(a7)+,d3
02:00005526 72FF            	  1565: 	moveq		#-1,d1		; return -1
02:00005528 4E75            	  1566: 	rts
                            	  1567: .0004:
02:0000552A 61D4            	  1568: 	bsr			_KeybdGetScancode
02:0000552C 261F            	  1569: 	move.l	(a7)+,d3
02:0000552E 4E75            	  1570: 	rts
                            	  1571: 
                            	  1572: 
                            	  1573: ; Wait until the keyboard transmit is complete
                            	  1574: ; Returns -1 if timedout, 0 if transmit completed
                            	  1575: ;
                            	  1576: KeybdWaitTx:
02:00005530 48E73000        	  1577: 	movem.l	d2/d3,-(a7)
02:00005534 7664            	  1578: 	moveq		#100,d3		; wait a max of 1s
                            	  1579: .0001:
02:00005536 61BE            	  1580: 	bsr			_KeybdGetStatus
02:00005538 08010006        	  1581: 	btst		#6,d1				; check for transmit complete bit
02:0000553C 6610            	  1582: 	bne	    .0002				; branch if bit set
02:0000553E 610002EE        	  1583: 	bsr			Wait10ms		; delay a little bit
02:00005542 51CBFFF2        	  1584: 	dbra		d3,.0001		; go back and try again
02:00005546 4CDF000C        	  1585: 	movem.l	(a7)+,d2/d3
02:0000554A 72FF            	  1586: 	moveq		#-1,d1			; return -1
02:0000554C 4E75            	  1587: 	rts
                            	  1588: .0002:
02:0000554E 4CDF000C        	  1589: 	movem.l	(a7)+,d2/d3
02:00005552 7200            	  1590: 	moveq	#0,d1		; return 0
02:00005554 4E75            	  1591: 	rts
                            	  1592: 
                            	  1593: ;------------------------------------------------------------------------------
                            	  1594: ; d1.b 0=echo off, non-zero = echo on
                            	  1595: ;------------------------------------------------------------------------------
                            	  1596: 
                            	  1597: SetKeyboardEcho:
02:00005556 13C10004000C    	  1598: 	move.b	d1,KeybdEcho
02:0000555C 4E75            	  1599: 	rts
                            	  1600: 
                            	  1601: ;------------------------------------------------------------------------------
                            	  1602: ; Get key pending status into d1.b
                            	  1603: ;
                            	  1604: ; Returns:
                            	  1605: ;		d1.b = 1 if a key is available, otherwise zero.
                            	  1606: ;------------------------------------------------------------------------------
                            	  1607: 
                            	  1608: CheckForKey:
02:0000555E 7200            	  1609: 	moveq.l	#0,d1					; clear high order bits
                            	  1610: ;	move.b	KEYBD+1,d1		; get keyboard port status
                            	  1611: ;	smi.b		d1						; set true/false
                            	  1612: ;	andi.b	#1,d1					; return true (1) if key available, 0 otherwise
02:00005560 4A3900100013    	  1613: 	tst.b		_KeybdCnt
02:00005566 56C1            	  1614: 	sne.b		d1
02:00005568 4E75            	  1615: 	rts
                            	  1616: 
                            	  1617: ;------------------------------------------------------------------------------
                            	  1618: ; GetKey
                            	  1619: ; 	Get a character from the keyboard. 
                            	  1620: ;
                            	  1621: ; Modifies:
                            	  1622: ;		d1
                            	  1623: ; Returns:
                            	  1624: ;		d1 = -1 if no key available or not in focus, otherwise key
                            	  1625: ;------------------------------------------------------------------------------
                            	  1626: 
                            	  1627: GetKey:
02:0000556A 2F00            	  1628: 	move.l	d0,-(a7)					; push d0
02:0000556C 123900100000    	  1629: 	move.b	IOFocus,d1				; Check if the core has the IO focus
02:00005572 4E7A0FE0        	  1630: 	movec.l	coreno,d0
02:00005576 B200            	  1631: 	cmp.b		d0,d1
02:00005578 6622            	  1632: 	bne.s		.0004							; go return no key available, if not in focus
02:0000557A 6132            	  1633: 	bsr			KeybdGetCharNoWait	; get a character
02:0000557C 4A81            	  1634: 	tst.l		d1						; was a key available?
02:0000557E 6B1C            	  1635: 	bmi.s		.0004
02:00005580 4A390004000C    	  1636: 	tst.b		KeybdEcho					; is keyboard echo on ?
02:00005586 6710            	  1637: 	beq.s		.0003							; no echo, just return the key
02:00005588 0C01000D        	  1638: 	cmpi.b	#CR,d1						; convert CR keystroke into CRLF
02:0000558C 6606            	  1639: 	bne.s		.0005
02:0000558E 6100F958        	  1640: 	bsr			CRLF
02:00005592 6004            	  1641: 	bra.s		.0003
                            	  1642: .0005:
02:00005594 6100F99C        	  1643: 	bsr			DisplayChar
                            	  1644: .0003:
02:00005598 201F            	  1645: 	move.l	(a7)+,d0					; pop d0
02:0000559A 4E75            	  1646: 	rts												; return key
                            	  1647: ; Return -1 indicating no char was available
                            	  1648: .0004:
02:0000559C 201F            	  1649: 	move.l	(a7)+,d0					; pop d0
02:0000559E 72FF            	  1650: 	moveq		#-1,d1						; return no key available
02:000055A0 4E75            	  1651: 	rts
                            	  1652: 
                            	  1653: CheckForCtrlC:
02:000055A2 610A            	  1654: 	bsr			KeybdGetCharNoWait
02:000055A4 0C010003        	  1655: 	cmpi.b	#CTRLC,d1
02:000055A8 670006B8        	  1656: 	beq			Monitor
02:000055AC 4E75            	  1657: 	rts
                            	  1658: 
                            	  1659: ;------------------------------------------------------------------------------
                            	  1660: ;------------------------------------------------------------------------------
                            	  1661: 
                            	  1662: KeybdGetCharNoWait:
02:000055AE 42390004000D    	  1663: 	clr.b	KeybdWaitFlag
02:000055B4 6008            	  1664: 	bra		KeybdGetChar
                            	  1665: 
                            	  1666: KeybdGetCharWait:
02:000055B6 13FC00FF0004000D	  1667: 	move.b	#-1,KeybdWaitFlag
                            	  1668: 
                            	  1669: KeybdGetChar:
02:000055BE 48E7B080        	  1670: 	movem.l	d0/d2/d3/a0,-(a7)
                            	  1671: .0003:
02:000055C2 4E7A0FE0        	  1672: 	movec		coreno,d0
02:000055C6 4840            	  1673: 	swap		d0
02:000055C8 7203            	  1674: 	moveq		#KEYBD_SEMA,d1
02:000055CA 6100ACCA        	  1675: 	bsr			LockSemaphore
02:000055CE 143900100013    	  1676: 	move.b	_KeybdCnt,d2		; get count of buffered scan codes
02:000055D4 673E            	  1677: 	beq.s		.0015						;
02:000055D6 143900100011    	  1678: 	move.b	_KeybdHead,d2		; d2 = buffer head
02:000055DC 4882            	  1679: 	ext.w		d2
02:000055DE 41F900100020    	  1680: 	lea			_KeybdBuf,a0		; a0 = pointer to keyboard buffer
02:000055E4 7200            	  1681: 	clr.l		d1
02:000055E6 12302000        	  1682: 	move.b	(a0,d2.w),d1		; d1 = scan code from buffer
02:000055EA 5202            	  1683: 	addi.b	#1,d2						; increment keyboard head index
02:000055EC 0202001F        	  1684: 	andi.b	#31,d2					; and wrap around at buffer size
02:000055F0 13C200100011    	  1685: 	move.b	d2,_KeybdHead
02:000055F6 533900100013    	  1686: 	subi.b	#1,_KeybdCnt		; decrement count of scan codes in buffer
02:000055FC C342            	  1687: 	exg			d1,d2						; save scancode value in d2
02:000055FE 4E7A0FE0        	  1688: 	movec		coreno,d0
02:00005602 4840            	  1689: 	swap		d0
02:00005604 7203            	  1690: 	moveq		#KEYBD_SEMA,d1
02:00005606 6100ACC8        	  1691: 	bsr			UnlockSemaphore
02:0000560A C541            	  1692: 	exg			d2,d1						; restore scancode value
02:0000560C 6026            	  1693: 	bra			.0001						; go process scan code
                            	  1694: .0014:
02:0000560E 6100FEE6        	  1695: 	bsr		_KeybdGetStatus		; check keyboard status for key available
02:00005612 6B1C            	  1696: 	bmi		.0006							; yes, go process
                            	  1697: .0015:
02:00005614 4E7A0FE0        	  1698: 	movec		coreno,d0
02:00005618 4840            	  1699: 	swap		d0
02:0000561A 7203            	  1700: 	moveq		#KEYBD_SEMA,d1
02:0000561C 6100ACB2        	  1701: 	bsr			UnlockSemaphore
02:00005620 4A390004000D    	  1702: 	tst.b		KeybdWaitFlag			; are we willing to wait for a key ?
02:00005626 6B9A            	  1703: 	bmi			.0003							; yes, branch back
02:00005628 4CDF010D        	  1704: 	movem.l	(a7)+,d0/d2/d3/a0
02:0000562C 72FF            	  1705: 	moveq		#-1,d1						; flag no char available
02:0000562E 4E75            	  1706: 	rts
                            	  1707: .0006:
02:00005630 6100FECE        	  1708: 	bsr		_KeybdGetScancode
                            	  1709: .0001:
02:00005634 33FC0001FD0FFF00	  1710: 	move.w	#1,leds
02:0000563C B23C00F0        	  1711: 	cmp.b	#SC_KEYUP,d1
02:00005640 670000C0        	  1712: 	beq		.doKeyup
02:00005644 B23C00E0        	  1713: 	cmp.b	#SC_EXTEND,d1
02:00005648 670000C4        	  1714: 	beq		.doExtend
02:0000564C B23C0014        	  1715: 	cmp.b	#SC_CTRL,d1
02:00005650 670000C8        	  1716: 	beq		.doCtrl
02:00005654 B23C0012        	  1717: 	cmp.b	#SC_LSHIFT,d1
02:00005658 6700012A        	  1718: 	beq		.doShift
02:0000565C B23C0059        	  1719: 	cmp.b	#SC_RSHIFT,d1
02:00005660 67000122        	  1720: 	beq		.doShift
02:00005664 B23C0077        	  1721: 	cmp.b	#SC_NUMLOCK,d1
02:00005668 67000142        	  1722: 	beq		.doNumLock
02:0000566C B23C0058        	  1723: 	cmp.b	#SC_CAPSLOCK,d1
02:00005670 67000148        	  1724: 	beq		.doCapsLock
02:00005674 B23C007E        	  1725: 	cmp.b	#SC_SCROLLLOCK,d1
02:00005678 6700014E        	  1726: 	beq		.doScrollLock
02:0000567C B23C0011        	  1727: 	cmp.b   #SC_ALT,d1
02:00005680 670000C0        	  1728: 	beq     .doAlt
02:00005684 14390010000F    	  1729: 	move.b	_KeyState1,d2			; check key up/down
02:0000568A 42390010000F    	  1730: 	move.b	#0,_KeyState1			; clear keyup status
02:00005690 4A02            	  1731: 	tst.b	d2
02:00005692 6600FF2E        	  1732: 	bne	    .0003					; ignore key up
02:00005696 B23C000D        	  1733: 	cmp.b   #SC_TAB,d1
02:0000569A 670000CE        	  1734: 	beq     .doTab
                            	  1735: .0013:
02:0000569E 143900100010    	  1736: 	move.b	_KeyState2,d2
02:000056A4 6A1A            	  1737: 	bpl		.0010					; is it extended code ?
02:000056A6 C43C007F        	  1738: 	and.b	#$7F,d2					; clear extended bit
02:000056AA 13C200100010    	  1739: 	move.b	d2,_KeyState2
02:000056B0 42390010000F    	  1740: 	move.b	#0,_KeyState1			; clear keyup
02:000056B6 41FA04C0        	  1741: 	lea		_keybdExtendedCodes,a0
02:000056BA 12301000        	  1742: 	move.b	(a0,d1.w),d1
02:000056BE 6034            	  1743: 	bra		.0008
                            	  1744: .0010:
02:000056C0 08020002        	  1745: 	btst	#2,d2					; is it CTRL code ?
02:000056C4 670E            	  1746: 	beq		.0009
02:000056C6 C27C007F        	  1747: 	and.w	#$7F,d1
02:000056CA 41FA042C        	  1748: 	lea		_keybdControlCodes,a0
02:000056CE 12301000        	  1749: 	move.b	(a0,d1.w),d1
02:000056D2 6020            	  1750: 	bra		.0008
                            	  1751: .0009:
02:000056D4 08020000        	  1752: 	btst	#0,d2					; is it shift down ?
02:000056D8 670A            	  1753: 	beq  	.0007
02:000056DA 41FA031C        	  1754: 	lea		_shiftedScanCodes,a0
02:000056DE 12301000        	  1755: 	move.b	(a0,d1.w),d1
02:000056E2 6010            	  1756: 	bra		.0008
                            	  1757: .0007:
02:000056E4 41FA0212        	  1758: 	lea		_unshiftedScanCodes,a0
02:000056E8 12301000        	  1759: 	move.b	(a0,d1.w),d1
02:000056EC 33FC0202FD0FFF00	  1760: 	move.w	#$0202,leds
                            	  1761: .0008:
02:000056F4 33FC0303FD0FFF00	  1762: 	move.w	#$0303,leds
02:000056FC 4CDF010D        	  1763: 	movem.l	(a7)+,d0/d2/d3/a0
02:00005700 4E75            	  1764: 	rts
                            	  1765: .doKeyup:
02:00005702 13FC00FF0010000F	  1766: 	move.b	#-1,_KeyState1
02:0000570A 6000FEB6        	  1767: 	bra		.0003
                            	  1768: .doExtend:
02:0000570E 0039008000100010	  1769: 	or.b	#$80,_KeyState2
02:00005716 6000FEAA        	  1770: 	bra		.0003
                            	  1771: .doCtrl:
02:0000571A 12390010000F    	  1772: 	move.b	_KeyState1,d1
02:00005720 42390010000F    	  1773: 	clr.b	_KeyState1
02:00005726 4A01            	  1774: 	tst.b	d1
02:00005728 6A0C            	  1775: 	bpl.s	.0004
02:0000572A 08B9000200100010	  1776: 	bclr	#2,_KeyState2
02:00005732 6000FE8E        	  1777: 	bra		.0003
                            	  1778: .0004:
02:00005736 08F9000200100010	  1779: 	bset	#2,_KeyState2
02:0000573E 6000FE82        	  1780: 	bra		.0003
                            	  1781: .doAlt:
02:00005742 12390010000F    	  1782: 	move.b	_KeyState1,d1
02:00005748 42390010000F    	  1783: 	clr.b	_KeyState1
02:0000574E 4A01            	  1784: 	tst.b	d1
02:00005750 6A0C            	  1785: 	bpl		.0011
02:00005752 08B9000100100010	  1786: 	bclr	#1,_KeyState2
02:0000575A 6000FE66        	  1787: 	bra		.0003
                            	  1788: .0011:
02:0000575E 08F9000100100010	  1789: 	bset	#1,_KeyState2
02:00005766 6000FE5A        	  1790: 	bra		.0003
                            	  1791: .doTab:
02:0000576A 2F01            	  1792: 	move.l	d1,-(a7)
02:0000576C 123900100010    	  1793:   move.b  _KeyState2,d1
02:00005772 08010001        	  1794:   btst	#1,d1                 ; is ALT down ?
02:00005776 6706            	  1795:   beq     .0012
                            	  1796: ;    	inc     _iof_switch
02:00005778 221F            	  1797:   move.l	(a7)+,d1
02:0000577A 6000FE46        	  1798:   bra     .0003
                            	  1799: .0012:
02:0000577E 221F            	  1800:   move.l	(a7)+,d1
02:00005780 6000FF1C        	  1801:   bra     .0013
                            	  1802: .doShift:
02:00005784 12390010000F    	  1803: 	move.b	_KeyState1,d1
02:0000578A 42390010000F    	  1804: 	clr.b	_KeyState1
02:00005790 4A01            	  1805: 	tst.b	d1
02:00005792 6A0C            	  1806: 	bpl.s	.0005
02:00005794 08B9000000100010	  1807: 	bclr	#0,_KeyState2
02:0000579C 6000FE24        	  1808: 	bra		.0003
                            	  1809: .0005:
02:000057A0 08F9000000100010	  1810: 	bset	#0,_KeyState2
02:000057A8 6000FE18        	  1811: 	bra		.0003
                            	  1812: .doNumLock:
02:000057AC 0879000400100010	  1813: 	bchg	#4,_KeyState2
02:000057B4 6120            	  1814: 	bsr		KeybdSetLEDStatus
02:000057B6 6000FE0A        	  1815: 	bra		.0003
                            	  1816: .doCapsLock:
02:000057BA 0879000500100010	  1817: 	bchg	#5,_KeyState2
02:000057C2 6112            	  1818: 	bsr		KeybdSetLEDStatus
02:000057C4 6000FDFC        	  1819: 	bra		.0003
                            	  1820: .doScrollLock:
02:000057C8 0879000600100010	  1821: 	bchg	#6,_KeyState2
02:000057D0 6104            	  1822: 	bsr		KeybdSetLEDStatus
02:000057D2 6000FDEE        	  1823: 	bra		.0003
                            	  1824: 
                            	  1825: KeybdSetLEDStatus:
02:000057D6 48E73000        	  1826: 	movem.l	d2/d3,-(a7)
02:000057DA 42390010000E    	  1827: 	clr.b		KeybdLEDs
02:000057E0 0839000400100010	  1828: 	btst		#4,_KeyState2
02:000057E8 6708            	  1829: 	beq.s		.0002
02:000057EA 13FC00020010000E	  1830: 	move.b	#2,KeybdLEDs
                            	  1831: .0002:
02:000057F2 0839000500100010	  1832: 	btst		#5,_KeyState2
02:000057FA 6708            	  1833: 	beq.s		.0003
02:000057FC 08F900020010000E	  1834: 	bset		#2,KeybdLEDs
                            	  1835: .0003:
02:00005804 0839000600100010	  1836: 	btst		#6,_KeyState2
02:0000580C 6708            	  1837: 	beq.s		.0004
02:0000580E 08F900000010000E	  1838: 	bset		#0,KeybdLEDs
                            	  1839: .0004:
02:00005816 12390010000E    	  1840: 	move.b	KeybdLEDs,d1
02:0000581C 6100FBAC        	  1841: 	bsr			KeybdSetLED
02:00005820 4CDF000C        	  1842: 	movem.l	(a7)+,d2/d3
02:00005824 4E75            	  1843: 	rts
                            	  1844: 
                            	  1845: KeybdSendByte:
02:00005826 13C1FD0FFE00    	  1846: 	move.b	d1,KEYBD
02:0000582C 4E75            	  1847: 	rts
                            	  1848: 	
                            	  1849: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1850: ; Wait for 10 ms
                            	  1851: ;
                            	  1852: ; Parameters: none
                            	  1853: ; Returns: none
                            	  1854: ; Modifies: none
                            	  1855: ; Stack Space: 2 long words
                            	  1856: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1857: 
                            	  1858: Wait10ms:
02:0000582E 48E7C000        	  1859: 	movem.l	d0/d1,-(a7)
02:00005832 4E7A0FF0        	  1860: 	movec		tick,d0
02:00005836 068000061A80    	  1861: 	addi.l	#400000,d0			; 400,000 cycles at 40MHz
                            	  1862: .0001:
02:0000583C 4E7A1FF0        	  1863: 	movec		tick,d1
02:00005840 B081            	  1864: 	cmp.l		d1,d0
02:00005842 62F8            	  1865: 	bhi			.0001
02:00005844 4CDF0003        	  1866: 	movem.l	(a7)+,d0/d1
02:00005848 4E75            	  1867: 	rts
                            	  1868: 
                            	  1869: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1870: ; Wait for 300 ms
                            	  1871: ;
                            	  1872: ; Parameters: none
                            	  1873: ; Returns: none
                            	  1874: ; Modifies: none
                            	  1875: ; Stack Space: 2 long words
                            	  1876: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1877: 
                            	  1878: Wait300ms:
02:0000584A 48E7C000        	  1879: 	movem.l	d0/d1,-(a7)
02:0000584E 4E7A0FF0        	  1880: 	movec		tick,d0
02:00005852 068000B71B00    	  1881: 	addi.l	#12000000,d0			; 12,000,000 cycles at 40MHz
                            	  1882: .0001:
02:00005858 4E7A1FF0        	  1883: 	movec		tick,d1
02:0000585C B081            	  1884: 	cmp.l		d1,d0
02:0000585E 62F8            	  1885: 	bhi			.0001
02:00005860 4CDF0003        	  1886: 	movem.l	(a7)+,d0/d1
02:00005864 4E75            	  1887: 	rts
                            	  1888: 
                            	  1889: ;--------------------------------------------------------------------------
                            	  1890: ; Keyboard IRQ routine.
                            	  1891: ;
                            	  1892: ; Returns:
                            	  1893: ; 	d1 = -1 if keyboard routine handled interrupt, otherwise positive.
                            	  1894: ;--------------------------------------------------------------------------
                            	  1895: 
                            	  1896: KeybdIRQ:
02:00005866 46FC2600        	  1897: 	move.w	#$2600,sr					; disable lower interrupts
02:0000586A 48E7C080        	  1898: 	movem.l	d0/d1/a0,-(a7)
02:0000586E 6100FC86        	  1899: 	bsr			_KeybdGetStatus		; check if keyboard
02:00005872 4A01            	  1900: 	tst.b		d1
02:00005874 6A7C            	  1901: 	bpl			.0001							; branch if not keyboard
02:00005876 4E7A0FE0        	  1902: 	movec		coreno,d0
02:0000587A 4840            	  1903: 	swap		d0
02:0000587C 7203            	  1904: 	moveq		#KEYBD_SEMA,d1
02:0000587E 6100AA16        	  1905: 	bsr			LockSemaphore
02:00005882 0839000100100010	  1906: 	btst		#1,_KeyState2			; Is Alt down?
02:0000588A 6728            	  1907: 	beq.s		.0003
02:0000588C 1039FD0FFE00    	  1908: 	move.b	KEYBD,d0					; get scan code
02:00005892 0C00000D        	  1909: 	cmpi.b	#SC_TAB,d0				; is Alt-Tab?
02:00005896 661C            	  1910: 	bne.s		.0003
02:00005898 6100FC66        	  1911: 	bsr			_KeybdGetScancode	; grab the scan code (clears interrupt)
02:0000589C 6100FA8C        	  1912: 	bsr			rotate_iofocus
02:000058A0 423900100011    	  1913: 	clr.b		_KeybdHead				; clear keyboard buffer
02:000058A6 423900100012    	  1914: 	clr.b		_KeybdTail
02:000058AC 423900100013    	  1915: 	clr.b		_KeybdCnt
02:000058B2 6032            	  1916: 	bra			.0002							; do not store Alt-Tab
                            	  1917: .0003:
                            	  1918: 	; Insert keyboard scan code into raw keyboard buffer
02:000058B4 6100FC4A        	  1919: 	bsr			_KeybdGetScancode	; grab the scan code (clears interrupt)
02:000058B8 0C39002000100013	  1920: 	cmpi.b	#32,_KeybdCnt			; see if keyboard buffer full
02:000058C0 6424            	  1921: 	bhs.s		.0002
02:000058C2 103900100012    	  1922: 	move.b	_KeybdTail,d0			; keyboard buffer not full, add to tail
02:000058C8 4880            	  1923: 	ext.w		d0
02:000058CA 41F900100020    	  1924: 	lea			_KeybdBuf,a0			; a0 = pointer to buffer
02:000058D0 11810000        	  1925: 	move.b	d1,(a0,d0.w)			; put scancode in buffer
02:000058D4 5200            	  1926: 	addi.b	#1,d0							; increment tail index
02:000058D6 0200001F        	  1927: 	andi.b	#31,d0						; wrap at buffer limit
02:000058DA 13C000100012    	  1928: 	move.b	d0,_KeybdTail			; update tail index
02:000058E0 523900100013    	  1929: 	addi.b	#1,_KeybdCnt			; increment buffer count
                            	  1930: .0002:
02:000058E6 4E7A0FE0        	  1931: 	movec		coreno,d0
02:000058EA 4840            	  1932: 	swap		d0
02:000058EC 7203            	  1933: 	moveq		#KEYBD_SEMA,d1
02:000058EE 6100A9E0        	  1934: 	bsr			UnlockSemaphore
                            	  1935: .0001:
02:000058F2 4CDF0103        	  1936: 	movem.l	(a7)+,d0/d1/a0		; return
02:000058F6 4E73            	  1937: 	rte
                            	  1938: 
                            	  1939: ;--------------------------------------------------------------------------
                            	  1940: ; PS2 scan codes to ascii conversion tables.
                            	  1941: ;--------------------------------------------------------------------------
                            	  1942: ;
                            	  1943: _unshiftedScanCodes:
02:000058F8 2E              	  1944: 	dc.b	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
02:000058F9 A9
02:000058FA 2E
02:000058FB A5
02:000058FC A3
02:000058FD A1
02:000058FE A2
02:000058FF AC
02:00005900 2E              	  1945: 	dc.b	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
02:00005901 AA
02:00005902 A8
02:00005903 A6
02:00005904 A4
02:00005905 09
02:00005906 60
02:00005907 2E
02:00005908 2E              	  1946: 	dc.b	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
02:00005909 2E
02:0000590A 2E
02:0000590B 2E
02:0000590C 2E
02:0000590D 71
02:0000590E 31
02:0000590F 2E
02:00005910 2E              	  1947: 	dc.b	$2e,$2e,$7a,$73,$61,$77,$32,$2e
02:00005911 2E
02:00005912 7A
02:00005913 73
02:00005914 61
02:00005915 77
02:00005916 32
02:00005917 2E
02:00005918 2E              	  1948: 	dc.b	$2e,$63,$78,$64,$65,$34,$33,$2e
02:00005919 63
02:0000591A 78
02:0000591B 64
02:0000591C 65
02:0000591D 34
02:0000591E 33
02:0000591F 2E
02:00005920 2E              	  1949: 	dc.b	$2e,$20,$76,$66,$74,$72,$35,$2e
02:00005921 20
02:00005922 76
02:00005923 66
02:00005924 74
02:00005925 72
02:00005926 35
02:00005927 2E
02:00005928 2E              	  1950: 	dc.b	$2e,$6e,$62,$68,$67,$79,$36,$2e
02:00005929 6E
02:0000592A 62
02:0000592B 68
02:0000592C 67
02:0000592D 79
02:0000592E 36
02:0000592F 2E
02:00005930 2E              	  1951: 	dc.b	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
02:00005931 2E
02:00005932 6D
02:00005933 6A
02:00005934 75
02:00005935 37
02:00005936 38
02:00005937 2E
02:00005938 2E              	  1952: 	dc.b	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
02:00005939 2C
02:0000593A 6B
02:0000593B 69
02:0000593C 6F
02:0000593D 30
02:0000593E 39
02:0000593F 2E
02:00005940 2E              	  1953: 	dc.b	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
02:00005941 2E
02:00005942 2F
02:00005943 6C
02:00005944 3B
02:00005945 70
02:00005946 2D
02:00005947 2E
02:00005948 2E              	  1954: 	dc.b	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
02:00005949 2E
02:0000594A 27
02:0000594B 2E
02:0000594C 5B
02:0000594D 3D
02:0000594E 2E
02:0000594F 2E
02:00005950 AD              	  1955: 	dc.b	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
02:00005951 2E
02:00005952 0D
02:00005953 5D
02:00005954 2E
02:00005955 5C
02:00005956 2E
02:00005957 2E
02:00005958 2E              	  1956: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
02:00005959 2E
02:0000595A 2E
02:0000595B 2E
02:0000595C 2E
02:0000595D 2E
02:0000595E 08
02:0000595F 2E
02:00005960 2E              	  1957: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
02:00005961 95
02:00005962 2E
02:00005963 93
02:00005964 94
02:00005965 2E
02:00005966 2E
02:00005967 2E
02:00005968 98              	  1958: 	dc.b	$98,$7f,$92,$2e,$91,$90,$1b,$af
02:00005969 7F
02:0000596A 92
02:0000596B 2E
02:0000596C 91
02:0000596D 90
02:0000596E 1B
02:0000596F AF
02:00005970 AB              	  1959: 	dc.b	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
02:00005971 2E
02:00005972 97
02:00005973 2E
02:00005974 2E
02:00005975 96
02:00005976 AE
02:00005977 2E
                            	  1960: 
02:00005978 2E              	  1961: 	dc.b	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
02:00005979 2E
02:0000597A 2E
02:0000597B A7
02:0000597C 2E
02:0000597D 2E
02:0000597E 2E
02:0000597F 2E
02:00005980 2E              	  1962: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005981 2E
02:00005982 2E
02:00005983 2E
02:00005984 2E
02:00005985 2E
02:00005986 2E
02:00005987 2E
02:00005988 2E              	  1963: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005989 2E
02:0000598A 2E
02:0000598B 2E
02:0000598C 2E
02:0000598D 2E
02:0000598E 2E
02:0000598F 2E
02:00005990 2E              	  1964: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005991 2E
02:00005992 2E
02:00005993 2E
02:00005994 2E
02:00005995 2E
02:00005996 2E
02:00005997 2E
02:00005998 2E              	  1965: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005999 2E
02:0000599A 2E
02:0000599B 2E
02:0000599C 2E
02:0000599D 2E
02:0000599E 2E
02:0000599F 2E
02:000059A0 2E              	  1966: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000059A1 2E
02:000059A2 2E
02:000059A3 2E
02:000059A4 2E
02:000059A5 2E
02:000059A6 2E
02:000059A7 2E
02:000059A8 2E              	  1967: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000059A9 2E
02:000059AA 2E
02:000059AB 2E
02:000059AC 2E
02:000059AD 2E
02:000059AE 2E
02:000059AF 2E
02:000059B0 2E              	  1968: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000059B1 2E
02:000059B2 2E
02:000059B3 2E
02:000059B4 2E
02:000059B5 2E
02:000059B6 2E
02:000059B7 2E
02:000059B8 2E              	  1969: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000059B9 2E
02:000059BA 2E
02:000059BB 2E
02:000059BC 2E
02:000059BD 2E
02:000059BE 2E
02:000059BF 2E
02:000059C0 2E              	  1970: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000059C1 2E
02:000059C2 2E
02:000059C3 2E
02:000059C4 2E
02:000059C5 2E
02:000059C6 2E
02:000059C7 2E
02:000059C8 2E              	  1971: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000059C9 2E
02:000059CA 2E
02:000059CB 2E
02:000059CC 2E
02:000059CD 2E
02:000059CE 2E
02:000059CF 2E
02:000059D0 2E              	  1972: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000059D1 2E
02:000059D2 2E
02:000059D3 2E
02:000059D4 2E
02:000059D5 2E
02:000059D6 2E
02:000059D7 2E
02:000059D8 2E              	  1973: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000059D9 2E
02:000059DA 2E
02:000059DB 2E
02:000059DC 2E
02:000059DD 2E
02:000059DE 2E
02:000059DF 2E
02:000059E0 2E              	  1974: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000059E1 2E
02:000059E2 2E
02:000059E3 2E
02:000059E4 2E
02:000059E5 2E
02:000059E6 2E
02:000059E7 2E
02:000059E8 2E              	  1975: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000059E9 2E
02:000059EA 2E
02:000059EB 2E
02:000059EC 2E
02:000059ED 2E
02:000059EE 2E
02:000059EF 2E
02:000059F0 2E              	  1976: 	dc.b	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
02:000059F1 2E
02:000059F2 FA
02:000059F3 2E
02:000059F4 2E
02:000059F5 2E
02:000059F6 2E
02:000059F7 2E
                            	  1977: 
                            	  1978: _shiftedScanCodes:
02:000059F8 2E              	  1979: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000059F9 2E
02:000059FA 2E
02:000059FB 2E
02:000059FC 2E
02:000059FD 2E
02:000059FE 2E
02:000059FF 2E
02:00005A00 2E              	  1980: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
02:00005A01 2E
02:00005A02 2E
02:00005A03 2E
02:00005A04 2E
02:00005A05 09
02:00005A06 7E
02:00005A07 2E
02:00005A08 2E              	  1981: 	dc.b	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
02:00005A09 2E
02:00005A0A 2E
02:00005A0B 2E
02:00005A0C 2E
02:00005A0D 51
02:00005A0E 21
02:00005A0F 2E
02:00005A10 2E              	  1982: 	dc.b	$2e,$2e,$5a,$53,$41,$57,$40,$2e
02:00005A11 2E
02:00005A12 5A
02:00005A13 53
02:00005A14 41
02:00005A15 57
02:00005A16 40
02:00005A17 2E
02:00005A18 2E              	  1983: 	dc.b	$2e,$43,$58,$44,$45,$24,$23,$2e
02:00005A19 43
02:00005A1A 58
02:00005A1B 44
02:00005A1C 45
02:00005A1D 24
02:00005A1E 23
02:00005A1F 2E
02:00005A20 2E              	  1984: 	dc.b	$2e,$20,$56,$46,$54,$52,$25,$2e
02:00005A21 20
02:00005A22 56
02:00005A23 46
02:00005A24 54
02:00005A25 52
02:00005A26 25
02:00005A27 2E
02:00005A28 2E              	  1985: 	dc.b	$2e,$4e,$42,$48,$47,$59,$5e,$2e
02:00005A29 4E
02:00005A2A 42
02:00005A2B 48
02:00005A2C 47
02:00005A2D 59
02:00005A2E 5E
02:00005A2F 2E
02:00005A30 2E              	  1986: 	dc.b	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
02:00005A31 2E
02:00005A32 4D
02:00005A33 4A
02:00005A34 55
02:00005A35 26
02:00005A36 2A
02:00005A37 2E
02:00005A38 2E              	  1987: 	dc.b	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
02:00005A39 3C
02:00005A3A 4B
02:00005A3B 49
02:00005A3C 4F
02:00005A3D 29
02:00005A3E 28
02:00005A3F 2E
02:00005A40 2E              	  1988: 	dc.b	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
02:00005A41 3E
02:00005A42 3F
02:00005A43 4C
02:00005A44 3A
02:00005A45 50
02:00005A46 5F
02:00005A47 2E
02:00005A48 2E              	  1989: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
02:00005A49 2E
02:00005A4A 22
02:00005A4B 2E
02:00005A4C 7B
02:00005A4D 2B
02:00005A4E 2E
02:00005A4F 2E
02:00005A50 2E              	  1990: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
02:00005A51 2E
02:00005A52 0D
02:00005A53 7D
02:00005A54 2E
02:00005A55 7C
02:00005A56 2E
02:00005A57 2E
02:00005A58 2E              	  1991: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
02:00005A59 2E
02:00005A5A 2E
02:00005A5B 2E
02:00005A5C 2E
02:00005A5D 2E
02:00005A5E 08
02:00005A5F 2E
02:00005A60 2E              	  1992: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A61 2E
02:00005A62 2E
02:00005A63 2E
02:00005A64 2E
02:00005A65 2E
02:00005A66 2E
02:00005A67 2E
02:00005A68 2E              	  1993: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
02:00005A69 7F
02:00005A6A 2E
02:00005A6B 2E
02:00005A6C 2E
02:00005A6D 2E
02:00005A6E 1B
02:00005A6F 2E
02:00005A70 2E              	  1994: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A71 2E
02:00005A72 2E
02:00005A73 2E
02:00005A74 2E
02:00005A75 2E
02:00005A76 2E
02:00005A77 2E
                            	  1995: 
02:00005A78 2E              	  1996: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A79 2E
02:00005A7A 2E
02:00005A7B 2E
02:00005A7C 2E
02:00005A7D 2E
02:00005A7E 2E
02:00005A7F 2E
02:00005A80 2E              	  1997: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A81 2E
02:00005A82 2E
02:00005A83 2E
02:00005A84 2E
02:00005A85 2E
02:00005A86 2E
02:00005A87 2E
02:00005A88 2E              	  1998: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A89 2E
02:00005A8A 2E
02:00005A8B 2E
02:00005A8C 2E
02:00005A8D 2E
02:00005A8E 2E
02:00005A8F 2E
02:00005A90 2E              	  1999: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A91 2E
02:00005A92 2E
02:00005A93 2E
02:00005A94 2E
02:00005A95 2E
02:00005A96 2E
02:00005A97 2E
02:00005A98 2E              	  2000: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A99 2E
02:00005A9A 2E
02:00005A9B 2E
02:00005A9C 2E
02:00005A9D 2E
02:00005A9E 2E
02:00005A9F 2E
02:00005AA0 2E              	  2001: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005AA1 2E
02:00005AA2 2E
02:00005AA3 2E
02:00005AA4 2E
02:00005AA5 2E
02:00005AA6 2E
02:00005AA7 2E
02:00005AA8 2E              	  2002: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005AA9 2E
02:00005AAA 2E
02:00005AAB 2E
02:00005AAC 2E
02:00005AAD 2E
02:00005AAE 2E
02:00005AAF 2E
02:00005AB0 2E              	  2003: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005AB1 2E
02:00005AB2 2E
02:00005AB3 2E
02:00005AB4 2E
02:00005AB5 2E
02:00005AB6 2E
02:00005AB7 2E
02:00005AB8 2E              	  2004: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005AB9 2E
02:00005ABA 2E
02:00005ABB 2E
02:00005ABC 2E
02:00005ABD 2E
02:00005ABE 2E
02:00005ABF 2E
02:00005AC0 2E              	  2005: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005AC1 2E
02:00005AC2 2E
02:00005AC3 2E
02:00005AC4 2E
02:00005AC5 2E
02:00005AC6 2E
02:00005AC7 2E
02:00005AC8 2E              	  2006: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005AC9 2E
02:00005ACA 2E
02:00005ACB 2E
02:00005ACC 2E
02:00005ACD 2E
02:00005ACE 2E
02:00005ACF 2E
02:00005AD0 2E              	  2007: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005AD1 2E
02:00005AD2 2E
02:00005AD3 2E
02:00005AD4 2E
02:00005AD5 2E
02:00005AD6 2E
02:00005AD7 2E
02:00005AD8 2E              	  2008: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005AD9 2E
02:00005ADA 2E
02:00005ADB 2E
02:00005ADC 2E
02:00005ADD 2E
02:00005ADE 2E
02:00005ADF 2E
02:00005AE0 2E              	  2009: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005AE1 2E
02:00005AE2 2E
02:00005AE3 2E
02:00005AE4 2E
02:00005AE5 2E
02:00005AE6 2E
02:00005AE7 2E
02:00005AE8 2E              	  2010: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005AE9 2E
02:00005AEA 2E
02:00005AEB 2E
02:00005AEC 2E
02:00005AED 2E
02:00005AEE 2E
02:00005AEF 2E
02:00005AF0 2E              	  2011: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005AF1 2E
02:00005AF2 2E
02:00005AF3 2E
02:00005AF4 2E
02:00005AF5 2E
02:00005AF6 2E
02:00005AF7 2E
                            	  2012: 
                            	  2013: ; control
                            	  2014: _keybdControlCodes:
02:00005AF8 2E              	  2015: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005AF9 2E
02:00005AFA 2E
02:00005AFB 2E
02:00005AFC 2E
02:00005AFD 2E
02:00005AFE 2E
02:00005AFF 2E
02:00005B00 2E              	  2016: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
02:00005B01 2E
02:00005B02 2E
02:00005B03 2E
02:00005B04 2E
02:00005B05 09
02:00005B06 7E
02:00005B07 2E
02:00005B08 2E              	  2017: 	dc.b	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
02:00005B09 2E
02:00005B0A 2E
02:00005B0B 2E
02:00005B0C 2E
02:00005B0D 11
02:00005B0E 21
02:00005B0F 2E
02:00005B10 2E              	  2018: 	dc.b	$2e,$2e,$1a,$13,$01,$17,$40,$2e
02:00005B11 2E
02:00005B12 1A
02:00005B13 13
02:00005B14 01
02:00005B15 17
02:00005B16 40
02:00005B17 2E
02:00005B18 2E              	  2019: 	dc.b	$2e,$03,$18,$04,$05,$24,$23,$2e
02:00005B19 03
02:00005B1A 18
02:00005B1B 04
02:00005B1C 05
02:00005B1D 24
02:00005B1E 23
02:00005B1F 2E
02:00005B20 2E              	  2020: 	dc.b	$2e,$20,$16,$06,$14,$12,$25,$2e
02:00005B21 20
02:00005B22 16
02:00005B23 06
02:00005B24 14
02:00005B25 12
02:00005B26 25
02:00005B27 2E
02:00005B28 2E              	  2021: 	dc.b	$2e,$0e,$02,$08,$07,$19,$5e,$2e
02:00005B29 0E
02:00005B2A 02
02:00005B2B 08
02:00005B2C 07
02:00005B2D 19
02:00005B2E 5E
02:00005B2F 2E
02:00005B30 2E              	  2022: 	dc.b	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
02:00005B31 2E
02:00005B32 0D
02:00005B33 0A
02:00005B34 15
02:00005B35 26
02:00005B36 2A
02:00005B37 2E
02:00005B38 2E              	  2023: 	dc.b	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
02:00005B39 3C
02:00005B3A 0B
02:00005B3B 09
02:00005B3C 0F
02:00005B3D 29
02:00005B3E 28
02:00005B3F 2E
02:00005B40 2E              	  2024: 	dc.b	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
02:00005B41 3E
02:00005B42 3F
02:00005B43 0C
02:00005B44 3A
02:00005B45 10
02:00005B46 5F
02:00005B47 2E
02:00005B48 2E              	  2025: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
02:00005B49 2E
02:00005B4A 22
02:00005B4B 2E
02:00005B4C 7B
02:00005B4D 2B
02:00005B4E 2E
02:00005B4F 2E
02:00005B50 2E              	  2026: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
02:00005B51 2E
02:00005B52 0D
02:00005B53 7D
02:00005B54 2E
02:00005B55 7C
02:00005B56 2E
02:00005B57 2E
02:00005B58 2E              	  2027: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
02:00005B59 2E
02:00005B5A 2E
02:00005B5B 2E
02:00005B5C 2E
02:00005B5D 2E
02:00005B5E 08
02:00005B5F 2E
02:00005B60 2E              	  2028: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B61 2E
02:00005B62 2E
02:00005B63 2E
02:00005B64 2E
02:00005B65 2E
02:00005B66 2E
02:00005B67 2E
02:00005B68 2E              	  2029: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
02:00005B69 7F
02:00005B6A 2E
02:00005B6B 2E
02:00005B6C 2E
02:00005B6D 2E
02:00005B6E 1B
02:00005B6F 2E
02:00005B70 2E              	  2030: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B71 2E
02:00005B72 2E
02:00005B73 2E
02:00005B74 2E
02:00005B75 2E
02:00005B76 2E
02:00005B77 2E
                            	  2031: 
                            	  2032: _keybdExtendedCodes:
02:00005B78 2E              	  2033: 	dc.b	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
02:00005B79 2E
02:00005B7A 2E
02:00005B7B 2E
02:00005B7C A3
02:00005B7D A1
02:00005B7E A2
02:00005B7F 2E
02:00005B80 2E              	  2034: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B81 2E
02:00005B82 2E
02:00005B83 2E
02:00005B84 2E
02:00005B85 2E
02:00005B86 2E
02:00005B87 2E
02:00005B88 2E              	  2035: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B89 2E
02:00005B8A 2E
02:00005B8B 2E
02:00005B8C 2E
02:00005B8D 2E
02:00005B8E 2E
02:00005B8F 2E
02:00005B90 2E              	  2036: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B91 2E
02:00005B92 2E
02:00005B93 2E
02:00005B94 2E
02:00005B95 2E
02:00005B96 2E
02:00005B97 2E
02:00005B98 2E              	  2037: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B99 2E
02:00005B9A 2E
02:00005B9B 2E
02:00005B9C 2E
02:00005B9D 2E
02:00005B9E 2E
02:00005B9F 2E
02:00005BA0 2E              	  2038: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005BA1 2E
02:00005BA2 2E
02:00005BA3 2E
02:00005BA4 2E
02:00005BA5 2E
02:00005BA6 2E
02:00005BA7 2E
02:00005BA8 2E              	  2039: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005BA9 2E
02:00005BAA 2E
02:00005BAB 2E
02:00005BAC 2E
02:00005BAD 2E
02:00005BAE 2E
02:00005BAF 2E
02:00005BB0 2E              	  2040: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005BB1 2E
02:00005BB2 2E
02:00005BB3 2E
02:00005BB4 2E
02:00005BB5 2E
02:00005BB6 2E
02:00005BB7 2E
02:00005BB8 2E              	  2041: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005BB9 2E
02:00005BBA 2E
02:00005BBB 2E
02:00005BBC 2E
02:00005BBD 2E
02:00005BBE 2E
02:00005BBF 2E
02:00005BC0 2E              	  2042: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005BC1 2E
02:00005BC2 2E
02:00005BC3 2E
02:00005BC4 2E
02:00005BC5 2E
02:00005BC6 2E
02:00005BC7 2E
02:00005BC8 2E              	  2043: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005BC9 2E
02:00005BCA 2E
02:00005BCB 2E
02:00005BCC 2E
02:00005BCD 2E
02:00005BCE 2E
02:00005BCF 2E
02:00005BD0 2E              	  2044: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005BD1 2E
02:00005BD2 2E
02:00005BD3 2E
02:00005BD4 2E
02:00005BD5 2E
02:00005BD6 2E
02:00005BD7 2E
02:00005BD8 2E              	  2045: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005BD9 2E
02:00005BDA 2E
02:00005BDB 2E
02:00005BDC 2E
02:00005BDD 2E
02:00005BDE 2E
02:00005BDF 2E
02:00005BE0 2E              	  2046: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
02:00005BE1 95
02:00005BE2 2E
02:00005BE3 93
02:00005BE4 94
02:00005BE5 2E
02:00005BE6 2E
02:00005BE7 2E
02:00005BE8 98              	  2047: 	dc.b	$98,$99,$92,$2e,$91,$90,$2e,$2e
02:00005BE9 99
02:00005BEA 92
02:00005BEB 2E
02:00005BEC 91
02:00005BED 90
02:00005BEE 2E
02:00005BEF 2E
02:00005BF0 2E              	  2048: 	dc.b	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
02:00005BF1 2E
02:00005BF2 97
02:00005BF3 2E
02:00005BF4 2E
02:00005BF5 96
02:00005BF6 2E
02:00005BF7 2E
                            	  2049: 
                            	  2050: ;==============================================================================
                            	  2051: ;==============================================================================
                            	  2052: ; Monitor
                            	  2053: ;==============================================================================
                            	  2054: ;==============================================================================
                            	  2055: 
                            	  2056: cmdString:
02:00005BF8 BF              	  2057: 	dc.b	'?'+$80						; ? display help
02:00005BF9 CC              	  2058: 	dc.b	'L'+$80						; L load S19 file
02:00005BFA 46              	  2059: 	dc.b	'F','B'+$80				; FB fill with byte
02:00005BFB C2
02:00005BFC 46              	  2060: 	dc.b	'F','W'+$80				; FW fill with wyde
02:00005BFD D7
02:00005BFE 46              	  2061: 	dc.b	'F','L'+$80				; FL fill with long wyde
02:00005BFF CC
02:00005C00 42              	  2062: 	dc.b	'B','A'+$80				; BA start Tiny Basic
02:00005C01 C1
02:00005C02 42              	  2063: 	dc.b	'B','R'+$80				; BR breakpoint
02:00005C03 D2
02:00005C04 44              	  2064: 	dc.b	'D','R'+$80				; DR dump registers
02:00005C05 D2
02:00005C06 C4              	  2065: 	dc.b	'D'+$80						; D dump memory
02:00005C07 CA              	  2066: 	dc.b	'J'+$80						; J jump to code
02:00005C08 BA              	  2067: 	dc.b	':'+$80						; : edit memory
02:00005C09 434C            	  2068: 	dc.b	"CL",'S'+$80			; CLS clear screen
02:00005C0B D3
02:00005C0C 434F52          	  2069: 	dc.b	"COR",'E'+$80			; CORE <n> switch to core
02:00005C0F C5
02:00005C10 545241          	  2070: 	dc.b  "TRA",'M'+$80			; TRAM test RAM
02:00005C13 CD
02:00005C14 54              	  2071: 	dc.b	'T','R'+$80				; TR test serial receive
02:00005C15 D2
02:00005C16 D4              	  2072: 	dc.b	'T'+$80						; T test CPU
02:00005C17 D3              	  2073: 	dc.b	'S'+$80						; S send serial
02:00005C18 52455345        	  2074: 	dc.b	"RESE",'T'+$80		; RESET <n>
02:00005C1C D4
02:00005C1D 434C4F43        	  2075: 	dc.b	"CLOC",'K'+$80		; CLOCK <n>
02:00005C21 CB
02:00005C22 D2              	  2076: 	dc.b	'R'+$80						; R receive serial
                            	  2077: 
                            	  2078: 	align	2
                            	  2079: cmdTable:
02:00005C24 5DD0            	  2080: 	dc.w	cmdHelp
02:00005C26 6422            	  2081: 	dc.w	cmdLoadS19
02:00005C28 605A            	  2082: 	dc.w	cmdFillB
02:00005C2A 607E            	  2083: 	dc.w	cmdFillW
02:00005C2C 60A2            	  2084: 	dc.w	cmdFillL
02:00005C2E 5D1C            	  2085: 	dc.w	cmdTinyBasic
02:00005C30 5CF8            	  2086: 	dc.w	cmdBreakpoint
02:00005C32 61D4            	  2087: 	dc.w	cmdDumpRegs
02:00005C34 6146            	  2088: 	dc.w	cmdDumpMemory
02:00005C36 6138            	  2089: 	dc.w	cmdJump
02:00005C38 60D8            	  2090: 	dc.w	cmdEditMemory
02:00005C3A 5D30            	  2091: 	dc.w	cmdClearScreen
02:00005C3C 5D3C            	  2092: 	dc.w	cmdCore
02:00005C3E 6368            	  2093: 	dc.w  cmdTestRAM
02:00005C40 627E            	  2094: 	dc.w	cmdTestSerialReceive
02:00005C42 5D20            	  2095: 	dc.w	cmdTestCPU
02:00005C44 5FF6            	  2096: 	dc.w	cmdSendSerial
02:00005C46 5D7E            	  2097: 	dc.w	cmdReset
02:00005C48 5D60            	  2098: 	dc.w	cmdClock
02:00005C4A 6026            	  2099: 	dc.w	cmdReceiveSerial	
02:00005C4C 5C62            	  2100: 	dc.w	cmdMonitor
                            	  2101: 
                            	  2102: ; Get a word from screen memory and swap byte order
                            	  2103: 
                            	  2104: FromScreen:
02:00005C4E 2210            	  2105: 	move.l	(a0),d1
02:00005C50 610009EC        	  2106: 	bsr			rbo
02:00005C54 5088            	  2107: 	lea			8(a0),a0	; increment screen pointer
02:00005C56 4E75            	  2108: 	rts
                            	  2109: 
                            	  2110: StartMon:
02:00005C58 427900040202    	  2111: 	clr.w		NumSetBreakpoints
02:00005C5E 61000EBA        	  2112: 	bsr			ClearBreakpointList
                            	  2113: cmdMonitor:
                            	  2114: Monitor:
                            	  2115: 	; Reset the stack pointer on each entry into the monitor
02:00005C62 2E7C00040FFC    	  2116: 	move.l	#$40FFC,sp	; reset core's stack
02:00005C68 46FC2200        	  2117: 	move.w	#$2200,sr		; enable level 2 and higher interrupts
02:00005C6C 4E7A0FE0        	  2118: 	movec		coreno,d0
02:00005C70 4840            	  2119: 	swap		d0
02:00005C72 7201            	  2120: 	moveq		#1,d1
02:00005C74 6100A65A        	  2121: 	bsr			UnlockSemaphore
02:00005C78 42390004000C    	  2122: 	clr.b		KeybdEcho		; turn off keyboard echo
                            	  2123: PromptLn:
02:00005C7E 6100F268        	  2124: 	bsr			CRLF
02:00005C82 123C0024        	  2125: 	move.b	#'$',d1
02:00005C86 6100F2AA        	  2126: 	bsr			DisplayChar
                            	  2127: 
                            	  2128: ; Get characters until a CR is keyed
                            	  2129: ;
                            	  2130: Prompt3:
02:00005C8A 6100F8DE        	  2131: 	bsr			GetKey
02:00005C8E 0C0100FF        	  2132: 	cmpi.b	#-1,d1
02:00005C92 67F6            	  2133: 	beq.s		Prompt3
02:00005C94 0C01000D        	  2134: 	cmpi.b	#CR,d1
02:00005C98 6706            	  2135: 	beq.s		Prompt1
02:00005C9A 6100F296        	  2136: 	bsr			DisplayChar
02:00005C9E 60EA            	  2137: 	bra.s		Prompt3
                            	  2138: 
                            	  2139: ; Process the screen line that the CR was keyed on
                            	  2140: 
                            	  2141: Prompt1:
02:00005CA0 423900040001    	  2142: 	clr.b		CursorCol			; go back to the start of the line
02:00005CA6 6100F27C        	  2143: 	bsr			CalcScreenLoc	; a0 = screen memory location
                            	  2144: .0001:
02:00005CAA 61A2            	  2145: 	bsr			FromScreen		; grab character off screen
02:00005CAC 0C010024        	  2146: 	cmpi.b	#'$',d1				; skip over '$' prompt character
02:00005CB0 67F8            	  2147: 	beq.s		.0001
                            	  2148: 	
                            	  2149: ; Dispatch based on command string
                            	  2150: 
                            	  2151: cmdDispatch:
02:00005CB2 45FAFF44        	  2152: 	lea			cmdString,a2
02:00005CB6 7800            	  2153: 	clr.l		d4						; command counter
02:00005CB8 5188            	  2154: 	lea			-8(a0),a0			; backup a character
02:00005CBA 2648            	  2155: 	move.l	a0,a3					; a3 = start of command on screen
                            	  2156: .checkNextCmd:
02:00005CBC 6190            	  2157: 	bsr			FromScreen		; d1 = char from input screen
02:00005CBE 1A1A            	  2158: 	move.b	(a2)+,d5
02:00005CC0 BB01            	  2159: 	eor.b		d5,d1					; does it match with command string?
02:00005CC2 67F8            	  2160: 	beq.s		.checkNextCmd	; If it does, keep matching for longest match
02:00005CC4 0C010080        	  2161: 	cmpi.b	#$80,d1				; didn't match, was it the end of the command?
02:00005CC8 6724            	  2162: 	beq.s		.foundCmd
02:00005CCA 4A2AFFFF        	  2163: 	tst.b		-1(a2)				; was end of table hit?
02:00005CCE 6712            	  2164: 	beq.s		.endOfTable
02:00005CD0 5444            	  2165: 	addi.w	#2,d4					; increment command counter
02:00005CD2 204B            	  2166: 	move.l	a3,a0					; reset input pointer
02:00005CD4 4A2AFFFF        	  2167: 	tst.b		-1(a2)				; were we at the end of the command?
02:00005CD8 6BE2            	  2168: 	bmi.s		.checkNextCmd	; if were at end continue, otherwise scan for enf of cmd
                            	  2169: .scanToEndOfCmd
02:00005CDA 4A1A            	  2170: 	tst.b		(a2)+					; scan to end of command
02:00005CDC 6704            	  2171: 	beq.s		.endOfTable
02:00005CDE 6AFA            	  2172: 	bpl.s		.scanToEndOfCmd
02:00005CE0 6BDA            	  2173: 	bmi.s		.checkNextCmd
                            	  2174: .endOfTable
02:00005CE2 43FA024C        	  2175: 	lea			msgUnknownCmd,a1
02:00005CE6 6100F4DA        	  2176: 	bsr			DisplayStringCRLF
02:00005CEA 6000FF76        	  2177: 	bra			Monitor
                            	  2178: .foundCmd:
02:00005CEE 43FAFF34        	  2179: 	lea			cmdTable,a1		; a1 = pointer to command address table
02:00005CF2 32714000        	  2180: 	move.w	(a1,d4.w),a1	; fetch command routine address from table
02:00005CF6 4ED1            	  2181: 	jmp			(a1)					; go execute command
                            	  2182: 
                            	  2183: cmdBreakpoint:
02:00005CF8 610003CC        	  2184: 	bsr			ignBlanks
02:00005CFC 6100FF50        	  2185: 	bsr			FromScreen
02:00005D00 0C01002B        	  2186: 	cmpi.b	#'+',d1
02:00005D04 67000D22        	  2187: 	beq			ArmBreakpoint
02:00005D08 0C01002D        	  2188: 	cmpi.b	#'-',d1
02:00005D0C 67000D98        	  2189: 	beq			DisarmBreakpoint
02:00005D10 0C01004C        	  2190: 	cmpi.b	#'L',d1
02:00005D14 67000DE4        	  2191: 	beq			ListBreakpoints
02:00005D18 6000FF48        	  2192: 	bra			Monitor
                            	  2193: 
                            	  2194: cmdTinyBasic:
02:00005D1C 6000E17E        	  2195: 	bra			CSTART
                            	  2196: 
                            	  2197: cmdTestCPU:
02:00005D20 6100A620        	  2198: 	bsr			cpu_test
02:00005D24 43FA100A        	  2199: 	lea			msg_test_done,a1
02:00005D28 6100F498        	  2200: 	bsr			DisplayStringCRLF
02:00005D2C 6000FF34        	  2201: 	bra			Monitor
                            	  2202: 
                            	  2203: cmdClearScreen:
02:00005D30 61000906        	  2204: 	bsr			ClearScreen
02:00005D34 6100F4B8        	  2205: 	bsr			HomeCursor
02:00005D38 6000FF28        	  2206: 	bra			Monitor
                            	  2207: 
                            	  2208: cmdCore:
02:00005D3C 61000388        	  2209: 	bsr			ignBlanks
02:00005D40 6100FF0C        	  2210: 	bsr			FromScreen
02:00005D44 0C010032        	  2211: 	cmpi.b	#'2',d1					; check range
02:00005D48 6500FF18        	  2212: 	blo			Monitor
02:00005D4C 0C010039        	  2213: 	cmpi.b	#'9',d1
02:00005D50 6200FF10        	  2214: 	bhi			Monitor
02:00005D54 04010030        	  2215: 	subi.b	#'0',d1					; convert ascii to binary
02:00005D58 6100F5BE        	  2216: 	bsr			select_iofocus
02:00005D5C 6000FF04        	  2217: 	bra			Monitor
                            	  2218: 
                            	  2219: ;-------------------------------------------------------------------------------
                            	  2220: ; CLOCK <n>
                            	  2221: ;    Set the clock register to n which will turn off or on clocks to the CPUs.
                            	  2222: ;-------------------------------------------------------------------------------
                            	  2223: 
                            	  2224: cmdClock:
02:00005D60 61000364        	  2225: 	bsr			ignBlanks
02:00005D64 61000538        	  2226: 	bsr			GetHexNumber
02:00005D68 4A00            	  2227: 	tst.b		d0							; was there a number?
02:00005D6A 6700FEF6        	  2228: 	beq			Monitor
02:00005D6E 00400004        	  2229: 	ori.w		#4,d0						; primary core's clock cannot be turned off
02:00005D72 E159            	  2230: 	rol.w		#8,d1						; switch byte order
02:00005D74 33C1FD0FFC02    	  2231: 	move.w	d1,RST_REG+2
02:00005D7A 6000FEE6        	  2232: 	bra			Monitor
                            	  2233: 
                            	  2234: ;-------------------------------------------------------------------------------
                            	  2235: ; RESET <n>
                            	  2236: ;    Reset the specified core. Resetting the core automatically turns on the 
                            	  2237: ; core's clock.
                            	  2238: ;-------------------------------------------------------------------------------
                            	  2239: 
                            	  2240: cmdReset:
02:00005D7E 61000346        	  2241: 	bsr			ignBlanks
02:00005D82 6100FECA        	  2242: 	bsr			FromScreen
02:00005D86 0C010032        	  2243: 	cmpi.b	#'2',d1					; check range
02:00005D8A 6500FED6        	  2244: 	blo			Monitor
02:00005D8E 0C010039        	  2245: 	cmpi.b	#'9',d1
02:00005D92 6200FECE        	  2246: 	bhi			Monitor
02:00005D96 04010030        	  2247: 	subi.b	#'0',d1					; convert ascii to binary
02:00005D9A E349            	  2248: 	lsl.w		#1,d1						; make into index
02:00005D9C 43FA0012        	  2249: 	lea			tblPow2,a1
02:00005DA0 32311000        	  2250: 	move.w	(a1,d1.w),d1
02:00005DA4 E159            	  2251: 	rol.w		#8,d1						; reverse byte order
02:00005DA6 33C1FD0FFC00    	  2252: 	move.w	d1,RST_REG
02:00005DAC 6000FEB4        	  2253: 	bra			Monitor
                            	  2254: 
                            	  2255: tblPow2:
02:00005DB0 0001            	  2256: 	dc.w		1
02:00005DB2 0002            	  2257: 	dc.w		2
02:00005DB4 0004            	  2258: 	dc.w		4
02:00005DB6 0008            	  2259: 	dc.w		8
02:00005DB8 0010            	  2260: 	dc.w		16
02:00005DBA 0020            	  2261: 	dc.w		32
02:00005DBC 0040            	  2262: 	dc.w		64
02:00005DBE 0080            	  2263: 	dc.w		128
02:00005DC0 0100            	  2264: 	dc.w		256
02:00005DC2 0200            	  2265: 	dc.w		512
02:00005DC4 0400            	  2266: 	dc.w		1024
02:00005DC6 0800            	  2267: 	dc.w		2048
02:00005DC8 1000            	  2268: 	dc.w		4096
02:00005DCA 2000            	  2269: 	dc.w		8192
02:00005DCC 4000            	  2270: 	dc.w		16384
02:00005DCE 8000            	  2271: 	dc.w		32768
                            	  2272: 	even
                            	  2273: 	
                            	  2274: cmdHelp:
                            	  2275: DisplayHelp:
02:00005DD0 43FA000A        	  2276: 	lea			HelpMsg,a1
02:00005DD4 6100F3D6        	  2277: 	bsr			DisplayString
02:00005DD8 6000FE88        	  2278: 	bra			Monitor
                            	  2279: 
                            	  2280: HelpMsg:
02:00005DDC 3F203D2044697370	  2281: 	dc.b	"? = Display help",LF,CR
02:00005DE4 6C61792068656C70
02:00005DEC 0A
02:00005DED 0D
02:00005DEE 434F5245206E203D	  2282: 	dc.b  "CORE n = switch to core n, n = 2 to 7",LF,CR
02:00005DF6 2073776974636820
02:00005DFE 746F20636F726520
02:00005E06 6E2C206E203D2032
02:00005E0E 20746F2037
02:00005E13 0A
02:00005E14 0D
02:00005E15 5245534554206E20	  2283: 	dc.b  "RESET n = reset core n",LF,CR
02:00005E1D 3D20726573657420
02:00005E25 636F7265206E
02:00005E2B 0A
02:00005E2C 0D
02:00005E2D 434C53203D20636C	  2284: 	dc.b	"CLS = clear screen",LF,CR
02:00005E35 6561722073637265
02:00005E3D 656E
02:00005E3F 0A
02:00005E40 0D
02:00005E41 3A203D2045646974	  2285: 	dc.b	": = Edit memory bytes",LF,CR
02:00005E49 206D656D6F727920
02:00005E51 6279746573
02:00005E56 0A
02:00005E57 0D
02:00005E58 4642203D2046696C	  2286: 	dc.b	"FB = Fill memory bytes, FW, FL",LF,CR
02:00005E60 6C206D656D6F7279
02:00005E68 2062797465732C20
02:00005E70 46572C20464C
02:00005E76 0A
02:00005E77 0D
02:00005E78 4C203D204C6F6164	  2287: 	dc.b	"L = Load S19 file",LF,CR
02:00005E80 205331392066696C
02:00005E88 65
02:00005E89 0A
02:00005E8A 0D
02:00005E8B 44203D2044756D70	  2288: 	dc.b	"D = Dump memory, DR = dump registers",LF,CR
02:00005E93 206D656D6F72792C
02:00005E9B 204452203D206475
02:00005EA3 6D70207265676973
02:00005EAB 74657273
02:00005EAF 0A
02:00005EB0 0D
02:00005EB1 4241203D20737461	  2289: 	dc.b	"BA = start tiny basic",LF,CR
02:00005EB9 72742074696E7920
02:00005EC1 6261736963
02:00005EC6 0A
02:00005EC7 0D
02:00005EC8 4252203D20736574	  2290: 	dc.b  "BR = set breakpoint",LF,CR
02:00005ED0 20627265616B706F
02:00005ED8 696E74
02:00005EDB 0A
02:00005EDC 0D
02:00005EDD 4A203D204A756D70	  2291: 	dc.b	"J = Jump to code",LF,CR
02:00005EE5 20746F20636F6465
02:00005EED 0A
02:00005EEE 0D
02:00005EEF 53203D2073656E64	  2292: 	dc.b  "S = send to serial port",LF,CR
02:00005EF7 20746F2073657269
02:00005EFF 616C20706F7274
02:00005F06 0A
02:00005F07 0D
02:00005F08 54203D2063707520	  2293: 	dc.b	"T = cpu test program",LF,CR
02:00005F10 746573742070726F
02:00005F18 6772616D
02:00005F1C 0A
02:00005F1D 0D
02:00005F1E 5452414D203D2074	  2294: 	dc.b	"TRAM = test RAM",LF,CR,0
02:00005F26 6573742052414D
02:00005F2D 0A
02:00005F2E 0D
02:00005F2F 00
                            	  2295: 
                            	  2296: msgUnknownCmd:
02:00005F30 636F6D6D616E6420	  2297: 	dc.b	"command unknown",0
02:00005F38 756E6B6E6F776E
02:00005F3F 00
                            	  2298: 
                            	  2299: msgHello:
02:00005F40 0A              	  2300: 	dc.b	LF,CR,"Hello World!",LF,CR,0
02:00005F41 0D
02:00005F42 48656C6C6F20576F
02:00005F4A 726C6421
02:00005F4E 0A
02:00005F4F 0D
02:00005F50 00
                            	  2301: 	even
                            	  2302: 
                            	  2303: ;------------------------------------------------------------------------------
                            	  2304: ; This routine borrowed from Gordo's Tiny Basic interpreter.
                            	  2305: ; Used to fetch a command line. (Not currently used).
                            	  2306: ;
                            	  2307: ; d0.b	- command prompt
                            	  2308: ;------------------------------------------------------------------------------
                            	  2309: 
                            	  2310: GetCmdLine:
02:00005F52 6100EFDE        	  2311: 		bsr		DisplayChar		; display prompt
02:00005F56 103C0020        	  2312: 		move.b	#' ',d0
02:00005F5A 6100EFD6        	  2313: 		bsr		DisplayChar
02:00005F5E 41F900040040    	  2314: 		lea		CmdBuf,a0
                            	  2315: .0001:
02:00005F64 6100F604        	  2316: 		bsr		GetKey
02:00005F68 B03C0008        	  2317: 		cmp.b	#CTRLH,d0
02:00005F6C 6728            	  2318: 		beq.s	.0003
02:00005F6E B03C0018        	  2319: 		cmp.b	#CTRLX,d0
02:00005F72 6746            	  2320: 		beq.s	.0004
02:00005F74 B03C000D        	  2321: 		cmp.b	#CR,d0
02:00005F78 6706            	  2322: 		beq.s	.0002
02:00005F7A B03C0020        	  2323: 		cmp.b	#' ',d0
02:00005F7E 65E4            	  2324: 		bcs.s	.0001
                            	  2325: .0002:
02:00005F80 1080            	  2326: 		move.b	d0,(a0)
02:00005F82 5088            	  2327: 		lea			8(a0),a0
02:00005F84 6100EFAC        	  2328: 		bsr		DisplayChar
02:00005F88 B03C000D        	  2329: 		cmp.b	#CR,d0
02:00005F8C 675E            	  2330: 		beq		.0007
02:00005F8E B1FC0004007F    	  2331: 		cmp.l	#CmdBufEnd-1,a0
02:00005F94 65CE            	  2332: 		bcs.s	.0001
                            	  2333: .0003:
02:00005F96 103C0008        	  2334: 		move.b	#CTRLH,d0
02:00005F9A 6100EF96        	  2335: 		bsr		DisplayChar
02:00005F9E 103C0020        	  2336: 		move.b	#' ',d0
02:00005FA2 6100EF8E        	  2337: 		bsr		DisplayChar
02:00005FA6 B1FC00040040    	  2338: 		cmp.l	#CmdBuf,a0
02:00005FAC 63B6            	  2339: 		bls.s	.0001
02:00005FAE 103C0008        	  2340: 		move.b	#CTRLH,d0
02:00005FB2 6100EF7E        	  2341: 		bsr		DisplayChar
02:00005FB6 5388            	  2342: 		subq.l	#1,a0
02:00005FB8 60AA            	  2343: 		bra.s	.0001
                            	  2344: .0004:
02:00005FBA 2208            	  2345: 		move.l	a0,d1
02:00005FBC 92BC00040040    	  2346: 		sub.l	#CmdBuf,d1
02:00005FC2 671E            	  2347: 		beq.s	.0006
02:00005FC4 5341            	  2348: 		subq	#1,d1
                            	  2349: .0005:
02:00005FC6 103C0008        	  2350: 		move.b	#CTRLH,d0
02:00005FCA 6100EF66        	  2351: 		bsr		DisplayChar
02:00005FCE 103C0020        	  2352: 		move.b	#' ',d0
02:00005FD2 6100EF5E        	  2353: 		bsr		DisplayChar
02:00005FD6 103C0008        	  2354: 		move.b	#CTRLH,d0
02:00005FDA 6100EF56        	  2355: 		bsr		DisplayChar
02:00005FDE 51C9FFE6        	  2356: 		dbra	d1,.0005
                            	  2357: .0006:
02:00005FE2 41F900040040    	  2358: 		lea		CmdBuf,a0
02:00005FE8 6000FF7A        	  2359: 		bra		.0001
                            	  2360: .0007:
02:00005FEC 103C000A        	  2361: 		move.b	#LF,d0
02:00005FF0 6100EF40        	  2362: 		bsr		DisplayChar
02:00005FF4 4E75            	  2363: 		rts
                            	  2364: 
                            	  2365: ;------------------------------------------------------------------------------
                            	  2366: ; S <address> <length>
                            	  2367: ; Send data buffer to serial port
                            	  2368: ; S 40000 40
                            	  2369: ;------------------------------------------------------------------------------
                            	  2370: 
                            	  2371: cmdSendSerial:
02:00005FF6 610000CE        	  2372: 	bsr			ignBlanks
02:00005FFA 610002A2        	  2373: 	bsr			GetHexNumber
02:00005FFE 6700FC62        	  2374: 	beq			Monitor
02:00006002 2C01            	  2375: 	move.l	d1,d6					; d6 points to buffer
02:00006004 610000C0        	  2376: 	bsr			ignBlanks
02:00006008 61000294        	  2377: 	bsr			GetHexNumber
02:0000600C 6602            	  2378: 	bne.s		.0003
02:0000600E 7210            	  2379: 	moveq		#16,d1
                            	  2380: .0003:
02:00006010 2246            	  2381: 	move.l	d6,a1					; a1 points to buffer
02:00006012 2401            	  2382: 	move.l	d1,d2					; d2 = count of bytes to send
02:00006014 6008            	  2383: 	bra.s		.0002					; enter loop at bottom
                            	  2384: .0001:
02:00006016 1219            	  2385: 	move.b	(a1)+,d1
02:00006018 303C0022        	  2386: 	move.w	#34,d0				; serial putchar
02:0000601C 4E4F            	  2387: 	trap		#15
                            	  2388: .0002:
02:0000601E 51CAFFF6        	  2389: 	dbra		d2,.0001
02:00006022 6000FC3E        	  2390: 	bra			Monitor
                            	  2391: 		
                            	  2392: ;------------------------------------------------------------------------------
                            	  2393: ; R <address> <length>
                            	  2394: ; Send data buffer to serial port
                            	  2395: ; R 10000 40
                            	  2396: ;------------------------------------------------------------------------------
                            	  2397: 
                            	  2398: cmdReceiveSerial:
02:00006026 6100009E        	  2399: 	bsr			ignBlanks
02:0000602A 61000272        	  2400: 	bsr			GetHexNumber
02:0000602E 6700FC32        	  2401: 	beq			Monitor
02:00006032 2C01            	  2402: 	move.l	d1,d6					; d6 points to buffer
02:00006034 61000090        	  2403: 	bsr			ignBlanks
02:00006038 61000264        	  2404: 	bsr			GetHexNumber
02:0000603C 6602            	  2405: 	bne.s		.0003
02:0000603E 7210            	  2406: 	moveq		#16,d1
                            	  2407: .0003:
02:00006040 2246            	  2408: 	move.l	d6,a1					; a1 points to buffer
02:00006042 2401            	  2409: 	move.l	d1,d2					; d2 = count of bytes to send
02:00006044 600C            	  2410: 	bra.s		.0002					; enter loop at bottom
                            	  2411: .0001:
02:00006046 303C0024        	  2412: 	move.w	#36,d0				; serial peek char
02:0000604A 4E4F            	  2413: 	trap		#15
02:0000604C 4A81            	  2414: 	tst.l		d1
02:0000604E 6BF6            	  2415: 	bmi.s		.0001
02:00006050 12C1            	  2416: 	move.b	d1,(a1)+
                            	  2417: .0002:
02:00006052 51CAFFF2        	  2418: 	dbra		d2,.0001
02:00006056 6000FC0A        	  2419: 	bra			Monitor
                            	  2420: 		
                            	  2421: ;------------------------------------------------------------------------------
                            	  2422: ; Fill memory
                            	  2423: ;
                            	  2424: ; FB = fill bytes		FB 00000010 100 FF	; fill starting at 10 for 256 bytes
                            	  2425: ; FW = fill words
                            	  2426: ; FL = fill longs
                            	  2427: ; F = fill bytes
                            	  2428: ;------------------------------------------------------------------------------
                            	  2429: 
                            	  2430: cmdFillB:
02:0000605A 616A            	  2431: 	bsr			ignBlanks
02:0000605C 61000240        	  2432: 	bsr			GetHexNumber
02:00006060 2241            	  2433: 	move.l	d1,a1					; a1 = start
02:00006062 6162            	  2434: 	bsr			ignBlanks
02:00006064 61000238        	  2435: 	bsr			GetHexNumber
02:00006068 2601            	  2436: 	move.l	d1,d3					; d3 = count
02:0000606A 6700FBF6        	  2437: 	beq			Monitor
02:0000606E 6156            	  2438: 	bsr			ignBlanks
02:00006070 6100022C        	  2439: 	bsr			GetHexNumber	; fill value
                            	  2440: .fmem:
02:00006074 12C1            	  2441: 	move.b	d1,(a1)+
02:00006076 5383            	  2442: 	sub.l		#1,d3
02:00006078 66FA            	  2443: 	bne.s		.fmem
02:0000607A 6000FBE6        	  2444: 	bra			Monitor
                            	  2445: 	
                            	  2446: cmdFillW:
02:0000607E 6146            	  2447: 	bsr			ignBlanks
02:00006080 6100021C        	  2448: 	bsr			GetHexNumber
02:00006084 2241            	  2449: 	move.l	d1,a1					; a1 = start
02:00006086 613E            	  2450: 	bsr			ignBlanks
02:00006088 61000214        	  2451: 	bsr			GetHexNumber
02:0000608C 2601            	  2452: 	move.l	d1,d3					; d3 = count
02:0000608E 6700FBD2        	  2453: 	beq			Monitor
02:00006092 6132            	  2454: 	bsr			ignBlanks
02:00006094 61000208        	  2455: 	bsr			GetHexNumber	; fill value
                            	  2456: .fmem:
02:00006098 32C1            	  2457: 	move.w	d1,(a1)+
02:0000609A 5383            	  2458: 	sub.l		#1,d3
02:0000609C 66FA            	  2459: 	bne.s		.fmem
02:0000609E 6000FBC2        	  2460: 	bra			Monitor
                            	  2461: 	
                            	  2462: cmdFillL:
02:000060A2 6122            	  2463: 	bsr			ignBlanks
02:000060A4 610001F8        	  2464: 	bsr			GetHexNumber
02:000060A8 2241            	  2465: 	move.l	d1,a1					; a1 = start
02:000060AA 611A            	  2466: 	bsr			ignBlanks
02:000060AC 610001F0        	  2467: 	bsr			GetHexNumber
02:000060B0 2601            	  2468: 	move.l	d1,d3					; d3 = count
02:000060B2 6700FBAE        	  2469: 	beq			Monitor
02:000060B6 610E            	  2470: 	bsr			ignBlanks
02:000060B8 610001E4        	  2471: 	bsr			GetHexNumber	; fill value
                            	  2472: .fmem:
02:000060BC 22C1            	  2473: 	move.l	d1,(a1)+
02:000060BE 5383            	  2474: 	sub.l		#1,d3
02:000060C0 66FA            	  2475: 	bne.s		.fmem
02:000060C2 6000FB9E        	  2476: 	bra			Monitor
                            	  2477: 	
                            	  2478: ;------------------------------------------------------------------------------
                            	  2479: ; Modifies:
                            	  2480: ;	a0	- text pointer
                            	  2481: ;------------------------------------------------------------------------------
                            	  2482: 
                            	  2483: ignBlanks:
02:000060C6 2F01            	  2484: 	move.l	d1,-(a7)
                            	  2485: .0001:
02:000060C8 6100FB84        	  2486: 	bsr			FromScreen
02:000060CC 0C010020        	  2487: 	cmpi.b	#' ',d1
02:000060D0 67F6            	  2488: 	beq.s		.0001
02:000060D2 5188            	  2489: 	lea			-8(a0),a0
02:000060D4 221F            	  2490: 	move.l	(a7)+,d1
02:000060D6 4E75            	  2491: 	rts
                            	  2492: 
                            	  2493: ;------------------------------------------------------------------------------
                            	  2494: ; Edit memory byte.
                            	  2495: ;    Bytes are built into long words in case the memory is only longword
                            	  2496: ; accessible.
                            	  2497: ;------------------------------------------------------------------------------
                            	  2498: 
                            	  2499: cmdEditMemory:
02:000060D8 61EC            	  2500: 	bsr			ignBlanks
02:000060DA 610001C2        	  2501: 	bsr			GetHexNumber
02:000060DE 2241            	  2502: 	move.l	d1,a1
                            	  2503: edtmem1:
02:000060E0 7400            	  2504: 	clr.l		d2
02:000060E2 61E2            	  2505: 	bsr			ignBlanks
02:000060E4 610001B8        	  2506: 	bsr			GetHexNumber
02:000060E8 1401            	  2507: 	move.b	d1,d2
                            	  2508: ;	move.b	d1,(a1)+
02:000060EA 61DA            	  2509: 	bsr			ignBlanks
02:000060EC 610001B0        	  2510: 	bsr			GetHexNumber
02:000060F0 E18A            	  2511: 	lsl.l		#8,d2
02:000060F2 1401            	  2512: 	move.b	d1,d2
                            	  2513: ;	move.b	d1,(a1)+
02:000060F4 61D0            	  2514: 	bsr			ignBlanks
02:000060F6 610001A6        	  2515: 	bsr			GetHexNumber
02:000060FA E18A            	  2516: 	lsl.l		#8,d2
02:000060FC 1401            	  2517: 	move.b	d1,d2
                            	  2518: ;	move.b	d1,(a1)+
02:000060FE 61C6            	  2519: 	bsr			ignBlanks
02:00006100 6100019C        	  2520: 	bsr			GetHexNumber
02:00006104 E18A            	  2521: 	lsl.l		#8,d2
02:00006106 1401            	  2522: 	move.b	d1,d2
02:00006108 22C2            	  2523: 	move.l	d2,(a1)+
                            	  2524: ;	move.b	d1,(a1)+
02:0000610A 7400            	  2525: 	clr.l		d2
02:0000610C 61B8            	  2526: 	bsr			ignBlanks
02:0000610E 6100018E        	  2527: 	bsr			GetHexNumber
02:00006112 1401            	  2528: 	move.b	d1,d2
                            	  2529: ;	move.b	d1,(a1)+
02:00006114 61B0            	  2530: 	bsr			ignBlanks
02:00006116 61000186        	  2531: 	bsr			GetHexNumber
02:0000611A E18A            	  2532: 	lsl.l		#8,d2
02:0000611C 1401            	  2533: 	move.b	d1,d2
                            	  2534: ;	move.b	d1,(a1)+
02:0000611E 61A6            	  2535: 	bsr			ignBlanks
02:00006120 6100017C        	  2536: 	bsr			GetHexNumber
02:00006124 E18A            	  2537: 	lsl.l		#8,d2
02:00006126 1401            	  2538: 	move.b	d1,d2
                            	  2539: ;	move.b	d1,(a1)+
02:00006128 619C            	  2540: 	bsr			ignBlanks
02:0000612A 61000172        	  2541: 	bsr			GetHexNumber
02:0000612E E18A            	  2542: 	lsl.l		#8,d2
02:00006130 1401            	  2543: 	move.b	d1,d2
                            	  2544: ;	move.b	d1,(a1)+
02:00006132 22C2            	  2545: 	move.l	d2,(a1)+
02:00006134 6000FB2C        	  2546: 	bra			Monitor
                            	  2547: 
                            	  2548: ;------------------------------------------------------------------------------
                            	  2549: ; Execute code at the specified address.
                            	  2550: ;------------------------------------------------------------------------------
                            	  2551: 
                            	  2552: cmdJump:
                            	  2553: ExecuteCode:
02:00006138 618C            	  2554: 	bsr			ignBlanks
02:0000613A 61000162        	  2555: 	bsr			GetHexNumber
02:0000613E 2041            	  2556: 	move.l	d1,a0
02:00006140 4E90            	  2557: 	jsr			(a0)
02:00006142 6000FB1E        	  2558: 	bra     Monitor
                            	  2559: 
                            	  2560: ;------------------------------------------------------------------------------
                            	  2561: ; Do a memory dump of the requested location.
                            	  2562: ; D 0800 0850
                            	  2563: ;------------------------------------------------------------------------------
                            	  2564: 
                            	  2565: cmdDumpMemory:
02:00006146 6100FF7E        	  2566: 	bsr			ignBlanks
02:0000614A 61000152        	  2567: 	bsr			GetHexNumber
02:0000614E 6700FB12        	  2568: 	beq			Monitor			; was there a number ? no, other garbage, just ignore
02:00006152 2601            	  2569: 	move.l	d1,d3				; save off start of range
02:00006154 6100FF70        	  2570: 	bsr			ignBlanks
02:00006158 61000144        	  2571: 	bsr			GetHexNumber
02:0000615C 6608            	  2572: 	bne.s		DumpMem1
02:0000615E 2203            	  2573: 	move.l	d3,d1
02:00006160 068100000040    	  2574: 	addi.l	#64,d1			; no end specified, just dump 64 bytes
                            	  2575: DumpMem1:
02:00006166 2043            	  2576: 	move.l	d3,a0
02:00006168 2241            	  2577: 	move.l	d1,a1
02:0000616A 6100ED7C        	  2578: 	bsr			CRLF
                            	  2579: .0001:
02:0000616E B3C8            	  2580: 	cmpa.l	a0,a1
02:00006170 6300FAF0        	  2581: 	bls			Monitor
02:00006174 6102            	  2582: 	bsr			DisplayMem
02:00006176 60F6            	  2583: 	bra.s		.0001
                            	  2584: 
                            	  2585: ;------------------------------------------------------------------------------
                            	  2586: ; Display memory dump in a format suitable for edit.
                            	  2587: ;
                            	  2588: ;	:12345678 00 11 22 33 44 55 66 77  "........"
                            	  2589: ;
                            	  2590: ; Modifies:
                            	  2591: ;		d1,d2,a0
                            	  2592: ;------------------------------------------------------------------------------
                            	  2593: 
                            	  2594: DisplayMem:
02:00006178 123C003A        	  2595: 	move.b	#':',d1
02:0000617C 6100EDB4        	  2596: 	bsr			DisplayChar
02:00006180 2208            	  2597: 	move.l	a0,d1
02:00006182 6100019A        	  2598: 	bsr			DisplayTetra
02:00006186 7407            	  2599: 	moveq		#7,d2
                            	  2600: dspmem1:
02:00006188 123C0020        	  2601: 	move.b	#' ',d1
02:0000618C 6100EDA4        	  2602: 	bsr			DisplayChar
02:00006190 1218            	  2603: 	move.b	(a0)+,d1
02:00006192 61000196        	  2604: 	bsr			DisplayByte
02:00006196 51CAFFF0        	  2605: 	dbra		d2,dspmem1
02:0000619A 61000168        	  2606: 	bsr			DisplayTwoSpaces
02:0000619E 123C0022        	  2607: 	move.b	#34,d1
02:000061A2 6100ED8E        	  2608: 	bsr			DisplayChar
02:000061A6 5188            	  2609: 	lea			-8(a0),a0
02:000061A8 7407            	  2610: 	moveq		#7,d2
                            	  2611: .0002:	
02:000061AA 1218            	  2612: 	move.b	(a0)+,d1
02:000061AC B23C0020        	  2613: 	cmp.b		#' ',d1
02:000061B0 6506            	  2614: 	blo.s		.0003
02:000061B2 B23C007F        	  2615: 	cmp.b		#127,d1
02:000061B6 6304            	  2616: 	bls.s		.0001
                            	  2617: .0003:
02:000061B8 123C002E        	  2618: 	move.b	#'.',d1
                            	  2619: .0001:
02:000061BC 6100ED74        	  2620: 	bsr			DisplayChar
02:000061C0 51CAFFE8        	  2621: 	dbra		d2,.0002
02:000061C4 123C0022        	  2622: 	move.b	#34,d1
02:000061C8 6100ED68        	  2623: 	bsr			DisplayChar
02:000061CC 6100F3D4        	  2624: 	bsr			CheckForCtrlC
02:000061D0 6000ED16        	  2625: 	bra			CRLF
                            	  2626: 
                            	  2627: ;------------------------------------------------------------------------------
                            	  2628: ; Dump Registers
                            	  2629: ;    The dump is in a format that allows the register value to be edited.
                            	  2630: ;
                            	  2631: ; RegD0 12345678
                            	  2632: ; RegD1 77777777
                            	  2633: ;	... etc
                            	  2634: ;------------------------------------------------------------------------------
                            	  2635: 
                            	  2636: cmdDumpRegs:
02:000061D4 6100ED12        	  2637: 	bsr			CRLF
02:000061D8 303C000F        	  2638: 	move.w	#15,d0					; number of registers-1
02:000061DC 41FA007A        	  2639: 	lea			msg_reglist,a0	;
02:000061E0 43FA0072        	  2640: 	lea			msg_regs,a1
02:000061E4 45F900040100    	  2641: 	lea			Regsave,a2			; a2 points to register save area
                            	  2642: .0001:
02:000061EA 6100EFC0        	  2643: 	bsr			DisplayString
02:000061EE 1218            	  2644: 	move.b	(a0)+,d1
02:000061F0 6100ED40        	  2645: 	bsr			DisplayChar
02:000061F4 1218            	  2646: 	move.b	(a0)+,d1
02:000061F6 6100ED3A        	  2647: 	bsr			DisplayChar
02:000061FA 6100011A        	  2648: 	bsr			DisplaySpace
02:000061FE 221A            	  2649: 	move.l	(a2)+,d1
02:00006200 6100011C        	  2650: 	bsr			DisplayTetra
02:00006204 6100ECE2        	  2651: 	bsr			CRLF
02:00006208 51C8FFE0        	  2652: 	dbra		d0,.0001
02:0000620C 6100EF9E        	  2653: 	bsr			DisplayString
02:00006210 1218            	  2654: 	move.b	(a0)+,d1
02:00006212 6100ED1E        	  2655: 	bsr			DisplayChar
02:00006216 1218            	  2656: 	move.b	(a0)+,d1
02:00006218 6100ED18        	  2657: 	bsr			DisplayChar
02:0000621C 610000F8        	  2658: 	bsr			DisplaySpace
02:00006220 223900040144    	  2659: 	move.l	Regsave+$44,d1
02:00006226 610000F6        	  2660: 	bsr			DisplayTetra
02:0000622A 6100ECBC        	  2661: 	bsr			CRLF
02:0000622E 6100EF7C        	  2662: 	bsr			DisplayString
02:00006232 1218            	  2663: 	move.b	(a0)+,d1
02:00006234 6100ECFC        	  2664: 	bsr			DisplayChar
02:00006238 1218            	  2665: 	move.b	(a0)+,d1
02:0000623A 6100ECF6        	  2666: 	bsr			DisplayChar
02:0000623E 610000D6        	  2667: 	bsr			DisplaySpace
02:00006242 323900040140    	  2668: 	move.w	Regsave+$40,d1
02:00006248 610000DA        	  2669: 	bsr			DisplayWyde
02:0000624C 6100EC9A        	  2670: 	bsr			CRLF
02:00006250 6000FA10        	  2671: 	bra			Monitor
                            	  2672: 
                            	  2673: msg_regs:
02:00006254 526567          	  2674: 	dc.b	"Reg",0
02:00006257 00
                            	  2675: msg_reglist:
02:00006258 4430443144324433	  2676: 	dc.b	"D0D1D2D3D4D5D6D7A0A1A2A3A4A5A6A7PCSR",0
02:00006260 4434443544364437
02:00006268 4130413141324133
02:00006270 4134413541364137
02:00006278 50435352
02:0000627C 00
                            	  2677: 
                            	  2678: 	align	1
                            	  2679: 
                            	  2680: ;------------------------------------------------------------------------------
                            	  2681: ;------------------------------------------------------------------------------
                            	  2682: 
                            	  2683: cmdTestSerialReceive:
                            	  2684: .0002:
02:0000627E 7024            	  2685: 	moveq		#36,d0				; serial get char from buffer
02:00006280 4E4F            	  2686: 	trap		#15
                            	  2687: ;	bsr			SerialPeekCharDirect
02:00006282 4A41            	  2688: 	tst.w		d1
02:00006284 6B0A            	  2689: 	bmi.s		.0001
02:00006286 0C01001A        	  2690: 	cmpi.b	#CTRLZ,d1
02:0000628A 670A            	  2691: 	beq			.0003
02:0000628C 6100ECA4        	  2692: 	bsr			DisplayChar
                            	  2693: .0001:	
02:00006290 6100F310        	  2694: 	bsr			CheckForCtrlC
02:00006294 60E8            	  2695: 	bra			.0002
                            	  2696: .0003:
02:00006296 6100F15E        	  2697: 	bsr			_KeybdInit
02:0000629A 6000F9C6        	  2698: 	bra			Monitor
                            	  2699: 
                            	  2700: ;------------------------------------------------------------------------------
                            	  2701: ; Get a hexidecimal number. Maximum of eight digits.
                            	  2702: ;
                            	  2703: ; Returns:
                            	  2704: ;		d0 = number of digits
                            	  2705: ;		d1 = value of number
                            	  2706: ;		zf = number of digits == 0
                            	  2707: ;------------------------------------------------------------------------------
                            	  2708: 
                            	  2709: GetHexNumber:
02:0000629E 2F02            	  2710: 	move.l	d2,-(a7)
02:000062A0 7400            	  2711: 	clr.l		d2
02:000062A2 7000            	  2712: 	moveq		#0,d0
                            	  2713: .0002:
02:000062A4 6100F9A8        	  2714: 	bsr			FromScreen
02:000062A8 6120            	  2715: 	bsr			AsciiToHexNybble
02:000062AA B23C00FF        	  2716: 	cmp.b		#$ff,d1
02:000062AE 6712            	  2717: 	beq.s		.0001
02:000062B0 E98A            	  2718: 	lsl.l		#4,d2
02:000062B2 02810000000F    	  2719: 	andi.l	#$0f,d1
02:000062B8 8481            	  2720: 	or.l		d1,d2
02:000062BA 5240            	  2721: 	addq		#1,d0
02:000062BC 0C000008        	  2722: 	cmpi.b	#8,d0
02:000062C0 65E2            	  2723: 	blo.s		.0002
                            	  2724: .0001:
02:000062C2 2202            	  2725: 	move.l	d2,d1
02:000062C4 241F            	  2726: 	move.l	(a7)+,d2
02:000062C6 4A00            	  2727: 	tst.b		d0
02:000062C8 4E75            	  2728: 	rts	
                            	  2729: 
                            	  2730: ;------------------------------------------------------------------------------
                            	  2731: ; Convert ASCII character in the range '0' to '9', 'a' tr 'f' or 'A' to 'F'
                            	  2732: ; to a hex nybble.
                            	  2733: ;------------------------------------------------------------------------------
                            	  2734: 
                            	  2735: AsciiToHexNybble:
02:000062CA 0C010030        	  2736: 	cmpi.b	#'0',d1
02:000062CE 6530            	  2737: 	blo.s		gthx3
02:000062D0 0C010039        	  2738: 	cmpi.b	#'9',d1
02:000062D4 6206            	  2739: 	bhi.s		gthx5
02:000062D6 04010030        	  2740: 	subi.b	#'0',d1
02:000062DA 4E75            	  2741: 	rts
                            	  2742: gthx5:
02:000062DC 0C010041        	  2743: 	cmpi.b	#'A',d1
02:000062E0 651E            	  2744: 	blo.s		gthx3
02:000062E2 0C010046        	  2745: 	cmpi.b	#'F',d1
02:000062E6 6206            	  2746: 	bhi.s		gthx6
02:000062E8 060100C9        	  2747: 	addi.b	#10-'A',d1
02:000062EC 4E75            	  2748: 	rts
                            	  2749: gthx6:
02:000062EE 0C010061        	  2750: 	cmpi.b	#'a',d1
02:000062F2 650C            	  2751: 	blo.s		gthx3
02:000062F4 0C010066        	  2752: 	cmpi.b	#'f',d1
02:000062F8 6206            	  2753: 	bhi.s		gthx3
02:000062FA 060100A9        	  2754: 	addi.b	#10-'a',d1
02:000062FE 4E75            	  2755: 	rts
                            	  2756: gthx3:
02:00006300 72FF            	  2757: 	moveq	#-1,d1		; not a hex number
02:00006302 4E75            	  2758: 	rts
                            	  2759: 
                            	  2760: ;------------------------------------------------------------------------------
                            	  2761: ;------------------------------------------------------------------------------
                            	  2762: 
                            	  2763: DisplayTwoSpaces:
02:00006304 2F01            	  2764: 	move.l	d1,-(a7)
02:00006306 123C0020        	  2765: 	move.b	#' ',d1
02:0000630A 6100EC26        	  2766: 	bsr			DisplayChar
                            	  2767: dspspc1:
02:0000630E 6100EC22        	  2768: 	bsr			DisplayChar
02:00006312 221F            	  2769: 	move.l	(a7)+,d1
02:00006314 4E75            	  2770: 	rts
                            	  2771: 
                            	  2772: DisplaySpace:
02:00006316 2F01            	  2773: 	move.l	d1,-(a7)
02:00006318 123C0020        	  2774: 	move.b	#' ',d1
02:0000631C 60F0            	  2775: 	bra			dspspc1
                            	  2776: 
                            	  2777: ;------------------------------------------------------------------------------
                            	  2778: ; Display the 32 bit word in D1.L
                            	  2779: ;------------------------------------------------------------------------------
                            	  2780: 
                            	  2781: DisplayTetra:
02:0000631E 4841            	  2782: 	swap	d1
02:00006320 6102            	  2783: 	bsr		DisplayWyde
02:00006322 4841            	  2784: 	swap	d1
                            	  2785: 
                            	  2786: ;------------------------------------------------------------------------------
                            	  2787: ; Display the byte in D1.W
                            	  2788: ;------------------------------------------------------------------------------
                            	  2789: 
                            	  2790: DisplayWyde:
02:00006324 E059            	  2791: 	ror.w		#8,d1
02:00006326 6102            	  2792: 	bsr			DisplayByte
02:00006328 E159            	  2793: 	rol.w		#8,d1
                            	  2794: 
                            	  2795: ;------------------------------------------------------------------------------
                            	  2796: ; Display the byte in D1.B
                            	  2797: ;------------------------------------------------------------------------------
                            	  2798: 
                            	  2799: DisplayByte:
02:0000632A E819            	  2800: 	ror.b		#4,d1
02:0000632C 6102            	  2801: 	bsr			DisplayNybble
02:0000632E E919            	  2802: 	rol.b		#4,d1
                            	  2803: 
                            	  2804: ;------------------------------------------------------------------------------
                            	  2805: ; Display nybble in D1.B
                            	  2806: ;------------------------------------------------------------------------------
                            	  2807: 
                            	  2808: DisplayNybble:
02:00006330 2F01            	  2809: 	move.l	d1,-(a7)
02:00006332 0201000F        	  2810: 	andi.b	#$F,d1
02:00006336 06010030        	  2811: 	addi.b	#'0',d1
02:0000633A 0C010039        	  2812: 	cmpi.b	#'9',d1
02:0000633E 6302            	  2813: 	bls.s		.0001
02:00006340 5E01            	  2814: 	addi.b	#7,d1
                            	  2815: .0001:
02:00006342 6100EBEE        	  2816: 	bsr			DisplayChar
02:00006346 221F            	  2817: 	move.l	(a7)+,d1
02:00006348 4E75            	  2818: 	rts
                            	  2819: 
                            	  2820: ;------------------------------------------------------------------------------
                            	  2821: ;------------------------------------------------------------------------------
                            	  2822: ;
                            	  2823: ;DisplayHexNumber:
                            	  2824: ;	move.w	#$A6A6,leds		; diagnostics
                            	  2825: ;	move.l	#VDGREG,a6
                            	  2826: ;	move.w	#7,d2		; number-1 of digits to display
                            	  2827: ;disphnum1:
                            	  2828: ;	move.b	d1,d0		; get digit into d0.b
                            	  2829: ;	andi.w	#$0f,d0
                            	  2830: ;	cmpi.w	#$09,d0
                            	  2831: ;	bls.s	disphnum2
                            	  2832: ;	addi.w	#7,d0
                            	  2833: ;disphnum2:
                            	  2834: ;	addi.w	#$30,d0	; convert to display char
                            	  2835: ;	move.w	d2,d3		; char count into d3
                            	  2836: ;	asl.w	#3,d3		; scale * 8
                            	  2837: ;disphnum3:
                            	  2838: ;	move.w	$42C(a6),d4			; read character queue index into d4
                            	  2839: ;	cmp.w	#28,d4					; allow up 28 entries to be in progress
                            	  2840: ;	bhs.s	disphnum3				; branch if too many chars queued
                            	  2841: ;	ext.w	d0						; zero out high order bits
                            	  2842: ;	move.w	d0,$420(a6)			; set char code
                            	  2843: ;	move.w	#WHITE,$422(a6)		; set fg color
                            	  2844: ;	move.w	#DARK_BLUE,$424(a6)	; set bk color
                            	  2845: ;	move.w	d3,$426(a6)			; set x pos
                            	  2846: ;	move.w	#8,$428(a6)			; set y pos
                            	  2847: ;	move.w	#$0707,$42A(a6)		; set font x,y extent
                            	  2848: ;	move.w	#0,$42E(a6)			; pulse character queue write signal
                            	  2849: ;	ror.l	#4,d1					; rot to next digit
                            	  2850: ;	dbeq	d2,disphnum1
                            	  2851: ;	jmp		(a5)
                            	  2852: 
                            	  2853: ;===============================================================================
                            	  2854: ;    Perform ram test. (Uses checkerboard testing).
                            	  2855: ; 
                            	  2856: ;    Local ram, which does not get tested, is used for the stack.
                            	  2857: ;===============================================================================
                            	  2858: 
                            	  2859: DisplayAddr:
02:0000634A 2208            	  2860: 	move.l a0,d1
02:0000634C E089            	  2861: 	lsr.l #8,d1
02:0000634E E089            	  2862: 	lsr.l #8,d1
02:00006350 E889            	  2863: 	lsr.l #4,d1
02:00006352 04410200        	  2864: 	subi.w #512,d1
02:00006356 A2C10000        	  2865: 	bin2bcd d1
02:0000635A 61C8            	  2866: 	bsr	DisplayWyde
02:0000635C 123C000D        	  2867: 	move.b #CR,d1
02:00006360 6000EBD0        	  2868: 	bra DisplayChar
02:00006364 08000083        	  2869: 	btst #$83,d0
                            	  2870: 	
                            	  2871: cmdTestRAM:
                            	  2872: ramtest:
02:00006368 33FCA5A5FD0FFF00	  2873: 	move.w	#$A5A5,leds		; diagnostics
02:00006370 263CAAAAAAAA    	  2874:   move.l #$aaaaaaaa,d3
02:00006376 283C55555555    	  2875:   move.l #$55555555,d4
02:0000637C 612C            	  2876:   bsr ramtest0
                            	  2877:   ; switch checkerboard pattern and repeat test.
02:0000637E C744            	  2878:   exg d3,d4
02:00006380 6128            	  2879:   bsr ramtest0
                            	  2880: 	; Save last ram address in end of memory pointer.
                            	  2881: rmtst5:
02:00006382 7025            	  2882: 	moveq #37,d0					; lock semaphore
02:00006384 7206            	  2883: 	moveq #MEMORY_SEMA,d1
02:00006386 4E4F            	  2884: 	trap #15
02:00006388 23C800100004    	  2885:   move.l a0,memend
                            	  2886: 	; Create very first memory block.
02:0000638E 41E8FFF4        	  2887:   suba.l #12,a0
02:00006392 23C820000004    	  2888:   move.l a0,$20000004		; length of block
02:00006398 23FC465245452000	  2889:   move.l #$46524545,$20000000
02:000063A0 0000
02:000063A2 7026            	  2890: 	moveq #38,d0					; unlock semaphore
02:000063A4 7206            	  2891: 	moveq #MEMORY_SEMA,d1
02:000063A6 4E4F            	  2892: 	trap #15
02:000063A8 4E75            	  2893:   rts
                            	  2894: 
                            	  2895: ramtest0:
02:000063AA 2003            	  2896: 	move.l d3,d0
02:000063AC 207C20000000    	  2897:   movea.l #$20000000,a0
                            	  2898: ;-----------------------------------------------------------
                            	  2899: ;   Write checkerboard pattern to ram then read it back to
                            	  2900: ; find the highest usable ram address (maybe). This address
                            	  2901: ; must be lower than the start of the rom (0xe00000).
                            	  2902: ;-----------------------------------------------------------
                            	  2903: ramtest1:
02:000063B2 20C3            	  2904:   move.l d3,(a0)+
02:000063B4 20C4            	  2905:   move.l d4,(a0)+
02:000063B6 2208            	  2906:   move.l a0,d1
02:000063B8 4A41            	  2907:   tst.w	d1
02:000063BA 6606            	  2908:   bne.s rmtst1
02:000063BC 618C            	  2909:   bsr DisplayAddr
02:000063BE 6100F1E2        	  2910:   bsr CheckForCtrlC
                            	  2911: rmtst1:
02:000063C2 B1FC3FFFFFF8    	  2912:   cmpa.l #$3FFFFFF8,a0
02:000063C8 65E8            	  2913:   blo.s ramtest1
02:000063CA 6100EB1C        	  2914:   bsr	CRLF
                            	  2915: ;------------------------------------------------------
                            	  2916: ;   Save maximum useable address for later comparison.
                            	  2917: ;------------------------------------------------------
                            	  2918: ramtest6:
02:000063CE 33FCA7A7FD0FFF00	  2919: 	move.w	#$A7A7,leds		; diagnostics
02:000063D6 2448            	  2920:   movea.l a0,a2
02:000063D8 207C20000000    	  2921:   movea.l #$20000000,a0
                            	  2922: ;--------------------------------------------
                            	  2923: ;   Read back checkerboard pattern from ram.
                            	  2924: ;--------------------------------------------
                            	  2925: ramtest2
02:000063DE 2A18            	  2926:   move.l (a0)+,d5
02:000063E0 2C18            	  2927:   move.l (a0)+,d6
02:000063E2 B1CA            	  2928:   cmpa.l a2,a0
02:000063E4 643A            	  2929:   bhs.s	ramtest3
02:000063E6 2208            	  2930:   move.l a0,d1
02:000063E8 4A41            	  2931:   tst.w	d1
02:000063EA 6608            	  2932:   bne.s	rmtst2
02:000063EC 6100FF5C        	  2933:   bsr	DisplayAddr
02:000063F0 6100F1B0        	  2934: 	bsr CheckForCtrlC
                            	  2935: rmtst2
02:000063F4 BA83            	  2936:   cmp.l d3,d5
02:000063F6 6604            	  2937:   bne.s rmtst3
02:000063F8 BC84            	  2938:   cmp.l d4,d6
02:000063FA 67E2            	  2939:   beq.s ramtest2
                            	  2940: ;----------------------------------
                            	  2941: ; Report error in ram.
                            	  2942: ;----------------------------------
                            	  2943: rmtst3
02:000063FC 6100EAEA        	  2944: 	bsr CRLF
02:00006400 7245            	  2945: 	moveq	#'E',d1
02:00006402 6100EB2E        	  2946: 	bsr DisplayChar
02:00006406 6100FF0E        	  2947: 	bsr DisplaySpace
02:0000640A 2208            	  2948: 	move.l a0,d1
02:0000640C 6100FF10        	  2949: 	bsr DisplayTetra
02:00006410 6100FF04        	  2950: 	bsr DisplaySpace
02:00006414 2205            	  2951: 	move.l d5,d1
02:00006416 6100FF06        	  2952: 	bsr DisplayTetra
02:0000641A 6100F186        	  2953: 	bsr CheckForCtrlC
02:0000641E 60BE            	  2954: 	bra ramtest2
                            	  2955: ramtest3
02:00006420 4E75            	  2956: 	rts
                            	  2957: 
                            	  2958: ;==============================================================================
                            	  2959: ; Load an S19 format file
                            	  2960: ;==============================================================================
                            	  2961: 
                            	  2962: cmdLoadS19:
02:00006422 6100EAC4        	  2963: 	bsr			CRLF
02:00006426 6012            	  2964: 	bra			ProcessRec
                            	  2965: NextRec:
02:00006428 610001DC        	  2966: 	bsr			sGetChar
02:0000642C 0C01000A        	  2967: 	cmpi.b	#LF,d1
02:00006430 66F6            	  2968: 	bne			NextRec
02:00006432 123C002E        	  2969: 	move.b	#'.',d1
02:00006436 6100EAFA        	  2970: 	bsr			DisplayChar
                            	  2971: ProcessRec:
02:0000643A 6100F166        	  2972: 	bsr			CheckForCtrlC	; check for CTRL-C once per record
02:0000643E 610001C6        	  2973: 	bsr			sGetChar
02:00006442 0C01000D        	  2974: 	cmpi.b	#CR,d1
02:00006446 67F2            	  2975: 	beq.s		ProcessRec
02:00006448 423900100150    	  2976: 	clr.b		S19Checksum
02:0000644E 1801            	  2977: 	move.b	d1,d4
02:00006450 0C04001A        	  2978: 	cmpi.b	#CTRLZ,d4			; CTRL-Z ?
02:00006454 6700F80C        	  2979: 	beq			Monitor
02:00006458 0C040053        	  2980: 	cmpi.b	#'S',d4				; All records must begin with an 'S'
02:0000645C 66CA            	  2981: 	bne.s		NextRec
02:0000645E 610001A6        	  2982: 	bsr			sGetChar
02:00006462 1801            	  2983: 	move.b	d1,d4
02:00006464 0C040030        	  2984: 	cmpi.b	#'0',d4				; Record type must be between '0' and '9'
02:00006468 65BE            	  2985: 	blo.s		NextRec
02:0000646A 0C040039        	  2986: 	cmpi.b	#'9',d4				; d4 = record type
02:0000646E 62B8            	  2987: 	bhi.s		NextRec
02:00006470 61000194        	  2988: 	bsr			sGetChar			; get byte count for record
02:00006474 6100FE54        	  2989: 	bsr			AsciiToHexNybble
02:00006478 1401            	  2990: 	move.b	d1,d2
02:0000647A 6100018A        	  2991: 	bsr			sGetChar
02:0000647E 6100FE4A        	  2992: 	bsr			AsciiToHexNybble
02:00006482 E90A            	  2993: 	lsl.b		#4,d2
02:00006484 8202            	  2994: 	or.b		d2,d1					; d1 = byte count
02:00006486 1601            	  2995: 	move.b	d1,d3					; d3 = byte count
02:00006488 D73900100150    	  2996: 	add.b		d3,S19Checksum
02:0000648E 0C040030        	  2997: 	cmpi.b	#'0',d4				; manufacturer ID record, ignore
02:00006492 6794            	  2998: 	beq			NextRec
02:00006494 0C040031        	  2999: 	cmpi.b	#'1',d4
02:00006498 670000A2        	  3000: 	beq			ProcessS1
02:0000649C 0C040032        	  3001: 	cmpi.b	#'2',d4
02:000064A0 6700009E        	  3002: 	beq			ProcessS2
02:000064A4 0C040033        	  3003: 	cmpi.b	#'3',d4
02:000064A8 6700009A        	  3004: 	beq			ProcessS3
02:000064AC 0C040035        	  3005: 	cmpi.b	#'5',d4				; record count record, ignore
02:000064B0 6700FF76        	  3006: 	beq			NextRec
02:000064B4 0C040037        	  3007: 	cmpi.b	#'7',d4
02:000064B8 6700008E        	  3008: 	beq			ProcessS7
02:000064BC 0C040038        	  3009: 	cmpi.b	#'8',d4
02:000064C0 67000096        	  3010: 	beq			ProcessS8
02:000064C4 0C040039        	  3011: 	cmpi.b	#'9',d4
02:000064C8 6700009E        	  3012: 	beq			ProcessS9
02:000064CC 6000FF5A        	  3013: 	bra			NextRec
                            	  3014: 
                            	  3015: pcssxa:
02:000064D0 2209            	  3016: 	move.l	a1,d1
02:000064D2 6100FE4A        	  3017: 	bsr			DisplayTetra
02:000064D6 123C000D        	  3018: 	move.b	#CR,d1
02:000064DA 6100EA56        	  3019: 	bsr			DisplayChar
02:000064DE 024300FF        	  3020: 	andi.w	#$ff,d3
02:000064E2 5343            	  3021: 	subi.w	#1,d3			; one less for dbra
                            	  3022: .0001:
02:000064E4 7400            	  3023: 	clr.l		d2
02:000064E6 6100011E        	  3024: 	bsr			sGetChar
02:000064EA 6100FDDE        	  3025: 	bsr			AsciiToHexNybble
02:000064EE E98A            	  3026: 	lsl.l		#4,d2
02:000064F0 8401            	  3027: 	or.b		d1,d2
02:000064F2 61000112        	  3028: 	bsr			sGetChar
02:000064F6 6100FDD2        	  3029: 	bsr			AsciiToHexNybble
02:000064FA E98A            	  3030: 	lsl.l		#4,d2
02:000064FC 8401            	  3031: 	or.b		d1,d2
02:000064FE D53900100150    	  3032: 	add.b		d2,S19Checksum
02:00006504 12C2            	  3033: 	move.b	d2,(a1)+			; move byte to memory
02:00006506 51CBFFDC        	  3034: 	dbra		d3,.0001
                            	  3035: 	; Get the checksum byte
02:0000650A 7400            	  3036: 	clr.l		d2
02:0000650C 610000F8        	  3037: 	bsr			sGetChar
02:00006510 6100FDB8        	  3038: 	bsr			AsciiToHexNybble
02:00006514 E98A            	  3039: 	lsl.l		#4,d2
02:00006516 8401            	  3040: 	or.b		d1,d2
02:00006518 610000EC        	  3041: 	bsr			sGetChar
02:0000651C 6100FDAC        	  3042: 	bsr			AsciiToHexNybble
02:00006520 E98A            	  3043: 	lsl.l		#4,d2
02:00006522 8401            	  3044: 	or.b		d1,d2
02:00006524 4602            	  3045: 	eor.b		#$FF,d2
02:00006526 B43900100150    	  3046: 	cmp.b		S19Checksum,d2
02:0000652C 6700FEFA        	  3047: 	beq			NextRec
02:00006530 123C0045        	  3048: 	move.b	#'E',d1
02:00006534 6100E9FC        	  3049: 	bsr			DisplayChar
02:00006538 6000FEEE        	  3050: 	bra			NextRec
                            	  3051: 
                            	  3052: ProcessS1:
02:0000653C 613A            	  3053: 	bsr			S19Get16BitAddress
02:0000653E 6090            	  3054: 	bra			pcssxa
                            	  3055: ProcessS2:
02:00006540 6144            	  3056: 	bsr			S19Get24BitAddress
02:00006542 608C            	  3057: 	bra			pcssxa
                            	  3058: ProcessS3:
02:00006544 614C            	  3059: 	bsr			S19Get32BitAddress
02:00006546 6088            	  3060: 	bra			pcssxa
                            	  3061: ProcessS7:
02:00006548 6148            	  3062: 	bsr			S19Get32BitAddress
02:0000654A 23C900040008    	  3063: 	move.l	a1,S19StartAddress
02:00006550 6100EEA4        	  3064: 	bsr			_KeybdInit
02:00006554 6000F70C        	  3065: 	bra			Monitor
                            	  3066: ProcessS8:
02:00006558 612C            	  3067: 	bsr			S19Get24BitAddress
02:0000655A 23C900040008    	  3068: 	move.l	a1,S19StartAddress
02:00006560 6100EE94        	  3069: 	bsr			_KeybdInit
02:00006564 6000F6FC        	  3070: 	bra			Monitor
                            	  3071: ProcessS9:
02:00006568 610E            	  3072: 	bsr			S19Get16BitAddress
02:0000656A 23C900040008    	  3073: 	move.l	a1,S19StartAddress
02:00006570 6100EE84        	  3074: 	bsr			_KeybdInit
02:00006574 6000F6EC        	  3075: 	bra			Monitor
                            	  3076: 
                            	  3077: S19Get16BitAddress:
02:00006578 7400            	  3078: 	clr.l		d2
02:0000657A 6100008A        	  3079: 	bsr			sGetChar
02:0000657E 6100FD4A        	  3080: 	bsr			AsciiToHexNybble
02:00006582 1401            	  3081: 	move.b	d1,d2
02:00006584 603E            	  3082: 	bra			S1932b
                            	  3083: 
                            	  3084: S19Get24BitAddress:
02:00006586 7400            	  3085: 	clr.l		d2
02:00006588 617C            	  3086: 	bsr			sGetChar
02:0000658A 6100FD3E        	  3087: 	bsr			AsciiToHexNybble
02:0000658E 1401            	  3088: 	move.b	d1,d2
02:00006590 601E            	  3089: 	bra			S1932a
                            	  3090: 
                            	  3091: S19Get32BitAddress:
02:00006592 7400            	  3092: 	clr.l		d2
02:00006594 6170            	  3093: 	bsr			sGetChar
02:00006596 6100FD32        	  3094: 	bsr			AsciiToHexNybble
02:0000659A 1401            	  3095: 	move.b	d1,d2
02:0000659C 6168            	  3096: 	bsr			sGetChar
02:0000659E 6100FD2A        	  3097: 	bsr			AsciiToHexNybble
02:000065A2 E98A            	  3098: 	lsl.l		#4,d2
02:000065A4 8401            	  3099: 	or.b		d1,d2
02:000065A6 615E            	  3100: 	bsr			sGetChar
02:000065A8 6100FD20        	  3101: 	bsr			AsciiToHexNybble
02:000065AC E98A            	  3102: 	lsl.l		#4,d2
02:000065AE 8401            	  3103: 	or.b		d1,d2
                            	  3104: S1932a:
02:000065B0 6154            	  3105: 	bsr			sGetChar
02:000065B2 6100FD16        	  3106: 	bsr			AsciiToHexNybble
02:000065B6 E98A            	  3107: 	lsl.l		#4,d2
02:000065B8 8401            	  3108: 	or.b		d1,d2
02:000065BA 614A            	  3109: 	bsr			sGetChar
02:000065BC 6100FD0C        	  3110: 	bsr			AsciiToHexNybble
02:000065C0 E98A            	  3111: 	lsl.l		#4,d2
02:000065C2 8401            	  3112: 	or.b		d1,d2
                            	  3113: S1932b:
02:000065C4 6140            	  3114: 	bsr			sGetChar
02:000065C6 6100FD02        	  3115: 	bsr			AsciiToHexNybble
02:000065CA E98A            	  3116: 	lsl.l		#4,d2
02:000065CC 8401            	  3117: 	or.b		d1,d2
02:000065CE 6136            	  3118: 	bsr			sGetChar
02:000065D0 6100FCF8        	  3119: 	bsr			AsciiToHexNybble
02:000065D4 E98A            	  3120: 	lsl.l		#4,d2
02:000065D6 8401            	  3121: 	or.b		d1,d2
02:000065D8 612C            	  3122: 	bsr			sGetChar
02:000065DA 6100FCEE        	  3123: 	bsr			AsciiToHexNybble
02:000065DE E98A            	  3124: 	lsl.l		#4,d2
02:000065E0 8401            	  3125: 	or.b		d1,d2
02:000065E2 7800            	  3126: 	clr.l		d4
02:000065E4 2242            	  3127: 	move.l	d2,a1
                            	  3128: 	; Add bytes from address value to checksum
02:000065E6 D53900100150    	  3129: 	add.b		d2,S19Checksum
02:000065EC E08A            	  3130: 	lsr.l		#8,d2
02:000065EE D53900100150    	  3131: 	add.b		d2,S19Checksum
02:000065F4 E08A            	  3132: 	lsr.l		#8,d2
02:000065F6 D53900100150    	  3133: 	add.b		d2,S19Checksum
02:000065FC E08A            	  3134: 	lsr.l		#8,d2
02:000065FE D53900100150    	  3135: 	add.b		d2,S19Checksum
02:00006604 4E75            	  3136: 	rts
                            	  3137: 
                            	  3138: ;------------------------------------------------------------------------------
                            	  3139: ; Get a character from auxillary input. Waiting for a character is limited to
                            	  3140: ; 32000 tries. If a character is not available within the limit, then a return
                            	  3141: ; to the monitor is done.
                            	  3142: ;
                            	  3143: ;	Parameters:
                            	  3144: ;		none
                            	  3145: ; Returns:
                            	  3146: ;		d1 = character from receive buffer or -1 if no char available
                            	  3147: ;------------------------------------------------------------------------------
                            	  3148: 
                            	  3149: sGetChar:
02:00006606 48E7A000        	  3150: 	movem.l	d0/d2,-(a7)
02:0000660A 343C7D00        	  3151: 	move.w	#32000,d2
                            	  3152: .0001:
02:0000660E 7024            	  3153: 	moveq		#36,d0				; serial get char from buffer
02:00006610 4E4F            	  3154: 	trap		#15
02:00006612 4A41            	  3155: 	tst.w		d1						; was there a char available?
02:00006614 6A10            	  3156: 	bpl.s		.0002
02:00006616 51CAFFF6        	  3157: 	dbra		d2,.0001			; no - try again
02:0000661A 4CDF0005        	  3158: 	movem.l	(a7)+,d0/d2
                            	  3159: .0003:
02:0000661E 6100EDD6        	  3160: 	bsr			_KeybdInit
02:00006622 6000F63E        	  3161: 	bra			Monitor				; ran out of tries
                            	  3162: .0002:
02:00006626 4CDF0005        	  3163: 	movem.l	(a7)+,d0/d2
02:0000662A 0C01001A        	  3164: 	cmpi.b	#CTRLZ,d1			; receive end of file?
02:0000662E 67EE            	  3165: 	beq			.0003
02:00006630 4E75            	  3166: 	rts
                            	  3167: 
                            	  3168: AudioInputTest:
02:00006632 4E75            	  3169: 	rts
                            	  3170: BouncingBalls:
02:00006634 4E75            	  3171: 	rts
                            	  3172: GraphicsDemo:
02:00006636 4E75            	  3173: 	rts
                            	  3174: ClearScreen:
02:00006638 6000E85E        	  3175: 	bra		clear_screen
02:0000663C 4E75            	  3176: 	rts
                            	  3177: 
                            	  3178: ;------------------------------------------------------------------------------
                            	  3179: ; Reverse the order of bytes in d1.
                            	  3180: ;------------------------------------------------------------------------------
                            	  3181: 
                            	  3182: rbo:
02:0000663E E159            	  3183: 	rol.w		#8,d1
02:00006640 4841            	  3184: 	swap		d1
02:00006642 E159            	  3185: 	rol.w		#8,d1
02:00006644 4E75            	  3186: 	rts
                            	  3187: 
                            	  3188: ;==============================================================================
                            	  3189: ; Serial I/O routines
                            	  3190: ;==============================================================================
                            	  3191: 
                            	  3192: ;------------------------------------------------------------------------------
                            	  3193: ; Initialize the serial port an enhanced 6551 circuit.
                            	  3194: ;
                            	  3195: ; Select internal baud rate clock divider for 9600 baud
                            	  3196: ; Reset fifos, set threshold to 3/4 full on transmit and 3/4 empty on receive
                            	  3197: ; Note that the byte order is swapped.
                            	  3198: ;------------------------------------------------------------------------------
                            	  3199: 
                            	  3200: SerialInit:
02:00006646 427900100162    	  3201: 	clr.w		SerHeadRcv					; clear receive buffer indexes
02:0000664C 427900100160    	  3202: 	clr.w		SerTailRcv
02:00006652 423900100164    	  3203: 	clr.b		SerRcvXon						; and Xon,Xoff flags
02:00006658 423900100165    	  3204: 	clr.b		SerRcvXoff
02:0000665E 203C09000000    	  3205: 	move.l	#$09000000,d0				; dtr,rts active, rxint enabled, no parity
02:00006664 23C0FD060008    	  3206: 	move.l	d0,ACIA+ACIA_CMD
                            	  3207: ;	move.l	#$1E00F700,d0				; fifos enabled
02:0000666A 203C1E000000    	  3208: 	move.l	#$1E000000,d0				; fifos disabled
02:00006670 23C0FD06000C    	  3209: 	move.l	d0,ACIA+ACIA_CTRL
02:00006676 4E75            	  3210: 	rts
                            	  3211: ;	move.l	#$0F000000,d0				; transmit a break for a while
                            	  3212: ;	move.l	d0,ACIA+ACIA_CMD
                            	  3213: ;	move.l	#300000,d2					; wait 100 ms
                            	  3214: ;	bra			.0001
                            	  3215: ;.0003:
                            	  3216: ;	swap		d2
                            	  3217: ;.0001:
                            	  3218: ;	nop
                            	  3219: ;	dbra		d2,.0001
                            	  3220: ;.0002:
                            	  3221: ;	swap		d2
                            	  3222: ;	dbra		d2,.0003
                            	  3223: ;	move.l	#$07000000,d0				; clear break
                            	  3224: ;	move.l	d0,ACIA+ACIA_CMD
                            	  3225: ;	rts
                            	  3226: 	
                            	  3227: ;------------------------------------------------------------------------------
                            	  3228: ; SerialGetChar
                            	  3229: ;
                            	  3230: ; Check the serial port buffer to see if there's a char available. If there's
                            	  3231: ; a char available then return it. If the buffer is almost empty then send an
                            	  3232: ; XON.
                            	  3233: ;
                            	  3234: ; Stack Space:
                            	  3235: ;		2 long words
                            	  3236: ; Parameters:
                            	  3237: ;		none
                            	  3238: ; Modifies:
                            	  3239: ;		d0,a0
                            	  3240: ; Returns:
                            	  3241: ;		d1 = character or -1
                            	  3242: ;------------------------------------------------------------------------------
                            	  3243: 
                            	  3244: SerialGetChar:
02:00006678 2F02            	  3245: 	move.l		d2,-(a7)
02:0000667A 4E7A0FE0        	  3246: 	movec			coreno,d0
02:0000667E 4840            	  3247: 	swap			d0
02:00006680 7202            	  3248: 	moveq			#SERIAL_SEMA,d1
02:00006682 61009C12        	  3249: 	bsr				LockSemaphore
02:00006686 610000DE        	  3250: 	bsr				SerialRcvCount			; check number of chars in receive buffer
02:0000668A 0C400008        	  3251: 	cmpi.w		#8,d0								; less than 8?
02:0000668E 621C            	  3252: 	bhi				.sgc2
02:00006690 4A3900100164    	  3253: 	tst.b			SerRcvXon						; skip sending XON if already sent
02:00006696 6614            	  3254: 	bne	  		.sgc2            		; XON already sent?
02:00006698 123C0011        	  3255: 	move.b		#XON,d1							; if <8 send an XON
02:0000669C 423900100165    	  3256: 	clr.b			SerRcvXoff					; clear XOFF status
02:000066A2 13C100100164    	  3257: 	move.b		d1,SerRcvXon				; flag so we don't send it multiple times
02:000066A8 61000098        	  3258: 	bsr				SerialPutChar				; send it
                            	  3259: .sgc2:
02:000066AC 323900100162    	  3260: 	move.w		SerHeadRcv,d1				; check if anything is in buffer
02:000066B2 B27900100160    	  3261: 	cmp.w			SerTailRcv,d1
02:000066B8 6720            	  3262: 	beq				.NoChars						; no?
02:000066BA 41F900101000    	  3263: 	lea				SerRcvBuf,a0
02:000066C0 12301000        	  3264: 	move.b		(a0,d1.w),d1				; get byte from buffer
02:000066C4 527900100162    	  3265: 	addi.w		#1,SerHeadRcv
02:000066CA 02790FFF00100162	  3266: 	andi.w		#$FFF,SerHeadRcv		; 4k wrap around
02:000066D2 0281000000FF    	  3267: 	andi.l		#$FF,d1
02:000066D8 6002            	  3268: 	bra				.Xit
                            	  3269: .NoChars:
02:000066DA 72FF            	  3270: 	moveq			#-1,d1
                            	  3271: .Xit:
02:000066DC C342            	  3272: 	exg				d1,d2
02:000066DE 4E7A0FE0        	  3273: 	movec			coreno,d0
02:000066E2 4840            	  3274: 	swap			d0
02:000066E4 7202            	  3275: 	moveq			#SERIAL_SEMA,d1
02:000066E6 61009BE8        	  3276: 	bsr				UnlockSemaphore
02:000066EA C541            	  3277: 	exg				d2,d1
02:000066EC 241F            	  3278: 	move.l		(a7)+,d2
02:000066EE 4E75            	  3279: 	rts
                            	  3280: 
                            	  3281: ;------------------------------------------------------------------------------
                            	  3282: ; SerialPeekChar
                            	  3283: ;
                            	  3284: ; Check the serial port buffer to see if there's a char available. If there's
                            	  3285: ; a char available then return it. But don't update the buffer indexes. No need
                            	  3286: ; to send an XON here.
                            	  3287: ;
                            	  3288: ; Stack Space:
                            	  3289: ;		0 words
                            	  3290: ; Parameters:
                            	  3291: ;		none
                            	  3292: ; Modifies:
                            	  3293: ;		d0,d2,a0
                            	  3294: ; Returns:
                            	  3295: ;		d1 = character or -1
                            	  3296: ;------------------------------------------------------------------------------
                            	  3297: 
                            	  3298: SerialPeekChar:
02:000066F0 4E7A0FE0        	  3299: 	movec		coreno,d0
02:000066F4 4840            	  3300: 	swap		d0
02:000066F6 7202            	  3301: 	moveq		#SERIAL_SEMA,d1
02:000066F8 61009B9C        	  3302: 	bsr			LockSemaphore
02:000066FC 343900100162    	  3303: 	move.w	SerHeadRcv,d2		; check if anything is in buffer
02:00006702 B47900100160    	  3304: 	cmp.w		SerTailRcv,d2
02:00006708 670C            	  3305: 	beq			.NoChars				; no?
02:0000670A 41F900101000    	  3306: 	lea			SerRcvBuf,a0
02:00006710 14302000        	  3307: 	move.b	(a0,d2.w),d2		; get byte from buffer
02:00006714 6002            	  3308: 	bra			.Xit
                            	  3309: .NoChars:
02:00006716 74FF            	  3310: 	moveq		#-1,d2
                            	  3311: .Xit:
02:00006718 4E7A0FE0        	  3312: 	movec		coreno,d0
02:0000671C 4840            	  3313: 	swap		d0
02:0000671E 7202            	  3314: 	moveq		#SERIAL_SEMA,d1
02:00006720 61009B74        	  3315: 	bsr			LockSemaphore
02:00006724 3202            	  3316: 	move		d2,d1
02:00006726 4E75            	  3317: 	rts
                            	  3318: 
                            	  3319: ;------------------------------------------------------------------------------
                            	  3320: ; SerialPeekChar
                            	  3321: ;		Get a character directly from the I/O port. This bypasses the input
                            	  3322: ; buffer.
                            	  3323: ;
                            	  3324: ; Stack Space:
                            	  3325: ;		0 words
                            	  3326: ; Parameters:
                            	  3327: ;		none
                            	  3328: ; Modifies:
                            	  3329: ;		d
                            	  3330: ; Returns:
                            	  3331: ;		d1 = character or -1
                            	  3332: ;------------------------------------------------------------------------------
                            	  3333: 
                            	  3334: SerialPeekCharDirect:
02:00006728 1239FD060004    	  3335: 	move.b	ACIA+ACIA_STAT,d1	; get serial status
02:0000672E 08010003        	  3336: 	btst		#3,d1							; look for Rx not empty
02:00006732 670A            	  3337: 	beq.s		.0001
02:00006734 7200            	  3338: 	moveq.l	#0,d1							; clear upper bits of return value
02:00006736 1239FD060000    	  3339: 	move.b	ACIA+ACIA_RX,d1		; get data from ACIA
02:0000673C 4E75            	  3340: 	rts												; return
                            	  3341: .0001:
02:0000673E 72FF            	  3342: 	moveq		#-1,d1
02:00006740 4E75            	  3343: 	rts
                            	  3344: 
                            	  3345: ;------------------------------------------------------------------------------
                            	  3346: ; SerialPutChar
                            	  3347: ;    Put a character to the serial transmitter. This routine blocks until the
                            	  3348: ; transmitter is empty. 
                            	  3349: ;
                            	  3350: ; Stack Space
                            	  3351: ;		0 words
                            	  3352: ; Parameters:
                            	  3353: ;		d1.b = character to put
                            	  3354: ; Modifies:
                            	  3355: ;		none
                            	  3356: ;------------------------------------------------------------------------------
                            	  3357: 
                            	  3358: SerialPutChar:
02:00006742 48E7C000        	  3359: 	movem.l	d0/d1,-(a7)				; push d0,d1
                            	  3360: .0001:
02:00006746 1039FD060004    	  3361: 	move.b	ACIA+ACIA_STAT,d0	; wait until the uart indicates tx empty
02:0000674C 08000004        	  3362: 	btst		#4,d0							; bit #4 of the status reg
02:00006750 67F4            	  3363: 	beq.s		.0001			    		; branch if transmitter is not empty
02:00006752 13C1FD060000    	  3364: 	move.b	d1,ACIA+ACIA_TX		; send the byte
02:00006758 4CDF0003        	  3365: 	movem.l	(a7)+,d0/d1				; pop d0,d1
02:0000675C 4E75            	  3366: 	rts
                            	  3367: 	
                            	  3368: ;------------------------------------------------------------------------------
                            	  3369: ; Reverse the order of bytes in d1.
                            	  3370: ;------------------------------------------------------------------------------
                            	  3371: 
                            	  3372: SerialRbo:
02:0000675E E159            	  3373: 	rol.w		#8,d1
02:00006760 4841            	  3374: 	swap		d1
02:00006762 E159            	  3375: 	rol.w		#8,d1
02:00006764 4E75            	  3376: 	rts
                            	  3377: 
                            	  3378: ;------------------------------------------------------------------------------
                            	  3379: ; Calculate number of character in input buffer
                            	  3380: ;
                            	  3381: ; Returns:
                            	  3382: ;		d0 = number of bytes in buffer.
                            	  3383: ;------------------------------------------------------------------------------
                            	  3384: 
                            	  3385: SerialRcvCount:
02:00006766 303900100160    	  3386: 	move.w	SerTailRcv,d0
02:0000676C 907900100162    	  3387: 	sub.w		SerHeadRcv,d0
02:00006772 6C10            	  3388: 	bge			.0001
02:00006774 303C1000        	  3389: 	move.w	#$1000,d0
02:00006778 907900100162    	  3390: 	sub.w		SerHeadRcv,d0
02:0000677E D07900100160    	  3391: 	add.w		SerTailRcv,d0
                            	  3392: .0001:
02:00006784 4E75            	  3393: 	rts
                            	  3394: 
                            	  3395: ;------------------------------------------------------------------------------
                            	  3396: ; Serial IRQ routine
                            	  3397: ;
                            	  3398: ; Keeps looping as long as it finds characters in the ACIA recieve buffer/fifo.
                            	  3399: ; Received characters are buffered. If the buffer becomes full, new characters
                            	  3400: ; will be lost.
                            	  3401: ;
                            	  3402: ; Parameters:
                            	  3403: ;		none
                            	  3404: ; Modifies:
                            	  3405: ;		none
                            	  3406: ; Returns:
                            	  3407: ;		d1 = -1 if IRQ handled, otherwise zero
                            	  3408: ;------------------------------------------------------------------------------
                            	  3409: 
                            	  3410: SerialIRQ:
02:00006786 46FC2300        	  3411: 	move.w	#$2300,sr						; disable lower level IRQs
02:0000678A 48E7E080        	  3412: 	movem.l	d0/d1/d2/a0,-(a7)
02:0000678E 4E7A0FE0        	  3413: 	movec		coreno,d0
02:00006792 4840            	  3414: 	swap		d0
02:00006794 7202            	  3415: 	moveq		#SERIAL_SEMA,d1
02:00006796 61009AFE        	  3416: 	bsr			LockSemaphore
                            	  3417: sirqNxtByte:
02:0000679A 1239FD060004    	  3418: 	move.b	ACIA+ACIA_STAT,d1		; check the status
02:000067A0 08010003        	  3419: 	btst		#3,d1								; bit 3 = rx full
02:000067A4 6756            	  3420: 	beq			notRxInt
02:000067A6 1239FD060000    	  3421: 	move.b	ACIA+ACIA_RX,d1
                            	  3422: sirq0001:
02:000067AC 303900100160    	  3423: 	move.w	SerTailRcv,d0				; check if recieve buffer full
02:000067B2 5240            	  3424: 	addi.w	#1,d0
02:000067B4 02400FFF        	  3425: 	andi.w	#$FFF,d0
02:000067B8 B07900100162    	  3426: 	cmp.w		SerHeadRcv,d0
02:000067BE 673C            	  3427: 	beq			sirqRxFull
02:000067C0 33C000100160    	  3428: 	move.w	d0,SerTailRcv				; update tail pointer
02:000067C6 5340            	  3429: 	subi.w	#1,d0								; backup
02:000067C8 02400FFF        	  3430: 	andi.w	#$FFF,d0
02:000067CC 41F900101000    	  3431: 	lea			SerRcvBuf,a0				; a0 = buffer address
02:000067D2 11810000        	  3432: 	move.b	d1,(a0,d0.w)				; store recieved byte in buffer
02:000067D6 4A3900100165    	  3433: 	tst.b		SerRcvXoff					; check if xoff already sent
02:000067DC 66BC            	  3434: 	bne			sirqNxtByte
02:000067DE 6186            	  3435: 	bsr			SerialRcvCount			; if more than 4080 chars in buffer
02:000067E0 0C400FF0        	  3436: 	cmpi.w	#4080,d0
02:000067E4 65B4            	  3437: 	blo			sirqNxtByte
02:000067E6 123C0013        	  3438: 	move.b	#XOFF,d1						; send an XOFF
02:000067EA 423900100164    	  3439: 	clr.b		SerRcvXon						; clear XON status
02:000067F0 13C100100165    	  3440: 	move.b	d1,SerRcvXoff				; set XOFF status
02:000067F6 6100FF4A        	  3441: 	bsr			SerialPutChar				; send XOFF
02:000067FA 609E            	  3442: 	bra			sirqNxtByte     		; check the status for another byte
                            	  3443: sirqRxFull:
                            	  3444: notRxInt:
02:000067FC 4E7A0FE0        	  3445: 	movec		coreno,d0
02:00006800 4840            	  3446: 	swap		d0
02:00006802 7202            	  3447: 	moveq		#SERIAL_SEMA,d1
02:00006804 61009ACA        	  3448: 	bsr			UnlockSemaphore
02:00006808 4CDF0107        	  3449: 	movem.l	(a7)+,d0/d1/d2/a0
02:0000680C 4E73            	  3450: 	rte
                            	  3451: 
                            	  3452: nmeSerial:
02:0000680E 53657269616C    	  3453: 	dc.b		"Serial",0
02:00006814 00
                            	  3454: 
                            	  3455: ;===============================================================================
                            	  3456: ; Generic I2C routines
                            	  3457: ;===============================================================================
                            	  3458: 
                            	  3459: 	even
                            	  3460: ; i2c
                            	  3461: i2c_setup:
                            	  3462: ;		lea		I2C,a6				
                            	  3463: ;		move.w	#19,I2C_PREL(a6)	; setup prescale for 400kHz clock
                            	  3464: ;		move.w	#0,I2C_PREH(a6)
                            	  3465: init_i2c:
02:00006816 4DF9FD069000    	  3466: 	lea	I2C2,a6				
02:0000681C 1CBC0013        	  3467: 	move.b #19,I2C_PREL(a6)	; setup prescale for 400kHz clock, 40MHz master
02:00006820 422E0001        	  3468: 	move.b #0,I2C_PREH(a6)
02:00006824 4E75            	  3469: 	rts
                            	  3470: 
                            	  3471: ; Wait for I2C transfer to complete
                            	  3472: ;
                            	  3473: ; Parameters
                            	  3474: ; 	a6 - I2C controller base address
                            	  3475: 
                            	  3476: i2c_wait_tip:
02:00006826 2F00            	  3477: 	move.l d0,-(a7)
                            	  3478: .0001				
02:00006828 102E0004        	  3479: 	move.b I2C_STAT(a6),d0		; wait for tip to clear
02:0000682C 08000001        	  3480: 	btst #1,d0
02:00006830 66F6            	  3481: 	bne.s	.0001
02:00006832 201F            	  3482: 	move.l (a7)+,d0
02:00006834 4E75            	  3483: 	rts
                            	  3484: 
                            	  3485: ; Parameters
                            	  3486: ;	d0.b - data to transmit
                            	  3487: ;	d1.b - command value
                            	  3488: ;	a6	 - I2C controller base address
                            	  3489: ;
                            	  3490: i2c_wr_cmd:
02:00006836 1D400003        	  3491: 	move.b d0,I2C_TXR(a6)
02:0000683A 1D410004        	  3492: 	move.b d1,I2C_CMD(a6)
02:0000683E 61E6            	  3493: 	bsr	i2c_wait_tip
02:00006840 102E0004        	  3494: 	move.b I2C_STAT(a6),d0
02:00006844 4E75            	  3495: 	rts
                            	  3496: 
                            	  3497: i2c_xmit1:
02:00006846 2F00            	  3498: 	move.l d0,-(a7)
02:00006848 1D7C00010002    	  3499: 	move.b #1,I2C_CTRL(a6)		; enable the core
02:0000684E 7076            	  3500: 	moveq	#$76,d0				; set slave address = %0111011
02:00006850 323C0090        	  3501: 	move.w #$90,d1				; set STA, WR
02:00006854 61E0            	  3502: 	bsr i2c_wr_cmd
02:00006856 610C            	  3503: 	bsr	i2c_wait_rx_nack
02:00006858 201F            	  3504: 	move.l (a7)+,d0
02:0000685A 323C0050        	  3505: 	move.w #$50,d1				; set STO, WR
02:0000685E 61D6            	  3506: 	bsr i2c_wr_cmd
02:00006860 61000002        	  3507: 	bsr	i2c_wait_rx_nack
                            	  3508: 
                            	  3509: i2c_wait_rx_nack:
02:00006864 2F00            	  3510: 	move.l d0,-(a7)
                            	  3511: .0001						
02:00006866 102E0004        	  3512: 	move.b I2C_STAT(a6),d0		; wait for RXack = 0
02:0000686A 08000007        	  3513: 	btst #7,d0
02:0000686E 66F6            	  3514: 	bne.s	.0001
02:00006870 201F            	  3515: 	move.l (a7)+,d0
02:00006872 4E75            	  3516: 	rts
                            	  3517: 
                            	  3518: ;===============================================================================
                            	  3519: ; Realtime clock routines
                            	  3520: ;===============================================================================
                            	  3521: 
                            	  3522: rtc_read:
02:00006874 2C7CFD069000    	  3523: 	movea.l	#I2C2,a6
02:0000687A 4BF900100200    	  3524: 	lea	RTCBuf,a5
02:00006880 1D7C00800002    	  3525: 	move.b	#$80,I2C_CTRL(a6)	; enable I2C
02:00006886 103C00DE        	  3526: 	move.b	#$DE,d0				; read address, write op
02:0000688A 123C0090        	  3527: 	move.b	#$90,d1				; STA + wr bit
02:0000688E 61A6            	  3528: 	bsr	i2c_wr_cmd
02:00006890 4A00            	  3529: 	tst.b	d0
02:00006892 6B66            	  3530: 	bmi	.rxerr
02:00006894 4200            	  3531: 	move.b #$00,d0				; address zero
02:00006896 123C0010        	  3532: 	move.b #$10,d1				; wr bit
02:0000689A 619A            	  3533: 	bsr	i2c_wr_cmd
02:0000689C 4A00            	  3534: 	tst.b	d0
02:0000689E 6B5A            	  3535: 	bmi	.rxerr
02:000068A0 103C00DF        	  3536: 	move.b #$DF,d0				; read address, read op
02:000068A4 123C0090        	  3537: 	move.b #$90,d1				; STA + wr bit
02:000068A8 618C            	  3538: 	bsr i2c_wr_cmd
02:000068AA 4A00            	  3539: 	tst.b	d0
02:000068AC 6B4C            	  3540: 	bmi	.rxerr
                            	  3541: 		
02:000068AE 343C0020        	  3542: 	move.w #$20,d2
                            	  3543: .0001
02:000068B2 1D7C00200004    	  3544: 	move.b #$20,I2C_CMD(a6)	; rd bit
02:000068B8 6100FF6C        	  3545: 	bsr	i2c_wait_tip
02:000068BC 61A6            	  3546: 	bsr	i2c_wait_rx_nack
02:000068BE 102E0004        	  3547: 	move.b I2C_STAT(a6),d0
02:000068C2 4A00            	  3548: 	tst.b	d0
02:000068C4 6B34            	  3549: 	bmi	.rxerr
02:000068C6 102E0003        	  3550: 	move.b I2C_RXR(a6),d0
02:000068CA 1B802000        	  3551: 	move.b d0,(a5,d2.w)
02:000068CE 5242            	  3552: 	addi.w #1,d2
02:000068D0 0C42005F        	  3553: 	cmpi.w #$5F,d2
02:000068D4 66DC            	  3554: 	bne	.0001
02:000068D6 1D7C00680004    	  3555: 	move.b #$68,I2C_CMD(a6)	; STO, rd bit + nack
02:000068DC 6100FF48        	  3556: 	bsr i2c_wait_tip
02:000068E0 6182            	  3557: 	bsr i2c_wait_rx_nack
02:000068E2 102E0004        	  3558: 	move.b I2C_STAT(a6),d0
02:000068E6 4A00            	  3559: 	tst.b	d0
02:000068E8 6B10            	  3560: 	bmi	.rxerr
02:000068EA 102E0003        	  3561: 	move.b I2C_RXR(a6),d0
02:000068EE 1B802000        	  3562: 	move.b d0,(a5,d2.w)
02:000068F2 422E0002        	  3563: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
02:000068F6 7000            	  3564: 	moveq	#0,d0
02:000068F8 4E75            	  3565: 	rts
                            	  3566: .rxerr
02:000068FA 422E0002        	  3567: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
02:000068FE 4E75            	  3568: 	rts
                            	  3569: 
                            	  3570: rtc_write:
02:00006900 2C7CFD069000    	  3571: 	movea.l	#I2C2,a6
02:00006906 4BF900100200    	  3572: 	lea	RTCBuf,a5
02:0000690C 1D7C00800002    	  3573: 	move.b #$80,I2C_CTRL(a6)	; enable I2C
02:00006912 103C00DE        	  3574: 	move.b #$DE,d0				; read address, write op
02:00006916 123C0090        	  3575: 	move.b #$90,d1				; STA + wr bit
02:0000691A 6100FF1A        	  3576: 	bsr	i2c_wr_cmd
02:0000691E 4A00            	  3577: 	tst.b	d0
02:00006920 6B42            	  3578: 	bmi	.rxerr
02:00006922 4200            	  3579: 	move.b #$00,d0				; address zero
02:00006924 123C0010        	  3580: 	move.b #$10,d1				; wr bit
02:00006928 6100FF0C        	  3581: 	bsr	i2c_wr_cmd
02:0000692C 4A00            	  3582: 	tst.b	d0
02:0000692E 6B34            	  3583: 	bmi	.rxerr
02:00006930 343C0020        	  3584: 	move.w #$20,d2
                            	  3585: .0001
02:00006934 10352000        	  3586: 	move.b (a5,d2.w),d0
02:00006938 123C0010        	  3587: 	move.b #$10,d1
02:0000693C 6100FEF8        	  3588: 	bsr	i2c_wr_cmd
02:00006940 4A00            	  3589: 	tst.b	d0
02:00006942 6B20            	  3590: 	bmi	.rxerr
02:00006944 5242            	  3591: 	addi.w #1,d2
02:00006946 0C42005F        	  3592: 	cmpi.w #$5F,d2
02:0000694A 66E8            	  3593: 	bne.s	.0001
02:0000694C 10352000        	  3594: 	move.b (a5,d2.w),d0
02:00006950 123C0050        	  3595: 	move.b #$50,d1				; STO, wr bit
02:00006954 6100FEE0        	  3596: 	bsr	i2c_wr_cmd
02:00006958 4A00            	  3597: 	tst.b	d0
02:0000695A 6B08            	  3598: 	bmi	.rxerr
02:0000695C 422E0002        	  3599: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
02:00006960 7000            	  3600: 	moveq	#0,d0
02:00006962 4E75            	  3601: 	rts
                            	  3602: .rxerr:
02:00006964 422E0002        	  3603: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
02:00006968 4E75            	  3604: 	rts
                            	  3605: 
                            	  3606: msgRtcReadFail:
02:0000696A 5254432072656164	  3607: 	dc.b	"RTC read/write failed.",$0A,$0D,$00
02:00006972 2F77726974652066
02:0000697A 61696C65642E
02:00006980 0A
02:00006981 0D
02:00006982 00
                            	  3608: 
                            	  3609: 	even
                            	  3610: 
                            	  3611: ;------------------------------------------------------------------------------
                            	  3612: ;------------------------------------------------------------------------------
                            	  3613: 	even
                            	  3614: 
                            	  3615: bus_err:
                            	  3616: .0001:
02:00006984 4E71            	  3617: 	nop
02:00006986 60FC            	  3618: 	bra			.0001
                            	  3619: 
                            	  3620: trap3:
                            	  3621: 	; First save all registers
02:00006988 48F9FFFF00040100	  3622: 	movem.l		d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
02:00006990 33DF00040140    	  3623: 	move.w		(a7)+,Regsave+$40
02:00006996 23DF00040144    	  3624: 	move.l		(a7)+,Regsave+$44
02:0000699C 2E7C00040FFC    	  3625: 	move.l		#$40FFC,a7			; reset stack pointer
02:000069A2 46FC2500        	  3626: 	move.w		#$2500,sr				; enable interrupts
02:000069A6 303900040202    	  3627: 	move.w		NumSetBreakpoints,d0
02:000069AC 5340            	  3628: 	subi.w		#1,d0
02:000069AE 41F900040220    	  3629: 	lea				Breakpoints,a0
02:000069B4 223900040144    	  3630: 	move.l		Regsave+$44,d1
                            	  3631: .0001:
02:000069BA B298            	  3632: 	cmp.l			(a0)+,d1
02:000069BC 6708            	  3633: 	beq.s			ProcessBreakpoint
02:000069BE 51C8FFFA        	  3634: 	dbra			d0,.0001
02:000069C2 6000F29E        	  3635: 	bra				Monitor					; not a breakpoint
                            	  3636: ProcessBreakpoint:
02:000069C6 6104            	  3637: 	bsr				DisarmAllBreakpoints
02:000069C8 6000F80A        	  3638: 	bra				cmdDumpRegs
                            	  3639: 
                            	  3640: ;------------------------------------------------------------------------------
                            	  3641: ; DisarmAllBreakpoints, used when entering the monitor.
                            	  3642: ;------------------------------------------------------------------------------
                            	  3643: 
                            	  3644: DisarmAllBreakpoints:
02:000069CC 48E780E0        	  3645: 	movem.l	d0/a0/a1/a2,-(a7)			; stack some regs
02:000069D0 303900040202    	  3646: 	move.w	NumSetBreakpoints,d0	; d0 = number of breakpoints that are set
02:000069D6 0C400008        	  3647: 	cmpi.w	#numBreakpoints,d0		; check for valid number
02:000069DA 641A            	  3648: 	bhs.s		.0001
02:000069DC 45F900040220    	  3649: 	lea			Breakpoints,a2				; a2 = pointer to breakpoint address table
02:000069E2 41F900040280    	  3650: 	lea			BreakpointWords,a0		; a0 = pointer to breakpoint instruction word table
02:000069E8 6004            	  3651: 	bra.s		.0003									; enter loop at bottom
                            	  3652: .0002:
02:000069EA 225A            	  3653: 	move.l	(a2)+,a1							; a1 = address of breakpoint
02:000069EC 3298            	  3654: 	move.w	(a0)+,(a1)						; copy instruction word back to code
                            	  3655: .0003:
02:000069EE 51C8FFFA        	  3656: 	dbra		d0,.0002
02:000069F2 4CDF0701        	  3657: 	movem.l	(a7)+,d0/a0/a1/a2			; restore regs
                            	  3658: .0001:
02:000069F6 4E75            	  3659: 	rts	
                            	  3660: 
                            	  3661: ;------------------------------------------------------------------------------
                            	  3662: ; ArmAllBreakpoints, used when entering the monitor.
                            	  3663: ;------------------------------------------------------------------------------
                            	  3664: 
                            	  3665: ArmAllBreakpoints:
02:000069F8 48E780E0        	  3666: 	movem.l		d0/a0/a1/a2,-(a7)			; stack some regs
02:000069FC 303900040202    	  3667: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
02:00006A02 0C400008        	  3668: 	cmpi.w		#numBreakpoints,d0		; is the number valid?
02:00006A06 641E            	  3669: 	bhs.s			.0001
02:00006A08 45F900040220    	  3670: 	lea				Breakpoints,a2				; a2 = pointer to breakpoint address table
02:00006A0E 41F900040280    	  3671: 	lea				BreakpointWords,a0		; a0 = pointer to instruction word table
02:00006A14 6008            	  3672: 	bra.s			.0003									; enter loop at bottom
                            	  3673: .0002:
02:00006A16 225A            	  3674: 	move.l		(a2)+,a1							; a1 = address of breakpoint
02:00006A18 3091            	  3675: 	move.w		(a1),(a0)							; copy instruction word to table
02:00006A1A 30FC4E43        	  3676: 	move.w		#$4E43,(a0)+					; set instruction = TRAP3
                            	  3677: .0003:
02:00006A1E 51C8FFF6        	  3678: 	dbra			d0,.0002
02:00006A22 4CDF0701        	  3679: 	movem.l		(a7)+,d0/a0/a1/a2			; restore regs
                            	  3680: .0001:
02:00006A26 4E75            	  3681: 	rts	
                            	  3682: 
                            	  3683: ;------------------------------------------------------------------------------
                            	  3684: ;------------------------------------------------------------------------------
                            	  3685: 
                            	  3686: ArmBreakpoint:
02:00006A28 48E7E0E0        	  3687: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
02:00006A2C 303900040202    	  3688: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
02:00006A32 0C400008        	  3689: 	cmpi.w		#numBreakpoints,d0		; check if too many
02:00006A36 645A            	  3690: 	bhs.s			.0001
02:00006A38 527900040202    	  3691: 	addi.w		#1,NumSetBreakpoints	; increment number of breakpoints
02:00006A3E 2400            	  3692: 	move.l		d0,d2
02:00006A40 6100F684        	  3693: 	bsr				ignBlanks
02:00006A44 6100F858        	  3694: 	bsr				GetHexNumber
02:00006A48 6748            	  3695: 	beq.s			.0001									; was there an address?
02:00006A4A 08010000        	  3696: 	btst			#0,d1									; address value must be even
02:00006A4E 6642            	  3697: 	bne.s			.0001
                            	  3698: 	; See if the breakpoint is in the table already
02:00006A50 43F900040220    	  3699: 	lea				Breakpoints,a1				; a1 points to breakpoint table
02:00006A56 343C0007        	  3700: 	move.w		#numBreakpoints-1,d2
                            	  3701: .0002:
02:00006A5A B299            	  3702: 	cmp.l			(a1)+,d1
02:00006A5C 673A            	  3703: 	beq.s			.0003									; breakpoint is in table already
02:00006A5E 51CAFFFA        	  3704: 	dbra			d2,.0002
                            	  3705: 	; Add breakpoint to table
                            	  3706: 	; Search for empty entry
02:00006A62 43F900040220    	  3707: 	lea				Breakpoints,a1				; a1 = pointer to breakpoint address table
02:00006A68 4242            	  3708: 	clr.w			d2										; d2 = count
                            	  3709: .0006:
02:00006A6A 4A91            	  3710: 	tst.l			(a1)									; is the entry empty?
02:00006A6C 670C            	  3711: 	beq.s			.0005									; branch if found empty entry
02:00006A6E 5889            	  3712: 	lea				4(a1),a1							; point to next entry
02:00006A70 5242            	  3713: 	addi.w		#1,d2									; increment count
02:00006A72 0C420008        	  3714: 	cmpi.w		#numBreakpoints,d2		; safety: check against max number
02:00006A76 65F2            	  3715: 	blo.s			.0006
02:00006A78 6018            	  3716: 	bra.s			.0001									; what? no empty entries found, table corrupt?
                            	  3717: .0005:
02:00006A7A E542            	  3718: 	asl.w			#2,d2									; d2 = long word index
02:00006A7C 23812000        	  3719: 	move.l		d1,(a1,d2.w)					; move breakpoint address to table
02:00006A80 2441            	  3720: 	move.l		d1,a2
02:00006A82 E24A            	  3721: 	lsr.w			#1,d2									; d2 = word index
                            	  3722: .0004:
02:00006A84 43F900040280    	  3723: 	lea				BreakpointWords,a1
02:00006A8A 33922000        	  3724: 	move.w		(a2),(a1,d2.w)				; copy instruction word to table
02:00006A8E 34BC4E43        	  3725: 	move.w		#$4E43,(a2)						; replace word with TRAP3
                            	  3726: .0001:
02:00006A92 4CDF0707        	  3727: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
02:00006A96 4E75            	  3728: 	rts
                            	  3729: .0003:
02:00006A98 2469FFFC        	  3730: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
02:00006A9C 0C524E43        	  3731: 	cmpi.w		#$4E43,(a2)						; see if breakpoint already armed
02:00006AA0 67F0            	  3732: 	beq.s			.0001
02:00006AA2 D482            	  3733: 	asl.l			#1,d2									; d2 = word index
02:00006AA4 60DE            	  3734: 	bra.s			.0004
                            	  3735: 
                            	  3736: 
                            	  3737: ;------------------------------------------------------------------------------
                            	  3738: ;------------------------------------------------------------------------------
                            	  3739: 
                            	  3740: DisarmBreakpoint:
02:00006AA6 48E7E0E0        	  3741: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
02:00006AAA 303900040202    	  3742: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
02:00006AB0 0C400008        	  3743: 	cmpi.w		#numBreakpoints,d0		; check if too many
02:00006AB4 623E            	  3744: 	bhi.s			.0001
02:00006AB6 2400            	  3745: 	move.l		d0,d2
02:00006AB8 6100F60C        	  3746: 	bsr				ignBlanks
02:00006ABC 6100F7E0        	  3747: 	bsr				GetHexNumber
02:00006AC0 6732            	  3748: 	beq.s			.0001									; was there an address?
02:00006AC2 08010000        	  3749: 	btst			#0,d1									; address value must be even
02:00006AC6 662C            	  3750: 	bne.s			.0001
                            	  3751: 	; See if the breakpoint is in the table already
02:00006AC8 43F900040220    	  3752: 	lea				Breakpoints,a1				; a1 points to breakpoint table
02:00006ACE 5342            	  3753: 	subi.w		#1,d2
                            	  3754: .0002:
02:00006AD0 B299            	  3755: 	cmp.l			(a1)+,d1
02:00006AD2 6706            	  3756: 	beq.s			.0003									; breakpoint is in table already
02:00006AD4 51CAFFFA        	  3757: 	dbra			d2,.0002
02:00006AD8 601A            	  3758: 	bra				.0001									; breakpoint was not in table
                            	  3759: .0003:
                            	  3760: 	; Remove breakpoint from table
02:00006ADA 537900040202    	  3761: 	subi.w		#1,NumSetBreakpoints	; decrement number of breakpoints
02:00006AE0 2469FFFC        	  3762: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
02:00006AE4 42A9FFFC        	  3763: 	clr.l			-4(a1)								; empty out breakpoint
02:00006AE8 43F900040280    	  3764: 	lea				BreakpointWords,a1
02:00006AEE D482            	  3765: 	asl.l			#1,d2									; d2 = word index
02:00006AF0 34B12000        	  3766: 	move.w		(a1,d2.w),(a2)				; copy instruction from table back to code
                            	  3767: .0001:
02:00006AF4 4CDF0707        	  3768: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
02:00006AF8 4E75            	  3769: 	rts
                            	  3770: 
                            	  3771: ;------------------------------------------------------------------------------
                            	  3772: ;------------------------------------------------------------------------------
                            	  3773: 
                            	  3774: ListBreakpoints:
02:00006AFA 6100E3EC        	  3775: 	bsr			CRLF
02:00006AFE 343C0008        	  3776: 	move.w	#numBreakpoints,d2
02:00006B02 43F900040220    	  3777: 	lea			Breakpoints,a1
                            	  3778: .0001:
02:00006B08 2219            	  3779: 	move.l	(a1)+,d1
02:00006B0A 6100F812        	  3780: 	bsr			DisplayTetra
02:00006B0E 6100E3D8        	  3781: 	bsr			CRLF
02:00006B12 51CAFFF4        	  3782: 	dbra		d2,.0001
02:00006B16 6000F14A        	  3783: 	bra			Monitor
                            	  3784: 
                            	  3785: ;------------------------------------------------------------------------------
                            	  3786: ;------------------------------------------------------------------------------
                            	  3787: 
                            	  3788: ClearBreakpointList:
02:00006B1A 343C0008        	  3789: 	move.w	#numBreakpoints,d2
02:00006B1E 43F900040220    	  3790: 	lea			Breakpoints,a1
                            	  3791: .0001:
02:00006B24 4299            	  3792: 	clr.l		(a1)+
02:00006B26 51CAFFFC        	  3793: 	dbra		d2,.0001
02:00006B2A 4E75            	  3794: 	rts
                            	  3795: 
                            	  3796: ;------------------------------------------------------------------------------
                            	  3797: ; SendMsg
                            	  3798: ; 00100xy0
                            	  3799: ;
                            	  3800: ; Parameters:
                            	  3801: ;		d1 = target core number
                            	  3802: ;		d2 = argument 1
                            	  3803: ;		d3 = argument 2
                            	  3804: ;		d4 = argument 3
                            	  3805: ;
                            	  3806: ;------------------------------------------------------------------------------
                            	  3807: 
                            	  3808: SendMsg:
02:00006B2C 48E70440        	  3809: 	movem.l	d5/a1,-(a7)
02:00006B30 E149            	  3810: 	lsl.w		#8,d1
02:00006B32 4E7A5FE0        	  3811: 	movec		coreno,d5
02:00006B36 E94D            	  3812: 	lsl.w		#4,d5
02:00006B38 8245            	  3813: 	or.w		d5,d1
02:00006B3A 43F900100000    	  3814: 	lea			$00100000,a1
02:00006B40 4AB11000        	  3815: 	tst.l		0(a1,d1.w)
02:00006B44 661C            	  3816: 	bne			.msgFull
02:00006B46 4E7A5FE0        	  3817: 	movec		coreno,d5
02:00006B4A 23851000        	  3818: 	move.l	d5,0(a1,d1.w)
02:00006B4E 23821004        	  3819: 	move.l	d2,4(a1,d1.w)
02:00006B52 23831008        	  3820: 	move.l	d3,8(a1,d1.w)
02:00006B56 2384100C        	  3821: 	move.l	d4,12(a1,d1.w)
02:00006B5A 4CDF0220        	  3822: 	movem.l	(a7)+,d5/a1
02:00006B5E 7200            	  3823: 	moveq		#0,d1
02:00006B60 4E75            	  3824: 	rts
                            	  3825: .msgFull:
02:00006B62 4CDF0220        	  3826: 	movem.l	(a7)+,d5/a1
02:00006B66 72FF            	  3827: 	moveq		#-1,d1
02:00006B68 4E75            	  3828: 	rts
                            	  3829: 
                            	  3830: ;------------------------------------------------------------------------------
                            	  3831: ; ReceiveMsg
                            	  3832: ;		Scan the message table for messages and dispatch them.
                            	  3833: ; 00100xy0
                            	  3834: ;
                            	  3835: ; Parameters:
                            	  3836: ;------------------------------------------------------------------------------
                            	  3837: 
                            	  3838: ReceiveMsg:
02:00006B6A 48E77F40        	  3839: 	movem.l		d1/d2/d3/d4/d5/d6/d7/a1,-(a7)
02:00006B6E 43F900100000    	  3840: 	lea				$00100000,a1
02:00006B74 4E7A5FE0        	  3841: 	movec			coreno,d5
02:00006B78 E14D            	  3842: 	lsl.w			#8,d5
02:00006B7A 7C02            	  3843: 	moveq			#2,d6
                            	  3844: .nextCore:
02:00006B7C 3E06            	  3845: 	move.w		d6,d7
02:00006B7E E94F            	  3846: 	lsl.w			#4,d7
02:00006B80 DE45            	  3847: 	add.w			d5,d7
02:00006B82 4AB17000        	  3848: 	tst.l			0(a1,d7.w)			; Is there a message from core d6?
02:00006B86 6716            	  3849: 	beq				.noMsg
02:00006B88 22317000        	  3850: 	move.l		0(a1,d7.w),d1
02:00006B8C 24317004        	  3851: 	move.l		4(a1,d7.w),d2
02:00006B90 26317008        	  3852: 	move.l		8(a1,d7.w),d3
02:00006B94 2831700C        	  3853: 	move.l		12(a1,d7.w),d4
02:00006B98 42B17000        	  3854: 	clr.l			0(a1,d7.w)			; indicate message was received
02:00006B9C 610E            	  3855: 	bsr				DispatchMsg
                            	  3856: .noMsg:
02:00006B9E 5246            	  3857: 	addq			#1,d6
02:00006BA0 BC7C0009        	  3858: 	cmp.w			#9,d6
02:00006BA4 63D6            	  3859: 	bls				.nextCore
02:00006BA6 4CDF02FE        	  3860: 	movem.l		(a7)+,d1/d2/d3/d4/d5/d6/d7/a1
02:00006BAA 4E75            	  3861: 	rts
                            	  3862: 
                            	  3863: ;------------------------------------------------------------------------------
                            	  3864: ;------------------------------------------------------------------------------
                            	  3865: 
                            	  3866: DispatchMsg:
02:00006BAC 4E75            	  3867: 	rts
                            	  3868: 
                            	  3869: 		
                            	  3870: ;------------------------------------------------------------------------------
                            	  3871: ;------------------------------------------------------------------------------
                            	  3872: 
                            	  3873: InitIRQ:
02:00006BAE 7006            	  3874: 	moveq		#6,d0
02:00006BB0 41FAECB4        	  3875: 	lea			KeybdIRQ,a0
02:00006BB4 610C            	  3876: 	bsr			InstallIRQ
02:00006BB6 41FA003A        	  3877: 	lea			TickIRQ,a0
02:00006BBA 6106            	  3878: 	bsr			InstallIRQ
02:00006BBC 7003            	  3879: 	moveq		#3,d0
02:00006BBE 41FAFBC6        	  3880: 	lea			SerialIRQ,a0
                            	  3881: 	; fall through
                            	  3882: 
                            	  3883: ;------------------------------------------------------------------------------
                            	  3884: ; Install an IRQ handler.
                            	  3885: ;
                            	  3886: ; Parameters:
                            	  3887: ;		d0 = IRQ level
                            	  3888: ;		a0 = pointer to IRQ routine
                            	  3889: ; Returns:
                            	  3890: ;		d1 = -1 if successfully added, 0 otherwise
                            	  3891: ;		nf = 1, zf = 0 if successfully added, otherwise nf = 0, zf = 1
                            	  3892: ;------------------------------------------------------------------------------
                            	  3893: 
                            	  3894: InstallIRQ:
02:00006BC2 2F00            	  3895: 	move.l	d0,-(a7)					; save working register
02:00006BC4 43F80400        	  3896: 	lea			InstalledIRQ,a1		; a1 points to installed IRQ list
02:00006BC8 EB48            	  3897: 	lsl.w		#5,d0							; multiply by 8 long words per IRQ level
                            	  3898: .nextSpot:
02:00006BCA B1F10000        	  3899: 	cmpa.l	(a1,d0.w),a0			; Is the IRQ already installed?
02:00006BCE 6716            	  3900: 	beq.s		.found
02:00006BD0 4AB10000        	  3901: 	tst.l		(a1,d0.w)					; test for an empty spot
02:00006BD4 670C            	  3902: 	beq.s		.foundSpot
02:00006BD6 5840            	  3903: 	addi.w	#4,d0							; increment to next slot
02:00006BD8 3200            	  3904: 	move.w	d0,d1
02:00006BDA 0241001F        	  3905: 	andi.w	#$1F,d1						; check to see if spots exhausted
02:00006BDE 670C            	  3906: 	beq.s		.noEmpties
02:00006BE0 60E8            	  3907: 	bra.s		.nextSpot
                            	  3908: .foundSpot:
02:00006BE2 23880000        	  3909: 	move.l	a0,(a1,d0.w)			; add IRQ routine to table
                            	  3910: .found:
02:00006BE6 201F            	  3911: 	move.l	(a7)+,d0
02:00006BE8 72FF            	  3912: 	moveq		#-1,d1						; return success
02:00006BEA 4E75            	  3913: 	rts
                            	  3914: .noEmpties:
02:00006BEC 201F            	  3915: 	move.l	(a7)+,d0
02:00006BEE 7200            	  3916: 	moveq		#0,d1							; return failed to add
02:00006BF0 4E75            	  3917: 	rts
                            	  3918: 	
                            	  3919: 
                            	  3920: ;------------------------------------------------------------------------------
                            	  3921: ;------------------------------------------------------------------------------
                            	  3922: 
                            	  3923: TickIRQ:
02:00006BF2 46FC2600        	  3924: 	move.w	#$2600,sr					; disable lower level IRQs
02:00006BF6 48E76080        	  3925: 	movem.l	d1/d2/a0,-(a7)
                            	  3926: 	; ToDo: detect a tick interrupt
                            	  3927: ;	move.l	PLIC+$00,d1
                            	  3928: ;	rol.l		#8,d1
                            	  3929: ;	cmpi.b	#29,d1
                            	  3930: ;	bne.s		.notTick
02:00006BFA 4E7A1FE0        	  3931: 	movec		coreno,d1					; d1 = core number
02:00006BFE 0C010002        	  3932: 	cmpi.b	#2,d1
02:00006C02 660A            	  3933: 	bne.s		.0001
02:00006C04 23FC1D000000FD09	  3934: 	move.l	#$1D000000,PLIC+$14	; reset edge sense circuit
02:00006C0C 0014
                            	  3935: .0001:	
02:00006C0E 207900040004    	  3936: 	move.l	TextScr,a0				; a0 = screen address
02:00006C14 2410            	  3937: 	move.l	(a0),d2
02:00006C16 E15A            	  3938: 	rol.w		#8,d2							; reverse byte order of d2
02:00006C18 4842            	  3939: 	swap		d2
02:00006C1A E15A            	  3940: 	rol.w		#8,d2
02:00006C1C 06010030        	  3941: 	addi.b	#'0',d1						; binary to ascii core number
02:00006C20 D202            	  3942: 	add.b		d2,d1
02:00006C22 E159            	  3943: 	rol.w		#8,d1							; put bytes back in order
02:00006C24 4841            	  3944: 	swap		d1
02:00006C26 E159            	  3945: 	rol.w		#8,d1
02:00006C28 21410004        	  3946: 	move.l	d1,4(a0)					; update onscreen IRQ flag
02:00006C2C 5290            	  3947: 	addi.l	#1,(a0)						; flashy colors
                            	  3948: ; addi.l	#1,40(a0)					; nice effect
02:00006C2E 6100FF3A        	  3949: 	bsr			ReceiveMsg
02:00006C32 4CDF0106        	  3950: 	movem.l	(a7)+,d1/d2/a0
02:00006C36 4E73            	  3951: 	rte
                            	  3952: ;.notTick:
                            	  3953: ;	movem.l	(a7)+,d1/a0
                            	  3954: ;	rte
                            	  3955: ;------------------------------------------------------------------------------
                            	  3956: ;------------------------------------------------------------------------------
                            	  3957: 
                            	  3958: irq3_rout:
02:00006C38 48E7C0C0        	  3959: 	movem.l	d0/d1/a0/a1,-(a7)
02:00006C3C 41F80460        	  3960: 	lea			InstalledIRQ+8*4*3,a0
02:00006C40 6008            	  3961: 	bra			irq_rout
                            	  3962: 
                            	  3963: irq6_rout:
02:00006C42 48E7C0C0        	  3964: 	movem.l	d0/d1/a0/a1,-(a7)
02:00006C46 41F804C0        	  3965: 	lea			InstalledIRQ+8*4*6,a0
                            	  3966: irq_rout:
02:00006C4A 7007            	  3967: 	moveq		#7,d0
                            	  3968: .nextHandler:
02:00006C4C 2258            	  3969: 	move.l	(a0)+,a1
02:00006C4E 6706            	  3970: 	beq.s		.0003
02:00006C50 4E91            	  3971: 	jsr			(a1)
02:00006C52 4A81            	  3972: 	tst.l		d1								; was IRQ handled?
02:00006C54 6B04            	  3973: 	bmi.s		.0002							; first one to return handled quits loop
                            	  3974: .0003:
02:00006C56 51C8FFF4        	  3975: 	dbra		d0,.nextHandler
                            	  3976: .0002:
02:00006C5A 4CDF0303        	  3977: 	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  3978: 
                            	  3979: SpuriousIRQ:
02:00006C5E 4E73            	  3980: 	rte
                            	  3981: 
                            	  3982: ;	bsr			KeybdIRQ
                            	  3983: ;	tst.l		d1								; handled by KeybdIRQ?
                            	  3984: ;	bmi.s		.0002							; if yes, go return
                            	  3985: ;.0001:
                            	  3986: ;	move.l	#$1D000000,PLIC+$14	; reset edge sense circuit
                            	  3987: ;	move.l	TextScr,a0				; a0 = screen address
                            	  3988: ;	addi.l	#1,40(a0)					; update onscreen IRQ flag
                            	  3989: ;.0002:	
                            	  3990: ;	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  3991: ;	rte
                            	  3992: 
                            	  3993: nmi_rout:
02:00006C60 48E7C080        	  3994: 	movem.l	d0/d1/a0,-(a7)
02:00006C64 123C004E        	  3995: 	move.b	#'N',d1
02:00006C68 6100E2C8        	  3996: 	bsr			DisplayChar
02:00006C6C 4CDF0103        	  3997: 	movem.l	(a7)+,d0/d1/a0		; return
02:00006C70 4E73            	  3998: 	rte
                            	  3999: 
                            	  4000: brdisp_trap:
02:00006C72 48F9FFFF00040100	  4001: 	movem.l	d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
02:00006C7A 33DF00040140    	  4002: 	move.w	(a7)+,Regsave+$40
02:00006C80 23DF00040144    	  4003: 	move.l	(a7)+,Regsave+$44
02:00006C86 2E7C00040FFC    	  4004: 	move.l	#$40FFC,a7			; reset stack pointer
02:00006C8C 46FC2500        	  4005: 	move.w	#$2500,sr				; enable interrupts
02:00006C90 43FA008C        	  4006: 	lea			msg_bad_branch_disp,a1
02:00006C94 6100E516        	  4007: 	bsr			DisplayString
02:00006C98 6100F67C        	  4008: 	bsr			DisplaySpace
02:00006C9C 223900040144    	  4009: 	move.l	Regsave+$44,d1	; exception address
02:00006CA2 6100F67A        	  4010: 	bsr			DisplayTetra		; and display it
                            	  4011: ;	move.l	(sp)+,d1				; pop format word 68010 mode only
02:00006CA6 6000F52C        	  4012: 	bra			cmdDumpRegs
                            	  4013: 
                            	  4014: illegal_trap:
02:00006CAA 544F            	  4015: 	addq		#2,sp						; get rid of sr
02:00006CAC 221F            	  4016: 	move.l	(sp)+,d1				; pop exception address
02:00006CAE 6100F66E        	  4017: 	bsr			DisplayTetra		; and display it
02:00006CB2 43FA0058        	  4018: 	lea			msg_illegal,a1	; followed by message
02:00006CB6 6100E4F4        	  4019: 	bsr			DisplayString
                            	  4020: .0001:
02:00006CBA 60FE            	  4021: 	bra			.0001
02:00006CBC 6000EFA4        	  4022: 	bra			Monitor
                            	  4023: 	
                            	  4024: io_irq:
02:00006CC0 544F            	  4025: 	addq #2,sp
02:00006CC2 221F            	  4026: 	move.l (sp)+,d1
02:00006CC4 6100F658        	  4027: 	bsr DisplayTetra
02:00006CC8 43FA0076        	  4028: 	lea msg_io_access,a1
02:00006CCC 6100E4DE        	  4029: 	bsr DisplayString
02:00006CD0 6000F502        	  4030: 	bra cmdDumpRegs
                            	  4031: 
                            	  4032: ; -----------------------------------------------------------------------------
                            	  4033: ; -----------------------------------------------------------------------------
                            	  4034: 
                            	  4035: msg_start:
02:00006CD4 46656D74696B6920	  4036: 	dc.b	"Femtiki rf68k Multi-core OS Starting",LF,CR,0
02:00006CDC 726636386B204D75
02:00006CE4 6C74692D636F7265
02:00006CEC 204F532053746172
02:00006CF4 74696E67
02:00006CF8 0A
02:00006CF9 0D
02:00006CFA 00
                            	  4037: ;	dc.b	"rf68k System Starting",CR,LF,0
                            	  4038: msg_core_start:
02:00006CFB 20636F7265207374	  4039: 	dc.b	" core starting",CR,LF,0
02:00006D03 617274696E67
02:00006D09 0D
02:00006D0A 0A
02:00006D0B 00
                            	  4040: msg_illegal:
02:00006D0C 20696C6C6567616C	  4041: 	dc.b	" illegal opcode",CR,LF,0
02:00006D14 206F70636F6465
02:00006D1B 0D
02:00006D1C 0A
02:00006D1D 00
                            	  4042: msg_bad_branch_disp:
02:00006D1E 206272616E636820	  4043: 	dc.b	" branch selfref: ",0
02:00006D26 73656C667265663A
02:00006D2E 20
02:00006D2F 00
                            	  4044: msg_test_done:
02:00006D30 2043505520746573	  4045: 	dc.b	" CPU test done.",0
02:00006D38 7420646F6E652E
02:00006D3F 00
                            	  4046: msg_io_access
02:00006D40 20756E7065726D69	  4047: 	dc.b " unpermitted access to I/O",0
02:00006D48 7474656420616363
02:00006D50 65737320746F2049
02:00006D58 2F4F
02:00006D5A 00
                            	  4048: 
                            	  4049: 
                            	  4050: 


Symbols by name:
ABCD_INNER1                     02:000026B2
ABCD_INNER2                     02:00002720
ABCD_NO_C1                      02:000026CE
ABCD_NO_C2                      02:000026D6
ABCD_NO_C3                      02:0000273C
ABCD_NO_C4                      02:00002744
ABCD_OUTER1                     02:000026B0
ABCD_OUTER2                     02:0000271E
ABS                             02:00004702
ABSRT                           02:00004710
ACIA                             E:FD060000
ACIA_CMD                         E:00000008
ACIA_CTRL                        E:0000000C
ACIA_RX                          E:00000000
ACIA_STAT                        E:00000004
ACIA_TX                          E:00000000
ADDA_OUTER1                     02:00003218
ADDQ_LOOP1                      02:00002A32
ADDQ_LOOP2                      02:00002A70
ADDQ_LOOP3                      02:00002AA6
ADDX_LOOP3                      02:0000333E
ADDX_LOOP4                      02:0000335A
ADDX_LOOP5                      02:00003376
ADDX_OUTER1                     02:000032AA
ADD_OUTER1                      02:0000303E
ADD_OUTER2                      02:000030B2
AHOW                            02:000047AC
ALL_DONE                        02:00000424
AND_OUTER1                      02:00002D5C
AND_OUTER2                      02:00002DD0
ASORRY                          02:000047A4
AUXIN                           02:00004AD8
AUXOUT                          02:00004AC8
AWHAT                           02:00004764
AXIRET                          02:00004AF6
ArmAllBreakpoints               02:000069F8
ArmBreakpoint                   02:00006A28
AsciiToHexNybble                02:000062CA
AudioInputTest                  02:00006632
BCC1                            02:00002958
BCC10                           02:000029AA
BCC11                           02:000029B2
BCC12                           02:000029BC
BCC13                           02:000029C4
BCC14                           02:000029CE
BCC2                            02:00002962
BCC3                            02:0000296A
BCC4                            02:00002974
BCC5                            02:0000297C
BCC6                            02:00002986
BCC7                            02:0000298E
BCC8                            02:00002998
BCC9                            02:000029A0
BSR_CLOSE1                      02:000014F8
BSR_CLOSE2                      02:0000152E
BSR_FAR1                        02:00000426
BSR_FAR2                        02:00002948
BUFFER                          02:00004B7A
BUFLEN                           E:00000050
BYEBYE                          02:00004AF8
BlankLastLine                   02:00005148
BouncingBalls                   02:00006634
BreakpointWords                  E:00040280
Breakpoints                      E:00040220
CALL                            02:000044FA
CHKIO                           02:00004A6E
CHKRET                          02:00004A7E
CLMSG                           02:00004B3E
CMPA_OUTER1                     02:00002F32
CMPM_LOOP1                      02:00002FC0
CMPM_LOOP2                      02:00002FDA
CMPM_LOOP3                      02:00002FF4
CMP_OUTER1                      02:00002EBC
CR                               E:0000000D
CRLF                            02:00004EE8
CSTART                          02:00003E9C
CTRLC                            E:00000003
CTRLH                            E:00000008
CTRLS                            E:00000013
CTRLX                            E:00000018
CTRLZ                            E:0000001A
CURRNT                          02:00004B4E
CalcScreenLoc                   02:00004F24
CallOS                          02:00004C10
CheckForCtrlC                   02:000055A2
CheckForKey                     02:0000555E
ClearBreakpointList             02:00006B1A
ClearScreen                     02:00006638
CmdBuf                           E:00040040
CmdBufEnd                        E:00040080
Cursor1                         02:000052E0
CursorCol                        E:00040001
CursorRow                        E:00040000
DBCC_LOOP1                      02:000029D8
DBCC_LOOP2                      02:000029E6
DEFLT                           02:000043EE
DIRECT                          02:000040B6
DIV1                            02:00004698
DIV2                            02:0000469E
DIV3                            02:000046A4
DIV32                           02:00004686
DIV4                            02:000046B2
DIVRT                           02:000046C0
DIVS_OUTER1                     02:00002C1C
DIVU_OUTER1                     02:00002BCA
DOQUO                           02:00004A4C
DOQUO1                          02:00004A54
Delay3s                         02:00000302
Delay3s2                        02:00000326
DisarmAllBreakpoints            02:000069CC
DisarmBreakpoint                02:00006AA6
DispatchMsg                     02:00006BAC
DisplayAddr                     02:0000634A
DisplayByte                     02:0000632A
DisplayChar                     02:00004F32
DisplayHelp                     02:00005DD0
DisplayMem                      02:00006178
DisplayNybble                   02:00006330
DisplaySpace                    02:00006316
DisplayString                   02:000051AC
DisplayStringCRLF               02:000051C2
DisplayStringLimited            02:000051C8
DisplayStringLimitedCRLF        02:000051E8
DisplayTetra                    02:0000631E
DisplayTwoSpaces                02:00006304
DisplayWyde                     02:00006324
DumpMem1                        02:00006166
ENDCHK                          02:00004750
ENDCHK1                         02:00004760
ENDMEM                          02:00003E98
EOR_OUTER2                      02:00002E46
ERROR                           02:00004768
EX1                             02:000040E8
EXCEPTION_6                     02:0000042E
EXCEPTION_7                     02:00000436
EXEC                            02:000040BE
EXGO                            02:000040F4
EXLP                            02:000040C6
EXMAT                           02:000040EE
EXNGO                           02:000040D0
EXP4RT                          02:000045D4
EXPR                            02:0000450E
EXPR2                           02:00004562
EXPR3                           02:00004596
EXPR4                           02:000045BE
ExecuteCode                     02:00006138
FI1                             02:00004742
FI2                             02:0000474E
FIN                             02:00004736
FINISH                          02:0000423C
FNDLN                           02:00004850
FNDLNP                          02:0000485E
FNDNXT                          02:00004876
FNDRET                          02:00004874
FNDSKP                          02:00004878
FOR                             02:00004292
FR1                             02:000042AC
FR2                             02:000042C2
FR3                             02:000042C8
FR4                             02:000042CA
FR5                             02:000042D0
FR6                             02:000042E2
FR7                             02:000042E6
FR8                             02:00004300
FemtikiInit                     02:00004BCA
FemtikiInitIRQ                  02:00004C00
FemtikiTimerIRQ                 02:00004DF4
ForceUnlockSemaphore            02:000002B6
FromScreen                      02:00005C4E
GBYTE                           02:00004444
GBYTE1                          02:00004448
GBYTE2                          02:00004456
GETLN                           02:000047B2
GL1                             02:000047C2
GL2                             02:000047E0
GL3                             02:000047F4
GL4                             02:00004818
GL5                             02:00004824
GL6                             02:00004840
GL7                             02:00004848
GOAUXI                          02:00003E8C
GOAUXO                          02:00003E88
GOBYE                           02:00003E90
GOIN                            02:00003E84
GOOUT                           02:00003E80
GOSUB                           02:00004244
GOTO                            02:00004198
GOWARM                          02:00003E7E
GetCmdLine                      02:00005F52
GetHexNumber                    02:0000629E
GetKey                          02:0000556A
GetRunningTCBPointer            02:00004C7A
GraphicsDemo                    02:00006636
HAS_MMU                          E:00000000
HOWMSG                          02:00004B29
HelpMsg                         02:00005DDC
HomeCursor                      02:000051EE
I2C2                             E:FD069000
I2C_CMD                          E:00000004
I2C_CTRL                         E:00000002
I2C_PREH                         E:00000001
I2C_PREL                         E:00000000
I2C_RXR                          E:00000003
I2C_STAT                         E:00000004
I2C_TXR                          E:00000003
IF                              02:00004358
IF1                             02:0000435C
IF2                             02:00004362
IGB1                            02:00004A1E
IGBRET                          02:00004A22
IGNBLK                          02:00004A18
INC                             02:00004AA8
INC1                            02:00004AB4
INCOM                           02:00004108
INCON                           02:000040FA
INITMSG                         02:00004AFC
INPERR                          02:00004372
INPPTR                          02:00004B46
INPUT                           02:00004380
IOCOM                           02:00004116
IOCON                           02:0000412E
IOFocus                          E:00100000
IO_BITMAP                        E:FD000000
IP2                             02:00004392
IP3                             02:000043AC
IP4                             02:000043E0
IP5                             02:000043EA
IncCursorPos                    02:000050AA
IncCursorRow                    02:000050CA
InitIOBitmap                    02:00000196
InitIRQ                         02:00006BAE
InitMMU                         02:0000015C
InitRand                        02:000001DC
InitSemaphores                  02:00000270
InsertIntoReadyQueue            02:00004CE6
InstallIRQ                      02:00006BC2
InstalledIRQ                     A:00000400
KEYBD                            E:FD0FFE00
KEYBD_SEMA                       E:00000003
KeybdEcho                        E:0004000C
KeybdGetChar                    02:000055BE
KeybdGetCharNoWait              02:000055AE
KeybdGetCharWait                02:000055B6
KeybdGetID                      02:0000538C
KeybdID                          E:00100016
KeybdIRQ                        02:00005866
KeybdInit                       02:000053F6
KeybdLEDs                        E:0010000E
KeybdRecvByte                   02:00005510
KeybdSendByte                   02:00005826
KeybdSetLED                     02:000053CA
KeybdSetLEDStatus               02:000057D6
KeybdWaitFlag                    E:0004000D
KeybdWaitTx                     02:00005530
LEA1                            02:00001F04
LET                             02:000043F4
LF                               E:0000000A
LIST                            02:000041AC
LOAD                            02:00004404
LOD1                            02:00004410
LOD2                            02:0000442A
LODEND                          02:0000443A
LOPINC                          02:00004B5E
LOPLMT                          02:00004B62
LOPLN                           02:00004B66
LOPPT                           02:00004B6A
LOPVAR                          02:00004B5A
LS1                             02:000041B8
LS2                             02:000041CC
LS3                             02:000041D2
LSTROM                          02:00004B42
LT1                             02:00004400
ListBreakpoints                 02:00006AFA
LockSemaphore                   02:00000296
MAX_TID                          E:00000FFF
MEMORY_SEMA                      E:00000006
MLT1                            02:0000464E
MLT2                            02:00004654
MLT3                            02:00004668
MLTRET                          02:00004684
MMU                              E:FDC00000
MOVE1                           02:00001B72
MOVE2                           02:00001AF6
MOVE3                           02:00001BF2
MOVE4                           02:00001D4C
MULS_OUTER1                     02:00003512
MULT32                          02:00004644
MULU_OUTER1                     02:000034C6
MVDOWN                          02:00004890
MVRET                           02:0000488E
MVUP                            02:00004886
Monitor                         02:00005C62
NBCD_LOOP                       02:00002898
NBCD_LOOP1                      02:000028DE
NBCD_NO_C                       02:000028A4
NBCD_NO_C1                      02:000028F2
NBCD_NO_Z                       02:000028A8
NBCD_NO_Z1                      02:000028F6
NEW                             02:00004146
NEXT                            02:00004304
NR_TCB                           E:00001000
NX0                             02:0000430E
NX1                             02:0000433A
NX2                             02:0000434E
NX3                             02:00004320
NextRec                         02:00006428
NumSetBreakpoints                E:00040202
OKMSG                           02:00004B22
OR_OUTER1                       02:00002C72
OR_OUTER2                       02:00002CE6
OSCallTable                     02:00004C0E
OUTC                            02:00004A8C
OUTC1                           02:00004A98
OUTCOM                          02:00004120
OUTCON                          02:00004138
OUTPTR                          02:00004B4A
PARN                            02:000045E0
PBYTE                           02:000044C2
PBYTE1                          02:000044C4
PBYTE2                          02:000044D8
PEEK                            02:000046C2
PKER                            02:000044F6
PLIC                             E:FD090000
PN1                             02:0000494C
PN3                             02:00004986
PN4                             02:00004992
PN5                             02:0000499E
PNOV                            02:0000495C
PNRET                           02:000049AC
POKE                            02:000044E2
POPA                            02:00004898
PP1                             02:000048BA
PR0                             02:000041F6
PR1                             02:00004204
PR2                             02:000041E8
PR3                             02:0000421A
PR4                             02:00004214
PR6                             02:00004226
PR8                             02:0000422C
PRINT                           02:000041D8
PRMESG                          02:00004A80
PRMRET                          02:00004A8A
PRTLN                           02:000049B0
PRTNUM                          02:0000493C
PRTRET                          02:000048FC
PRTSTG                          02:000048E2
PS1                             02:000048E4
PU1                             02:000048DE
PUSHA                           02:000048BC
PointerToTCBHandle              02:00004CB0
PopReadyQueue                   02:00004D54
ProcessBreakpoint               02:000069C6
ProcessRec                      02:0000643A
ProcessS1                       02:0000653C
ProcessS2                       02:00006540
ProcessS3                       02:00006544
ProcessS7                       02:00006548
ProcessS8                       02:00006558
ProcessS9                       02:00006568
Prompt1                         02:00005CA0
Prompt3                         02:00005C8A
PromptLn                        02:00005C7E
QHOW                            02:000047AA
QSORRY                          02:000047A2
QT1                             02:00004908
QT2                             02:00004918
QT3                             02:0000491C
QT4                             02:00004928
QT5                             02:0000493A
QTSTG                           02:000048FE
QWHAT                           02:00004762
QueueCycle                       E:0010031C
RA1                             02:000046EE
RAND_MW                          E:FD0FFD0C
RAND_MZ                          E:FD0FFD08
RAND_NUM                         E:FD0FFD00
RAND_SEMA                        E:00000004
RAND_STRM                        E:FD0FFD04
RANPNT                          02:00004B42
REM                             02:00004356
RETURN                          02:00004270
RND                             02:000046CE
ROXx_FLAGS                      02:000037DA
ROXx_LOOP1                      02:000037F0
ROXx_LOOP2                      02:00003810
ROXx_LOOP3                      02:00003830
ROXx_LOOP4                      02:00003850
ROXx_LOOP5                      02:00003870
ROXx_LOOP6                      02:00003892
ROx_FLAGS                       02:000035A4
ROx_LOOP1                       02:000035BA
ROx_LOOP2                       02:000035DA
ROx_LOOP3                       02:000035FA
ROx_LOOP4                       02:0000361A
ROx_LOOP5                       02:0000363A
ROx_LOOP6                       02:0000365C
RST_REG                          E:FD0FFC00
RTCBuf                           E:00100200
RTR_DONE                        02:0000293A
RUN                             02:0000415A
RUNNXL                          02:00004168
RUNSML                          02:00004188
RUNTSL                          02:0000417E
RandGetNum                      02:00000226
RandInit                        02:000001DC
RandWait                        02:0000025A
ReceiveMsg                      02:00006B6A
Regsave                          E:00040100
RemoveFromReadyQueue            02:00004D36
RunningTCB                       E:00100224
S1932a                          02:000065B0
S1932b                          02:000065C4
S19Checksum                      E:00100150
S19Get16BitAddress              02:00006578
S19Get24BitAddress              02:00006586
S19Get32BitAddress              02:00006592
S19StartAddress                  E:00040008
SAVE                            02:00004464
SAVE1                           02:0000446C
SAVE2                           02:00004490
SAVEND                          02:0000449E
SBCD_INNER1                     02:000027AA
SBCD_INNER2                     02:00002818
SBCD_NO_C1                      02:000027C6
SBCD_NO_C2                      02:000027CE
SBCD_NO_C3                      02:00002834
SBCD_NO_C4                      02:0000283C
SBCD_OUTER1                     02:000027A8
SBCD_OUTER2                     02:00002816
SCREEN_SEMA                      E:00000005
SC_ALT                           E:00000011
SC_CAPSLOCK                      E:00000058
SC_CTRL                          E:00000014
SC_EXTEND                        E:000000E0
SC_KEYUP                         E:000000F0
SC_LSHIFT                        E:00000012
SC_NUMLOCK                       E:00000077
SC_RSHIFT                        E:00000059
SC_SCROLLLOCK                    E:0000007E
SC_TAB                           E:0000000D
SERIAL_SEMA                      E:00000002
SETVAL                          02:0000471C
SHIFTS2_FLAGS                   02:00003C52
SHIFTS2_LOOP1                   02:00003C68
SHIFTS2_LOOP2                   02:00003C84
SHIFTS2_LOOP3                   02:00003CA0
SHIFTS2_LOOP4                   02:00003CBC
SHIFTS2_LOOP5                   02:00003CD8
SHIFTS2_LOOP6                   02:00003CF6
SHIFTS_FLAGS                    02:00003A10
SHIFTS_LOOP1                    02:00003A26
SHIFTS_LOOP2                    02:00003A46
SHIFTS_LOOP3                    02:00003A66
SHIFTS_LOOP4                    02:00003A86
SHIFTS_LOOP5                    02:00003AA6
SHIFTS_LOOP6                    02:00003AC8
SIZE                            02:00004712
SRYMSG                          02:00004B38
ST3                             02:00003F00
ST4                             02:00003F4E
START                           02:00003E7C
STKGOS                          02:00004B52
STKINP                          02:00004B56
STKLMT                          02:00004B76
STOP                            02:00004152
SUBA_OUTER1                     02:00003264
SUBQ_LOOP1                      02:00002AF0
SUBQ_LOOP2                      02:00002B2A
SUBQ_LOOP3                      02:00002B60
SUBX_LOOP3                      02:0000344E
SUBX_LOOP4                      02:0000346A
SUBX_LOOP5                      02:00003486
SUBX_OUTER1                     02:000033BA
SUB_OUTER1                      02:00003128
SUB_OUTER2                      02:0000319C
SV1                             02:00004734
ScrollUp                        02:000050FE
SelectThreadToRun               02:00004CC0
SendMsg                         02:00006B2C
SerHeadRcv                       E:00100162
SerRcvBuf                        E:00101000
SerRcvXoff                       E:00100165
SerRcvXon                        E:00100164
SerTailRcv                       E:00100160
SerialGetChar                   02:00006678
SerialIRQ                       02:00006786
SerialInit                      02:00006646
SerialPeekChar                  02:000066F0
SerialPeekCharDirect            02:00006728
SerialPutChar                   02:00006742
SerialRbo                       02:0000675E
SerialRcvCount                  02:00006766
SetKeyboardEcho                 02:00005556
SpuriousIRQ                     02:00006C5E
StartMon                        02:00005C58
StartQ                          02:00004D4C
StubRout                        02:00005316
SyncCursor                      02:00005200
T15DispatchTable                02:00005240
T15LockSemaphore                02:000002EA
T15UnlockSemaphore              02:000002F6
TAB1                            02:00003F88
TAB1_1                          02:0000400E
TAB2                            02:00003FB4
TAB2_1                          02:0000403A
TAB4                            02:00003FEC
TAB4_1                          02:00004076
TAB5                            02:00003FFB
TAB5_1                          02:0000408A
TAB6                            02:00003FFE
TAB6_1                          02:00004092
TAB8                            02:00004003
TAB8_1                          02:0000409A
TC1                             02:000049DC
TCBEndTick                       E:00000070
TCBHandleToPointer              02:00004C98
TCBNext                          E:0000007C
TCBPC                            E:00000050
TCBPrev                          E:00000080
TCBPriority                      E:00000055
TCBRegs                          E:00000004
TCBSR                            E:0000004C
TCBSSP                           E:00000048
TCBStartTick                     E:0000006C
TCBStatus                        E:00000054
TCBTicks                         E:00000074
TCBUSP                           E:00000044
TCB_SEMA                         E:00000007
TCB_SIZE                         E:00000100
TEXTREG                          E:FD03FF00
TN1                             02:000049E8
TOASCII                         02:00004976
TOUPB1                          02:00004A2A
TOUPBRT                         02:00004A4A
TOUPBUF                         02:00004A24
TOUPPER                         02:00004A5C
TOUPRET                         02:00004A6C
TRAP15                          02:0000522A
TSNMRET                         02:00004A16
TSTC                            02:000049CA
TSTNUM                          02:000049E2
TSTV                            02:000045F6
TSTVRT                          02:00004642
TS_PREEMPT                       E:00000020
TS_RUNNING                       E:00000080
TV1                             02:0000462C
TXT                             02:00004BCA
TXTBGN                          02:00003E94
TXTUNF                          02:00004B6E
TextCols                         E:0004008D
TextCurpos                       E:00040002
TextPos                          E:00040002
TextRows                         E:0004008C
TextScr                          E:00040004
TickIRQ                         02:00006BF2
TimerStack                       E:00040BFC
UnlockSemaphore                 02:000002D0
UpdateIRQLive                   02:00004DD2
UpdateTextPos                   02:00004EFA
VARBGN                          02:00004B72
WHTMSG                          02:00004B30
WSTART                          02:00003EE0
Wait10ms                        02:0000582E
Wait300ms                       02:0000584A
XOFF                             E:00000013
XON                              E:00000011
XP11                            02:0000451E
XP12                            02:00004524
XP13                            02:0000452A
XP14                            02:00004530
XP15                            02:00004536
XP15RT                          02:0000453C
XP16                            02:0000453E
XP16RT                          02:00004544
XP17                            02:0000454E
XP18                            02:00004552
XP21                            02:0000456C
XP22                            02:00004572
XP23                            02:00004574
XP24                            02:0000457E
XP25                            02:00004588
XP26                            02:0000458E
XP31                            02:00004598
XP34                            02:000045AA
XP40                            02:000045CA
XP41                            02:000045D6
XP42                            02:000045F0
XP43                            02:000045F2
XPRT0                           02:00004546
XPRT1                           02:0000454A
_KeyState1                       E:0010000F
_KeyState2                       E:00100010
_KeybdBuf                        E:00100020
_KeybdCnt                        E:00100013
_KeybdGetScancode               02:00005500
_KeybdGetStatus                 02:000054F6
_KeybdHead                       E:00100011
_KeybdInit                      02:000053F6
_KeybdTail                       E:00100012
_keybdControlCodes              02:00005AF8
_keybdExtendedCodes             02:00005B78
_shiftedScanCodes               02:000059F8
_unshiftedScanCodes             02:000058F8
bkColor                          E:00040088
brdisp_trap                     02:00006C72
bus_err                         02:00006984
clear_screen                    02:00004E98
cmdBreakpoint                   02:00005CF8
cmdClearScreen                  02:00005D30
cmdClock                        02:00005D60
cmdCore                         02:00005D3C
cmdDispatch                     02:00005CB2
cmdDumpMemory                   02:00006146
cmdDumpRegs                     02:000061D4
cmdEditMemory                   02:000060D8
cmdFillB                        02:0000605A
cmdFillL                        02:000060A2
cmdFillW                        02:0000607E
cmdHelp                         02:00005DD0
cmdJump                         02:00006138
cmdLoadS19                      02:00006422
cmdMonitor                      02:00005C62
cmdReceiveSerial                02:00006026
cmdReset                        02:00005D7E
cmdSendSerial                   02:00005FF6
cmdString                       02:00005BF8
cmdTable                        02:00005C24
cmdTestCPU                      02:00005D20
cmdTestRAM                      02:00006368
cmdTestSerialReceive            02:0000627E
cmdTinyBasic                    02:00005D1C
cpu_test                        02:00000342
dccr                            02:00004F5A
dclf                            02:0000502A
dcx10                           02:00004FC2
dcx11                           02:00004FE4
dcx12                           02:00004FDA
dcx14                           02:00004F50
dcx16                           02:0000502E
dcx4                            02:00005032
dcx6                            02:00004F78
dcx7                            02:00004F54
dcx8                            02:00004F8E
dcx9                            02:00004FA4
dly3s1                          02:00000312
dly3s2                          02:00000310
doBackspace                     02:0000503C
doCtrlX                         02:00005086
doDelete                        02:0000504A
do_nothing                      02:000000FE
dspj1                           02:000051B0
dspmem1                         02:00006188
dspspc1                         02:0000630E
dsret                           02:000051BC
edtmem1                         02:000060E0
fgColor                          E:00040084
get_screen_address              02:00004E90
get_screen_color                02:00004E64
gthx3                           02:00006300
gthx5                           02:000062DC
gthx6                           02:000062EE
i2c_setup                       02:00006816
i2c_wait_rx_nack                02:00006864
i2c_wait_tip                    02:00006826
i2c_wr_cmd                      02:00006836
i2c_xmit1                       02:00006846
icc1                            02:000050FC
ignBlanks                       02:000060C6
illegal_trap                    02:00006CAA
init_i2c                        02:00006816
init_plic                       02:00005356
io_irq                          02:00006CC0
irq3_rout                       02:00006C38
irq6_rout                       02:00006C42
irq_rout                        02:00006C4A
kbdi0002                        02:0000541E
kbdi0004                        02:0000548A
kbdi0005                        02:000054A4
kbdiTryAgain                    02:0000547C
kbdiXmitBusy                    02:000054BE
kgid1                           02:000053BE
kgnotKbd                        02:000053C6
leds                             E:FD0FFF00
ledxit                          02:000054A8
loop1                           02:000000D0
loop2                           02:000000CE
loop3                           02:00004ECE
memend                           E:00100004
mmu_adrtbl                      02:00000104
msgBadKeybd                     02:000054CC
msgHello                        02:00005F40
msgRtcReadFail                  02:0000696A
msgUnknownCmd                   02:00005F30
msgXmitBusy                     02:000054DB
msg_bad_branch_disp             02:00006D1E
msg_core_start                  02:00006CFB
msg_illegal                     02:00006D0C
msg_io_access                   02:00006D40
msg_reglist                     02:00006258
msg_regs                        02:00006254
msg_start                       02:00006CD4
msg_test_done                   02:00006D30
nmeSerial                       02:0000680E
nmi_rout                        02:00006C60
notRxInt                        02:000067FC
numBreakpoints                   E:00000008
op_ABCD                         02:00002690
op_ADD                          02:0000301E
op_ADDA                         02:000031F2
op_ADDQ                         02:00002A1E
op_ADDX                         02:0000328A
op_ADD_I                        02:0000171E
op_AND                          02:00002D3C
op_ANDI_TO_CCR                  02:000004CE
op_ANDI_TO_SR                   02:000004F4
op_BCC                          02:00002950
op_BCHG                         02:000008C4
op_BCLR                         02:00000C2C
op_BOOL_I                       02:0000134E
op_BSET                         02:00000F7A
op_BSR                          02:00001500
op_BTST                         02:0000051A
op_BTST0                        02:000006A4
op_BTST1                        02:000006B0
op_BTST10                       02:000006F8
op_BTST11                       02:00000700
op_BTST12                       02:00000706
op_BTST2                        02:000006B8
op_BTST20                       02:0000085E
op_BTST21                       02:00000868
op_BTST22                       02:0000086E
op_BTST23                       02:00000874
op_BTST24                       02:0000087A
op_BTST25                       02:00000880
op_BTST26                       02:00000886
op_BTST27                       02:0000088C
op_BTST28                       02:00000892
op_BTST29                       02:00000898
op_BTST3                        02:000006C0
op_BTST30                       02:0000089E
op_BTST31                       02:000008A4
op_BTST32                       02:000008A8
op_BTST4                        02:000006C8
op_BTST5                        02:000006D0
op_BTST6                        02:000006D8
op_BTST7                        02:000006E0
op_BTST8                        02:000006E8
op_BTST9                        02:000006F0
op_CHK                          02:00001FAA
op_CMP                          02:00002E9C
op_CMPA                         02:00002F12
op_CMPM                         02:00002F78
op_CMP_I                        02:00001536
op_DBCC                         02:000029D0
op_DIVS                         02:00002C00
op_DIVU                         02:00002BAE
op_EOR                          02:00002E26
op_EORI_TO_CCR                  02:00000482
op_EORI_TO_SR                   02:000004A8
op_EXG                          02:00003542
op_EXT                          02:00001E2A
op_LEAPEA                       02:00001E6C
op_LINKS                        02:00001F7C
op_MOVE                         02:00001A2A
op_MOVEM                        02:00002372
op_MOVEP                        02:000012C2
op_MOVEQ                        02:00002B92
op_MOVE_USP                     02:00001F9A
op_MOVE_xxx_FLAGS               02:00001C36
op_MULS                         02:000034F6
op_MULU                         02:000034AA
op_NBCD                         02:00002880
op_NEGS                         02:00001FE4
op_OR                           02:00002C52
op_ORI_TO_CCR                   02:0000043E
op_ORI_TO_SR                    02:00000460
op_ROXx                         02:000037E6
op_ROx                          02:000035B0
op_RTR                          02:0000292E
op_SBCD                         02:00002788
op_SCC                          02:000029F6
op_SHIFTS                       02:00003A1C
op_SHIFTS2                      02:00003C5E
op_SUB                          02:00003108
op_SUBA                         02:0000323E
op_SUBQ                         02:00002AD8
op_SUBX                         02:0000339A
op_SUB_I                        02:000018A4
op_SWAP                         02:00001E56
op_TAS                          02:00001F18
op_TRAPV                        02:00002912
op_TST                          02:00001F3E
pcssxa                          02:000064D0
ramtest                         02:00006368
ramtest0                        02:000063AA
ramtest1                        02:000063B2
ramtest2                        02:000063DE
ramtest3                        02:00006420
ramtest6                        02:000063CE
rbo                             02:0000663E
readyQ                           E:00100320
rmtst1                          02:000063C2
rmtst2                          02:000063F4
rmtst3                          02:000063FC
rmtst5                          02:00006382
rotate_iofocus                  02:0000532A
rtc_read                        02:00006874
rtc_write                       02:00006900
sGetChar                        02:00006606
select_focus1                   02:0000533C
select_iofocus                  02:00005318
semamem                          E:FD050000
sirq0001                        02:000067AC
sirqNxtByte                     02:0000679A
sirqRxFull                      02:000067FC
start                           02:00000000
start_other                     02:000000E2
tblPow2                         02:00005DB0
tcbs                             E:20010000
trap3                           02:00006988

Symbols by value:
FD000000 IO_BITMAP
FD03FF00 TEXTREG
FD050000 semamem
FD060000 ACIA
FD069000 I2C2
FD090000 PLIC
FD0FFC00 RST_REG
FD0FFD00 RAND_NUM
FD0FFD04 RAND_STRM
FD0FFD08 RAND_MZ
FD0FFD0C RAND_MW
FD0FFE00 KEYBD
FD0FFF00 leds
FDC00000 MMU
00000000 ACIA_TX
00000000 I2C_PREL
00000000 start
00000000 HAS_MMU
00000000 ACIA_RX
00000001 I2C_PREH
00000002 I2C_CTRL
00000002 SERIAL_SEMA
00000003 KEYBD_SEMA
00000003 I2C_TXR
00000003 CTRLC
00000003 I2C_RXR
00000004 ACIA_STAT
00000004 RAND_SEMA
00000004 TCBRegs
00000004 I2C_STAT
00000004 I2C_CMD
00000005 SCREEN_SEMA
00000006 MEMORY_SEMA
00000007 TCB_SEMA
00000008 ACIA_CMD
00000008 numBreakpoints
00000008 CTRLH
0000000A LF
0000000C ACIA_CTRL
0000000D CR
0000000D SC_TAB
00000011 SC_ALT
00000011 XON
00000012 SC_LSHIFT
00000013 XOFF
00000013 CTRLS
00000014 SC_CTRL
00000018 CTRLX
0000001A CTRLZ
00000020 TS_PREEMPT
00000044 TCBUSP
00000048 TCBSSP
0000004C TCBSR
00000050 BUFLEN
00000050 TCBPC
00000054 TCBStatus
00000055 TCBPriority
00000058 SC_CAPSLOCK
00000059 SC_RSHIFT
0000006C TCBStartTick
00000070 TCBEndTick
00000074 TCBTicks
00000077 SC_NUMLOCK
0000007C TCBNext
0000007E SC_SCROLLLOCK
00000080 TS_RUNNING
00000080 TCBPrev
000000CE loop2
000000D0 loop1
000000E0 SC_EXTEND
000000E2 start_other
000000F0 SC_KEYUP
000000FE do_nothing
00000100 TCB_SIZE
00000104 mmu_adrtbl
0000015C InitMMU
00000196 InitIOBitmap
000001DC RandInit
000001DC InitRand
00000226 RandGetNum
0000025A RandWait
00000270 InitSemaphores
00000296 LockSemaphore
000002B6 ForceUnlockSemaphore
000002D0 UnlockSemaphore
000002EA T15LockSemaphore
000002F6 T15UnlockSemaphore
00000302 Delay3s
00000310 dly3s2
00000312 dly3s1
00000326 Delay3s2
00000342 cpu_test
00000400 InstalledIRQ
00000424 ALL_DONE
00000426 BSR_FAR1
0000042E EXCEPTION_6
00000436 EXCEPTION_7
0000043E op_ORI_TO_CCR
00000460 op_ORI_TO_SR
00000482 op_EORI_TO_CCR
000004A8 op_EORI_TO_SR
000004CE op_ANDI_TO_CCR
000004F4 op_ANDI_TO_SR
0000051A op_BTST
000006A4 op_BTST0
000006B0 op_BTST1
000006B8 op_BTST2
000006C0 op_BTST3
000006C8 op_BTST4
000006D0 op_BTST5
000006D8 op_BTST6
000006E0 op_BTST7
000006E8 op_BTST8
000006F0 op_BTST9
000006F8 op_BTST10
00000700 op_BTST11
00000706 op_BTST12
0000085E op_BTST20
00000868 op_BTST21
0000086E op_BTST22
00000874 op_BTST23
0000087A op_BTST24
00000880 op_BTST25
00000886 op_BTST26
0000088C op_BTST27
00000892 op_BTST28
00000898 op_BTST29
0000089E op_BTST30
000008A4 op_BTST31
000008A8 op_BTST32
000008C4 op_BCHG
00000C2C op_BCLR
00000F7A op_BSET
00000FFF MAX_TID
00001000 NR_TCB
000012C2 op_MOVEP
0000134E op_BOOL_I
000014F8 BSR_CLOSE1
00001500 op_BSR
0000152E BSR_CLOSE2
00001536 op_CMP_I
0000171E op_ADD_I
000018A4 op_SUB_I
00001A2A op_MOVE
00001AF6 MOVE2
00001B72 MOVE1
00001BF2 MOVE3
00001C36 op_MOVE_xxx_FLAGS
00001D4C MOVE4
00001E2A op_EXT
00001E56 op_SWAP
00001E6C op_LEAPEA
00001F04 LEA1
00001F18 op_TAS
00001F3E op_TST
00001F7C op_LINKS
00001F9A op_MOVE_USP
00001FAA op_CHK
00001FE4 op_NEGS
00002372 op_MOVEM
00002690 op_ABCD
000026B0 ABCD_OUTER1
000026B2 ABCD_INNER1
000026CE ABCD_NO_C1
000026D6 ABCD_NO_C2
0000271E ABCD_OUTER2
00002720 ABCD_INNER2
0000273C ABCD_NO_C3
00002744 ABCD_NO_C4
00002788 op_SBCD
000027A8 SBCD_OUTER1
000027AA SBCD_INNER1
000027C6 SBCD_NO_C1
000027CE SBCD_NO_C2
00002816 SBCD_OUTER2
00002818 SBCD_INNER2
00002834 SBCD_NO_C3
0000283C SBCD_NO_C4
00002880 op_NBCD
00002898 NBCD_LOOP
000028A4 NBCD_NO_C
000028A8 NBCD_NO_Z
000028DE NBCD_LOOP1
000028F2 NBCD_NO_C1
000028F6 NBCD_NO_Z1
00002912 op_TRAPV
0000292E op_RTR
0000293A RTR_DONE
00002948 BSR_FAR2
00002950 op_BCC
00002958 BCC1
00002962 BCC2
0000296A BCC3
00002974 BCC4
0000297C BCC5
00002986 BCC6
0000298E BCC7
00002998 BCC8
000029A0 BCC9
000029AA BCC10
000029B2 BCC11
000029BC BCC12
000029C4 BCC13
000029CE BCC14
000029D0 op_DBCC
000029D8 DBCC_LOOP1
000029E6 DBCC_LOOP2
000029F6 op_SCC
00002A1E op_ADDQ
00002A32 ADDQ_LOOP1
00002A70 ADDQ_LOOP2
00002AA6 ADDQ_LOOP3
00002AD8 op_SUBQ
00002AF0 SUBQ_LOOP1
00002B2A SUBQ_LOOP2
00002B60 SUBQ_LOOP3
00002B92 op_MOVEQ
00002BAE op_DIVU
00002BCA DIVU_OUTER1
00002C00 op_DIVS
00002C1C DIVS_OUTER1
00002C52 op_OR
00002C72 OR_OUTER1
00002CE6 OR_OUTER2
00002D3C op_AND
00002D5C AND_OUTER1
00002DD0 AND_OUTER2
00002E26 op_EOR
00002E46 EOR_OUTER2
00002E9C op_CMP
00002EBC CMP_OUTER1
00002F12 op_CMPA
00002F32 CMPA_OUTER1
00002F78 op_CMPM
00002FC0 CMPM_LOOP1
00002FDA CMPM_LOOP2
00002FF4 CMPM_LOOP3
0000301E op_ADD
0000303E ADD_OUTER1
000030B2 ADD_OUTER2
00003108 op_SUB
00003128 SUB_OUTER1
0000319C SUB_OUTER2
000031F2 op_ADDA
00003218 ADDA_OUTER1
0000323E op_SUBA
00003264 SUBA_OUTER1
0000328A op_ADDX
000032AA ADDX_OUTER1
0000333E ADDX_LOOP3
0000335A ADDX_LOOP4
00003376 ADDX_LOOP5
0000339A op_SUBX
000033BA SUBX_OUTER1
0000344E SUBX_LOOP3
0000346A SUBX_LOOP4
00003486 SUBX_LOOP5
000034AA op_MULU
000034C6 MULU_OUTER1
000034F6 op_MULS
00003512 MULS_OUTER1
00003542 op_EXG
000035A4 ROx_FLAGS
000035B0 op_ROx
000035BA ROx_LOOP1
000035DA ROx_LOOP2
000035FA ROx_LOOP3
0000361A ROx_LOOP4
0000363A ROx_LOOP5
0000365C ROx_LOOP6
000037DA ROXx_FLAGS
000037E6 op_ROXx
000037F0 ROXx_LOOP1
00003810 ROXx_LOOP2
00003830 ROXx_LOOP3
00003850 ROXx_LOOP4
00003870 ROXx_LOOP5
00003892 ROXx_LOOP6
00003A10 SHIFTS_FLAGS
00003A1C op_SHIFTS
00003A26 SHIFTS_LOOP1
00003A46 SHIFTS_LOOP2
00003A66 SHIFTS_LOOP3
00003A86 SHIFTS_LOOP4
00003AA6 SHIFTS_LOOP5
00003AC8 SHIFTS_LOOP6
00003C52 SHIFTS2_FLAGS
00003C5E op_SHIFTS2
00003C68 SHIFTS2_LOOP1
00003C84 SHIFTS2_LOOP2
00003CA0 SHIFTS2_LOOP3
00003CBC SHIFTS2_LOOP4
00003CD8 SHIFTS2_LOOP5
00003CF6 SHIFTS2_LOOP6
00003E7C START
00003E7E GOWARM
00003E80 GOOUT
00003E84 GOIN
00003E88 GOAUXO
00003E8C GOAUXI
00003E90 GOBYE
00003E94 TXTBGN
00003E98 ENDMEM
00003E9C CSTART
00003EE0 WSTART
00003F00 ST3
00003F4E ST4
00003F88 TAB1
00003FB4 TAB2
00003FEC TAB4
00003FFB TAB5
00003FFE TAB6
00004003 TAB8
0000400E TAB1_1
0000403A TAB2_1
00004076 TAB4_1
0000408A TAB5_1
00004092 TAB6_1
0000409A TAB8_1
000040B6 DIRECT
000040BE EXEC
000040C6 EXLP
000040D0 EXNGO
000040E8 EX1
000040EE EXMAT
000040F4 EXGO
000040FA INCON
00004108 INCOM
00004116 IOCOM
00004120 OUTCOM
0000412E IOCON
00004138 OUTCON
00004146 NEW
00004152 STOP
0000415A RUN
00004168 RUNNXL
0000417E RUNTSL
00004188 RUNSML
00004198 GOTO
000041AC LIST
000041B8 LS1
000041CC LS2
000041D2 LS3
000041D8 PRINT
000041E8 PR2
000041F6 PR0
00004204 PR1
00004214 PR4
0000421A PR3
00004226 PR6
0000422C PR8
0000423C FINISH
00004244 GOSUB
00004270 RETURN
00004292 FOR
000042AC FR1
000042C2 FR2
000042C8 FR3
000042CA FR4
000042D0 FR5
000042E2 FR6
000042E6 FR7
00004300 FR8
00004304 NEXT
0000430E NX0
00004320 NX3
0000433A NX1
0000434E NX2
00004356 REM
00004358 IF
0000435C IF1
00004362 IF2
00004372 INPERR
00004380 INPUT
00004392 IP2
000043AC IP3
000043E0 IP4
000043EA IP5
000043EE DEFLT
000043F4 LET
00004400 LT1
00004404 LOAD
00004410 LOD1
0000442A LOD2
0000443A LODEND
00004444 GBYTE
00004448 GBYTE1
00004456 GBYTE2
00004464 SAVE
0000446C SAVE1
00004490 SAVE2
0000449E SAVEND
000044C2 PBYTE
000044C4 PBYTE1
000044D8 PBYTE2
000044E2 POKE
000044F6 PKER
000044FA CALL
0000450E EXPR
0000451E XP11
00004524 XP12
0000452A XP13
00004530 XP14
00004536 XP15
0000453C XP15RT
0000453E XP16
00004544 XP16RT
00004546 XPRT0
0000454A XPRT1
0000454E XP17
00004552 XP18
00004562 EXPR2
0000456C XP21
00004572 XP22
00004574 XP23
0000457E XP24
00004588 XP25
0000458E XP26
00004596 EXPR3
00004598 XP31
000045AA XP34
000045BE EXPR4
000045CA XP40
000045D4 EXP4RT
000045D6 XP41
000045E0 PARN
000045F0 XP42
000045F2 XP43
000045F6 TSTV
0000462C TV1
00004642 TSTVRT
00004644 MULT32
0000464E MLT1
00004654 MLT2
00004668 MLT3
00004684 MLTRET
00004686 DIV32
00004698 DIV1
0000469E DIV2
000046A4 DIV3
000046B2 DIV4
000046C0 DIVRT
000046C2 PEEK
000046CE RND
000046EE RA1
00004702 ABS
00004710 ABSRT
00004712 SIZE
0000471C SETVAL
00004734 SV1
00004736 FIN
00004742 FI1
0000474E FI2
00004750 ENDCHK
00004760 ENDCHK1
00004762 QWHAT
00004764 AWHAT
00004768 ERROR
000047A2 QSORRY
000047A4 ASORRY
000047AA QHOW
000047AC AHOW
000047B2 GETLN
000047C2 GL1
000047E0 GL2
000047F4 GL3
00004818 GL4
00004824 GL5
00004840 GL6
00004848 GL7
00004850 FNDLN
0000485E FNDLNP
00004874 FNDRET
00004876 FNDNXT
00004878 FNDSKP
00004886 MVUP
0000488E MVRET
00004890 MVDOWN
00004898 POPA
000048BA PP1
000048BC PUSHA
000048DE PU1
000048E2 PRTSTG
000048E4 PS1
000048FC PRTRET
000048FE QTSTG
00004908 QT1
00004918 QT2
0000491C QT3
00004928 QT4
0000493A QT5
0000493C PRTNUM
0000494C PN1
0000495C PNOV
00004976 TOASCII
00004986 PN3
00004992 PN4
0000499E PN5
000049AC PNRET
000049B0 PRTLN
000049CA TSTC
000049DC TC1
000049E2 TSTNUM
000049E8 TN1
00004A16 TSNMRET
00004A18 IGNBLK
00004A1E IGB1
00004A22 IGBRET
00004A24 TOUPBUF
00004A2A TOUPB1
00004A4A TOUPBRT
00004A4C DOQUO
00004A54 DOQUO1
00004A5C TOUPPER
00004A6C TOUPRET
00004A6E CHKIO
00004A7E CHKRET
00004A80 PRMESG
00004A8A PRMRET
00004A8C OUTC
00004A98 OUTC1
00004AA8 INC
00004AB4 INC1
00004AC8 AUXOUT
00004AD8 AUXIN
00004AF6 AXIRET
00004AF8 BYEBYE
00004AFC INITMSG
00004B22 OKMSG
00004B29 HOWMSG
00004B30 WHTMSG
00004B38 SRYMSG
00004B3E CLMSG
00004B42 RANPNT
00004B42 LSTROM
00004B46 INPPTR
00004B4A OUTPTR
00004B4E CURRNT
00004B52 STKGOS
00004B56 STKINP
00004B5A LOPVAR
00004B5E LOPINC
00004B62 LOPLMT
00004B66 LOPLN
00004B6A LOPPT
00004B6E TXTUNF
00004B72 VARBGN
00004B76 STKLMT
00004B7A BUFFER
00004BCA FemtikiInit
00004BCA TXT
00004C00 FemtikiInitIRQ
00004C0E OSCallTable
00004C10 CallOS
00004C7A GetRunningTCBPointer
00004C98 TCBHandleToPointer
00004CB0 PointerToTCBHandle
00004CC0 SelectThreadToRun
00004CE6 InsertIntoReadyQueue
00004D36 RemoveFromReadyQueue
00004D4C StartQ
00004D54 PopReadyQueue
00004DD2 UpdateIRQLive
00004DF4 FemtikiTimerIRQ
00004E64 get_screen_color
00004E90 get_screen_address
00004E98 clear_screen
00004ECE loop3
00004EE8 CRLF
00004EFA UpdateTextPos
00004F24 CalcScreenLoc
00004F32 DisplayChar
00004F50 dcx14
00004F54 dcx7
00004F5A dccr
00004F78 dcx6
00004F8E dcx8
00004FA4 dcx9
00004FC2 dcx10
00004FDA dcx12
00004FE4 dcx11
0000502A dclf
0000502E dcx16
00005032 dcx4
0000503C doBackspace
0000504A doDelete
00005086 doCtrlX
000050AA IncCursorPos
000050CA IncCursorRow
000050FC icc1
000050FE ScrollUp
00005148 BlankLastLine
000051AC DisplayString
000051B0 dspj1
000051BC dsret
000051C2 DisplayStringCRLF
000051C8 DisplayStringLimited
000051E8 DisplayStringLimitedCRLF
000051EE HomeCursor
00005200 SyncCursor
0000522A TRAP15
00005240 T15DispatchTable
000052E0 Cursor1
00005316 StubRout
00005318 select_iofocus
0000532A rotate_iofocus
0000533C select_focus1
00005356 init_plic
0000538C KeybdGetID
000053BE kgid1
000053C6 kgnotKbd
000053CA KeybdSetLED
000053F6 KeybdInit
000053F6 _KeybdInit
0000541E kbdi0002
0000547C kbdiTryAgain
0000548A kbdi0004
000054A4 kbdi0005
000054A8 ledxit
000054BE kbdiXmitBusy
000054CC msgBadKeybd
000054DB msgXmitBusy
000054F6 _KeybdGetStatus
00005500 _KeybdGetScancode
00005510 KeybdRecvByte
00005530 KeybdWaitTx
00005556 SetKeyboardEcho
0000555E CheckForKey
0000556A GetKey
000055A2 CheckForCtrlC
000055AE KeybdGetCharNoWait
000055B6 KeybdGetCharWait
000055BE KeybdGetChar
000057D6 KeybdSetLEDStatus
00005826 KeybdSendByte
0000582E Wait10ms
0000584A Wait300ms
00005866 KeybdIRQ
000058F8 _unshiftedScanCodes
000059F8 _shiftedScanCodes
00005AF8 _keybdControlCodes
00005B78 _keybdExtendedCodes
00005BF8 cmdString
00005C24 cmdTable
00005C4E FromScreen
00005C58 StartMon
00005C62 Monitor
00005C62 cmdMonitor
00005C7E PromptLn
00005C8A Prompt3
00005CA0 Prompt1
00005CB2 cmdDispatch
00005CF8 cmdBreakpoint
00005D1C cmdTinyBasic
00005D20 cmdTestCPU
00005D30 cmdClearScreen
00005D3C cmdCore
00005D60 cmdClock
00005D7E cmdReset
00005DB0 tblPow2
00005DD0 cmdHelp
00005DD0 DisplayHelp
00005DDC HelpMsg
00005F30 msgUnknownCmd
00005F40 msgHello
00005F52 GetCmdLine
00005FF6 cmdSendSerial
00006026 cmdReceiveSerial
0000605A cmdFillB
0000607E cmdFillW
000060A2 cmdFillL
000060C6 ignBlanks
000060D8 cmdEditMemory
000060E0 edtmem1
00006138 ExecuteCode
00006138 cmdJump
00006146 cmdDumpMemory
00006166 DumpMem1
00006178 DisplayMem
00006188 dspmem1
000061D4 cmdDumpRegs
00006254 msg_regs
00006258 msg_reglist
0000627E cmdTestSerialReceive
0000629E GetHexNumber
000062CA AsciiToHexNybble
000062DC gthx5
000062EE gthx6
00006300 gthx3
00006304 DisplayTwoSpaces
0000630E dspspc1
00006316 DisplaySpace
0000631E DisplayTetra
00006324 DisplayWyde
0000632A DisplayByte
00006330 DisplayNybble
0000634A DisplayAddr
00006368 cmdTestRAM
00006368 ramtest
00006382 rmtst5
000063AA ramtest0
000063B2 ramtest1
000063C2 rmtst1
000063CE ramtest6
000063DE ramtest2
000063F4 rmtst2
000063FC rmtst3
00006420 ramtest3
00006422 cmdLoadS19
00006428 NextRec
0000643A ProcessRec
000064D0 pcssxa
0000653C ProcessS1
00006540 ProcessS2
00006544 ProcessS3
00006548 ProcessS7
00006558 ProcessS8
00006568 ProcessS9
00006578 S19Get16BitAddress
00006586 S19Get24BitAddress
00006592 S19Get32BitAddress
000065B0 S1932a
000065C4 S1932b
00006606 sGetChar
00006632 AudioInputTest
00006634 BouncingBalls
00006636 GraphicsDemo
00006638 ClearScreen
0000663E rbo
00006646 SerialInit
00006678 SerialGetChar
000066F0 SerialPeekChar
00006728 SerialPeekCharDirect
00006742 SerialPutChar
0000675E SerialRbo
00006766 SerialRcvCount
00006786 SerialIRQ
0000679A sirqNxtByte
000067AC sirq0001
000067FC notRxInt
000067FC sirqRxFull
0000680E nmeSerial
00006816 i2c_setup
00006816 init_i2c
00006826 i2c_wait_tip
00006836 i2c_wr_cmd
00006846 i2c_xmit1
00006864 i2c_wait_rx_nack
00006874 rtc_read
00006900 rtc_write
0000696A msgRtcReadFail
00006984 bus_err
00006988 trap3
000069C6 ProcessBreakpoint
000069CC DisarmAllBreakpoints
000069F8 ArmAllBreakpoints
00006A28 ArmBreakpoint
00006AA6 DisarmBreakpoint
00006AFA ListBreakpoints
00006B1A ClearBreakpointList
00006B2C SendMsg
00006B6A ReceiveMsg
00006BAC DispatchMsg
00006BAE InitIRQ
00006BC2 InstallIRQ
00006BF2 TickIRQ
00006C38 irq3_rout
00006C42 irq6_rout
00006C4A irq_rout
00006C5E SpuriousIRQ
00006C60 nmi_rout
00006C72 brdisp_trap
00006CAA illegal_trap
00006CC0 io_irq
00006CD4 msg_start
00006CFB msg_core_start
00006D0C msg_illegal
00006D1E msg_bad_branch_disp
00006D30 msg_test_done
00006D40 msg_io_access
00040000 CursorRow
00040001 CursorCol
00040002 TextPos
00040002 TextCurpos
00040004 TextScr
00040008 S19StartAddress
0004000C KeybdEcho
0004000D KeybdWaitFlag
00040040 CmdBuf
00040080 CmdBufEnd
00040084 fgColor
00040088 bkColor
0004008C TextRows
0004008D TextCols
00040100 Regsave
00040202 NumSetBreakpoints
00040220 Breakpoints
00040280 BreakpointWords
00040BFC TimerStack
00100000 IOFocus
00100004 memend
0010000E KeybdLEDs
0010000F _KeyState1
00100010 _KeyState2
00100011 _KeybdHead
00100012 _KeybdTail
00100013 _KeybdCnt
00100016 KeybdID
00100020 _KeybdBuf
00100150 S19Checksum
00100160 SerTailRcv
00100162 SerHeadRcv
00100164 SerRcvXon
00100165 SerRcvXoff
00100200 RTCBuf
00100224 RunningTCB
0010031C QueueCycle
00100320 readyQ
00101000 SerRcvBuf
20010000 tcbs

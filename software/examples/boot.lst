Sections:
00: "DATA" (0-218)
01: "seg500" (500-500)
02: "CODE" (0-7EF4)


Source: "boot.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;-------------------------------------------------------------------------------
                            	    37: ;
                            	    38: ; system memory map
                            	    39: ;
                            	    40: ;
                            	    41: ; 00000000 +----------------+      <+
                            	    42: ;          | startup sp,pc  | 8 B   |
                            	    43: ; 00000008 +----------------+       |
                            	    44: ;					 |    vectors     | pair shared+
                            	    45: ; 00000400 +----------------+       |
                            	    46: ;					 |   bios mem     |       |
                            	    47: ; 00001000 +----------------+       |
                            	    48: ;					 |   bios code    |       |
                            	    49: ; 00020000 +----------------+      <+
                            	    50: ;					 |    unused      |
                            	    51: ; 00040000 +----------------+
                            	    52: ;					 |   local ram    |
                            	    53: ; 00042000 +----------------+
                            	    54: ;					 |    unused      |
                            	    55: ; 00100000 +----------------+
                            	    56: ;					 |   global ram   |
                            	    57: ; 00101000 +----------------+
                            	    58: ;					 | serial rcvbuf  |
                            	    59: ; 00102000 +----------------+
                            	    60: ;					 |    unused      |
                            	    61: ; 40000000 +----------------+
                            	    62: ;          |                |
                            	    63: ;          |                |
                            	    64: ;          |                |
                            	    65: ;          :  dram memory   : 1GB MB
                            	    66: ;          |                |
                            	    67: ;          |                |
                            	    68: ;          |                |
                            	    69: ; 80000000 +----------------+
                            	    70: ;          |                |
                            	    71: ;          :     unused     :
                            	    72: ;          |                |
                            	    73: ; FD000000 +----------------+
                            	    74: ;          |                |
                            	    75: ;          :    I/O area    : 1.0 M
                            	    76: ;          |                |
                            	    77: ; FFE00000 +----------------+
                            	    78: ;          |                |
                            	    79: ;          :     unused     :
                            	    80: ;          |                |
                            	    81: ; FFFFFFFF +----------------+
                            	    82: ;
                            	    83: ;-------------------------------------------------------------------------------
                            	    84: ;
                            	    85: HAS_MMU equ 0
                            	    86: 
                            	    87: CTRLC	EQU		$03
                            	    88: CTRLH	EQU		$08
                            	    89: CTRLS	EQU		$13
                            	    90: CTRLX	EQU		$18
                            	    91: CTRLZ	EQU		$1A
                            	    92: LF		EQU		$0A
                            	    93: CR		EQU		$0D
                            	    94: XON		EQU		$11
                            	    95: XOFF	EQU		$13
                            	    96: 
                            	    97: SC_F12  EQU    $07
                            	    98: SC_C    EQU    $21
                            	    99: SC_T    EQU    $2C
                            	   100: SC_Z    EQU    $1A
                            	   101: SC_KEYUP	EQU		$F0
                            	   102: SC_EXTEND   EQU		$E0
                            	   103: SC_CTRL		EQU		$14
                            	   104: SC_RSHIFT	EQU		$59
                            	   105: SC_NUMLOCK	EQU		$77
                            	   106: SC_SCROLLLOCK	EQU	$7E
                            	   107: SC_CAPSLOCK		EQU	$58
                            	   108: SC_ALT		EQU		$11
                            	   109: SC_LSHIFT	EQU		$12
                            	   110: SC_DEL		EQU		$71		; extend
                            	   111: SC_LCTRL	EQU		$58
                            	   112: SC_TAB      EQU		$0D
                            	   113: 
                            	   114: 	if HAS_MMU
                            	   115: TEXTREG		EQU	$1E3FF00	; virtual addresses
                            	   116: txtscreen	EQU	$1E00000
                            	   117: semamem		EQU	$1E50000
                            	   118: ACIA			EQU	$1E60000
                            	   119: ACIA_RX		EQU	0
                            	   120: ACIA_TX		EQU	0
                            	   121: ACIA_STAT	EQU	4
                            	   122: ACIA_CMD	EQU	8
                            	   123: ACIA_CTRL	EQU	12
                            	   124: I2C2 			equ $01E69000
                            	   125: I2C_PREL 	equ 0
                            	   126: I2C_PREH 	equ 1
                            	   127: I2C_CTRL 	equ 2
                            	   128: I2C_RXR 	equ 3
                            	   129: I2C_TXR 	equ 3
                            	   130: I2C_CMD 	equ 4
                            	   131: I2C_STAT 	equ 4
                            	   132: PLIC			EQU	$1E90000
                            	   133: MMU				EQU $FDC00000	; physical address
                            	   134: leds			EQU	$1EFFF00	; virtual addresses
                            	   135: keybd			EQU	$1EFFE00
                            	   136: KEYBD			EQU	$1EFFE00
                            	   137: RAND			EQU	$1EFFD00
                            	   138: RAND_NUM	EQU	$1EFFD00
                            	   139: RAND_STRM	EQU	$1EFFD04
                            	   140: RAND_MZ		EQU $1EFFD08
                            	   141: RAND_MW		EQU	$1EFFD0C
                            	   142: RST_REG		EQU	$1EFFC00
                            	   143: IO_BITMAP	EQU $1F00000
                            	   144: 	else
                            	   145: TEXTREG		EQU	$FD080000
                            	   146: txtscreen	EQU	$FD000000
                            	   147: semamem		EQU	$FD050000
                            	   148: ACIA			EQU	$FD060000
                            	   149: ACIA_RX		EQU	0
                            	   150: ACIA_TX		EQU	0
                            	   151: ACIA_STAT	EQU	4
                            	   152: ACIA_CMD	EQU	8
                            	   153: ACIA_CTRL	EQU	12
                            	   154: I2C2 			equ $FD069000
                            	   155: I2C_PREL 	equ 0
                            	   156: I2C_PREH 	equ 1
                            	   157: I2C_CTRL 	equ 2
                            	   158: I2C_RXR 	equ 3
                            	   159: I2C_TXR 	equ 3
                            	   160: I2C_CMD 	equ 4
                            	   161: I2C_STAT 	equ 4
                            	   162: PLIC			EQU	$FD090000
                            	   163: MMU				EQU $FDC00000	; physical address
                            	   164: leds			EQU	$FD0FFF00	; virtual addresses
                            	   165: keybd			EQU	$FD0FFE00
                            	   166: KEYBD			EQU	$FD0FFE00
                            	   167: RAND			EQU	$FD0FFD00
                            	   168: RAND_NUM	EQU	$FD0FFD00
                            	   169: RAND_STRM	EQU	$FD0FFD04
                            	   170: RAND_MZ		EQU $FD0FFD08
                            	   171: RAND_MW		EQU	$FD0FFD0C
                            	   172: RST_REG		EQU	$FD0FFC00
                            	   173: IO_BITMAP	EQU $FD100000
                            	   174: 	endif
                            	   175: 
                            	   176: SERIAL_SEMA	EQU	2
                            	   177: KEYBD_SEMA	EQU	3
                            	   178: RAND_SEMA		EQU	4
                            	   179: SCREEN_SEMA	EQU	5
                            	   180: MEMORY_SEMA EQU 6
                            	   181: TCB_SEMA 		EQU	7
                            	   182: FMTK_SEMA		EQU	8
                            	   183: 
                            	   184: 	data
00:00000000 00040FFC        	   185: 	dc.l		$00040FFC
00:00000004 00000000        	   186: 	dc.l		start
00:00000008 00007A20        	   187: 	dc.l		bus_err
00:0000000C 00007DC0        	   188: 	dc.l		addr_err
00:00000010 00007E0E        	   189: 	dc.l		illegal_trap		* ILLEGAL instruction
00:00000014 00000000        	   190: 	dc.l		0
00:00000018 000002DA        	   191: 	dc.l		chk_exception		; CHK
00:0000001C 00000422        	   192: 	dc.l		EXCEPTION_7			* TRAPV
00:00000020 00000000        	   193: 	dc.l		0
00:00000024 00000000        	   194: 	dc.l		0
                            	   195: 	
                            	   196: 	; 10
00:00000028 00000000        	   197: 	dc.l		0
00:0000002C 00000000        	   198: 	dc.l		0
00:00000030 00000000        	   199: 	dc.l		0
00:00000034 00000000        	   200: 	dc.l		0
00:00000038 00000000        	   201: 	dc.l		0
00:0000003C 00000000        	   202: 	dc.l		0
00:00000040 00000000        	   203: 	dc.l		0
00:00000044 00000000        	   204: 	dc.l		0
00:00000048 00000000        	   205: 	dc.l		0
00:0000004C 00000000        	   206: 	dc.l		0
                            	   207: 	
                            	   208: 	; 20
00:00000050 00000000        	   209: 	dc.l		0
00:00000054 00000000        	   210: 	dc.l		0
00:00000058 00000000        	   211: 	dc.l		0
00:0000005C 00000000        	   212: 	dc.l		0
00:00000060 00007DAC        	   213: 	dc.l		SpuriousIRQ
00:00000064 00000000        	   214: 	dc.l		0
00:00000068 00000000        	   215: 	dc.l		0
00:0000006C 00007D86        	   216: 	dc.l		irq3_rout
00:00000070 00000000        	   217: 	dc.l		0
00:00000074 00000000        	   218: 	dc.l		0
                            	   219: 	
                            	   220: 	; 30
00:00000078 00007D34        	   221: 	dc.l		TickIRQ						; IRQ 30 - timer / keyboard
00:0000007C 00007DAE        	   222: 	dc.l		nmi_rout
00:00000080 00000000        	   223: 	dc.l		0
00:00000084 00000000        	   224: 	dc.l		0
00:00000088 00000000        	   225: 	dc.l		0
00:0000008C 00007A24        	   226: 	dc.l		trap3							; breakpoint
00:00000090 00000000        	   227: 	dc.l		0
00:00000094 00000000        	   228: 	dc.l		0
00:00000098 00000000        	   229: 	dc.l		0
00:0000009C 00000000        	   230: 	dc.l		0
                            	   231: 
                            	   232: 	; 40
00:000000A0 00000000        	   233: 	dc.l		0
00:000000A4 00000000        	   234: 	dc.l		0
00:000000A8 00000000        	   235: 	dc.l		0
00:000000AC 00000000        	   236: 	dc.l		0
00:000000B0 00000000        	   237: 	dc.l		0
00:000000B4 00000000        	   238: 	dc.l		0
00:000000B8 00000000        	   239: 	dc.l		0
00:000000BC 00005BDA        	   240: 	dc.l		TRAP15
00:000000C0 00000000        	   241: 	dc.l		0
00:000000C4 00000000        	   242: 	dc.l		0
                            	   243: 
                            	   244: 	; 50	
00:000000C8 00000000        	   245: 	dc.l		0
00:000000CC 00000000        	   246: 	dc.l		0
00:000000D0 00000000        	   247: 	dc.l		0
00:000000D4 00000000        	   248: 	dc.l		0
00:000000D8 00000000        	   249: 	dc.l		0
00:000000DC 00000000        	   250: 	dc.l		0
00:000000E0 00000000        	   251: 	dc.l		0
00:000000E4 00000000        	   252: 	dc.l		0
00:000000E8 00000000        	   253: 	dc.l		0
00:000000EC 00007E24        	   254: 	dc.l		io_irq
                            	   255: 
                            	   256: 	; 60
00:000000F0 00006280        	   257: 	dc.l		KeybdIRQ
00:000000F4 00007822        	   258: 	dc.l		SerialIRQ
00:000000F8 00000000        	   259: 	dc.l		0
00:000000FC 00007DD6        	   260: 	dc.l		brdisp_trap
00:00000100 00000000        	   261: 	dc.l		0
00:00000104 00000000        	   262: 	dc.l		0
00:00000108 00000000        	   263: 	dc.l		0
00:0000010C 00000000        	   264: 	dc.l		0
00:00000110 00000000        	   265: 	dc.l		0
00:00000114 00000000        	   266: 	dc.l		0
                            	   267: 
                            	   268: 	org			$400
                            	   269: 
                            	   270: InstalledIRQ:
00:00000400 00000000        	   271: 	dc.l		0
00:00000404 00000000        	   272: 	dc.l		0
00:00000408 00000000        	   273: 	dc.l		0
00:0000040C 00000000        	   274: 	dc.l		0
00:00000410 00000000        	   275: 	dc.l		0
00:00000414 00000000        	   276: 	dc.l		0
00:00000418 00000000        	   277: 	dc.l		0
00:0000041C 00000000        	   278: 	dc.l		0
                            	   279: 
00:00000420 00000000        	   280: 	dc.l		0
00:00000424 00000000        	   281: 	dc.l		0
00:00000428 00000000        	   282: 	dc.l		0
00:0000042C 00000000        	   283: 	dc.l		0
00:00000430 00000000        	   284: 	dc.l		0
00:00000434 00000000        	   285: 	dc.l		0
00:00000438 00000000        	   286: 	dc.l		0
00:0000043C 00000000        	   287: 	dc.l		0
                            	   288: 
00:00000440 00000000        	   289: 	dc.l		0
00:00000444 00000000        	   290: 	dc.l		0
00:00000448 00000000        	   291: 	dc.l		0
00:0000044C 00000000        	   292: 	dc.l		0
00:00000450 00000000        	   293: 	dc.l		0
00:00000454 00000000        	   294: 	dc.l		0
00:00000458 00000000        	   295: 	dc.l		0
00:0000045C 00000000        	   296: 	dc.l		0
                            	   297: 
00:00000460 00000000        	   298: 	dc.l		0
00:00000464 00000000        	   299: 	dc.l		0
00:00000468 00000000        	   300: 	dc.l		0
00:0000046C 00000000        	   301: 	dc.l		0
00:00000470 00000000        	   302: 	dc.l		0
00:00000474 00000000        	   303: 	dc.l		0
00:00000478 00000000        	   304: 	dc.l		0
00:0000047C 00000000        	   305: 	dc.l		0
                            	   306: 
00:00000480 00000000        	   307: 	dc.l		0
00:00000484 00000000        	   308: 	dc.l		0
00:00000488 00000000        	   309: 	dc.l		0
00:0000048C 00000000        	   310: 	dc.l		0
00:00000490 00000000        	   311: 	dc.l		0
00:00000494 00000000        	   312: 	dc.l		0
00:00000498 00000000        	   313: 	dc.l		0
00:0000049C 00000000        	   314: 	dc.l		0
                            	   315: 
00:000004A0 00000000        	   316: 	dc.l		0
00:000004A4 00000000        	   317: 	dc.l		0
00:000004A8 00000000        	   318: 	dc.l		0
00:000004AC 00000000        	   319: 	dc.l		0
00:000004B0 00000000        	   320: 	dc.l		0
00:000004B4 00000000        	   321: 	dc.l		0
00:000004B8 00000000        	   322: 	dc.l		0
00:000004BC 00000000        	   323: 	dc.l		0
                            	   324: 
00:000004C0 00000000        	   325: 	dc.l		0
00:000004C4 00000000        	   326: 	dc.l		0
00:000004C8 00000000        	   327: 	dc.l		0
00:000004CC 00000000        	   328: 	dc.l		0
00:000004D0 00000000        	   329: 	dc.l		0
00:000004D4 00000000        	   330: 	dc.l		0
00:000004D8 00000000        	   331: 	dc.l		0
00:000004DC 00000000        	   332: 	dc.l		0
                            	   333: 
00:000004E0 00000000        	   334: 	dc.l		0
00:000004E4 00000000        	   335: 	dc.l		0
00:000004E8 00000000        	   336: 	dc.l		0
00:000004EC 00000000        	   337: 	dc.l		0
00:000004F0 00000000        	   338: 	dc.l		0
00:000004F4 00000000        	   339: 	dc.l		0
00:000004F8 00000000        	   340: 	dc.l		0
00:000004FC 00000000        	   341: 	dc.l		0
                            	   342: 
                            	   343: 	org			$500
                            	   344: 
                            	   345: ;-------------------------------------------------------------------------------
                            	   346: ;-------------------------------------------------------------------------------
                            	   347: 
                            	   348: ; BIOS variables which must be local (not shared) to each core
                            	   349: 
                            	   350: CursorRow	equ		$40000
                            	   351: CursorCol	equ		$40001
                            	   352: TextPos		equ		$40002
                            	   353: TextCurpos	equ	$40002
                            	   354: TextScr			equ	$40004
                            	   355: S19StartAddress	equ	$40008
                            	   356: KeybdEcho		equ	$4000C
                            	   357: KeybdWaitFlag	equ	$4000D
                            	   358: CmdBuf			equ $40040
                            	   359: CmdBufEnd		equ	$40080
                            	   360: fgColor			equ	$40084
                            	   361: bkColor			equ	$40088
                            	   362: TextRows		equ	$4008C
                            	   363: TextCols		equ	$4008D
                            	   364: _fpTextIncr	equ $40094
                            	   365: _canary			equ $40098
                            	   366: IRQFlag			equ $400A0
                            	   367: InputDevice	equ $400A4
                            	   368: OutputDevice	equ $400A8
                            	   369: Regsave			equ	$40100
                            	   370: numBreakpoints	equ		8
                            	   371: BreakpointFlag	equ		$40200
                            	   372: NumSetBreakpoints	equ	$40202	; to $40203
                            	   373: Breakpoints			equ		$40220	; to $40240
                            	   374: BreakpointWords	equ		$40280	; to $402A0
                            	   375: fpBuf       equ $402C0
                            	   376: ;RunningTCB  equ $40300
                            	   377: _exp equ $40500
                            	   378: _digit equ $40504
                            	   379: _width equ $40508
                            	   380: _E equ $4050C
                            	   381: _digits_before_decpt equ $40510
                            	   382: _precision equ $40514
                            	   383: _fpBuf equ $40520	; to $40560
                            	   384: _fpWork equ $40600
                            	   385: TimerStack	equ	$40BFC
                            	   386: 
                            	   387: ; Keyboard buffer is in shared memory
                            	   388: IOFocus			EQU	$00100000
                            	   389: memend			equ $00100004
                            	   390: KeybdLEDs		equ	$0010000E
                            	   391: _KeyState1	equ	$0010000F
                            	   392: _KeyState2	equ	$00100010
                            	   393: _KeybdHead	equ	$00100011
                            	   394: _KeybdTail	equ	$00100012
                            	   395: _KeybdCnt		equ	$00100013
                            	   396: KeybdID			equ	$00100016
                            	   397: _KeybdBuf		equ	$00100020
                            	   398: S19Checksum	equ	$00100150
                            	   399: SerTailRcv	equ	$00100160
                            	   400: SerHeadRcv	equ	$00100162
                            	   401: SerRcvXon		equ	$00100164
                            	   402: SerRcvXoff	equ	$00100165
                            	   403: SerRcvBuf		equ	$00101000
                            	   404: RTCBuf			equ $00100200	; to $0010023F
                            	   405: 
                            	   406: 	code
                            	   407: 	align		2
                            	   408: start:
                            	   409: ;	fadd (a0)+,fp2
02:00000000 46FC2700        	   410: 	move.w #$2700,sr					; enable level 6 and higher interrupts
02:00000004 7000            	   411: 	moveq #0,d0								; set address space zero
02:00000006 4E7B0003        	   412: 	movec d0,asid
                            	   413: 	; Setup circuit select signals
02:0000000A 203CFDC00000    	   414: 	move.l #MMU,d0
02:00000010 4E7B0014        	   415: 	movec d0,mmus
                            	   416: 	if HAS_MMU
                            	   417: 		move.l #$01F00000,d0			; set virtual address for iop bitmap
                            	   418: 		movec d0,iops
                            	   419: 		move.l #$01E00000,d0			; set virtual address for io block
                            	   420: 		movec d0,ios
                            	   421: 	else
02:00000014 203CFD100000    	   422: 		move.l #$FD100000,d0			; set virtual address for iop bitmap
02:0000001A 4E7B0016        	   423: 		movec d0,iops
02:0000001E 203CFD000000    	   424: 		move.l #$FD000000,d0			; set virtual address for io block
02:00000024 4E7B0015        	   425: 		movec d0,ios
                            	   426: 	endif
02:00000028 4E7A0FE0        	   427: 	movec coreno,d0							; set initial value of thread register
02:0000002C 4840            	   428: 	swap d0											; coreno in high eight bits
02:0000002E E188            	   429: 	lsl.l #8,d0
02:00000030 4E7B0012        	   430: 	movec d0,tr
                            	   431: 	; Prepare local variable storage
02:00000034 303C03FF        	   432: 	move.w #1023,d0						; 1024 longs to clear
02:00000038 41F900040000    	   433: 	lea	$40000,a0							; non shared local memory address
                            	   434: .0111:
02:0000003E 4298            	   435: 	clr.l	(a0)+								; clear the memory area
02:00000040 51C8FFFC        	   436: 	dbra d0,.0111
02:00000044 13FC0001000400A8	   437: 	move.b #1,OutputDevice		; select stdout
02:0000004C 23FC001FFFFF0004	   438: 	move.l #$1fffff,fgColor		; set foreground / background color
02:00000054 0084
02:00000056 23FC0000003F0004	   439: 	move.l #$00003f,bkColor
02:0000005E 0088
02:00000060 4E7A0FE0        	   440: 	movec.l	coreno,d0					; get core number (2 to 9)
02:00000064 5500            	   441: 	subi.b #2,d0							; adjust (0 to 7)
02:00000066 C0FC4000        	   442: 	mulu #16384,d0						; compute screen location
                            	   443: 	if HAS_MMU
                            	   444: 		addi.l #$01E00000,d0
                            	   445: 	else
02:0000006A 0680FD000000    	   446: 		addi.l #$FD000000,d0
                            	   447: 	endif
02:00000070 23C000040004    	   448: 	move.l d0,TextScr
02:00000076 13FC00400004008D	   449: 	move.b #64,TextCols				; set rows and columns
02:0000007E 13FC00200004008C	   450: 	move.b #32,TextRows
02:00000086 4E7A0FE0        	   451: 	movec.l	coreno,d0					; get core number
02:0000008A 0C000002        	   452: 	cmpi.b #2,d0
02:0000008E 6678            	   453: 	bne	start_other
02:00000090 13C000100000    	   454: 	move.b d0,IOFocus					; Set the IO focus in global memory
                            	   455: 	if HAS_MMU
                            	   456: 		bsr InitMMU							; Can't access anything till this is done'
                            	   457: 	endif
02:00000096 610000A4        	   458: 	bsr	InitIOPBitmap					; not going to get far without this
02:0000009A 61000196        	   459: 	bsr	InitSemaphores
02:0000009E 610000EC        	   460: 	bsr	InitRand
02:000000A2 61000128        	   461: 	bsr RandGetNum
02:000000A6 0281FFFFFF00    	   462: 	andi.l #$FFFFFF00,d1
02:000000AC 23C100040098    	   463: 	move.l d1,_canary
02:000000B2 4E7B1020        	   464: 	movec d1,canary
02:000000B6 61000236        	   465: 	bsr	Delay3s						; give devices time to reset
02:000000BA 6100578A        	   466: 	bsr	clear_screen
                            	   467: 
02:000000BE 61005D00        	   468: 	bsr	_KeybdInit
                            	   469: ;	bsr	InitIRQ
02:000000C2 6100761E        	   470: 	bsr	SerialInit
                            	   471: ;	bsr init_i2c
                            	   472: ;	bsr rtc_read
                            	   473: 
                            	   474: 	; Write startup message to screen
                            	   475: 
02:000000C6 43FA7D70        	   476: 	lea	msg_start,a1
02:000000CA 61005A86        	   477: 	bsr	DisplayString
                            	   478: ;	bsr	FemtikiInit
02:000000CE 4E7A0FE0        	   479: 	movec	coreno,d0
02:000000D2 4840            	   480: 	swap d0
02:000000D4 7201            	   481: 	moveq	#1,d1
02:000000D6 610001BC        	   482: 	bsr	UnlockSemaphore	; allow another cpu access
02:000000DA 7200            	   483: 	moveq	#0,d1
02:000000DC 610001B6        	   484: 	bsr	UnlockSemaphore	; allow other cpus to proceed
02:000000E0 33FCA4A4FD0FFF00	   485: 	move.w #$A4A4,leds			; diagnostics
02:000000E8 61005C36        	   486: 	bsr	init_plic				; initialize platform level interrupt controller
02:000000EC 600065C8        	   487: 	bra	StartMon
02:000000F0 6100023C        	   488: 	bsr	cpu_test
                            	   489: ;	lea	brdisp_trap,a0	; set brdisp trap vector
                            	   490: ;	move.l	a0,64*4
                            	   491: 
                            	   492: loop2:
02:000000F4 70FF            	   493: 	move.l	#-1,d0
                            	   494: loop1:
02:000000F6 2200            	   495: 	move.l	d0,d1
02:000000F8 E089            	   496: 	lsr.l		#8,d1
02:000000FA E089            	   497: 	lsr.l		#8,d1
02:000000FC 13C1FD0FFF00    	   498: 	move.b	d1,leds
02:00000102 51C8FFF2        	   499: 	dbra		d0,loop1
02:00000106 60EC            	   500: 	bra			loop2
                            	   501: 
                            	   502: start_other:
02:00000108 61000208        	   503: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
02:0000010C 61000204        	   504: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
02:00000110 61000200        	   505: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
02:00000114 61005730        	   506: 	bsr			clear_screen
02:00000118 4E7A1FE0        	   507: 	movec		coreno,d1
02:0000011C 610072A2        	   508: 	bsr			DisplayByte
02:00000120 43FA7D3D        	   509: 	lea			msg_core_start,a1
02:00000124 61005A2C        	   510: 	bsr			DisplayString
                            	   511: ;	bsr			FemtikiInitIRQ
                            	   512: do_nothing:	
02:00000128 6000658C        	   513: 	bra			StartMon
02:0000012C 60FA            	   514: 	bra			do_nothing
                            	   515: 
                            	   516: ;------------------------------------------------------------------------------
                            	   517: ; Initialize the MMU to allow thread #0 access to IO
                            	   518: ;------------------------------------------------------------------------------
                            	   519: 	if HAS_MMU
                            	   520: 	align 2
                            	   521: mmu_adrtbl:	; virtual address[24:16], physical address[31:16] bytes reversed!
                            	   522: 	dc.l	$0010,$10000300	; global scratch pad
                            	   523: 	dc.l	$01E0,$00FD0300	
                            	   524: 	dc.l	$01E1,$01FD0300
                            	   525: 	dc.l	$01E2,$02FD0300
                            	   526: 	dc.l  $01E3,$03FD0300
                            	   527: 	dc.l	$01E5,$05FD0300
                            	   528: 	dc.l	$01E6,$06FD0300
                            	   529: 	dc.l	$01E9,$09FD0300
                            	   530: 	dc.l	$01EF,$0FFD0300
                            	   531: 	dc.l	$01F0,$10FD0300
                            	   532: 	dc.l  $01FF,$FFFF0300	; all ones output for IRQ ack needed
                            	   533: 
                            	   534: 	even
                            	   535: InitMMU:
                            	   536: 	lea MMU+8,a0				; first 128kB is local RAM
                            	   537: 	move.l #$32000,d2		; map all pages to DRAM
                            	   538: 	move.l #510,d0			; then override for IO later
                            	   539: .0002
                            	   540: 	move.l d2,d1
                            	   541: 	bsr rbo
                            	   542: 	move.l d1,(a0)+
                            	   543: 	addi.w #1,d2				; increment DRAM page number
                            	   544: 	dbra d0,.0002
                            	   545: 	lea MMU,a0					; now program IO access
                            	   546: 	lea mmu_adrtbl,a1
                            	   547: 	moveq #10,d0
                            	   548: .0001
                            	   549: 	move.l (a1)+,d2
                            	   550: 	lsl.l #2,d2
                            	   551: 	move.l (a1)+,(a0,d2.w)
                            	   552: 	dbra d0,.0001
                            	   553: 	rts	
                            	   554: 	endif
                            	   555: 
                            	   556: ;------------------------------------------------------------------------------
                            	   557: ;------------------------------------------------------------------------------
                            	   558: 
                            	   559: ;------------------------------------------------------------------------------
                            	   560: ;------------------------------------------------------------------------------
                            	   561: 
                            	   562: GlobalReadLong:
02:0000012E 2210            	   563: 		move.l (a0),d1
02:00000130 4E75            	   564: 		rts
02:00000132 6004            	   565: 		bra nd1
                            	   566: GlobalWriteLong:
02:00000134 2081            	   567: 		move.l d1,(a0)
02:00000136 4E75            	   568: 		rts
                            	   569: net_delay:
                            	   570: 		bra nd1
                            	   571: nd1	bra nd2
                            	   572: nd2 bra nd3
                            	   573: nd3 bra nd4
02:00000138 4E71            	   574: nd4	nop
02:0000013A 4E75            	   575: 		rts
                            	   576: 	
                            	   577: 
                            	   578: ;------------------------------------------------------------------------------
                            	   579: ; The IO bitmap needs to be initialized to allow access to IO.
                            	   580: ;------------------------------------------------------------------------------
                            	   581: 
                            	   582: InitIOPBitmap:
02:0000013C 7600            	   583: 	moveq #0,d3				; d3 = asid value
02:0000013E 303C003F        	   584: 	move.w #63,d0			; 64 bitmaps to setup
02:00000142 4E7A8016        	   585: 	movec iops,a0			; a0 = IOP bitmap address
02:00000146 2248            	   586: 	movea.l a0,a1			; a1 = table address
                            	   587: .0004
02:00000148 4A03            	   588: 	tst.b d3
02:0000014A 57C1            	   589: 	seq d1						; set entire bitmap for asid 0, otherwise clear entire bitmap
02:0000014C 4881            	   590: 	ext.w	d1					; make into a long value
02:0000014E 48C1            	   591: 	ext.l d1
02:00000150 383C007F        	   592: 	move.w #127,d4
                            	   593: .0001
02:00000154 22C1            	   594: 	move.l d1,(a1)+		; set or clear entire table
02:00000156 51CCFFFC        	   595: 	dbra d4,.0001
02:0000015A 72FF            	   596: 	moveq #-1,d1
02:0000015C 214100A0        	   597: 	move.l d1,160(a0)	; all cores have access to semaphores
02:00000160 214100A4        	   598: 	move.l d1,164(a0)
02:00000164 214100A8        	   599: 	move.l d1,168(a0)
02:00000168 214100AC        	   600: 	move.l d1,172(a0)
02:0000016C 217C0000000201FC	   601: 	move.l #2,508(a0)	; all cores access random # generator
02:00000174 4840            	   602: 	swap d0
02:00000176 303C001F        	   603: 	move.w #31,d0			; 32 long words for the screen area per bitmap
                            	   604: .0003
02:0000017A 20C1            	   605: 	move.l d1,(a0)+		; all cores have access to a screen
02:0000017C 51C8FFFC        	   606: 	dbra d0,.0003
02:00000180 4840            	   607: 	swap d0
02:00000182 5203            	   608: 	addi.b #1,d3			; do next address space
02:00000184 2049            	   609: 	movea.l a1,a0			; a0 points to area for next address space
02:00000186 51C8FFC0        	   610: 	dbra d0,.0004
02:0000018A 4E75            	   611: 	rts	
                            	   612: 	
                            	   613: ;------------------------------------------------------------------------------
                            	   614: ; RandInit
                            	   615: ; 	Initialize random number generator.
                            	   616: ;
                            	   617: ; Modifies:
                            	   618: ;		none
                            	   619: ; Parameters:
                            	   620: ;		none
                            	   621: ;	Returns:
                            	   622: ;		none
                            	   623: ;------------------------------------------------------------------------------
                            	   624: 
                            	   625: InitRand:
                            	   626: RandInit:
02:0000018C 48E7C000        	   627: 	movem.l	d0/d1,-(a7)
02:00000190 7025            	   628: 	moveq #37,d0								; lock semaphore
02:00000192 7204            	   629: 	moveq	#RAND_SEMA,d1
02:00000194 4E4F            	   630: 	trap #15
02:00000196 4E7A0FE0        	   631: 	movec coreno,d0							; d0 = core number
02:0000019A ED88            	   632: 	lsl.l	#6,d0									; allow 64 streams per core
02:0000019C 23C0FD0FFD04    	   633: 	move.l d0,RAND_STRM					; select the stream
02:000001A2 23FC12345678FD0F	   634: 	move.l #$12345678,RAND_MZ		; initialize to some value
02:000001AA FD08
02:000001AC 23FC98765432FD0F	   635: 	move.l #$98765432,RAND_MW
02:000001B4 FD0C
02:000001B6 23FC2E5BF271FD0F	   636: 	move.l #777777777,RAND_NUM	; generate first number
02:000001BE FD00
02:000001C0 7026            	   637: 	moveq #38,d0								; unlock semaphore
02:000001C2 7204            	   638: 	moveq	#RAND_SEMA,d1
02:000001C4 4E4F            	   639: 	trap #15
02:000001C6 4CDF0003        	   640: 	movem.l	(a7)+,d0/d1
02:000001CA 4E75            	   641: 	rts
                            	   642: 
                            	   643: ;------------------------------------------------------------------------------
                            	   644: ; Returns
                            	   645: ;		d1 = random integer
                            	   646: ;------------------------------------------------------------------------------
                            	   647: 
                            	   648: RandGetNum:
02:000001CC 48E7A000        	   649: 	movem.l	d0/d2,-(a7)
02:000001D0 7204            	   650: 	moveq #RAND_SEMA,d1
02:000001D2 610000DC        	   651: 	bsr T15LockSemaphore
02:000001D6 4E7A0FE0        	   652: 	movec	coreno,d0
02:000001DA ED88            	   653: 	lsl.l	#6,d0
02:000001DC 23C0FD0FFD04    	   654: 	move.l d0,RAND_STRM					; select the stream
02:000001E2 2439FD0FFD00    	   655: 	move.l RAND_NUM,d2					; d2 = random number
02:000001E8 42B9FD0FFD00    	   656: 	clr.l	RAND_NUM							; generate next number
02:000001EE 610000C6        	   657: 	bsr T15UnlockSemaphore
02:000001F2 2202            	   658: 	move.l d2,d1
02:000001F4 4CDF0005        	   659: 	movem.l	(a7)+,d0/d2
02:000001F8 4E75            	   660: 	rts
                            	   661: 
                            	   662: ;------------------------------------------------------------------------------
                            	   663: ; Modifies:
                            	   664: ;		none
                            	   665: ; Returns
                            	   666: ;		fp0 = random float between 0 and 1.
                            	   667: ;------------------------------------------------------------------------------
                            	   668: 
                            	   669: _GetRand:
02:000001FA 2F01            	   670: 	move.l d1,-(sp)
02:000001FC F2276880        	   671: 	fmove.x fp1,-(sp)
02:00000200 61CA            	   672: 	bsr RandGetNum
02:00000202 E289            	   673: 	lsr.l #1,d1									; make number between 0 and 2^31
02:00000204 F2014000        	   674: 	fmove.l d1,fp0
02:00000208 F23C40807FFFFFFF	   675: 	fmove.l #$7FFFFFFF,fp1			; divide by 2^31
02:00000210 F2000420        	   676: 	fdiv fp1,fp0
02:00000214 F21F4880        	   677: 	fmove.x (sp)+,fp1
02:00000218 221F            	   678: 	move.l (sp)+,d1
02:0000021A 4E75            	   679: 	rts
                            	   680: 
                            	   681: ;------------------------------------------------------------------------------
                            	   682: ; RandWait
                            	   683: ;    Wait some random number of clock cycles before returning.
                            	   684: ;------------------------------------------------------------------------------
                            	   685: 
                            	   686: RandWait:
02:0000021C 48E7C000        	   687: 	movem.l	d0/d1,-(a7)
02:00000220 61AA            	   688: 	bsr			RandGetNum
02:00000222 0241000F        	   689: 	andi.w	#15,d1
                            	   690: .0001:
02:00000226 4E71            	   691: 	nop
02:00000228 51C9FFFC        	   692: 	dbra		d1,.0001
02:0000022C 4CDF0003        	   693: 	movem.l	(a7)+,d0/d1
02:00000230 4E75            	   694: 	rts
                            	   695: 
                            	   696: ;------------------------------------------------------------------------------
                            	   697: ; Initialize semaphores
                            	   698: ; - all semaphores are set to unlocked except the first one, which is locked
                            	   699: ; for core #2.
                            	   700: ;
                            	   701: ; Parameters:
                            	   702: ;		<none>
                            	   703: ; Modifies:
                            	   704: ;		<none>
                            	   705: ; Returns:
                            	   706: ;		<none>
                            	   707: ;------------------------------------------------------------------------------
                            	   708: 
                            	   709: InitSemaphores:
02:00000232 48E74080        	   710: 	movem.l	d1/a0,-(a7)
02:00000236 41F9FD050000    	   711: 	lea			semamem,a0
02:0000023C 217C000200002000	   712: 	move.l	#$20000,$2000(a0)	; lock the first semaphore for core #2, thread #0
02:00000244 323C00FE        	   713: 	move.w	#254,d1
                            	   714: .0001:
02:00000248 5888            	   715: 	lea			4(a0),a0
02:0000024A 42A82000        	   716: 	clr.l		$2000(a0)					; write zeros to unlock
02:0000024E 51C9FFF8        	   717: 	dbra		d1,.0001
02:00000252 4CDF0102        	   718: 	movem.l	(a7)+,d1/a0
02:00000256 4E75            	   719: 	rts
                            	   720: 
                            	   721: ; -----------------------------------------------------------------------------
                            	   722: ; Parameters:
                            	   723: ;		d1 semaphore number
                            	   724: ;
                            	   725: ; Side Effects:
                            	   726: ;		increments semaphore, saturates at 255
                            	   727: ;
                            	   728: ; Returns:	
                            	   729: ; 	z flag set if semaphore was zero
                            	   730: ; -----------------------------------------------------------------------------
                            	   731: 
                            	   732: ;IncrementSemaphore:
                            	   733: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   734: ;	lea			semamem,a0			; point to semaphore memory
                            	   735: ;	ext.w		d1							; make d1 word value
                            	   736: ;	asl.w		#4,d1						; align to memory
                            	   737: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   738: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   739: ;	rts
                            	   740: 	
                            	   741: ; -----------------------------------------------------------------------------
                            	   742: ; Parameters:
                            	   743: ;		d1 semaphore number
                            	   744: ;
                            	   745: ; Side Effects:
                            	   746: ;		decrements semaphore, saturates at zero
                            	   747: ;
                            	   748: ; Returns:	
                            	   749: ; 	z flag set if semaphore was zero
                            	   750: ; -----------------------------------------------------------------------------
                            	   751: 
                            	   752: ;DecrementSemaphore:
                            	   753: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   754: ;	lea			semamem,a0			; point to semaphore memory
                            	   755: ;	andi.w	#255,d1					; make d1 word value
                            	   756: ;	asl.w		#4,d1						; align to memory
                            	   757: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   758: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   759: ;	rts
                            	   760: 
                            	   761: ; -----------------------------------------------------------------------------
                            	   762: ; Lock a semaphore
                            	   763: ;
                            	   764: ; Parameters:
                            	   765: ;		d0 = key
                            	   766: ;		d1 = semaphore number
                            	   767: ; -----------------------------------------------------------------------------
                            	   768: 
                            	   769: LockSemaphore:
02:00000258 4E75            	   770: 	rts
02:0000025A 48E74080        	   771: 	movem.l	d1/a0,-(a7)			; save registers
02:0000025E 41F9FD050000    	   772: 	lea			semamem,a0			; point to semaphore memory lock area
02:00000264 024100FF        	   773: 	andi.w	#255,d1					; make d1 word value
02:00000268 E549            	   774: 	lsl.w		#2,d1						; align to memory
                            	   775: .0001
02:0000026A 21801000        	   776: 	move.l	d0,(a0,d1.w)		; try and write the semaphore
02:0000026E B0B01000        	   777: 	cmp.l		(a0,d1.w),d0		; did it lock?
02:00000272 66F6            	   778: 	bne.s		.0001						; no, try again
02:00000274 4CDF0102        	   779: 	movem.l	(a7)+,a0/d1			; restore regs
02:00000278 4E75            	   780: 	rts
                            	   781: 	
                            	   782: ; -----------------------------------------------------------------------------
                            	   783: ; Unlocks a semaphore even if not the owner.
                            	   784: ;
                            	   785: ; Parameters:
                            	   786: ;		d1 semaphore number
                            	   787: ; -----------------------------------------------------------------------------
                            	   788: 
                            	   789: ForceUnlockSemaphore:
02:0000027A 48E74080        	   790: 	movem.l	d1/a0,-(a7)				; save registers
02:0000027E 41F9FD053000    	   791: 	lea			semamem+$3000,a0	; point to semaphore memory read/write area
02:00000284 024100FF        	   792: 	andi.w	#255,d1						; make d1 word value
02:00000288 E549            	   793: 	lsl.w		#2,d1							; align to memory
02:0000028A 42B01000        	   794: 	clr.l		(a0,d1.w)					; write zero to unlock
02:0000028E 4CDF0102        	   795: 	movem.l	(a7)+,a0/d1				; restore regs
02:00000292 4E75            	   796: 	rts
                            	   797: 
                            	   798: ; -----------------------------------------------------------------------------
                            	   799: ; Unlocks a semaphore. Must be the owner to have effect.
                            	   800: ; Three cases:
                            	   801: ;	1) the owner, the semaphore will be reset to zero
                            	   802: ;	2) not the owner, the write will be ignored
                            	   803: ; 3) already unlocked, the write will be ignored
                            	   804: ;
                            	   805: ; Parameters:
                            	   806: ;		d0 = key
                            	   807: ;		d1 = semaphore number
                            	   808: ; -----------------------------------------------------------------------------
                            	   809: 
                            	   810: UnlockSemaphore:
02:00000294 60E4            	   811: 	bra ForceUnlockSemaphore
02:00000296 48E74080        	   812: 	movem.l	d1/a0,-(a7)				; save registers
02:0000029A 41F9FD051000    	   813: 	lea			semamem+$1000,a0	; point to semaphore memory unlock area
02:000002A0 024100FF        	   814: 	andi.w	#255,d1						; make d1 word value
02:000002A4 E549            	   815: 	lsl.w		#2,d1							; align to memory
02:000002A6 21801000        	   816: 	move.l	d0,(a0,d1.w)			; write matching value to unlock
02:000002AA 4CDF0102        	   817: 	movem.l	(a7)+,a0/d1				; restore regs
02:000002AE 4E75            	   818: 	rts
                            	   819: 
                            	   820: ; -----------------------------------------------------------------------------
                            	   821: ; Parameters:
                            	   822: ;		d1 = semaphore to lock / unlock
                            	   823: ; -----------------------------------------------------------------------------
                            	   824: 
                            	   825: T15LockSemaphore:	
02:000002B0 4E7A0012        	   826: 	movec tr,d0
02:000002B4 60A2            	   827: 	bra LockSemaphore
                            	   828: 
                            	   829: T15UnlockSemaphore:
02:000002B6 4E7A0012        	   830: 	movec tr,d0
02:000002BA 60D8            	   831: 	bra UnlockSemaphore
                            	   832: 
                            	   833: T15GetFloat:
02:000002BC 2049            	   834: 	move.l a1,a0
02:000002BE 2001            	   835: 	move.l d1,d0
02:000002C0 61007026        	   836: 	bsr _GetFloat
02:000002C4 2248            	   837: 	move.l a0,a1
02:000002C6 2200            	   838: 	move.l d0,d1
02:000002C8 4E75            	   839: 	rts
                            	   840: 
                            	   841: T15Abort:
02:000002CA 610070F4        	   842: 	bsr DisplayByte
02:000002CE 43FA7C0A        	   843: 	lea msgStackCanary,a1
02:000002D2 61005894        	   844: 	bsr DisplayStringCRLF
02:000002D6 600063E8        	   845: 	bra Monitor
                            	   846: 
                            	   847: chk_exception:
02:000002DA 222F0002        	   848: 	move.l 2(sp),d1
02:000002DE 610070D4        	   849: 	bsr DisplayTetra
02:000002E2 43FA7BE8        	   850: 	lea msgChk,a1
02:000002E6 61005880        	   851: 	bsr DisplayStringCRLF
02:000002EA 600063D4        	   852: 	bra Monitor
                            	   853: 
                            	   854: ; -----------------------------------------------------------------------------
                            	   855: ; Delay for a few seconds to allow some I/O reset operations to take place.
                            	   856: ; -----------------------------------------------------------------------------
                            	   857: 
                            	   858: Delay3s:
02:000002EE 203C002DC6C0    	   859: 	move.l	#3000000,d0		; this should take a few seconds to loop
02:000002F4 41F9FD0FFF00    	   860: 	lea			leds,a0				; a0 = address of LED output register
02:000002FA 6002            	   861: 	bra			dly3s1				; branch to the loop
                            	   862: dly3s2:	
02:000002FC 4840            	   863: 	swap		d0						; loop is larger than 16-bits
                            	   864: dly3s1:
02:000002FE 2200            	   865: 	move.l	d0,d1					; the counter cycles fast, so use upper bits for display
02:00000300 E199            	   866: 	rol.l		#8,d1					; could use swap here, but lets test rol
02:00000302 E199            	   867: 	rol.l		#8,d1
02:00000304 1081            	   868: 	move.b	d1,(a0)				; set the LEDs
02:00000306 51C8FFF6        	   869: 	dbra		d0,dly3s1			; decrement and branch back
02:0000030A 4840            	   870: 	swap		d0
02:0000030C 51C8FFEE        	   871: 	dbra		d0,dly3s2
02:00000310 4E75            	   872: 	rts
                            	   873: 
                            	   874: Delay3s2:
02:00000312 4E7A0FE0        	   875: 	movec		coreno,d0			; vary delay by core to stagger startup
02:00000316 E188            	   876: 	lsl.l		#8,d0
02:00000318 0680002DC6C0    	   877: 	addi.l	#3000000,d0		; this should take a few seconds to loop
02:0000031E 6002            	   878: 	bra			.0001					; branch to the loop
                            	   879: .0002	
02:00000320 4840            	   880: 	swap		d0						; loop is larger than 16-bits
                            	   881: .0001
02:00000322 51C8FFFE        	   882: 	dbra		d0,.0001			; decrement and branch back
02:00000326 4840            	   883: 	swap		d0
02:00000328 51C8FFF6        	   884: 	dbra		d0,.0002
02:0000032C 4E75            	   885: 	rts
                            	   886: 
                            	   887: 	include "cputest.asm"

Source: "cputest.asm"
                            	     1: ** @name cputest.s Tests 68000 cpu
                            	     2: *
                            	     3: * Based on https://github.com/MicroCoreLabs/Projects/blob/master/MCL68/MC68000_Test_Code/MC68000_test_all_opcodes.X68
                            	     4: *
                            	     5: * Converted into a CD-i system ROM image by CD-i Fan:
                            	     6: * - comment lines must start in first column
                            	     7: * - replaced org instructions by suitable rept
                            	     8: * - copy vectors to low memory at startup
                            	     9: * - replaced jsr/jmp by bsr/bra for position independence
                            	    10: * - replaced move.l by moveq whenever possible
                            	    11: * - converted branches to short form whenever possible (e.g. beq => beq.s)
                            	    12: * - added immediate suffix to opcodes where required (e.g. and => andi)
                            	    13: * The last three modifications are required to make the test work;
                            	    14: * apparently the original assembler was somewhat smarter then
                            	    15: * the Microware OS-9 assembler and did this automatically.
                            	    16: *
                            	    17: * In some cases the opcodes of the test are used as test data!
                            	    18: *
                            	    19: * Original file header follows.
                            	    20: *
                            	    21: *  File Name   :  MCL68 Opcode Tests
                            	    22: *  Used on     :
                            	    23: *  Author      :  Ted Fried, MicroCore Labs
                            	    24: *  Creation    :  7/14/2020
                            	    25: *
                            	    26: *   Description:
                            	    27: *   ============
                            	    28: *
                            	    29: *  Program to test all of the Motorola 68000's opcodes.
                            	    30: *
                            	    31: *  If failures are detected, the code will immediately loop on itself.
                            	    32: *  All addressing modes, data sizes, and opcode combinations are tested.
                            	    33: *
                            	    34: *  This code was developed using the Easy68K simulator where all tests passed!
                            	    35: *
                            	    36: *------------------------------------------------------------------------
                            	    37: *
                            	    38: * Modification History:
                            	    39: * =====================
                            	    40: *
                            	    41: * Revision 1 7/14/2020
                            	    42: * Initial revision
                            	    43: *
                            	    44: *
                            	    45: *------------------------------------------------------------------------
                            	    46: *
                            	    47: * Copyright (c) 2020 Ted Fried
                            	    48: *
                            	    49: * Permission is hereby granted, free of charge, to any person obtaining a copy
                            	    50: * of this software and associated documentation files (the "Software"), to deal
                            	    51: * in the Software without restriction, including without limitation the rights
                            	    52: * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                            	    53: * copies of the Software, and to permit persons to whom the Software is
                            	    54: * furnished to do so, subject to the following conditions:
                            	    55: *
                            	    56: * The above copyright notice and this permission notice shall be included in all
                            	    57: * copies or substantial portions of the Software.
                            	    58: *
                            	    59: * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            	    60: * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            	    61: * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            	    62: * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            	    63: * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                            	    64: * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                            	    65: * SOFTWARE.
                            	    66: 
                            	    67: * Modified for rf68000 project (c) 2022 Robert Finch
                            	    68: 
                            	    69: *	data
                            	    70: *	dc.l		$0001FFFC						; top of local ram area
                            	    71: *	dc.l		start
                            	    72: 
                            	    73: *    org $1000												; code starts at $400 in local ram
                            	    74: *start:
                            	    75: *	move.l	$FFFFFFE0,d0		; get core number
                            	    76: *	cmpi.b	#2,d0
                            	    77: *	bne			do_nothing
                            	    78: 
                            	    79: *	lea			EXCEPTION_6,a0	* check exception vector
                            	    80: *	move.l	a0,6*4
                            	    81: *	lea			EXCEPTION_7,a0	* TRAPV exception vector
                            	    82: *	move.l	a0,7*4
                            	    83: 
                            	    84: cpu_test:
02:0000032E 610000FA        	    85: 	bsr	op_ORI_TO_CCR
02:00000332 61000118        	    86: 	bsr	op_ORI_TO_SR
02:00000336 61000136        	    87: 	bsr	op_EORI_TO_CCR
02:0000033A 61000158        	    88: 	bsr	op_EORI_TO_SR
02:0000033E 6100017A        	    89: 	bsr	op_ANDI_TO_CCR
02:00000342 6100019C        	    90: 	bsr	op_ANDI_TO_SR
02:00000346 610001BE        	    91: 	bsr	op_BTST
02:0000034A 61000564        	    92: 	bsr	op_BCHG
02:0000034E 610008C8        	    93: 	bsr	op_BCLR
02:00000352 61000C12        	    94: 	bsr	op_BSET
02:00000356 61000F56        	    95: 	bsr op_MOVEP
02:0000035A 61000FDE        	    96: 	bsr op_BOOL_I
02:0000035E 610011C2        	    97: 	bsr op_CMP_I
02:00000362 610013A6        	    98: 	bsr op_ADD_I
02:00000366 61001528        	    99: 	bsr op_SUB_I
02:0000036A 610016AA        	   100: 	bsr op_MOVE
02:0000036E 610018B2        	   101: 	bsr op_MOVE_xxx_FLAGS
02:00000372 61001AA2        	   102: 	bsr op_EXT
02:00000376 61001ACA        	   103: 	bsr op_SWAP
02:0000037A 61001ADC        	   104: 	bsr op_LEAPEA
02:0000037E 61001B84        	   105: 	bsr op_TAS
02:00000382 61001BA6        	   106: 	bsr op_TST
02:00000386 61001BE0        	   107: 	bsr op_LINKS
02:0000038A 61001BFA        	   108: 	bsr op_MOVE_USP
02:0000038E 61001C06        	   109: 	bsr op_CHK
02:00000392 61001C3C        	   110: 	bsr op_NEGS
02:00000396 61001FC6        	   111: 	bsr op_MOVEM
                            	   112: *	bsr op_ABCD
                            	   113: *	bsr op_SBCD
                            	   114: *	bsr op_NBCD
02:0000039A 61002562        	   115: 	bsr op_TRAPV
02:0000039E 6100257A        	   116: 	bsr op_RTR
02:000003A2 61001148        	   117: 	bsr op_BSR
02:000003A6 61002594        	   118: 	bsr op_BCC
02:000003AA 61002610        	   119: 	bsr op_DBCC
02:000003AE 61002632        	   120: 	bsr op_SCC
02:000003B2 6100265E        	   121: 	bsr op_ADDQ
02:000003B6 61002714        	   122: 	bsr op_SUBQ
02:000003BA 610027CA        	   123: 	bsr op_MOVEQ
02:000003BE 610027E2        	   124: 	bsr op_DIVU
                            	   125: *	bsr op_DIVS
02:000003C2 61002882        	   126: 	bsr op_OR
02:000003C6 61002968        	   127: 	bsr op_AND
02:000003CA 61002A4E        	   128: 	bsr op_EOR
02:000003CE 61002AC0        	   129: 	bsr op_CMP
02:000003D2 61002B32        	   130: 	bsr op_CMPA
02:000003D6 61002B94        	   131: 	bsr op_CMPM
02:000003DA 61002C36        	   132: 	bsr op_ADD
02:000003DE 61002D1C        	   133: 	bsr op_SUB
02:000003E2 61002E02        	   134: 	bsr op_ADDA
02:000003E6 61002E4A        	   135: 	bsr op_SUBA
02:000003EA 61002E92        	   136: 	bsr op_ADDX	
02:000003EE 61002F9E        	   137: 	bsr op_SUBX
02:000003F2 610030AA        	   138: 	bsr op_MULU
02:000003F6 610030F2        	   139: 	bsr op_MULS
02:000003FA 6100313A        	   140: 	bsr op_EXG
02:000003FE 610031A4        	   141: 	bsr op_ROx
02:00000402 610033D6        	   142: 	bsr op_ROXx
02:00000406 61003608        	   143: 	bsr op_SHIFTS
02:0000040A 61003846        	   144: 	bsr op_SHIFTS2
                            	   145: 
02:0000040E 4E75            	   146: 	rts
                            	   147: 	bra ALL_DONE
                            	   148: 
                            	   149: * Loop here when all tests pass
                            	   150: *
                            	   151: 
02:00000410 60FE            	   152: ALL_DONE: bra.s ALL_DONE
                            	   153: 
02:00000412 263C33333333    	   154: BSR_FAR1:       move.l #$33333333,d3
02:00000418 4E75            	   155:                 rts
                            	   156: 
                            	   157: ;	moveq		#-1,d0
                            	   158: ;	move.l	d0,$FD0FFF00
                            	   159: ;do_nothing:
                            	   160: ;	bra			*		
                            	   161: 
                            	   162: 
                            	   163: * Exception Vector = 6   CHK Instruction
                            	   164: *
                            	   165: *	align	4
                            	   166: EXCEPTION_6:
02:0000041A 2C3CEEEE0006    	   167: 	move.l #$EEEE0006,d6      * Set d6 to the exception vector
02:00000420 4E73            	   168: 	rte
                            	   169: 
                            	   170: * Exception Vector = 7   TRAPV Instruction
                            	   171: *
                            	   172: *	align	4
                            	   173: EXCEPTION_7:
02:00000422 203C12345678    	   174: 	move.l #$12345678,d0      * Set d6 to the exception vector
02:00000428 4E73            	   175: 	rte
                            	   176: 
                            	   177: ;-----------------------------------------------------------
                            	   178: ;-----------------------------------------------------------
                            	   179: ; OPCODE : ORI_TO_CCR
                            	   180: ;-----------------------------------------------------------
                            	   181: ;-----------------------------------------------------------
                            	   182: op_ORI_TO_CCR:
                            	   183: 
02:0000042A 003C00FF        	   184:     ori.b #$FF,CCR
02:0000042E 6AFE            	   185:     bpl.s *                   ; branch if Z clear
02:00000430 66FE            	   186:     bne.s *                   ; branch if N clear
02:00000432 68FE            	   187:     bvc.s *                   ; branch if V clear
02:00000434 64FE            	   188:     bcc.s *                   ; branch if C clear
                            	   189: 
02:00000436 44FC0000        	   190:     move #$00,CCR
02:0000043A 003C0000        	   191:     ori.b #$00,CCR
02:0000043E 67FE            	   192:     beq.s *                   ; branch if Z set
02:00000440 6BFE            	   193:     bmi.s *                   ; branch if N set
02:00000442 69FE            	   194:     bvs.s *                   ; branch if V set
02:00000444 65FE            	   195:     bcs.s *                   ; branch if C set
                            	   196: 
02:00000446 46FC2700        	   197:     move.w #$2700,SR          ; Put flags back to initial value
                            	   198: 
02:0000044A 4E75            	   199:     rts
                            	   200: 
                            	   201: ;-----------------------------------------------------------
                            	   202: ;-----------------------------------------------------------
                            	   203: ; OPCODE : ORI_TO_SR
                            	   204: ;-----------------------------------------------------------
                            	   205: ;-----------------------------------------------------------
                            	   206: 
                            	   207: op_ORI_TO_SR:
                            	   208: 
02:0000044C 007C2FFF        	   209:     ori.w #$2FFF,SR
02:00000450 6AFE            	   210:     bpl.s *                   * branch if Z clear
02:00000452 66FE            	   211:     bne.s *                   * branch if N clear
02:00000454 68FE            	   212:     bvc.s *                   * branch if V clear
02:00000456 64FE            	   213:     bcc.s *                   * branch if C clear
                            	   214: 
02:00000458 46FC2000        	   215:     move.w #$2000,SR
02:0000045C 007C0000        	   216:     ori.w #$0000,SR
02:00000460 67FE            	   217:     beq.s *                   * branch if Z set
02:00000462 6BFE            	   218:     bmi.s *                   * branch if N set
02:00000464 69FE            	   219:     bvs.s *                   * branch if V set
02:00000466 65FE            	   220:     bcs.s *                   * branch if C set
                            	   221: 
02:00000468 46FC2700        	   222:     move.w #$2700,sr         * Put flags back to initial value
                            	   223: 
02:0000046C 4E75            	   224:     rts
                            	   225: ; 
                            	   226: ;-----------------------------------------------------------
                            	   227: ;-----------------------------------------------------------
                            	   228: ; OPCODE : EORI_TO_CCR
                            	   229: ;-----------------------------------------------------------
                            	   230: ;-----------------------------------------------------------
                            	   231: op_EORI_TO_CCR:
                            	   232: 
02:0000046E 44FC0000        	   233:     move #$00,CCR
02:00000472 0A3C00FF        	   234:     eori.b #$FF,CCR
02:00000476 6AFE            	   235:     bpl.s *                   ; branch if Z clear
02:00000478 66FE            	   236:     bne.s *                   ; branch if N clear
02:0000047A 68FE            	   237:     bvc.s *                   ; branch if V clear
02:0000047C 64FE            	   238:     bcc.s *                   ; branch if C clear
                            	   239: 
02:0000047E 44FC0000        	   240:     move #$00,CCR
02:00000482 0A3C0000        	   241:     eori.b #$00,CCR
02:00000486 67FE            	   242:     beq.s *                   ; branch if Z set
02:00000488 6BFE            	   243:     bmi.s *                   ; branch if N set
02:0000048A 69FE            	   244:     bvs.s *                   ; branch if V set
02:0000048C 65FE            	   245:     bcs.s *                   ; branch if C set
                            	   246: 
02:0000048E 46FC2700        	   247:     move.w #$2700,sr           ; Put flags back to initial value
                            	   248: 
02:00000492 4E75            	   249:     rts
                            	   250: 
                            	   251: 
                            	   252: 
                            	   253: *-----------------------------------------------------------
                            	   254: *-----------------------------------------------------------
                            	   255: * OPCODE : EORI_TO_SR
                            	   256: *-----------------------------------------------------------
                            	   257: *-----------------------------------------------------------
                            	   258: op_EORI_TO_SR:
                            	   259: 
02:00000494 46FC2000        	   260:     move.w #$2000,SR
02:00000498 0A7C0FFF        	   261:     eori.w #$0FFF,SR
02:0000049C 6AFE            	   262:     bpl.s *                   * branch if Z clear
02:0000049E 66FE            	   263:     bne.s *                   * branch if N clear
02:000004A0 68FE            	   264:     bvc.s *                   * branch if V clear
02:000004A2 64FE            	   265:     bcc.s *                   * branch if C clear
                            	   266: 
02:000004A4 46FC2000        	   267:     move.w #$2000,SR
02:000004A8 0A7C0000        	   268:     eori.w #$0000,SR
02:000004AC 67FE            	   269:     beq.s *                   * branch if Z set
02:000004AE 6BFE            	   270:     bmi.s *                   * branch if N set
02:000004B0 69FE            	   271:     bvs.s *                   * branch if V set
02:000004B2 65FE            	   272:     bcs.s *                   * branch if C set
                            	   273: 
02:000004B4 46FC2700        	   274:     move.w #$2700,sr          * Put flags back to initial value
                            	   275: 
02:000004B8 4E75            	   276:     rts
                            	   277: 
                            	   278: 
                            	   279: 
                            	   280: *-----------------------------------------------------------
                            	   281: *-----------------------------------------------------------
                            	   282: * OPCODE : ANDI_TO_CCR
                            	   283: *-----------------------------------------------------------
                            	   284: *-----------------------------------------------------------
                            	   285: op_ANDI_TO_CCR:
                            	   286: 
02:000004BA 44FC00FF        	   287:     move #$FF,CCR
02:000004BE 023C00FF        	   288:     andi.b #$FF,CCR
02:000004C2 6AFE            	   289:     bpl.s *                   * branch if Z clear
02:000004C4 66FE            	   290:     bne.s *                   * branch if N clear
02:000004C6 68FE            	   291:     bvc.s *                   * branch if V clear
02:000004C8 64FE            	   292:     bcc.s *                   * branch if C clear
                            	   293: 
02:000004CA 44FC00FF        	   294:     move #$FF,CCR
02:000004CE 023C0000        	   295:     andi.b #$00,CCR
02:000004D2 67FE            	   296:     beq.s *                   * branch if Z set
02:000004D4 6BFE            	   297:     bmi.s *                   * branch if N set
02:000004D6 69FE            	   298:     bvs.s *                   * branch if V set
02:000004D8 65FE            	   299:     bcs.s *                   * branch if C set
                            	   300: 
02:000004DA 46FC2700        	   301:     move #$2700,SR           * Put flags back to initial value
                            	   302: 
02:000004DE 4E75            	   303:     rts
                            	   304: 
                            	   305: 
                            	   306: 
                            	   307: *-----------------------------------------------------------
                            	   308: *-----------------------------------------------------------
                            	   309: * OPCODE : ANDI_TO_SR
                            	   310: *-----------------------------------------------------------
                            	   311: *-----------------------------------------------------------
                            	   312: op_ANDI_TO_SR:
02:000004E0 46FC20FF        	   313:     move.w #$20FF,SR
02:000004E4 027CFFFF        	   314:     andi.w #$FFFF,SR
02:000004E8 6AFE            	   315:     bpl.s *                   * branch if Z clear
02:000004EA 66FE            	   316:     bne.s *                   * branch if N clear
02:000004EC 68FE            	   317:     bvc.s *                   * branch if V clear
02:000004EE 64FE            	   318:     bcc.s *                   * branch if C clear
                            	   319: 
02:000004F0 46FC20FF        	   320:     move.w #$20FF,SR
02:000004F4 027CFF00        	   321:     andi.w #$FF00,SR
02:000004F8 67FE            	   322:     beq.s *                   * branch if Z set
02:000004FA 6BFE            	   323:     bmi.s *                   * branch if N set
02:000004FC 69FE            	   324:     bvs.s *                   * branch if V set
02:000004FE 65FE            	   325:     bcs.s *                   * branch if C set
                            	   326: 
02:00000500 46FC2700        	   327:     move.w #$2700,sr           * Put flags back to initial value
                            	   328: 
02:00000504 4E75            	   329:     rts
                            	   330: 
                            	   331: 
                            	   332: *-----------------------------------------------------------
                            	   333: *-----------------------------------------------------------
                            	   334: * OPCODE : BTST
                            	   335: *-----------------------------------------------------------
                            	   336: *-----------------------------------------------------------
                            	   337: op_BTST:
                            	   338: 
                            	   339: *  Bit Number.s Static
                            	   340: 
                            	   341: *             EA = Dn  - LONG only
02:00000506 203C80000001    	   342:             move.l #$80000001,d0      * populate test data
02:0000050C 08000000        	   343:             btst.l #0,d0
02:00000510 67FE            	   344:             beq.s *               * branch if Z set
02:00000512 08000001        	   345:             btst.l #1,d0              *
02:00000516 66FE            	   346:             bne.s *               * branch if Z clear
02:00000518 0800001F        	   347:             btst.l #31,d0             *
02:0000051C 67FE            	   348:             beq.s *               * branch if Z set
                            	   349: 
                            	   350: 
                            	   351: *             EA = (An)  - BYTE only
02:0000051E 307C0100        	   352:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000522 10BC0081        	   353:             move.b #$81,(a0)          * populate test data
02:00000526 1210            	   354:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:00000528 08100000        	   355:             btst.b #0,(a0)
02:0000052C 67FE            	   356:             beq.s *               * branch if Z set
02:0000052E 08100001        	   357:             btst.b #1,(a0)            *
02:00000532 66FE            	   358:             bne.s *               * branch if Z clear
02:00000534 08100007        	   359:             btst.b #7,(a0)            *
02:00000538 67FE            	   360:             beq.s *               * branch if Z set
                            	   361: 
                            	   362: 
                            	   363: *             EA = (An)+  - BYTE only
02:0000053A 307C0100        	   364:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000053E 10FC0001        	   365:             move.b #$01,(a0)+         * populate test data
02:00000542 10FC00FC        	   366:             move.b #$FC,(a0)+         * populate test data
02:00000546 10FC0080        	   367:             move.b #$80,(a0)+         * populate test data
02:0000054A 307C0100        	   368:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000054E 08180000        	   369:             btst.b #0,(a0)+
02:00000552 67FE            	   370:             beq.s *               * branch if Z set
02:00000554 08180001        	   371:             btst.b #1,(a0)+           *
02:00000558 66FE            	   372:             bne.s *               * branch if Z clear
02:0000055A 08180007        	   373:             btst.b #7,(a0)+           *
02:0000055E 67FE            	   374:             beq.s *               * branch if Z set
                            	   375: 
                            	   376: 
                            	   377: *             EA = -(An)  - BYTE only
02:00000560 307C0100        	   378:             move.l #$00000100,a0      * point to memory to address
02:00000564 10FC0080        	   379:             move.b #$80,(a0)+         * populate test data
02:00000568 10FC00FC        	   380:             move.b #$FC,(a0)+         * populate test data
02:0000056C 10FC0001        	   381:             move.b #$01,(a0)+         * populate test data
02:00000570 307C0103        	   382:             move.l #$00000103,a0      * point to memory to address
02:00000574 08200000        	   383:             btst.b #0,-(a0)
02:00000578 67FE            	   384:             beq.s *               * branch if Z set
02:0000057A 08200001        	   385:             btst.b #1,-(a0)           *
02:0000057E 66FE            	   386:             bne.s *               * branch if Z clear
02:00000580 08200007        	   387:             btst.b #7,-(a0)           *
02:00000584 67FE            	   388:             beq.s *               * branch if Z set
                            	   389: 
                            	   390: 
                            	   391: *             EA = n(An)  - BYTE only
02:00000586 307C0100        	   392:             move.l #$00000100,a0      * point to memory to address
02:0000058A 10FC0001        	   393:             move.b #$01,(a0)+         * populate test data
02:0000058E 10FC00FC        	   394:             move.b #$FC,(a0)+         * populate test data
02:00000592 10FC0080        	   395:             move.b #$80,(a0)+         * populate test data
02:00000596 307C0100        	   396:             move.l #$00000100,a0      * point to memory to address
02:0000059A 08100000        	   397:             btst.b #0,0(a0)
02:0000059E 67FE            	   398:             beq.s *               * branch if Z set
02:000005A0 082800010001    	   399:             btst.b #1,1(a0)           *
02:000005A6 66FE            	   400:             bne.s *               * branch if Z clear
02:000005A8 082800070002    	   401:             btst.b #7,2(a0)           *
02:000005AE 67FE            	   402:             beq.s *               * branch if Z set
                            	   403: 
                            	   404: 
                            	   405: *             EA = n(An,R.W)  - BYTE only
02:000005B0 307C0100        	   406:             move.l #$00000100,a0      * point to memory to address
02:000005B4 93C9            	   407:             move.l #$00000000,a1      * point to memory to address
02:000005B6 347C0001        	   408:             move.l #$00000001,a2      * point to memory to address
02:000005BA 7000            	   409:             moveq  #$00000000,d0      * point to memory to address
02:000005BC 7201            	   410:             moveq  #$00000001,d1      * point to memory to address
02:000005BE 083000000000    	   411:             btst.b #0,0(a0,d0.w)
02:000005C4 67FE            	   412:             beq.s *               * branch if Z set
02:000005C6 083000011000    	   413:             btst.b #1,0(a0,d1.w)      *
02:000005CC 66FE            	   414:             bne.s *               * branch if Z clear
02:000005CE 083000071001    	   415:             btst.b #7,1(a0,d1.w)      *
02:000005D4 67FE            	   416:             beq.s *               * branch if Z set
                            	   417: *             EA = n(An,R.L)  - BYTE only
02:000005D6 083000000800    	   418:             btst.b #0,0(a0,d0.l)
02:000005DC 67FE            	   419:             beq.s *               * branch if Z set
02:000005DE 083000011800    	   420:             btst.b #1,0(a0,d1.l)      *
02:000005E4 66FE            	   421:             bne.s *               * branch if Z clear
02:000005E6 083000071801    	   422:             btst.b #7,1(a0,d1.l)      *
02:000005EC 67FE            	   423:             beq.s *               * branch if Z set
                            	   424: *             EA = n(An,A.W)  - BYTE only
02:000005EE 083000009000    	   425:             btst.b #0,0(a0,a1.w)
02:000005F4 67FE            	   426:             beq.s *               * branch if Z set
02:000005F6 08300001A000    	   427:             btst.b #1,0(a0,a2.w)      *
02:000005FC 66FE            	   428:             bne.s *               * branch if Z clear
02:000005FE 08300007A001    	   429:             btst.b #7,1(a0,a2.w)      *
02:00000604 67FE            	   430:             beq.s *               * branch if Z set
                            	   431: *             EA = n(An,A.L)  - BYTE only
02:00000606 083000009800    	   432:             btst.b #0,0(a0,a1.l)
02:0000060C 67FE            	   433:             beq.s *               * branch if Z set
02:0000060E 08300001A800    	   434:             btst.b #1,0(a0,a2.l)      *
02:00000614 66FE            	   435:             bne.s *               * branch if Z clear
02:00000616 08300007A801    	   436:             btst.b #7,1(a0,a2.l)      *
02:0000061C 67FE            	   437:             beq.s *               * branch if Z set
                            	   438: 
                            	   439: 
                            	   440: *             EA = x.W  - BYTE only
02:0000061E 083800000100    	   441:             btst.b #0,$0100
02:00000624 67FE            	   442:             beq.s *               * branch if Z set
02:00000626 083800010101    	   443:             btst.b #1,$0101           *
02:0000062C 66FE            	   444:             bne.s *               * branch if Z clear
02:0000062E 083800070102    	   445:             btst.b #7,$0102           *
02:00000634 67FE            	   446:             beq.s *               * branch if Z set
                            	   447: 
                            	   448: 
                            	   449: *             EA = x.L  - BYTE only
02:00000636 207C0000F100    	   450:             move.l #$F100,a0      * point to memory to address 0x100
02:0000063C 10FC0001        	   451:             move.b #$01,(a0)+         * populate test data
02:00000640 10FC00FC        	   452:             move.b #$FC,(a0)+         * populate test data
02:00000644 10FC0080        	   453:             move.b #$80,(a0)+         * populate test data
02:00000648 083900000000F100	   454:             btst.b #0,$F100
02:00000650 67FE            	   455:             beq.s *               * branch if Z set
02:00000652 083900010000F101	   456:             btst.b #1,$F101       *
02:0000065A 66FE            	   457:             bne.s *               * branch if Z clear
02:0000065C 083900070000F102	   458:             btst.b #7,$F102       *
02:00000664 67FE            	   459:             beq.s *               * branch if Z set
                            	   460: 
                            	   461: 
                            	   462: *             EA = x(PC)  - BYTE only
02:00000666 4BFAFE9E        	   463:             lea op_BTST(pc),a5
02:0000066A 083A0000FE98    	   464:             btst.b #0,op_BTST(pc)
02:00000670 66FE            	   465:             bne.s *               * branch if Z clear
02:00000672 083A0003001A    	   466:             btst.b #3,op_BTST0(pc)     *
02:00000678 67FE            	   467:             beq.s *               * branch if Z set
02:0000067A 083A00060074    	   468:             btst.b #6,op_BTST12(pc)    *
02:00000680 67FE            	   469:             beq.s *               * branch if Z set
                            	   470: 
                            	   471: 
                            	   472: *             EA = n(PC,R.W)  - BYTE only
02:00000682 307C0100        	   473:             move.l #$00000100,a0      * point to memory to address
02:00000686 93C9            	   474:             move.l #$00000000,a1      * point to memory to address
02:00000688 347C0001        	   475:             move.l #$00000001,a2      * point to memory to address
02:0000068C 7000            	   476:             moveq  #$00000000,d0      * point to memory to address
02:0000068E 7201            	   477:             moveq  #$00000001,d1      * point to memory to address
                            	   478: 
02:00000690 083B000000FC    	   479: op_BTST0:   btst.b #0,op_BTST0(pc,d0.w)
02:00000696 66FE            	   480:             bne.s *               * branch if Z clear
                            	   481: 
02:00000698 4BFB1002        	   482:             lea op_BTST1(pc,d1.w),a5
02:0000069C 083B000110FC    	   483: op_BTST1:   btst.b #1,op_BTST1(pc,d1.w)      *
02:000006A2 67FE            	   484:             beq.s *               * branch if Z set
02:000006A4 083B000710FC    	   485: op_BTST2:   btst.b #7,op_BTST2(pc,d1.w)      *
02:000006AA 66FE            	   486:             bne.s *               * branch if Z clear
                            	   487: *             EA = n(PC,R.L)  - BYTE only
02:000006AC 083B000008FC    	   488: op_BTST3:   btst.b #0,op_BTST3(pc,d0.l)
02:000006B2 66FE            	   489:             bne.s *               * branch if Z clear
02:000006B4 083B000118FC    	   490: op_BTST4:   btst.b #1,op_BTST4(pc,d1.l)      *
02:000006BA 67FE            	   491:             beq.s *               * branch if Z set
02:000006BC 083B000718FC    	   492: op_BTST5:   btst.b #7,op_BTST5(pc,d1.l)      *
02:000006C2 66FE            	   493:             bne.s *               * branch if Z clear
                            	   494: *             EA = n(PC,A.W)  - BYTE only
02:000006C4 083B000090FC    	   495: op_BTST6    btst.b #0,op_BTST6(pc,a1.w)
02:000006CA 66FE            	   496:             bne.s *               * branch if Z clear
02:000006CC 083B0001A0FC    	   497: op_BTST7:   btst.b #1,op_BTST7(pc,a2.w)      *
02:000006D2 67FE            	   498:             beq.s *               * branch if Z set
02:000006D4 083B0007A0FC    	   499: op_BTST8:   btst.b #7,op_BTST8(pc,a2.w)      *
02:000006DA 66FE            	   500:             bne.s *               * branch if Z clear
                            	   501: *             EA = n(PC,A.L)  - BYTE only
02:000006DC 083B000098FC    	   502: op_BTST9:   btst.b #0,op_BTST9(pc,a1.l)
02:000006E2 66FE            	   503:             bne.s *               * branch if Z clear
02:000006E4 083B0001A8FC    	   504: op_BTST10:  btst.b #1,op_BTST10(pc,a2.l)      *
02:000006EA 67FE            	   505:             beq.s *               * branch if Z set
02:000006EC 083B0007A8FC    	   506: op_BTST11:  btst.b #7,op_BTST11(pc,a2.l)      *
02:000006F2 66FE            	   507: op_BTST12:  bne.s *               * branch if Z clear
                            	   508: 
                            	   509: 
                            	   510: 
                            	   511: * Bit Number.s Dynamic
                            	   512: 
                            	   513: *             EA = Dn  - LONG only
02:000006F4 203C80000001    	   514:             move.l #$80000001,d0      * populate test data
02:000006FA 7A00            	   515:             move.l #0,d5              * populate bit.s number to test
02:000006FC 7C01            	   516:             move.l #1,d6              * populate bit.s number to test
02:000006FE 7E1F            	   517:             move.l #31,d7              * populate bit.s number to test
                            	   518: 
02:00000700 0B00            	   519:             btst.l d5,d0
02:00000702 67FE            	   520:             beq.s *               * branch if Z set
02:00000704 0D00            	   521:             btst.l d6,d0              *
02:00000706 66FE            	   522:             bne.s *               * branch if Z clear
02:00000708 0F00            	   523:             btst.l d7,d0             *
02:0000070A 67FE            	   524:             beq.s *               * branch if Z set
                            	   525: 
                            	   526: 
                            	   527: *             EA = (An)  - BYTE only
02:0000070C 7A00            	   528:             move.l #0,d5              * populate bit.s number to test
02:0000070E 7C01            	   529:             move.l #1,d6              * populate bit.s number to test
02:00000710 7E07            	   530:             move.l #7,d7              * populate bit.s number to test
02:00000712 307C0100        	   531:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000716 10BC0081        	   532:             move.b #$81,(a0)          * populate test data
02:0000071A 1210            	   533:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:0000071C 0B10            	   534:             btst.b d5,(a0)
02:0000071E 67FE            	   535:             beq.s *               * branch if Z set
02:00000720 0D10            	   536:             btst.b d6,(a0)            *
02:00000722 66FE            	   537:             bne.s *               * branch if Z clear
02:00000724 0F10            	   538:             btst.b d7,(a0)            *
02:00000726 67FE            	   539:             beq.s *               * branch if Z set
                            	   540: 
                            	   541: * ---
                            	   542: 
                            	   543: 
                            	   544: *             EA = (An)+  - BYTE only
02:00000728 307C0100        	   545:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000072C 10FC0001        	   546:             move.b #$01,(a0)+         * populate test data
02:00000730 10FC00FC        	   547:             move.b #$FC,(a0)+         * populate test data
02:00000734 10FC0080        	   548:             move.b #$80,(a0)+         * populate test data
02:00000738 307C0100        	   549:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000073C 0B18            	   550:             btst.b d5,(a0)+
02:0000073E 67FE            	   551:             beq.s *               * branch if Z set
02:00000740 0D18            	   552:             btst.b d6,(a0)+           *
02:00000742 66FE            	   553:             bne.s *               * branch if Z clear
02:00000744 0F18            	   554:             btst.b d7,(a0)+           *
02:00000746 67FE            	   555:             beq.s *               * branch if Z set
                            	   556: 
                            	   557: 
                            	   558: *             EA = -(An)  - BYTE only
02:00000748 307C0100        	   559:             move.l #$00000100,a0      * point to memory to address
02:0000074C 10FC0080        	   560:             move.b #$80,(a0)+         * populate test data
02:00000750 10FC00FC        	   561:             move.b #$FC,(a0)+         * populate test data
02:00000754 10FC0001        	   562:             move.b #$01,(a0)+         * populate test data
02:00000758 307C0103        	   563:             move.l #$00000103,a0      * point to memory to address
02:0000075C 0B20            	   564:             btst.b d5,-(a0)
02:0000075E 67FE            	   565:             beq.s *               * branch if Z set
02:00000760 0D20            	   566:             btst.b d6,-(a0)           *
02:00000762 66FE            	   567:             bne.s *               * branch if Z clear
02:00000764 0F20            	   568:             btst.b d7,-(a0)           *
02:00000766 67FE            	   569:             beq.s *               * branch if Z set
                            	   570: 
                            	   571: 
                            	   572: *             EA = n(An)  - BYTE only
02:00000768 307C0100        	   573:             move.l #$00000100,a0      * point to memory to address
02:0000076C 10FC0001        	   574:             move.b #$01,(a0)+         * populate test data
02:00000770 10FC00FC        	   575:             move.b #$FC,(a0)+         * populate test data
02:00000774 10FC0080        	   576:             move.b #$80,(a0)+         * populate test data
02:00000778 307C0100        	   577:             move.l #$00000100,a0      * point to memory to address
02:0000077C 0B10            	   578:             btst.b d5,0(a0)
02:0000077E 67FE            	   579:             beq.s *               * branch if Z set
02:00000780 0D280001        	   580:             btst.b d6,1(a0)           *
02:00000784 66FE            	   581:             bne.s *               * branch if Z clear
02:00000786 0F280002        	   582:             btst.b d7,2(a0)           *
02:0000078A 67FE            	   583:             beq.s *               * branch if Z set
                            	   584: 
                            	   585: 
                            	   586: *             EA = n(An,R.W)  - BYTE only
02:0000078C 307C0100        	   587:             move.l #$00000100,a0      * point to memory to address
02:00000790 93C9            	   588:             move.l #$00000000,a1      * point to memory to address
02:00000792 347C0001        	   589:             move.l #$00000001,a2      * point to memory to address
02:00000796 7000            	   590:             moveq  #$00000000,d0      * point to memory to address
02:00000798 7201            	   591:             moveq  #$00000001,d1      * point to memory to address
02:0000079A 0B300000        	   592:             btst.b d5,0(a0,d0.w)
02:0000079E 67FE            	   593:             beq.s *               * branch if Z set
02:000007A0 0D301000        	   594:             btst.b d6,0(a0,d1.w)      *
02:000007A4 66FE            	   595:             bne.s *               * branch if Z clear
02:000007A6 0F301001        	   596:             btst.b d7,1(a0,d1.w)      *
02:000007AA 67FE            	   597:             beq.s *               * branch if Z set
                            	   598: *             EA = n(An,R.L)  - BYTE only
02:000007AC 0B300800        	   599:             btst.b d5,0(a0,d0.l)
02:000007B0 67FE            	   600:             beq.s *               * branch if Z set
02:000007B2 0D301800        	   601:             btst.b d6,0(a0,d1.l)      *
02:000007B6 66FE            	   602:             bne.s *               * branch if Z clear
02:000007B8 0F301801        	   603:             btst.b d7,1(a0,d1.l)      *
02:000007BC 67FE            	   604:             beq.s *               * branch if Z set
                            	   605: *             EA = n(An,A.W)  - BYTE only
02:000007BE 0B309000        	   606:             btst.b d5,0(a0,a1.w)
02:000007C2 67FE            	   607:             beq.s *               * branch if Z set
02:000007C4 0D30A000        	   608:             btst.b d6,0(a0,a2.w)      *
02:000007C8 66FE            	   609:             bne.s *               * branch if Z clear
02:000007CA 0F30A001        	   610:             btst.b d7,1(a0,a2.w)      *
02:000007CE 67FE            	   611:             beq.s *               * branch if Z set
                            	   612: *             EA = n(An,A.L)  - BYTE only
02:000007D0 0B309800        	   613:             btst.b d5,0(a0,a1.l)
02:000007D4 67FE            	   614:             beq.s *               * branch if Z set
02:000007D6 0D30A800        	   615:             btst.b d6,0(a0,a2.l)      *
02:000007DA 66FE            	   616:             bne.s *               * branch if Z clear
02:000007DC 0F30A801        	   617:             btst.b d7,1(a0,a2.l)      *
02:000007E0 67FE            	   618:             beq.s *               * branch if Z set
                            	   619: 
                            	   620: 
                            	   621: *             EA = x.W  - BYTE only
02:000007E2 0B380100        	   622:             btst.b d5,$0100
02:000007E6 67FE            	   623:             beq.s *               * branch if Z set
02:000007E8 0D380101        	   624:             btst.b d6,$0101           *
02:000007EC 66FE            	   625:             bne.s *               * branch if Z clear
02:000007EE 0F380102        	   626:             btst.b d7,$0102           *
02:000007F2 67FE            	   627:             beq.s *               * branch if Z set
                            	   628: 
                            	   629: 
                            	   630: *             EA = x.L  - BYTE only
02:000007F4 207C0000F100    	   631:             move.l #$F100,a0      * point to memory to address 0x100
02:000007FA 10FC0001        	   632:             move.b #$01,(a0)+         * populate test data
02:000007FE 10FC00FC        	   633:             move.b #$FC,(a0)+         * populate test data
02:00000802 10FC0080        	   634:             move.b #$80,(a0)+         * populate test data
02:00000806 0B390000F100    	   635:             btst.b d5,$F100
02:0000080C 67FE            	   636:             beq.s *               * branch if Z set
02:0000080E 0D390000F101    	   637:             btst.b d6,$F101       *
02:00000814 66FE            	   638:             bne.s *               * branch if Z clear
02:00000816 0F390000F102    	   639:             btst.b d7,$F102       *
02:0000081C 67FE            	   640:             beq.s *               * branch if Z set
                            	   641: 
                            	   642: 
                            	   643: *             EA = x(PC)  - BYTE only
02:0000081E 7C03            	   644:             move.l #3,d6              * populate bit.s number to test
02:00000820 7E06            	   645:             move.l #6,d7              * populate bit.s number to test
02:00000822 4BFAFCE2        	   646:             lea op_BTST(pc),a5
02:00000826 0B3AFCDE        	   647:             btst.b d5,op_BTST(pc)
02:0000082A 66FE            	   648:             bne.s *               * branch if Z clear
02:0000082C 0D3AFE62        	   649:             btst.b d6,op_BTST0(pc)     *
02:00000830 67FE            	   650:             beq.s *               * branch if Z set
02:00000832 0F3AFEBE        	   651:             btst.b d7,op_BTST12(pc)    *
02:00000836 67FE            	   652:             beq.s *               * branch if Z set
                            	   653: 
                            	   654: 
                            	   655: *             EA = n(PC,R.W)  - BYTE only
02:00000838 307C0100        	   656:             move.l #$00000100,a0      * point to memory to address
02:0000083C 93C9            	   657:             move.l #$00000000,a1      * point to memory to address
02:0000083E 347C0001        	   658:             move.l #$00000001,a2      * point to memory to address
02:00000842 7000            	   659:             moveq  #$00000000,d0      * point to memory to address
02:00000844 7201            	   660:             moveq  #$00000001,d1      * point to memory to address
02:00000846 7C01            	   661:             move.l #1,d6              * populate bit.s number to test
02:00000848 7E07            	   662:             move.l #7,d7              * populate bit.s number to test
                            	   663: 
02:0000084A 0B3B00FE        	   664: op_BTST20:  btst.b d5,op_BTST20(pc,d0.w)
02:0000084E 67FE            	   665:             beq.s *               * branch if Z set
02:00000850 4BFB1002        	   666:             lea op_BTST21(pc,d1.w),a5
02:00000854 0D3B10FE        	   667: op_BTST21:  btst.b d6,op_BTST21(pc,d1.w)      *
02:00000858 67FE            	   668:             beq.s *               * branch if Z set
02:0000085A 0F3B10FE        	   669: op_BTST22:  btst.b d7,op_BTST22(pc,d1.w)      *
02:0000085E 66FE            	   670:             bne.s *               * branch if Z clear
                            	   671: *             EA = n(PC,R.L)  - BYTE only
02:00000860 0B3B08FE        	   672: op_BTST23:  btst.b d5,op_BTST23(pc,d0.l)
02:00000864 67FE            	   673:             beq.s *               * branch if Z set
02:00000866 0D3B18FE        	   674: op_BTST24: btst.b d6,op_BTST24(pc,d1.l)      *
02:0000086A 67FE            	   675:             beq.s *               * branch if Z set
02:0000086C 0F3B18FE        	   676: op_BTST25  btst.b d7,op_BTST25(pc,d1.l)      *
02:00000870 66FE            	   677:             bne.s *               * branch if Z clear
                            	   678: *             EA = n(PC,A.W)  - BYTE only
02:00000872 0B3B90FE        	   679: op_BTST26   btst.b d5,op_BTST26(pc,a1.w)
02:00000876 67FE            	   680:             beq.s *               * branch if Z set
02:00000878 0D3BA0FE        	   681: op_BTST27:  btst.b d6,op_BTST27(pc,a2.w)      *
02:0000087C 67FE            	   682:             beq.s *               * branch if Z set
02:0000087E 0F3BA0FE        	   683: op_BTST28:  btst.b d7,op_BTST28(pc,a2.w)      *
02:00000882 66FE            	   684:             bne.s *               * branch if Z clear
                            	   685: *             EA = n(PC,A.L)  - BYTE only
02:00000884 0B3B98FE        	   686: op_BTST29:  btst.b d5,op_BTST29(pc,a1.l)
02:00000888 67FE            	   687:             beq.s *               * branch if Z set
02:0000088A 0D3BA8FE        	   688: op_BTST30:  btst.b d6,op_BTST30(pc,a2.l)      *
02:0000088E 67FE            	   689:             beq.s *               * branch if Z set
02:00000890 0F3BA8FE        	   690: op_BTST31:  btst.b d7,op_BTST31(pc,a2.l)      *
02:00000894 66FE            	   691: op_BTST32:  bne.s *               * branch if Z clear
                            	   692: 
                            	   693: *             EA = #x  - BYTE only
                            	   694: 
02:00000896 7A00            	   695:             move.l #0,d5              * populate bit.s number to test
02:00000898 7C03            	   696:             move.l #3,d6              * populate bit.s number to test
02:0000089A 7E07            	   697:             move.l #7,d7              * populate bit.s number to test
                            	   698: 
02:0000089C 0B3C0088        	   699:             btst.b d5,#$88
02:000008A0 66FE            	   700:             bne.s *               * branch if Z clear
02:000008A2 0D3C0088        	   701:             btst.b d6,#$88
02:000008A6 67FE            	   702:             beq.s *               * branch if Z set
02:000008A8 0F3C0088        	   703:             btst.b d7,#$88
02:000008AC 67FE            	   704:             beq.s *               * branch if Z set
                            	   705: 
                            	   706: 
02:000008AE 4E75            	   707:     rts
                            	   708: 
                            	   709: *-----------------------------------------------------------
                            	   710: *-----------------------------------------------------------
                            	   711: * OPCODE : BCHG
                            	   712: *-----------------------------------------------------------
                            	   713: *-----------------------------------------------------------
                            	   714: op_BCHG:
                            	   715: 
                            	   716: 
                            	   717: *  Bit Number.s Static
                            	   718: 
                            	   719: *             EA = Dn  - LONG only
02:000008B0 203C80000001    	   720:             move.l #$80000001,d0      * populate test data
02:000008B6 08400000        	   721:             bchg.l #0,d0
02:000008BA 67FE            	   722:             beq.s *               * branch if Z set
02:000008BC 08400001        	   723:             bchg.l #1,d0              *
02:000008C0 66FE            	   724:             bne.s *               * branch if Z clear
02:000008C2 0840001F        	   725:             bchg.l #31,d0             *
02:000008C6 67FE            	   726:             beq.s *               * branch if Z set
02:000008C8 0C8000000002    	   727:             cmpi.l #$00000002,d0
02:000008CE 66FE            	   728:             bne.s *               * branch if Z clear
                            	   729: 
                            	   730: 
                            	   731: *             EA = (An)  - BYTE only
02:000008D0 307C0100        	   732:             move.l #$00000100,a0      * point to memory to address 0x100
02:000008D4 10BC0081        	   733:             move.b #$81,(a0)          * populate test data
02:000008D8 1210            	   734:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:000008DA 08500000        	   735:             bchg.b #0,(a0)
02:000008DE 67FE            	   736:             beq.s *               * branch if Z set
02:000008E0 08500001        	   737:             bchg.b #1,(a0)            *
02:000008E4 66FE            	   738:             bne.s *               * branch if Z clear
02:000008E6 08500007        	   739:             bchg.b #7,(a0)            *
02:000008EA 67FE            	   740:             beq.s *               * branch if Z set
02:000008EC 0C100002        	   741:             cmpi.b #$02,(a0)
02:000008F0 66FE            	   742:             bne.s *               * branch if Z clear
                            	   743: 
                            	   744: *             EA = (An)+  - BYTE only
02:000008F2 307C0100        	   745:             move.l #$00000100,a0      * point to memory to address 0x100
02:000008F6 10FC0001        	   746:             move.b #$01,(a0)+         * populate test data
02:000008FA 10FC00FC        	   747:             move.b #$FC,(a0)+         * populate test data
02:000008FE 10FC0080        	   748:             move.b #$80,(a0)+         * populate test data
02:00000902 307C0100        	   749:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000906 08580000        	   750:             bchg.b #0,(a0)+
02:0000090A 67FE            	   751:             beq.s *               * branch if Z set
02:0000090C 08580001        	   752:             bchg.b #1,(a0)+           *
02:00000910 66FE            	   753:             bne.s *               * branch if Z clear
02:00000912 08580007        	   754:             bchg.b #7,(a0)+           *
02:00000916 67FE            	   755:             beq.s *               * branch if Z set
02:00000918 307C0100        	   756:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000091C 4A18            	   757:             cmpi.b #$00,(a0)+
02:0000091E 66FE            	   758:             bne.s *               * branch if Z clear
02:00000920 0C1800FE        	   759:             cmpi.b #$FE,(a0)+
02:00000924 66FE            	   760:             bne.s *               * branch if Z clear
02:00000926 4A18            	   761:             cmpi.b #$00,(a0)+
02:00000928 66FE            	   762:             bne.s *               * branch if Z clear
                            	   763: 
                            	   764: *             EA = -(An)  - BYTE only
02:0000092A 307C0100        	   765:             move.l #$00000100,a0      * point to memory to address
02:0000092E 10FC0080        	   766:             move.b #$80,(a0)+         * populate test data
02:00000932 10FC00FC        	   767:             move.b #$FC,(a0)+         * populate test data
02:00000936 10FC0001        	   768:             move.b #$01,(a0)+         * populate test data
02:0000093A 307C0103        	   769:             move.l #$00000103,a0      * point to memory to address
02:0000093E 08600000        	   770:             bchg.b #0,-(a0)
02:00000942 67FE            	   771:             beq.s *               * branch if Z set
02:00000944 08600001        	   772:             bchg.b #1,-(a0)           *
02:00000948 66FE            	   773:             bne.s *               * branch if Z clear
02:0000094A 08600007        	   774:             bchg.b #7,-(a0)           *
02:0000094E 67FE            	   775:             beq.s *               * branch if Z set
02:00000950 307C0103        	   776:             move.l #$00000103,a0      * point to memory to address 0x100
02:00000954 4A20            	   777:             cmpi.b #$00,-(a0)
02:00000956 66FE            	   778:             bne.s *               * branch if Z clear
02:00000958 0C2000FE        	   779:             cmpi.b #$FE,-(a0)
02:0000095C 66FE            	   780:             bne.s *               * branch if Z clear
02:0000095E 4A20            	   781:             cmpi.b #$00,-(a0)
02:00000960 66FE            	   782:             bne.s *               * branch if Z clear
                            	   783: 
                            	   784: 
                            	   785: *             EA = n(An)  - BYTE only
02:00000962 307C0100        	   786:             move.l #$00000100,a0      * point to memory to address
02:00000966 10FC0001        	   787:             move.b #$01,(a0)+         * populate test data
02:0000096A 10FC00FC        	   788:             move.b #$FC,(a0)+         * populate test data
02:0000096E 10FC0080        	   789:             move.b #$80,(a0)+         * populate test data
02:00000972 307C0100        	   790:             move.l #$00000100,a0      * point to memory to address
02:00000976 08500000        	   791:             bchg.b #0,0(a0)
02:0000097A 67FE            	   792:             beq.s *               * branch if Z set
02:0000097C 086800010001    	   793:             bchg.b #1,1(a0)           *
02:00000982 66FE            	   794:             bne.s *               * branch if Z clear
02:00000984 086800070002    	   795:             bchg.b #7,2(a0)           *
02:0000098A 67FE            	   796:             beq.s *               * branch if Z set
02:0000098C 307C0100        	   797:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000990 4A18            	   798:             cmpi.b #$00,(a0)+
02:00000992 66FE            	   799:             bne.s *               * branch if Z clear
02:00000994 0C1800FE        	   800:             cmpi.b #$FE,(a0)+
02:00000998 66FE            	   801:             bne.s *               * branch if Z clear
02:0000099A 4A18            	   802:             cmpi.b #$00,(a0)+
02:0000099C 66FE            	   803:             bne.s *               * branch if Z clear
                            	   804: 
                            	   805: 
                            	   806: *             EA = n(An,D.W)  - BYTE only
02:0000099E 307C0100        	   807:             move.l #$00000100,a0      * point to memory to address
02:000009A2 93C9            	   808:             move.l #$00000000,a1      * point to memory to address
02:000009A4 347C0001        	   809:             move.l #$00000001,a2      * point to memory to address
02:000009A8 7000            	   810:             moveq  #$00000000,d0      * point to memory to address
02:000009AA 7201            	   811:             moveq  #$00000001,d1      * point to memory to address
02:000009AC 087000000000    	   812:             bchg.b #0,0(a0,d0.w)
02:000009B2 66FE            	   813:             bne.s *               * branch if Z clear
02:000009B4 087000011000    	   814:             bchg.b #1,0(a0,d1.w)      *
02:000009BA 67FE            	   815:             beq.s *               * branch if Z set
02:000009BC 087000071001    	   816:             bchg.b #7,1(a0,d1.w)      *
02:000009C2 66FE            	   817:             bne.s *               * branch if Z clear
                            	   818: *             EA = n(An,D.L)  - BYTE only
02:000009C4 087000000800    	   819:             bchg.b #0,0(a0,d0.l)
02:000009CA 67FE            	   820:             beq.s *               * branch if Z set
02:000009CC 087000011800    	   821:             bchg.b #1,0(a0,d1.l)      *
02:000009D2 66FE            	   822:             bne.s *               * branch if Z clear
02:000009D4 087000071801    	   823:             bchg.b #7,1(a0,d1.l)      *
02:000009DA 67FE            	   824:             beq.s *               * branch if Z set
                            	   825: *             EA = n(An,A.W)  - BYTE only
02:000009DC 087000009000    	   826:             bchg.b #0,0(a0,a1.w)
02:000009E2 66FE            	   827:             bne.s *               * branch if Z clear
02:000009E4 08700001A000    	   828:             bchg.b #1,0(a0,a2.w)      *
02:000009EA 67FE            	   829:             beq.s *               * branch if Z set
02:000009EC 08700007A001    	   830:             bchg.b #7,1(a0,a2.w)      *
02:000009F2 66FE            	   831:             bne.s *               * branch if Z clear
                            	   832: *             EA = n(An,A.L)  - BYTE only
02:000009F4 087000009800    	   833:             bchg.b #0,0(a0,a1.l)
02:000009FA 67FE            	   834:             beq.s *               * branch if Z set
02:000009FC 08700001A800    	   835:             bchg.b #1,0(a0,a2.l)      *
02:00000A02 66FE            	   836:             bne.s *               * branch if Z clear
02:00000A04 08700007A801    	   837:             bchg.b #7,1(a0,a2.l)      *
02:00000A0A 67FE            	   838:             beq.s *               * branch if Z set
02:00000A0C 307C0100        	   839:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A10 4A18            	   840:             cmpi.b #$00,(a0)+
02:00000A12 66FE            	   841:             bne.s *               * branch if Z clear
02:00000A14 0C1800FE        	   842:             cmpi.b #$FE,(a0)+
02:00000A18 66FE            	   843:             bne.s *               * branch if Z clear
02:00000A1A 4A18            	   844:             cmpi.b #$00,(a0)+
02:00000A1C 66FE            	   845:             bne.s *               * branch if Z clear
                            	   846: 
                            	   847: 
                            	   848: *             EA = x.W  - BYTE only
02:00000A1E 087800000100    	   849:             bchg.b #0,$0100
02:00000A24 66FE            	   850:             bne.s *               * branch if Z clear
02:00000A26 087800010101    	   851:             bchg.b #1,$0101           *
02:00000A2C 67FE            	   852:             beq.s *               * branch if Z set
02:00000A2E 087800070102    	   853:             bchg.b #7,$0102           *
02:00000A34 66FE            	   854:             bne.s *               * branch if Z clear
02:00000A36 307C0100        	   855:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A3A 0C180001        	   856:             cmpi.b #$01,(a0)+
02:00000A3E 66FE            	   857:             bne.s *               * branch if Z clear
02:00000A40 0C1800FC        	   858:             cmpi.b #$FC,(a0)+
02:00000A44 66FE            	   859:             bne.s *               * branch if Z clear
02:00000A46 0C180080        	   860:             cmpi.b #$80,(a0)+
02:00000A4A 66FE            	   861:             bne.s *               * branch if Z clear
                            	   862: 
                            	   863: *             EA = x.L  - BYTE only
02:00000A4C 207C0000F100    	   864:             move.l #$F100,a0      * point to memory to address 0x100
02:00000A52 10FC0001        	   865:             move.b #$01,(a0)+         * populate test data
02:00000A56 10FC00FC        	   866:             move.b #$FC,(a0)+         * populate test data
02:00000A5A 10FC0080        	   867:             move.b #$80,(a0)+         * populate test data
02:00000A5E 087900000000F100	   868:             bchg.b #0,$F100
02:00000A66 67FE            	   869:             beq.s *               * branch if Z set
02:00000A68 087900010000F101	   870:             bchg.b #1,$F101       *
02:00000A70 66FE            	   871:             bne.s *               * branch if Z clear
02:00000A72 087900070000F102	   872:             bchg.b #7,$F102       *
02:00000A7A 67FE            	   873:             beq.s *               * branch if Z set
02:00000A7C 307C0100        	   874:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A80 0C180001        	   875:             cmpi.b #$01,(a0)+
02:00000A84 66FE            	   876:             bne.s *               * branch if Z clear
02:00000A86 0C1800FC        	   877:             cmpi.b #$FC,(a0)+
02:00000A8A 66FE            	   878:             bne.s *               * branch if Z clear
02:00000A8C 0C180080        	   879:             cmpi.b #$80,(a0)+
02:00000A90 66FE            	   880:             bne.s *               * branch if Z clear
                            	   881: 
                            	   882: 
                            	   883: * Bit Number.s Dynamic
                            	   884: 
                            	   885: *             EA = Dn  - LONG only
02:00000A92 203C80000001    	   886:             move.l #$80000001,d0      * populate test data
02:00000A98 7A00            	   887:             move.l #0,d5              * populate bit.s number to test
02:00000A9A 7C01            	   888:             move.l #1,d6              * populate bit.s number to test
02:00000A9C 7E1F            	   889:             move.l #31,d7              * populate bit.s number to test
                            	   890: 
02:00000A9E 0B40            	   891:             bchg.l d5,d0
02:00000AA0 67FE            	   892:             beq.s *               * branch if Z set
02:00000AA2 0D40            	   893:             bchg.l d6,d0              *
02:00000AA4 66FE            	   894:             bne.s *               * branch if Z clear
02:00000AA6 0F40            	   895:             bchg.l d7,d0             *
02:00000AA8 67FE            	   896:             beq.s *               * branch if Z set
02:00000AAA 0C8000000002    	   897:             cmpi.l #$00000002,d0
02:00000AB0 66FE            	   898:             bne.s *               * branch if Z clear
                            	   899: 
                            	   900: 
                            	   901: *             EA = (An)  - BYTE only
02:00000AB2 7A00            	   902:             move.l #0,d5              * populate bit.s number to test
02:00000AB4 7C01            	   903:             move.l #1,d6              * populate bit.s number to test
02:00000AB6 7E07            	   904:             move.l #7,d7              * populate bit.s number to test
02:00000AB8 307C0100        	   905:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000ABC 10BC0081        	   906:             move.b #$81,(a0)          * populate test data
02:00000AC0 1210            	   907:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:00000AC2 0B50            	   908:             bchg.b d5,(a0)
02:00000AC4 67FE            	   909:             beq.s *               * branch if Z set
02:00000AC6 0D50            	   910:             bchg.b d6,(a0)            *
02:00000AC8 66FE            	   911:             bne.s *               * branch if Z clear
02:00000ACA 0F50            	   912:             bchg.b d7,(a0)            *
02:00000ACC 67FE            	   913:             beq.s *               * branch if Z set
02:00000ACE 0C100002        	   914:             cmpi.b #$02,(a0)
02:00000AD2 66FE            	   915:             bne.s *               * branch if Z clear
                            	   916: 
                            	   917: 
                            	   918: *             EA = (An)+  - BYTE only
02:00000AD4 307C0100        	   919:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000AD8 10FC0001        	   920:             move.b #$01,(a0)+         * populate test data
02:00000ADC 10FC00FC        	   921:             move.b #$FC,(a0)+         * populate test data
02:00000AE0 10FC0080        	   922:             move.b #$80,(a0)+         * populate test data
02:00000AE4 307C0100        	   923:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000AE8 0B58            	   924:             bchg.b d5,(a0)+
02:00000AEA 67FE            	   925:             beq.s *               * branch if Z set
02:00000AEC 0D58            	   926:             bchg.b d6,(a0)+           *
02:00000AEE 66FE            	   927:             bne.s *               * branch if Z clear
02:00000AF0 0F58            	   928:             bchg.b d7,(a0)+           *
02:00000AF2 67FE            	   929:             beq.s *               * branch if Z set
02:00000AF4 307C0100        	   930:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000AF8 4A18            	   931:             cmpi.b #$00,(a0)+
02:00000AFA 66FE            	   932:             bne.s *               * branch if Z clear
02:00000AFC 0C1800FE        	   933:             cmpi.b #$FE,(a0)+
02:00000B00 66FE            	   934:             bne.s *               * branch if Z clear
02:00000B02 4A18            	   935:             cmpi.b #$00,(a0)+
02:00000B04 66FE            	   936:             bne.s *               * branch if Z clear
                            	   937: 
                            	   938: *             EA = -(An)  - BYTE only
02:00000B06 307C0100        	   939:             move.l #$00000100,a0      * point to memory to address
02:00000B0A 10FC0080        	   940:             move.b #$80,(a0)+         * populate test data
02:00000B0E 10FC00FC        	   941:             move.b #$FC,(a0)+         * populate test data
02:00000B12 10FC0001        	   942:             move.b #$01,(a0)+         * populate test data
02:00000B16 307C0103        	   943:             move.l #$00000103,a0      * point to memory to address
02:00000B1A 0B60            	   944:             bchg.b d5,-(a0)
02:00000B1C 67FE            	   945:             beq.s *               * branch if Z set
02:00000B1E 0D60            	   946:             bchg.b d6,-(a0)           *
02:00000B20 66FE            	   947:             bne.s *               * branch if Z clear
02:00000B22 0F60            	   948:             bchg.b d7,-(a0)           *
02:00000B24 67FE            	   949:             beq.s *               * branch if Z set
02:00000B26 307C0103        	   950:             move.l #$00000103,a0      * point to memory to address 0x100
02:00000B2A 4A20            	   951:             cmpi.b #$00,-(a0)
02:00000B2C 66FE            	   952:             bne.s *               * branch if Z clear
02:00000B2E 0C2000FE        	   953:             cmpi.b #$FE,-(a0)
02:00000B32 66FE            	   954:             bne.s *               * branch if Z clear
02:00000B34 4A20            	   955:             cmpi.b #$00,-(a0)
02:00000B36 66FE            	   956:             bne.s *               * branch if Z clear
                            	   957: 
                            	   958: *             EA = n(An)  - BYTE only
02:00000B38 307C0100        	   959:             move.l #$00000100,a0      * point to memory to address
02:00000B3C 10FC0001        	   960:             move.b #$01,(a0)+         * populate test data
02:00000B40 10FC00FC        	   961:             move.b #$FC,(a0)+         * populate test data
02:00000B44 10FC0080        	   962:             move.b #$80,(a0)+         * populate test data
02:00000B48 307C0100        	   963:             move.l #$00000100,a0      * point to memory to address
02:00000B4C 0B50            	   964:             bchg.b d5,0(a0)
02:00000B4E 67FE            	   965:             beq.s *               * branch if Z set
02:00000B50 0D680001        	   966:             bchg.b d6,1(a0)           *
02:00000B54 66FE            	   967:             bne.s *               * branch if Z clear
02:00000B56 0F680002        	   968:             bchg.b d7,2(a0)           *
02:00000B5A 67FE            	   969:             beq.s *               * branch if Z set
02:00000B5C 307C0100        	   970:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000B60 4A18            	   971:             cmpi.b #$00,(a0)+
02:00000B62 66FE            	   972:             bne.s *               * branch if Z clear
02:00000B64 0C1800FE        	   973:             cmpi.b #$FE,(a0)+
02:00000B68 66FE            	   974:             bne.s *               * branch if Z clear
02:00000B6A 4A18            	   975:             cmpi.b #$00,(a0)+
02:00000B6C 66FE            	   976:             bne.s *               * branch if Z clear
                            	   977: 
                            	   978: *             EA = n(An,R.W)  - BYTE only
02:00000B6E 307C0100        	   979:             move.l #$00000100,a0      * point to memory to address
02:00000B72 93C9            	   980:             move.l #$00000000,a1      * point to memory to address
02:00000B74 347C0001        	   981:             move.l #$00000001,a2      * point to memory to address
02:00000B78 7000            	   982:             moveq  #$00000000,d0      * point to memory to address
02:00000B7A 7201            	   983:             moveq  #$00000001,d1      * point to memory to address
02:00000B7C 0B700000        	   984:             bchg.b d5,0(a0,d0.w)
02:00000B80 66FE            	   985:             bne.s *               * branch if Z clear
02:00000B82 0D701000        	   986:             bchg.b d6,0(a0,d1.w)      *
02:00000B86 67FE            	   987:             beq.s *               * branch if Z set
02:00000B88 0F701001        	   988:             bchg.b d7,1(a0,d1.w)      *
02:00000B8C 66FE            	   989:             bne.s *               * branch if Z clear
                            	   990: *             EA = n(An,R.L)  - BYTE only
02:00000B8E 0B700800        	   991:             bchg.b d5,0(a0,d0.l)
02:00000B92 67FE            	   992:             beq.s *               * branch if Z set
02:00000B94 0D701800        	   993:             bchg.b d6,0(a0,d1.l)      *
02:00000B98 66FE            	   994:             bne.s *               * branch if Z clear
02:00000B9A 0F701801        	   995:             bchg.b d7,1(a0,d1.l)      *
02:00000B9E 67FE            	   996:             beq.s *               * branch if Z set
                            	   997: *             EA = n(An,A.W)  - BYTE only
02:00000BA0 0B709000        	   998:             bchg.b d5,0(a0,a1.w)
02:00000BA4 66FE            	   999:             bne.s *               * branch if Z clear
02:00000BA6 0D70A000        	  1000:             bchg.b d6,0(a0,a2.w)      *
02:00000BAA 67FE            	  1001:             beq.s *               * branch if Z set
02:00000BAC 0F70A001        	  1002:             bchg.b d7,1(a0,a2.w)      *
02:00000BB0 66FE            	  1003:             bne.s *               * branch if Z clear
                            	  1004: *             EA = n(An,A.L)  - BYTE only
02:00000BB2 0B709800        	  1005:             bchg.b d5,0(a0,a1.l)
02:00000BB6 67FE            	  1006:             beq.s *               * branch if Z set
02:00000BB8 0D70A800        	  1007:             bchg.b d6,0(a0,a2.l)      *
02:00000BBC 66FE            	  1008:             bne.s *               * branch if Z clear
02:00000BBE 0F70A801        	  1009:             bchg.b d7,1(a0,a2.l)      *
02:00000BC2 67FE            	  1010:             beq.s *               * branch if Z set
02:00000BC4 4A18            	  1011:             cmpi.b #$00,(a0)+
02:00000BC6 66FE            	  1012:             bne.s *               * branch if Z clear
                            	  1013: 
                            	  1014: *             EA = x.W  - BYTE only
02:00000BC8 0B780100        	  1015:             bchg.b d5,$0100
02:00000BCC 66FE            	  1016:             bne.s *               * branch if Z clear
02:00000BCE 0D780101        	  1017:             bchg.b d6,$0101           *
02:00000BD2 67FE            	  1018:             beq.s *               * branch if Z set
02:00000BD4 0F780102        	  1019:             bchg.b d7,$0102           *
02:00000BD8 66FE            	  1020:             bne.s *               * branch if Z clear
02:00000BDA 0C1800FC        	  1021:             cmpi.b #$FC,(a0)+
02:00000BDE 66FE            	  1022:             bne.s *               * branch if Z clear
                            	  1023: 
                            	  1024: *             EA = x.L  - BYTE only
02:00000BE0 207C0000F100    	  1025:             move.l #$F100,a0      * point to memory to address 0x100
02:00000BE6 10FC0001        	  1026:             move.b #$01,(a0)+         * populate test data
02:00000BEA 10FC00FC        	  1027:             move.b #$FC,(a0)+         * populate test data
02:00000BEE 10FC0080        	  1028:             move.b #$80,(a0)+         * populate test data
02:00000BF2 0B790000F100    	  1029:             bchg.b d5,$F100
02:00000BF8 67FE            	  1030:             beq.s *               * branch if Z set
02:00000BFA 0D790000F101    	  1031:             bchg.b d6,$F101       *
02:00000C00 66FE            	  1032:             bne.s *               * branch if Z clear
02:00000C02 0F790000F102    	  1033:             bchg.b d7,$F102       *
02:00000C08 67FE            	  1034:             beq.s *               * branch if Z set
02:00000C0A 207C0000F101    	  1035:             move.l #$F101,a0      * point to memory to address 0x100
02:00000C10 0C1000FE        	  1036:             cmpi.b #$FE,(a0)
02:00000C14 66FE            	  1037:             bne.s *               * branch if Z clear
                            	  1038: 
                            	  1039: 
02:00000C16 4E75            	  1040:     rts
                            	  1041: 
                            	  1042: *-----------------------------------------------------------
                            	  1043: *-----------------------------------------------------------
                            	  1044: * OPCODE : BCLR
                            	  1045: *-----------------------------------------------------------
                            	  1046: *-----------------------------------------------------------
                            	  1047: op_BCLR:
                            	  1048: 
                            	  1049: 
                            	  1050: *  Bit Number.s Static
                            	  1051: 
                            	  1052: *             EA = Dn  - LONG only
02:00000C18 203CFF0000FF    	  1053:             move.l #$FF0000FF,d0      * populate test data
02:00000C1E 08800000        	  1054:             bclr.l #0,d0
02:00000C22 67FE            	  1055:             beq.s *               * branch if Z set
02:00000C24 08800001        	  1056:             bclr.l #1,d0              *
02:00000C28 67FE            	  1057:             beq.s *               * branch if Z set
02:00000C2A 0880000F        	  1058:             bclr.l #15,d0             *
02:00000C2E 66FE            	  1059:             bne.s *               * branch if Z clear
02:00000C30 0880001F        	  1060:             bclr.l #31,d0             *
02:00000C34 67FE            	  1061:             beq.s *               * branch if Z set
02:00000C36 0C807F0000FC    	  1062:             cmpi.l #$7F0000FC,d0
02:00000C3C 66FE            	  1063:             bne.s *               * branch if Z clear
                            	  1064: 
                            	  1065: 
                            	  1066: *             EA = (An)  - BYTE only
02:00000C3E 307C0100        	  1067:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C42 10BC000F        	  1068:             move.b #$0F,(a0)          * populate test data
02:00000C46 08900000        	  1069:             bclr.b #0,(a0)
02:00000C4A 67FE            	  1070:             beq.s *               * branch if Z set
02:00000C4C 08900007        	  1071:             bclr.b #7,(a0)            *
02:00000C50 66FE            	  1072:             bne.s *               * branch if Z clear
02:00000C52 0C10000E        	  1073:             cmpi.b #$0E,(a0)
02:00000C56 66FE            	  1074:             bne.s *               * branch if Z clear
                            	  1075: 
                            	  1076: *             EA = (An)+  - BYTE only
02:00000C58 307C0100        	  1077:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C5C 10FC0001        	  1078:             move.b #$01,(a0)+         * populate test data
02:00000C60 4218            	  1079:             move.b #$00,(a0)+         * populate test data
02:00000C62 307C0100        	  1080:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C66 08980000        	  1081:             bclr.b #0,(a0)+
02:00000C6A 67FE            	  1082:             beq.s *               * branch if Z set
02:00000C6C 08980001        	  1083:             bclr.b #1,(a0)+           *
02:00000C70 66FE            	  1084:             bne.s *               * branch if Z clear
02:00000C72 307C0100        	  1085:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C76 4A18            	  1086:             cmpi.b #$00,(a0)+
02:00000C78 66FE            	  1087:             bne.s *               * branch if Z clear
02:00000C7A 4A18            	  1088:             cmpi.b #$00,(a0)+
02:00000C7C 66FE            	  1089:             bne.s *               * branch if Z clear
                            	  1090: 
                            	  1091: 
                            	  1092: *             EA = -(An)  - BYTE only
02:00000C7E 307C0100        	  1093:             move.l #$00000100,a0      * point to memory to address
02:00000C82 10FC0001        	  1094:             move.b #$01,(a0)+         * populate test data
02:00000C86 10FC0080        	  1095:             move.b #$80,(a0)+         * populate test data
02:00000C8A 08A00007        	  1096:             bclr.b #7,-(a0)
02:00000C8E 67FE            	  1097:             beq.s *               * branch if Z set
02:00000C90 08A00000        	  1098:             bclr.b #0,-(a0)           *
02:00000C94 67FE            	  1099:             beq.s *               * branch if Z set
02:00000C96 307C0102        	  1100:             move.l #$00000102,a0      * point to memory to address 0x100
02:00000C9A 4A20            	  1101:             cmpi.b #$00,-(a0)
02:00000C9C 66FE            	  1102:             bne.s *               * branch if Z clear
02:00000C9E 4A20            	  1103:             cmpi.b #$00,-(a0)
02:00000CA0 66FE            	  1104:             bne.s *               * branch if Z clear
                            	  1105: 
                            	  1106: 
                            	  1107: *             EA = n(An)  - BYTE only
02:00000CA2 307C0100        	  1108:             move.l #$00000100,a0      * point to memory to address
02:00000CA6 10FC00FF        	  1109:             move.b #$FF,(a0)+         * populate test data
02:00000CAA 10FC00FF        	  1110:             move.b #$FF,(a0)+         * populate test data
02:00000CAE 307C0100        	  1111:             move.l #$00000100,a0      * point to memory to address
02:00000CB2 08900000        	  1112:             bclr.b #0,0(a0)
02:00000CB6 67FE            	  1113:             beq.s *               * branch if Z set
02:00000CB8 08A800040001    	  1114:             bclr.b #4,1(a0)           *
02:00000CBE 67FE            	  1115:             beq.s *               * branch if Z set
02:00000CC0 307C0100        	  1116:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000CC4 0C1800FE        	  1117:             cmpi.b #$FE,(a0)+
02:00000CC8 66FE            	  1118:             bne.s *               * branch if Z clear
02:00000CCA 0C1800EF        	  1119:             cmpi.b #$EF,(a0)+
02:00000CCE 66FE            	  1120:             bne.s *               * branch if Z clear
                            	  1121: 
                            	  1122: 
                            	  1123: *             EA = n(An,D.W)  - BYTE only
02:00000CD0 307C0100        	  1124:             move.l #$00000100,a0      * point to memory to address
02:00000CD4 93C9            	  1125:             move.l #$00000000,a1      * point to memory to address
02:00000CD6 347C0001        	  1126:             move.l #$00000001,a2      * point to memory to address
02:00000CDA 7000            	  1127:             moveq  #$00000000,d0      * point to memory to address
02:00000CDC 7201            	  1128:             moveq  #$00000001,d1      * point to memory to address
02:00000CDE 10FC00FF        	  1129:             move.b #$FF,(a0)+         * populate test data
02:00000CE2 10FC00FF        	  1130:             move.b #$FF,(a0)+         * populate test data
02:00000CE6 307C0100        	  1131:             move.l #$00000100,a0      * point to memory to address
02:00000CEA 08B000000000    	  1132:             bclr.b #0,0(a0,d0.w)
02:00000CF0 67FE            	  1133:             beq.s *               * branch if Z set
02:00000CF2 08B000011000    	  1134:             bclr.b #1,0(a0,d1.w)      *
02:00000CF8 67FE            	  1135:             beq.s *               * branch if Z set
02:00000CFA 08B000021001    	  1136:             bclr.b #2,1(a0,d1.w)      *
02:00000D00 66FE            	  1137:             bne.s *               * branch if Z clear
                            	  1138: *             EA = n(An,D.L)  - BYTE only
02:00000D02 08B000030800    	  1139:             bclr.b #3,0(a0,d0.l)
02:00000D08 67FE            	  1140:             beq.s *               * branch if Z set
02:00000D0A 08B000041800    	  1141:             bclr.b #4,0(a0,d1.l)      *
02:00000D10 67FE            	  1142:             beq.s *               * branch if Z set
02:00000D12 08B000051801    	  1143:             bclr.b #5,1(a0,d1.l)      *
02:00000D18 66FE            	  1144:             bne.s *               * branch if Z clear
                            	  1145: *             EA = n(An,A.W)  - BYTE only
02:00000D1A 08B000069000    	  1146:             bclr.b #6,0(a0,a1.w)
02:00000D20 67FE            	  1147:             beq.s *               * branch if Z set
02:00000D22 08B00001A000    	  1148:             bclr.b #1,0(a0,a2.w)      *
02:00000D28 66FE            	  1149:             bne.s *               * branch if Z clear
02:00000D2A 08B00007A001    	  1150:             bclr.b #7,1(a0,a2.w)      *
02:00000D30 67FE            	  1151:             beq.s *               * branch if Z set
                            	  1152: *             EA = n(An,A.L)  - BYTE only
02:00000D32 08B000009800    	  1153:             bclr.b #0,0(a0,a1.l)
02:00000D38 66FE            	  1154:             bne.s *               * branch if Z clear
02:00000D3A 08B00000A800    	  1155:             bclr.b #0,0(a0,a2.l)      *
02:00000D40 67FE            	  1156:             beq.s *               * branch if Z set
02:00000D42 08B00001A801    	  1157:             bclr.b #1,1(a0,a2.l)      *
02:00000D48 66FE            	  1158:             bne.s *               * branch if Z clear
02:00000D4A 307C0100        	  1159:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000D4E 0C1800B6        	  1160:             cmpi.b #$B6,(a0)+
02:00000D52 66FE            	  1161:             bne.s *               * branch if Z clear
02:00000D54 0C1800EC        	  1162:             cmpi.b #$EC,(a0)+
02:00000D58 66FE            	  1163:             bne.s *               * branch if Z clear
02:00000D5A 0C180059        	  1164:             cmpi.b #$59,(a0)+
02:00000D5E 67FE            	  1165:             beq.s *               * branch if Z set
                            	  1166: 
                            	  1167: 
                            	  1168: *             EA = x.W  - BYTE only
02:00000D60 307C0100        	  1169:             move.l #$00000100,a0      * point to memory to address
02:00000D64 10FC00FF        	  1170:             move.b #$FF,(a0)+         * populate test data
02:00000D68 08B800000100    	  1171:             bclr.b #0,$0100
02:00000D6E 67FE            	  1172:             beq.s *               * branch if Z set
02:00000D70 08B800010100    	  1173:             bclr.b #1,$0100           *
02:00000D76 67FE            	  1174:             beq.s *               * branch if Z set
02:00000D78 307C0100        	  1175:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000D7C 0C1800FC        	  1176:             cmpi.b #$FC,(a0)+
02:00000D80 66FE            	  1177:             bne.s *               * branch if Z clear
                            	  1178: 
                            	  1179: 
                            	  1180: *             EA = x.L  - BYTE only
02:00000D82 207C0000F100    	  1181:             move.l #$F100,a0      * point to memory to address 0x100
02:00000D88 10BC00FF        	  1182:             move.b #$FF,(a0)          * populate test data
02:00000D8C 08B900000000F100	  1183:             bclr.b #0,$F100
02:00000D94 67FE            	  1184:             beq.s *               * branch if Z set
02:00000D96 08B900010000F100	  1185:             bclr.b #1,$F100       *
02:00000D9E 67FE            	  1186:             beq.s *               * branch if Z set
02:00000DA0 08B900020000F100	  1187:             bclr.b #2,$F100       *
02:00000DA8 67FE            	  1188:             beq.s *               * branch if Z set
02:00000DAA 207C0000F100    	  1189:             move.l #$F100,a0      * point to memory to address 0x100
02:00000DB0 0C1800F8        	  1190:             cmpi.b #$F8,(a0)+
02:00000DB4 66FE            	  1191:             bne.s *               * branch if Z clear
                            	  1192: 
                            	  1193: 
                            	  1194: * Bit Number.s Dynamic
                            	  1195: 
                            	  1196: *             EA = Dn  - LONG only
02:00000DB6 203CFF00FF00    	  1197:             move.l #$FF00FF00,d0      * populate test data
02:00000DBC 7A00            	  1198:             move.l #0,d5              * populate bit.s number to test
02:00000DBE 7C01            	  1199:             move.l #1,d6              * populate bit.s number to test
02:00000DC0 7E1F            	  1200:             move.l #31,d7              * populate bit.s number to test
                            	  1201: 
02:00000DC2 0B80            	  1202:             bclr.l d5,d0
02:00000DC4 66FE            	  1203:             bne.s *               * branch if Z clear
02:00000DC6 0D80            	  1204:             bclr.l d6,d0              *
02:00000DC8 66FE            	  1205:             bne.s *               * branch if Z clear
02:00000DCA 0F80            	  1206:             bclr.l d7,d0             *
02:00000DCC 67FE            	  1207:             beq.s *               * branch if Z set
02:00000DCE 0C807F00FF00    	  1208:             cmpi.l #$7F00FF00,d0
02:00000DD4 66FE            	  1209:             bne.s *               * branch if Z clear
                            	  1210: 
                            	  1211: 
                            	  1212: *             EA = (An)  - BYTE only
02:00000DD6 7A00            	  1213:             move.l #0,d5              * populate bit.s number to test
02:00000DD8 7C01            	  1214:             move.l #1,d6              * populate bit.s number to test
02:00000DDA 7E07            	  1215:             move.l #7,d7              * populate bit.s number to test
02:00000DDC 307C0100        	  1216:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000DE0 10BC0081        	  1217:             move.b #$81,(a0)          * populate test data
02:00000DE4 0B90            	  1218:             bclr.b d5,(a0)
02:00000DE6 67FE            	  1219:             beq.s *               * branch if Z set
02:00000DE8 0D90            	  1220:             bclr.b d6,(a0)            *
02:00000DEA 66FE            	  1221:             bne.s *               * branch if Z clear
02:00000DEC 0F90            	  1222:             bclr.b d7,(a0)            *
02:00000DEE 67FE            	  1223:             beq.s *               * branch if Z set
02:00000DF0 4A10            	  1224:             cmpi.b #$00,(a0)
02:00000DF2 66FE            	  1225:             bne.s *               * branch if Z clear
                            	  1226: 
                            	  1227: 
                            	  1228: *             EA = (An)+  - BYTE only
02:00000DF4 307C0100        	  1229:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000DF8 10FC0001        	  1230:             move.b #$01,(a0)+         * populate test data
02:00000DFC 10FC00FC        	  1231:             move.b #$FC,(a0)+         * populate test data
02:00000E00 10FC0080        	  1232:             move.b #$80,(a0)+         * populate test data
02:00000E04 307C0100        	  1233:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000E08 0B98            	  1234:             bclr.b d5,(a0)+
02:00000E0A 67FE            	  1235:             beq.s *               * branch if Z set
02:00000E0C 0D98            	  1236:             bclr.b d6,(a0)+           *
02:00000E0E 66FE            	  1237:             bne.s *               * branch if Z clear
02:00000E10 0F98            	  1238:             bclr.b d7,(a0)+           *
02:00000E12 67FE            	  1239:             beq.s *               * branch if Z set
02:00000E14 307C0100        	  1240:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000E18 4A18            	  1241:             cmpi.b #$00,(a0)+
02:00000E1A 66FE            	  1242:             bne.s *               * branch if Z clear
02:00000E1C 0C1800FC        	  1243:             cmpi.b #$FC,(a0)+
02:00000E20 66FE            	  1244:             bne.s *               * branch if Z clear
02:00000E22 4A18            	  1245:             cmpi.b #$00,(a0)+
02:00000E24 66FE            	  1246:             bne.s *               * branch if Z clear
                            	  1247: 
                            	  1248: *             EA = -(An)  - BYTE only
02:00000E26 307C0100        	  1249:             move.l #$00000100,a0      * point to memory to address
02:00000E2A 10FC0080        	  1250:             move.b #$80,(a0)+         * populate test data
02:00000E2E 10FC00FC        	  1251:             move.b #$FC,(a0)+         * populate test data
02:00000E32 10FC0001        	  1252:             move.b #$01,(a0)+         * populate test data
02:00000E36 307C0103        	  1253:             move.l #$00000103,a0      * point to memory to address
02:00000E3A 0BA0            	  1254:             bclr.b d5,-(a0)
02:00000E3C 67FE            	  1255:             beq.s *               * branch if Z set
02:00000E3E 0DA0            	  1256:             bclr.b d6,-(a0)           *
02:00000E40 66FE            	  1257:             bne.s *               * branch if Z clear
02:00000E42 0FA0            	  1258:             bclr.b d7,-(a0)           *
02:00000E44 67FE            	  1259:             beq.s *               * branch if Z set
02:00000E46 307C0103        	  1260:             move.l #$00000103,a0      * point to memory to address 0x100
02:00000E4A 4A20            	  1261:             cmpi.b #$00,-(a0)
02:00000E4C 66FE            	  1262:             bne.s *               * branch if Z clear
02:00000E4E 0C2000FC        	  1263:             cmpi.b #$FC,-(a0)
02:00000E52 66FE            	  1264:             bne.s *               * branch if Z clear
02:00000E54 4A20            	  1265:             cmpi.b #$00,-(a0)
02:00000E56 66FE            	  1266:             bne.s *               * branch if Z clear
                            	  1267: 
                            	  1268: *             EA = n(An)  - BYTE only
02:00000E58 307C0100        	  1269:             move.l #$00000100,a0      * point to memory to address
02:00000E5C 10FC0001        	  1270:             move.b #$01,(a0)+         * populate test data
02:00000E60 10FC00FC        	  1271:             move.b #$FC,(a0)+         * populate test data
02:00000E64 10FC0080        	  1272:             move.b #$80,(a0)+         * populate test data
02:00000E68 307C0100        	  1273:             move.l #$00000100,a0      * point to memory to address
02:00000E6C 0B90            	  1274:             bclr.b d5,0(a0)
02:00000E6E 67FE            	  1275:             beq.s *               * branch if Z set
02:00000E70 0DA80001        	  1276:             bclr.b d6,1(a0)           *
02:00000E74 66FE            	  1277:             bne.s *               * branch if Z clear
02:00000E76 0FA80002        	  1278:             bclr.b d7,2(a0)           *
02:00000E7A 67FE            	  1279:             beq.s *               * branch if Z set
02:00000E7C 307C0100        	  1280:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000E80 4A18            	  1281:             cmpi.b #$00,(a0)+
02:00000E82 66FE            	  1282:             bne.s *               * branch if Z clear
02:00000E84 0C1800FC        	  1283:             cmpi.b #$FC,(a0)+
02:00000E88 66FE            	  1284:             bne.s *               * branch if Z clear
02:00000E8A 4A18            	  1285:             cmpi.b #$00,(a0)+
02:00000E8C 66FE            	  1286:             bne.s *               * branch if Z clear
                            	  1287: 
                            	  1288: *             EA = n(An,R.W)  - BYTE only
02:00000E8E 307C0100        	  1289:             move.l #$00000100,a0      * point to memory to address
02:00000E92 10FC00FF        	  1290:             move.b #$FF,(a0)+         * populate test data
02:00000E96 10FC00FF        	  1291:             move.b #$FF,(a0)+         * populate test data
02:00000E9A 10FC00FF        	  1292:             move.b #$FF,(a0)+         * populate test data
02:00000E9E 307C0103        	  1293:             move.l #$00000103,a0      * point to memory to address
02:00000EA2 307C0100        	  1294:             move.l #$00000100,a0      * point to memory to address
02:00000EA6 93C9            	  1295:             move.l #$00000000,a1      * point to memory to address
02:00000EA8 347C0001        	  1296:             move.l #$00000001,a2      * point to memory to address
02:00000EAC 7000            	  1297:             moveq  #$00000000,d0      * point to memory to address
02:00000EAE 7201            	  1298:             moveq  #$00000001,d1      * point to memory to address
02:00000EB0 0BB00000        	  1299:             bclr.b d5,0(a0,d0.w)
02:00000EB4 67FE            	  1300:             beq.s *               * branch if Z set
02:00000EB6 0DB01000        	  1301:             bclr.b d6,0(a0,d1.w)      *
02:00000EBA 67FE            	  1302:             beq.s *               * branch if Z set
02:00000EBC 0FB01001        	  1303:             bclr.b d7,1(a0,d1.w)      *
02:00000EC0 67FE            	  1304:             beq.s *               * branch if Z set
                            	  1305: *             EA = n(An,R.L)  - BYTE only
02:00000EC2 0BB00800        	  1306:             bclr.b d5,0(a0,d0.l)
02:00000EC6 66FE            	  1307:             bne.s *               * branch if Z clear
02:00000EC8 0DB01800        	  1308:             bclr.b d6,0(a0,d1.l)      *
02:00000ECC 66FE            	  1309:             bne.s *               * branch if Z clear
02:00000ECE 0FB01801        	  1310:             bclr.b d7,1(a0,d1.l)      *
02:00000ED2 66FE            	  1311:             bne.s *               * branch if Z clear
                            	  1312: *             EA = n(An,A.W)  - BYTE only
02:00000ED4 0BB09000        	  1313:             bclr.b d5,0(a0,a1.w)
02:00000ED8 66FE            	  1314:             bne.s *               * branch if Z clear
02:00000EDA 0DB0A000        	  1315:             bclr.b d6,0(a0,a2.w)      *
02:00000EDE 66FE            	  1316:             bne.s *               * branch if Z clear
02:00000EE0 0FB0A001        	  1317:             bclr.b d7,1(a0,a2.w)      *
02:00000EE4 66FE            	  1318:             bne.s *               * branch if Z clear
                            	  1319: *             EA = n(An,A.L)  - BYTE only
02:00000EE6 0BB09800        	  1320:             bclr.b d5,0(a0,a1.l)
02:00000EEA 66FE            	  1321:             bne.s *               * branch if Z clear
02:00000EEC 0DB0A800        	  1322:             bclr.b d6,0(a0,a2.l)      *
02:00000EF0 66FE            	  1323:             bne.s *               * branch if Z clear
02:00000EF2 0FB0A801        	  1324:             bclr.b d7,1(a0,a2.l)      *
02:00000EF6 66FE            	  1325:             bne.s *               * branch if Z clear
02:00000EF8 307C0100        	  1326:             move.l #$00000100,a0      * point to memory to address
02:00000EFC 0C1000FE        	  1327:             cmpi.b #$FE,(a0)
02:00000F00 66FE            	  1328:             bne.s *               * branch if Z clear
                            	  1329: 
                            	  1330: *             EA = x.W  - BYTE only
02:00000F02 307C0100        	  1331:             move.l #$00000100,a0      * point to memory to address
02:00000F06 10FC00FF        	  1332:             move.b #$FF,(a0)+         * populate test data
02:00000F0A 10FC00FF        	  1333:             move.b #$FF,(a0)+         * populate test data
02:00000F0E 10FC00FF        	  1334:             move.b #$FF,(a0)+         * populate test data
02:00000F12 0BB80100        	  1335:             bclr.b d5,$0100
02:00000F16 67FE            	  1336:             beq.s *               * branch if Z set
02:00000F18 0DB80101        	  1337:             bclr.b d6,$0101           *
02:00000F1C 67FE            	  1338:             beq.s *               * branch if Z set
02:00000F1E 0FB80102        	  1339:             bclr.b d7,$0102           *
02:00000F22 67FE            	  1340:             beq.s *               * branch if Z set
02:00000F24 307C0100        	  1341:             move.l #$00000100,a0      * point to memory to address
02:00000F28 0C1800FE        	  1342:             cmpi.b #$FE,(a0)+
02:00000F2C 66FE            	  1343:             bne.s *               * branch if Z clear
                            	  1344: 
                            	  1345: *             EA = x.L  - BYTE only
02:00000F2E 207C0000F100    	  1346:             move.l #$F100,a0      * point to memory to address 0x100
02:00000F34 10FC0001        	  1347:             move.b #$01,(a0)+         * populate test data
02:00000F38 10FC00FC        	  1348:             move.b #$FC,(a0)+         * populate test data
02:00000F3C 10FC0080        	  1349:             move.b #$80,(a0)+         * populate test data
02:00000F40 0BB90000F100    	  1350:             bclr.b d5,$F100
02:00000F46 67FE            	  1351:             beq.s *               * branch if Z set
02:00000F48 0DB90000F101    	  1352:             bclr.b d6,$F101       *
02:00000F4E 66FE            	  1353:             bne.s *               * branch if Z clear
02:00000F50 0FB90000F102    	  1354:             bclr.b d7,$F102       *
02:00000F56 67FE            	  1355:             beq.s *               * branch if Z set
02:00000F58 207C0000F101    	  1356:             move.l #$F101,a0      * point to memory to address 0x100
02:00000F5E 0C1000FC        	  1357:             cmpi.b #$FC,(a0)
02:00000F62 66FE            	  1358:             bne.s *               * branch if Z clear
                            	  1359: 
                            	  1360: 
                            	  1361: 
02:00000F64 4E75            	  1362:     rts
                            	  1363: 
                            	  1364: *-----------------------------------------------------------
                            	  1365: *-----------------------------------------------------------
                            	  1366: * OPCODE : BSET
                            	  1367: *-----------------------------------------------------------
                            	  1368: *-----------------------------------------------------------
                            	  1369: op_BSET:
                            	  1370: 
                            	  1371: 
                            	  1372: *  Bit Number.s Static
                            	  1373: 
                            	  1374: *             EA = Dn  - LONG only
02:00000F66 7000            	  1375:             moveq  #$00000000,d0      * populate test data
02:00000F68 08C00000        	  1376:             bset.l #0,d0
02:00000F6C 66FE            	  1377:             bne.s *               * branch if Z clear
02:00000F6E 08C00001        	  1378:             bset.l #1,d0              *
02:00000F72 66FE            	  1379:             bne.s *               * branch if Z clear
02:00000F74 08C0000F        	  1380:             bset.l #15,d0             *
02:00000F78 66FE            	  1381:             bne.s *               * branch if Z clear
02:00000F7A 08C0001F        	  1382:             bset.l #31,d0             *
02:00000F7E 66FE            	  1383:             bne.s *               * branch if Z clear
02:00000F80 0C8080008003    	  1384:             cmpi.l #$80008003,d0
02:00000F86 66FE            	  1385:             bne.s *               * branch if Z clear
                            	  1386: 
                            	  1387: 
                            	  1388: *             EA = (An)  - BYTE only
02:00000F88 307C0100        	  1389:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000F8C 4210            	  1390:             move.b #$00,(a0)          * populate test data
02:00000F8E 08D00000        	  1391:             bset.b #0,(a0)
02:00000F92 66FE            	  1392:             bne.s *               * branch if Z clear
02:00000F94 08D00007        	  1393:             bset.b #7,(a0)            *
02:00000F98 66FE            	  1394:             bne.s *               * branch if Z clear
02:00000F9A 0C100081        	  1395:             cmpi.b #$81,(a0)
02:00000F9E 66FE            	  1396:             bne.s *               * branch if Z clear
                            	  1397: 
                            	  1398: *             EA = (An)+  - BYTE only
02:00000FA0 307C0100        	  1399:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000FA4 4218            	  1400:             move.b #$00,(a0)+         * populate test data
02:00000FA6 4218            	  1401:             move.b #$00,(a0)+         * populate test data
02:00000FA8 307C0100        	  1402:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000FAC 08D80000        	  1403:             bset.b #0,(a0)+
02:00000FB0 66FE            	  1404:             bne.s *               * branch if Z clear
02:00000FB2 08D80001        	  1405:             bset.b #1,(a0)+           *
02:00000FB6 66FE            	  1406:             bne.s *               * branch if Z clear
02:00000FB8 307C0100        	  1407:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000FBC 0C180001        	  1408:             cmpi.b #$01,(a0)+
02:00000FC0 66FE            	  1409:             bne.s *               * branch if Z clear
02:00000FC2 0C180002        	  1410:             cmpi.b #$02,(a0)+
02:00000FC6 66FE            	  1411:             bne.s *               * branch if Z clear
                            	  1412: 
                            	  1413: 
                            	  1414: *             EA = -(An)  - BYTE only
02:00000FC8 307C0100        	  1415:             move.l #$00000100,a0      * point to memory to address
02:00000FCC 4218            	  1416:             move.b #$00,(a0)+         * populate test data
02:00000FCE 4218            	  1417:             move.b #$00,(a0)+         * populate test data
02:00000FD0 08E00007        	  1418:             bset.b #7,-(a0)
02:00000FD4 66FE            	  1419:             bne.s *               * branch if Z clear
02:00000FD6 08E00000        	  1420:             bset.b #0,-(a0)           *
02:00000FDA 66FE            	  1421:             bne.s *               * branch if Z clear
02:00000FDC 307C0102        	  1422:             move.l #$00000102,a0      * point to memory to address 0x100
02:00000FE0 0C200080        	  1423:             cmpi.b #$80,-(a0)
02:00000FE4 66FE            	  1424:             bne.s *               * branch if Z clear
02:00000FE6 0C200001        	  1425:             cmpi.b #$01,-(a0)
02:00000FEA 66FE            	  1426:             bne.s *               * branch if Z clear
                            	  1427: 
                            	  1428: 
                            	  1429: *             EA = n(An)  - BYTE only
02:00000FEC 307C0100        	  1430:             move.l #$00000100,a0      * point to memory to address
02:00000FF0 4218            	  1431:             move.b #$00,(a0)+         * populate test data
02:00000FF2 4218            	  1432:             move.b #$00,(a0)+         * populate test data
02:00000FF4 307C0100        	  1433:             move.l #$00000100,a0      * point to memory to address
02:00000FF8 08D00000        	  1434:             bset.b #0,0(a0)
02:00000FFC 66FE            	  1435:             bne.s *               * branch if Z clear
02:00000FFE 08E800040001    	  1436:             bset.b #4,1(a0)           *
02:00001004 66FE            	  1437:             bne.s *               * branch if Z clear
02:00001006 307C0100        	  1438:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000100A 0C180001        	  1439:             cmpi.b #$01,(a0)+
02:0000100E 66FE            	  1440:             bne.s *               * branch if Z clear
02:00001010 0C180010        	  1441:             cmpi.b #$10,(a0)+
02:00001014 66FE            	  1442:             bne.s *               * branch if Z clear
                            	  1443: 
                            	  1444: 
                            	  1445: *             EA = n(An,D.W)  - BYTE only
02:00001016 307C0100        	  1446:             move.l #$00000100,a0      * point to memory to address
02:0000101A 93C9            	  1447:             move.l #$00000000,a1      * point to memory to address
02:0000101C 347C0004        	  1448:             move.l #$00000004,a2      * point to memory to address
02:00001020 7000            	  1449:             moveq  #$00000000,d0      * point to memory to address
02:00001022 7201            	  1450:             moveq  #$00000001,d1      * point to memory to address
02:00001024 4218            	  1451:             move.b #$00,(a0)+         * populate test data
02:00001026 4218            	  1452:             move.b #$00,(a0)+         * populate test data
02:00001028 4218            	  1453:             move.b #$00,(a0)+         * populate test data
02:0000102A 4218            	  1454:             move.b #$00,(a0)+         * populate test data
02:0000102C 4218            	  1455:             move.b #$00,(a0)+         * populate test data
02:0000102E 4218            	  1456:             move.b #$00,(a0)+         * populate test data
02:00001030 4218            	  1457:             move.b #$00,(a0)+         * populate test data
02:00001032 4218            	  1458:             move.b #$00,(a0)+         * populate test data
02:00001034 4218            	  1459:             move.b #$00,(a0)+         * populate test data
02:00001036 4218            	  1460:             move.b #$00,(a0)+         * populate test data
02:00001038 307C0100        	  1461:             move.l #$00000100,a0      * point to memory to address
02:0000103C 08F000000000    	  1462:             bset.b #0,0(a0,d0.w)
02:00001042 66FE            	  1463:             bne.s *               * branch if Z clear
02:00001044 08F000011000    	  1464:             bset.b #1,0(a0,d1.w)      *
02:0000104A 66FE            	  1465:             bne.s *               * branch if Z clear
02:0000104C 08F000021001    	  1466:             bset.b #2,1(a0,d1.w)      *
02:00001052 66FE            	  1467:             bne.s *               * branch if Z clear
                            	  1468: *             EA = n(An,D.L)  - BYTE only
02:00001054 08F000030802    	  1469:             bset.b #3,2(a0,d0.l)
02:0000105A 66FE            	  1470:             bne.s *               * branch if Z clear
02:0000105C 08F000041800    	  1471:             bset.b #4,0(a0,d1.l)      *
02:00001062 66FE            	  1472:             bne.s *               * branch if Z clear
02:00001064 08F000051801    	  1473:             bset.b #5,1(a0,d1.l)      *
02:0000106A 66FE            	  1474:             bne.s *               * branch if Z clear
                            	  1475: *             EA = n(An,A.W)  - BYTE only
02:0000106C 08F000069000    	  1476:             bset.b #6,0(a0,a1.w)
02:00001072 66FE            	  1477:             bne.s *               * branch if Z clear
02:00001074 08F00001A000    	  1478:             bset.b #1,0(a0,a2.w)      *
02:0000107A 66FE            	  1479:             bne.s *               * branch if Z clear
02:0000107C 08F00007A001    	  1480:             bset.b #7,1(a0,a2.w)      *
02:00001082 66FE            	  1481:             bne.s *               * branch if Z clear
                            	  1482: *             EA = n(An,A.L)  - BYTE only
02:00001084 08F00000A802    	  1483:             bset.b #0,2(a0,a2.l)
02:0000108A 66FE            	  1484:             bne.s *               * branch if Z clear
02:0000108C 08F00000A803    	  1485:             bset.b #0,3(a0,a2.l)      *
02:00001092 66FE            	  1486:             bne.s *               * branch if Z clear
02:00001094 08F00001A804    	  1487:             bset.b #1,4(a0,a2.l)      *
02:0000109A 66FE            	  1488:             bne.s *               * branch if Z clear
02:0000109C 307C0100        	  1489:             move.l #$00000100,a0      * point to memory to address 0x100
02:000010A0 0C9841122C00    	  1490:             cmpi.l #$41122C00,(a0)+
02:000010A6 66FE            	  1491:             bne.s *               * branch if Z clear
02:000010A8 0C9802800101    	  1492:             cmpi.l #$02800101,(a0)+
02:000010AE 66FE            	  1493:             bne.s *
                            	  1494: 
                            	  1495: 
                            	  1496: 
                            	  1497: *             EA = x.W  - BYTE only
02:000010B0 307C0100        	  1498:             move.l #$00000100,a0      * point to memory to address
02:000010B4 4218            	  1499:             move.b #$00,(a0)+         * populate test data
02:000010B6 08F800000100    	  1500:             bset.b #0,$0100
02:000010BC 66FE            	  1501:             bne.s *               * branch if Z clear
02:000010BE 08F800010100    	  1502:             bset.b #1,$0100           *
02:000010C4 66FE            	  1503:             bne.s *               * branch if Z clear
02:000010C6 307C0100        	  1504:             move.l #$00000100,a0      * point to memory to address 0x100
02:000010CA 0C180003        	  1505:             cmpi.b #$03,(a0)+
02:000010CE 66FE            	  1506:             bne.s *
                            	  1507: 
                            	  1508: 
                            	  1509: *             EA = x.L  - BYTE only
02:000010D0 207C0000F100    	  1510:             move.l #$F100,a0      * point to memory to address 0x100
02:000010D6 4210            	  1511:             move.b #$00,(a0)          * populate test data
02:000010D8 08F900000000F100	  1512:             bset.b #0,$F100
02:000010E0 66FE            	  1513:             bne.s *               * branch if Z clear
02:000010E2 08F900010000F100	  1514:             bset.b #1,$F100       *
02:000010EA 66FE            	  1515:             bne.s *               * branch if Z clear
02:000010EC 08F900020000F100	  1516:             bset.b #2,$F100       *
02:000010F4 66FE            	  1517:             bne.s *               * branch if Z clear
02:000010F6 207C0000F100    	  1518:             move.l #$F100,a0      * point to memory to address 0x100
02:000010FC 0C180007        	  1519:             cmpi.b #$07,(a0)+
02:00001100 66FE            	  1520:             bne.s *
                            	  1521: 
                            	  1522: 
                            	  1523: * Bit Number.s Dynamic
                            	  1524: 
                            	  1525: *             EA = Dn  - LONG only
02:00001102 7000            	  1526:             moveq  #$00000000,d0      * populate test data
02:00001104 7A00            	  1527:             move.l #0,d5              * populate bit.s number to test
02:00001106 7C01            	  1528:             move.l #1,d6              * populate bit.s number to test
02:00001108 7E1F            	  1529:             move.l #31,d7              * populate bit.s number to test
                            	  1530: 
02:0000110A 0BC0            	  1531:             bset.l d5,d0
02:0000110C 66FE            	  1532:             bne.s *               * branch if Z clear
02:0000110E 0DC0            	  1533:             bset.l d6,d0              *
02:00001110 66FE            	  1534:             bne.s *               * branch if Z clear
02:00001112 0FC0            	  1535:             bset.l d7,d0             *
02:00001114 66FE            	  1536:             bne.s *               * branch if Z clear
02:00001116 0C8080000003    	  1537:             cmpi.l #$80000003,d0
02:0000111C 66FE            	  1538:             bne.s *               * branch if Z clear
                            	  1539: 
                            	  1540: 
                            	  1541: *             EA = (An)  - BYTE only
02:0000111E 7A00            	  1542:             move.l #0,d5              * populate bit.s number to test
02:00001120 7C01            	  1543:             move.l #1,d6              * populate bit.s number to test
02:00001122 7E07            	  1544:             move.l #7,d7              * populate bit.s number to test
02:00001124 307C0100        	  1545:             move.l #$00000100,a0      * point to memory to address 0x100
02:00001128 4210            	  1546:             move.b #$00,(a0)          * populate test data
02:0000112A 0BD0            	  1547:             bset.b d5,(a0)
02:0000112C 66FE            	  1548:             bne.s *               * branch if Z clear
02:0000112E 0DD0            	  1549:             bset.b d6,(a0)            *
02:00001130 66FE            	  1550:             bne.s *               * branch if Z clear
02:00001132 0FD0            	  1551:             bset.b d7,(a0)            *
02:00001134 66FE            	  1552:             bne.s *               * branch if Z clear
02:00001136 0C100083        	  1553:             cmpi.b #$83,(a0)
02:0000113A 66FE            	  1554:             bne.s *               * branch if Z clear
                            	  1555: 
                            	  1556: 
                            	  1557: *             EA = (An)+  - BYTE only
02:0000113C 307C0100        	  1558:             move.l #$00000100,a0      * point to memory to address 0x100
02:00001140 4218            	  1559:             move.b #$00,(a0)+         * populate test data
02:00001142 4218            	  1560:             move.b #$00,(a0)+         * populate test data
02:00001144 4218            	  1561:             move.b #$00,(a0)+         * populate test data
02:00001146 307C0100        	  1562:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000114A 0BD8            	  1563:             bset.b d5,(a0)+
02:0000114C 66FE            	  1564:             bne.s *               * branch if Z clear
02:0000114E 0DD8            	  1565:             bset.b d6,(a0)+           *
02:00001150 66FE            	  1566:             bne.s *               * branch if Z clear
02:00001152 0FD8            	  1567:             bset.b d7,(a0)+           *
02:00001154 66FE            	  1568:             bne.s *               * branch if Z clear
02:00001156 307C0100        	  1569:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000115A 0C180001        	  1570:             cmpi.b #$01,(a0)+
02:0000115E 66FE            	  1571:             bne.s *               * branch if Z clear
02:00001160 0C180002        	  1572:             cmpi.b #$02,(a0)+
02:00001164 66FE            	  1573:             bne.s *               * branch if Z clear
02:00001166 0C180080        	  1574:             cmpi.b #$80,(a0)+
02:0000116A 66FE            	  1575:             bne.s *               * branch if Z clear
                            	  1576: 
                            	  1577: *             EA = -(An)  - BYTE only
02:0000116C 307C0100        	  1578:             move.l #$00000100,a0      * point to memory to address
02:00001170 4218            	  1579:             move.b #$00,(a0)+         * populate test data
02:00001172 4218            	  1580:             move.b #$00,(a0)+         * populate test data
02:00001174 4218            	  1581:             move.b #$00,(a0)+         * populate test data
02:00001176 307C0103        	  1582:             move.l #$00000103,a0      * point to memory to address
02:0000117A 0BE0            	  1583:             bset.b d5,-(a0)
02:0000117C 66FE            	  1584:             bne.s *               * branch if Z clear
02:0000117E 0DE0            	  1585:             bset.b d6,-(a0)           *
02:00001180 66FE            	  1586:             bne.s *               * branch if Z clear
02:00001182 0FE0            	  1587:             bset.b d7,-(a0)           *
02:00001184 66FE            	  1588:             bne.s *               * branch if Z clear
02:00001186 307C0103        	  1589:             move.l #$00000103,a0      * point to memory to address 0x100
02:0000118A 0C200001        	  1590:             cmpi.b #$01,-(a0)
02:0000118E 66FE            	  1591:             bne.s *               * branch if Z clear
02:00001190 0C200002        	  1592:             cmpi.b #$02,-(a0)
02:00001194 66FE            	  1593:             bne.s *               * branch if Z clear
02:00001196 0C200080        	  1594:             cmpi.b #$80,-(a0)
02:0000119A 66FE            	  1595:             bne.s *               * branch if Z clear
                            	  1596: 
                            	  1597: *             EA = n(An)  - BYTE only
02:0000119C 307C0100        	  1598:             move.l #$00000100,a0      * point to memory to address
02:000011A0 4218            	  1599:             move.b #$00,(a0)+         * populate test data
02:000011A2 4218            	  1600:             move.b #$00,(a0)+         * populate test data
02:000011A4 4218            	  1601:             move.b #$00,(a0)+         * populate test data
02:000011A6 307C0100        	  1602:             move.l #$00000100,a0      * point to memory to address
02:000011AA 0BD0            	  1603:             bset.b d5,0(a0)
02:000011AC 66FE            	  1604:             bne.s *               * branch if Z clear
02:000011AE 0DE80001        	  1605:             bset.b d6,1(a0)           *
02:000011B2 66FE            	  1606:             bne.s *               * branch if Z clear
02:000011B4 0FE80002        	  1607:             bset.b d7,2(a0)           *
02:000011B8 66FE            	  1608:             bne.s *               * branch if Z clear
02:000011BA 307C0100        	  1609:             move.l #$00000100,a0      * point to memory to address 0x100
02:000011BE 0C180001        	  1610:             cmpi.b #$01,(a0)+
02:000011C2 66FE            	  1611:             bne.s *               * branch if Z clear
02:000011C4 0C180002        	  1612:             cmpi.b #$02,(a0)+
02:000011C8 66FE            	  1613:             bne.s *               * branch if Z clear
02:000011CA 0C180080        	  1614:             cmpi.b #$80,(a0)+
02:000011CE 66FE            	  1615:             bne.s *               * branch if Z clear
                            	  1616: 
                            	  1617: *             EA = n(An,R.W)  - BYTE only
02:000011D0 307C0100        	  1618:             move.l #$00000100,a0      * point to memory to address
02:000011D4 4218            	  1619:             move.b #$00,(a0)+         * populate test data
02:000011D6 4218            	  1620:             move.b #$00,(a0)+         * populate test data
02:000011D8 4218            	  1621:             move.b #$00,(a0)+         * populate test data
02:000011DA 4218            	  1622:             move.b #$00,(a0)+         * populate test data
02:000011DC 4218            	  1623:             move.b #$00,(a0)+         * populate test data
02:000011DE 4218            	  1624:             move.b #$00,(a0)+         * populate test data
02:000011E0 4218            	  1625:             move.b #$00,(a0)+         * populate test data
02:000011E2 4218            	  1626:             move.b #$00,(a0)+         * populate test data
02:000011E4 4218            	  1627:             move.b #$00,(a0)+         * populate test data
02:000011E6 4218            	  1628:             move.b #$00,(a0)+         * populate test data
02:000011E8 4218            	  1629:             move.b #$00,(a0)+         * populate test data
02:000011EA 4218            	  1630:             move.b #$00,(a0)+         * populate test data
02:000011EC 307C0100        	  1631:             move.l #$00000100,a0      * point to memory to address
02:000011F0 93C9            	  1632:             move.l #$00000000,a1      * point to memory to address
02:000011F2 347C0001        	  1633:             move.l #$00000001,a2      * point to memory to address
02:000011F6 7000            	  1634:             moveq  #$00000000,d0      * point to memory to address
02:000011F8 7201            	  1635:             moveq  #$00000001,d1      * point to memory to address
02:000011FA 0BF00000        	  1636:             bset.b d5,0(a0,d0.w)
02:000011FE 66FE            	  1637:             bne.s *               * branch if Z clear
02:00001200 0DF01000        	  1638:             bset.b d6,0(a0,d1.w)      *
02:00001204 66FE            	  1639:             bne.s *               * branch if Z clear
02:00001206 0FF01001        	  1640:             bset.b d7,1(a0,d1.w)      *
02:0000120A 66FE            	  1641:             bne.s *               * branch if Z clear
                            	  1642: *             EA = n(An,R.L)  - BYTE only
02:0000120C 0BF00802        	  1643:             bset.b d5,2(a0,d0.l)
02:00001210 66FE            	  1644:             bne.s *               * branch if Z clear
02:00001212 0DF01803        	  1645:             bset.b d6,3(a0,d1.l)      *
02:00001216 66FE            	  1646:             bne.s *               * branch if Z clear
02:00001218 0FF01804        	  1647:             bset.b d7,4(a0,d1.l)      *
02:0000121C 66FE            	  1648:             bne.s *               * branch if Z clear
                            	  1649: *             EA = n(An,A.W)  - BYTE only
02:0000121E 0BF09005        	  1650:             bset.b d5,5(a0,a1.w)
02:00001222 66FE            	  1651:             bne.s *               * branch if Z clear
02:00001224 0DF0A006        	  1652:             bset.b d6,6(a0,a2.w)      *
02:00001228 66FE            	  1653:             bne.s *               * branch if Z clear
02:0000122A 0FF0A007        	  1654:             bset.b d7,7(a0,a2.w)      *
02:0000122E 66FE            	  1655:             bne.s *               * branch if Z clear
                            	  1656: *             EA = n(An,A.L)  - BYTE only
02:00001230 0BF09808        	  1657:             bset.b d5,8(a0,a1.l)
02:00001234 66FE            	  1658:             bne.s *               * branch if Z clear
02:00001236 0DF0A809        	  1659:             bset.b d6,9(a0,a2.l)      *
02:0000123A 66FE            	  1660:             bne.s *               * branch if Z clear
02:0000123C 0FF0A80A        	  1661:             bset.b d7,10(a0,a2.l)      *
02:00001240 66FE            	  1662:             bne.s *               * branch if Z clear
02:00001242 307C0100        	  1663:             move.l #$00000100,a0      * point to memory to address 0x100
02:00001246 0C9801028100    	  1664:             cmpi.l #$01028100,(a0)+
02:0000124C 66FE            	  1665:             bne.s *               * branch if Z clear
02:0000124E 0C9802810002    	  1666:             cmpi.l #$02810002,(a0)+
02:00001254 66FE            	  1667:             bne.s *
                            	  1668: 
                            	  1669: 
                            	  1670: *             EA = x.W  - BYTE only
02:00001256 307C0100        	  1671:             move.l #$00000100,a0      * point to memory to address
02:0000125A 4218            	  1672:             move.b #$00,(a0)+         * populate test data
02:0000125C 4218            	  1673:             move.b #$00,(a0)+         * populate test data
02:0000125E 4218            	  1674:             move.b #$00,(a0)+         * populate test data
02:00001260 0BF80100        	  1675:             bset.b d5,$0100
02:00001264 66FE            	  1676:             bne.s *               * branch if Z clear
02:00001266 0DF80100        	  1677:             bset.b d6,$0100           *
02:0000126A 66FE            	  1678:             bne.s *               * branch if Z clear
02:0000126C 0FF80100        	  1679:             bset.b d7,$0100           *
02:00001270 66FE            	  1680:             bne.s *               * branch if Z clear
02:00001272 307C0100        	  1681:             move.l #$00000100,a0      * point to memory to address
02:00001276 0C180083        	  1682:             cmpi.b #$83,(a0)+
02:0000127A 66FE            	  1683:             bne.s *               * branch if Z clear
                            	  1684: 
                            	  1685: *             EA = x.L  - BYTE only
02:0000127C 207C0000F100    	  1686:             move.l #$F100,a0      * point to memory to address 0x100
02:00001282 4218            	  1687:             move.b #$00,(a0)+         * populate test data
02:00001284 4218            	  1688:             move.b #$00,(a0)+         * populate test data
02:00001286 4218            	  1689:             move.b #$00,(a0)+         * populate test data
02:00001288 0BF90000F100    	  1690:             bset.b d5,$F100
02:0000128E 66FE            	  1691:             bne.s *               * branch if Z clear
02:00001290 0DF90000F100    	  1692:             bset.b d6,$F100       *
02:00001296 66FE            	  1693:             bne.s *               * branch if Z clear
02:00001298 0FF90000F100    	  1694:             bset.b d7,$F100       *
02:0000129E 66FE            	  1695:             bne.s *               * branch if Z clear
02:000012A0 207C0000F100    	  1696:             move.l #$F100,a0      * point to memory to address 0x100
02:000012A6 0C100083        	  1697:             cmpi.b #$83,(a0)
02:000012AA 66FE            	  1698:             bne.s *               * branch if Z clear
                            	  1699: 
                            	  1700: 
02:000012AC 4E75            	  1701:     rts
                            	  1702: 
                            	  1703: *-----------------------------------------------------------
                            	  1704: *-----------------------------------------------------------
                            	  1705: * OPCODE : MOVEP
                            	  1706: *-----------------------------------------------------------
                            	  1707: *-----------------------------------------------------------
                            	  1708: op_MOVEP:
                            	  1709: 
                            	  1710: * Dn --> x(An)
02:000012AE 307C0100        	  1711:             move.l #$00000100,a0
02:000012B2 203C12345678    	  1712:             move.l #$12345678,d0
02:000012B8 223CAABBCCDD    	  1713:             move.l #$AABBCCDD,d1
02:000012BE 4290            	  1714:             move.l #0,(a0)
02:000012C0 42A80004        	  1715:             move.l #0,4(a0)
                            	  1716: 
02:000012C4 01880000        	  1717:             movep.w d0,0(a0)      * even offset
02:000012C8 03880001        	  1718:             movep.w d1,1(a0)      * odd offset
                            	  1719: 
02:000012CC 01C80004        	  1720:             movep.l d0,4(a0)      * even offset
02:000012D0 03C80005        	  1721:             movep.l d1,5(a0)      * odd offset
                            	  1722: 
02:000012D4 0C9056CC78DD    	  1723:             cmpi.l #$56CC78DD,(a0)
02:000012DA 66FE            	  1724:             bne.s *
02:000012DC 0CA812AA34BB0004	  1725:             cmpi.l #$12AA34BB,4(a0)
02:000012E4 66FE            	  1726:             bne.s *
02:000012E6 0CA856CC78DD0008	  1727:             cmpi.l #$56CC78DD,8(a0)
02:000012EE 66FE            	  1728:             bne.s *
                            	  1729: 
                            	  1730: 
                            	  1731: * x(An)--> Dn
02:000012F0 203C5A5A5A5A    	  1732:             move.l #$5a5a5a5a,d0
02:000012F6 223C5A5A5A5A    	  1733:             move.l #$5a5a5a5a,d1
02:000012FC 243C5A5A5A5A    	  1734:             move.l #$5a5a5a5a,d2
02:00001302 263C5A5A5A5A    	  1735:             move.l #$5a5a5a5a,d3
                            	  1736: 
02:00001308 01080000        	  1737:             movep.w 0(a0),d0      * even offset
02:0000130C 03080001        	  1738:             movep.w 1(a0),d1      * odd offset
                            	  1739: 
02:00001310 05480004        	  1740:             movep.l 4(a0),d2      * even offset
02:00001314 07480005        	  1741:             movep.l 5(a0),d3      * odd offset
                            	  1742: 
02:00001318 0C805A5A5678    	  1743:             cmpi.l #$5a5a5678,d0
02:0000131E 66FE            	  1744:             bne.s *
02:00001320 0C815A5ACCDD    	  1745:             cmpi.l #$5a5aCCDD,d1
02:00001326 66FE            	  1746:             bne.s *
02:00001328 0C8212345678    	  1747:             cmpi.l #$12345678,d2
02:0000132E 66FE            	  1748:             bne.s *
02:00001330 0C83AABBCCDD    	  1749:             cmpi.l #$AABBCCDD,d3
02:00001336 66FE            	  1750:             bne.s *
                            	  1751: 
02:00001338 4E75            	  1752:             rts
                            	  1753: 
                            	  1754: 
                            	  1755: 
                            	  1756: *-----------------------------------------------------------
                            	  1757: *-----------------------------------------------------------
                            	  1758: * OPCODE : BOOL_I
                            	  1759: *-----------------------------------------------------------
                            	  1760: *-----------------------------------------------------------
                            	  1761: op_BOOL_I:
                            	  1762: 
                            	  1763: *     Dn -- BYTE
02:0000133A 203C12345678    	  1764:             move.l #$12345678,d0
02:00001340 44FC000F        	  1765:             move.w #$000F,CCR          * pre-set Flags
02:00001344 000000FF        	  1766:             ori.b  #$FF,d0
02:00001348 0A00005A        	  1767:             eori.b #$5A,d0
02:0000134C 020000F0        	  1768:             andi.b #$F0,d0
02:00001350 69FE            	  1769:             bvs.s *                       * Check V,C are cleared
02:00001352 65FE            	  1770:             bcs.s *
02:00001354 6AFE            	  1771:             bpl.s *                       * Verify if N flag is set
02:00001356 4200            	  1772:             andi.b #$00,d0
02:00001358 6BFE            	  1773:             bmi.s *                       * Verify if N flag is cleared
02:0000135A 66FE            	  1774:             bne.s *                       * Verify if Z flag is set
                            	  1775: 
                            	  1776: *     Dn -- WORD
02:0000135C 223C12345678    	  1777:             move.l #$12345678,d1
02:00001362 44FC000F        	  1778:             move.w #$000F,CCR          * pre-set Flags
02:00001366 0041FFFF        	  1779:             ori.w  #$FFFF,d1
02:0000136A 0A415A5A        	  1780:             eori.w #$5A5A,d1
02:0000136E 0241F0F0        	  1781:             andi.w #$F0F0,d1
02:00001372 69FE            	  1782:             bvs.s *                       * Check V,C are cleared
02:00001374 65FE            	  1783:             bcs.s *
02:00001376 6AFE            	  1784:             bpl.s *                       * Verify if N flag is set
02:00001378 4241            	  1785:             andi.w #$0000,d1
02:0000137A 6BFE            	  1786:             bmi.s *                       * Verify if N flag is cleared
02:0000137C 66FE            	  1787:             bne.s *                       * Verify if Z flag is set
                            	  1788: 
                            	  1789: *     Dn -- LONG
02:0000137E 243C12345678    	  1790:             move.l #$12345678,d2
02:00001384 44FC000F        	  1791:             move.w #$000F,CCR          * pre-set Flags
02:00001388 0082FFFFFFFF    	  1792:             ori.l  #$FFFFFFFF,d2
02:0000138E 0A825A5A5A5A    	  1793:             eori.l #$5A5A5A5A,d2
02:00001394 0282F0F0F0F0    	  1794:             andi.l #$F0F0F0F0,d2
02:0000139A 69FE            	  1795:             bvs.s *                       * Check V,C are cleared
02:0000139C 65FE            	  1796:             bcs.s *
02:0000139E 6AFE            	  1797:             bpl.s *                       * Verify if N flag is set
02:000013A0 4282            	  1798:             andi.l #$00000000,d2
02:000013A2 6BFE            	  1799:             bmi.s *                       * Verify if N flag is cleared
02:000013A4 66FE            	  1800:             bne.s *                       * Verify if Z flag is set
                            	  1801: 
                            	  1802: 
                            	  1803: *     (An) -- BYTE
02:000013A6 307C0100        	  1804:             move.l #$00000100,a0
02:000013AA 20BC12345678    	  1805:             move.l #$12345678,(a0)
02:000013B0 44FC000F        	  1806:             move.w #$000F,CCR          * pre-set Flags
02:000013B4 001000FF        	  1807:             ori.b  #$FF,(a0)
02:000013B8 0A10005A        	  1808:             eori.b #$5A,(a0)
02:000013BC 021000F0        	  1809:             andi.b #$F0,(a0)
02:000013C0 69FE            	  1810:             bvs.s *                       * Check V,C are cleared
02:000013C2 65FE            	  1811:             bcs.s *
02:000013C4 6AFE            	  1812:             bpl.s *                       * Verify if N flag is set
02:000013C6 4210            	  1813:             andi.b #$00,(a0)
02:000013C8 6BFE            	  1814:             bmi.s *                       * Verify if N flag is cleared
02:000013CA 66FE            	  1815:             bne.s *                       * Verify if Z flag is set
02:000013CC 4A10            	  1816:             cmpi.b #$00,(a0)
02:000013CE 66FE            	  1817:             bne.s *                       * Verify if Z flag is set
                            	  1818: 
                            	  1819: *     (An) -- WORD
02:000013D0 20BC12345678    	  1820:             move.l #$12345678,(a0)
02:000013D6 44FC000F        	  1821:             move.w #$000F,CCR          * pre-set Flags
02:000013DA 0050FFFF        	  1822:             ori.w  #$FFFF,(a0)
02:000013DE 0A505A5A        	  1823:             eori.w #$5A5A,(a0)
02:000013E2 0250F0F0        	  1824:             andi.w #$F0F0,(a0)
02:000013E6 69FE            	  1825:             bvs.s *                       * Check V,C are cleared
02:000013E8 65FE            	  1826:             bcs.s *
02:000013EA 6AFE            	  1827:             bpl.s *                       * Verify if N flag is set
02:000013EC 4250            	  1828:             andi.w #$0000,(a0)
02:000013EE 6BFE            	  1829:             bmi.s *                       * Verify if N flag is cleared
02:000013F0 66FE            	  1830:             bne.s *                       * Verify if Z flag is set
02:000013F2 4A50            	  1831:             cmpi.w #$00,(a0)
02:000013F4 66FE            	  1832:             bne.s *                       * Verify if Z flag is set
                            	  1833: 
                            	  1834: *     (An) -- LONG
02:000013F6 20BC12345678    	  1835:             move.l #$12345678,(a0)
02:000013FC 44FC000F        	  1836:             move.w #$000F,CCR          * pre-set Flags
02:00001400 0090FFFFFFFF    	  1837:             ori.l  #$FFFFFFFF,(a0)
02:00001406 0A905A5A5A5A    	  1838:             eori.l #$5A5A5A5A,(a0)
02:0000140C 0290F0F0F0F0    	  1839:             andi.l #$F0F0F0F0,(a0)
02:00001412 69FE            	  1840:             bvs.s *                       * Check V,C are cleared
02:00001414 65FE            	  1841:             bcs.s *
02:00001416 6AFE            	  1842:             bpl.s *                       * Verify if N flag is set
02:00001418 4290            	  1843:             andi.l #$00000000,(a0)
02:0000141A 6BFE            	  1844:             bmi.s *                       * Verify if N flag is cleared
02:0000141C 66FE            	  1845:             bne.s *                       * Verify if Z flag is set
02:0000141E 4A90            	  1846:             cmpi.l #$00,(a0)
02:00001420 66FE            	  1847:             bne.s *                       * Verify if Z flag is set
                            	  1848: 
                            	  1849: 
                            	  1850: 
                            	  1851: *     (An)+ -- BYTE
02:00001422 307C0100        	  1852:             move.l #$00000100,a0
02:00001426 20BC00A5FF88    	  1853:             move.l #$00A5FF88,(a0)
02:0000142C 44FC000F        	  1854:             move.w #$000F,CCR          * pre-set Flags
                            	  1855: 
02:00001430 001800F5        	  1856:             ori.b  #$F5,(a0)+
02:00001434 6AFE            	  1857:             bpl.s *                       * Verify if N flag is set
02:00001436 67FE            	  1858:             beq.s *                       * Verify if Z flag is cleared
                            	  1859: 
02:00001438 4618            	  1860:             eori.b #$FF,(a0)+
02:0000143A 6BFE            	  1861:             bmi.s *                       * Verify if N flag is cleared
02:0000143C 67FE            	  1862:             beq.s *                       * Verify if Z flag is cleared
                            	  1863: 
02:0000143E 021800AA        	  1864:             andi.b #$AA,(a0)+
02:00001442 6AFE            	  1865:             bpl.s *                       * Verify if N flag is set
02:00001444 67FE            	  1866:             beq.s *                       * Verify if Z flag is cleared
                            	  1867: 
02:00001446 307C0100        	  1868:             move.l #$00000100,a0
02:0000144A 0C90F55AAA88    	  1869:             cmpi.l #$F55AAA88,(a0)
02:00001450 66FE            	  1870:             bne.s *                       * Verify if Z flag is set
                            	  1871: 
                            	  1872: 
                            	  1873: *     (An)+ -- WORD
02:00001452 307C0100        	  1874:             move.l #$00000100,a0
02:00001456 327C0104        	  1875:             move.l #$00000104,a1
02:0000145A 20BC00005A5A    	  1876:             move.l #$00005a5a,(a0)
02:00001460 22BC12345678    	  1877:             move.l #$12345678,(a1)
02:00001466 44FC000F        	  1878:             move.w #$000F,CCR          * pre-set Flags
                            	  1879: 
02:0000146A 00585678        	  1880:             ori.w  #$5678,(a0)+
02:0000146E 6BFE            	  1881:             bmi.s *                       * Verify if N flag is cleared
02:00001470 67FE            	  1882:             beq.s *                       * Verify if Z flag is cleared
                            	  1883: 
02:00001472 4658            	  1884:             eori.w #$FFFF,(a0)+
02:00001474 6AFE            	  1885:             bpl.s *                       * Verify if N flag is set
02:00001476 67FE            	  1886:             beq.s *                       * Verify if Z flag is cleared
                            	  1887: 
02:00001478 0258A55A        	  1888:             andi.w #$A55A,(a0)+
02:0000147C 6BFE            	  1889:             bmi.s *                       * Verify if N flag is cleared
02:0000147E 67FE            	  1890:             beq.s *                       * Verify if Z flag is cleared
                            	  1891: 
02:00001480 307C0100        	  1892:             move.l #$00000100,a0
02:00001484 0C905678A5A5    	  1893:             cmpi.l #$5678a5a5,(a0)
02:0000148A 307C0104        	  1894:             move.l #$00000104,a0
02:0000148E 0C9000105678    	  1895:             cmpi.l #$00105678,(a0)
02:00001494 66FE            	  1896:             bne.s *                       * Verify if Z flag is set
                            	  1897: 
                            	  1898: *     (An)+ -- LONG
02:00001496 307C0100        	  1899:             move.l #$00000100,a0
02:0000149A 4298            	  1900:             move.l #$00000000,(a0)+
02:0000149C 20FC5A5A5A5A    	  1901:             move.l #$5a5a5a5a,(a0)+
02:000014A2 20FCFFFFFFFF    	  1902:             move.l #$FFFFFFFF,(a0)+
02:000014A8 307C0100        	  1903:             move.l #$00000100,a0
02:000014AC 44FC000F        	  1904:             move.w #$000F,CCR          * pre-set Flags
                            	  1905: 
02:000014B0 009812345678    	  1906:             ori.l  #$12345678,(a0)+
02:000014B6 6BFE            	  1907:             bmi.s *                       * Verify if N flag is cleared
02:000014B8 67FE            	  1908:             beq.s *                       * Verify if Z flag is cleared
                            	  1909: 
02:000014BA 4698            	  1910:             eori.l #$FFFFFFFF,(a0)+
02:000014BC 6AFE            	  1911:             bpl.s *                       * Verify if N flag is set
02:000014BE 67FE            	  1912:             beq.s *                       * Verify if Z flag is cleared
                            	  1913: 
02:000014C0 0298A5A5A55A    	  1914:             andi.l #$A5A5A55A,(a0)+
02:000014C6 6AFE            	  1915:             bpl.s *                       * Verify if N flag is set
02:000014C8 67FE            	  1916:             beq.s *                       * Verify if Z flag is cleared
                            	  1917: 
02:000014CA 307C0100        	  1918:             move.l #$00000100,a0
02:000014CE 0C9812345678    	  1919:             cmpi.l #$12345678,(a0)+
02:000014D4 0C98A5A5A5A5    	  1920:             cmpi.l #$a5a5a5a5,(a0)+
02:000014DA 0C98A5A5A55A    	  1921:             cmpi.l #$a5a5a55a,(a0)+
02:000014E0 66FE            	  1922:             bne.s *                       * Verify if Z flag is set
                            	  1923: 
02:000014E2 4E75            	  1924:             rts
                            	  1925: 
                            	  1926: 
                            	  1927: *-----------------------------------------------------------
                            	  1928: *-----------------------------------------------------------
                            	  1929: * OPCODE : BSR
                            	  1930: *-----------------------------------------------------------
                            	  1931: *-----------------------------------------------------------
                            	  1932: 
                            	  1933: 
02:000014E4 223C11111111    	  1934: BSR_CLOSE1:     move.l #$11111111,d1
02:000014EA 4E75            	  1935:                 rts
                            	  1936: 
                            	  1937: 
                            	  1938: 
02:000014EC 61F6            	  1939: op_BSR:         bsr BSR_CLOSE1        * Negative 8-bit.s displacement
02:000014EE 612A            	  1940:                 bsr BSR_CLOSE2        * Positive 8-bit.s displacement
02:000014F0 6100EF20        	  1941:                 bsr.w BSR_FAR1          * Negative 16-bit.s displacement
02:000014F4 6100143E        	  1942:                 bsr.w BSR_FAR2          * Positive 16-bit.s displacement
                            	  1943: 
02:000014F8 0C8111111111    	  1944:                 cmpi.l #$11111111,d1
02:000014FE 66FE            	  1945:                 bne.s *
02:00001500 0C8222222222    	  1946:                 cmpi.l #$22222222,d2
02:00001506 66FE            	  1947:                 bne.s *
02:00001508 0C8333333333    	  1948:                 cmpi.l #$33333333,d3
02:0000150E 66FE            	  1949:                 bne.s *
02:00001510 0C8444444444    	  1950:                 cmpi.l #$44444444,d4
02:00001516 66FE            	  1951:                 bne.s *
                            	  1952: 
02:00001518 4E75            	  1953:                 rts
                            	  1954: 
                            	  1955: 
02:0000151A 243C22222222    	  1956: BSR_CLOSE2:     move.l #$22222222,d2
02:00001520 4E75            	  1957:                 rts
                            	  1958: 
                            	  1959: *-----------------------------------------------------------
                            	  1960: *-----------------------------------------------------------
                            	  1961: * OPCODE : op_CMP_I
                            	  1962: *-----------------------------------------------------------
                            	  1963: *-----------------------------------------------------------
                            	  1964: op_CMP_I:
                            	  1965: 
02:00001522 307C0100        	  1966:             move.l #$00000100,a0
02:00001526 20BC00000100    	  1967:             move.l #$00000100,(a0)
                            	  1968: 
                            	  1969: *     REGISTER - BYTE
02:0000152C 7080            	  1970:             move.l #$FFFFFF80,d0
02:0000152E 0C000080        	  1971:             cmpi.b #$80,d0
02:00001532 66FE            	  1972:             bne.s *                       * Check Z Flag  beq/bne
02:00001534 6BFE            	  1973:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001536 65FE            	  1974:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001538 69FE            	  1975:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1976: 
02:0000153A 223CFFFFF000    	  1977:             move.l #$FFFFF000,d1
02:00001540 4A01            	  1978:             cmpi.b #$00,d1
02:00001542 66FE            	  1979:             bne.s *                       * Check Z Flag  beq/bne
02:00001544 6BFE            	  1980:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001546 65FE            	  1981:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001548 69FE            	  1982:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1983: 
02:0000154A 7481D442        	  1984:             move.l #$FFFFFF02,d2
02:0000154E 0C0200FF        	  1985:             cmpi.b #$FF,d2
02:00001552 67FE            	  1986:             beq.s *                       * Check Z Flag  beq/bne
02:00001554 6BFE            	  1987:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001556 64FE            	  1988:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001558 69FE            	  1989:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1990: 
02:0000155A 263CFFFFFF7F    	  1991:             move.l #$FFFFFF7F,d3
02:00001560 0C0300FF        	  1992:             cmpi.b #$FF,d3
02:00001564 67FE            	  1993:             beq.s *                       * Check Z Flag  beq/bne
02:00001566 6AFE            	  1994:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001568 64FE            	  1995:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000156A 68FE            	  1996:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  1997: 
                            	  1998: 
                            	  1999: *     REGISTER - WORD
02:0000156C 203CFFFF8000    	  2000:             move.l #$FFFF8000,d0
02:00001572 0C408000        	  2001:             cmpi.w #$8000,d0
02:00001576 66FE            	  2002:             bne.s *                       * Check Z Flag  beq/bne
02:00001578 6BFE            	  2003:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000157A 65FE            	  2004:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000157C 69FE            	  2005:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2006: 
02:0000157E 223CFFF00000    	  2007:             move.l #$FFF00000,d1
02:00001584 4A41            	  2008:             cmpi.w #$0000,d1
02:00001586 66FE            	  2009:             bne.s *                       * Check Z Flag  beq/bne
02:00001588 6BFE            	  2010:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000158A 65FE            	  2011:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000158C 69FE            	  2012:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2013: 
02:0000158E 243CFFFF0002    	  2014:             move.l #$FFFF0002,d2
02:00001594 0C42FFFF        	  2015:             cmpi.w #$FFFF,d2
02:00001598 67FE            	  2016:             beq.s *                       * Check Z Flag  beq/bne
02:0000159A 6BFE            	  2017:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000159C 64FE            	  2018:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000159E 69FE            	  2019:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2020: 
02:000015A0 263CFFFF7FFF    	  2021:             move.l #$FFFF7FFF,d3
02:000015A6 0C43FFFF        	  2022:             cmpi.w #$FFFF,d3
02:000015AA 67FE            	  2023:             beq.s *                       * Check Z Flag  beq/bne
02:000015AC 6AFE            	  2024:             bpl.s *                       * Check N Flag  bmi/bpl
02:000015AE 64FE            	  2025:             bcc.s *                       * Check C Flag  bcc/bcs
02:000015B0 68FE            	  2026:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2027: 
                            	  2028: *     REGISTER - LONG
02:000015B2 203C80000000    	  2029:             move.l #$80000000,d0
02:000015B8 0C8080000000    	  2030:             cmpi.l #$80000000,d0
02:000015BE 66FE            	  2031:             bne.s *                       * Check Z Flag  beq/bne
02:000015C0 6BFE            	  2032:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015C2 65FE            	  2033:             bcs.s *                       * Check C Flag  bcc/bcs
02:000015C4 69FE            	  2034:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2035: 
02:000015C6 7200            	  2036:             moveq  #$00000000,d1
02:000015C8 4A81            	  2037:             cmpi.l #$00000000,d1
02:000015CA 66FE            	  2038:             bne.s *                       * Check Z Flag  beq/bne
02:000015CC 6BFE            	  2039:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015CE 65FE            	  2040:             bcs.s *                       * Check C Flag  bcc/bcs
02:000015D0 69FE            	  2041:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2042: 
02:000015D2 7402            	  2043:             moveq  #$00000002,d2
02:000015D4 0C82FFFFFFFF    	  2044:             cmpi.l #$FFFFFFFF,d2
02:000015DA 67FE            	  2045:             beq.s *                       * Check Z Flag  beq/bne
02:000015DC 6BFE            	  2046:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015DE 64FE            	  2047:             bcc.s *                       * Check C Flag  bcc/bcs
02:000015E0 69FE            	  2048:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2049: 
02:000015E2 263C7FFFFFFF    	  2050:             move.l #$7FFFFFFF,d3
02:000015E8 0C83FFFFFFFF    	  2051:             cmpi.l #$FFFFFFFF,d3
02:000015EE 67FE            	  2052:             beq.s *                       * Check Z Flag  beq/bne
02:000015F0 6AFE            	  2053:             bpl.s *                       * Check N Flag  bmi/bpl
02:000015F2 64FE            	  2054:             bcc.s *                       * Check C Flag  bcc/bcs
02:000015F4 68FE            	  2055:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2056: 
                            	  2057: 
                            	  2058: 
                            	  2059: 
                            	  2060: *     EA=x(An,Dn) - BYTE
02:000015F6 307C0100        	  2061:             move.l #$00000100,a0
02:000015FA 7E04            	  2062:             moveq  #$00000004,d7
                            	  2063: 
02:000015FC 21BCFFFFFF80700C	  2064:             move.l #$FFFFFF80,12(a0,d7)
02:00001604 21BCFFFFFF80700C	  2065:             move.l #$FFFFFF80,12(a0,d7)
02:0000160C 0C300080700F    	  2066:             cmpi.b #$80,15(a0,d7)
02:00001612 66FE            	  2067:             bne.s *                       * Check Z Flag  beq/bne
02:00001614 6BFE            	  2068:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001616 65FE            	  2069:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001618 69FE            	  2070:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2071: 
02:0000161A 21BCFFFFF000700C	  2072:             move.l #$FFFFF000,12(a0,d7)
02:00001622 4A30700F        	  2073:             cmpi.b #$00,15(a0,d7)
02:00001626 66FE            	  2074:             bne.s *                       * Check Z Flag  beq/bne
02:00001628 6BFE            	  2075:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000162A 65FE            	  2076:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000162C 69FE            	  2077:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2078: 
02:0000162E 21BCFFFFFF02700C	  2079:             move.l #$FFFFFF02,12(a0,d7)
02:00001636 0C3000FF700F    	  2080:             cmpi.b #$FF,15(a0,d7)
02:0000163C 67FE            	  2081:             beq.s *                       * Check Z Flag  beq/bne
02:0000163E 6BFE            	  2082:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001640 64FE            	  2083:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001642 69FE            	  2084:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2085: 
02:00001644 21BCFFFFFF7F700C	  2086:             move.l #$FFFFFF7F,12(a0,d7)
02:0000164C 0C3000FF700F    	  2087:             cmpi.b #$FF,15(a0,d7)
02:00001652 67FE            	  2088:             beq.s *                       * Check Z Flag  beq/bne
02:00001654 6AFE            	  2089:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001656 64FE            	  2090:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001658 68FE            	  2091:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2092: 
                            	  2093: 
                            	  2094: *     EA=x(An,Dn) - WORD
02:0000165A 21BCFFFF8000700C	  2095:             move.l #$FFFF8000,12(a0,d7)
02:00001662 0C708000700E    	  2096:             cmpi.w #$8000,14(a0,d7)
02:00001668 66FE            	  2097:             bne.s *                       * Check Z Flag  beq/bne
02:0000166A 6BFE            	  2098:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000166C 65FE            	  2099:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000166E 69FE            	  2100:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2101: 
02:00001670 21BCFFF00000700C	  2102:             move.l #$FFF00000,12(a0,d7)
02:00001678 4A70700E        	  2103:             cmpi.w #$0000,14(a0,d7)
02:0000167C 66FE            	  2104:             bne.s *                       * Check Z Flag  beq/bne
02:0000167E 6BFE            	  2105:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001680 65FE            	  2106:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001682 69FE            	  2107:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2108: 
02:00001684 21BCFFFF0002700C	  2109:             move.l #$FFFF0002,12(a0,d7)
02:0000168C 0C70FFFF700E    	  2110:             cmpi.w #$FFFF,14(a0,d7)
02:00001692 67FE            	  2111:             beq.s *                       * Check Z Flag  beq/bne
02:00001694 6BFE            	  2112:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001696 64FE            	  2113:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001698 69FE            	  2114:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2115: 
02:0000169A 21BCFFFF7FFF700C	  2116:             move.l #$FFFF7FFF,12(a0,d7)
02:000016A2 0C70FFFF700E    	  2117:             cmpi.w #$FFFF,14(a0,d7)
02:000016A8 67FE            	  2118:             beq.s *                       * Check Z Flag  beq/bne
02:000016AA 6AFE            	  2119:             bpl.s *                       * Check N Flag  bmi/bpl
02:000016AC 64FE            	  2120:             bcc.s *                       * Check C Flag  bcc/bcs
02:000016AE 68FE            	  2121:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2122: 
                            	  2123: *     EA=x(An,Dn) - LONG
02:000016B0 21BC80000000700C	  2124:             move.l #$80000000,12(a0,d7)
02:000016B8 0CB080000000700C	  2125:             cmpi.l #$80000000,12(a0,d7)
02:000016C0 66FE            	  2126:             bne.s *                       * Check Z Flag  beq/bne
02:000016C2 6BFE            	  2127:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016C4 65FE            	  2128:             bcs.s *                       * Check C Flag  bcc/bcs
02:000016C6 69FE            	  2129:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2130: 
02:000016C8 42B0700C        	  2131:             move.l #$00000000,12(a0,d7)
02:000016CC 4AB0700C        	  2132:             cmpi.l #$00000000,12(a0,d7)
02:000016D0 66FE            	  2133:             bne.s *                       * Check Z Flag  beq/bne
02:000016D2 6BFE            	  2134:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016D4 65FE            	  2135:             bcs.s *                       * Check C Flag  bcc/bcs
02:000016D6 69FE            	  2136:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2137: 
02:000016D8 21BC00000002700C	  2138:             move.l #$00000002,12(a0,d7)
02:000016E0 0CB0FFFFFFFF700C	  2139:             cmpi.l #$FFFFFFFF,12(a0,d7)
02:000016E8 67FE            	  2140:             beq.s *                       * Check Z Flag  beq/bne
02:000016EA 6BFE            	  2141:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016EC 64FE            	  2142:             bcc.s *                       * Check C Flag  bcc/bcs
02:000016EE 69FE            	  2143:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2144: 
02:000016F0 21BC7FFFFFFF700C	  2145:             move.l #$7FFFFFFF,12(a0,d7)
02:000016F8 0CB0FFFFFFFF700C	  2146:             cmpi.l #$FFFFFFFF,12(a0,d7)
02:00001700 67FE            	  2147:             beq.s *                       * Check Z Flag  beq/bne
02:00001702 6AFE            	  2148:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001704 64FE            	  2149:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001706 68FE            	  2150:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2151: 
                            	  2152: 
                            	  2153: 
                            	  2154: 
02:00001708 4E75            	  2155:             rts
                            	  2156: 
                            	  2157: 
                            	  2158: 
                            	  2159: *-----------------------------------------------------------
                            	  2160: *-----------------------------------------------------------
                            	  2161: * OPCODE : ADD_I
                            	  2162: *-----------------------------------------------------------
                            	  2163: *-----------------------------------------------------------
                            	  2164: op_ADD_I:
                            	  2165: 
                            	  2166: *     EA = Dn  - Byte
02:0000170A 203C12345678    	  2167:             move.l #$12345678,d0      * populate test data
02:00001710 06000000        	  2168:             addi.b #0,d0
02:00001714 67FE            	  2169:             beq.s *                       * Check Z Flag  beq/bne
02:00001716 6BFE            	  2170:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001718 65FE            	  2171:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000171A 69FE            	  2172:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000171C 06000010        	  2173:             addi.b #$10,d0
02:00001720 67FE            	  2174:             beq.s *                       * Check Z Flag  beq/bne
02:00001722 6AFE            	  2175:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001724 65FE            	  2176:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001726 68FE            	  2177:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001728 060000A5        	  2178:             addi.b #$A5,d0
02:0000172C 67FE            	  2179:             beq.s *                       * Check Z Flag  beq/bne
02:0000172E 6BFE            	  2180:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001730 64FE            	  2181:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001732 68FE            	  2182:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001734 0C00002D        	  2183:             cmpi.b #$2D,d0
02:00001738 66FE            	  2184:             bne.s *                       * Check Z Flag  beq/bne
                            	  2185: 
                            	  2186: *     EA = Dn  - WORD
02:0000173A 203C12345678    	  2187:             move.l #$12345678,d0      * populate test data
02:00001740 06400000        	  2188:             addi.w #0,d0
02:00001744 67FE            	  2189:             beq.s *                       * Check Z Flag  beq/bne
02:00001746 6BFE            	  2190:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001748 65FE            	  2191:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000174A 69FE            	  2192:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000174C 06407000        	  2193:             addi.w #$7000,d0
02:00001750 67FE            	  2194:             beq.s *                       * Check Z Flag  beq/bne
02:00001752 6AFE            	  2195:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001754 65FE            	  2196:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001756 68FE            	  2197:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001758 0640A55A        	  2198:             addi.w #$A55A,d0
02:0000175C 67FE            	  2199:             beq.s *                       * Check Z Flag  beq/bne
02:0000175E 6BFE            	  2200:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001760 64FE            	  2201:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001762 68FE            	  2202:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001764 0C406BD2        	  2203:             cmpi.w #$6BD2,d0
02:00001768 66FE            	  2204:             bne.s *                       * Check Z Flag  beq/bne
                            	  2205: 
                            	  2206: *     EA = Dn  - LONG
02:0000176A 203C12345678    	  2207:             move.l #$12345678,d0      * populate test data
02:00001770 068000000000    	  2208:             addi.l #0,d0
02:00001776 67FE            	  2209:             beq.s *                       * Check Z Flag  beq/bne
02:00001778 6BFE            	  2210:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000177A 65FE            	  2211:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000177C 69FE            	  2212:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000177E 0680F0000000    	  2213:             addi.l #$F0000000,d0
02:00001784 67FE            	  2214:             beq.s *                       * Check Z Flag  beq/bne
02:00001786 6BFE            	  2215:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001788 64FE            	  2216:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000178A 69FE            	  2217:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000178C 0680855AA55A    	  2218:             addi.l #$855AA55A,d0
02:00001792 67FE            	  2219:             beq.s *                       * Check Z Flag  beq/bne
02:00001794 6AFE            	  2220:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001796 65FE            	  2221:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001798 69FE            	  2222:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000179A 0680A0000000    	  2223:             addi.l #$A0000000,d0
02:000017A0 68FE            	  2224:             bvc.s *                       * Check V Flag  bvc/bvs
02:000017A2 0C80278EFBD2    	  2225:             cmpi.l #$278EFBD2,d0
02:000017A8 66FE            	  2226:             bne.s *                       * Check Z Flag  beq/bne
                            	  2227: 
                            	  2228: 
                            	  2229: 
                            	  2230: *     EA = x.L  - Byte
02:000017AA 207C0000F100    	  2231:             move.l #$F100,a0      * populate test data
02:000017B0 20BC12345678    	  2232:             move.l #$12345678,(a0)     * populate test data
02:000017B6 063900000000F103	  2233:             addi.b #0,$F103
02:000017BE 67FE            	  2234:             beq.s *                       * Check Z Flag  beq/bne
02:000017C0 6BFE            	  2235:             bmi.s *                       * Check N Flag  bmi/bpl
02:000017C2 65FE            	  2236:             bcs.s *                       * Check C Flag  bcc/bcs
02:000017C4 69FE            	  2237:             bvs.s *                       * Check V Flag  bvc/bvs
02:000017C6 063900100000F103	  2238:             addi.b #$10,$F103
02:000017CE 67FE            	  2239:             beq.s *                       * Check Z Flag  beq/bne
02:000017D0 6AFE            	  2240:             bpl.s *                       * Check N Flag  bmi/bpl
02:000017D2 65FE            	  2241:             bcs.s *                       * Check C Flag  bcc/bcs
02:000017D4 68FE            	  2242:             bvc.s *                       * Check V Flag  bvc/bvs
02:000017D6 063900A50000F103	  2243:             addi.b #$A5,$F103
02:000017DE 67FE            	  2244:             beq.s *                       * Check Z Flag  beq/bne
02:000017E0 6BFE            	  2245:             bmi.s *                       * Check N Flag  bmi/bpl
02:000017E2 64FE            	  2246:             bcc.s *                       * Check C Flag  bcc/bcs
02:000017E4 68FE            	  2247:             bvc.s *                       * Check V Flag  bvc/bvs
02:000017E6 0C39002D0000F103	  2248:             cmpi.b #$2D,$F103
02:000017EE 66FE            	  2249:             bne.s *                       * Check Z Flag  beq/bne
                            	  2250: 
                            	  2251: *     EA = x.L- WORD
02:000017F0 207C0000F100    	  2252:             move.l #$F100,a0      * populate test data
02:000017F6 20BC12345678    	  2253:             move.l #$12345678,(a0)     * populate test data
02:000017FC 067900000000F100	  2254:             addi.w #0,$F100
02:00001804 67FE            	  2255:             beq.s *                       * Check Z Flag  beq/bne
02:00001806 6BFE            	  2256:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001808 65FE            	  2257:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000180A 69FE            	  2258:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000180C 067970000000F100	  2259:             addi.w #$7000,$F100
02:00001814 67FE            	  2260:             beq.s *                       * Check Z Flag  beq/bne
02:00001816 6AFE            	  2261:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001818 65FE            	  2262:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000181A 68FE            	  2263:             bvc.s *                       * Check V Flag  bvc/bvs
02:0000181C 0679A55A0000F100	  2264:             addi.w #$A55A,$F100
02:00001824 67FE            	  2265:             beq.s *                       * Check Z Flag  beq/bne
02:00001826 6BFE            	  2266:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001828 64FE            	  2267:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000182A 68FE            	  2268:             bvc.s *                       * Check V Flag  bvc/bvs
02:0000182C 0C79278E0000F100	  2269:             cmpi.w #$278E,$F100
02:00001834 66FE            	  2270:             bne.s *                       * Check Z Flag  beq/bne
                            	  2271: 
                            	  2272: *     EA = x.L- LONG
02:00001836 23FC123456780000	  2273:             move.l #$12345678,$F100  * populate test data
02:0000183E F100
02:00001840 06B9000000000000	  2274:             addi.l #0,$F100
02:00001848 F100
02:0000184A 67FE            	  2275:             beq.s *                       * Check Z Flag  beq/bne
02:0000184C 6BFE            	  2276:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000184E 65FE            	  2277:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001850 69FE            	  2278:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001852 06B9F00000000000	  2279:             addi.l #$F0000000,$F100
02:0000185A F100
02:0000185C 67FE            	  2280:             beq.s *                       * Check Z Flag  beq/bne
02:0000185E 6BFE            	  2281:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001860 64FE            	  2282:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001862 69FE            	  2283:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001864 06B9855AA55A0000	  2284:             addi.l #$855AA55A,$F100
02:0000186C F100
02:0000186E 67FE            	  2285:             beq.s *                       * Check Z Flag  beq/bne
02:00001870 6AFE            	  2286:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001872 65FE            	  2287:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001874 69FE            	  2288:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001876 06B9A00000000000	  2289:             addi.l #$A0000000,$F100
02:0000187E F100
02:00001880 68FE            	  2290:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001882 0CB9278EFBD20000	  2291:             cmpi.l #$278EFBD2,$F100
02:0000188A F100
02:0000188C 66FE            	  2292:             bne.s *                       * Check Z Flag  beq/bne
                            	  2293: 
02:0000188E 4E75            	  2294:             rts
                            	  2295: 
                            	  2296: 
                            	  2297: *-----------------------------------------------------------
                            	  2298: *-----------------------------------------------------------
                            	  2299: * OPCODE : SUB_I
                            	  2300: *-----------------------------------------------------------
                            	  2301: *-----------------------------------------------------------
                            	  2302: op_SUB_I:
                            	  2303: 
                            	  2304: *     EA = Dn  - Byte
02:00001890 203C12345678    	  2305:             move.l #$12345678,d0      * populate test data
02:00001896 04000000        	  2306:             subi.b #0,d0
02:0000189A 67FE            	  2307:             beq.s *                       * Check Z Flag  beq/bne
02:0000189C 6BFE            	  2308:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000189E 65FE            	  2309:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018A0 69FE            	  2310:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018A2 04000010        	  2311:             subi.b #$10,d0
02:000018A6 67FE            	  2312:             beq.s *                       * Check Z Flag  beq/bne
02:000018A8 6BFE            	  2313:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018AA 65FE            	  2314:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018AC 69FE            	  2315:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018AE 040000A5        	  2316:             subi.b #$A5,d0
02:000018B2 67FE            	  2317:             beq.s *                       * Check Z Flag  beq/bne
02:000018B4 6AFE            	  2318:             bpl.s *                       * Check N Flag  bmi/bpl
02:000018B6 64FE            	  2319:             bcc.s *                       * Check C Flag  bcc/bcs
02:000018B8 68FE            	  2320:             bvc.s *                       * Check V Flag  bvc/bvs
02:000018BA 0C0000C3        	  2321:             cmpi.b #$C3,d0
02:000018BE 66FE            	  2322:             bne.s *                       * Check Z Flag  beq/bne
                            	  2323: 
                            	  2324: *     EA = Dn  - WORD
02:000018C0 203C12345678    	  2325:             move.l #$12345678,d0      * populate test data
02:000018C6 04400000        	  2326:             subi.w #0,d0
02:000018CA 67FE            	  2327:             beq.s *                       * Check Z Flag  beq/bne
02:000018CC 6BFE            	  2328:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018CE 65FE            	  2329:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018D0 69FE            	  2330:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018D2 04407000        	  2331:             subi.w #$7000,d0
02:000018D6 67FE            	  2332:             beq.s *                       * Check Z Flag  beq/bne
02:000018D8 6AFE            	  2333:             bpl.s *                       * Check N Flag  bmi/bpl
02:000018DA 64FE            	  2334:             bcc.s *                       * Check C Flag  bcc/bcs
02:000018DC 69FE            	  2335:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018DE 0440A55A        	  2336:             subi.w #$A55A,d0
02:000018E2 67FE            	  2337:             beq.s *                       * Check Z Flag  beq/bne
02:000018E4 6BFE            	  2338:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018E6 65FE            	  2339:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018E8 69FE            	  2340:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018EA 0C40411E        	  2341:             cmpi.w #$411E,d0
02:000018EE 66FE            	  2342:             bne.s *                       * Check Z Flag  beq/bne
                            	  2343: 
                            	  2344: *     EA = Dn  - LONG
02:000018F0 203C12345678    	  2345:             move.l #$12345678,d0      * populate test data
02:000018F6 048000000000    	  2346:             subi.l #0,d0
02:000018FC 67FE            	  2347:             beq.s *                       * Check Z Flag  beq/bne
02:000018FE 6BFE            	  2348:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001900 65FE            	  2349:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001902 69FE            	  2350:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001904 0480F0000000    	  2351:             subi.l #$F0000000,d0
02:0000190A 67FE            	  2352:             beq.s *                       * Check Z Flag  beq/bne
02:0000190C 6BFE            	  2353:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000190E 64FE            	  2354:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001910 69FE            	  2355:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001912 0480855AA55A    	  2356:             subi.l #$855AA55A,d0
02:00001918 67FE            	  2357:             beq.s *                       * Check Z Flag  beq/bne
02:0000191A 6AFE            	  2358:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000191C 64FE            	  2359:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000191E 68FE            	  2360:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001920 0480A0000000    	  2361:             subi.l #$A0000000,d0
02:00001926 69FE            	  2362:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001928 0C80FCD9B11E    	  2363:             cmpi.l #$FCD9B11E,d0
02:0000192E 66FE            	  2364:             bne.s *                       * Check Z Flag  beq/bne
                            	  2365: 
                            	  2366: 
                            	  2367: 
                            	  2368: *     EA = x.L  - Byte
02:00001930 207C0000F100    	  2369:             move.l #$F100,a0      * populate test data
02:00001936 20BC12345678    	  2370:             move.l #$12345678,(a0)     * populate test data
02:0000193C 043900000000F103	  2371:             subi.b #0,$F103
02:00001944 67FE            	  2372:             beq.s *                       * Check Z Flag  beq/bne
02:00001946 6BFE            	  2373:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001948 65FE            	  2374:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000194A 69FE            	  2375:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000194C 043900100000F103	  2376:             subi.b #$10,$F103
02:00001954 67FE            	  2377:             beq.s *                       * Check Z Flag  beq/bne
02:00001956 6BFE            	  2378:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001958 65FE            	  2379:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000195A 69FE            	  2380:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000195C 043900A50000F103	  2381:             subi.b #$A5,$F103
02:00001964 67FE            	  2382:             beq.s *                       * Check Z Flag  beq/bne
02:00001966 6AFE            	  2383:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001968 64FE            	  2384:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000196A 68FE            	  2385:             bvc.s *                       * Check V Flag  bvc/bvs
02:0000196C 0C3900C30000F103	  2386:             cmpi.b #$C3,$F103
02:00001974 66FE            	  2387:             bne.s *                       * Check Z Flag  beq/bne
                            	  2388: 
                            	  2389: *     EA = x.L- WORD
02:00001976 207C0000F100    	  2390:             move.l #$F100,a0      * populate test data
02:0000197C 20BC12345678    	  2391:             move.l #$12345678,(a0)     * populate test data
02:00001982 047900000000F100	  2392:             subi.w #0,$F100
02:0000198A 67FE            	  2393:             beq.s *                       * Check Z Flag  beq/bne
02:0000198C 6BFE            	  2394:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000198E 65FE            	  2395:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001990 69FE            	  2396:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001992 047970000000F100	  2397:             subi.w #$7000,$F100
02:0000199A 67FE            	  2398:             beq.s *                       * Check Z Flag  beq/bne
02:0000199C 6AFE            	  2399:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000199E 64FE            	  2400:             bcc.s *                       * Check C Flag  bcc/bcs
02:000019A0 69FE            	  2401:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019A2 0479A55A0000F100	  2402:             subi.w #$A55A,$F100
02:000019AA 67FE            	  2403:             beq.s *                       * Check Z Flag  beq/bne
02:000019AC 6AFE            	  2404:             bpl.s *                       * Check N Flag  bmi/bpl
02:000019AE 64FE            	  2405:             bcc.s *                       * Check C Flag  bcc/bcs
02:000019B0 69FE            	  2406:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019B2 0C79FCDA0000F100	  2407:             cmpi.w #$FCDA,$F100
02:000019BA 66FE            	  2408:             bne.s *                       * Check Z Flag  beq/bne
                            	  2409: 
                            	  2410: *     EA = x.L- LONG
02:000019BC 23FC123456780000	  2411:             move.l #$12345678,$F100  * populate test data
02:000019C4 F100
02:000019C6 04B9000000000000	  2412:             subi.l #0,$F100
02:000019CE F100
02:000019D0 67FE            	  2413:             beq.s *                       * Check Z Flag  beq/bne
02:000019D2 6BFE            	  2414:             bmi.s *                       * Check N Flag  bmi/bpl
02:000019D4 65FE            	  2415:             bcs.s *                       * Check C Flag  bcc/bcs
02:000019D6 69FE            	  2416:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019D8 04B9F00000000000	  2417:             subi.l #$F0000000,$F100
02:000019E0 F100
02:000019E2 67FE            	  2418:             beq.s *                       * Check Z Flag  beq/bne
02:000019E4 6BFE            	  2419:             bmi.s *                       * Check N Flag  bmi/bpl
02:000019E6 64FE            	  2420:             bcc.s *                       * Check C Flag  bcc/bcs
02:000019E8 69FE            	  2421:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019EA 04B9855AA55A0000	  2422:             subi.l #$855AA55A,$F100
02:000019F2 F100
02:000019F4 67FE            	  2423:             beq.s *                       * Check Z Flag  beq/bne
02:000019F6 6AFE            	  2424:             bpl.s *                       * Check N Flag  bmi/bpl
02:000019F8 64FE            	  2425:             bcc.s *                       * Check C Flag  bcc/bcs
02:000019FA 68FE            	  2426:             bvc.s *                       * Check V Flag  bvc/bvs
02:000019FC 04B9A00000000000	  2427:             subi.l #$A0000000,$F100
02:00001A04 F100
02:00001A06 69FE            	  2428:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001A08 0CB9FCD9B11E0000	  2429:             cmpi.l #$FCD9B11E,$F100
02:00001A10 F100
02:00001A12 66FE            	  2430:             bne.s *                       * Check Z Flag  beq/bne
                            	  2431: 
02:00001A14 4E75            	  2432:             rts
                            	  2433: 
                            	  2434: 
                            	  2435: 
                            	  2436: *-----------------------------------------------------------
                            	  2437: *-----------------------------------------------------------
                            	  2438: * OPCODE : MOVE
                            	  2439: *-----------------------------------------------------------
                            	  2440: *-----------------------------------------------------------
                            	  2441: op_MOVE:
02:00001A16 203C11223344    	  2442:             move.l #$11223344,d0
02:00001A1C 223C55667788    	  2443:             move.l #$55667788,d1
02:00001A22 243C8899AABB    	  2444:             move.l #$8899aabb,d2
02:00001A28 263CCCDDEEFF    	  2445:             move.l #$ccddeeff,d3
02:00001A2E 7800            	  2446:             moveq  #$00000000,d4
02:00001A30 7A00            	  2447:             moveq  #$00000000,d5
02:00001A32 7C00            	  2448:             moveq  #$00000000,d6
02:00001A34 7E00            	  2449:             moveq  #$00000000,d7
02:00001A36 207C44332211    	  2450:             move.l #$44332211,a0
02:00001A3C 227C88776655    	  2451:             move.l #$88776655,a1
02:00001A42 247CBBAA9988    	  2452:             move.l #$bbaa9988,a2
02:00001A48 267CFFEEDDCC    	  2453:             move.l #$ffeeddcc,a3
                            	  2454: 
02:00001A4E 1800            	  2455:             move.b d0,d4              * BYTE - DATA REGISTER
02:00001A50 67FE            	  2456:             beq.s *                       * Check Z Flag  beq/bne
02:00001A52 6BFE            	  2457:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A54 0C8400000044    	  2458:             cmpi.l #$00000044,d4
02:00001A5A 66FE            	  2459:             bne.s *                       * Check Z Flag  beq/bne
                            	  2460: 
02:00001A5C 3A01            	  2461:             move.w d1,d5              * WORD - DATA REGISTER
02:00001A5E 67FE            	  2462:             beq.s *                       * Check Z Flag  beq/bne
02:00001A60 6BFE            	  2463:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A62 0C8500007788    	  2464:             cmpi.l #$00007788,d5
02:00001A68 66FE            	  2465:             bne.s *                       * Check Z Flag  beq/bne
                            	  2466: 
02:00001A6A 2C02            	  2467:             move.l d2,d6              * LONG - DATA REGISTER
02:00001A6C 67FE            	  2468:             beq.s *                       * Check Z Flag  beq/bne
02:00001A6E 6AFE            	  2469:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001A70 0C868899AABB    	  2470:             cmpi.l #$8899aabb,d6
02:00001A76 66FE            	  2471:             bne.s *                       * Check Z Flag  beq/bne
                            	  2472: 
02:00001A78 3A09            	  2473:             move.w a1,d5              * WORD - ADDRESS REGISTER
02:00001A7A 67FE            	  2474:             beq.s *                       * Check Z Flag  beq/bne
02:00001A7C 6BFE            	  2475:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A7E 0C8500006655    	  2476:             cmpi.l #$00006655,d5
02:00001A84 66FE            	  2477:             bne.s *                       * Check Z Flag  beq/bne
                            	  2478: 
02:00001A86 2C0A            	  2479:             move.l a2,d6              * LONG - ADDRESS REGISTER
02:00001A88 67FE            	  2480:             beq.s *                       * Check Z Flag  beq/bne
02:00001A8A 6AFE            	  2481:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001A8C 0C86BBAA9988    	  2482:             cmpi.l #$bbaa9988,d6
02:00001A92 66FE            	  2483:             bne.s *                       * Check Z Flag  beq/bne
                            	  2484: 
                            	  2485: 
02:00001A94 3842            	  2486:             movea.w d2,a4             * WORD - ADDRESS REGISTER as SOURCE ## MOVEA
02:00001A96 B9C2            	  2487:             cmpa.l d2,a4
02:00001A98 67FE            	  2488:             beq.s *                       * Check Z Flag  beq/bne ## comopare fails because A4 was sign extended
                            	  2489: 
02:00001A9A 2A41            	  2490:             movea.l d1,a5             * LONG - ADDRESS REGISTER as SOURCE ## MOVEA
02:00001A9C BBC1            	  2491:             cmpa.l d1,a5
02:00001A9E 66FE            	  2492:             bne.s *                       * Check Z Flag  beq/bne
                            	  2493: 
                            	  2494: 
                            	  2495: 
                            	  2496: *   Too mamy EA combinations to test,so we focus on a few of the more complicted EA's
                            	  2497: 
02:00001AA0 203C11223344    	  2498:             move.l #$11223344,d0
02:00001AA6 223C00010100    	  2499:             move.l #$00010100,d1
02:00001AAC 243C8899AABB    	  2500:             move.l #$8899aabb,d2
02:00001AB2 7601            	  2501:             moveq  #$00000001,d3
02:00001AB4 7800            	  2502:             moveq  #$00000000,d4
02:00001AB6 7A00            	  2503:             moveq  #$00000000,d5
02:00001AB8 7C00            	  2504:             moveq  #$00000000,d6
02:00001ABA 7E00            	  2505:             moveq  #$00000000,d7
02:00001ABC 91C8            	  2506:             move.l #$00000000,a0
02:00001ABE 227C00010100    	  2507:             move.l #$00010100,a1
                            	  2508: 
                            	  2509: *     x(An,AL) --> x.L
02:00001AC4 11BC005A9804    	  2510:             move.b #$5A,4(a0,a1.l)    * BYTE
02:00001ACA 47F09804        	  2511:             lea 4(a0,a1.l),a3
02:00001ACE 13F0980400010105	  2512:             move.b 4(a0,a1.l),$00010105
02:00001AD6 67FE            	  2513:             beq.s *                       * Check Z Flag  beq/bne
02:00001AD8 6BFE            	  2514:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001ADA 0C30005A9805    	  2515:             cmpi.b #$5A,5(a0,a1.l)
02:00001AE0 66FE            	  2516:             bne.s *                       * Check Z Flag  beq/bne
                            	  2517: 
                            	  2518: *     x.L --> n(An,Dw)
02:00001AE2 11B9000101051007	  2519: MOVE2:      move.b  $00010105,7(a0,d1.w)    * BYTE
02:00001AEA 67FE            	  2520:             beq.s *                       * Check Z Flag  beq/bne
02:00001AEC 6BFE            	  2521:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001AEE 0C30005A1007    	  2522:             cmpi.b #$5A,7(a0,d1.w)
02:00001AF4 66FE            	  2523:             bne.s *                       * Check Z Flag  beq/bne
                            	  2524: 
                            	  2525: *     x(PC,Ds) --> x.w
02:00001AF6 11FB30660100    	  2526:             move.b  MOVE1(pc,d3.w),$0100 * BYTE
02:00001AFC 67FE            	  2527:             beq.s *                       * Check Z Flag  beq/bne
02:00001AFE 6AFE            	  2528:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001B00 0C3900B900001AE3	  2529:             cmpi.b #$B9,1+MOVE2
02:00001B08 66FE            	  2530:             bne.s *                       * Check Z Flag  beq/bne
                            	  2531: 
                            	  2532: *     #x -->    n(An,AL)
02:00001B0A 11BC00781007    	  2533:             move.b  #$78,7(a0,d1.w)    * BYTE
02:00001B10 67FE            	  2534:             beq.s *                       * Check Z Flag  beq/bne
02:00001B12 6BFE            	  2535:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B14 0C3000781007    	  2536:             cmpi.b #$78,7(a0,d1.w)
02:00001B1A 66FE            	  2537:             bne.s *                       * Check Z Flag  beq/bne
                            	  2538: 
02:00001B1C 203C11223344    	  2539:             move.l #$11223344,d0
02:00001B22 223C00010100    	  2540:             move.l #$00010100,d1
02:00001B28 243C8899AABB    	  2541:             move.l #$8899aabb,d2
02:00001B2E 7602            	  2542:             moveq  #$00000002,d3
02:00001B30 7800            	  2543:             moveq  #$00000000,d4
02:00001B32 7A00            	  2544:             moveq  #$00000000,d5
02:00001B34 7C00            	  2545:             moveq  #$00000000,d6
02:00001B36 7E00            	  2546:             moveq  #$00000000,d7
02:00001B38 91C8            	  2547:             move.l #$00000000,a0
02:00001B3A 227C00010100    	  2548:             move.l #$00010100,a1
                            	  2549: 
                            	  2550: *     x(An,AL) --> x.L
02:00001B40 31BC5A5A9804    	  2551:             move.w #$5A5A,4(a0,a1.l)    * WORD
02:00001B46 49F09804        	  2552:             lea 4(a0,a1.l),a4
02:00001B4A 33F0980400010104	  2553:             move.w 4(a0,a1.l),$00010104
02:00001B52 67FE            	  2554:             beq.s *                       * Check Z Flag  beq/bne
02:00001B54 6BFE            	  2555:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B56 0C705A5A9804    	  2556:             cmpi.w #$5A5A,4(a0,a1.l)
02:00001B5C 66FE            	  2557:             bne.s *                       * Check Z Flag  beq/bne
                            	  2558: 
                            	  2559: *     x.L --> n(An,Dw)
02:00001B5E 31B9000101041006	  2560: MOVE1:      move.w  $00010104,6(a0,d1.w)    * WORD
02:00001B66 67FE            	  2561:             beq.s *                       * Check Z Flag  beq/bne
02:00001B68 6BFE            	  2562:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B6A 0C705A5A1006    	  2563:             cmpi.w #$5A5A,6(a0,d1.w)
02:00001B70 66FE            	  2564:             bne.s *                       * Check Z Flag  beq/bne
                            	  2565: 
                            	  2566: *     x(PC,Ds) --> x.w
02:00001B72 31FB30EA0100    	  2567:             move.w  MOVE1(pc,d3),$0100 * WORD
02:00001B78 67FE            	  2568:             beq.s *                       * Check Z Flag  beq/bne
02:00001B7A 6BFE            	  2569:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B7C 0C7967FE00001B66	  2570:             cmpi.w #$67FE,8+MOVE1
02:00001B84 66FE            	  2571:             bne.s *                       * Check Z Flag  beq/bne
                            	  2572: 
                            	  2573: *     #x -->    n(An,AL)
02:00001B86 31BC78781006    	  2574:             move.w  #$7878,6(a0,d1.w)    * WORD
02:00001B8C 67FE            	  2575:             beq.s *                       * Check Z Flag  beq/bne
02:00001B8E 6BFE            	  2576:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B90 0C7078781006    	  2577:             cmpi.w #$7878,6(a0,d1.w)
02:00001B96 66FE            	  2578:             bne.s *                       * Check Z Flag  beq/bne
                            	  2579: 
                            	  2580: * ---
                            	  2581: 
02:00001B98 203C11223344    	  2582:             move.l #$11223344,d0
02:00001B9E 223C00010100    	  2583:             move.l #$00010100,d1
02:00001BA4 243C8899AABB    	  2584:             move.l #$8899aabb,d2
02:00001BAA 7602            	  2585:             moveq  #$00000002,d3
02:00001BAC 7800            	  2586:             moveq  #$00000000,d4
02:00001BAE 7A00            	  2587:             moveq  #$00000000,d5
02:00001BB0 7C00            	  2588:             moveq  #$00000000,d6
02:00001BB2 7E00            	  2589:             moveq  #$00000000,d7
02:00001BB4 91C8            	  2590:             move.l #$00000000,a0
02:00001BB6 227C00010100    	  2591:             move.l #$00010100,a1
                            	  2592: 
                            	  2593: *     x(An,AL) --> x.L
02:00001BBC 21BC5A5A12349804	  2594:             move.l #$5A5A1234,4(a0,a1.l)    * LONG
02:00001BC4 49F09804        	  2595:             lea 4(a0,a1.l),a4
02:00001BC8 23F0980400010104	  2596:             move.l 4(a0,a1.l),$00010104
02:00001BD0 67FE            	  2597:             beq.s *                       * Check Z Flag  beq/bne
02:00001BD2 6BFE            	  2598:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001BD4 0CB05A5A12349804	  2599:             cmpi.l #$5A5A1234,4(a0,a1.l)
02:00001BDC 66FE            	  2600:             bne.s *                       * Check Z Flag  beq/bne
                            	  2601: 
                            	  2602: *     x.L --> n(An,Dw)
02:00001BDE 21B9000101041006	  2603: MOVE3:      move.l  $00010104,6(a0,d1.w)    * LONG
02:00001BE6 67FE            	  2604:             beq.s *                       * Check Z Flag  beq/bne
02:00001BE8 6BFE            	  2605:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001BEA 0CB05A5A12341006	  2606:             cmpi.l #$5A5A1234,6(a0,d1.w)
02:00001BF2 66FE            	  2607:             bne.s *                       * Check Z Flag  beq/bne
                            	  2608: 
                            	  2609: *     x(PC,Ds) --> x.w
02:00001BF4 21FB30E80100    	  2610:             move.l  MOVE3(pc,d3),$0100 * LONG
02:00001BFA 67FE            	  2611:             beq.s *                       * Check Z Flag  beq/bne
02:00001BFC 6BFE            	  2612:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001BFE 0CB967FE6BFE0000	  2613:             cmpi.l #$67FE6BFE,8+MOVE3
02:00001C06 1BE6
02:00001C08 66FE            	  2614:             bne.s *                       * Check Z Flag  beq/bne
                            	  2615: 
                            	  2616: *     #x -->    n(An,AL)
02:00001C0A 21BC787823231006	  2617:             move.l  #$78782323,6(a0,d1.w)    * LONG
02:00001C12 67FE            	  2618:             beq.s *                       * Check Z Flag  beq/bne
02:00001C14 6BFE            	  2619:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001C16 0CB0787823231006	  2620:             cmpi.l #$78782323,6(a0,d1.w)
02:00001C1E 66FE            	  2621:             bne.s *                       * Check Z Flag  beq/bne
                            	  2622: 
                            	  2623: 
02:00001C20 4E75            	  2624:          rts
                            	  2625: 
                            	  2626: 
                            	  2627: *-----------------------------------------------------------
                            	  2628: *-----------------------------------------------------------
                            	  2629: * OPCODE : MOVE_xxx_FLAGS
                            	  2630: *-----------------------------------------------------------
                            	  2631: *-----------------------------------------------------------
                            	  2632: op_MOVE_xxx_FLAGS:
                            	  2633: 
                            	  2634: *     Move_To_SR
                            	  2635: 
                            	  2636: *     Dn
                            	  2637: 
02:00001C22 303C2FFF        	  2638:             move.w #$2FFF,d0
02:00001C26 46C0            	  2639:             move.w d0,SR
02:00001C28 6AFE            	  2640:             bpl.s *           * branch if Z clear
02:00001C2A 66FE            	  2641:             bne.s *           * branch if N clear
02:00001C2C 68FE            	  2642:             bvc.s *           * branch if V clear
02:00001C2E 64FE            	  2643:             bcc.s *           * branch if C clear
02:00001C30 303C2F00        	  2644:             move.w #$2F00,d0
02:00001C34 44C0            	  2645:             move d0,CCR
02:00001C36 67FE            	  2646:             beq.s *           * branch if Z set
02:00001C38 6BFE            	  2647:             bmi.s *           * branch if N set
02:00001C3A 69FE            	  2648:             bvs.s *           * branch if V set
02:00001C3C 65FE            	  2649:             bcs.s *           * branch if C set
                            	  2650: 
02:00001C3E 303C2000        	  2651:             move.w #$2000,d0
02:00001C42 46C0            	  2652:             move.w d0,SR
02:00001C44 67FE            	  2653:             beq.s *           * branch if Z set
02:00001C46 6BFE            	  2654:             bmi.s *           * branch if N set
02:00001C48 69FE            	  2655:             bvs.s *           * branch if V set
02:00001C4A 65FE            	  2656:             bcs.s *           * branch if C set
                            	  2657: 
                            	  2658: *     (An)
02:00001C4C 307C0100        	  2659:             move.l #$00000100,a0
02:00001C50 30BC2FFF        	  2660:             move.w #$2FFF,(a0)
02:00001C54 46D0            	  2661:             move.w (a0),SR
02:00001C56 6AFE            	  2662:             bpl.s *           * branch if Z clear
02:00001C58 66FE            	  2663:             bne.s *           * branch if N clear
02:00001C5A 68FE            	  2664:             bvc.s *           * branch if V clear
02:00001C5C 64FE            	  2665:             bcc.s *           * branch if C clear
                            	  2666: 
02:00001C5E 30BC2000        	  2667:             move.w #$2000,(a0)
02:00001C62 46D0            	  2668:             move.w (a0),SR
02:00001C64 67FE            	  2669:             beq.s *           * branch if Z set
02:00001C66 6BFE            	  2670:             bmi.s *           * branch if N set
02:00001C68 69FE            	  2671:             bvs.s *           * branch if V set
02:00001C6A 65FE            	  2672:             bcs.s *           * branch if C set
                            	  2673: 
                            	  2674: *     (An)+
02:00001C6C 307C0100        	  2675:             move.l #$00000100,a0
02:00001C70 30BC2FFF        	  2676:             move.w #$2FFF,(a0)
02:00001C74 46D8            	  2677:             move.w (a0)+,SR
02:00001C76 6AFE            	  2678:             bpl.s *           * branch if Z clear
02:00001C78 66FE            	  2679:             bne.s *           * branch if N clear
02:00001C7A 68FE            	  2680:             bvc.s *           * branch if V clear
02:00001C7C 64FE            	  2681:             bcc.s *           * branch if C clear
                            	  2682: 
02:00001C7E 30BC2000        	  2683:             move.w #$2000,(a0)
02:00001C82 46D8            	  2684:             move.w (a0)+,SR
02:00001C84 67FE            	  2685:             beq.s *           * branch if Z set
02:00001C86 6BFE            	  2686:             bmi.s *           * branch if N set
02:00001C88 69FE            	  2687:             bvs.s *           * branch if V set
02:00001C8A 65FE            	  2688:             bcs.s *           * branch if C set
                            	  2689: 
                            	  2690: *     -(An)
02:00001C8C 307C0102        	  2691:             move.l #$00000102,a0
02:00001C90 30BC2FFF        	  2692:             move.w #$2FFF,(a0)
02:00001C94 46D8            	  2693:             move.w (a0)+,SR
02:00001C96 6AFE            	  2694:             bpl.s *           * branch if Z clear
02:00001C98 66FE            	  2695:             bne.s *           * branch if N clear
02:00001C9A 68FE            	  2696:             bvc.s *           * branch if V clear
02:00001C9C 64FE            	  2697:             bcc.s *           * branch if C clear
                            	  2698: 
02:00001C9E 30BC2000        	  2699:             move.w #$2000,(a0)
02:00001CA2 46D8            	  2700:             move.w (a0)+,SR
02:00001CA4 67FE            	  2701:             beq.s *           * branch if Z set
02:00001CA6 6BFE            	  2702:             bmi.s *           * branch if N set
02:00001CA8 69FE            	  2703:             bvs.s *           * branch if V set
02:00001CAA 65FE            	  2704:             bcs.s *           * branch if C set
                            	  2705: 
                            	  2706: *     n(An)
02:00001CAC 307C0102        	  2707:             move.l #$00000102,a0
02:00001CB0 317C2FFF0002    	  2708:             move.w #$2FFF,2(a0)
02:00001CB6 46E80002        	  2709:             move.w 2(a0),SR
02:00001CBA 6AFE            	  2710:             bpl.s *           * branch if Z clear
02:00001CBC 66FE            	  2711:             bne.s *           * branch if N clear
02:00001CBE 68FE            	  2712:             bvc.s *           * branch if V clear
02:00001CC0 64FE            	  2713:             bcc.s *           * branch if C clear
                            	  2714: 
02:00001CC2 317C20000002    	  2715:             move.w #$2000,2(a0)
02:00001CC8 46E80002        	  2716:             move.w 2(a0),SR
02:00001CCC 67FE            	  2717:             beq.s *           * branch if Z set
02:00001CCE 6BFE            	  2718:             bmi.s *           * branch if N set
02:00001CD0 69FE            	  2719:             bvs.s *           * branch if V set
02:00001CD2 65FE            	  2720:             bcs.s *           * branch if C set
                            	  2721: 
                            	  2722: *     n(An,Rn.l)
02:00001CD4 307C0100        	  2723:             move.l #$00000100,a0
02:00001CD8 7002            	  2724:             moveq  #$00000002,d0
02:00001CDA 31BC2FFF0802    	  2725:             move.w #$2FFF,2(a0,d0.l)
02:00001CE0 46F00802        	  2726:             move.w 2(a0,d0.l),SR
02:00001CE4 6AFE            	  2727:             bpl.s *           * branch if Z clear
02:00001CE6 66FE            	  2728:             bne.s *           * branch if N clear
02:00001CE8 68FE            	  2729:             bvc.s *           * branch if V clear
02:00001CEA 64FE            	  2730:             bcc.s *           * branch if C clear
                            	  2731: 
02:00001CEC 31BC20000802    	  2732:             move.w #$2000,2(a0,d0.l)
02:00001CF2 46F00802        	  2733:             move.w 2(a0,d0.l),SR
02:00001CF6 67FE            	  2734:             beq.s *           * branch if Z set
02:00001CF8 6BFE            	  2735:             bmi.s *           * branch if N set
02:00001CFA 69FE            	  2736:             bvs.s *           * branch if V set
02:00001CFC 65FE            	  2737:             bcs.s *           * branch if C set
                            	  2738: 
                            	  2739: *     x.W
02:00001CFE 31FC2FFF0100    	  2740:             move.w #$2FFF,$0100
02:00001D04 46F80100        	  2741:             move.w $0100,SR
02:00001D08 6AFE            	  2742:             bpl.s *           * branch if Z clear
02:00001D0A 66FE            	  2743:             bne.s *           * branch if N clear
02:00001D0C 68FE            	  2744:             bvc.s *           * branch if V clear
02:00001D0E 64FE            	  2745:             bcc.s *           * branch if C clear
                            	  2746: 
02:00001D10 31FC20000100    	  2747:             move.w #$2000,$0100
02:00001D16 46F80100        	  2748:             move.w $0100,SR
02:00001D1A 67FE            	  2749:             beq.s *           * branch if Z set
02:00001D1C 6BFE            	  2750:             bmi.s *           * branch if N set
02:00001D1E 69FE            	  2751:             bvs.s *           * branch if V set
02:00001D20 65FE            	  2752:             bcs.s *           * branch if C set
                            	  2753: 
                            	  2754: *     x.L
02:00001D22 33FC2FFF00010100	  2755:             move.w #$2FFF,$00010100
02:00001D2A 46F900010100    	  2756:             move.w $00010100,SR
02:00001D30 6AFE            	  2757:             bpl.s *           * branch if Z clear
02:00001D32 66FE            	  2758:             bne.s *           * branch if N clear
02:00001D34 68FE            	  2759:             bvc.s *           * branch if V clear
02:00001D36 64FE            	  2760:             bcc.s *           * branch if C clear
                            	  2761: 
02:00001D38 33FC200000010100	  2762: MOVE4:      move.w #$2000,$00010100
02:00001D40 46F900010100    	  2763:             move.w $00010100,SR
02:00001D46 67FE            	  2764:             beq.s *           * branch if Z set
02:00001D48 6BFE            	  2765:             bmi.s *           * branch if N set
02:00001D4A 69FE            	  2766:             bvs.s *           * branch if V set
02:00001D4C 65FE            	  2767:             bcs.s *           * branch if C set
                            	  2768: 
                            	  2769: *     x(PC)
02:00001D4E 46FAFFEA        	  2770:             move.w MOVE4+2(pc),SR
02:00001D52 67FE            	  2771:             beq.s *           * branch if Z set
02:00001D54 6BFE            	  2772:             bmi.s *           * branch if N set
02:00001D56 69FE            	  2773:             bvs.s *           * branch if V set
02:00001D58 65FE            	  2774:             bcs.s *           * branch if C set
                            	  2775: 
                            	  2776: *     x(PC,d0.l)
02:00001D5A 7000            	  2777:             moveq  #$00000000,d0
02:00001D5C 46FB08DC        	  2778:             move.w MOVE4+2(pc,d0.l),SR
02:00001D60 67FE            	  2779:             beq.s *           * branch if Z set
02:00001D62 6BFE            	  2780:             bmi.s *           * branch if N set
02:00001D64 69FE            	  2781:             bvs.s *           * branch if V set
02:00001D66 65FE            	  2782:             bcs.s *           * branch if C set
02:00001D68 44FB08D0        	  2783:             move MOVE4+2(pc,d0.l),CCR
02:00001D6C 67FE            	  2784:             beq.s *           * branch if Z set
02:00001D6E 6BFE            	  2785:             bmi.s *           * branch if N set
02:00001D70 69FE            	  2786:             bvs.s *           * branch if V set
02:00001D72 65FE            	  2787:             bcs.s *           * branch if C set
                            	  2788: 
                            	  2789: *     #x
02:00001D74 46FC2FFF        	  2790:             move.w #$2FFF,SR
02:00001D78 66FE            	  2791:             bne.s *           * branch if Z clear
02:00001D7A 6AFE            	  2792:             bpl.s *           * branch if N clear
02:00001D7C 68FE            	  2793:             bvc.s *           * branch if V clear
02:00001D7E 64FE            	  2794:             bcc.s *           * branch if C clear
                            	  2795: 
                            	  2796: 
                            	  2797: 
                            	  2798: *  MOVE_From_SR
                            	  2799: 
                            	  2800: 
                            	  2801: 
                            	  2802: *     Dn
02:00001D80 46FC275A        	  2803:             move.w #$275A,SR          * Initial value
02:00001D84 40C0            	  2804:             move.w SR,d0
02:00001D86 0C40271A        	  2805:             cmpi.w #$271A,d0
                            	  2806: * The following fails because sr bits are implemented and non-zero so later code works.           
                            	  2807: *            bne.s *                   * branch if Z set
                            	  2808: 
                            	  2809: *     (An)
02:00001D8A 307C0100        	  2810:             move.l #$00000100,a0
02:00001D8E 46FC275A        	  2811:             move.w #$275A,SR          * Initial value
02:00001D92 40D0            	  2812:             move.w SR,(a0)
02:00001D94 0C50275A        	  2813:             cmpi.w #$275A,(a0)
02:00001D98 66FE            	  2814:             bne.s *                   * branch if Z set
                            	  2815: 
                            	  2816: *     (An)+
02:00001D9A 307C0100        	  2817:             move.l #$00000100,a0
02:00001D9E 46FC257A        	  2818:             move.w #$257A,SR          * Initial value
02:00001DA2 40D8            	  2819:             move.w SR,(a0)+
02:00001DA4 307C0100        	  2820:             move.l #$00000100,a0
02:00001DA8 0C58257A        	  2821:             cmpi.w #$257A,(a0)+
02:00001DAC 66FE            	  2822:             bne.s *                   * branch if Z set
                            	  2823: 
                            	  2824: *     -(An)
02:00001DAE 307C0102        	  2825:             move.l #$00000102,a0
02:00001DB2 46FC2766        	  2826:             move.w #$2766,SR          * Initial value
02:00001DB6 40E0            	  2827:             move.w SR,-(a0)
02:00001DB8 307C0100        	  2828:             move.l #$00000100,a0
02:00001DBC 0C502766        	  2829:             cmpi.w #$2766,(a0)
02:00001DC0 66FE            	  2830:             bne.s *                   * branch if Z set
                            	  2831: 
                            	  2832: *     x(An)
02:00001DC2 307C0102        	  2833:             move.l #$00000102,a0
02:00001DC6 46FC2733        	  2834:             move.w #$2733,SR          * Initial value
02:00001DCA 40E80004        	  2835:             move.w SR,4(a0)
02:00001DCE 0C6827330004    	  2836:             cmpi.w #$2733,4(a0)
02:00001DD4 66FE            	  2837:             bne.s *                   * branch if Z set
                            	  2838: 
                            	  2839: *     x(An,rn)
02:00001DD6 307C0102        	  2840:             move.l #$00000102,a0
02:00001DDA 7004            	  2841:             moveq  #$00000004,d0
02:00001DDC 46FC275A        	  2842:             move.w #$275a,SR          * Initial value
02:00001DE0 40F00804        	  2843:             move.w SR,4(a0,d0.l)
02:00001DE4 0C70275A0804    	  2844:             cmpi.w #$275a,4(a0,d0.l)
02:00001DEA 66FE            	  2845:             bne.s *                   * branch if Z set
                            	  2846: 
                            	  2847: *     x.W
02:00001DEC 46FC2777        	  2848:             move.w #$2777,SR          * Initial value
02:00001DF0 40F80102        	  2849:             move.w SR,$0102
02:00001DF4 0C7827770102    	  2850:             cmpi.w #$2777,$0102
02:00001DFA 66FE            	  2851:             bne.s *                   * branch if Z set
                            	  2852: 
                            	  2853: *     x.L
02:00001DFC 46FC2777        	  2854:             move.w #$2777,SR          * Initial value
02:00001E00 40F900010102    	  2855:             move.w SR,$10102
02:00001E06 0C79277700010102	  2856:             cmpi.w #$2777,$10102
02:00001E0E 66FE            	  2857:             bne.s *                   * branch if Z set
                            	  2858: 
                            	  2859: 
                            	  2860: 
02:00001E10 46FC2700        	  2861:             move.w #$2700,SR          * Put flags back to initial value
                            	  2862: 
02:00001E14 4E75            	  2863:             rts
                            	  2864: 
                            	  2865: 
                            	  2866: *-----------------------------------------------------------
                            	  2867: *-----------------------------------------------------------
                            	  2868: * OPCODE : EXT
                            	  2869: *-----------------------------------------------------------
                            	  2870: *-----------------------------------------------------------
                            	  2871: op_EXT:
                            	  2872: 
02:00001E16 707F            	  2873:             move.l #$0000007F,d0
02:00001E18 223C00008FFF    	  2874:             move.l #$00008FFF,d1
02:00001E1E 7400            	  2875:             moveq  #$00000000,d2
                            	  2876: 
02:00001E20 4880            	  2877:             ext.w d0
02:00001E22 6BFE            	  2878:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001E24 67FE            	  2879:             beq.s *                   * Check Z Flag  beq/bne
02:00001E26 0C800000007F    	  2880:             cmpi.l #$0000007F,d0
02:00001E2C 66FE            	  2881:             bne.s *                   * branch if Z set
                            	  2882: 
02:00001E2E 48C1            	  2883:             ext.l d1
02:00001E30 6AFE            	  2884:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001E32 67FE            	  2885:             beq.s *                   * Check Z Flag  beq/bne
02:00001E34 0C81FFFF8FFF    	  2886:             cmpi.l #$FFFF8FFF,d1
02:00001E3A 66FE            	  2887:             bne.s *                   * branch if Z set
                            	  2888: 
02:00001E3C 48C2            	  2889:             ext.l d2
02:00001E3E 66FE            	  2890:             bne.s *                   * Check Z Flag  beq/bne
                            	  2891: 
                            	  2892: 
                            	  2893: 
02:00001E40 4E75            	  2894:             rts
                            	  2895: 
                            	  2896: 
                            	  2897: *-----------------------------------------------------------
                            	  2898: *-----------------------------------------------------------
                            	  2899: * OPCODE : SWAP
                            	  2900: *-----------------------------------------------------------
                            	  2901: *-----------------------------------------------------------
                            	  2902: op_SWAP:
                            	  2903: 
02:00001E42 203C12345678    	  2904:             move.l #$12345678,d0
                            	  2905: 
02:00001E48 4840            	  2906:             swap d0
02:00001E4A 6BFE            	  2907:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001E4C 67FE            	  2908:             beq.s *                   * Check Z Flag  beq/bne
02:00001E4E 0C8056781234    	  2909:             cmpi.l #$56781234,d0
02:00001E54 66FE            	  2910:             bne.s *                   * branch if Z set
                            	  2911: 
                            	  2912: 
                            	  2913: 
02:00001E56 4E75            	  2914:             rts
                            	  2915: 
                            	  2916: 
                            	  2917: *-----------------------------------------------------------
                            	  2918: *-----------------------------------------------------------
                            	  2919: * OPCODE : LEA_PEA
                            	  2920: *-----------------------------------------------------------
                            	  2921: *-----------------------------------------------------------
                            	  2922: op_LEAPEA:
                            	  2923: 
02:00001E58 207C00345678    	  2924:             move.l #$00345678,a0
02:00001E5E 7800            	  2925:             moveq  #$00000000,d4
                            	  2926: 
                            	  2927: *     (An)
02:00001E60 4DD0            	  2928:             lea (a0),a6
02:00001E62 200E            	  2929:             move.l a6,d0
02:00001E64 0C8000345678    	  2930:             cmpi.l #$00345678,d0
02:00001E6A 66FE            	  2931:             bne.s *                   * branch if Z set
02:00001E6C 4850            	  2932:             pea (a0)
02:00001E6E 0C9700345678    	  2933:             cmpi.l #$00345678,(a7)
02:00001E74 66FE            	  2934:             bne.s *                   * branch if Z set
                            	  2935:             * This was without a specifier which the assembler defaulted to .w
02:00001E76 588F            	  2936:             addq.l #4,a7            * Restore Stack Pointer
                            	  2937: 
                            	  2938: *     x(An)
02:00001E78 4DE80004        	  2939:             lea 4(a0),a6
02:00001E7C 200E            	  2940:             move.l a6,d0
02:00001E7E 0C800034567C    	  2941:             cmpi.l #$0034567C,d0
02:00001E84 66FE            	  2942:             bne.s *                   * branch if Z set
02:00001E86 48680004        	  2943:             pea 4(a0)
02:00001E8A 0C970034567C    	  2944:             cmpi.l #$0034567C,(a7)
02:00001E90 66FE            	  2945:             bne.s *                   * branch if Z set
                            	  2946:             * This was without a specifier which the assembler defaulted to .w
02:00001E92 588F            	  2947:             addq.l #4,a7            * Restore Stack Pointer
                            	  2948: 
                            	  2949: *     x(An,Dn.l)
02:00001E94 4DF04004        	  2950:             lea 4(a0,d4),a6
02:00001E98 200E            	  2951:             move.l a6,d0
02:00001E9A 0C800034567C    	  2952:             cmpi.l #$0034567C,d0
02:00001EA0 66FE            	  2953:             bne.s *                   * branch if Z set
02:00001EA2 48704804        	  2954:             pea 4(a0,d4.l)
02:00001EA6 0C970034567C    	  2955:             cmpi.l #$0034567C,(a7)
02:00001EAC 66FE            	  2956:             bne.s *                   * branch if Z set
                            	  2957:             * This was without a specifier which the assembler defaulted to .w
02:00001EAE 588F            	  2958:             addq.l #4,a7            * Restore Stack Pointer
                            	  2959: 
                            	  2960: *     x.W
02:00001EB0 4DF81234        	  2961:             lea $1234,a6
02:00001EB4 200E            	  2962:             move.l a6,d0
02:00001EB6 0C401234        	  2963:             cmpi.w #$1234,d0
02:00001EBA 66FE            	  2964:             bne.s *                   * branch if Z set
02:00001EBC 48781234        	  2965:             pea $1234
02:00001EC0 0C9700001234    	  2966:             cmpi.l #$00001234,(a7)
02:00001EC6 66FE            	  2967:             bne.s *                   * branch if Z set
                            	  2968:             * This was without a specifier which the assembler defaulted to .w
02:00001EC8 588F            	  2969:             addq.l #4,a7            * Restore Stack Pointer
                            	  2970: 
                            	  2971: *     x.L
02:00001ECA 4DF900345678    	  2972:             lea $00345678,a6
02:00001ED0 200E            	  2973:             move.l a6,d0
02:00001ED2 B08E            	  2974:             cmp.l a6,d0
02:00001ED4 66FE            	  2975:             bne.s *                   * branch if Z set
02:00001ED6 487900345678    	  2976:             pea $00345678
02:00001EDC 0C9700345678    	  2977:             cmpi.l #$00345678,(a7)
02:00001EE2 66FE            	  2978:             bne.s *                   * branch if Z set
                            	  2979:             * This was without a specifier which the assembler defaulted to .w
02:00001EE4 588F            	  2980:             addq.l #4,a7            * Restore Stack Pointer
                            	  2981: 
                            	  2982: *     x(PC)
02:00001EE6 4DFA0008        	  2983:             lea LEA1(pc),a6
02:00001EEA 200E            	  2984:             move.l a6,d0
02:00001EEC B08E            	  2985:             cmp.l a6,d0
02:00001EEE 66FE            	  2986:             bne.s *                   * branch if Z set
02:00001EF0 487AFFFE        	  2987: LEA1:       pea LEA1(pc)
02:00001EF4 0C970000241E    	  2988:             cmpi.l #$0000241E,(a7)
02:00001EFA 67FE            	  2989:             beq.s *                   * branch if Z clear
                            	  2990:             * This was without a specifier which the assembler defaulted to .w
02:00001EFC 588F            	  2991:             addq.l #4,a7              * Restore Stack Pointer
                            	  2992: 
                            	  2993: 
                            	  2994: 
                            	  2995: 
02:00001EFE 46FC2700        	  2996:             move.w #$2700,sr          * Put flags back to initial value
                            	  2997: 
02:00001F02 4E75            	  2998:             rts
                            	  2999:  	
                            	  3000: 
                            	  3001: 
                            	  3002: *-----------------------------------------------------------
                            	  3003: *-----------------------------------------------------------
                            	  3004: * OPCODE : LEA_TAS
                            	  3005: *-----------------------------------------------------------
                            	  3006: *-----------------------------------------------------------
                            	  3007: op_TAS:
                            	  3008: 
                            	  3009: *     Test just one addressing mode
                            	  3010: 
02:00001F04 307C0100        	  3011:             move.l #$00000100,a0
                            	  3012: 
                            	  3013: *     (An)
02:00001F08 4210            	  3014:             move.b #$00,(a0)
02:00001F0A 6BFE            	  3015:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F0C 66FE            	  3016:             bne.s *                   * Check Z Flag  beq/bne
02:00001F0E 4AD0            	  3017:             tas (a0)
02:00001F10 0C100080        	  3018:             cmpi.b #$80,(a0)
02:00001F14 66FE            	  3019:             bne.s *                   * branch if Z set
02:00001F16 10BC00F5        	  3020:             move.b #$F5,(a0)
02:00001F1A 4AD0            	  3021:             tas (a0)
02:00001F1C 6AFE            	  3022:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F1E 67FE            	  3023:             beq.s *                   * Check Z Flag  beq/bne
02:00001F20 4AD0            	  3024:             tas (a0)
02:00001F22 0C1000F5        	  3025:             cmpi.b #$F5,(a0)
02:00001F26 66FE            	  3026:             bne.s *                   * branch if Z set
                            	  3027: 
02:00001F28 4E75            	  3028:             rts
                            	  3029: 
                            	  3030: 
                            	  3031: *-----------------------------------------------------------
                            	  3032: *-----------------------------------------------------------
                            	  3033: * OPCODE : LEA_TST
                            	  3034: *-----------------------------------------------------------
                            	  3035: *-----------------------------------------------------------
                            	  3036: op_TST:
                            	  3037: 
                            	  3038: *     Test just one addressing mode
                            	  3039: 
02:00001F2A 307C0100        	  3040:             move.l #$00000100,a0
                            	  3041: 
                            	  3042: *     (An) - BYTE
02:00001F2E 4210            	  3043:             move.b #$00,(a0)
02:00001F30 4A10            	  3044:             tst.b (a0)
02:00001F32 6BFE            	  3045:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F34 66FE            	  3046:             bne.s *                   * Check Z Flag  beq/bne
02:00001F36 10BC00F5        	  3047:             move.b #$F5,(a0)
02:00001F3A 4A10            	  3048:             tst.b (a0)
02:00001F3C 6AFE            	  3049:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F3E 67FE            	  3050:             beq.s *                   * Check Z Flag  beq/bne
                            	  3051: 
                            	  3052: *     (An) - WORD
02:00001F40 4250            	  3053:             move.w #$0000,(a0)
02:00001F42 4A50            	  3054:             tst.w (a0)
02:00001F44 6BFE            	  3055:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F46 66FE            	  3056:             bne.s *                   * Check Z Flag  beq/bne
02:00001F48 30BCF567        	  3057:             move.w #$F567,(a0)
02:00001F4C 4A50            	  3058:             tst.w (a0)
02:00001F4E 6AFE            	  3059:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F50 67FE            	  3060:             beq.s *                   * Check Z Flag  beq/bne
                            	  3061: 
                            	  3062: *     (An) - LONG
02:00001F52 4290            	  3063:             move.l #$00000000,(a0)
02:00001F54 4A90            	  3064:             tst.l (a0)
02:00001F56 6BFE            	  3065:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F58 66FE            	  3066:             bne.s *                   * Check Z Flag  beq/bne
02:00001F5A 20BCF56789AB    	  3067:             move.l #$F56789ab,(a0)
02:00001F60 4A90            	  3068:             tst.l (a0)
02:00001F62 6AFE            	  3069:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F64 67FE            	  3070:             beq.s *                   * Check Z Flag  beq/bne
                            	  3071: 
                            	  3072: 
02:00001F66 4E75            	  3073:             rts
                            	  3074: 
                            	  3075: 
                            	  3076: *-----------------------------------------------------------
                            	  3077: *-----------------------------------------------------------
                            	  3078: * OPCODE : LINKS
                            	  3079: *-----------------------------------------------------------
                            	  3080: *-----------------------------------------------------------
                            	  3081: op_LINKS:
                            	  3082: 
02:00001F68 207C11223344    	  3083:             move.l #$11223344,a0
02:00001F6E 203C11223344    	  3084:             move.l #$11223344,d0
02:00001F74 4E500000        	  3085:             link a0,#$0
02:00001F78 0C9711223344    	  3086:             cmpi.l #$11223344,(a7)
                            	  3087: 
02:00001F7E 4E58            	  3088:             unlk a0
02:00001F80 B1C0            	  3089:             cmp.l d0,a0
02:00001F82 66FE            	  3090:             bne.s *                   * branch if Z set
                            	  3091: 
02:00001F84 4E75            	  3092:             rts
                            	  3093: 
                            	  3094: *-----------------------------------------------------------
                            	  3095: *-----------------------------------------------------------
                            	  3096: * OPCODE : MOVE_USP
                            	  3097: *-----------------------------------------------------------
                            	  3098: *-----------------------------------------------------------
                            	  3099: op_MOVE_USP:
                            	  3100: 
02:00001F86 207C11223344    	  3101:             move.l #$11223344,a0
02:00001F8C 4E60            	  3102:             move a0,USP
02:00001F8E 4E69            	  3103:             move USP,a1
02:00001F90 B3C8            	  3104:             cmp.l a0,a1
02:00001F92 66FE            	  3105:             bne.s *                   * branch if Z set
                            	  3106: 
02:00001F94 4E75            	  3107:             rts
                            	  3108: 
                            	  3109: 
                            	  3110: *-----------------------------------------------------------
                            	  3111: *-----------------------------------------------------------
                            	  3112: * OPCODE : CHK
                            	  3113: *-----------------------------------------------------------
                            	  3114: *-----------------------------------------------------------
                            	  3115: op_CHK:
02:00001F96 303C1122        	  3116:             move.w #$1122,d0
02:00001F9A 323C1122        	  3117:             move.w #$1122,d1
02:00001F9E 4380            	  3118:             chk d0,d1
                            	  3119: 
02:00001FA0 4E71            	  3120:             nop
02:00001FA2 4E71            	  3121:             nop
                            	  3122: 
02:00001FA4 323C1122        	  3123:             move.w #$1122,d1
02:00001FA8 43BC1122        	  3124:             chk #$1122,d1
                            	  3125: 
02:00001FAC 323C1122        	  3126:             move.w #$1122,d1
02:00001FB0 43BC007A        	  3127:             chk #00122,d1
02:00001FB4 BCBCEEEE0006    	  3128:             cmp.l #$EEEE0006,d6
02:00001FBA 66FE            	  3129:             bne.s *                   * branch if Z set
                            	  3130: 
02:00001FBC 303C1122        	  3131:             move.w #$1122,d0
02:00001FC0 323C8000        	  3132:             move.w #$8000,d1
02:00001FC4 4380            	  3133:             chk d0,d1
02:00001FC6 BCBCEEEE0006    	  3134:             cmp.l #$EEEE0006,d6
02:00001FCC 66FE            	  3135:             bne.s *                   * branch if Z set
                            	  3136: 
02:00001FCE 4E75            	  3137:             rts
                            	  3138: 
                            	  3139: 
                            	  3140: *-----------------------------------------------------------
                            	  3141: *-----------------------------------------------------------
                            	  3142: * OPCODE : NEGS
                            	  3143: *-----------------------------------------------------------
                            	  3144: *-----------------------------------------------------------
                            	  3145: op_NEGS:
                            	  3146: 
                            	  3147: *     NOT - BYTE
02:00001FD0 307C0100        	  3148:             move.l #$00000100,a0
02:00001FD4 7000            	  3149:             moveq  #$00000000,d0
02:00001FD6 4600            	  3150:             not.b d0
02:00001FD8 6AFE            	  3151:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001FDA 67FE            	  3152:             beq.s *                   * Check Z Flag  beq/bne
02:00001FDC 4600            	  3153:             not.b d0
02:00001FDE 6BFE            	  3154:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001FE0 66FE            	  3155:             bne.s *                   * Check Z Flag  beq/bne
02:00001FE2 4A00            	  3156:             cmpi.b #$00,d0
02:00001FE4 66FE            	  3157:             bne.s *                   * Check Z Flag  beq/bne
02:00001FE6 10BC0080        	  3158:             move.b #$80,(a0)
02:00001FEA 4610            	  3159:             not.b (a0)
02:00001FEC 6BFE            	  3160:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001FEE 67FE            	  3161:             beq.s *                   * Check Z Flag  beq/bne
02:00001FF0 4610            	  3162:             not.b (a0)
02:00001FF2 6AFE            	  3163:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001FF4 67FE            	  3164:             beq.s *                   * Check Z Flag  beq/bne
02:00001FF6 0C100080        	  3165:             cmpi.b #$80,(a0)
02:00001FFA 66FE            	  3166:             bne.s *                   * Check Z Flag  beq/bne
                            	  3167: 
                            	  3168: *     NOT - WORD
02:00001FFC 307C0100        	  3169:             move.l #$00000100,a0
02:00002000 7000            	  3170:             moveq  #$00000000,d0
02:00002002 4640            	  3171:             not.w d0
02:00002004 6AFE            	  3172:             bpl.s *                   * Check N Flag  bmi/bpl
02:00002006 67FE            	  3173:             beq.s *                   * Check Z Flag  beq/bne
02:00002008 4640            	  3174:             not.w d0
02:0000200A 6BFE            	  3175:             bmi.s *                   * Check N Flag  bmi/bpl
02:0000200C 66FE            	  3176:             bne.s *                   * Check Z Flag  beq/bne
02:0000200E 4A40            	  3177:             cmpi.w #$0000,d0
02:00002010 66FE            	  3178:             bne.s *                   * Check Z Flag  beq/bne
02:00002012 30BC5A5A        	  3179:             move.w #$5a5a,(a0)
02:00002016 4650            	  3180:             not.w (a0)
02:00002018 6AFE            	  3181:             bpl.s *                   * Check N Flag  bmi/bpl
02:0000201A 67FE            	  3182:             beq.s *                   * Check Z Flag  beq/bne
02:0000201C 4650            	  3183:             not.w (a0)
02:0000201E 6BFE            	  3184:             bmi.s *                   * Check N Flag  bmi/bpl
02:00002020 67FE            	  3185:             beq.s *                   * Check Z Flag  beq/bne
02:00002022 0C505A5A        	  3186:             cmpi.w #$5a5a,(a0)
02:00002026 66FE            	  3187:             bne.s *                   * Check Z Flag  beq/bne
                            	  3188: 
                            	  3189: *     NOT - LONG
02:00002028 307C0100        	  3190:             move.l #$00000100,a0
02:0000202C 7000            	  3191:             moveq  #$00000000,d0
02:0000202E 4680            	  3192:             not.l d0
02:00002030 6AFE            	  3193:             bpl.s *                   * Check N Flag  bmi/bpl
02:00002032 67FE            	  3194:             beq.s *                   * Check Z Flag  beq/bne
02:00002034 4680            	  3195:             not.l d0
02:00002036 6BFE            	  3196:             bmi.s *                   * Check N Flag  bmi/bpl
02:00002038 66FE            	  3197:             bne.s *                   * Check Z Flag  beq/bne
02:0000203A 4A80            	  3198:             cmpi.l #$00000000,d0
02:0000203C 66FE            	  3199:             bne.s *                   * Check Z Flag  beq/bne
02:0000203E 20BC5A5A1234    	  3200:             move.l #$5a5a1234,(a0)
02:00002044 4690            	  3201:             not.l (a0)
02:00002046 6AFE            	  3202:             bpl.s *                   * Check N Flag  bmi/bpl
02:00002048 67FE            	  3203:             beq.s *                   * Check Z Flag  beq/bne
02:0000204A 4690            	  3204:             not.l (a0)
02:0000204C 6BFE            	  3205:             bmi.s *                   * Check N Flag  bmi/bpl
02:0000204E 67FE            	  3206:             beq.s *                   * Check Z Flag  beq/bne
02:00002050 0C905A5A1234    	  3207:             cmpi.l #$5a5a1234,(a0)
02:00002056 66FE            	  3208:             bne.s *                   * Check Z Flag  beq/bne
                            	  3209: 
                            	  3210: * -----
                            	  3211: 
                            	  3212: *     NEG - BYTE
02:00002058 307C0100        	  3213:             move.l #$00000100,a0
02:0000205C 7000            	  3214:             moveq  #$00000000,d0
02:0000205E 7240D241        	  3215:             move.l #$00000080,d1
02:00002062 4400            	  3216:             neg.b d0
02:00002064 6BFE            	  3217:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002066 66FE            	  3218:             bne.s *                   * Check Z Flag  beq/bne 1
02:00002068 65FE            	  3219:             bcs.s *                   * Check C Flag  bcc/bcs 1
02:0000206A 69FE            	  3220:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000206C 4401            	  3221:             neg.b d1
02:0000206E 6AFE            	  3222:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002070 67FE            	  3223:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002072 64FE            	  3224:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002074 68FE            	  3225:             bvc.s *                   * Check V Flag  bvc/bvs 0
02:00002076 0C010080        	  3226:             cmpi.b #$80,d1
02:0000207A 66FE            	  3227:             bne.s *                   * Check Z Flag  beq/bne
02:0000207C 10BC007F        	  3228:             move.b #$7F,(a0)
02:00002080 4410            	  3229:             neg.b (a0)
02:00002082 6AFE            	  3230:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002084 67FE            	  3231:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002086 64FE            	  3232:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002088 69FE            	  3233:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000208A 10BC00F5        	  3234:             move.b #$F5,(a0)
02:0000208E 4410            	  3235:             neg.b (a0)
02:00002090 6BFE            	  3236:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002092 67FE            	  3237:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002094 64FE            	  3238:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002096 69FE            	  3239:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002098 0C10000B        	  3240:             cmpi.b #$0B,(a0)
02:0000209C 66FE            	  3241:             bne.s *                   * Check Z Flag  beq/bne
                            	  3242: 
                            	  3243: * -----
                            	  3244: 
                            	  3245: *     NEG - WORD
02:0000209E 307C0100        	  3246:             move.l #$00000100,a0
02:000020A2 7000            	  3247:             moveq  #$00000000,d0
02:000020A4 223C00008000    	  3248:             move.l #$00008000,d1
02:000020AA 4440            	  3249:             neg.w d0
02:000020AC 6BFE            	  3250:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000020AE 66FE            	  3251:             bne.s *                   * Check Z Flag  beq/bne 1
02:000020B0 65FE            	  3252:             bcs.s *                   * Check C Flag  bcc/bcs 1
02:000020B2 69FE            	  3253:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020B4 4441            	  3254:             neg.w d1
02:000020B6 6AFE            	  3255:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000020B8 67FE            	  3256:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020BA 64FE            	  3257:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020BC 68FE            	  3258:             bvc.s *                   * Check V Flag  bvc/bvs 0
02:000020BE 0C418000        	  3259:             cmpi.w #$8000,d1
02:000020C2 66FE            	  3260:             bne.s *                   * Check Z Flag  beq/bne
02:000020C4 30BC7FFF        	  3261:             move.w #$7FFF,(a0)
02:000020C8 4450            	  3262:             neg.w (a0)
02:000020CA 6AFE            	  3263:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000020CC 67FE            	  3264:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020CE 64FE            	  3265:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020D0 69FE            	  3266:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020D2 30BCF578        	  3267:             move.w #$F578,(a0)
02:000020D6 4450            	  3268:             neg.w (a0)
02:000020D8 6BFE            	  3269:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000020DA 67FE            	  3270:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020DC 64FE            	  3271:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020DE 69FE            	  3272:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020E0 0C500A88        	  3273:             cmpi.w #$0A88,(a0)
02:000020E4 66FE            	  3274:             bne.s *                   * Check Z Flag  beq/bne
                            	  3275: 
                            	  3276: * -----
                            	  3277: 
                            	  3278: *     NEG - LONG
02:000020E6 307C0100        	  3279:             move.l #$00000100,a0
02:000020EA 7000            	  3280:             moveq  #$00000000,d0
02:000020EC 223C80000000    	  3281:             move.l #$80000000,d1
02:000020F2 4480            	  3282:             neg.l d0
02:000020F4 6BFE            	  3283:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000020F6 66FE            	  3284:             bne.s *                   * Check Z Flag  beq/bne 1
02:000020F8 65FE            	  3285:             bcs.s *                   * Check C Flag  bcc/bcs 1
02:000020FA 69FE            	  3286:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020FC 4481            	  3287:             neg.l d1
02:000020FE 6AFE            	  3288:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002100 67FE            	  3289:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002102 64FE            	  3290:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002104 68FE            	  3291:             bvc.s *                   * Check V Flag  bvc/bvs 0
02:00002106 0C8180000000    	  3292:             cmpi.l #$80000000,d1
02:0000210C 66FE            	  3293:             bne.s *                   * Check Z Flag  beq/bne
02:0000210E 20BC7FFFFFFF    	  3294:             move.l #$7FFFFFFF,(a0)
02:00002114 4490            	  3295:             neg.l (a0)
02:00002116 6AFE            	  3296:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002118 67FE            	  3297:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000211A 64FE            	  3298:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000211C 69FE            	  3299:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000211E 20BCF5781234    	  3300:             move.l #$F5781234,(a0)
02:00002124 4490            	  3301:             neg.l (a0)
02:00002126 6BFE            	  3302:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002128 67FE            	  3303:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000212A 64FE            	  3304:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000212C 69FE            	  3305:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000212E 0C900A87EDCC    	  3306:             cmpi.l #$0A87EDCC,(a0)
02:00002134 66FE            	  3307:             bne.s *                   * Check Z Flag  beq/bne
                            	  3308: 
                            	  3309: 
                            	  3310: * -----
                            	  3311: 
                            	  3312: *     NEGX - BYTE
02:00002136 307C0100        	  3313:             move.l #$00000100,a0
02:0000213A 7000            	  3314:             moveq  #$00000000,d0
02:0000213C 7240D241        	  3315:             move.l #$00000080,d1
02:00002140 003C0010        	  3316:             ori.b #$10,CCR        * Set X Flag
02:00002144 4000            	  3317:             negx.b d0
02:00002146 6AFE            	  3318:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:00002148 67FE            	  3319:             beq.s *                   * Check Z Flag  beq/bne 1
02:0000214A 64FE            	  3320:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:0000214C 69FE            	  3321:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000214E 023C00EF        	  3322:             andi.b #$EF,CCR       * Clear X Flag
02:00002152 4000            	  3323:             negx.b d0
02:00002154 6BFE            	  3324:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002156 67FE            	  3325:             beq.s *                   * Check Z Flag  beq/bne 1
02:00002158 64FE            	  3326:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:0000215A 69FE            	  3327:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000215C 003C0010        	  3328:             ori.b #$10,CCR        * Set X Flag
02:00002160 4001            	  3329:             negx.b d1
02:00002162 6BFE            	  3330:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:00002164 67FE            	  3331:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002166 64FE            	  3332:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002168 69FE            	  3333:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:0000216A 0C01007F        	  3334:             cmpi.b #$7F,d1
02:0000216E 66FE            	  3335:             bne.s *                   * Check Z Flag  beq/bne
02:00002170 023C00EF        	  3336:             andi.b #$EF,CCR       * Clear X Flag
02:00002174 4001            	  3337:             negx.b d1
02:00002176 6AFE            	  3338:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002178 67FE            	  3339:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000217A 64FE            	  3340:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000217C 69FE            	  3341:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:0000217E 0C010081        	  3342:             cmpi.b #$81,d1
02:00002182 66FE            	  3343:             bne.s *                   * Check Z Flag  beq/bne
02:00002184 10BC007F        	  3344:             move.b #$7F,(a0)
02:00002188 003C0010        	  3345:             ori.b #$10,CCR        * Set X Flag
02:0000218C 4010            	  3346:             negx.b (a0)
02:0000218E 6AFE            	  3347:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002190 67FE            	  3348:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002192 64FE            	  3349:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3350:             * I think overflow should happen here.
                            	  3351: *            bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002194 10BC007F        	  3352:             move.b #$7F,(a0)
02:00002198 023C00EF        	  3353:             andi.b #$EF,CCR       * Clear X Flag
02:0000219C 4010            	  3354:             negx.b (a0)
02:0000219E 6AFE            	  3355:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000021A0 67FE            	  3356:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021A2 64FE            	  3357:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000021A4 69FE            	  3358:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021A6 10BC00F5        	  3359:             move.b #$F5,(a0)
02:000021AA 003C0010        	  3360:             ori.b #$10,CCR        * Set X Flag
02:000021AE 4010            	  3361:             negx.b (a0)
02:000021B0 6BFE            	  3362:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000021B2 67FE            	  3363:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021B4 64FE            	  3364:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000021B6 69FE            	  3365:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021B8 0C10000A        	  3366:             cmpi.b #$0A,(a0)
02:000021BC 66FE            	  3367:             bne.s *                   * Check Z Flag  beq/bne
02:000021BE 023C00EF        	  3368:             andi.b #$EF,CCR       * Clear X Flag
02:000021C2 4010            	  3369:             negx.b (a0)
02:000021C4 6AFE            	  3370:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:000021C6 67FE            	  3371:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021C8 64FE            	  3372:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000021CA 69FE            	  3373:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021CC 0C1000F6        	  3374:             cmpi.b #$F6,(a0)
02:000021D0 66FE            	  3375:             bne.s *                   * Check Z Flag  beq/bne
                            	  3376: 
                            	  3377: 
                            	  3378: 
                            	  3379: * -----
                            	  3380: 
                            	  3381: *     NEGX - WORD
02:000021D2 307C0100        	  3382:             move.l #$00000100,a0
02:000021D6 7000            	  3383:             moveq  #$00000000,d0
02:000021D8 223C00008000    	  3384:             move.l #$00008000,d1
02:000021DE 003C0010        	  3385:             ori.b #$10,CCR        * Set X Flag
02:000021E2 4040            	  3386:             negx.w d0
02:000021E4 6AFE            	  3387:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:000021E6 67FE            	  3388:             beq.s *                   * Check Z Flag  beq/bne 1
02:000021E8 64FE            	  3389:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:000021EA 69FE            	  3390:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021EC 023C00EF        	  3391:             andi.b #$EF,CCR       * Clear X Flag
02:000021F0 4040            	  3392:             negx.w d0
02:000021F2 6BFE            	  3393:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000021F4 67FE            	  3394:             beq.s *                   * Check Z Flag  beq/bne 1
02:000021F6 64FE            	  3395:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:000021F8 69FE            	  3396:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021FA 003C0010        	  3397:             ori.b #$10,CCR        * Set X Flag
02:000021FE 4041            	  3398:             negx.w d1
02:00002200 6BFE            	  3399:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:00002202 67FE            	  3400:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002204 64FE            	  3401:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002206 69FE            	  3402:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:00002208 0C417FFF        	  3403:             cmpi.w #$7FFF,d1
02:0000220C 66FE            	  3404:             bne.s *                   * Check Z Flag  beq/bne
02:0000220E 023C00EF        	  3405:             andi.b #$EF,CCR       * Clear X Flag
02:00002212 4041            	  3406:             negx.w d1
02:00002214 6AFE            	  3407:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002216 67FE            	  3408:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002218 64FE            	  3409:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000221A 69FE            	  3410:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:0000221C 0C418001        	  3411:             cmpi.w #$8001,d1
02:00002220 66FE            	  3412:             bne.s *                   * Check Z Flag  beq/bne
02:00002222 30BC7FFF        	  3413:             move.w #$7FFF,(a0)
02:00002226 003C0010        	  3414:             ori.b #$10,CCR        * Set X Flag
02:0000222A 4050            	  3415:             negx.w (a0)
02:0000222C 6AFE            	  3416:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:0000222E 67FE            	  3417:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002230 64FE            	  3418:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3419: ***            
                            	  3420: *            bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002232 30BCF567        	  3421:             move.w #$F567,(a0)
02:00002236 023C00EF        	  3422:             andi.b #$EF,CCR       * Clear X Flag
02:0000223A 4050            	  3423:             negx.w (a0)
02:0000223C 6BFE            	  3424:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:0000223E 67FE            	  3425:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002240 64FE            	  3426:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002242 69FE            	  3427:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002244 30BCF567        	  3428:             move.w #$F567,(a0)
02:00002248 003C0010        	  3429:             ori.b #$10,CCR        * Set X Flag
02:0000224C 4050            	  3430:             negx.w (a0)
02:0000224E 6BFE            	  3431:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002250 67FE            	  3432:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002252 64FE            	  3433:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002254 69FE            	  3434:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002256 0C500A98        	  3435:             cmpi.w #$0A98,(a0)
02:0000225A 66FE            	  3436:             bne.s *                   * Check Z Flag  beq/bne
02:0000225C 023C00EF        	  3437:             andi.b #$EF,CCR       * Clear X Flag
02:00002260 4050            	  3438:             negx.w (a0)
02:00002262 6AFE            	  3439:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:00002264 67FE            	  3440:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002266 64FE            	  3441:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002268 69FE            	  3442:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000226A 0C50F568        	  3443:             cmpi.w #$F568,(a0)
02:0000226E 66FE            	  3444:             bne.s *                   * Check Z Flag  beq/bne
                            	  3445: 
                            	  3446: 
                            	  3447: * -----
                            	  3448: 
                            	  3449: *     NEGX - LONG
02:00002270 307C0100        	  3450:             move.l #$00000100,a0
02:00002274 7000            	  3451:             moveq  #$00000000,d0
02:00002276 223C80000000    	  3452:             move.l #$80000000,d1
02:0000227C 003C0010        	  3453:             ori.b #$10,CCR        * Set X Flag
02:00002280 4080            	  3454:             negx.l d0
02:00002282 6AFE            	  3455:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:00002284 67FE            	  3456:             beq.s *                   * Check Z Flag  beq/bne 1
02:00002286 64FE            	  3457:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:00002288 69FE            	  3458:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000228A 023C00EF        	  3459:             andi.b #$EF,CCR       * Clear X Flag
02:0000228E 4080            	  3460:             negx.l d0
02:00002290 6BFE            	  3461:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002292 67FE            	  3462:             beq.s *                   * Check Z Flag  beq/bne 1
02:00002294 64FE            	  3463:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:00002296 69FE            	  3464:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002298 003C0010        	  3465:             ori.b #$10,CCR        * Set X Flag
02:0000229C 4081            	  3466:             negx.l d1
02:0000229E 6BFE            	  3467:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:000022A0 67FE            	  3468:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022A2 64FE            	  3469:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000022A4 69FE            	  3470:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:000022A6 0C817FFFFFFF    	  3471:             cmpi.l #$7FFFFFFF,d1
02:000022AC 66FE            	  3472:             bne.s *                   * Check Z Flag  beq/bne
02:000022AE 023C00EF        	  3473:             andi.b #$EF,CCR       * Clear X Flag
02:000022B2 4081            	  3474:             negx.l d1
02:000022B4 6AFE            	  3475:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000022B6 67FE            	  3476:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022B8 64FE            	  3477:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3478: ****            
                            	  3479: *            bvs.s *                   * Check V Flag  bvc/bvs 0
02:000022BA 0C8180000001    	  3480:             cmpi.l #$80000001,d1
02:000022C0 66FE            	  3481:             bne.s *                   * Check Z Flag  beq/bne
02:000022C2 20BC00007FFF    	  3482:             move.l #$7FFF,(a0)
02:000022C8 003C0010        	  3483:             ori.b #$10,CCR        * Set X Flag
02:000022CC 4090            	  3484:             negx.l (a0)
02:000022CE 6AFE            	  3485:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000022D0 67FE            	  3486:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022D2 64FE            	  3487:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3488: ****            
                            	  3489: *            bvs.s *                   * Check V Flag  bvc/bvs 1
02:000022D4 20BCF5671234    	  3490:             move.l #$F5671234,(a0)
02:000022DA 023C00EF        	  3491:             andi.b #$EF,CCR       * Clear X Flag
02:000022DE 4090            	  3492:             negx.l (a0)
02:000022E0 6BFE            	  3493:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:000022E2 67FE            	  3494:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022E4 64FE            	  3495:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000022E6 69FE            	  3496:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000022E8 20BCF5675678    	  3497:             move.l #$F5675678,(a0)
02:000022EE 003C0010        	  3498:             ori.b #$10,CCR        * Set X Flag
02:000022F2 4090            	  3499:             negx.l (a0)
02:000022F4 6BFE            	  3500:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000022F6 67FE            	  3501:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022F8 64FE            	  3502:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000022FA 69FE            	  3503:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000022FC 0C900A98A987    	  3504:             cmpi.l #$0A98A987,(a0)
02:00002302 66FE            	  3505:             bne.s *                   * Check Z Flag  beq/bne
02:00002304 023C00EF        	  3506:             andi.b #$EF,CCR       * Clear X Flag
02:00002308 4090            	  3507:             negx.l (a0)
02:0000230A 6AFE            	  3508:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:0000230C 67FE            	  3509:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000230E 64FE            	  3510:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002310 69FE            	  3511:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002312 0C90F5675679    	  3512:             cmpi.l #$F5675679,(a0)
02:00002318 66FE            	  3513:             bne.s *                   * Check Z Flag  beq/bne
                            	  3514: 
                            	  3515: 
                            	  3516: * -----
                            	  3517: 
                            	  3518: *     CLR - BYTE
02:0000231A 307C0100        	  3519:             move.l #$00000100,a0
02:0000231E 203C12345678    	  3520:             move.l #$12345678,d0
02:00002324 223C12345678    	  3521:             move.l #$12345678,d1
02:0000232A 243C12345678    	  3522:             move.l #$12345678,d2
02:00002330 283C12345600    	  3523:             move.l #$12345600,d4
02:00002336 2A3C12340000    	  3524:             move.l #$12340000,d5
02:0000233C 7C00            	  3525:             moveq  #$00000000,d6
                            	  3526: 
02:0000233E 4200            	  3527:             clr.b d0
02:00002340 66FE            	  3528:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002342 6BFE            	  3529:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002344 B880            	  3530:             cmp.l d0,d4
02:00002346 66FE            	  3531:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3532: 
02:00002348 4241            	  3533:             clr.w d1
02:0000234A 66FE            	  3534:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000234C 6BFE            	  3535:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000234E BA81            	  3536:             cmp.l d1,d5
02:00002350 66FE            	  3537:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3538: 
02:00002352 7400            	  3539:             clr.l d2
02:00002354 66FE            	  3540:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002356 6BFE            	  3541:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002358 BC82            	  3542:             cmp.l d2,d6
02:0000235A 66FE            	  3543:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3544: 
02:0000235C 4E75            	  3545:             rts
                            	  3546: 
                            	  3547: 
                            	  3548: 
                            	  3549: *-----------------------------------------------------------
                            	  3550: *-----------------------------------------------------------
                            	  3551: * OPCODE : MOVEM
                            	  3552: *-----------------------------------------------------------
                            	  3553: *-----------------------------------------------------------
                            	  3554: op_MOVEM:
                            	  3555: 
                            	  3556: *     WORD  Registers --> Memory
02:0000235E 203C0000D0D0    	  3557:             move.l #$0000d0d0,d0
02:00002364 223C0000D1D1    	  3558:             move.l #$0000d1d1,d1
02:0000236A 243C0000D2D2    	  3559:             move.l #$0000d2d2,d2
02:00002370 263C0000D3D3    	  3560:             move.l #$0000d3d3,d3
02:00002376 283C0000D4D4    	  3561:             move.l #$0000d4d4,d4
02:0000237C 2A3C0000D5D5    	  3562:             move.l #$0000d5d5,d5
02:00002382 2C3C0000D6D6    	  3563:             move.l #$0000d6d6,d6
02:00002388 2E3C0000D7D7    	  3564:             move.l #$0000d7d7,d7
02:0000238E 307C0A0A        	  3565:             move.l #$00000a0a,a0
02:00002392 327C1A1A        	  3566:             move.l #$00001a1a,a1
02:00002396 347C2A2A        	  3567:             move.l #$00002a2a,a2
02:0000239A 367C3A3A        	  3568:             move.l #$00003a3a,a3
02:0000239E 387C4A4A        	  3569:             move.l #$00004a4a,a4
02:000023A2 3A7C5A5A        	  3570:             move.l #$00005a5a,a5
02:000023A6 3C7C6A6A        	  3571:             move.l #$00006a6a,a6
                            	  3572: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3573: 
02:000023AA 48B8FFFF0100    	  3574:             movem.w D0-D7/A0-A7,$00000100
                            	  3575: 
02:000023B0 307C0100        	  3576:             move.l #$00000100,a0
                            	  3577: 
02:000023B4 B058            	  3578:             cmp.w (a0)+,d0
02:000023B6 66FE            	  3579:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023B8 B258            	  3580:             cmp.w (a0)+,d1
02:000023BA 66FE            	  3581:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023BC B458            	  3582:             cmp.w (a0)+,d2
02:000023BE 66FE            	  3583:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023C0 B658            	  3584:             cmp.w (a0)+,d3
02:000023C2 66FE            	  3585:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023C4 B858            	  3586:             cmp.w (a0)+,d4
02:000023C6 66FE            	  3587:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023C8 BA58            	  3588:             cmp.w (a0)+,d5
02:000023CA 66FE            	  3589:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023CC BC58            	  3590:             cmp.w (a0)+,d6
02:000023CE 66FE            	  3591:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023D0 BE58            	  3592:             cmp.w (a0)+,d7
02:000023D2 66FE            	  3593:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3594: 
02:000023D4 0C580A0A        	  3595:             cmpi.w #$0A0A,(a0)+    * Because we are using a0 as a pointer
02:000023D8 66FE            	  3596:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3597: 
02:000023DA B2D8            	  3598:             cmp.w (a0)+,a1
02:000023DC 66FE            	  3599:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023DE B4D8            	  3600:             cmp.w (a0)+,a2
02:000023E0 66FE            	  3601:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023E2 B6D8            	  3602:             cmp.w (a0)+,a3
02:000023E4 66FE            	  3603:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023E6 B8D8            	  3604:             cmp.w (a0)+,a4
02:000023E8 66FE            	  3605:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023EA BAD8            	  3606:             cmp.w (a0)+,a5
02:000023EC 66FE            	  3607:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023EE BCD8            	  3608:             cmp.w (a0)+,a6
02:000023F0 66FE            	  3609:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3610: 
                            	  3611: 
                            	  3612: 
                            	  3613: 
                            	  3614: *     LONG  Registers --> Memory
02:000023F2 203CD0D0D0D0    	  3615:             move.l #$d0d0d0d0,d0
02:000023F8 223CD1D1D1D1    	  3616:             move.l #$d1d1d1d1,d1
02:000023FE 243CD2D2D2D2    	  3617:             move.l #$d2d2d2d2,d2
02:00002404 263CD3D3D3D3    	  3618:             move.l #$d3d3d3d3,d3
02:0000240A 283CD4D4D4D4    	  3619:             move.l #$d4d4d4d4,d4
02:00002410 2A3CD5D5D5D5    	  3620:             move.l #$d5d5d5d5,d5
02:00002416 2C3CD6D6D6D6    	  3621:             move.l #$d6d6d6d6,d6
02:0000241C 2E3CD7D7D7D7    	  3622:             move.l #$d7d7d7d7,d7
02:00002422 207C0A0A0A0A    	  3623:             move.l #$0a0a0a0a,a0
02:00002428 227C1A1A1A1A    	  3624:             move.l #$1a1a1a1a,a1
02:0000242E 247C2A2A2A2A    	  3625:             move.l #$2a2a2a2a,a2
02:00002434 267C3A3A3A3A    	  3626:             move.l #$3a3a3a3a,a3
02:0000243A 287C4A4A4A4A    	  3627:             move.l #$4a4a4a4a,a4
02:00002440 2A7C5A5A5A5A    	  3628:             move.l #$5a5a5a5a,a5
02:00002446 2C7C6A6A6A6A    	  3629:             move.l #$6a6a6a6a,a6
                            	  3630: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3631: 
                            	  3632: 
02:0000244C 48F8FFFF0120    	  3633:             movem.l D0-D7/A0-A7,$00000120
                            	  3634: 
02:00002452 307C0120        	  3635:             move.l #$00000120,a0
                            	  3636: 
02:00002456 B098            	  3637:             cmp.l (a0)+,d0
02:00002458 66FE            	  3638:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000245A B298            	  3639:             cmp.l (a0)+,d1
02:0000245C 66FE            	  3640:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000245E B498            	  3641:             cmp.l (a0)+,d2
02:00002460 66FE            	  3642:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002462 B698            	  3643:             cmp.l (a0)+,d3
02:00002464 66FE            	  3644:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002466 B898            	  3645:             cmp.l (a0)+,d4
02:00002468 66FE            	  3646:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000246A BA98            	  3647:             cmp.l (a0)+,d5
02:0000246C 66FE            	  3648:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000246E BC98            	  3649:             cmp.l (a0)+,d6
02:00002470 66FE            	  3650:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002472 BE98            	  3651:             cmp.l (a0)+,d7
02:00002474 66FE            	  3652:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3653: 
02:00002476 0C980A0A0A0A    	  3654:             cmpi.l #$0A0A0A0A,(a0)+    * Because we are using a0 as a pointer
02:0000247C 66FE            	  3655:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3656: 
02:0000247E B3D8            	  3657:             cmp.l (a0)+,a1
02:00002480 66FE            	  3658:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002482 B5D8            	  3659:             cmp.l (a0)+,a2
02:00002484 66FE            	  3660:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002486 B7D8            	  3661:             cmp.l (a0)+,a3
02:00002488 66FE            	  3662:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000248A B9D8            	  3663:             cmp.l (a0)+,a4
02:0000248C 66FE            	  3664:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000248E BBD8            	  3665:             cmp.l (a0)+,a5
02:00002490 66FE            	  3666:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002492 BDD8            	  3667:             cmp.l (a0)+,a6
02:00002494 66FE            	  3668:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3669: *      ----
                            	  3670: 
                            	  3671: 
                            	  3672: *     WORD  Registers --> Memory  -(An) EA Mode
02:00002496 203C0000D0D0    	  3673:             move.l #$0000d0d0,d0
02:0000249C 223C0000D1D1    	  3674:             move.l #$0000d1d1,d1
02:000024A2 243C0000D2D2    	  3675:             move.l #$0000d2d2,d2
02:000024A8 263C0000D3D3    	  3676:             move.l #$0000d3d3,d3
02:000024AE 283C0000D4D4    	  3677:             move.l #$0000d4d4,d4
02:000024B4 2A3C0000D5D5    	  3678:             move.l #$0000d5d5,d5
02:000024BA 2C3C0000D6D6    	  3679:             move.l #$0000d6d6,d6
02:000024C0 2E3C0000D7D7    	  3680:             move.l #$0000d7d7,d7
02:000024C6 307C0A0A        	  3681:             move.l #$00000a0a,a0
02:000024CA 327C1A1A        	  3682:             move.l #$00001a1a,a1
02:000024CE 347C2A2A        	  3683:             move.l #$00002a2a,a2
02:000024D2 367C3A3A        	  3684:             move.l #$00003a3a,a3
02:000024D6 387C4A4A        	  3685:             move.l #$00004a4a,a4
02:000024DA 3A7C5A5A        	  3686:             move.l #$00005a5a,a5
02:000024DE 3C7C6A6A        	  3687:             move.l #$00006a6a,a6
                            	  3688: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3689: 
02:000024E2 307C01A0        	  3690:             move.l #$000001A0,a0
02:000024E6 48A0FFFF        	  3691:             movem.w D0-D7/A0-A7,-(a0)
                            	  3692: 
02:000024EA 307C019E        	  3693:             move.l #$0000019E,a0
                            	  3694: 
02:000024EE BCE0            	  3695:             cmp.w -(a0),a6
02:000024F0 66FE            	  3696:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024F2 BAE0            	  3697:             cmp.w -(a0),a5
02:000024F4 66FE            	  3698:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024F6 B8E0            	  3699:             cmp.w -(a0),a4
02:000024F8 66FE            	  3700:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024FA B6E0            	  3701:             cmp.w -(a0),a3
02:000024FC 66FE            	  3702:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024FE B4E0            	  3703:             cmp.w -(a0),a2
02:00002500 66FE            	  3704:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002502 B2E0            	  3705:             cmp.w -(a0),a1
02:00002504 66FE            	  3706:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002506 B0E0            	  3707:             cmp.w -(a0),a0
                            	  3708: *            bne.s *                   * Check Z Flag  beq/bne 0
02:00002508 BE60            	  3709:             cmp.w -(a0),d7
02:0000250A 66FE            	  3710:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000250C BC60            	  3711:             cmp.w -(a0),d6
02:0000250E 66FE            	  3712:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002510 BA60            	  3713:             cmp.w -(a0),d5
02:00002512 66FE            	  3714:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002514 B860            	  3715:             cmp.w -(a0),d4
02:00002516 66FE            	  3716:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002518 B660            	  3717:             cmp.w -(a0),d3
02:0000251A 66FE            	  3718:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000251C B460            	  3719:             cmp.w -(a0),d2
02:0000251E 66FE            	  3720:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002520 B260            	  3721:             cmp.w -(a0),d1
02:00002522 66FE            	  3722:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002524 B060            	  3723:             cmp.w -(a0),d0
02:00002526 66FE            	  3724:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3725: 
                            	  3726: 
                            	  3727: 
                            	  3728: 
                            	  3729: *     LONG  Registers --> Memory   -(An) EA Mode
02:00002528 203CD0D0D0D0    	  3730:             move.l #$d0d0d0d0,d0
02:0000252E 223CD1D1D1D1    	  3731:             move.l #$d1d1d1d1,d1
02:00002534 243CD2D2D2D2    	  3732:             move.l #$d2d2d2d2,d2
02:0000253A 263CD3D3D3D3    	  3733:             move.l #$d3d3d3d3,d3
02:00002540 283CD4D4D4D4    	  3734:             move.l #$d4d4d4d4,d4
02:00002546 2A3CD5D5D5D5    	  3735:             move.l #$d5d5d5d5,d5
02:0000254C 2C3CD6D6D6D6    	  3736:             move.l #$d6d6d6d6,d6
02:00002552 2E3CD7D7D7D7    	  3737:             move.l #$d7d7d7d7,d7
02:00002558 207C0A0A0A0A    	  3738:             move.l #$0a0a0a0a,a0
02:0000255E 227C1A1A1A1A    	  3739:             move.l #$1a1a1a1a,a1
02:00002564 247C2A2A2A2A    	  3740:             move.l #$2a2a2a2a,a2
02:0000256A 267C3A3A3A3A    	  3741:             move.l #$3a3a3a3a,a3
02:00002570 287C4A4A4A4A    	  3742:             move.l #$4a4a4a4a,a4
02:00002576 2A7C5A5A5A5A    	  3743:             move.l #$5a5a5a5a,a5
02:0000257C 2C7C6A6A6A6A    	  3744:             move.l #$6a6a6a6a,a6
                            	  3745: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3746: 
                            	  3747: 
02:00002582 307C01A0        	  3748:             move.l #$000001A0,a0
02:00002586 48E0FFFF        	  3749:             movem.l D0-D7/A0-A7,-(a0)
                            	  3750: 
02:0000258A 307C019C        	  3751:             move.l #$0000019C,a0
                            	  3752: 
02:0000258E BDE0            	  3753:             cmp.l -(a0),a6
02:00002590 66FE            	  3754:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002592 BBE0            	  3755:             cmp.l -(a0),a5
02:00002594 66FE            	  3756:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002596 B9E0            	  3757:             cmp.l -(a0),a4
02:00002598 66FE            	  3758:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000259A B7E0            	  3759:             cmp.l -(a0),a3
02:0000259C 66FE            	  3760:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000259E B5E0            	  3761:             cmp.l -(a0),a2
02:000025A0 66FE            	  3762:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025A2 B3E0            	  3763:             cmp.l -(a0),a1
02:000025A4 66FE            	  3764:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025A6 B1E0            	  3765:             cmp.l -(a0),a0
                            	  3766: *            bne.s *                   * Check Z Flag  beq/bne 0
02:000025A8 BEA0            	  3767:             cmp.l -(a0),d7
02:000025AA 66FE            	  3768:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025AC BCA0            	  3769:             cmp.l -(a0),d6
02:000025AE 66FE            	  3770:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025B0 BAA0            	  3771:             cmp.l -(a0),d5
02:000025B2 66FE            	  3772:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025B4 B8A0            	  3773:             cmp.l -(a0),d4
02:000025B6 66FE            	  3774:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025B8 B6A0            	  3775:             cmp.l -(a0),d3
02:000025BA 66FE            	  3776:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025BC B4A0            	  3777:             cmp.l -(a0),d2
02:000025BE 66FE            	  3778:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025C0 B2A0            	  3779:             cmp.l -(a0),d1
02:000025C2 66FE            	  3780:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025C4 B0A0            	  3781:             cmp.l -(a0),d0
02:000025C6 66FE            	  3782:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3783: 
                            	  3784: 
                            	  3785: 
                            	  3786: *     ----
                            	  3787: 
                            	  3788: *     WORD - Memory --> Registers
02:000025C8 7000            	  3789:             moveq  #$00000000,d0
02:000025CA 7200            	  3790:             moveq  #$00000000,d1
02:000025CC 7400            	  3791:             moveq  #$00000000,d2
02:000025CE 7600            	  3792:             moveq  #$00000000,d3
02:000025D0 7800            	  3793:             moveq  #$00000000,d4
02:000025D2 7A00            	  3794:             moveq  #$00000000,d5
02:000025D4 7C00            	  3795:             moveq  #$00000000,d6
02:000025D6 7E00            	  3796:             moveq  #$00000000,d7
02:000025D8 91C8            	  3797:             move.l #$00000000,a0
02:000025DA 93C9            	  3798:             move.l #$00000000,a1
02:000025DC 95CA            	  3799:             move.l #$00000000,a2
02:000025DE 97CB            	  3800:             move.l #$00000000,a3
02:000025E0 99CC            	  3801:             move.l #$00000000,a4
02:000025E2 9BCD            	  3802:             move.l #$00000000,a5
02:000025E4 9DCE            	  3803:             move.l #$00000000,a6
                            	  3804: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3805: 
02:000025E6 4CB82A550100    	  3806:             movem.w $00000100,D0/D2/D4/D6/A1/A3/A5
                            	  3807: 
02:000025EC B0BCFFFFD0D0    	  3808:             cmp.l #$FFFFD0D0,d0
02:000025F2 66FE            	  3809:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025F4 B4BCFFFFD1D1    	  3810:             cmp.l #$FFFFD1D1,d2
02:000025FA 66FE            	  3811:             bne.s *                  * Check Z Flag  beq/bne 0
02:000025FC B8BCFFFFD2D2    	  3812:             cmp.l #$FFFFD2D2,d4
02:00002602 66FE            	  3813:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002604 BCBCFFFFD3D3    	  3814:             cmp.l #$FFFFD3D3,d6
02:0000260A 66FE            	  3815:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000260C B2FCD4D4        	  3816:             cmp.l #$FFFFD4D4,a1
02:00002610 66FE            	  3817:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002612 B6FCD5D5        	  3818:             cmp.l #$FFFFD5D5,a3
02:00002616 66FE            	  3819:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002618 BAFCD6D6        	  3820:             cmp.l #$FFFFD6D6,a5
02:0000261C 66FE            	  3821:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3822: 
                            	  3823: 
                            	  3824: *     LONG - Memory --> Registers
02:0000261E 7000            	  3825:             moveq  #$00000000,d0
02:00002620 7200            	  3826:             moveq  #$00000000,d1
02:00002622 7400            	  3827:             moveq  #$00000000,d2
02:00002624 7600            	  3828:             moveq  #$00000000,d3
02:00002626 7800            	  3829:             moveq  #$00000000,d4
02:00002628 7A00            	  3830:             moveq  #$00000000,d5
02:0000262A 7C00            	  3831:             moveq  #$00000000,d6
02:0000262C 7E00            	  3832:             moveq  #$00000000,d7
02:0000262E 91C8            	  3833:             move.l #$00000000,a0
02:00002630 93C9            	  3834:             move.l #$00000000,a1
02:00002632 95CA            	  3835:             move.l #$00000000,a2
02:00002634 97CB            	  3836:             move.l #$00000000,a3
02:00002636 99CC            	  3837:             move.l #$00000000,a4
02:00002638 9BCD            	  3838:             move.l #$00000000,a5
02:0000263A 9DCE            	  3839:             move.l #$00000000,a6
                            	  3840: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3841: 
02:0000263C 4CF82A550120    	  3842:             movem.l $00000120,D0/D2/D4/D6/A1/A3/A5
                            	  3843: 
02:00002642 B0BCD0D0D0D0    	  3844:             cmp.l #$D0D0D0D0,d0
02:00002648 66FE            	  3845:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000264A B4BCD1D1D1D1    	  3846:             cmp.l #$D1D1D1D1,d2
02:00002650 66FE            	  3847:             bne.s *                  * Check Z Flag  beq/bne 0
02:00002652 B8BCD2D2D2D2    	  3848:             cmp.l #$D2D2D2D2,d4
02:00002658 66FE            	  3849:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000265A BCBCD3D3D3D3    	  3850:             cmp.l #$D3D3D3D3,d6
02:00002660 66FE            	  3851:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002662 B3FCD4D4D4D4    	  3852:             cmp.l #$D4D4D4D4,a1
02:00002668 66FE            	  3853:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000266A B7FCD5D5D5D5    	  3854:             cmp.l #$D5D5D5D5,a3
02:00002670 66FE            	  3855:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002672 BBFCD6D6D6D6    	  3856:             cmp.l #$D6D6D6D6,a5
02:00002678 66FE            	  3857:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3858: 
02:0000267A 4E75            	  3859:             rts
                            	  3860: 
                            	  3861: 
                            	  3862: *-----------------------------------------------------------
                            	  3863: *-----------------------------------------------------------
                            	  3864: * OPCODE : ABCD
                            	  3865: *-----------------------------------------------------------
                            	  3866: *-----------------------------------------------------------
                            	  3867: op_ABCD:
                            	  3868: 
                            	  3869: *     Test with X Flag CLEARED
02:0000267C 307C0110        	  3870:                 move.l #$00000110,a0 * Address pointer-X
02:00002680 327C0120        	  3871:                 move.l #$00000120,a1 * Address pointer-Y
02:00002684 7000            	  3872:                 moveq  #$00000000,d0 * BCD byte-X
02:00002686 7200            	  3873:                 moveq  #$00000000,d1 * BCD byte-Y
02:00002688 7400            	  3874:                 moveq  #$00000000,d2
02:0000268A 7600            	  3875:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:0000268C 7800            	  3876:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:0000268E 7A00            	  3877:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:00002690 2C3C00000099    	  3878:                 move.l #$00000099,d6 * Inner loop counter
02:00002696 2E3C00000099    	  3879:                 move.l #$00000099,d7 * Outer loop counter
                            	  3880: 
02:0000269C 2007            	  3881: ABCD_OUTER1:    move.l d7,d0
02:0000269E 2206            	  3882: ABCD_INNER1:    move.l d6,d1
02:000026A0 023C00EF        	  3883:                 andi.b #$EF,CCR     * Clear X Flag
02:000026A4 307C0110        	  3884:                 move.l #$00000110,a0 * Address pointer-X
02:000026A8 327C0120        	  3885:                 move.l #$00000120,a1 * Address pointer-Y
02:000026AC 1140FFFF        	  3886:                 move.b d0,-1(a0)
02:000026B0 1341FFFF        	  3887:                 move.b d1,-1(a1)
                            	  3888: 
02:000026B4 C300            	  3889:                 abcd d0,d1
02:000026B6 6402            	  3890:                 bcc.s ABCD_NO_C1          * Check C Flag  bcc/bcs 0
02:000026B8 5284            	  3891:                 add.l #1,d4
02:000026BA DA81            	  3892: ABCD_NO_C1:     add.l d1,d5
                            	  3893: 
02:000026BC C308            	  3894:                 abcd -(a0),-(a1)
02:000026BE 6402            	  3895:                 bcc.s ABCD_NO_C2          * Check C Flag  bcc/bcs 0
02:000026C0 5284            	  3896:                 add.l #1,d4
02:000026C2 D611            	  3897: ABCD_NO_C2:     add.b (a1),d3
                            	  3898: 
                            	  3899: 
02:000026C4 51CEFFD8        	  3900:                 dbf d6,ABCD_INNER1
02:000026C8 2C3C00000099    	  3901:                 move.l #$00000099,d6
02:000026CE 51CFFFCC        	  3902:                 dbf d7,ABCD_OUTER1
02:000026D2 0C8400005AFC    	  3903:                 cmpi.l #$00005AFC,d4  * Check the cumulative results
02:000026D8 66FE            	  3904:                 bne.s *
02:000026DA 0C85001C9A34    	  3905:                 cmpi.l #$001C9A34,d5
02:000026E0 66FE            	  3906:                 bne.s *
02:000026E2 0C8300000034    	  3907:                 cmpi.l #$00000034,d3
02:000026E8 66FE            	  3908:                 bne.s *
                            	  3909: 
                            	  3910: *     Test with X Flag SET
02:000026EA 307C0110        	  3911:                 move.l #$00000110,a0 * Address pointer-X
02:000026EE 327C0120        	  3912:                 move.l #$00000120,a1 * Address pointer-Y
02:000026F2 7000            	  3913:                 moveq  #$00000000,d0 * BCD byte-X
02:000026F4 7200            	  3914:                 moveq  #$00000000,d1 * BCD byte-Y
02:000026F6 7400            	  3915:                 moveq  #$00000000,d2
02:000026F8 7600            	  3916:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:000026FA 7800            	  3917:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:000026FC 7A00            	  3918:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:000026FE 2C3C00000099    	  3919:                 move.l #$00000099,d6 * Inner loop counter
02:00002704 2E3C00000099    	  3920:                 move.l #$00000099,d7 * Outer loop counter
                            	  3921: 
02:0000270A 2007            	  3922: ABCD_OUTER2:    move.l d7,d0
02:0000270C 2206            	  3923: ABCD_INNER2:    move.l d6,d1
02:0000270E 003C0010        	  3924:                 ori.b #$10,CCR      * Set X Flag
02:00002712 307C0110        	  3925:                 move.l #$00000110,a0 * Address pointer-X
02:00002716 327C0120        	  3926:                 move.l #$00000120,a1 * Address pointer-Y
02:0000271A 1140FFFF        	  3927:                 move.b d0,-1(a0)
02:0000271E 1341FFFF        	  3928:                 move.b d1,-1(a1)
                            	  3929: 
02:00002722 C300            	  3930:                 abcd d0,d1
02:00002724 6402            	  3931:                 bcc.s ABCD_NO_C3          * Check C Flag  bcc/bcs 0
02:00002726 5284            	  3932:                 add.l #1,d4
02:00002728 DA81            	  3933: ABCD_NO_C3:     add.l d1,d5
                            	  3934: 
02:0000272A C308            	  3935:                 abcd -(a0),-(a1)
02:0000272C 6402            	  3936:                 bcc.s ABCD_NO_C4          * Check C Flag  bcc/bcs 0
02:0000272E 5284            	  3937:                 add.l #1,d4
02:00002730 D611            	  3938: ABCD_NO_C4:     add.b (a1),d3
                            	  3939: 
                            	  3940: 
02:00002732 51CEFFD8        	  3941:                 dbf d6,ABCD_INNER2
02:00002736 2C3C00000099    	  3942:                 move.l #$00000099,d6
02:0000273C 51CFFFCC        	  3943:                 dbf d7,ABCD_OUTER2
02:00002740 0C8400005B60    	  3944:                 cmpi.l #$00005B60,d4  * Check the cumulative results
02:00002746 66FE            	  3945:                 bne.s *
02:00002748 0C85001CCFC8    	  3946:                 cmpi.l #$001CCFC8,d5
02:0000274E 66FE            	  3947:                 bne.s *
02:00002750 0C8300000034    	  3948:                 cmpi.l #$00000034,d3
02:00002756 66FE            	  3949:                 bne.s *
                            	  3950: 
                            	  3951: *             Quick check of Z Flag
02:00002758 4200            	  3952:                 move.b #$00,d0
02:0000275A 4201            	  3953:                 move.b #$00,d1
02:0000275C 44FC0000        	  3954:                 move #$00,CCR              * Set Z flag to 0
02:00002760 C101            	  3955:                 abcd d1,d0                  * Should NOT set Z Flag to 1
02:00002762 67FE            	  3956:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3957: 
02:00002764 103C0001        	  3958:                 move.b #$01,d0
02:00002768 4201            	  3959:                 move.b #$00,d1
02:0000276A 44FC0004        	  3960:                 move #$04,CCR              * Set Z flag to 0
02:0000276E C101            	  3961:                 abcd d1,d0                  * Should NOT set Z Flag to 1
02:00002770 67FE            	  3962:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3963: 
02:00002772 4E75            	  3964:                 rts
                            	  3965: 
                            	  3966: *-----------------------------------------------------------
                            	  3967: *-----------------------------------------------------------
                            	  3968: * OPCODE : SBCD
                            	  3969: *-----------------------------------------------------------
                            	  3970: *-----------------------------------------------------------
                            	  3971: op_SBCD:
                            	  3972: 
                            	  3973: *     Test with X Flag CLEARED
02:00002774 307C0110        	  3974:                 move.l #$00000110,a0 * Address pointer-X
02:00002778 327C0120        	  3975:                 move.l #$00000120,a1 * Address pointer-Y
02:0000277C 7000            	  3976:                 moveq  #$00000000,d0 * BCD byte-X
02:0000277E 7200            	  3977:                 moveq  #$00000000,d1 * BCD byte-Y
02:00002780 7400            	  3978:                 moveq  #$00000000,d2
02:00002782 7600            	  3979:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:00002784 7800            	  3980:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:00002786 7A00            	  3981:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:00002788 2C3C00000099    	  3982:                 move.l #$00000099,d6 * Inner loop counter
02:0000278E 2E3C00000099    	  3983:                 move.l #$00000099,d7 * Outer loop counter
                            	  3984: 
02:00002794 2007            	  3985: SBCD_OUTER1:    move.l d7,d0
02:00002796 2206            	  3986: SBCD_INNER1:    move.l d6,d1
02:00002798 023C00EF        	  3987:                 andi.b #$EF,CCR     * Clear X Flag
02:0000279C 307C0110        	  3988:                 move.l #$00000110,a0 * Address pointer-X
02:000027A0 327C0120        	  3989:                 move.l #$00000120,a1 * Address pointer-Y
02:000027A4 1140FFFF        	  3990:                 move.b d0,-1(a0)
02:000027A8 1341FFFF        	  3991:                 move.b d1,-1(a1)
                            	  3992: 
02:000027AC 8300            	  3993:                 sbcd d0,d1
02:000027AE 6402            	  3994:                 bcc.s SBCD_NO_C1          * Check C Flag  bcc/bcs 0
02:000027B0 5284            	  3995:                 add.l #1,d4
02:000027B2 DA81            	  3996: SBCD_NO_C1:     add.l d1,d5
                            	  3997: 
02:000027B4 8308            	  3998:                 sbcd -(a0),-(a1)
02:000027B6 6402            	  3999:                 bcc.s SBCD_NO_C2          * Check C Flag  bcc/bcs 0
02:000027B8 5284            	  4000:                 add.l #1,d4
02:000027BA D611            	  4001: SBCD_NO_C2:     add.b (a1),d3
                            	  4002: 
                            	  4003: 
02:000027BC 51CEFFD8        	  4004:                 dbf d6,SBCD_INNER1
02:000027C0 2C3C00000099    	  4005:                 move.l #$00000099,d6
02:000027C6 51CFFFCC        	  4006:                 dbf d7,SBCD_OUTER1
02:000027CA 0C8400005C0A    	  4007:                 cmpi.l #$00005C0A,d4  * Check the cumulative results
02:000027D0 66FE            	  4008:                 bne.s *
02:000027D2 0C85001C459E    	  4009:                 cmpi.l #$001C459E,d5
02:000027D8 66FE            	  4010:                 bne.s *
02:000027DA 0C830000009E    	  4011:                 cmpi.l #$0000009E,d3
02:000027E0 66FE            	  4012:                 bne.s *
                            	  4013: 
                            	  4014: *     Test with X Flag SET
02:000027E2 307C0110        	  4015:                 move.l #$00000110,a0 * Address pointer-X
02:000027E6 327C0120        	  4016:                 move.l #$00000120,a1 * Address pointer-Y
02:000027EA 7000            	  4017:                 moveq  #$00000000,d0 * BCD byte-X
02:000027EC 7200            	  4018:                 moveq  #$00000000,d1 * BCD byte-Y
02:000027EE 7400            	  4019:                 moveq  #$00000000,d2
02:000027F0 7600            	  4020:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:000027F2 7800            	  4021:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:000027F4 7A00            	  4022:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:000027F6 2C3C00000099    	  4023:                 move.l #$00000099,d6 * Inner loop counter
02:000027FC 2E3C00000099    	  4024:                 move.l #$00000099,d7 * Outer loop counter
                            	  4025: 
02:00002802 2007            	  4026: SBCD_OUTER2:    move.l d7,d0
02:00002804 2206            	  4027: SBCD_INNER2:    move.l d6,d1
02:00002806 003C0010        	  4028:                 ori.b #$10,CCR      * Set X Flag
02:0000280A 307C0110        	  4029:                 move.l #$00000110,a0 * Address pointer-X
02:0000280E 327C0120        	  4030:                 move.l #$00000120,a1 * Address pointer-Y
02:00002812 1140FFFF        	  4031:                 move.b d0,-1(a0)
02:00002816 1341FFFF        	  4032:                 move.b d1,-1(a1)
                            	  4033: 
02:0000281A 8300            	  4034:                 sbcd d0,d1
02:0000281C 6402            	  4035:                 bcc.s SBCD_NO_C3          * Check C Flag  bcc/bcs 0
02:0000281E 5284            	  4036:                 add.l #1,d4
02:00002820 DA81            	  4037: SBCD_NO_C3:     add.l d1,d5
                            	  4038: 
02:00002822 8308            	  4039:                 sbcd -(a0),-(a1)
02:00002824 6402            	  4040:                 bcc.s SBCD_NO_C4          * Check C Flag  bcc/bcs 0
02:00002826 5284            	  4041:                 add.l #1,d4
02:00002828 D611            	  4042: SBCD_NO_C4:     add.b (a1),d3
                            	  4043: 
02:0000282A 51CEFFD8        	  4044:                 dbf d6,SBCD_INNER2
02:0000282E 2C3C00000099    	  4045:                 move.l #$00000099,d6
02:00002834 51CFFFCC        	  4046:                 dbf d7,SBCD_OUTER2
02:00002838 0C8400005CA4    	  4047:                 cmpi.l #$00005CA4,d4  * Check the cumulative results
02:0000283E 66FE            	  4048:                 bne.s *
02:00002840 0C85001C5C66    	  4049:                 cmpi.l #$001C5C66,d5
02:00002846 66FE            	  4050:                 bne.s *
02:00002848 0C830000009E    	  4051:                 cmpi.l #$0000009E,d3
02:0000284E 66FE            	  4052:                 bne.s *
                            	  4053: 
                            	  4054: 
                            	  4055: *             Quick check of Z Flag
02:00002850 4200            	  4056:                 move.b #$00,d0
02:00002852 4201            	  4057:                 move.b #$00,d1
02:00002854 44FC0000        	  4058:                 move #$00,CCR              * Set Z flag to 0
02:00002858 8101            	  4059:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
02:0000285A 67FE            	  4060:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4061: 
02:0000285C 103C0001        	  4062:                 move.b #$01,d0
02:00002860 4201            	  4063:                 move.b #$00,d1
02:00002862 44FC0004        	  4064:                 move #$04,CCR              * Set Z flag to 0
02:00002866 8101            	  4065:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
02:00002868 67FE            	  4066:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4067: 
02:0000286A 4E75            	  4068:                 rts
                            	  4069: 
                            	  4070: *-----------------------------------------------------------
                            	  4071: *-----------------------------------------------------------
                            	  4072: * OPCODE : NBCD
                            	  4073: *-----------------------------------------------------------
                            	  4074: *-----------------------------------------------------------
                            	  4075: op_NBCD:
                            	  4076: 
                            	  4077: *        NBCD to a  Register
                            	  4078: 
02:0000286C 7000            	  4079:                 moveq  #$00000000,d0 * BCD byte
02:0000286E 7200            	  4080:                 moveq  #$00000000,d1
02:00002870 7400            	  4081:                 moveq  #$00000000,d2
02:00002872 7600            	  4082:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
02:00002874 7800            	  4083:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:00002876 7A00            	  4084:                 moveq  #$00000000,d5 * Cumulative BCD results
02:00002878 2C3C00000099    	  4085:                 move.l #$00000099,d6
02:0000287E 2E3C00000099    	  4086:                 move.l #$00000099,d7 * Loop counter
                            	  4087: 
02:00002884 2007            	  4088: NBCD_LOOP:      move.l d7,d0
02:00002886 44FC0004        	  4089:                 move #$04,CCR        * Set Z flag to 0
                            	  4090: 
02:0000288A 4800            	  4091:                 nbcd d0
                            	  4092: 
02:0000288C 6402            	  4093:                 bcc.s NBCD_NO_C         * Check C Flag
02:0000288E 5284            	  4094:                 add.l #1,d4
02:00002890 6602            	  4095: NBCD_NO_C:      bne.s NBCD_NO_Z         * Check Z Flag
02:00002892 5283            	  4096:                 add.l #1,d3
02:00002894 DA80            	  4097: NBCD_NO_Z:      add.l d0,d5         * Add results into d5
                            	  4098: 
02:00002896 51CFFFEC        	  4099:                 dbf d7,NBCD_LOOP
                            	  4100: 
02:0000289A 0C8300000001    	  4101:                 cmpi.l #$00000001,d3  * Check the cumulative results
02:000028A0 66FE            	  4102:                 bne.s *
02:000028A2 0C8400000099    	  4103:                 cmpi.l #$00000099,d4
02:000028A8 66FE            	  4104:                 bne.s *
02:000028AA 0C8500002E3B    	  4105:                 cmpi.l #$00002E3B,d5
02:000028B0 66FE            	  4106:                 bne.s *
                            	  4107: 
                            	  4108: 
                            	  4109: *        NBCD to a memory location
                            	  4110: 
02:000028B2 7000            	  4111:                 moveq  #$00000000,d0 * BCD byte
02:000028B4 7200            	  4112:                 moveq  #$00000000,d1
02:000028B6 7400            	  4113:                 moveq  #$00000000,d2
02:000028B8 7600            	  4114:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
02:000028BA 7800            	  4115:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:000028BC 7A00            	  4116:                 moveq  #$00000000,d5 * Cumulative BCD results
02:000028BE 2C3C00000099    	  4117:                 move.l #$00000099,d6
02:000028C4 2E3C00000099    	  4118:                 move.l #$00000099,d7 * Loop counter
                            	  4119: 
02:000028CA 11C70100        	  4120: NBCD_LOOP1:     move.b d7,$00000100
02:000028CE 44FC0004        	  4121:                 move #$04,CCR        * Set Z flag to 0
                            	  4122: 
02:000028D2 48380100        	  4123:                 nbcd $00000100
02:000028D6 10380100        	  4124:                 move.b $00000100,d0
                            	  4125: 
02:000028DA 6402            	  4126:                 bcc.s NBCD_NO_C1        * Check C Flag
02:000028DC 5284            	  4127:                 add.l #1,d4
02:000028DE 6602            	  4128: NBCD_NO_C1:     bne.s NBCD_NO_Z1        * Check Z Flag
02:000028E0 5283            	  4129:                 add.l #1,d3
02:000028E2 DA80            	  4130: NBCD_NO_Z1:     add.l d0,d5         * Add results into d5
                            	  4131: 
02:000028E4 51CFFFE4        	  4132:                 dbf d7,NBCD_LOOP1
                            	  4133: 
02:000028E8 0C8300000001    	  4134:                 cmpi.l #$00000001,d3  * Check the cumulative results
02:000028EE 66FE            	  4135:                 bne.s *
02:000028F0 4A84            	  4136:                 cmpi.l #$00000000,d4
02:000028F2 66FE            	  4137:                 bne.s *
02:000028F4 0C8500002E3B    	  4138:                 cmpi.l #$00002E3B,d5
02:000028FA 66FE            	  4139:                 bne.s *
                            	  4140: 
                            	  4141: 
02:000028FC 4E75            	  4142:                 rts
                            	  4143: 
                            	  4144: 
                            	  4145: 
                            	  4146: *-----------------------------------------------------------
                            	  4147: *-----------------------------------------------------------
                            	  4148: * OPCODE : TRAPV
                            	  4149: *-----------------------------------------------------------
                            	  4150: *-----------------------------------------------------------
                            	  4151: op_TRAPV:
                            	  4152: 
                            	  4153: *     TRAPV will set d0 to 12345678 if V flag is set
                            	  4154: 
02:000028FE 7000            	  4155:                 moveq  #$00000000,d0 * Clear d0
                            	  4156: 
02:00002900 44FC0000        	  4157:                 move #$00,CCR        * Clear V flag
02:00002904 4E76            	  4158:                 trapv
02:00002906 4A80            	  4159:                 cmpi.l #$00000000,d0  * Check of d0 was updated (should not be_)
02:00002908 66FE            	  4160:                 bne.s *
                            	  4161: 
02:0000290A 44FC0002        	  4162:                 move #$02,CCR        * Set V flag
02:0000290E 4E76            	  4163:                 trapv
02:00002910 0C8012345678    	  4164:                 cmpi.l #$12345678,d0  * Check of d0 was updated (should not be_)
02:00002916 66FE            	  4165:                 bne.s *
                            	  4166: 
                            	  4167: 
02:00002918 4E75            	  4168:                 rts
                            	  4169: 
                            	  4170: 
                            	  4171: 
                            	  4172: *-----------------------------------------------------------
                            	  4173: *-----------------------------------------------------------
                            	  4174: * OPCODE : RTR
                            	  4175: *-----------------------------------------------------------
                            	  4176: *-----------------------------------------------------------
                            	  4177: 
                            	  4178: op_RTR:
                            	  4179: 
                            	  4180: *     Leventhal claims only 5 LSB's are popped from the stack to the CCR
                            	  4181: 
02:0000291A 41FA000A        	  4182:                 lea 		RTR_DONE,a0
02:0000291E 2F08            	  4183:                 move.l 	a0,-(a7)     * push destination PC to the stack
02:00002920 3F3CFF15        	  4184:                 move.w 	#$FF15,-(a7)       * push flags=0xFFFF to the stack
02:00002924 4E77            	  4185:                 rtr
                            	  4186: 
02:00002926 40C0            	  4187: RTR_DONE:       move.w SR,d0
02:00002928 0240001F        	  4188:                 andi.w #$1F,d0
02:0000292C 0C400015        	  4189:                 cmpi.w #$15,d0
02:00002930 66FE            	  4190:                 bne.s *
                            	  4191: 
02:00002932 4E75            	  4192:                 rts
                            	  4193: 
                            	  4194: 
02:00002934 283C44444444    	  4195: BSR_FAR2:       move.l #$44444444,d4
02:0000293A 4E75            	  4196:                 rts
                            	  4197: 
                            	  4198: 
                            	  4199: *-----------------------------------------------------------
                            	  4200: *-----------------------------------------------------------
                            	  4201: * OPCODE : BCC
                            	  4202: *-----------------------------------------------------------
                            	  4203: *-----------------------------------------------------------
                            	  4204: 
02:0000293C 44FC0000        	  4205: op_BCC:         move #$00,CCR
02:00002940 6202            	  4206:                 bhi.s BCC1            * Higher Than         C=0 AND Z=0
02:00002942 60FE            	  4207:                 bra.s *
                            	  4208: 
02:00002944 44FC0001        	  4209: BCC1:           move #$01,CCR
02:00002948 63000004        	  4210:                 bls.w BCC2            * Lower or Same       C=1 OR Z=1
02:0000294C 60FE            	  4211:                 bra.s *
                            	  4212: 
02:0000294E 44FC0000        	  4213: BCC2:           move #$00,CCR
02:00002952 6402            	  4214:                 bcc.s BCC3            * Carry Clear         C=0
02:00002954 60FE            	  4215:                 bra.s *
                            	  4216: 
02:00002956 44FC0001        	  4217: BCC3:           move #$01,CCR
02:0000295A 65000004        	  4218:                 bcs.w BCC4            * Carry Set           C=1
02:0000295E 60FE            	  4219:                 bra.s *
                            	  4220: 
02:00002960 44FC0000        	  4221: BCC4:           move #$00,CCR
02:00002964 6602            	  4222:                 bne.s BCC5            * Not Equal           Z=0
02:00002966 60FE            	  4223:                 bra.s *
                            	  4224: 
02:00002968 44FC0004        	  4225: BCC5:           move #$04,CCR
02:0000296C 67000004        	  4226:                 beq.w BCC6            * Equal               Z=1
02:00002970 60FE            	  4227:                 bra.s *
                            	  4228: 
02:00002972 44FC0000        	  4229: BCC6:           move #$00,CCR
02:00002976 6802            	  4230:                 bvc.s BCC7            * V Clear             V=0
02:00002978 60FE            	  4231:                 bra.s *
                            	  4232: 
02:0000297A 44FC0002        	  4233: BCC7:           move #$02,CCR
02:0000297E 69000004        	  4234:                 bvs.w BCC8            * V Set               V=1
02:00002982 60FE            	  4235:                 bra.s *
                            	  4236: 
02:00002984 44FC0000        	  4237: BCC8:           move #$00,CCR
02:00002988 6A02            	  4238:                 bpl.s BCC9            * Plus                N=0
02:0000298A 60FE            	  4239:                 bra.s *
                            	  4240: 
02:0000298C 44FC0008        	  4241: BCC9:           move #$08,CCR
02:00002990 6B000004        	  4242:                 bmi.w BCC10           * Minus               N=1
02:00002994 60FE            	  4243:                 bra.s *
                            	  4244: 
02:00002996 44FC0000        	  4245: BCC10:          move #$00,CCR
02:0000299A 6C02            	  4246:                 bge.s BCC11           * Greater or Equal    N=V
02:0000299C 60FE            	  4247:                 bra.s *
                            	  4248: 
02:0000299E 44FC0002        	  4249: BCC11:          move #$02,CCR
02:000029A2 6D000004        	  4250:                 blt.w BCC12           * Less Than           N!=V
02:000029A6 60FE            	  4251:                 bra.s *
                            	  4252: 
02:000029A8 44FC000A        	  4253: BCC12:          move #$0A,CCR
02:000029AC 6E02            	  4254:                 bgt.s BCC13           * Greater Than        N=V  AND Z=0
02:000029AE 60FE            	  4255:                 bra.s *
                            	  4256: 
02:000029B0 44FC0006        	  4257: BCC13:          move #$06,CCR
02:000029B4 6F000004        	  4258:                 ble.w BCC14           * Less Than or Equal  N!=V AND Z=1
02:000029B8 60FE            	  4259:                 bra.s *
                            	  4260: 
                            	  4261: 
02:000029BA 4E75            	  4262: BCC14:          rts
                            	  4263: 
                            	  4264: 
                            	  4265: *-----------------------------------------------------------
                            	  4266: *-----------------------------------------------------------
                            	  4267: * OPCODE : DBCC
                            	  4268: *-----------------------------------------------------------
                            	  4269: *-----------------------------------------------------------
                            	  4270: 
02:000029BC 7003            	  4271: op_DBCC:        moveq  #$00000003,d0    * Loop counter
02:000029BE 7200            	  4272:                 moveq  #$00000000,d1    * Accumulator
02:000029C0 44FC0000        	  4273:                 move #$00,CCR
                            	  4274: 
02:000029C4 5201            	  4275: DBCC_LOOP1:     addi.b #$1,d1
02:000029C6 51C8FFFC        	  4276:                 dbf d0,DBCC_LOOP1
                            	  4277: 
02:000029CA 0C8100000004    	  4278:                 cmpi.l #$00000004,d1  * Check Accumulator results
02:000029D0 66FE            	  4279:                 bne.s *
                            	  4280: 
02:000029D2 5201            	  4281: DBCC_LOOP2:     addi.b #$1,d1
02:000029D4 54C8FFFC        	  4282:                 dbcc d0,DBCC_LOOP2    * Dont loop
                            	  4283: 
02:000029D8 0C8100000005    	  4284:                 cmpi.l #$00000005,d1  * Check Accumulator results
02:000029DE 66FE            	  4285:                 bne.s *
                            	  4286: 
02:000029E0 4E75            	  4287:                 rts
                            	  4288: 
                            	  4289: 
                            	  4290: *-----------------------------------------------------------
                            	  4291: *-----------------------------------------------------------
                            	  4292: * OPCODE : SCC
                            	  4293: *-----------------------------------------------------------
                            	  4294: *-----------------------------------------------------------
                            	  4295: 
02:000029E2 44FC0001        	  4296: op_SCC:         move #$01,CCR
02:000029E6 54F900010000    	  4297:                 scc $00010000                   * Clear the EA byte
02:000029EC 4A3900010000    	  4298:                 cmpi.b #$00,$00010000
02:000029F2 66FE            	  4299:                 bne.s *
                            	  4300: 
02:000029F4 44FC0000        	  4301:                 move #$00,CCR
02:000029F8 54F900010000    	  4302:                 scc $00010000                   * Set the EA byte to 0xFF
02:000029FE 0C3900FF00010000	  4303:                 cmpi.b #$FF,$00010000
02:00002A06 66FE            	  4304:                 bne.s *
                            	  4305: 
02:00002A08 54C0            	  4306: 								scc d0													* Test setting a data register
02:00002A0A 0C0000FF        	  4307: 								cmpi.b #$FF,d0
02:00002A0E 66FE            	  4308: 								bne.s *
02:00002A10 4E75            	  4309:                 rts
                            	  4310: 
                            	  4311: 
                            	  4312: 
                            	  4313: *-----------------------------------------------------------
                            	  4314: *-----------------------------------------------------------
                            	  4315: * OPCODE : ADDQ
                            	  4316: *-----------------------------------------------------------
                            	  4317: *-----------------------------------------------------------
                            	  4318: 
                            	  4319: op_ADDQ:
                            	  4320: 
                            	  4321: *     BYTE
02:00002A12 203C000000FF    	  4322:                 move.l #$000000FF,d0    * Loop counter
02:00002A18 7200            	  4323:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002A1A 7400            	  4324:                 moveq  #$00000000,d2    * Data results accumulator
02:00002A1C 7600            	  4325:                 moveq  #$00000000,d3
02:00002A1E 7800            	  4326:                 moveq  #$00000000,d4
02:00002A20 7A00            	  4327:                 moveq  #$00000000,d5
02:00002A22 7C00            	  4328:                 moveq  #$00000000,d6
02:00002A24 7E00            	  4329:                 moveq  #$00000000,d7
                            	  4330: 
02:00002A26 5605            	  4331: ADDQ_LOOP1:     addq.b #3,d5
02:00002A28 40C6            	  4332:                 move.w SR,d6
02:00002A2A 02860000001F    	  4333:                 andi.l #$1F,d6        * Isolate flags
02:00002A30 D286            	  4334:                 add.l d6,d1           * Copy flag results into accumulator
02:00002A32 D485            	  4335:                 add.l d5,d2           * Copy data results into data accumulator
02:00002A34 51C8FFF0        	  4336:                 dbf d0,ADDQ_LOOP1
                            	  4337: 
02:00002A38 0C810000043D    	  4338:                 cmpi.l #$0000043D,d1
02:00002A3E 66FE            	  4339:                 bne.s *
02:00002A40 0C8200007F80    	  4340:                 cmpi.l #$00007F80,d2
02:00002A46 66FE            	  4341:                 bne.s *
                            	  4342: 
                            	  4343: 
                            	  4344: *     WORD
02:00002A48 203C000000FF    	  4345:                 move.l #$000000FF,d0    * Loop counter
02:00002A4E 7200            	  4346:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002A50 7400            	  4347:                 moveq  #$00000000,d2    * Data results accumulator
02:00002A52 7600            	  4348:                 moveq  #$00000000,d3
02:00002A54 7800            	  4349:                 moveq  #$00000000,d4
02:00002A56 2A3C0000FFF0    	  4350:                 move.l #$0000FFF0,d5
02:00002A5C 7C00            	  4351:                 moveq  #$00000000,d6
02:00002A5E 7E00            	  4352:                 moveq  #$00000000,d7
02:00002A60 307C0100        	  4353:                 move.l #$00000100,a0
                            	  4354: 
02:00002A64 5A45            	  4355: ADDQ_LOOP2:     addq.w #5,d5
02:00002A66 40C6            	  4356:                 move.w SR,d6
02:00002A68 02860000001F    	  4357:                 andi.l #$1F,d6        * Isolate flags
02:00002A6E D286            	  4358:                 add.l d6,d1           * Copy flag results into accumulator
02:00002A70 D485            	  4359:                 add.l d5,d2           * Copy data results into data accumulator
02:00002A72 51C8FFF0        	  4360:                 dbf d0,ADDQ_LOOP2
                            	  4361: 
02:00002A76 0C8100000029    	  4362:                 cmpi.l #$00000029,d1
02:00002A7C 66FE            	  4363:                 bne.s *
02:00002A7E 0C8200057280    	  4364:                 cmpi.l #$00057280,d2
02:00002A84 66FE            	  4365:                 bne.s *
                            	  4366: 
                            	  4367: 
                            	  4368: *     LONG
02:00002A86 203C000000FF    	  4369:                 move.l #$000000FF,d0    * Loop counter
02:00002A8C 7200            	  4370:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002A8E 7400            	  4371:                 moveq  #$00000000,d2    * Data results accumulator
02:00002A90 7600            	  4372:                 moveq  #$00000000,d3
02:00002A92 7800            	  4373:                 moveq  #$00000000,d4
02:00002A94 7AF0            	  4374:                 move.l #$FFFFFFF0,d5
02:00002A96 7C00            	  4375:                 moveq  #$00000000,d6
02:00002A98 7E00            	  4376:                 moveq  #$00000000,d7
                            	  4377: 
02:00002A9A 5285            	  4378: ADDQ_LOOP3:     addq.l #1,d5
02:00002A9C 40C6            	  4379:                 move.w SR,d6
02:00002A9E 02860000001F    	  4380:                 andi.l #$1F,d6        * Isolate flags
02:00002AA4 D286            	  4381:                 add.l d6,d1           * Copy flag results into accumulator
02:00002AA6 D485            	  4382:                 add.l d5,d2           * Copy data results into data accumulator
02:00002AA8 51C8FFF0        	  4383:                 dbf d0,ADDQ_LOOP3
                            	  4384: 
02:00002AAC 0C810000008D    	  4385:                 cmpi.l #$0000008D,d1
02:00002AB2 66FE            	  4386:                 bne.s *
02:00002AB4 0C8200007080    	  4387:                 cmpi.l #$00007080,d2
02:00002ABA 66FE            	  4388:                 bne.s *
                            	  4389: 
                            	  4390: *     Check that Flags are not updated for Address registers
02:00002ABC 207C0000FFFF    	  4391:                 move.l #$0000FFFF,a0
02:00002AC2 44FC0000        	  4392:                 move #$00,CCR         * Clear flags
02:00002AC6 5E48            	  4393:                 addq.w #$7,a0
02:00002AC8 65FE            	  4394:                 bcs.s *
                            	  4395: 
02:00002ACA 4E75            	  4396:                 rts
                            	  4397: 
                            	  4398: 
                            	  4399: 
                            	  4400: *-----------------------------------------------------------
                            	  4401: *-----------------------------------------------------------
                            	  4402: * OPCODE : SUBQ
                            	  4403: *-----------------------------------------------------------
                            	  4404: *-----------------------------------------------------------
                            	  4405: 
                            	  4406: op_SUBQ:
                            	  4407: 
                            	  4408: *     BYTE
02:00002ACC 203C000000FF    	  4409:                 move.l #$000000FF,d0    * Loop counter
02:00002AD2 7200            	  4410:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002AD4 243C00001234    	  4411:                 move.l #$00001234,d2    * Data results accumulator
02:00002ADA 7600            	  4412:                 moveq  #$00000000,d3
02:00002ADC 7800            	  4413:                 moveq  #$00000000,d4
02:00002ADE 7A12            	  4414:                 moveq  #$00000012,d5
02:00002AE0 7C00            	  4415:                 moveq  #$00000000,d6
02:00002AE2 7E00            	  4416:                 moveq  #$00000000,d7
                            	  4417: 
02:00002AE4 5305            	  4418: SUBQ_LOOP1:     subq.b #1,d5
02:00002AE6 40C6            	  4419:                 move.w SR,d6
02:00002AE8 02860000001F    	  4420:                 andi.l #$1F,d6        * Isolate flags
02:00002AEE D286            	  4421:                 add.l d6,d1           * Copy flag results into accumulator
02:00002AF0 D485            	  4422:                 add.l d5,d2           * Copy data results into data accumulator
02:00002AF2 51C8FFF0        	  4423:                 dbf d0,SUBQ_LOOP1
                            	  4424: 
02:00002AF6 0C8100000417    	  4425:                 cmpi.l #$00000417,d1
02:00002AFC 66FE            	  4426:                 bne.s *
02:00002AFE 0C82000091B4    	  4427:                 cmpi.l #$000091B4,d2
02:00002B04 66FE            	  4428:                 bne.s *
                            	  4429: 
                            	  4430: 
                            	  4431: *     WORD
02:00002B06 203C000000FF    	  4432:                 move.l #$000000FF,d0    * Loop counter
02:00002B0C 7200            	  4433:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002B0E 7400            	  4434:                 moveq  #$00000000,d2    * Data results accumulator
02:00002B10 7600            	  4435:                 moveq  #$00000000,d3
02:00002B12 7800            	  4436:                 moveq  #$00000000,d4
02:00002B14 7A02            	  4437:                 moveq  #$00000002,d5
02:00002B16 7C00            	  4438:                 moveq  #$00000000,d6
02:00002B18 7E00            	  4439:                 moveq  #$00000000,d7
02:00002B1A 307C0100        	  4440:                 move.l #$00000100,a0
                            	  4441: 
02:00002B1E 5B45            	  4442: SUBQ_LOOP2:     subq.w #5,d5
02:00002B20 40C6            	  4443:                 move.w SR,d6
02:00002B22 02860000001F    	  4444:                 andi.l #$1F,d6        * Isolate flags
02:00002B28 D286            	  4445:                 add.l d6,d1           * Copy flag results into accumulator
02:00002B2A D485            	  4446:                 add.l d5,d2           * Copy data results into data accumulator
02:00002B2C 51C8FFF0        	  4447:                 dbf d0,SUBQ_LOOP2
                            	  4448: 
02:00002B30 0C8100000811    	  4449:                 cmpi.l #$00000811,d1
02:00002B36 66FE            	  4450:                 bne.s *
02:00002B38 0C8200FD7F80    	  4451:                 cmpi.l #$00FD7F80,d2
02:00002B3E 66FE            	  4452:                 bne.s *
                            	  4453: 
                            	  4454: 
                            	  4455: *     LONG
02:00002B40 203C000000FF    	  4456:                 move.l #$000000FF,d0    * Loop counter
02:00002B46 7200            	  4457:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002B48 7400            	  4458:                 moveq  #$00000000,d2    * Data results accumulator
02:00002B4A 7600            	  4459:                 moveq  #$00000000,d3
02:00002B4C 7800            	  4460:                 moveq  #$00000000,d4
02:00002B4E 7A07            	  4461:                 moveq  #$00000007,d5
02:00002B50 7C00            	  4462:                 moveq  #$00000000,d6
02:00002B52 7E00            	  4463:                 moveq  #$00000000,d7
                            	  4464: 
02:00002B54 5385            	  4465: SUBQ_LOOP3:     subq.l #1,d5
02:00002B56 40C6            	  4466:                 move.w SR,d6
02:00002B58 02860000001F    	  4467:                 andi.l #$1F,d6        * Isolate flags
02:00002B5E D286            	  4468:                 add.l d6,d1           * Copy flag results into accumulator
02:00002B60 D485            	  4469:                 add.l d5,d2           * Copy data results into data accumulator
02:00002B62 51C8FFF0        	  4470:                 dbf d0,SUBQ_LOOP3
                            	  4471: 
02:00002B66 0C81000007DD    	  4472:                 cmpi.l #$000007DD,d1
02:00002B6C 66FE            	  4473:                 bne.s *
02:00002B6E 0C82FFFF8680    	  4474:                 cmpi.l #$FFFF8680,d2
02:00002B74 66FE            	  4475:                 bne.s *
                            	  4476: 
                            	  4477: *     Check that Flags are not updated for Address registers
02:00002B76 207C0001FFFF    	  4478:                 move.l #$0001FFFF,a0
02:00002B7C 44FC0000        	  4479:                 move #$00,CCR         * Clear flags
02:00002B80 5F48            	  4480:                 subq.w #$7,a0
02:00002B82 65FE            	  4481:                 bcs.s *
                            	  4482: 
02:00002B84 4E75            	  4483:                 rts
                            	  4484: 
                            	  4485: 
                            	  4486: 
                            	  4487: 
                            	  4488: *-----------------------------------------------------------
                            	  4489: *-----------------------------------------------------------
                            	  4490: * OPCODE : MOVEQ
                            	  4491: *-----------------------------------------------------------
                            	  4492: *-----------------------------------------------------------
                            	  4493: 
                            	  4494: op_MOVEQ:
02:00002B86 7000            	  4495:                 moveq  #$00000000,d0
02:00002B88 7000            	  4496:                 moveq #$0,d0
02:00002B8A 66FE            	  4497:                 bne.s *
02:00002B8C 4A80            	  4498:                 cmpi.l #$00000000,d0
02:00002B8E 66FE            	  4499:                 bne.s *
                            	  4500: 
02:00002B90 7000            	  4501:                 moveq  #$00000000,d0
02:00002B92 7080            	  4502:                 moveq #-128,d0
02:00002B94 67FE            	  4503:                 beq.s *
02:00002B96 6AFE            	  4504:                 bpl.s *
02:00002B98 0C80FFFFFF80    	  4505:                 cmpi.l #$FFFFFF80,d0
02:00002B9E 66FE            	  4506:                 bne.s *
                            	  4507: 
                            	  4508: 
02:00002BA0 4E75            	  4509:                 rts
                            	  4510: 
                            	  4511: 
                            	  4512: *-----------------------------------------------------------
                            	  4513: *-----------------------------------------------------------
                            	  4514: * OPCODE : DIVU
                            	  4515: *-----------------------------------------------------------
                            	  4516: *-----------------------------------------------------------
                            	  4517: 
                            	  4518: op_DIVU:
                            	  4519: 
02:00002BA2 203CA5A5A5A5    	  4520:                 move.l #$a5a5a5a5,d0        * Initial Numerator
02:00002BA8 223C00005A5A    	  4521:                 move.l #$00005a5a,d1        * Initial Divisor
02:00002BAE 243CA5A5A5A5    	  4522:                 move.l #$a5a5a5a5,d2
02:00002BB4 7600            	  4523:                 moveq  #$00000000,d3
02:00002BB6 7800            	  4524:                 moveq  #$00000000,d4        * Cumulative data results
02:00002BB8 7A00            	  4525:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002BBA 7C0E            	  4526:                 move.l #$0000000E,d6       * Inner loop counter
02:00002BBC 7E1E            	  4527:                 move.l #$0000001E,d7       * Outer loop counter
                            	  4528: 
                            	  4529: 
02:00002BBE 80C1            	  4530: DIVU_OUTER1:    divu d1,d0               * !! Easy68K C not always cleared
02:00002BC0 40C3            	  4531:                 move.w SR,d3
02:00002BC2 02830000000C    	  4532:                 andi.l #$0C,d3            * Isolate flags
02:00002BC8 DA83            	  4533:                 add.l d3,d5               * Copy flag results into accumulator
02:00002BCA D880            	  4534:                 add.l d0,d4               * Copy data results into data accumulator
02:00002BCC E289            	  4535:                 lsr.l #$1,d1
                            	  4536: 
02:00002BCE 51CEFFEE        	  4537:                 dbf d6,DIVU_OUTER1
02:00002BD2 E28A            	  4538:                 lsr.l #$1,d2
02:00002BD4 2002            	  4539:                 move.l d2,d0
02:00002BD6 223C00005A5A    	  4540:                 move.l #$00005a5a,d1       * Initial Divisor
02:00002BDC 7C0E            	  4541:                 move.l #$0000000E,d6       * Inner loop counter
02:00002BDE 51CFFFDE        	  4542:                 dbf d7,DIVU_OUTER1
                            	  4543: 
02:00002BE2 0C8492FEDB89    	  4544:                 cmpi.l #$92FEDB89,d4      * Check the data results
02:00002BE8 66FE            	  4545:                 bne.s *
                            	  4546: 
02:00002BEA 0C8500000110    	  4547:                 cmpi.l #$00000110,d5      * Check the Flag results
02:00002BF0 66FE            	  4548:                 bne.s *
                            	  4549: 
                            	  4550: 
02:00002BF2 4E75            	  4551:                 rts
                            	  4552: 
                            	  4553: 
                            	  4554: 
                            	  4555: *-----------------------------------------------------------
                            	  4556: *-----------------------------------------------------------
                            	  4557: * OPCODE : DIVS
                            	  4558: *-----------------------------------------------------------
                            	  4559: *-----------------------------------------------------------
                            	  4560: 
                            	  4561: op_DIVS:
                            	  4562: 
02:00002BF4 203CA5A5A5A5    	  4563:                 move.l #$a5a5a5a5,d0        * Initial Numerator
02:00002BFA 223C00005A5A    	  4564:                 move.l #$00005a5a,d1        * Initial Divisor
02:00002C00 243CA5A5A5A5    	  4565:                 move.l #$a5a5a5a5,d2
02:00002C06 7600            	  4566:                 moveq  #$00000000,d3
02:00002C08 7800            	  4567:                 moveq  #$00000000,d4        * Cumulative data results
02:00002C0A 7A00            	  4568:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002C0C 7C0E            	  4569:                 move.l #$0000000E,d6       * Inner loop counter
02:00002C0E 7E1E            	  4570:                 move.l #$0000001E,d7       * Outer loop counter
                            	  4571: 
                            	  4572: 
02:00002C10 81C1            	  4573: DIVS_OUTER1:    divs d1,d0               * !! Easy68K C not always cleared
02:00002C12 40C3            	  4574:                 move.w SR,d3
02:00002C14 02830000000C    	  4575:                 andi.l #$0C,d3            * Isolate flags
02:00002C1A DA83            	  4576:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C1C D880            	  4577:                 add.l d0,d4               * Copy data results into data accumulator
02:00002C1E E289            	  4578:                 lsr.l #$1,d1
                            	  4579: 
02:00002C20 51CEFFEE        	  4580:                 dbf d6,DIVS_OUTER1
02:00002C24 E28A            	  4581:                 lsr.l #$1,d2
02:00002C26 2002            	  4582:                 move.l d2,d0
02:00002C28 223C00005A5A    	  4583:                 move.l #$00005a5a,d1       * Initial Divisor
02:00002C2E 7C0E            	  4584:                 move.l #$0000000E,d6       * Inner loop counter
02:00002C30 51CFFFDE        	  4585:                 dbf d7,DIVS_OUTER1
                            	  4586: 
02:00002C34 0C844EC5D057    	  4587:                 cmpi.l #$4EC5D057,d4      * Check the data results
02:00002C3A 66FE            	  4588:                 bne.s *
                            	  4589: 
02:00002C3C 0C8500000038    	  4590:                 cmpi.l #$00000038,d5      * Check the Flag results
02:00002C42 66FE            	  4591:                 bne.s *
                            	  4592: 
                            	  4593: 
02:00002C44 4E75            	  4594:                 rts
                            	  4595: 
                            	  4596: 
                            	  4597: 
                            	  4598: *-----------------------------------------------------------
                            	  4599: *-----------------------------------------------------------
                            	  4600: * OPCODE : OR
                            	  4601: *-----------------------------------------------------------
                            	  4602: *-----------------------------------------------------------
                            	  4603: 
                            	  4604: op_OR:
                            	  4605: 
                            	  4606: *  * <EA> to Register
                            	  4607: 
02:00002C46 203CA5A5A5A5    	  4608:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002C4C 223C8167E123    	  4609:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002C52 243CA5A5A5A5    	  4610:                 move.l #$a5a5a5a5,d2
02:00002C58 7600            	  4611:                 moveq  #$00000000,d3
02:00002C5A 7800            	  4612:                 moveq  #$00000000,d4       * Cumulative data results
02:00002C5C 7A00            	  4613:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002C5E 7C1E            	  4614:                 move.l #$0000001E,d6       * Inner loop counter
02:00002C60 7E1E            	  4615:                 move.l #$0000001E,d7       * Outer loop counter
02:00002C62 307C0100        	  4616:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4617: 
                            	  4618: 
                            	  4619: OR_OUTER1:
                            	  4620: 
                            	  4621: *     BYTE
02:00002C66 2081            	  4622:                 move.l d1,(a0)
02:00002C68 8010            	  4623:                 or.b (a0),d0
02:00002C6A 40C3            	  4624:                 move.w SR,d3
02:00002C6C 02830000000C    	  4625:                 andi.l #$0C,d3            * Isolate flags
02:00002C72 DA83            	  4626:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C74 D880            	  4627:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4628: 
                            	  4629: *     WORD
02:00002C76 2081            	  4630:                 move.l d1,(a0)
02:00002C78 8050            	  4631:                 or.w (a0),d0
02:00002C7A 40C3            	  4632:                 move.w SR,d3
02:00002C7C 02830000000C    	  4633:                 andi.l #$0C,d3            * Isolate flags
02:00002C82 DA83            	  4634:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C84 D880            	  4635:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4636: 
                            	  4637: *     LONG
02:00002C86 2081            	  4638:                 move.l d1,(a0)
02:00002C88 8090            	  4639:                 or.l (a0),d0
02:00002C8A 40C3            	  4640:                 move.w SR,d3
02:00002C8C 02830000000F    	  4641:                 andi.l #$0F,d3            * Isolate flags
02:00002C92 DA83            	  4642:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C94 D880            	  4643:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4644: 
                            	  4645: 
02:00002C96 E289            	  4646:                 lsr.l #$1,d1
02:00002C98 51CEFFCC        	  4647:                 dbf d6,OR_OUTER1
02:00002C9C E28A            	  4648:                 lsr.l #$1,d2
02:00002C9E 223C8167E123    	  4649:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002CA4 7C1E            	  4650:                 move.l #$0000001E,d6       * Inner loop counter
02:00002CA6 51CFFFBE        	  4651:                 dbf d7,OR_OUTER1
                            	  4652: 
02:00002CAA 0C8476EAC803    	  4653:                 cmpi.l #$76EAC803,d4      * Check the data results
02:00002CB0 66FE            	  4654:                 bne.s *
02:00002CB2 0C8500005A18    	  4655:                 cmpi.l #$00005A18,d5      * Check the Flag results
02:00002CB8 66FE            	  4656:                 bne.s *
                            	  4657: 
                            	  4658: 
                            	  4659: *  * Register to <EA>
                            	  4660: 
02:00002CBA 203C86738374    	  4661:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00002CC0 223CFC55F2FE    	  4662:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00002CC6 243C86738374    	  4663:                 move.l #$86738374,d2
02:00002CCC 7600            	  4664:                 moveq  #$00000000,d3
02:00002CCE 7800            	  4665:                 moveq  #$00000000,d4       * Cumulative data results
02:00002CD0 7A00            	  4666:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002CD2 7C1E            	  4667:                 move.l #$0000001E,d6       * Inner loop counter
02:00002CD4 7E1D            	  4668:                 move.l #$0000001D,d7       * Outer loop counter
02:00002CD6 307C0100        	  4669:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4670: 
                            	  4671: 
                            	  4672: OR_OUTER2:
                            	  4673: 
                            	  4674: *     BYTE
02:00002CDA 2080            	  4675:                 move.l d0,(a0)
02:00002CDC 8310            	  4676:                 or.b d1,(a0)
02:00002CDE 40C3            	  4677:                 move.w SR,d3
02:00002CE0 02830000000C    	  4678:                 andi.l #$0C,d3            * Isolate flags
02:00002CE6 DA83            	  4679:                 add.l d3,d5               * Copy flag results into accumulator
02:00002CE8 D890            	  4680:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4681: 
                            	  4682: *     WORD
02:00002CEA 2080            	  4683:                 move.l d0,(a0)
02:00002CEC 8350            	  4684:                 or.w d1,(a0)
02:00002CEE 40C3            	  4685:                 move.w SR,d3
02:00002CF0 02830000000C    	  4686:                 andi.l #$0C,d3            * Isolate flags
02:00002CF6 DA83            	  4687:                 add.l d3,d5               * Copy flag results into accumulator
02:00002CF8 D890            	  4688:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4689: 
                            	  4690: *     LONG
02:00002CFA 2080            	  4691:                 move.l d0,(a0)
02:00002CFC 8390            	  4692:                 or.l d1,(a0)
02:00002CFE 40C3            	  4693:                 move.w SR,d3
02:00002D00 02830000000F    	  4694:                 andi.l #$0F,d3            * Isolate flags
02:00002D06 DA83            	  4695:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D08 D890            	  4696:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4697: 
                            	  4698: 
02:00002D0A E289            	  4699:                 lsr.l #$1,d1
02:00002D0C 51CEFFCC        	  4700:                 dbf d6,OR_OUTER2
02:00002D10 E28A            	  4701:                 lsr.l #$1,d2
02:00002D12 223C8167E123    	  4702:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002D18 7C1E            	  4703:                 move.l #$0000001E,d6       * Inner loop counter
02:00002D1A 51CFFFBE        	  4704:                 dbf d7,OR_OUTER2
                            	  4705: 
02:00002D1E 0C84FA82B9E4    	  4706:                 cmpi.l #$FA82B9E4,d4      * Check the data results
02:00002D24 66FE            	  4707:                 bne.s *
02:00002D26 0C8500005730    	  4708:                 cmpi.l #$00005730,d5      * Check the Flag results
02:00002D2C 66FE            	  4709:                 bne.s *
                            	  4710: 
                            	  4711: 
02:00002D2E 4E75            	  4712:                 rts
                            	  4713: 
                            	  4714: 
                            	  4715: 
                            	  4716: *-----------------------------------------------------------
                            	  4717: *-----------------------------------------------------------
                            	  4718: * OPCODE : AND
                            	  4719: *-----------------------------------------------------------
                            	  4720: *-----------------------------------------------------------
                            	  4721: 
                            	  4722: op_AND:
                            	  4723: 
                            	  4724: *  * <EA> to Register
                            	  4725: 
02:00002D30 203CA5A5A5A5    	  4726:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002D36 223C8167E123    	  4727:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002D3C 243CA5A5A5A5    	  4728:                 move.l #$a5a5a5a5,d2
02:00002D42 7600            	  4729:                 moveq  #$00000000,d3
02:00002D44 7800            	  4730:                 moveq  #$00000000,d4       * Cumulative data results
02:00002D46 7A00            	  4731:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002D48 7C1E            	  4732:                 move.l #$0000001E,d6       * Inner loop counter
02:00002D4A 7E1E            	  4733:                 move.l #$0000001E,d7       * Outer loop counter
02:00002D4C 307C0100        	  4734:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4735: 
                            	  4736: 
                            	  4737: AND_OUTER1:
                            	  4738: 
                            	  4739: *     BYTE
02:00002D50 2081            	  4740:                 move.l d1,(a0)
02:00002D52 C010            	  4741:                 and.b (a0),d0
02:00002D54 40C3            	  4742:                 move.w sr,d3
02:00002D56 02830000000C    	  4743:                 andi.l #$0C,d3            * Isolate flags
02:00002D5C DA83            	  4744:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D5E D880            	  4745:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4746: 
                            	  4747: *     WORD
02:00002D60 2081            	  4748:                 move.l d1,(a0)
02:00002D62 C050            	  4749:                 and.w (a0),d0
02:00002D64 40C3            	  4750:                 move.w sr,d3
02:00002D66 02830000000C    	  4751:                 andi.l #$0C,d3            * Isolate flags
02:00002D6C DA83            	  4752:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D6E D880            	  4753:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4754: 
                            	  4755: *     LONG
02:00002D70 2081            	  4756:                 move.l d1,(a0)
02:00002D72 C090            	  4757:                 and.l (a0),d0
02:00002D74 40C3            	  4758:                 move.w sr,d3
02:00002D76 02830000000F    	  4759:                 andi.l #$0F,d3            * Isolate flags
02:00002D7C DA83            	  4760:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D7E D880            	  4761:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4762: 
                            	  4763: 
02:00002D80 E289            	  4764:                 lsr.l #$1,d1
02:00002D82 51CEFFCC        	  4765:                 dbf d6,AND_OUTER1
02:00002D86 E28A            	  4766:                 lsr.l #$1,d2
02:00002D88 223C8167E123    	  4767:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002D8E 7C1E            	  4768:                 move.l #$0000001E,d6       * Inner loop counter
02:00002D90 51CFFFBE        	  4769:                 dbf d7,AND_OUTER1
                            	  4770: 
02:00002D94 0C84CF212883    	  4771:                 cmpi.l #$CF212883,d4      * Check the data results
02:00002D9A 66FE            	  4772:                 bne.s *
02:00002D9C 0C8500002D10    	  4773:                 cmpi.l #$00002D10,d5      * Check the Flag results
02:00002DA2 66FE            	  4774:                 bne.s *
                            	  4775: 
                            	  4776: 
                            	  4777: *  * Register to <EA>
                            	  4778: 
02:00002DA4 203C86738374    	  4779:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00002DAA 223CFC55F2FE    	  4780:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00002DB0 243C86738374    	  4781:                 move.l #$86738374,d2
02:00002DB6 7600            	  4782:                 moveq  #$00000000,d3
02:00002DB8 7800            	  4783:                 moveq  #$00000000,d4       * Cumulative data results
02:00002DBA 7A00            	  4784:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002DBC 7C1E            	  4785:                 move.l #$0000001E,d6       * Inner loop counter
02:00002DBE 7E1D            	  4786:                 move.l #$0000001D,d7       * Outer loop counter
02:00002DC0 307C0100        	  4787:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4788: 
                            	  4789: 
                            	  4790: AND_OUTER2:
                            	  4791: 
                            	  4792: *     BYTE
02:00002DC4 2080            	  4793:                 move.l d0,(a0)
02:00002DC6 C310            	  4794:                 and.b d1,(a0)
02:00002DC8 40C3            	  4795:                 move.w sr,d3
02:00002DCA 02830000000C    	  4796:                 andi.l #$0C,d3            * Isolate flags
02:00002DD0 DA83            	  4797:                 add.l d3,d5               * Copy flag results into accumulator
02:00002DD2 D890            	  4798:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4799: 
                            	  4800: *     WORD
02:00002DD4 2080            	  4801:                 move.l d0,(a0)
02:00002DD6 C350            	  4802:                 and.w d1,(a0)
02:00002DD8 40C3            	  4803:                 move.w sr,d3
02:00002DDA 02830000000C    	  4804:                 andi.l #$0C,d3            * Isolate flags
02:00002DE0 DA83            	  4805:                 add.l d3,d5               * Copy flag results into accumulator
02:00002DE2 D890            	  4806:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4807: 
                            	  4808: *     LONG
02:00002DE4 2080            	  4809:                 move.l d0,(a0)
02:00002DE6 C390            	  4810:                 and.l d1,(a0)
02:00002DE8 40C3            	  4811:                 move.w sr,d3
02:00002DEA 02830000000F    	  4812:                 andi.l #$0F,d3            * Isolate flags
02:00002DF0 DA83            	  4813:                 add.l d3,d5               * Copy flag results into accumulator
02:00002DF2 D890            	  4814:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4815: 
                            	  4816: 
02:00002DF4 E289            	  4817:                 lsr.l #$1,d1
02:00002DF6 51CEFFCC        	  4818:                 dbf d6,AND_OUTER2
02:00002DFA E28A            	  4819:                 lsr.l #$1,d2
02:00002DFC 223C8167E123    	  4820:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002E02 7C1E            	  4821:                 move.l #$0000001E,d6       * Inner loop counter
02:00002E04 51CFFFBE        	  4822:                 dbf d7,AND_OUTER2
                            	  4823: 
02:00002E08 0C844A3DE544    	  4824:                 cmpi.l #$4A3DE544,d4      * Check the data results
02:00002E0E 66FE            	  4825:                 bne.s *
02:00002E10 0C85000018E8    	  4826:                 cmpi.l #$000018E8,d5      * Check the Flag results
02:00002E16 66FE            	  4827:                 bne.s *
                            	  4828: 
                            	  4829: 
02:00002E18 4E75            	  4830:                 rts
                            	  4831: 
                            	  4832: 
                            	  4833: 
                            	  4834: *-----------------------------------------------------------
                            	  4835: *-----------------------------------------------------------
                            	  4836: * OPCODE : EOR
                            	  4837: *-----------------------------------------------------------
                            	  4838: *-----------------------------------------------------------
                            	  4839: 
                            	  4840: op_EOR:
                            	  4841: 
                            	  4842: *  * Register to <EA>
                            	  4843: 
02:00002E1A 203C86738374    	  4844:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00002E20 223CFC55F2FE    	  4845:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00002E26 243C86738374    	  4846:                 move.l #$86738374,d2
02:00002E2C 7600            	  4847:                 moveq  #$00000000,d3
02:00002E2E 7800            	  4848:                 moveq  #$00000000,d4       * Cumulative data results
02:00002E30 7A00            	  4849:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002E32 7C1E            	  4850:                 move.l #$0000001E,d6       * Inner loop counter
02:00002E34 7E1D            	  4851:                 move.l #$0000001D,d7       * Outer loop counter
02:00002E36 307C0100        	  4852:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4853: 
                            	  4854: 
                            	  4855: EOR_OUTER2:
                            	  4856: 
                            	  4857: *     BYTE
02:00002E3A 2080            	  4858:                 move.l d0,(a0)
02:00002E3C B310            	  4859:                 eor.b d1,(a0)
02:00002E3E 40C3            	  4860:                 move.w sr,d3
02:00002E40 02830000000C    	  4861:                 andi.l #$0C,d3            * Isolate flags
02:00002E46 DA83            	  4862:                 add.l d3,d5               * Copy flag results into accumulator
02:00002E48 D890            	  4863:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4864: 
                            	  4865: *     WORD
02:00002E4A 2080            	  4866:                 move.l d0,(a0)
02:00002E4C B350            	  4867:                 eor.w d1,(a0)
02:00002E4E 40C3            	  4868:                 move.w sr,d3
02:00002E50 02830000000C    	  4869:                 andi.l #$0C,d3            * Isolate flags
02:00002E56 DA83            	  4870:                 add.l d3,d5               * Copy flag results into accumulator
02:00002E58 D890            	  4871:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4872: 
                            	  4873: *     LONG
02:00002E5A 2080            	  4874:                 move.l d0,(a0)
02:00002E5C B390            	  4875:                 eor.l d1,(a0)
02:00002E5E 40C3            	  4876:                 move.w sr,d3
02:00002E60 02830000000F    	  4877:                 andi.l #$0F,d3            * Isolate flags
02:00002E66 DA83            	  4878:                 add.l d3,d5               * Copy flag results into accumulator
02:00002E68 D890            	  4879:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4880: 
                            	  4881: 
02:00002E6A E289            	  4882:                 lsr.l #$1,d1
02:00002E6C 51CEFFCC        	  4883:                 dbf d6,EOR_OUTER2
02:00002E70 E28A            	  4884:                 lsr.l #$1,d2
02:00002E72 223C8167E123    	  4885:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002E78 7C1E            	  4886:                 move.l #$0000001E,d6       * Inner loop counter
02:00002E7A 51CFFFBE        	  4887:                 dbf d7,EOR_OUTER2
                            	  4888: 
02:00002E7E 0C8455C5EB70    	  4889:                 cmpi.l #$55C5EB70,d4      * Check the data results
02:00002E84 66FE            	  4890:                 bne.s *
02:00002E86 0C8500004430    	  4891:                 cmpi.l #$00004430,d5      * Check the Flag results
02:00002E8C 66FE            	  4892:                 bne.s *
                            	  4893: 
                            	  4894: 
02:00002E8E 4E75            	  4895:                 rts
                            	  4896: 
                            	  4897: 
                            	  4898: *-----------------------------------------------------------
                            	  4899: *-----------------------------------------------------------
                            	  4900: * OPCODE : CMP
                            	  4901: *-----------------------------------------------------------
                            	  4902: *-----------------------------------------------------------
                            	  4903: 
                            	  4904: op_CMP:
                            	  4905: 
                            	  4906: 
                            	  4907: *  * <EA> to Register
                            	  4908: 
02:00002E90 203CA5A5A5A5    	  4909:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002E96 223C8167E123    	  4910:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002E9C 243CA5A5A5A5    	  4911:                 move.l #$a5a5a5a5,d2
02:00002EA2 7600            	  4912:                 moveq  #$00000000,d3
02:00002EA4 7800            	  4913:                 moveq  #$00000000,d4       * Cumulative data results
02:00002EA6 7A00            	  4914:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002EA8 7C1E            	  4915:                 move.l #$0000001E,d6       * Inner loop counter
02:00002EAA 7E1E            	  4916:                 move.l #$0000001E,d7       * Outer loop counter
02:00002EAC 307C0100        	  4917:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4918: 
                            	  4919: 
                            	  4920: CMP_OUTER1:
                            	  4921: 
                            	  4922: *     BYTE
02:00002EB0 2081            	  4923:                 move.l d1,(a0)
02:00002EB2 B010            	  4924:                 cmp.b (a0),d0
02:00002EB4 40C3            	  4925:                 move.w sr,d3
02:00002EB6 02830000000F    	  4926:                 andi.l #$0F,d3            * Isolate flags
02:00002EBC DA83            	  4927:                 add.l d3,d5               * Copy flag results into accumulator
02:00002EBE D880            	  4928:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4929: 
                            	  4930: *     WORD
02:00002EC0 2081            	  4931:                 move.l d1,(a0)
02:00002EC2 B050            	  4932:                 cmp.w (a0),d0
02:00002EC4 40C3            	  4933:                 move.w sr,d3
02:00002EC6 02830000000F    	  4934:                 andi.l #$0F,d3            * Isolate flags
02:00002ECC DA83            	  4935:                 add.l d3,d5               * Copy flag results into accumulator
02:00002ECE D880            	  4936:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4937: 
                            	  4938: *     LONG
02:00002ED0 2081            	  4939:                 move.l d1,(a0)
02:00002ED2 B090            	  4940:                 cmp.l (a0),d0
02:00002ED4 40C3            	  4941:                 move.w sr,d3
02:00002ED6 02830000000F    	  4942:                 andi.l #$0F,d3            * Isolate flags
02:00002EDC DA83            	  4943:                 add.l d3,d5               * Copy flag results into accumulator
02:00002EDE D880            	  4944:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4945: 
                            	  4946: 
02:00002EE0 E289            	  4947:                 lsr.l #$1,d1
02:00002EE2 51CEFFCC        	  4948:                 dbf d6,CMP_OUTER1
02:00002EE6 E28A            	  4949:                 lsr.l #$1,d2
02:00002EE8 223C8167E123    	  4950:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002EEE 7C1E            	  4951:                 move.l #$0000001E,d6       * Inner loop counter
02:00002EF0 51CFFFBE        	  4952:                 dbf d7,CMP_OUTER1
                            	  4953: 
02:00002EF4 0C847878712F    	  4954:                 cmpi.l #$7878712F,d4      * Check the data results
02:00002EFA 66FE            	  4955:                 bne.s *
02:00002EFC 0C8500005502    	  4956:                 cmpi.l #$00005502,d5      * Check the Flag results
02:00002F02 66FE            	  4957:                 bne.s *
                            	  4958: 
                            	  4959: 
                            	  4960: 
02:00002F04 4E75            	  4961:                 rts
                            	  4962: 
                            	  4963: 
                            	  4964: *-----------------------------------------------------------
                            	  4965: *-----------------------------------------------------------
                            	  4966: * OPCODE : CMPA
                            	  4967: *-----------------------------------------------------------
                            	  4968: *-----------------------------------------------------------
                            	  4969: 
                            	  4970: op_CMPA:
                            	  4971: 
                            	  4972: 
                            	  4973: *  * <EA> to Register
                            	  4974: 
02:00002F06 207CA5A5A5A5    	  4975:                 move.l #$a5a5a5a5,a0       * Initial Data-X  Inner loop
02:00002F0C 223C8167E123    	  4976:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002F12 243CA5A5A5A5    	  4977:                 move.l #$a5a5a5a5,d2
02:00002F18 7600            	  4978:                 moveq  #$00000000,d3
02:00002F1A 7800            	  4979:                 moveq  #$00000000,d4       * Cumulative data results
02:00002F1C 7A00            	  4980:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002F1E 7C1E            	  4981:                 move.l #$0000001E,d6       * Inner loop counter
02:00002F20 7E1E            	  4982:                 move.l #$0000001E,d7       * Outer loop counter
02:00002F22 327C0100        	  4983:                 move.l #$00000100,a1       * Address for memory EA operations
                            	  4984: 
                            	  4985: 
                            	  4986: CMPA_OUTER1:
                            	  4987: 
                            	  4988: 
                            	  4989: *     WORD
02:00002F26 2281            	  4990:                 move.l d1,(a1)
02:00002F28 B0D1            	  4991:                 cmpa.w (a1),a0
02:00002F2A 40C3            	  4992:                 move.w sr,d3
02:00002F2C 02830000000F    	  4993:                 andi.l #$0F,d3            * Isolate flags
02:00002F32 DA83            	  4994:                 add.l d3,d5               * Copy flag results into accumulator
02:00002F34 D888            	  4995:                 add.l a0,d4               * Copy data results into data accumulator
                            	  4996: 
                            	  4997: *     LONG
02:00002F36 2281            	  4998:                 move.l d1,(a1)
02:00002F38 B1D1            	  4999:                 cmpa.l (a1),a0
02:00002F3A 40C3            	  5000:                 move.w sr,d3
02:00002F3C 02830000000F    	  5001:                 andi.l #$0F,d3            * Isolate flags
02:00002F42 DA83            	  5002:                 add.l d3,d5               * Copy flag results into accumulator
02:00002F44 D888            	  5003:                 add.l a0,d4               * Copy data results into data accumulator
                            	  5004: 
                            	  5005: 
02:00002F46 E289            	  5006:                 lsr.l #$1,d1
02:00002F48 51CEFFDC        	  5007:                 dbf d6,CMPA_OUTER1
02:00002F4C E28A            	  5008:                 lsr.l #$1,d2
02:00002F4E 223C8167E123    	  5009:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002F54 7C1E            	  5010:                 move.l #$0000001E,d6       * Inner loop counter
02:00002F56 51CFFFCE        	  5011:                 dbf d7,CMPA_OUTER1
                            	  5012: 
02:00002F5A 0C84A5A5A0CA    	  5013:                 cmpi.l #$a5a5a0ca,d4      * Check the data results
02:00002F60 66FE            	  5014:                 bne.s *
02:00002F62 0C8500003A7D    	  5015:                 cmpi.l #$00003A7D,d5      * Check the Flag results
02:00002F68 66FE            	  5016:                 bne.s *
                            	  5017: 
                            	  5018: 
02:00002F6A 4E75            	  5019:                 rts
                            	  5020: 
                            	  5021: 
                            	  5022: 
                            	  5023: *-----------------------------------------------------------
                            	  5024: *-----------------------------------------------------------
                            	  5025: * OPCODE : CMPM
                            	  5026: *-----------------------------------------------------------
                            	  5027: *-----------------------------------------------------------
                            	  5028: 
                            	  5029: op_CMPM:
                            	  5030: 
02:00002F6C 307C0100        	  5031:                 move.l #$00000100,a0       * Address for Data-X
02:00002F70 327C0200        	  5032:                 move.l #$00000200,a1       * Address for Data-Y
02:00002F74 7000            	  5033:                 moveq  #$00000000,d0
02:00002F76 7200            	  5034:                 moveq  #$00000000,d1
02:00002F78 7400            	  5035:                 moveq  #$00000000,d2
                            	  5036: 
02:00002F7A 20FC11FF5580    	  5037:                 move.l #$11FF5580,(a0)+   * Populate test data
02:00002F80 20FC1111FFFF    	  5038:                 move.l #$1111FFFF,(a0)+   * Populate test data
02:00002F86 20FC33333333    	  5039:                 move.l #$33333333,(a0)+   * Populate test data
02:00002F8C 20FC44444444    	  5040:                 move.l #$44444444,(a0)+   * Populate test data
                            	  5041: 
02:00002F92 22FC80FF337F    	  5042:                 move.l #$80FF337F,(a1)+   * Populate test data
02:00002F98 22FCFFFF1111    	  5043:                 move.l #$FFFF1111,(a1)+   * Populate test data
02:00002F9E 22FC33333333    	  5044:                 move.l #$33333333,(a1)+   * Populate test data
02:00002FA4 22FC44444444    	  5045:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5046: 
02:00002FAA 307C0100        	  5047:                 move.l #$00000100,a0       * Address for Data-X
02:00002FAE 327C0200        	  5048:                 move.l #$00000200,a1       * Address for Data-Y
02:00002FB2 7C0F            	  5049:                 move.l #$0000000F,d6       * Loop counter
                            	  5050: 
02:00002FB4 B308            	  5051: CMPM_LOOP1:     cmpm.b (a0)+,(a1)+
02:00002FB6 40C3            	  5052:                 move.w sr,d3
02:00002FB8 02830000000F    	  5053:                 andi.l #$0F,d3            * Isolate flags
02:00002FBE D083            	  5054:                 add.l d3,d0               * Copy flag results into accumulator
02:00002FC0 51CEFFF2        	  5055:                 dbf d6,CMPM_LOOP1
                            	  5056: 
                            	  5057: 
02:00002FC4 307C0100        	  5058:                 move.l #$00000100,a0       * Address for Data-X
02:00002FC8 327C0200        	  5059:                 move.l #$00000200,a1       * Address for Data-Y
02:00002FCC 7C07            	  5060:                 moveq  #$00000007,d6       * Loop counter
                            	  5061: 
02:00002FCE B348            	  5062: CMPM_LOOP2:     cmpm.w (a0)+,(a1)+
02:00002FD0 40C3            	  5063:                 move.w sr,d3
02:00002FD2 02830000000F    	  5064:                 andi.l #$0F,d3            * Isolate flags
02:00002FD8 D283            	  5065:                 add.l d3,d1               * Copy flag results into accumulator
02:00002FDA 51CEFFF2        	  5066:                 dbf d6,CMPM_LOOP2
                            	  5067: 
                            	  5068: 
02:00002FDE 307C0100        	  5069:                 move.l #$00000100,a0       * Address for Data-X
02:00002FE2 327C0200        	  5070:                 move.l #$00000200,a1       * Address for Data-Y
02:00002FE6 7C03            	  5071:                 moveq  #$00000003,d6       * Loop counter
                            	  5072: 
02:00002FE8 B388            	  5073: CMPM_LOOP3:     cmpm.l (a0)+,(a1)+
02:00002FEA 40C3            	  5074:                 move.w sr,d3
02:00002FEC 02830000000F    	  5075:                 andi.l #$0F,d3            * Isolate flags
02:00002FF2 D483            	  5076:                 add.l d3,d2               * Copy flag results into accumulator
02:00002FF4 51CEFFF2        	  5077:                 dbf d6,CMPM_LOOP3
                            	  5078: 
                            	  5079: 
02:00002FF8 0C800000004C    	  5080:                 cmpi.l #$0000004C,d0      * Check the data results
02:00002FFE 66FE            	  5081:                 bne.s *
02:00003000 0C8100000024    	  5082:                 cmpi.l #$00000024,d1
02:00003006 66FE            	  5083:                 bne.s *
02:00003008 0C8200000012    	  5084:                 cmpi.l #$00000012,d2
02:0000300E 66FE            	  5085:                 bne.s *
                            	  5086: 
02:00003010 4E75            	  5087:                 rts
                            	  5088: 
                            	  5089: 
                            	  5090: *-----------------------------------------------------------
                            	  5091: *-----------------------------------------------------------
                            	  5092: * OPCODE : ADD
                            	  5093: *-----------------------------------------------------------
                            	  5094: *-----------------------------------------------------------
                            	  5095: 
                            	  5096: op_ADD:
                            	  5097: 
                            	  5098: 
                            	  5099: *  * <EA> to Register
02:00003012 203CA5A5A5A5    	  5100:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003018 223C8167E123    	  5101:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:0000301E 243CA5A5A5A5    	  5102:                 move.l #$a5a5a5a5,d2
02:00003024 7600            	  5103:                 moveq  #$00000000,d3
02:00003026 7800            	  5104:                 moveq  #$00000000,d4       * Cumulative data results
02:00003028 7A00            	  5105:                 moveq  #$00000000,d5       * Cumulative flag results
02:0000302A 7C1E            	  5106:                 move.l #$0000001E,d6       * Inner loop counter
02:0000302C 7E1E            	  5107:                 move.l #$0000001E,d7       * Outer loop counter
02:0000302E 307C0100        	  5108:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5109: 
                            	  5110: 
                            	  5111: ADD_OUTER1:
                            	  5112: 
                            	  5113: *     BYTE
02:00003032 2081            	  5114:                 move.l d1,(a0)
02:00003034 D010            	  5115:                 add.b (a0),d0
02:00003036 40C3            	  5116:                 move.w sr,d3
02:00003038 02830000001F    	  5117:                 andi.l #$1F,d3            * Isolate flags
02:0000303E DA83            	  5118:                 add.l d3,d5               * Copy flag results into accumulator
02:00003040 D880            	  5119:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5120: 
                            	  5121: *     WORD
02:00003042 2081            	  5122:                 move.l d1,(a0)
02:00003044 D050            	  5123:                 add.w (a0),d0
02:00003046 40C3            	  5124:                 move.w sr,d3
02:00003048 02830000000C    	  5125:                 andi.l #$0C,d3            * Isolate flags
02:0000304E DA83            	  5126:                 add.l d3,d5               * Copy flag results into accumulator
02:00003050 D880            	  5127:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5128: 
                            	  5129: *     LONG
02:00003052 2081            	  5130:                 move.l d1,(a0)
02:00003054 D090            	  5131:                 add.l (a0),d0
02:00003056 40C3            	  5132:                 move.w sr,d3
02:00003058 02830000000F    	  5133:                 andi.l #$0F,d3            * Isolate flags
02:0000305E DA83            	  5134:                 add.l d3,d5               * Copy flag results into accumulator
02:00003060 D880            	  5135:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5136: 
                            	  5137: 
02:00003062 E299            	  5138:                 ror.l #$1,d1
02:00003064 51CEFFCC        	  5139:                 dbf d6,ADD_OUTER1
02:00003068 E29A            	  5140:                 ror.l #$1,d2
02:0000306A 223C8167E123    	  5141:                 move.l #$8167E123,d1       * Initial Data-Y
02:00003070 7C1E            	  5142:                 move.l #$0000001E,d6       * Inner loop counter
02:00003072 51CFFFBE        	  5143:                 dbf d7,ADD_OUTER1
                            	  5144: 
02:00003076 0C8423ED428F    	  5145:                 cmpi.l #$23ED428F,d4      * Check the data results
02:0000307C 66FE            	  5146:                 bne.s *
02:0000307E 0C8500004C96    	  5147:                 cmpi.l #$00004C96,d5      * Check the Flag results
02:00003084 66FE            	  5148:                 bne.s *
                            	  5149: 
                            	  5150: 
                            	  5151: *  * Register to <EA>
02:00003086 203C86738374    	  5152:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:0000308C 223CFC55F2FE    	  5153:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00003092 243C86738374    	  5154:                 move.l #$86738374,d2
02:00003098 7600            	  5155:                 moveq  #$00000000,d3
02:0000309A 7800            	  5156:                 moveq  #$00000000,d4       * Cumulative data results
02:0000309C 7A00            	  5157:                 moveq  #$00000000,d5       * Cumulative flag results
02:0000309E 7C1E            	  5158:                 move.l #$0000001E,d6       * Inner loop counter
02:000030A0 7E1D            	  5159:                 move.l #$0000001D,d7       * Outer loop counter
02:000030A2 307C0100        	  5160:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5161: 
                            	  5162: 
                            	  5163: ADD_OUTER2:
                            	  5164: 
                            	  5165: *     BYTE
02:000030A6 2080            	  5166:                 move.l d0,(a0)
02:000030A8 D310            	  5167:                 add.b d1,(a0)
02:000030AA 40C3            	  5168:                 move.w sr,d3
02:000030AC 02830000000C    	  5169:                 andi.l #$0C,d3            * Isolate flags
02:000030B2 DA83            	  5170:                 add.l d3,d5               * Copy flag results into accumulator
02:000030B4 D890            	  5171:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5172: 
                            	  5173: *     WORD
02:000030B6 2080            	  5174:                 move.l d0,(a0)
02:000030B8 D350            	  5175:                 add.w d1,(a0)
02:000030BA 40C3            	  5176:                 move.w sr,d3
02:000030BC 02830000001F    	  5177:                 andi.l #$1F,d3            * Isolate flags
02:000030C2 DA83            	  5178:                 add.l d3,d5               * Copy flag results into accumulator
02:000030C4 D890            	  5179:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5180: 
                            	  5181: *     LONG
02:000030C6 2080            	  5182:                 move.l d0,(a0)
02:000030C8 D390            	  5183:                 add.l d1,(a0)
02:000030CA 40C3            	  5184:                 move.w sr,d3
02:000030CC 02830000000F    	  5185:                 andi.l #$0F,d3            * Isolate flags
02:000030D2 DA83            	  5186:                 add.l d3,d5               * Copy flag results into accumulator
02:000030D4 D890            	  5187:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5188: 
                            	  5189: 
02:000030D6 E299            	  5190:                 ror.l #$1,d1
02:000030D8 51CEFFCC        	  5191:                 dbf d6,ADD_OUTER2
02:000030DC E29A            	  5192:                 ror.l #$1,d2
02:000030DE 223C8167E123    	  5193:                 move.l #$8167E123,d1       * Initial Data-Y
02:000030E4 7C1E            	  5194:                 move.l #$0000001E,d6       * Inner loop counter
02:000030E6 51CFFFBE        	  5195:                 dbf d7,ADD_OUTER2
                            	  5196: 
02:000030EA 0C846701B884    	  5197:                 cmpi.l #$6701B884,d4      * Check the data results
02:000030F0 66FE            	  5198:                 bne.s *
02:000030F2 0C8500005467    	  5199:                 cmpi.l #$00005467,d5      * Check the Flag results
02:000030F8 66FE            	  5200:                 bne.s *
                            	  5201: 
02:000030FA 4E75            	  5202:                 rts
                            	  5203: 
                            	  5204: *-----------------------------------------------------------
                            	  5205: *-----------------------------------------------------------
                            	  5206: * OPCODE : SUB
                            	  5207: *-----------------------------------------------------------
                            	  5208: *-----------------------------------------------------------
                            	  5209: 
                            	  5210: op_SUB:
                            	  5211: 
                            	  5212: *  * <EA> to Register
02:000030FC 203CA5A5A5A5    	  5213:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003102 223C8167E123    	  5214:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00003108 243CA5A5A5A5    	  5215:                 move.l #$a5a5a5a5,d2
02:0000310E 7600            	  5216:                 moveq  #$00000000,d3
02:00003110 7800            	  5217:                 moveq  #$00000000,d4       * Cumulative data results
02:00003112 7A00            	  5218:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003114 7C1E            	  5219:                 move.l #$0000001E,d6       * Inner loop counter
02:00003116 7E1E            	  5220:                 move.l #$0000001E,d7       * Outer loop counter
02:00003118 307C0100        	  5221:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5222: 
                            	  5223: 
                            	  5224: SUB_OUTER1:
                            	  5225: 
                            	  5226: *     BYTE
02:0000311C 2081            	  5227:                 move.l d1,(a0)
02:0000311E 9010            	  5228:                 sub.b (a0),d0
02:00003120 40C3            	  5229:                 move.w sr,d3
02:00003122 02830000001F    	  5230:                 andi.l #$1F,d3            * Isolate flags
02:00003128 DA83            	  5231:                 add.l d3,d5               * Copy flag results into accumulator
02:0000312A D880            	  5232:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5233: 
                            	  5234: *     WORD
02:0000312C 2081            	  5235:                 move.l d1,(a0)
02:0000312E 9050            	  5236:                 sub.w (a0),d0
02:00003130 40C3            	  5237:                 move.w sr,d3
02:00003132 02830000000C    	  5238:                 andi.l #$0C,d3            * Isolate flags
02:00003138 DA83            	  5239:                 add.l d3,d5               * Copy flag results into accumulator
02:0000313A D880            	  5240:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5241: 
                            	  5242: *     LONG
02:0000313C 2081            	  5243:                 move.l d1,(a0)
02:0000313E 9090            	  5244:                 sub.l (a0),d0
02:00003140 40C3            	  5245:                 move.w sr,d3
02:00003142 02830000000F    	  5246:                 andi.l #$0F,d3            * Isolate flags
02:00003148 DA83            	  5247:                 add.l d3,d5               * Copy flag results into accumulator
02:0000314A D880            	  5248:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5249: 
                            	  5250: 
02:0000314C E299            	  5251:                 ror.l #$1,d1
02:0000314E 51CEFFCC        	  5252:                 dbf d6,SUB_OUTER1
02:00003152 E29A            	  5253:                 ror.l #$1,d2
02:00003154 223C8167E123    	  5254:                 move.l #$8167E123,d1       * Initial Data-Y
02:0000315A 7C1E            	  5255:                 move.l #$0000001E,d6       * Inner loop counter
02:0000315C 51CFFFBE        	  5256:                 dbf d7,SUB_OUTER1
                            	  5257: 
02:00003160 0C841A8D14CF    	  5258:                 cmpi.l #$1A8D14CF,d4      * Check the data results
02:00003166 66FE            	  5259:                 bne.s *
02:00003168 0C8500004FC4    	  5260:                 cmpi.l #$00004FC4,d5      * Check the Flag results
02:0000316E 66FE            	  5261:                 bne.s *
                            	  5262: 
                            	  5263: 
                            	  5264: *  * Register to <EA>
02:00003170 203C86738374    	  5265:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00003176 223CFC55F2FE    	  5266:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:0000317C 243C86738374    	  5267:                 move.l #$86738374,d2
02:00003182 7600            	  5268:                 moveq  #$00000000,d3
02:00003184 7800            	  5269:                 moveq  #$00000000,d4       * Cumulative data results
02:00003186 7A00            	  5270:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003188 7C1E            	  5271:                 move.l #$0000001E,d6       * Inner loop counter
02:0000318A 7E1D            	  5272:                 move.l #$0000001D,d7       * Outer loop counter
02:0000318C 307C0100        	  5273:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5274: 
                            	  5275: 
                            	  5276: SUB_OUTER2:
                            	  5277: 
                            	  5278: *     BYTE
02:00003190 2080            	  5279:                 move.l d0,(a0)
02:00003192 9310            	  5280:                 sub.b d1,(a0)
02:00003194 40C3            	  5281:                 move.w sr,d3
02:00003196 02830000000C    	  5282:                 andi.l #$0C,d3            * Isolate flags
02:0000319C DA83            	  5283:                 add.l d3,d5               * Copy flag results into accumulator
02:0000319E D890            	  5284:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5285: 
                            	  5286: *     WORD
02:000031A0 2080            	  5287:                 move.l d0,(a0)
02:000031A2 9350            	  5288:                 sub.w d1,(a0)
02:000031A4 40C3            	  5289:                 move.w sr,d3
02:000031A6 02830000001F    	  5290:                 andi.l #$1F,d3            * Isolate flags
02:000031AC DA83            	  5291:                 add.l d3,d5               * Copy flag results into accumulator
02:000031AE D890            	  5292:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5293: 
                            	  5294: *     LONG
02:000031B0 2080            	  5295:                 move.l d0,(a0)
02:000031B2 9390            	  5296:                 sub.l d1,(a0)
02:000031B4 40C3            	  5297:                 move.w sr,d3
02:000031B6 02830000000F    	  5298:                 andi.l #$0F,d3            * Isolate flags
02:000031BC DA83            	  5299:                 add.l d3,d5               * Copy flag results into accumulator
02:000031BE D890            	  5300:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5301: 
                            	  5302: 
02:000031C0 E299            	  5303:                 ror.l #$1,d1
02:000031C2 51CEFFCC        	  5304:                 dbf d6,SUB_OUTER2
02:000031C6 E29A            	  5305:                 ror.l #$1,d2
02:000031C8 223C8167E123    	  5306:                 move.l #$8167E123,d1       * Initial Data-Y
02:000031CE 7C1E            	  5307:                 move.l #$0000001E,d6       * Inner loop counter
02:000031D0 51CFFFBE        	  5308:                 dbf d7,SUB_OUTER2
                            	  5309: 
02:000031D4 0C8436D38BEC    	  5310:                 cmpi.l #$36D38BEC,d4      * Check the data results
02:000031DA 66FE            	  5311:                 bne.s *
02:000031DC 0C85000045A5    	  5312:                 cmpi.l #$000045A5,d5      * Check the Flag results
02:000031E2 66FE            	  5313:                 bne.s *
                            	  5314: 
                            	  5315: 
                            	  5316: 
                            	  5317: 
02:000031E4 4E75            	  5318:                 rts
                            	  5319: 
                            	  5320: 
                            	  5321: 
                            	  5322: *-----------------------------------------------------------
                            	  5323: *-----------------------------------------------------------
                            	  5324: * OPCODE : ADDA
                            	  5325: *-----------------------------------------------------------
                            	  5326: *-----------------------------------------------------------
                            	  5327: 
                            	  5328: op_ADDA:
                            	  5329: 
                            	  5330: *  * <EA> to Register
02:000031E6 203CA5A5A5A5    	  5331:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:000031EC 223C8167E123    	  5332:                 move.l #$8167E123,d1
02:000031F2 243CA5A5A5A5    	  5333:                 move.l #$a5a5a5a5,d2
02:000031F8 7600            	  5334:                 moveq  #$00000000,d3
02:000031FA 7800            	  5335:                 moveq  #$00000000,d4       * Cumulative data results
02:000031FC 7A00            	  5336:                 moveq  #$00000000,d5       * Cumulative flag results
02:000031FE 7C1E            	  5337:                 move.l #$0000001E,d6       * Inner loop counter
02:00003200 7E1E            	  5338:                 move.l #$0000001E,d7       * Outer loop counter
02:00003202 307C0100        	  5339:                 move.l #$00000100,a0       * Address for memory EA operations
02:00003206 227C8167E123    	  5340:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5341: 
                            	  5342: ADDA_OUTER1:
                            	  5343: 
                            	  5344: *     WORD
                            	  5345: *                move.l d1,(a0)       * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5346: *                adda.w (a0),a1
                            	  5347: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5348: 
                            	  5349: *     LONG
02:0000320C 2081            	  5350:                 move.l d1,(a0)
02:0000320E D3D0            	  5351:                 adda.l (a0),a1
02:00003210 D889            	  5352:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5353: 
02:00003212 E299            	  5354:                 ror.l #$1,d1
02:00003214 51CEFFF6        	  5355:                 dbf d6,ADDA_OUTER1
02:00003218 E299            	  5356:                 ror.l #$1,d1
02:0000321A 2241            	  5357:                 move.l d1,a1
02:0000321C 223C8167E123    	  5358:                 move.l #$8167E123,d1       * Initial Data-Y
02:00003222 7C1E            	  5359:                 move.l #$0000001E,d6       * Inner loop counter
02:00003224 51CFFFE6        	  5360:                 dbf d7,ADDA_OUTER1
                            	  5361: 
02:00003228 0C84AC04DB4C    	  5362:                 cmpi.l #$AC04DB4C,d4      * Check the data results
02:0000322E 66FE            	  5363:                 bne.s *
                            	  5364: 
                            	  5365: 
02:00003230 4E75            	  5366:                 rts
                            	  5367: 
                            	  5368: 
                            	  5369: *-----------------------------------------------------------
                            	  5370: *-----------------------------------------------------------
                            	  5371: * OPCODE : SUBA
                            	  5372: *-----------------------------------------------------------
                            	  5373: *-----------------------------------------------------------
                            	  5374: 
                            	  5375: op_SUBA:
                            	  5376: 
                            	  5377: *  * <EA> to Register
02:00003232 203CA5A5A5A5    	  5378:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003238 223C8167E123    	  5379:                 move.l #$8167E123,d1
02:0000323E 243CA5A5A5A5    	  5380:                 move.l #$a5a5a5a5,d2
02:00003244 7600            	  5381:                 moveq  #$00000000,d3
02:00003246 7800            	  5382:                 moveq  #$00000000,d4       * Cumulative data results
02:00003248 7A00            	  5383:                 moveq  #$00000000,d5       * Cumulative flag results
02:0000324A 7C1E            	  5384:                 move.l #$0000001E,d6       * Inner loop counter
02:0000324C 7E1E            	  5385:                 move.l #$0000001E,d7       * Outer loop counter
02:0000324E 307C0100        	  5386:                 move.l #$00000100,a0       * Address for memory EA operations
02:00003252 227C8167E123    	  5387:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5388: 
                            	  5389: SUBA_OUTER1:
                            	  5390: 
                            	  5391: *     WORD
                            	  5392: *                move.l d1,(a0) * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5393: *                suba.w (a0),a1
                            	  5394: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5395: 
                            	  5396: *     LONG
02:00003258 2081            	  5397:                 move.l d1,(a0)
02:0000325A 93D0            	  5398:                 suba.l (a0),a1
02:0000325C D889            	  5399:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5400: 
02:0000325E E299            	  5401:                 ror.l #$1,d1
02:00003260 51CEFFF6        	  5402:                 dbf d6,SUBA_OUTER1
02:00003264 E299            	  5403:                 ror.l #$1,d1
02:00003266 2241            	  5404:                 move.l d1,a1
02:00003268 223C8167E123    	  5405:                 move.l #$8167E123,d1       * Initial Data-Y
02:0000326E 7C1E            	  5406:                 move.l #$0000001E,d6       * Inner loop counter
02:00003270 51CFFFE6        	  5407:                 dbf d7,SUBA_OUTER1
                            	  5408: 
02:00003274 0C84E1E36D7A    	  5409:                 cmpi.l #$E1E36D7A,d4      * Check the data results
02:0000327A 66FE            	  5410:                 bne.s *
                            	  5411: 
                            	  5412: 
02:0000327C 4E75            	  5413:                 rts
                            	  5414: 
                            	  5415: 
                            	  5416: 
                            	  5417: *-----------------------------------------------------------
                            	  5418: *-----------------------------------------------------------
                            	  5419: * OPCODE : ADDX
                            	  5420: *-----------------------------------------------------------
                            	  5421: *-----------------------------------------------------------
                            	  5422: 
                            	  5423: op_ADDX:
                            	  5424: 
                            	  5425: 
                            	  5426: *  * Register to Register
02:0000327E 203CA5A5A5A5    	  5427:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003284 223C8167E123    	  5428:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:0000328A 243CA5A5A5A5    	  5429:                 move.l #$a5a5a5a5,d2
02:00003290 7600            	  5430:                 moveq  #$00000000,d3
02:00003292 7800            	  5431:                 moveq  #$00000000,d4       * Cumulative data results
02:00003294 7A00            	  5432:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003296 7C1E            	  5433:                 move.l #$0000001E,d6       * Inner loop counter
02:00003298 7E1E            	  5434:                 move.l #$0000001E,d7       * Outer loop counter
02:0000329A 307C0100        	  5435:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5436: 
                            	  5437: 
                            	  5438: ADDX_OUTER1:
                            	  5439: 
                            	  5440: *     BYTE
02:0000329E 2002            	  5441:                 move.l d2,d0
02:000032A0 D101            	  5442:                 addx.b d1,d0
02:000032A2 40C3            	  5443:                 move.w sr,d3
02:000032A4 02830000001F    	  5444:                 andi.l #$1F,d3            * Isolate flags
02:000032AA DA83            	  5445:                 add.l d3,d5               * Copy flag results into accumulator
02:000032AC D880            	  5446:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5447: 
                            	  5448: *     WORD
02:000032AE 2002            	  5449:                 move.l d2,d0
02:000032B0 D141            	  5450:                 addx.w d1,d0
02:000032B2 40C3            	  5451:                 move.w sr,d3
02:000032B4 02830000001F    	  5452:                 andi.l #$1F,d3            * Isolate flags
02:000032BA DA83            	  5453:                 add.l d3,d5               * Copy flag results into accumulator
02:000032BC D880            	  5454:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5455: 
                            	  5456: *     LONG
02:000032BE 2002            	  5457:                 move.l d2,d0
02:000032C0 D181            	  5458:                 addx.l d1,d0
02:000032C2 40C3            	  5459:                 move.w sr,d3
02:000032C4 02830000001F    	  5460:                 andi.l #$1F,d3            * Isolate flags
02:000032CA DA83            	  5461:                 add.l d3,d5               * Copy flag results into accumulator
02:000032CC D880            	  5462:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5463: 
02:000032CE E299            	  5464:                 ror.l #$1,d1
02:000032D0 51CEFFCC        	  5465:                 dbf d6,ADDX_OUTER1
02:000032D4 E29A            	  5466:                 ror.l #$1,d2
02:000032D6 223C8167E123    	  5467:                 move.l #$8167E123,d1       * Initial Data-Y
02:000032DC 7C1E            	  5468:                 move.l #$0000001E,d6       * Inner loop counter
02:000032DE 51CFFFBE        	  5469:                 dbf d7,ADDX_OUTER1
                            	  5470: 
02:000032E2 0C844E96A4D9    	  5471:                 cmpi.l #$4E96A4D9,d4      * Check the data results
02:000032E8 66FE            	  5472:                 bne.s *
02:000032EA 0C85000085CD    	  5473:                 cmpi.l #$000085CD,d5      * Check the Flag results
02:000032F0 66FE            	  5474:                 bne.s *
                            	  5475: 
                            	  5476: 
                            	  5477: 
                            	  5478: *     -(An),-(An)
                            	  5479: 
02:000032F2 7000            	  5480:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
02:000032F4 7200            	  5481:                 moveq  #$00000000,d1
02:000032F6 7400            	  5482:                 moveq  #$00000000,d2
02:000032F8 307C0100        	  5483:                 move.l #$00000100,a0       * Address for Data-X
02:000032FC 327C0200        	  5484:                 move.l #$00000200,a1       * Address for Data-Y
02:00003300 20FC11FF5580    	  5485:                 move.l #$11FF5580,(a0)+   * Populate test data
02:00003306 20FC1111FFFF    	  5486:                 move.l #$1111FFFF,(a0)+   * Populate test data
02:0000330C 20FC33333333    	  5487:                 move.l #$33333333,(a0)+   * Populate test data
02:00003312 20FC44444444    	  5488:                 move.l #$44444444,(a0)+   * Populate test data
02:00003318 22FC80FF337F    	  5489:                 move.l #$80FF337F,(a1)+   * Populate test data
02:0000331E 22FCFFFF1111    	  5490:                 move.l #$FFFF1111,(a1)+   * Populate test data
02:00003324 22FC33333333    	  5491:                 move.l #$33333333,(a1)+   * Populate test data
02:0000332A 22FC44444444    	  5492:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5493: 
                            	  5494: 
02:00003330 7C0F            	  5495:                 move.l #$0000000F,d6       * Loop counter
                            	  5496: 
02:00003332 D308            	  5497: ADDX_LOOP3:     addx.b -(a0),-(a1)
02:00003334 40C3            	  5498:                 move.w sr,d3
02:00003336 02830000000F    	  5499:                 andi.l #$0F,d3            * Isolate flags
02:0000333C D083            	  5500:                 add.l d3,d0               * Copy flag results into accumulator
02:0000333E D211            	  5501:                 add.b (a1),d1
02:00003340 51CEFFF0        	  5502:                 dbf d6,ADDX_LOOP3
                            	  5503: 
                            	  5504: 
02:00003344 307C0110        	  5505:                 move.l #$00000110,a0       * Address for Data-X
02:00003348 327C0210        	  5506:                 move.l #$00000210,a1       * Address for Data-Y
02:0000334C 7C07            	  5507:                 moveq  #$00000007,d6       * Loop counter
                            	  5508: 
02:0000334E D348            	  5509: ADDX_LOOP4:     addx.w -(a0),-(a1)
02:00003350 40C3            	  5510:                 move.w sr,d3
02:00003352 02830000000F    	  5511:                 andi.l #$0F,d3            * Isolate flags
02:00003358 D083            	  5512:                 add.l d3,d0               * Copy flag results into accumulator
02:0000335A D251            	  5513:                 add.w (a1),d1
02:0000335C 51CEFFF0        	  5514:                 dbf d6,ADDX_LOOP4
                            	  5515: 
                            	  5516: 
02:00003360 307C0110        	  5517:                 move.l #$00000110,a0       * Address for Data-X
02:00003364 327C0210        	  5518:                 move.l #$00000210,a1       * Address for Data-Y
02:00003368 7C03            	  5519:                 moveq  #$00000003,d6       * Loop counter
                            	  5520: 
02:0000336A D388            	  5521: ADDX_LOOP5:     addx.l -(a0),-(a1)
02:0000336C 40C3            	  5522:                 move.w sr,d3
02:0000336E 02830000000F    	  5523:                 andi.l #$0F,d3            * Isolate flags
02:00003374 D083            	  5524:                 add.l d3,d0               * Copy flag results into accumulator
02:00003376 D291            	  5525:                 add.l (a1),d1
02:00003378 51CEFFF0        	  5526:                 dbf d6,ADDX_LOOP5
                            	  5527: 
                            	  5528: 
02:0000337C 0C8000000095    	  5529:                 cmpi.l #$00000095,d0      * Check the flag results
02:00003382 66FE            	  5530:                 bne.s *
02:00003384 0C81C812A682    	  5531:                 cmpi.l #$C812A682,d1      * Check the data results
02:0000338A 66FE            	  5532:                 bne.s *
                            	  5533: 
02:0000338C 4E75            	  5534:                 rts
                            	  5535: 
                            	  5536: 
                            	  5537: 
                            	  5538: 
                            	  5539: *-----------------------------------------------------------
                            	  5540: *-----------------------------------------------------------
                            	  5541: * OPCODE : SUBX
                            	  5542: *-----------------------------------------------------------
                            	  5543: *-----------------------------------------------------------
                            	  5544: 
                            	  5545: op_SUBX:
                            	  5546: 
                            	  5547: 
                            	  5548: *  * Register to Register
02:0000338E 203CA5A5A5A5    	  5549:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003394 223C8167E123    	  5550:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:0000339A 243CA5A5A5A5    	  5551:                 move.l #$a5a5a5a5,d2
02:000033A0 7600            	  5552:                 moveq  #$00000000,d3
02:000033A2 7800            	  5553:                 moveq  #$00000000,d4       * Cumulative data results
02:000033A4 7A00            	  5554:                 moveq  #$00000000,d5       * Cumulative flag results
02:000033A6 7C1E            	  5555:                 move.l #$0000001E,d6       * Inner loop counter
02:000033A8 7E1E            	  5556:                 move.l #$0000001E,d7       * Outer loop counter
02:000033AA 307C0100        	  5557:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5558: 
                            	  5559: 
                            	  5560: SUBX_OUTER1:
                            	  5561: 
                            	  5562: *     BYTE
02:000033AE 2002            	  5563:                 move.l d2,d0
02:000033B0 9101            	  5564:                 subx.b d1,d0
02:000033B2 40C3            	  5565:                 move.w sr,d3
02:000033B4 02830000001F    	  5566:                 andi.l #$1F,d3            * Isolate flags
02:000033BA DA83            	  5567:                 add.l d3,d5               * Copy flag results into accumulator
02:000033BC D880            	  5568:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5569: 
                            	  5570: *     WORD
02:000033BE 2002            	  5571:                 move.l d2,d0
02:000033C0 9141            	  5572:                 subx.w d1,d0
02:000033C2 40C3            	  5573:                 move.w sr,d3
02:000033C4 02830000001F    	  5574:                 andi.l #$1F,d3            * Isolate flags
02:000033CA DA83            	  5575:                 add.l d3,d5               * Copy flag results into accumulator
02:000033CC D880            	  5576:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5577: 
                            	  5578: *     LONG
02:000033CE 2002            	  5579:                 move.l d2,d0
02:000033D0 9181            	  5580:                 subx.l d1,d0
02:000033D2 40C3            	  5581:                 move.w sr,d3
02:000033D4 02830000001F    	  5582:                 andi.l #$1F,d3            * Isolate flags
02:000033DA DA83            	  5583:                 add.l d3,d5               * Copy flag results into accumulator
02:000033DC D880            	  5584:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5585: 
02:000033DE E299            	  5586:                 ror.l #$1,d1
02:000033E0 51CEFFCC        	  5587:                 dbf d6,SUBX_OUTER1
02:000033E4 E29A            	  5588:                 ror.l #$1,d2
02:000033E6 223C8167E123    	  5589:                 move.l #$8167E123,d1       * Initial Data-Y
02:000033EC 7C1E            	  5590:                 move.l #$0000001E,d6       * Inner loop counter
02:000033EE 51CFFFBE        	  5591:                 dbf d7,SUBX_OUTER1
                            	  5592: 
02:000033F2 0C84FCAA913E    	  5593:                 cmpi.l #$FCAA913E,d4      * Check the data results
02:000033F8 66FE            	  5594:                 bne.s *
02:000033FA 0C8500007E89    	  5595:                 cmpi.l #$00007E89,d5      * Check the Flag results
02:00003400 66FE            	  5596:                 bne.s *
                            	  5597: 
                            	  5598: 
                            	  5599: 
                            	  5600: *     -(An),-(An)
                            	  5601: 
02:00003402 7000            	  5602:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
02:00003404 7200            	  5603:                 moveq  #$00000000,d1
02:00003406 7400            	  5604:                 moveq  #$00000000,d2
02:00003408 307C0100        	  5605:                 move.l #$00000100,a0       * Address for Data-X
02:0000340C 327C0200        	  5606:                 move.l #$00000200,a1       * Address for Data-Y
02:00003410 20FC11FF5580    	  5607:                 move.l #$11FF5580,(a0)+   * Populate test data
02:00003416 20FC1111FFFF    	  5608:                 move.l #$1111FFFF,(a0)+   * Populate test data
02:0000341C 20FC80FF337F    	  5609:                 move.l #$80FF337F,(a0)+   * Populate test data
02:00003422 20FC44444444    	  5610:                 move.l #$44444444,(a0)+   * Populate test data
02:00003428 22FC80FF337F    	  5611:                 move.l #$80FF337F,(a1)+   * Populate test data
02:0000342E 22FC1111FFFF    	  5612:                 move.l #$1111FFFF,(a1)+   * Populate test data
02:00003434 22FC33333333    	  5613:                 move.l #$33333333,(a1)+   * Populate test data
02:0000343A 22FC5580EECC    	  5614:                 move.l #$5580EECC,(a1)+   * Populate test data
                            	  5615: 
                            	  5616: 
02:00003440 7C0F            	  5617:                 move.l #$0000000F,d6       * Loop counter
                            	  5618: 
02:00003442 9308            	  5619: SUBX_LOOP3:     subx.b -(a0),-(a1)
02:00003444 40C3            	  5620:                 move.w sr,d3
02:00003446 02830000000F    	  5621:                 andi.l #$0F,d3            * Isolate flags
02:0000344C D083            	  5622:                 add.l d3,d0               * Copy flag results into accumulator
02:0000344E D211            	  5623:                 add.b (a1),d1
02:00003450 51CEFFF0        	  5624:                 dbf d6,SUBX_LOOP3
                            	  5625: 
                            	  5626: 
02:00003454 307C0110        	  5627:                 move.l #$00000110,a0       * Address for Data-X
02:00003458 327C0210        	  5628:                 move.l #$00000210,a1       * Address for Data-Y
02:0000345C 7C07            	  5629:                 moveq  #$00000007,d6       * Loop counter
                            	  5630: 
02:0000345E 9348            	  5631: SUBX_LOOP4:     subx.w -(a0),-(a1)
02:00003460 40C3            	  5632:                 move.w sr,d3
02:00003462 02830000000F    	  5633:                 andi.l #$0F,d3            * Isolate flags
02:00003468 D083            	  5634:                 add.l d3,d0               * Copy flag results into accumulator
02:0000346A D251            	  5635:                 add.w (a1),d1
02:0000346C 51CEFFF0        	  5636:                 dbf d6,SUBX_LOOP4
                            	  5637: 
                            	  5638: 
02:00003470 307C0110        	  5639:                 move.l #$00000110,a0       * Address for Data-X
02:00003474 327C0210        	  5640:                 move.l #$00000210,a1       * Address for Data-Y
02:00003478 7C03            	  5641:                 moveq  #$00000003,d6       * Loop counter
                            	  5642: 
02:0000347A 9388            	  5643: SUBX_LOOP5:     subx.l -(a0),-(a1)
02:0000347C 40C3            	  5644:                 move.w sr,d3
02:0000347E 02830000000F    	  5645:                 andi.l #$0F,d3            * Isolate flags
02:00003484 D083            	  5646:                 add.l d3,d0               * Copy flag results into accumulator
02:00003486 D291            	  5647:                 add.l (a1),d1
02:00003488 51CEFFF0        	  5648:                 dbf d6,SUBX_LOOP5
                            	  5649: 
                            	  5650: 
02:0000348C 0C80000000B1    	  5651:                 cmpi.l #$000000B1,d0      * Check the flag results
02:00003492 66FE            	  5652:                 bne.s *
02:00003494 0C8162C6F417    	  5653:                 cmpi.l #$62C6F417,d1      * Check the data results
02:0000349A 66FE            	  5654:                 bne.s *
                            	  5655: 
02:0000349C 4E75            	  5656:                 rts
                            	  5657: 
                            	  5658: 
                            	  5659: *-----------------------------------------------------------
                            	  5660: *-----------------------------------------------------------
                            	  5661: * OPCODE : MULU
                            	  5662: *-----------------------------------------------------------
                            	  5663: *-----------------------------------------------------------
                            	  5664: 
                            	  5665: op_MULU:
                            	  5666: 
02:0000349E 203CFE805501    	  5667:                 move.l #$FE805501,d0        * Initial
02:000034A4 223C5697EDB6    	  5668:                 move.l #$5697EDB6,d1        * Initial Y
02:000034AA 243CFE805501    	  5669:                 move.l #$FE805501,d2
02:000034B0 7600            	  5670:                 moveq  #$00000000,d3
02:000034B2 7800            	  5671:                 moveq  #$00000000,d4        * Cumulative data results
02:000034B4 7A00            	  5672:                 moveq  #$00000000,d5       * Cumulative flag results
02:000034B6 7C0E            	  5673:                 move.l #$0000000E,d6       * Inner loop counter
02:000034B8 7E0E            	  5674:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5675: 
                            	  5676: 
02:000034BA C0C1            	  5677: MULU_OUTER1:    mulu d1,d0
02:000034BC 40C3            	  5678:                 move.w sr,d3
02:000034BE 02830000000C    	  5679:                 andi.l #$0C,d3            * Isolate flags
02:000034C4 DA83            	  5680:                 add.l d3,d5               * Copy flag results into accumulator
02:000034C6 D880            	  5681:                 add.l d0,d4               * Copy data results into data accumulator
02:000034C8 E299            	  5682:                 ror.l #$1,d1
                            	  5683: 
02:000034CA 51CEFFEE        	  5684:                 dbf d6,MULU_OUTER1
02:000034CE E29A            	  5685:                 ror.l #$1,d2
02:000034D0 2002            	  5686:                 move.l d2,d0
02:000034D2 7C0E            	  5687:                 move.l #$0000000E,d6       * Inner loop counter
02:000034D4 51CFFFE4        	  5688:                 dbf d7,MULU_OUTER1
                            	  5689: 
02:000034D8 0C8476FB988C    	  5690:                 cmpi.l #$76FB988C,d4      * Check the data results
02:000034DE 66FE            	  5691:                 bne.s *
                            	  5692: 
02:000034E0 0C8500000170    	  5693:                 cmpi.l #$00000170,d5      * Check the Flag results
02:000034E6 66FE            	  5694:                 bne.s *
                            	  5695: 
                            	  5696: 
02:000034E8 4E75            	  5697:                 rts
                            	  5698: 
                            	  5699: 
                            	  5700: *-----------------------------------------------------------
                            	  5701: *-----------------------------------------------------------
                            	  5702: * OPCODE : MULS
                            	  5703: *-----------------------------------------------------------
                            	  5704: *-----------------------------------------------------------
                            	  5705: 
                            	  5706: op_MULS:
                            	  5707: 
02:000034EA 203CFE805501    	  5708:                 move.l #$FE805501,d0        * Initial
02:000034F0 223C5697EDB6    	  5709:                 move.l #$5697EDB6,d1        * Initial Y
02:000034F6 243CFE805501    	  5710:                 move.l #$FE805501,d2
02:000034FC 7600            	  5711:                 moveq  #$00000000,d3
02:000034FE 7800            	  5712:                 moveq  #$00000000,d4        * Cumulative data results
02:00003500 7A00            	  5713:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003502 7C0E            	  5714:                 move.l #$0000000E,d6       * Inner loop counter
02:00003504 7E0E            	  5715:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5716: 
                            	  5717: 
02:00003506 C1C1            	  5718: MULS_OUTER1:    muls d1,d0
02:00003508 40C3            	  5719:                 move.w sr,d3
02:0000350A 02830000000C    	  5720:                 andi.l #$0C,d3            * Isolate flags
02:00003510 DA83            	  5721:                 add.l d3,d5               * Copy flag results into accumulator
02:00003512 D880            	  5722:                 add.l d0,d4               * Copy data results into data accumulator
02:00003514 E299            	  5723:                 ror.l #$1,d1
                            	  5724: 
02:00003516 51CEFFEE        	  5725:                 dbf d6,MULS_OUTER1
02:0000351A E29A            	  5726:                 ror.l #$1,d2
02:0000351C 2002            	  5727:                 move.l d2,d0
02:0000351E 7C0E            	  5728:                 move.l #$0000000E,d6       * Inner loop counter
02:00003520 51CFFFE4        	  5729:                 dbf d7,MULS_OUTER1
                            	  5730: 
02:00003524 0C84D4E2988C    	  5731:                 cmpi.l #$D4E2988C,d4      * Check the data results
02:0000352A 66FE            	  5732:                 bne.s *
                            	  5733: 
02:0000352C 0C85000003E0    	  5734:                 cmpi.l #$000003E0,d5      * Check the Flag results
02:00003532 66FE            	  5735:                 bne.s *
                            	  5736: 
                            	  5737: 
02:00003534 4E75            	  5738:                 rts
                            	  5739: 
                            	  5740: 
                            	  5741: 
                            	  5742: *-----------------------------------------------------------
                            	  5743: *-----------------------------------------------------------
                            	  5744: * OPCODE : EXG
                            	  5745: *-----------------------------------------------------------
                            	  5746: *-----------------------------------------------------------
                            	  5747: 
                            	  5748: op_EXG:
02:00003536 223CD1D1D1D1    	  5749:                 move.l #$d1d1d1d1,d1
02:0000353C 243CD2D2D2D2    	  5750:                 move.l #$d2d2d2d2,d2
02:00003542 263CD3D3D3D3    	  5751:                 move.l #$d3d3d3d3,d3
02:00003548 227CA1A1A1A1    	  5752:                 move.l #$a1a1a1a1,a1
02:0000354E 247CA2A2A2A2    	  5753:                 move.l #$a2a2a2a2,a2
02:00003554 267CA3A3A3A3    	  5754:                 move.l #$a3a3a3a3,a3
                            	  5755: 
02:0000355A C342            	  5756:                 exg d1,d2
02:0000355C C34A            	  5757:                 exg a1,a2
02:0000355E C78B            	  5758:                 exg d3,a3
                            	  5759: 
02:00003560 0C81D2D2D2D2    	  5760:                 cmpi.l #$d2d2d2d2,d1      * Check the results
02:00003566 66FE            	  5761:                 bne.s *
02:00003568 0C82D1D1D1D1    	  5762:                 cmpi.l #$d1d1d1d1,d2
02:0000356E 66FE            	  5763:                 bne.s *
02:00003570 0C83A3A3A3A3    	  5764:                 cmpi.l #$a3a3a3a3,d3
02:00003576 66FE            	  5765:                 bne.s *
                            	  5766: 
02:00003578 2209            	  5767:                 move.l a1,d1
02:0000357A 240A            	  5768:                 move.l a2,d2
02:0000357C 260B            	  5769:                 move.l a3,d3
                            	  5770: 
02:0000357E 0C81A2A2A2A2    	  5771:                 cmpi.l #$a2a2a2a2,d1
02:00003584 66FE            	  5772:                 bne.s *
02:00003586 0C82A1A1A1A1    	  5773:                 cmpi.l #$a1a1a1a1,d2
02:0000358C 66FE            	  5774:                 bne.s *
02:0000358E 0C83D3D3D3D3    	  5775:                 cmpi.l #$d3d3d3d3,d3
02:00003594 66FE            	  5776:                 bne.s *
                            	  5777: 
02:00003596 4E75            	  5778:                 rts
                            	  5779: 
                            	  5780: 
                            	  5781: *-----------------------------------------------------------
                            	  5782: *-----------------------------------------------------------
                            	  5783: * OPCODE : ROx
                            	  5784: *-----------------------------------------------------------
                            	  5785: *-----------------------------------------------------------
                            	  5786: 
                            	  5787: *     Subroutine to check and accumulate the flags
02:00003598 40C3            	  5788: ROx_FLAGS:      move.w sr,d3
02:0000359A 02830000000F    	  5789:                 andi.l #$0F,d3            * Isolate flags
02:000035A0 DA83            	  5790:                 add.l d3,d5               * Copy flag results into accumulator
02:000035A2 4E75            	  5791:                 rts
                            	  5792: 
                            	  5793: op_ROx:
                            	  5794: 
                            	  5795: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  5796: 
                            	  5797: *        BYTE LEFT
02:000035A4 203C80018FF1    	  5798:                 move.l #$80018FF1,d0
02:000035AA 7A00            	  5799:                 moveq  #$00000000,d5
02:000035AC 7C11            	  5800:                 moveq  #$00000011,d6
                            	  5801: ROx_LOOP1:
02:000035AE ED38            	  5802:                 rol.b d6,d0
02:000035B0 61E6            	  5803:                 bsr ROx_FLAGS
02:000035B2 51CEFFFA        	  5804:                 dbf d6,ROx_LOOP1
02:000035B6 0C8080018FE3    	  5805:                 cmpi.l #$80018FE3,d0
02:000035BC 66FE            	  5806:                 bne.s *
02:000035BE 0C850000006B    	  5807:                 cmpi.l #$0000006B,d5
02:000035C4 66FE            	  5808:                 bne.s *
                            	  5809: 
                            	  5810: *        BYTE RIGHT
02:000035C6 203C80018FF1    	  5811:                 move.l #$80018FF1,d0
02:000035CC 7C12            	  5812:                 moveq  #$00000012,d6
                            	  5813: ROx_LOOP2:
02:000035CE EC38            	  5814:                 ror.b d6,d0
02:000035D0 61C6            	  5815:                 bsr ROx_FLAGS
02:000035D2 51CEFFFA        	  5816:                 dbf d6,ROx_LOOP2
02:000035D6 0C8080018F3E    	  5817:                 cmpi.l #$80018F3E,d0
02:000035DC 66FE            	  5818:                 bne.s *
02:000035DE 0C85000000C5    	  5819:                 cmpi.l #$000000C5,d5
02:000035E4 66FE            	  5820:                 bne.s *
                            	  5821: 
                            	  5822: 
                            	  5823: *        WORD LEFT
02:000035E6 203C80018FF1    	  5824:                 move.l #$80018FF1,d0
02:000035EC 7C13            	  5825:                 moveq  #$00000013,d6
                            	  5826: ROx_LOOP3:
02:000035EE ED78            	  5827:                 rol.w d6,d0
02:000035F0 61A6            	  5828:                 bsr ROx_FLAGS
02:000035F2 51CEFFFA        	  5829:                 dbf d6,ROx_LOOP3
02:000035F6 0C80800163FC    	  5830:                 cmpi.l #$800163FC,d0
02:000035FC 66FE            	  5831:                 bne.s *
02:000035FE 0C8500000131    	  5832:                 cmpi.l #$00000131,d5
02:00003604 66FE            	  5833:                 bne.s *
                            	  5834: 
                            	  5835: *        WORD RIGHT
02:00003606 203C80018FF1    	  5836:                 move.l #$80018FF1,d0
02:0000360C 7C1E            	  5837:                 move.l #$0000001E,d6
                            	  5838: ROx_LOOP4:
02:0000360E EC78            	  5839:                 ror.w d6,d0
02:00003610 6186            	  5840:                 bsr ROx_FLAGS
02:00003612 51CEFFFA        	  5841:                 dbf d6,ROx_LOOP4
02:00003616 0C808001C7F8    	  5842:                 cmpi.l #$8001C7F8,d0
02:0000361C 66FE            	  5843:                 bne.s *
02:0000361E 0C85000001DB    	  5844:                 cmpi.l #$000001DB,d5
02:00003624 66FE            	  5845:                 bne.s *
                            	  5846: 
                            	  5847: 
                            	  5848: *        LONG LEFT
02:00003626 203C80018FF1    	  5849:                 move.l #$80018FF1,d0
02:0000362C 7C15            	  5850:                 moveq  #$00000015,d6
                            	  5851: ROx_LOOP5:
02:0000362E EDB8            	  5852:                 rol.l d6,d0
02:00003630 6100FF66        	  5853:                 bsr ROx_FLAGS
02:00003634 51CEFFF8        	  5854:                 dbf d6,ROx_LOOP5
02:00003638 0C8000C7F8C0    	  5855:                 cmpi.l #$00C7F8C0,d0
02:0000363E 66FE            	  5856:                 bne.s *
02:00003640 0C850000021A    	  5857:                 cmpi.l #$0000021A,d5
02:00003646 66FE            	  5858:                 bne.s *
                            	  5859: 
                            	  5860: *        LONG RIGHT
02:00003648 203C80018FF1    	  5861:                 move.l #$80018FF1,d0
02:0000364E 7C16            	  5862:                 moveq  #$00000016,d6
                            	  5863: ROx_LOOP6:
02:00003650 ECB8            	  5864:                 ror.l d6,d0
02:00003652 6100FF44        	  5865:                 bsr ROx_FLAGS
02:00003656 51CEFFF8        	  5866:                 dbf d6,ROx_LOOP6
02:0000365A 0C80000C7F8C    	  5867:                 cmpi.l #$000C7F8C,d0
02:00003660 66FE            	  5868:                 bne.s *
02:00003662 0C8500000250    	  5869:                 cmpi.l #$00000250,d5
02:00003668 66FE            	  5870:                 bne.s *
                            	  5871: 
                            	  5872: 
                            	  5873: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  5874: 
02:0000366A 203C80018FF1    	  5875:                 move.l #$80018FF1,d0
02:00003670 7A00            	  5876:                 moveq  #$00000000,d5
                            	  5877: 
                            	  5878: *        BYTE LEFT
02:00003672 E318            	  5879:                 rol.b #1,d0
02:00003674 6100FF22        	  5880:                 bsr ROx_FLAGS
02:00003678 EB18            	  5881:                 rol.b #5,d0
02:0000367A 6100FF1C        	  5882:                 bsr ROx_FLAGS
02:0000367E EF18            	  5883:                 rol.b #7,d0
02:00003680 6100FF16        	  5884:                 bsr ROx_FLAGS
02:00003684 E118            	  5885:                 rol.b #8,d0
02:00003686 6100FF10        	  5886:                 bsr ROx_FLAGS
02:0000368A 0C8080018F3E    	  5887:                 cmpi.l #$80018F3E,d0
02:00003690 66FE            	  5888:                 bne.s *
02:00003692 0C8500000009    	  5889:                 cmpi.l #$00000009,d5
02:00003698 66FE            	  5890:                 bne.s *
                            	  5891: 
                            	  5892: *        BYTE RIGHT
02:0000369A E218            	  5893:                 ror.b #1,d0
02:0000369C 6100FEFA        	  5894:                 bsr ROx_FLAGS
02:000036A0 EA18            	  5895:                 ror.b #5,d0
02:000036A2 6100FEF4        	  5896:                 bsr ROx_FLAGS
02:000036A6 EE18            	  5897:                 ror.b #7,d0
02:000036A8 6100FEEE        	  5898:                 bsr ROx_FLAGS
02:000036AC E018            	  5899:                 ror.b #8,d0
02:000036AE 6100FEE8        	  5900:                 bsr ROx_FLAGS
02:000036B2 0C8080018FF1    	  5901:                 cmpi.l #$80018FF1,d0
02:000036B8 66FE            	  5902:                 bne.s *
02:000036BA 0C8500000024    	  5903:                 cmpi.l #$00000024,d5
02:000036C0 66FE            	  5904:                 bne.s *
                            	  5905: 
                            	  5906: *        WORD LEFT
02:000036C2 E358            	  5907:                 rol.w #1,d0
02:000036C4 6100FED2        	  5908:                 bsr ROx_FLAGS
02:000036C8 EB58            	  5909:                 rol.w #5,d0
02:000036CA 6100FECC        	  5910:                 bsr ROx_FLAGS
02:000036CE EF58            	  5911:                 rol.w #7,d0
02:000036D0 6100FEC6        	  5912:                 bsr ROx_FLAGS
02:000036D4 E158            	  5913:                 rol.w #8,d0
02:000036D6 6100FEC0        	  5914:                 bsr ROx_FLAGS
02:000036DA 0C808001FE31    	  5915:                 cmpi.l #$8001FE31,d0
02:000036E0 66FE            	  5916:                 bne.s *
02:000036E2 0C8500000037    	  5917:                 cmpi.l #$00000037,d5
02:000036E8 66FE            	  5918:                 bne.s *
                            	  5919: 
                            	  5920: *        WORD RIGHT
02:000036EA E258            	  5921:                 ror.w #1,d0
02:000036EC 6100FEAA        	  5922:                 bsr ROx_FLAGS
02:000036F0 EA58            	  5923:                 ror.w #5,d0
02:000036F2 6100FEA4        	  5924:                 bsr ROx_FLAGS
02:000036F6 EE58            	  5925:                 ror.w #7,d0
02:000036F8 6100FE9E        	  5926:                 bsr ROx_FLAGS
02:000036FC E058            	  5927:                 ror.w #8,d0
02:000036FE 6100FE98        	  5928:                 bsr ROx_FLAGS
02:00003702 0C8080018FF1    	  5929:                 cmpi.l #$80018FF1,d0
02:00003708 66FE            	  5930:                 bne.s *
02:0000370A 0C850000005B    	  5931:                 cmpi.l #$0000005B,d5
02:00003710 66FE            	  5932:                 bne.s *
                            	  5933: 
                            	  5934: *        LONG LEFT
02:00003712 E398            	  5935:                 rol.l #1,d0
02:00003714 6100FE82        	  5936:                 bsr ROx_FLAGS
02:00003718 EB98            	  5937:                 rol.l #5,d0
02:0000371A 6100FE7C        	  5938:                 bsr ROx_FLAGS
02:0000371E EF98            	  5939:                 rol.l #7,d0
02:00003720 6100FE76        	  5940:                 bsr ROx_FLAGS
02:00003724 E198            	  5941:                 rol.l #8,d0
02:00003726 6100FE70        	  5942:                 bsr ROx_FLAGS
02:0000372A 0C80FE300031    	  5943:                 cmpi.l #$FE300031,d0
02:00003730 66FE            	  5944:                 bne.s *
02:00003732 0C8500000065    	  5945:                 cmpi.l #$00000065,d5
02:00003738 66FE            	  5946:                 bne.s *
                            	  5947: 
                            	  5948: *        LONG RIGHT
02:0000373A E298            	  5949:                 ror.l #1,d0
02:0000373C 6100FE5A        	  5950:                 bsr ROx_FLAGS
02:00003740 EA98            	  5951:                 ror.l #5,d0
02:00003742 6100FE54        	  5952:                 bsr ROx_FLAGS
02:00003746 EE98            	  5953:                 ror.l #7,d0
02:00003748 6100FE4E        	  5954:                 bsr ROx_FLAGS
02:0000374C E098            	  5955:                 ror.l #8,d0
02:0000374E 6100FE48        	  5956:                 bsr ROx_FLAGS
02:00003752 0C8080018FF1    	  5957:                 cmpi.l #$80018FF1,d0
02:00003758 66FE            	  5958:                 bne.s *
02:0000375A 0C8500000080    	  5959:                 cmpi.l #$00000080,d5
02:00003760 66FE            	  5960:                 bne.s *
                            	  5961: 
                            	  5962: 
                            	  5963: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  5964: 
02:00003762 7A00            	  5965:                 moveq  #$00000000,d5
02:00003764 307C0100        	  5966:                 move.l #$00000100,a0
02:00003768 30BC8FF1        	  5967:                 move.w #$8FF1,(a0)
                            	  5968: 
                            	  5969: *        WORD LEFT
02:0000376C E7D0            	  5970:                 rol (a0)
02:0000376E 6100FE28        	  5971:                 bsr ROx_FLAGS
02:00003772 E7D0            	  5972:                 rol (a0)
02:00003774 6100FE22        	  5973:                 bsr ROx_FLAGS
02:00003778 E7D0            	  5974:                 rol (a0)
02:0000377A 6100FE1C        	  5975:                 bsr ROx_FLAGS
02:0000377E E7D0            	  5976:                 rol (a0)
02:00003780 6100FE16        	  5977:                 bsr ROx_FLAGS
02:00003784 3010            	  5978:                 move.w (a0),d0
02:00003786 0C808001FF18    	  5979:                 cmpi.l #$8001FF18,d0
02:0000378C 66FE            	  5980:                 bne.s *
02:0000378E 0C8500000009    	  5981:                 cmpi.l #$00000009,d5
02:00003794 66FE            	  5982:                 bne.s *
                            	  5983: 
                            	  5984: *        WORD RIGHT
02:00003796 E6D0            	  5985:                 ror (a0)
02:00003798 6100FDFE        	  5986:                 bsr ROx_FLAGS
02:0000379C E6D0            	  5987:                 ror (a0)
02:0000379E 6100FDF8        	  5988:                 bsr ROx_FLAGS
02:000037A2 E6D0            	  5989:                 ror (a0)
02:000037A4 6100FDF2        	  5990:                 bsr ROx_FLAGS
02:000037A8 E6D0            	  5991:                 ror (a0)
02:000037AA 6100FDEC        	  5992:                 bsr ROx_FLAGS
02:000037AE E6D0            	  5993:                 ror (a0)
02:000037B0 6100FDE6        	  5994:                 bsr ROx_FLAGS
02:000037B4 E6D0            	  5995:                 ror (a0)
02:000037B6 6100FDE0        	  5996:                 bsr ROx_FLAGS
02:000037BA 3010            	  5997:                 move.w (a0),d0
02:000037BC 0C80800163FC    	  5998:                 cmpi.l #$800163FC,d0
02:000037C2 66FE            	  5999:                 bne.s *
02:000037C4 0C850000001B    	  6000:                 cmpi.l #$0000001B,d5
02:000037CA 66FE            	  6001:                 bne.s *
                            	  6002: 
02:000037CC 4E75            	  6003:                 rts
                            	  6004: 
                            	  6005: 
                            	  6006: 
                            	  6007: *-----------------------------------------------------------
                            	  6008: *-----------------------------------------------------------
                            	  6009: * OPCODE : ROXx
                            	  6010: *-----------------------------------------------------------
                            	  6011: *-----------------------------------------------------------
                            	  6012: 
                            	  6013: *     Subroutine to check and accumulate the flags
02:000037CE 40C3            	  6014: ROXx_FLAGS:     move.w sr,d3
02:000037D0 02830000000F    	  6015:                 andi.l #$0F,d3            * Isolate flags
02:000037D6 DA83            	  6016:                 add.l d3,d5               * Copy flag results into accumulator
02:000037D8 4E75            	  6017:                 rts
                            	  6018: 
                            	  6019: op_ROXx:
                            	  6020: 
                            	  6021: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6022: 
                            	  6023: *        BYTE LEFT
02:000037DA 203C80018FF1    	  6024:                 move.l #$80018FF1,d0
02:000037E0 7A00            	  6025:                 moveq  #$00000000,d5
02:000037E2 7C11            	  6026:                 moveq  #$00000011,d6
                            	  6027: ROXx_LOOP1:
02:000037E4 ED30            	  6028:                 roxl.b d6,d0
02:000037E6 61E6            	  6029:                 bsr ROXx_FLAGS
02:000037E8 51CEFFFA        	  6030:                 dbf d6,ROXx_LOOP1
02:000037EC 0C8080018FD0    	  6031:                 cmpi.l #$80018FD0,d0
02:000037F2 66FE            	  6032:                 bne.s *
02:000037F4 0C8500000042    	  6033:                 cmpi.l #$00000042,d5
02:000037FA 66FE            	  6034:                 bne.s *
                            	  6035: 
                            	  6036: *        BYTE RIGHT
02:000037FC 203C80018FF1    	  6037:                 move.l #$80018FF1,d0
02:00003802 7C12            	  6038:                 moveq  #$00000012,d6
                            	  6039: ROXx_LOOP2:
02:00003804 EC30            	  6040:                 roxr.b d6,d0
02:00003806 61C6            	  6041:                 bsr ROXx_FLAGS
02:00003808 51CEFFFA        	  6042:                 dbf d6,ROXx_LOOP2
02:0000380C 0C8080018F51    	  6043:                 cmpi.l #$80018F51,d0
02:00003812 66FE            	  6044:                 bne.s *
02:00003814 0C850000009C    	  6045:                 cmpi.l #$0000009C,d5
02:0000381A 66FE            	  6046:                 bne.s *
                            	  6047: 
                            	  6048: 
                            	  6049: *        WORD LEFT
02:0000381C 203C80018FF1    	  6050:                 move.l #$80018FF1,d0
02:00003822 7C13            	  6051:                 moveq  #$00000013,d6
                            	  6052: ROXx_LOOP3:
02:00003824 ED70            	  6053:                 roxl.w d6,d0
02:00003826 61A6            	  6054:                 bsr ROXx_FLAGS
02:00003828 51CEFFFA        	  6055:                 dbf d6,ROXx_LOOP3
02:0000382C 0C8080013980    	  6056:                 cmpi.l #$80013980,d0
02:00003832 66FE            	  6057:                 bne.s *
02:00003834 0C85000000C9    	  6058:                 cmpi.l #$000000C9,d5
02:0000383A 66FE            	  6059:                 bne.s *
                            	  6060: 
                            	  6061: *        WORD RIGHT
02:0000383C 203C80018FF1    	  6062:                 move.l #$80018FF1,d0
02:00003842 7C1E            	  6063:                 move.l #$0000001E,d6
                            	  6064: ROXx_LOOP4:
02:00003844 EC70            	  6065:                 roxr.w d6,d0
02:00003846 6186            	  6066:                 bsr ROXx_FLAGS
02:00003848 51CEFFFA        	  6067:                 dbf d6,ROXx_LOOP4
02:0000384C 0C8080010A1D    	  6068:                 cmpi.l #$80010A1D,d0
02:00003852 66FE            	  6069:                 bne.s *
02:00003854 0C850000014D    	  6070:                 cmpi.l #$0000014D,d5
02:0000385A 66FE            	  6071:                 bne.s *
                            	  6072: 
                            	  6073: 
                            	  6074: *        LONG LEFT
02:0000385C 203C80018FF1    	  6075:                 move.l #$80018FF1,d0
02:00003862 7C15            	  6076:                 moveq  #$00000015,d6
                            	  6077: ROXx_LOOP5:
02:00003864 EDB0            	  6078:                 roxl.l d6,d0
02:00003866 6100FF66        	  6079:                 bsr ROXx_FLAGS
02:0000386A 51CEFFF8        	  6080:                 dbf d6,ROXx_LOOP5
02:0000386E 0C80800185D0    	  6081:                 cmpi.l #$800185D0,d0
02:00003874 66FE            	  6082:                 bne.s *
02:00003876 0C85000001A1    	  6083:                 cmpi.l #$000001A1,d5
02:0000387C 66FE            	  6084:                 bne.s *
                            	  6085: 
                            	  6086: *        LONG RIGHT
02:0000387E 203C80018FF1    	  6087:                 move.l #$80018FF1,d0
02:00003884 7C16            	  6088:                 moveq  #$00000016,d6
                            	  6089: ROXx_LOOP6:
02:00003886 ECB0            	  6090:                 roxr.l d6,d0
02:00003888 6100FF44        	  6091:                 bsr ROXx_FLAGS
02:0000388C 51CEFFF8        	  6092:                 dbf d6,ROXx_LOOP6
02:00003890 0C80082D8200    	  6093:                 cmpi.l #$082D8200,d0
02:00003896 66FE            	  6094:                 bne.s *
02:00003898 0C85000001DE    	  6095:                 cmpi.l #$000001DE,d5
02:0000389E 66FE            	  6096:                 bne.s *
                            	  6097: 
                            	  6098: 
                            	  6099: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6100: 
02:000038A0 203C80018FF1    	  6101:                 move.l #$80018FF1,d0
02:000038A6 7A00            	  6102:                 moveq  #$00000000,d5
                            	  6103: 
                            	  6104: *        BYTE LEFT
02:000038A8 E310            	  6105:                 roxl.b #1,d0
02:000038AA 6100FF22        	  6106:                 bsr ROXx_FLAGS
02:000038AE EB10            	  6107:                 roxl.b #5,d0
02:000038B0 6100FF1C        	  6108:                 bsr ROXx_FLAGS
02:000038B4 EF10            	  6109:                 roxl.b #7,d0
02:000038B6 6100FF16        	  6110:                 bsr ROXx_FLAGS
02:000038BA E110            	  6111:                 roxl.b #8,d0
02:000038BC 6100FF10        	  6112:                 bsr ROXx_FLAGS
02:000038C0 0C8080018F09    	  6113:                 cmpi.l #$80018F09,d0
02:000038C6 66FE            	  6114:                 bne.s *
02:000038C8 0C850000000B    	  6115:                 cmpi.l #$0000000B,d5
02:000038CE 66FE            	  6116:                 bne.s *
                            	  6117: 
                            	  6118: *        BYTE RIGHT
02:000038D0 E210            	  6119:                 roxr.b #1,d0
02:000038D2 6100FEFA        	  6120:                 bsr ROXx_FLAGS
02:000038D6 EA10            	  6121:                 roxr.b #5,d0
02:000038D8 6100FEF4        	  6122:                 bsr ROXx_FLAGS
02:000038DC EE10            	  6123:                 roxr.b #7,d0
02:000038DE 6100FEEE        	  6124:                 bsr ROXx_FLAGS
02:000038E2 E010            	  6125:                 roxr.b #8,d0
02:000038E4 6100FEE8        	  6126:                 bsr ROXx_FLAGS
02:000038E8 0C8080018F00    	  6127:                 cmpi.l #$80018F00,d0
02:000038EE 66FE            	  6128:                 bne.s *
02:000038F0 0C8500000015    	  6129:                 cmpi.l #$00000015,d5
02:000038F6 66FE            	  6130:                 bne.s *
                            	  6131: 
                            	  6132: *        WORD LEFT
02:000038F8 E350            	  6133:                 roxl.w #1,d0
02:000038FA 6100FED2        	  6134:                 bsr ROXx_FLAGS
02:000038FE EB50            	  6135:                 roxl.w #5,d0
02:00003900 6100FECC        	  6136:                 bsr ROXx_FLAGS
02:00003904 EF50            	  6137:                 roxl.w #7,d0
02:00003906 6100FEC6        	  6138:                 bsr ROXx_FLAGS
02:0000390A E150            	  6139:                 roxl.w #8,d0
02:0000390C 6100FEC0        	  6140:                 bsr ROXx_FLAGS
02:00003910 0C808001B000    	  6141:                 cmpi.l #$8001B000,d0
02:00003916 66FE            	  6142:                 bne.s *
02:00003918 0C8500000027    	  6143:                 cmpi.l #$00000027,d5
02:0000391E 66FE            	  6144:                 bne.s *
                            	  6145: 
                            	  6146: *        WORD RIGHT
02:00003920 E250            	  6147:                 roxr.w #1,d0
02:00003922 6100FEAA        	  6148:                 bsr ROXx_FLAGS
02:00003926 EA50            	  6149:                 roxr.w #5,d0
02:00003928 6100FEA4        	  6150:                 bsr ROXx_FLAGS
02:0000392C EE50            	  6151:                 roxr.w #7,d0
02:0000392E 6100FE9E        	  6152:                 bsr ROXx_FLAGS
02:00003932 E050            	  6153:                 roxr.w #8,d0
02:00003934 6100FE98        	  6154:                 bsr ROXx_FLAGS
02:00003938 0C8080010A00    	  6155:                 cmpi.l #$80010A00,d0
02:0000393E 66FE            	  6156:                 bne.s *
02:00003940 0C8500000028    	  6157:                 cmpi.l #$00000028,d5
02:00003946 66FE            	  6158:                 bne.s *
                            	  6159: 
                            	  6160: *        LONG LEFT
02:00003948 E390            	  6161:                 roxl.l #1,d0
02:0000394A 6100FE82        	  6162:                 bsr ROXx_FLAGS
02:0000394E EB90            	  6163:                 roxl.l #5,d0
02:00003950 6100FE7C        	  6164:                 bsr ROXx_FLAGS
02:00003954 EF90            	  6165:                 roxl.l #7,d0
02:00003956 6100FE76        	  6166:                 bsr ROXx_FLAGS
02:0000395A E190            	  6167:                 roxl.l #8,d0
02:0000395C 6100FE70        	  6168:                 bsr ROXx_FLAGS
02:00003960 0C8040000010    	  6169:                 cmpi.l #$40000010,d0
02:00003966 66FE            	  6170:                 bne.s *
02:00003968 0C850000002A    	  6171:                 cmpi.l #$0000002A,d5
02:0000396E 66FE            	  6172:                 bne.s *
                            	  6173: 
                            	  6174: *        LONG RIGHT
02:00003970 E290            	  6175:                 roxr.l #1,d0
02:00003972 6100FE5A        	  6176:                 bsr ROXx_FLAGS
02:00003976 EA90            	  6177:                 roxr.l #5,d0
02:00003978 6100FE54        	  6178:                 bsr ROXx_FLAGS
02:0000397C EE90            	  6179:                 roxr.l #7,d0
02:0000397E 6100FE4E        	  6180:                 bsr ROXx_FLAGS
02:00003982 E090            	  6181:                 roxr.l #8,d0
02:00003984 6100FE48        	  6182:                 bsr ROXx_FLAGS
02:00003988 0C8000010200    	  6183:                 cmpi.l #$00010200,d0
02:0000398E 66FE            	  6184:                 bne.s *
02:00003990 0C8500000032    	  6185:                 cmpi.l #$00000032,d5
02:00003996 66FE            	  6186:                 bne.s *
                            	  6187: 
                            	  6188: 
                            	  6189: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6190: 
02:00003998 7A00            	  6191:                 moveq  #$00000000,d5
02:0000399A 307C0100        	  6192:                 move.l #$00000100,a0
02:0000399E 30BC8FF1        	  6193:                 move.w #$8FF1,(a0)
                            	  6194: 
                            	  6195: *        WORD LEFT
02:000039A2 E5D0            	  6196:                 roxl (a0)
02:000039A4 6100FE28        	  6197:                 bsr ROXx_FLAGS
02:000039A8 E5D0            	  6198:                 roxl (a0)
02:000039AA 6100FE22        	  6199:                 bsr ROXx_FLAGS
02:000039AE E5D0            	  6200:                 roxl (a0)
02:000039B0 6100FE1C        	  6201:                 bsr ROXx_FLAGS
02:000039B4 E5D0            	  6202:                 roxl (a0)
02:000039B6 6100FE16        	  6203:                 bsr ROXx_FLAGS
02:000039BA 3010            	  6204:                 move.w (a0),d0
02:000039BC 0C800001FF10    	  6205:                 cmpi.l #$0001FF10,d0
02:000039C2 66FE            	  6206:                 bne.s *
02:000039C4 0C8500000009    	  6207:                 cmpi.l #$00000009,d5
02:000039CA 66FE            	  6208:                 bne.s *
                            	  6209: 
                            	  6210: *        WORD RIGHT
02:000039CC E4D0            	  6211:                 roxr (a0)
02:000039CE 6100FDFE        	  6212:                 bsr ROXx_FLAGS
02:000039D2 E4D0            	  6213:                 roxr (a0)
02:000039D4 6100FDF8        	  6214:                 bsr ROXx_FLAGS
02:000039D8 E4D0            	  6215:                 roxr (a0)
02:000039DA 6100FDF2        	  6216:                 bsr ROXx_FLAGS
02:000039DE E4D0            	  6217:                 roxr (a0)
02:000039E0 6100FDEC        	  6218:                 bsr ROXx_FLAGS
02:000039E4 E4D0            	  6219:                 roxr (a0)
02:000039E6 6100FDE6        	  6220:                 bsr ROXx_FLAGS
02:000039EA E4D0            	  6221:                 roxr (a0)
02:000039EC 6100FDE0        	  6222:                 bsr ROXx_FLAGS
02:000039F0 3010            	  6223:                 move.w (a0),d0
02:000039F2 0C80000103FC    	  6224:                 cmpi.l #$000103FC,d0
02:000039F8 66FE            	  6225:                 bne.s *
02:000039FA 0C850000000A    	  6226:                 cmpi.l #$0000000A,d5
02:00003A00 66FE            	  6227:                 bne.s *
                            	  6228: 
02:00003A02 4E75            	  6229:                 rts
                            	  6230: 
                            	  6231: 
                            	  6232: 
                            	  6233: 
                            	  6234: *-----------------------------------------------------------
                            	  6235: *-----------------------------------------------------------
                            	  6236: * OPCODE : SHIFTS
                            	  6237: *-----------------------------------------------------------
                            	  6238: *-----------------------------------------------------------
                            	  6239: 
                            	  6240: *     Subroutine to check and accumulate the flags
02:00003A04 40C3            	  6241: SHIFTS_FLAGS:   move.w sr,d3
02:00003A06 02830000000F    	  6242:                 andi.l #$0F,d3            * Isolate flags
02:00003A0C DA83            	  6243:                 add.l d3,d5               * Copy flag results into accumulator
02:00003A0E 4E75            	  6244:                 rts
                            	  6245: 
                            	  6246: op_SHIFTS:
                            	  6247: 
                            	  6248: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6249: 
                            	  6250: *        BYTE LEFT
02:00003A10 203C80018F81    	  6251:                 move.l #$80018F81,d0
02:00003A16 7A00            	  6252:                 moveq  #$00000000,d5
02:00003A18 7C02            	  6253:                 moveq  #$00000002,d6
                            	  6254: SHIFTS_LOOP1:
02:00003A1A ED20            	  6255:                 asl.b d6,d0
02:00003A1C 61E6            	  6256:                 bsr SHIFTS_FLAGS
02:00003A1E 51CEFFFA        	  6257:                 dbf d6,SHIFTS_LOOP1
02:00003A22 0C8080018F08    	  6258:                 cmpi.l #$80018F08,d0
02:00003A28 66FE            	  6259:                 bne.s *
02:00003A2A 0C8500000002    	  6260:                 cmpi.l #$00000002,d5
02:00003A30 66FE            	  6261:                 bne.s *
                            	  6262: 
                            	  6263: *        BYTE RIGHT
02:00003A32 203C80018F81    	  6264:                 move.l #$80018F81,d0
02:00003A38 7C02            	  6265:                 moveq  #$00000002,d6
                            	  6266: SHIFTS_LOOP2:
02:00003A3A EC20            	  6267:                 asr.b d6,d0
02:00003A3C 61C6            	  6268:                 bsr SHIFTS_FLAGS
02:00003A3E 51CEFFFA        	  6269:                 dbf d6,SHIFTS_LOOP2
02:00003A42 0C8080018FF0    	  6270:                 cmpi.l #$80018FF0,d0
02:00003A48 66FE            	  6271:                 bne.s *
02:00003A4A 0C850000001A    	  6272:                 cmpi.l #$0000001A,d5
02:00003A50 66FE            	  6273:                 bne.s *
                            	  6274: 
                            	  6275: 
                            	  6276: *        WORD LEFT
02:00003A52 203C80018FF1    	  6277:                 move.l #$80018FF1,d0
02:00003A58 7C02            	  6278:                 moveq  #$00000002,d6
                            	  6279: SHIFTS_LOOP3:
02:00003A5A ED60            	  6280:                 asl.w d6,d0
02:00003A5C 61A6            	  6281:                 bsr SHIFTS_FLAGS
02:00003A5E 51CEFFFA        	  6282:                 dbf d6,SHIFTS_LOOP3
02:00003A62 0C8080017F88    	  6283:                 cmpi.l #$80017F88,d0
02:00003A68 66FE            	  6284:                 bne.s *
02:00003A6A 0C850000001C    	  6285:                 cmpi.l #$0000001C,d5
02:00003A70 66FE            	  6286:                 bne.s *
                            	  6287: 
                            	  6288: *        WORD RIGHT
02:00003A72 203C80018FF1    	  6289:                 move.l #$80018FF1,d0
02:00003A78 7C02            	  6290:                 moveq  #$00000002,d6
                            	  6291: SHIFTS_LOOP4:
02:00003A7A EC60            	  6292:                 asr.w d6,d0
02:00003A7C 6186            	  6293:                 bsr SHIFTS_FLAGS
02:00003A7E 51CEFFFA        	  6294:                 dbf d6,SHIFTS_LOOP4
02:00003A82 0C808001F1FE    	  6295:                 cmpi.l #$8001F1FE,d0
02:00003A88 66FE            	  6296:                 bne.s *
02:00003A8A 0C8500000034    	  6297:                 cmpi.l #$00000034,d5
02:00003A90 66FE            	  6298:                 bne.s *
                            	  6299: 
                            	  6300: 
                            	  6301: *        LONG LEFT
02:00003A92 203C80018FF1    	  6302:                 move.l #$80018FF1,d0
02:00003A98 7C02            	  6303:                 moveq  #$00000002,d6
                            	  6304: SHIFTS_LOOP5:
02:00003A9A EDA0            	  6305:                 asl.l d6,d0
02:00003A9C 6100FF66        	  6306:                 bsr SHIFTS_FLAGS
02:00003AA0 51CEFFF8        	  6307:                 dbf d6,SHIFTS_LOOP5
02:00003AA4 0C80000C7F88    	  6308:                 cmpi.l #$000C7F88,d0
02:00003AAA 66FE            	  6309:                 bne.s *
02:00003AAC 0C8500000036    	  6310:                 cmpi.l #$00000036,d5
02:00003AB2 66FE            	  6311:                 bne.s *
                            	  6312: 
                            	  6313: *        LONG RIGHT
02:00003AB4 203C80018FF1    	  6314:                 move.l #$80018FF1,d0
02:00003ABA 7C02            	  6315:                 moveq  #$00000002,d6
                            	  6316: SHIFTS_LOOP6:
02:00003ABC ECA0            	  6317:                 asr.l d6,d0
02:00003ABE 6100FF44        	  6318:                 bsr SHIFTS_FLAGS
02:00003AC2 51CEFFF8        	  6319:                 dbf d6,SHIFTS_LOOP6
02:00003AC6 0C80F00031FE    	  6320:                 cmpi.l #$F00031FE,d0
02:00003ACC 66FE            	  6321:                 bne.s *
02:00003ACE 0C850000004E    	  6322:                 cmpi.l #$0000004E,d5
02:00003AD4 66FE            	  6323:                 bne.s *
                            	  6324: 
                            	  6325: 
                            	  6326: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6327: 
02:00003AD6 203C80018FF1    	  6328:                 move.l #$80018FF1,d0
02:00003ADC 7A00            	  6329:                 moveq  #$00000000,d5
                            	  6330: 
                            	  6331: *        BYTE LEFT
02:00003ADE D000            	  6332:                 asl.b #1,d0
02:00003AE0 6100FF22        	  6333:                 bsr SHIFTS_FLAGS
02:00003AE4 E500            	  6334:                 asl.b #2,d0
02:00003AE6 6100FF1C        	  6335:                 bsr SHIFTS_FLAGS
02:00003AEA D000            	  6336:                 asl.b #1,d0
02:00003AEC 6100FF16        	  6337:                 bsr SHIFTS_FLAGS
02:00003AF0 E700            	  6338:                 asl.b #3,d0
02:00003AF2 6100FF10        	  6339:                 bsr SHIFTS_FLAGS
02:00003AF6 0C8080018F80    	  6340:                 cmpi.l #$80018F80,d0
02:00003AFC 66FE            	  6341:                 bne.s *
02:00003AFE 0C850000001F    	  6342:                 cmpi.l #$0000001F,d5
02:00003B04 66FE            	  6343:                 bne.s *
                            	  6344: 
                            	  6345: *        BYTE RIGHT
02:00003B06 E200            	  6346:                 asr.b #1,d0
02:00003B08 6100FEFA        	  6347:                 bsr SHIFTS_FLAGS
02:00003B0C E400            	  6348:                 asr.b #2,d0
02:00003B0E 6100FEF4        	  6349:                 bsr SHIFTS_FLAGS
02:00003B12 E600            	  6350:                 asr.b #3,d0
02:00003B14 6100FEEE        	  6351:                 bsr SHIFTS_FLAGS
02:00003B18 E200            	  6352:                 asr.b #1,d0
02:00003B1A 6100FEE8        	  6353:                 bsr SHIFTS_FLAGS
02:00003B1E 0C8080018FFF    	  6354:                 cmpi.l #$80018FFF,d0
02:00003B24 66FE            	  6355:                 bne.s *
02:00003B26 0C850000003F    	  6356:                 cmpi.l #$0000003F,d5
02:00003B2C 66FE            	  6357:                 bne.s *
                            	  6358: 
                            	  6359: *        WORD LEFT
02:00003B2E D040            	  6360:                 asl.w #1,d0
02:00003B30 6100FED2        	  6361:                 bsr SHIFTS_FLAGS
02:00003B34 E540            	  6362:                 asl.w #2,d0
02:00003B36 6100FECC        	  6363:                 bsr SHIFTS_FLAGS
02:00003B3A E740            	  6364:                 asl.w #3,d0
02:00003B3C 6100FEC6        	  6365:                 bsr SHIFTS_FLAGS
02:00003B40 EB40            	  6366:                 asl.w #5,d0
02:00003B42 6100FEC0        	  6367:                 bsr SHIFTS_FLAGS
02:00003B46 0C808001F800    	  6368:                 cmpi.l #$8001F800,d0
02:00003B4C 66FE            	  6369:                 bne.s *
02:00003B4E 0C8500000056    	  6370:                 cmpi.l #$00000056,d5
02:00003B54 66FE            	  6371:                 bne.s *
                            	  6372: 
                            	  6373: *        WORD RIGHT
02:00003B56 EA40            	  6374:                 asr.w #5,d0
02:00003B58 6100FEAA        	  6375:                 bsr SHIFTS_FLAGS
02:00003B5C E240            	  6376:                 asr.w #1,d0
02:00003B5E 6100FEA4        	  6377:                 bsr SHIFTS_FLAGS
02:00003B62 E440            	  6378:                 asr.w #2,d0
02:00003B64 6100FE9E        	  6379:                 bsr SHIFTS_FLAGS
02:00003B68 E840            	  6380:                 asr.w #4,d0
02:00003B6A 6100FE98        	  6381:                 bsr SHIFTS_FLAGS
02:00003B6E 0C808001FFFF    	  6382:                 cmpi.l #$8001FFFF,d0
02:00003B74 66FE            	  6383:                 bne.s *
02:00003B76 0C8500000077    	  6384:                 cmpi.l #$00000077,d5
02:00003B7C 66FE            	  6385:                 bne.s *
                            	  6386: 
                            	  6387: *        LONG LEFT
02:00003B7E 203C80018FF1    	  6388:                 move.l #$80018FF1,d0
02:00003B84 D080            	  6389:                 asl.l #1,d0
02:00003B86 6100FE7C        	  6390:                 bsr SHIFTS_FLAGS
02:00003B8A E580            	  6391:                 asl.l #2,d0
02:00003B8C 6100FE76        	  6392:                 bsr SHIFTS_FLAGS
02:00003B90 EF80            	  6393:                 asl.l #7,d0
02:00003B92 6100FE70        	  6394:                 bsr SHIFTS_FLAGS
02:00003B96 E980            	  6395:                 asl.l #4,d0
02:00003B98 6100FE6A        	  6396:                 bsr SHIFTS_FLAGS
02:00003B9C 0C8063FC4000    	  6397:                 cmpi.l #$63FC4000,d0
02:00003BA2 66FE            	  6398:                 bne.s *
02:00003BA4 0C850000007A    	  6399:                 cmpi.l #$0000007A,d5
02:00003BAA 66FE            	  6400:                 bne.s *
                            	  6401: 
                            	  6402: *        LONG RIGHT
02:00003BAC 203C80018FF1    	  6403:                 move.l #$80018FF1,d0
02:00003BB2 E280            	  6404:                 asr.l #1,d0
02:00003BB4 6100FE4E        	  6405:                 bsr SHIFTS_FLAGS
02:00003BB8 EA80            	  6406:                 asr.l #5,d0
02:00003BBA 6100FE48        	  6407:                 bsr SHIFTS_FLAGS
02:00003BBE EE80            	  6408:                 asr.l #7,d0
02:00003BC0 6100FE42        	  6409:                 bsr SHIFTS_FLAGS
02:00003BC4 E080            	  6410:                 asr.l #8,d0
02:00003BC6 6100FE3C        	  6411:                 bsr SHIFTS_FLAGS
02:00003BCA 0C80FFFFFC00    	  6412:                 cmpi.l #$FFFFFC00,d0
02:00003BD0 66FE            	  6413:                 bne.s *
02:00003BD2 0C850000009C    	  6414:                 cmpi.l #$0000009C,d5
02:00003BD8 66FE            	  6415:                 bne.s *
                            	  6416: 
                            	  6417: 
                            	  6418: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6419: 
02:00003BDA 7A00            	  6420:                 moveq  #$00000000,d5
02:00003BDC 307C0100        	  6421:                 move.l #$00000100,a0
02:00003BE0 30BC8FF1        	  6422:                 move.w #$8FF1,(a0)
                            	  6423: 
                            	  6424: *        WORD LEFT
02:00003BE4 E1D0            	  6425:                 asl  (a0)
02:00003BE6 6100FE1C        	  6426:                 bsr SHIFTS_FLAGS
02:00003BEA E1D0            	  6427:                 asl  (a0)
02:00003BEC 6100FE16        	  6428:                 bsr SHIFTS_FLAGS
02:00003BF0 E1D0            	  6429:                 asl  (a0)
02:00003BF2 6100FE10        	  6430:                 bsr SHIFTS_FLAGS
02:00003BF6 E1D0            	  6431:                 asl  (a0)
02:00003BF8 6100FE0A        	  6432:                 bsr SHIFTS_FLAGS
02:00003BFC 3010            	  6433:                 move.w (a0),d0
02:00003BFE 0C80FFFFFF10    	  6434:                 cmpi.l #$FFFFFF10,d0
02:00003C04 66FE            	  6435:                 bne.s *
02:00003C06 0C850000000D    	  6436:                 cmpi.l #$0000000D,d5
02:00003C0C 66FE            	  6437:                 bne.s *
                            	  6438: 
                            	  6439: *        WORD RIGHT
02:00003C0E E0D0            	  6440:                 asr (a0)
02:00003C10 6100FDF2        	  6441:                 bsr SHIFTS_FLAGS
02:00003C14 E0D0            	  6442:                 asr (a0)
02:00003C16 6100FDEC        	  6443:                 bsr SHIFTS_FLAGS
02:00003C1A E0D0            	  6444:                 asr (a0)
02:00003C1C 6100FDE6        	  6445:                 bsr SHIFTS_FLAGS
02:00003C20 E0D0            	  6446:                 asr (a0)
02:00003C22 6100FDE0        	  6447:                 bsr SHIFTS_FLAGS
02:00003C26 E0D0            	  6448:                 asr (a0)
02:00003C28 6100FDDA        	  6449:                 bsr SHIFTS_FLAGS
02:00003C2C E0D0            	  6450:                 asr (a0)
02:00003C2E 6100FDD4        	  6451:                 bsr SHIFTS_FLAGS
02:00003C32 3010            	  6452:                 move.w (a0),d0
02:00003C34 0C80FFFFFFFC    	  6453:                 cmpi.l #$FFFFFFFC,d0
02:00003C3A 66FE            	  6454:                 bne.s *
02:00003C3C 0C850000003E    	  6455:                 cmpi.l #$0000003E,d5
02:00003C42 66FE            	  6456:                 bne.s *
                            	  6457: 
02:00003C44 4E75            	  6458:                 rts
                            	  6459: 
                            	  6460: 
                            	  6461: 
                            	  6462: *-----------------------------------------------------------
                            	  6463: *-----------------------------------------------------------
                            	  6464: * OPCODE : SHIFTS2
                            	  6465: *-----------------------------------------------------------
                            	  6466: *-----------------------------------------------------------
                            	  6467: 
                            	  6468: *     Subroutine to check and accumulate the flags
02:00003C46 40C3            	  6469: SHIFTS2_FLAGS:  move.w sr,d3
02:00003C48 02830000000F    	  6470:                 andi.l #$0F,d3            * Isolate flags
02:00003C4E DA83            	  6471:                 add.l d3,d5               * Copy flag results into accumulator
02:00003C50 4E75            	  6472:                 rts
                            	  6473: 
                            	  6474: op_SHIFTS2:
                            	  6475: 
                            	  6476: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6477: 
                            	  6478: *        BYTE LEFT
02:00003C52 203C80018F81    	  6479:                 move.l #$80018F81,d0
02:00003C58 7A00            	  6480:                 moveq  #$00000000,d5
02:00003C5A 7C02            	  6481:                 moveq  #$00000002,d6
                            	  6482: SHIFTS2_LOOP1:
02:00003C5C ED28            	  6483:                 lsl.b d6,d0
02:00003C5E 61E6            	  6484:                 bsr SHIFTS2_FLAGS
02:00003C60 51CEFFFA        	  6485:                 dbf d6,SHIFTS2_LOOP1
02:00003C64 0C8080018F08    	  6486:                 cmpi.l #$80018F08,d0
02:00003C6A 66FE            	  6487:                 bne.s *
02:00003C6C 4A85            	  6488:                 cmpi.l #$00000000,d5
02:00003C6E 66FE            	  6489:                 bne.s *
                            	  6490: 
                            	  6491: *        BYTE RIGHT
02:00003C70 203C80018F81    	  6492:                 move.l #$80018F81,d0
02:00003C76 7C02            	  6493:                 moveq  #$00000002,d6
                            	  6494: SHIFTS2_LOOP2:
02:00003C78 EC28            	  6495:                 lsr.b d6,d0
02:00003C7A 61CA            	  6496:                 bsr SHIFTS2_FLAGS
02:00003C7C 51CEFFFA        	  6497:                 dbf d6,SHIFTS2_LOOP2
02:00003C80 0C8080018F10    	  6498:                 cmpi.l #$80018F10,d0
02:00003C86 66FE            	  6499:                 bne.s *
02:00003C88 4A85            	  6500:                 cmpi.l #$00000000,d5
02:00003C8A 66FE            	  6501:                 bne.s *
                            	  6502: 
                            	  6503: 
                            	  6504: *        WORD LEFT
02:00003C8C 203C80018FF1    	  6505:                 move.l #$80018FF1,d0
02:00003C92 7C02            	  6506:                 moveq  #$00000002,d6
                            	  6507: SHIFTS2_LOOP3:
02:00003C94 ED68            	  6508:                 lsl.w d6,d0
02:00003C96 61AE            	  6509:                 bsr SHIFTS2_FLAGS
02:00003C98 51CEFFFA        	  6510:                 dbf d6,SHIFTS2_LOOP3
02:00003C9C 0C8080017F88    	  6511:                 cmpi.l #$80017F88,d0
02:00003CA2 66FE            	  6512:                 bne.s *
02:00003CA4 4A85            	  6513:                 cmpi.l #$00000000,d5
02:00003CA6 66FE            	  6514:                 bne.s *
                            	  6515: 
                            	  6516: *        WORD RIGHT
02:00003CA8 203C80018FF1    	  6517:                 move.l #$80018FF1,d0
02:00003CAE 7C02            	  6518:                 moveq  #$00000002,d6
                            	  6519: SHIFTS2_LOOP4:
02:00003CB0 EC68            	  6520:                 lsr.w d6,d0
02:00003CB2 6192            	  6521:                 bsr SHIFTS2_FLAGS
02:00003CB4 51CEFFFA        	  6522:                 dbf d6,SHIFTS2_LOOP4
02:00003CB8 0C80800111FE    	  6523:                 cmpi.l #$800111FE,d0
02:00003CBE 66FE            	  6524:                 bne.s *
02:00003CC0 4A85            	  6525:                 cmpi.l #$00000000,d5
02:00003CC2 66FE            	  6526:                 bne.s *
                            	  6527: 
                            	  6528: 
                            	  6529: *        LONG LEFT
02:00003CC4 203C80018FF1    	  6530:                 move.l #$80018FF1,d0
02:00003CCA 7C02            	  6531:                 moveq  #$00000002,d6
                            	  6532: SHIFTS2_LOOP5:
02:00003CCC EDA8            	  6533:                 lsl.l d6,d0
02:00003CCE 6100FF76        	  6534:                 bsr SHIFTS2_FLAGS
02:00003CD2 51CEFFF8        	  6535:                 dbf d6,SHIFTS2_LOOP5
02:00003CD6 0C80000C7F88    	  6536:                 cmpi.l #$000C7F88,d0
02:00003CDC 66FE            	  6537:                 bne.s *
02:00003CDE 4A85            	  6538:                 cmpi.l #$00000000,d5
02:00003CE0 66FE            	  6539:                 bne.s *
                            	  6540: 
                            	  6541: *        LONG RIGHT
02:00003CE2 203C80018FF1    	  6542:                 move.l #$80018FF1,d0
02:00003CE8 7C02            	  6543:                 moveq  #$00000002,d6
                            	  6544: SHIFTS2_LOOP6:
02:00003CEA ECA8            	  6545:                 lsr.l d6,d0
02:00003CEC 6100FF58        	  6546:                 bsr SHIFTS2_FLAGS
02:00003CF0 51CEFFF8        	  6547:                 dbf d6,SHIFTS2_LOOP6
02:00003CF4 0C80100031FE    	  6548:                 cmpi.l #$100031FE,d0
02:00003CFA 66FE            	  6549:                 bne.s *
02:00003CFC 4A85            	  6550:                 cmpi.l #$00000000,d5
02:00003CFE 66FE            	  6551:                 bne.s *
                            	  6552: 
                            	  6553: 
                            	  6554: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6555: 
02:00003D00 203C80018FF1    	  6556:                 move.l #$80018FF1,d0
02:00003D06 7A00            	  6557:                 moveq  #$00000000,d5
                            	  6558: 
                            	  6559: *        BYTE LEFT
02:00003D08 E308            	  6560:                 lsl.b #1,d0
02:00003D0A 6100FF3A        	  6561:                 bsr SHIFTS2_FLAGS
02:00003D0E E508            	  6562:                 lsl.b #2,d0
02:00003D10 6100FF34        	  6563:                 bsr SHIFTS2_FLAGS
02:00003D14 E308            	  6564:                 lsl.b #1,d0
02:00003D16 6100FF2E        	  6565:                 bsr SHIFTS2_FLAGS
02:00003D1A E708            	  6566:                 lsl.b #3,d0
02:00003D1C 6100FF28        	  6567:                 bsr SHIFTS2_FLAGS
02:00003D20 0C8080018F80    	  6568:                 cmpi.l #$80018F80,d0
02:00003D26 66FE            	  6569:                 bne.s *
02:00003D28 0C850000001B    	  6570:                 cmpi.l #$0000001B,d5
02:00003D2E 66FE            	  6571:                 bne.s *
                            	  6572: 
                            	  6573: *        BYTE RIGHT
02:00003D30 E208            	  6574:                 lsr.b #1,d0
02:00003D32 6100FF12        	  6575:                 bsr SHIFTS2_FLAGS
02:00003D36 E408            	  6576:                 lsr.b #2,d0
02:00003D38 6100FF0C        	  6577:                 bsr SHIFTS2_FLAGS
02:00003D3C E608            	  6578:                 lsr.b #3,d0
02:00003D3E 6100FF06        	  6579:                 bsr SHIFTS2_FLAGS
02:00003D42 E208            	  6580:                 lsr.b #1,d0
02:00003D44 6100FF00        	  6581:                 bsr SHIFTS2_FLAGS
02:00003D48 0C8080018F01    	  6582:                 cmpi.l #$80018F01,d0
02:00003D4E 66FE            	  6583:                 bne.s *
02:00003D50 0C850000001B    	  6584:                 cmpi.l #$0000001B,d5
02:00003D56 66FE            	  6585:                 bne.s *
                            	  6586: 
                            	  6587: *        WORD LEFT
02:00003D58 E348            	  6588:                 lsl.w #1,d0
02:00003D5A 6100FEEA        	  6589:                 bsr SHIFTS2_FLAGS
02:00003D5E E548            	  6590:                 lsl.w #2,d0
02:00003D60 6100FEE4        	  6591:                 bsr SHIFTS2_FLAGS
02:00003D64 E748            	  6592:                 lsl.w #3,d0
02:00003D66 6100FEDE        	  6593:                 bsr SHIFTS2_FLAGS
02:00003D6A EB48            	  6594:                 lsl.w #5,d0
02:00003D6C 6100FED8        	  6595:                 bsr SHIFTS2_FLAGS
02:00003D70 0C8080010800    	  6596:                 cmpi.l #$80010800,d0
02:00003D76 66FE            	  6597:                 bne.s *
02:00003D78 0C8500000025    	  6598:                 cmpi.l #$00000025,d5
02:00003D7E 66FE            	  6599:                 bne.s *
                            	  6600: 
                            	  6601: *        WORD RIGHT
02:00003D80 EA48            	  6602:                 lsr.w #5,d0
02:00003D82 6100FEC2        	  6603:                 bsr SHIFTS2_FLAGS
02:00003D86 E248            	  6604:                 lsr.w #1,d0
02:00003D88 6100FEBC        	  6605:                 bsr SHIFTS2_FLAGS
02:00003D8C E448            	  6606:                 lsr.w #2,d0
02:00003D8E 6100FEB6        	  6607:                 bsr SHIFTS2_FLAGS
02:00003D92 E848            	  6608:                 lsr.w #4,d0
02:00003D94 6100FEB0        	  6609:                 bsr SHIFTS2_FLAGS
02:00003D98 0C8080010000    	  6610:                 cmpi.l #$80010000,d0
02:00003D9E 66FE            	  6611:                 bne.s *
02:00003DA0 0C850000002A    	  6612:                 cmpi.l #$0000002A,d5
02:00003DA6 66FE            	  6613:                 bne.s *
                            	  6614: 
                            	  6615: *        LONG LEFT
02:00003DA8 203C80018FF1    	  6616:                 move.l #$80018FF1,d0
02:00003DAE E388            	  6617:                 lsl.l #1,d0
02:00003DB0 6100FE94        	  6618:                 bsr SHIFTS2_FLAGS
02:00003DB4 E588            	  6619:                 lsl.l #2,d0
02:00003DB6 6100FE8E        	  6620:                 bsr SHIFTS2_FLAGS
02:00003DBA EF88            	  6621:                 lsl.l #7,d0
02:00003DBC 6100FE88        	  6622:                 bsr SHIFTS2_FLAGS
02:00003DC0 E988            	  6623:                 lsl.l #4,d0
02:00003DC2 6100FE82        	  6624:                 bsr SHIFTS2_FLAGS
02:00003DC6 0C8063FC4000    	  6625:                 cmpi.l #$63FC4000,d0
02:00003DCC 66FE            	  6626:                 bne.s *
02:00003DCE 0C850000002B    	  6627:                 cmpi.l #$0000002B,d5
02:00003DD4 66FE            	  6628:                 bne.s *
                            	  6629: 
                            	  6630: *        LONG RIGHT
02:00003DD6 203C80018FF1    	  6631:                 move.l #$80018FF1,d0
02:00003DDC E288            	  6632:                 lsr.l #1,d0
02:00003DDE 6100FE66        	  6633:                 bsr SHIFTS2_FLAGS
02:00003DE2 EA88            	  6634:                 lsr.l #5,d0
02:00003DE4 6100FE60        	  6635:                 bsr SHIFTS2_FLAGS
02:00003DE8 EE88            	  6636:                 lsr.l #7,d0
02:00003DEA 6100FE5A        	  6637:                 bsr SHIFTS2_FLAGS
02:00003DEE E088            	  6638:                 lsr.l #8,d0
02:00003DF0 6100FE54        	  6639:                 bsr SHIFTS2_FLAGS
02:00003DF4 0C8000000400    	  6640:                 cmpi.l #$00000400,d0
02:00003DFA 66FE            	  6641:                 bne.s *
02:00003DFC 0C850000002D    	  6642:                 cmpi.l #$0000002D,d5
02:00003E02 66FE            	  6643:                 bne.s *
                            	  6644: 
                            	  6645: 
                            	  6646: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6647: 
02:00003E04 7A00            	  6648:                 moveq  #$00000000,d5
02:00003E06 307C0100        	  6649:                 move.l #$00000100,a0
02:00003E0A 30BC8FF1        	  6650:                 move.w #$8FF1,(a0)
                            	  6651: 
                            	  6652: *        WORD LEFT
02:00003E0E E3D0            	  6653:                 lsl  (a0)
02:00003E10 6100FE34        	  6654:                 bsr SHIFTS2_FLAGS
02:00003E14 E3D0            	  6655:                 lsl  (a0)
02:00003E16 6100FE2E        	  6656:                 bsr SHIFTS2_FLAGS
02:00003E1A E3D0            	  6657:                 lsl  (a0)
02:00003E1C 6100FE28        	  6658:                 bsr SHIFTS2_FLAGS
02:00003E20 E3D0            	  6659:                 lsl  (a0)
02:00003E22 6100FE22        	  6660:                 bsr SHIFTS2_FLAGS
02:00003E26 3010            	  6661:                 move.w (a0),d0
02:00003E28 0C800000FF10    	  6662:                 cmpi.l #$0000FF10,d0
02:00003E2E 66FE            	  6663:                 bne.s *
02:00003E30 0C8500000009    	  6664:                 cmpi.l #$00000009,d5
02:00003E36 66FE            	  6665:                 bne.s *
                            	  6666: 
                            	  6667: *        WORD RIGHT
02:00003E38 E2D0            	  6668:                 lsr (a0)
02:00003E3A 6100FE0A        	  6669:                 bsr SHIFTS2_FLAGS
02:00003E3E E2D0            	  6670:                 lsr (a0)
02:00003E40 6100FE04        	  6671:                 bsr SHIFTS2_FLAGS
02:00003E44 E2D0            	  6672:                 lsr (a0)
02:00003E46 6100FDFE        	  6673:                 bsr SHIFTS2_FLAGS
02:00003E4A E2D0            	  6674:                 lsr (a0)
02:00003E4C 6100FDF8        	  6675:                 bsr SHIFTS2_FLAGS
02:00003E50 E2D0            	  6676:                 lsr (a0)
02:00003E52 6100FDF2        	  6677:                 bsr SHIFTS2_FLAGS
02:00003E56 E2D0            	  6678:                 lsr (a0)
02:00003E58 6100FDEC        	  6679:                 bsr SHIFTS2_FLAGS
02:00003E5C 3010            	  6680:                 move.w (a0),d0
02:00003E5E 0C80000003FC    	  6681:                 cmpi.l #$000003FC,d0
02:00003E64 66FE            	  6682:                 bne.s *
02:00003E66 0C850000000A    	  6683:                 cmpi.l #$0000000A,d5
02:00003E6C 66FE            	  6684:                 bne.s *
                            	  6685: 
02:00003E6E 4E75            	  6686:                 rts
                            	  6687: 
                            	  6688: ;-----------------------------------------------------------
                            	  6689: ;-----------------------------------------------------------
                            	  6690: ; OPCODE : BSR / RTS
                            	  6691: ;-----------------------------------------------------------
                            	  6692: ;-----------------------------------------------------------
                            	  6693: 
                            	  6694: ;t3_bsr:
                            	  6695: ;	moveq	#3,d3
                            	  6696: ;	rts
                            	  6697: 
                            	  6698: ;t1_bsr:
                            	  6699: ;	moveq	#1,d1
                            	  6700: ;	rts
                            	  6701: 
                            	  6702: ;op_bsr:
                            	  6703: ;	bsr			t1_bsr
                            	  6704: ;	bsr			t2_bsr
                            	  6705: ;	bsr.w		t3_bsr
                            	  6706: ;	bsr.w		t4_bsr
                            	  6707: ;	cmpi.l	#1,d1
                            	  6708: ;	bne			*
                            	  6709: ;	cmpi.l	#2,d2
                            	  6710: ;	bne			*
                            	  6711: ;	cmpi.l	#3,d3
                            	  6712: ;	bne			*
                            	  6713: ;	cmpi.l	#4,d4
                            	  6714: ;	bne			*
                            	  6715: ;	rts
                            	  6716: 
                            	  6717: ;t2_bsr:
                            	  6718: ;	moveq	#2,d2
                            	  6719: ;	rts
                            	  6720: 	
                            	  6721: ;t4_bsr:
                            	  6722: ;	moveq	#4,d4
                            	  6723: ;	rts
                            	  6724: *    END
                            	  6725:     
                            	  6726: 

Source: "boot.x68"
                            	   888: 	include "TinyBasicFlt.x68"

Source: "TinyBasicFlt.x68"
                            	     1: ******************************************************************
                            	     2: *								 *
                            	     3: *		Tiny Float BASIC for the Motorola MC68000		 *
                            	     4: *								 *
                            	     5: * Derived from Palo Alto Tiny BASIC as published in the May 1976 *
                            	     6: * issue of Dr. Dobb's Journal.  Adapted to the 68000 by:         *
                            	     7: *	Gordon Brandly						 *
                            	     8: *								 *
                            	     9: ******************************************************************
                            	    10: *    Copyright (C) 1984 by Gordon Brandly. This program may be	 *
                            	    11: *    freely distributed for personal use only. All commercial	 *
                            	    12: *		       rights are reserved.			 *
                            	    13: ******************************************************************
                            	    14: * Modified (c) 2022 for the rf68000. Robert Finch
                            	    15: * Numerics changed to floating-point
                            	    16: * added string handling
                            	    17: ******************************************************************
                            	    18: 
                            	    19: * Vers. 1.0  1984/7/17	- Original version by Gordon Brandly
                            	    20: *	1.1  1984/12/9	- Addition of '$' print term by Marvin Lipford
                            	    21: *	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                            	    22: 
                            	    23: *	OPT	FRS,BRS 	forward ref.'s & branches default to short
                            	    24: 
                            	    25: ;CR	EQU	$0D		ASCII equates
                            	    26: ;LF	EQU	$0A
                            	    27: ;TAB	EQU	$09
                            	    28: ;CTRLC	EQU	$03
                            	    29: ;CTRLH	EQU	$08
                            	    30: ;CTRLS	EQU	$13
                            	    31: ;CTRLX	EQU	$18
                            	    32: 
                            	    33: DT_NONE equ 0
                            	    34: DT_NUMERIC equ 1
                            	    35: DT_STRING equ 2		; string descriptor
                            	    36: DT_TEXTPTR equ 3	; pointer into program text
                            	    37: 
                            	    38: BUFLEN	EQU	80		length of keyboard input buffer
                            	    39: STRAREASIZE	EQU	2048	; size of string area
                            	    40: 	CODE
                            	    41: *	ORG	$10000		first free address using Tutor
                            	    42: *
                            	    43: * Standard jump table. You can change these addresses if you are
                            	    44: * customizing this interpreter for a different environment.
                            	    45: *
02:00003E70 6020            	    46: START	BRA	CSTART		Cold Start entry point
02:00003E72 60000088        	    47: GOWARM	BRA	WSTART		Warm Start entry point
02:00003E76 60001460        	    48: GOOUT	BRA OUTC		Jump to character-out routine
02:00003E7A 6000146C        	    49: GOIN	BRA INC		Jump to character-in routine
02:00003E7E 60001488        	    50: GOAUXO	BRA	AUXOUT		Jump to auxiliary-out routine
02:00003E82 60001498        	    51: GOAUXI	BRA	AUXIN		Jump to auxiliary-in routine
02:00003E86 600014B4        	    52: GOBYE	BRA	BYEBYE		Jump to monitor, DOS, etc.
                            	    53: *
                            	    54: * Modifiable system constants:
                            	    55: *
02:00003E8A 00041000        	    56: TXTBGN	DC.L	$41000		beginning of program memory
02:00003E8E 00047FF0        	    57: ENDMEM	DC.L	$47FF0		end of available memory
                            	    58: *
                            	    59: * The main interpreter starts here:
                            	    60: *
                            	    61: CSTART
02:00003E92 2E7AFFFA        	    62: 	MOVE.L ENDMEM,SP	initialize stack pointer
02:00003E96 23FC000052F40000	    63: 	move.l #INC1,INPPTR
02:00003E9E 53AC
02:00003EA0 4239000400A4    	    64: 	move.b #0,InputDevice
02:00003EA6 13FC0001000400A8	    65: 	move.b #1,OutputDevice
02:00003EAE 23FC000000010004	    66: 	move.l #1,_fpTextIncr
02:00003EB6 0094
02:00003EB8 4DFA1490        	    67: 	LEA	INITMSG,A6	tell who we are
02:00003EBC 61001402        	    68: 	BSR	PRMESG
02:00003EC0 23FAFFC8000053FC	    69: 	MOVE.L TXTBGN,TXTUNF	init. end-of-program pointer
02:00003EC8 203AFFC4        	    70: 	MOVE.L ENDMEM,D0	get address of end of memory
02:00003ECC 23FAFFC0000053B8	    71: 	move.l ENDMEM,STKFP
02:00003ED4 90BC00001000    	    72: 	SUB.L	#4096,D0	reserve 4K for the stack
02:00003EDA 23C0000053EC    	    73: 	MOVE.L D0,STRSTK
02:00003EE0 D0BC00000020    	    74: 	ADD.L #32,D0
02:00003EE6 23C000005404    	    75: 	MOVE.L D0,STKLMT
02:00003EEC 90BC00000200    	    76: 	SUB.L	#512,D0 	reserve variable area (32 16 byte floats)
02:00003EF2 23C000005400    	    77: 	MOVE.L D0,VARBGN
02:00003EF8 610000C2        	    78: 	bsr ClearStringArea
                            	    79: WSTART
02:00003EFC 7000            	    80: 	CLR.L	D0		initialize internal variables
02:00003EFE 23FC000000010004	    81: 	move.l #1,_fpTextIncr
02:00003F06 0094
02:00003F08 42B9000053E8    	    82: 	clr.l IRQROUT
02:00003F0E 23C0000053C4    	    83: 	MOVE.L	D0,LOPVAR
02:00003F14 23C0000053BC    	    84: 	MOVE.L	D0,STKGOS
02:00003F1A 23C0000053B4    	    85: 	MOVE.L	D0,CURRNT	; current line number pointer = 0
02:00003F20 2E7AFF6C        	    86: 	MOVE.L ENDMEM,SP	; init S.P. again, just in case
02:00003F24 610000B6        	    87: 	bsr ClearStringStack
02:00003F28 4DFA1444        	    88: 	LEA	OKMSG,A6			; display "OK"
02:00003F2C 61001392        	    89: 	bsr	PRMESG
                            	    90: ST3
02:00003F30 103C003E        	    91: 	MOVE.B	#'>',D0         Prompt with a '>' and
02:00003F34 610010CE        	    92: 	bsr	GETLN		read a line.
02:00003F38 6100132A        	    93: 	bsr	TOUPBUF 	convert to upper case
02:00003F3C 2848            	    94: 	MOVE.L	A0,A4		save pointer to end of line
02:00003F3E 41FA14CC        	    95: 	LEA	BUFFER,A0	point to the beginning of line
02:00003F42 610012CA        	    96: 	bsr	TSTNUM		is there a number there?
02:00003F46 61001312        	    97: 	bsr	IGNBLK		skip trailing blanks
02:00003F4A F2016080        	    98: 	FMOVE.L FP1,D1
02:00003F4E 4A82            	    99: 	TST.L D2			; does line no. exist? (or nonzero?)
02:00003F50 67000246        	   100: 	BEQ	DIRECT		; if not, it's a direct statement
02:00003F54 B2BC0000FFFF    	   101: 	CMP.L	#$FFFF,D1	see if line no. is <= 16 bits
02:00003F5A 6400109A        	   102: 	BCC	QHOW		if not, we've overflowed
02:00003F5E 1101            	   103: 	MOVE.B	D1,-(A0)	store the binary line no.
02:00003F60 E059            	   104: 	ROR	#8,D1		(Kludge to store a word on a
02:00003F62 1101            	   105: 	MOVE.B	D1,-(A0)	possible byte boundary)
02:00003F64 E159            	   106: 	ROL	#8,D1
02:00003F66 6100113A        	   107: 	bsr	FNDLN		find this line in save area
02:00003F6A 2A49            	   108: 	MOVE.L	A1,A5		save possible line pointer
02:00003F6C 6614            	   109: 	BNE	ST4		if not found, insert
02:00003F6E 61001158        	   110: 	bsr	FNDNXT		find the next line (into A1)
02:00003F72 244D            	   111: 	MOVE.L	A5,A2		pointer to line to be deleted
02:00003F74 267A1486        	   112: 	MOVE.L	TXTUNF,A3	points to top of save area
02:00003F78 6100115E        	   113: 	bsr	MVUP		move up to delete
02:00003F7C 23CA000053FC    	   114: 	MOVE.L	A2,TXTUNF	update the end pointer
                            	   115: ST4
02:00003F82 200C            	   116: 	MOVE.L	A4,D0		calculate the length of new line
02:00003F84 9088            	   117: 	SUB.L	A0,D0
02:00003F86 B0BC00000003    	   118: 	CMP.L	#3,D0		is it just a line no. & CR?
02:00003F8C 6FA2            	   119: 	BLE	ST3		if so, it was just a delete
02:00003F8E 267A146C        	   120: 	MOVE.L TXTUNF,A3	compute new end
02:00003F92 2C4B            	   121: 	MOVE.L A3,A6
02:00003F94 D7C0            	   122: 	ADD.L	D0,A3
02:00003F96 203A145C        	   123: 	MOVE.L StrArea,D0	see if there's enough room
02:00003F9A B08B            	   124: 	CMP.L	A3,D0
02:00003F9C 63001050        	   125: 	BLS	QSORRY		if not, say so
02:00003FA0 23CB000053FC    	   126: 	MOVE.L	A3,TXTUNF	if so, store new end position
02:00003FA6 224E            	   127: 	MOVE.L	A6,A1		points to old unfilled area
02:00003FA8 244D            	   128: 	MOVE.L	A5,A2		points to beginning of move area
02:00003FAA 61001140        	   129: 	bsr	MVDOWN		move things out of the way
02:00003FAE 2248            	   130: 	MOVE.L	A0,A1		set up to do the insertion
02:00003FB0 244D            	   131: 	MOVE.L	A5,A2
02:00003FB2 264C            	   132: 	MOVE.L	A4,A3
02:00003FB4 61001122        	   133: 	bsr	MVUP		do it
02:00003FB8 6000FF76        	   134: 	BRA	ST3		go back and get another line
                            	   135: 
                            	   136: ClearStringArea:
02:00003FBC 203A1442        	   137: 	move.l VARBGN,d0
02:00003FC0 90BC00000800    	   138: 	SUB.L #STRAREASIZE,D0
02:00003FC6 23C0000053F4    	   139: 	MOVE.L D0,StrArea
02:00003FCC 23C0000053F8    	   140: 	MOVE.L D0,LastStr
02:00003FD2 207A1420        	   141: 	move.l StrArea,a0
02:00003FD6 4298            	   142: 	clr.l (a0)+
02:00003FD8 4298            	   143: 	clr.l (a0)+
02:00003FDA 4E75            	   144: 	rts
                            	   145: 
                            	   146: ClearStringStack:
02:00003FDC 7007            	   147: 	moveq #7,d0
02:00003FDE 227A140C        	   148: 	move.l STRSTK,a1
                            	   149: .0001
02:00003FE2 4299            	   150: 	clr.l (a1)+				; clear the string stack
02:00003FE4 51C8FFFC        	   151: 	dbra d0,.0001
02:00003FE8 23C9000053F0    	   152: 	move.l a1,StrSp		; set string stack stack pointer
02:00003FEE 4E75            	   153: 	rts
                            	   154: 
                            	   155: 	even
                            	   156: 
                            	   157: *******************************************************************
                            	   158: *
                            	   159: * *** Tables *** DIRECT *** EXEC ***
                            	   160: *
                            	   161: * This section of the code tests a string against a table. When
                            	   162: * a match is found, control is transferred to the section of
                            	   163: * code according to the table.
                            	   164: *
                            	   165: * At 'EXEC', A0 should point to the string, A1 should point to
                            	   166: * the character table, and A2 should point to the execution
                            	   167: * table. At 'DIRECT', A0 should point to the string, A1 and
                            	   168: * A2 will be set up to point to TAB1 and TAB1_1, which are
                            	   169: * the tables of all direct and statement commands.
                            	   170: *
                            	   171: * A '.' in the string will terminate the test and the partial
                            	   172: * match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                            	   173: * 'PRIN.', or 'PRINT' will all match 'PRINT'.
                            	   174: *
                            	   175: * There are two tables: the character table and the execution
                            	   176: * table. The character table consists of any number of text items.
                            	   177: * Each item is a string of characters with the last character's
                            	   178: * high bit set to one. The execution table holds a 16-bit
                            	   179: * execution addresses that correspond to each entry in the
                            	   180: * character table.
                            	   181: *
                            	   182: * The end of the character table is a 0 byte which corresponds
                            	   183: * to the default routine in the execution table, which is
                            	   184: * executed if none of the other table items are matched.
                            	   185: *
                            	   186: * Character-matching tables:
                            	   187: TAB1
02:00003FF0 3C434F          	   188: 	DC.B	'<CO',('M'+$80)
02:00003FF3 CD
02:00003FF4 3C434F          	   189: 	DC.B	'<CO',('N'+$80)
02:00003FF7 CE
02:00003FF8 3E434F          	   190: 	DC.B	'>CO',('M'+$80)
02:00003FFB CD
02:00003FFC 3E434F          	   191: 	DC.B	'>CO',('N'+$80)
02:00003FFF CE
02:00004000 3C3E434F        	   192: 	DC.B	'<>CO',('M'+$80)
02:00004004 CD
02:00004005 3C3E434F        	   193: 	DC.B	'<>CO',('N'+$80)
02:00004009 CE
02:0000400A 4C4953          	   194: 	DC.B	'LIS',('T'+$80)         Direct commands
02:0000400D D4
02:0000400E 4C4F41          	   195: 	DC.B	'LOA',('D'+$80)
02:00004011 C4
02:00004012 4E45            	   196: 	DC.B	'NE',('W'+$80)
02:00004014 D7
02:00004015 5255            	   197: 	DC.B	'RU',('N'+$80)
02:00004017 CE
02:00004018 534156          	   198: 	DC.B	'SAV',('E'+$80)
02:0000401B C5
02:0000401C 434C            	   199: 	DC.B 	'CL',('S'+$80)
02:0000401E D3
                            	   200: TAB2
02:0000401F 4E4558          	   201: 	DC.B	'NEX',('T'+$80)         Direct / statement
02:00004022 D4
02:00004023 4C45            	   202: 	DC.B	'LE',('T'+$80)
02:00004025 D4
02:00004026 49              	   203: 	DC.B	'I',('F'+$80)
02:00004027 C6
02:00004028 474F54          	   204: 	DC.B	'GOT',('O'+$80)
02:0000402B CF
02:0000402C 474F5355        	   205: 	DC.B	'GOSU',('B'+$80)
02:00004030 C2
02:00004031 5245545552      	   206: 	DC.B	'RETUR',('N'+$80)
02:00004036 CE
02:00004037 5245            	   207: 	DC.B	'RE',('M'+$80)
02:00004039 CD
02:0000403A 464F            	   208: 	DC.B	'FO',('R'+$80)
02:0000403C D2
02:0000403D 494E5055        	   209: 	DC.B	'INPU',('T'+$80)
02:00004041 D4
02:00004042 5052494E        	   210: 	DC.B	'PRIN',('T'+$80)
02:00004046 D4
02:00004047 504F4B          	   211: 	DC.B	'POK',('E'+$80)
02:0000404A C5
02:0000404B 53544F          	   212: 	DC.B	'STO',('P'+$80)
02:0000404E D0
02:0000404F 4259            	   213: 	DC.B	'BY',('E'+$80)
02:00004051 C5
02:00004052 43414C          	   214: 	DC.B	'CAL',('L'+$80)
02:00004055 CC
02:00004056 4F4E4952        	   215: 	DC.B	'ONIR',('Q'+$80)
02:0000405A D1
02:0000405B 00              	   216: 	DC.B	0
                            	   217: TAB4
02:0000405C 504545          	   218: 	DC.B	'PEE',('K'+$80)         Functions
02:0000405F CB
02:00004060 524E            	   219: 	DC.B	'RN',('D'+$80)
02:00004062 C4
02:00004063 4142            	   220: 	DC.B	'AB',('S'+$80)
02:00004065 D3
02:00004066 53495A          	   221: 	DC.B	'SIZ',('E'+$80)
02:00004069 C5
02:0000406A 544943          	   222: 	DC.B	'TIC',('K'+$80)
02:0000406D CB
02:0000406E 434F52454E      	   223: 	DC.B	'COREN',('O'+$80)
02:00004073 CF
02:00004074 4C454654        	   224: 	DC.B	'LEFT',('$'+$80)
02:00004078 A4
02:00004079 5249474854      	   225: 	DC.B	'RIGHT',('$'+$80)
02:0000407E A4
02:0000407F 4D4944          	   226: 	DC.B	'MID',('$'+$80)
02:00004082 A4
02:00004083 4C45            	   227: 	DC.B	'LE',('N'+$80)
02:00004085 CE
02:00004086 494E            	   228: 	DC.B	'IN',('T'+$80)
02:00004088 D4
02:00004089 434852          	   229: 	DC.B	'CHR',('$'+$80)
02:0000408C A4
02:0000408D 00              	   230: 	DC.B	0
                            	   231: TAB5
02:0000408E 54              	   232: 	DC.B	'T',('O'+$80)           "TO" in "FOR"
02:0000408F CF
02:00004090 00              	   233: 	DC.B	0
                            	   234: TAB6
02:00004091 535445          	   235: 	DC.B	'STE',('P'+$80)         "STEP" in "FOR"
02:00004094 D0
02:00004095 00              	   236: 	DC.B	0
                            	   237: TAB8
02:00004096 3E              	   238: 	DC.B	'>',('='+$80)           Relational operators
02:00004097 BD
02:00004098 3C              	   239: 	DC.B	'<',('>'+$80)
02:00004099 BE
02:0000409A BE              	   240: 	DC.B	('>'+$80)
02:0000409B BD              	   241: 	DC.B	('='+$80)
02:0000409C 3C              	   242: 	DC.B	'<',('='+$80)
02:0000409D BD
02:0000409E BC              	   243: 	DC.B	('<'+$80)
02:0000409F 00              	   244: 	DC.B	0
02:000040A0 00              	   245: 	DC.B	0	<- for aligning on a word boundary
                            	   246: TAB9
02:000040A1 414E            	   247: 	DC.B	'AN',('D'+$80)
02:000040A3 C4
02:000040A4 00              	   248: 	DC.B	0
                            	   249: TAB10
02:000040A5 4F              	   250: 	DC.B	'O',('R'+$80)
02:000040A6 D2
02:000040A7 00              	   251: 	DC.B	0
                            	   252: TAB11
02:000040A8 4D4F            	   253: 	DC.B	'MO',('D'+$80)
02:000040AA C4
02:000040AB 00              	   254: 	DC.B	0
02:000040AC 00              	   255: 	DC.B	0
                            	   256: 
                            	   257: ; Execution address tables:
                            	   258: 	align 2
                            	   259: TAB1_1	
02:000040B0 000041F0        	   260: 	DC.L	INCOM
02:000040B4 000041E2        	   261: 	DC.L	INCON
02:000040B8 00004208        	   262: 	DC.L	OUTCOM
02:000040BC 0000421E        	   263: 	DC.L	OUTCON
02:000040C0 000041FE        	   264: 	DC.L	IOCOM
02:000040C4 00004214        	   265: 	DC.L	IOCON
02:000040C8 00004308        	   266: 	DC.L	LIST			Direct commands
02:000040CC 000045E6        	   267: 	DC.L	LOAD
02:000040D0 0000422A        	   268: 	DC.L	NEW
02:000040D4 00004246        	   269: 	DC.L	RUN
02:000040D8 00004646        	   270: 	DC.L	SAVE
02:000040DC 000052CC        	   271: 	DC.L	CLS
                            	   272: TAB2_1
02:000040E0 000044A4        	   273: 	DC.L	NEXT			Direct / statement
02:000040E4 000045D6        	   274: 	DC.L	LET
02:000040E8 00004510        	   275: 	DC.L	IF
02:000040EC 000042C0        	   276: 	DC.L	GOTO
02:000040F0 000043BE        	   277: 	DC.L	GOSUB
02:000040F4 000043F8        	   278: 	DC.L	RETURN
02:000040F8 0000450E        	   279: 	DC.L	REM
02:000040FC 00004424        	   280: 	DC.L	FOR
02:00004100 00004538        	   281: 	DC.L	INPUT
02:00004104 00004334        	   282: 	DC.L	PRINT
02:00004108 000046C4        	   283: 	DC.L	POKE
02:0000410C 0000423E        	   284: 	DC.L	STOP
02:00004110 00003E86        	   285: 	DC.L	GOBYE
02:00004114 0000473E        	   286: 	DC.L	CALL
02:00004118 000042D4        	   287: 	DC.L	ONIRQ
02:0000411C 000045CE        	   288: 	DC.L	DEFLT
                            	   289: TAB4_1
02:00004120 00004CEE        	   290: 	DC.L	PEEK			; Functions
02:00004124 00004D56        	   291: 	DC.L	RND
02:00004128 00004D80        	   292: 	DC.L	ABS
02:0000412C 00004D8C        	   293: 	DC.L	SIZE
02:00004130 00004D9C        	   294: 	DC.L	TICK
02:00004134 00004DA8        	   295: 	DC.L	CORENO
02:00004138 00004EBA        	   296: 	DC.L	LEFT
02:0000413C 00004EC6        	   297: 	DC.L	RIGHT
02:00004140 00004DF0        	   298: 	DC.L	MID
02:00004144 00004EEE        	   299: 	DC.L	LEN
02:00004148 00004F14        	   300: 	DC.L	INT
02:0000414C 00004F2A        	   301: 	DC.L  CHR
02:00004150 000049F8        	   302: 	DC.L	XP40
                            	   303: TAB5_1
02:00004154 0000443E        	   304: 	DC.L	FR1			; "TO" in "FOR"
02:00004158 00004FAE        	   305: 	DC.L	QWHAT
                            	   306: TAB6_1
02:0000415C 00004456        	   307: 	DC.L	FR2			; "STEP" in "FOR"
02:00004160 0000445C        	   308: 	DC.L	FR3
                            	   309: TAB8_1
02:00004164 0000482E        	   310: 	DC.L	XP11	>=		Relational operators
02:00004168 0000483A        	   311: 	DC.L	XP12	<>
02:0000416C 00004846        	   312: 	DC.L	XP13	>
02:00004170 0000485E        	   313: 	DC.L	XP15	=
02:00004174 00004852        	   314: 	DC.L	XP14	<=
02:00004178 0000486C        	   315: 	DC.L	XP16	<
02:0000417C 0000488A        	   316: 	DC.L	XP17
                            	   317: TAB9_1
02:00004180 000047EC        	   318: 	DC.L	XP_AND
02:00004184 00004802        	   319: 	DC.L	XP_ANDX
                            	   320: TAB10_1
02:00004188 000047C4        	   321: 	DC.L	XP_OR
02:0000418C 00004802        	   322: 	DC.L	XP_ORX
                            	   323: TAB11_1
02:00004190 000049CA        	   324: 	DC.L	XP_MOD
02:00004194 00004994        	   325: 	DC.L	XP31
                            	   326: 	even
                            	   327: 	
                            	   328: DIRECT
02:00004198 33FC000100005408	   329: 	move.w #1,DIRFLG
02:000041A0 43FAFE4E        	   330: 	LEA	TAB1,A1
02:000041A4 45FAFF0A        	   331: 	LEA	TAB1_1,A2
                            	   332: EXEC
02:000041A8 610010B0        	   333: 	bsr	IGNBLK				; ignore leading blanks
02:000041AC 2648            	   334: 	MOVE.L A0,A3			; save the pointer
02:000041AE 4202            	   335: 	CLR.B	D2					; clear match flag
                            	   336: EXLP
02:000041B0 1018            	   337: 	MOVE.B (A0)+,D0	 	; get the program character
02:000041B2 1211            	   338: 	MOVE.B (A1),D1 		; get the table character
02:000041B4 6604            	   339: 	BNE	EXNGO					; If end of table,
02:000041B6 204B            	   340: 	MOVE.L A3,A0			; restore the text pointer and...
02:000041B8 6024            	   341: 	BRA	EXGO					; execute the default.
                            	   342: EXNGO
02:000041BA 1600            	   343: 	MOVE.B D0,D3		 	; Else check for period...
02:000041BC C602            	   344: 	AND.B	D2,D3				; and a match.
02:000041BE B63C002E        	   345: 	CMP.B	#'.',D3
02:000041C2 671A            	   346: 	BEQ	EXGO					; if so, execute
02:000041C4 C23C007F        	   347: 	AND.B	#$7F,D1 		; ignore the table's high bit
02:000041C8 B200            	   348: 	CMP.B	D0,D1				; is there a match?
02:000041CA 670C            	   349: 	BEQ	EXMAT
02:000041CC 588A            	   350: 	ADDQ.L #4,A2			; if not, try the next entry
02:000041CE 204B            	   351: 	MOVE.L A3,A0			; reset the program pointer
02:000041D0 4202            	   352: 	CLR.B	D2					; sorry, no match
                            	   353: EX1
02:000041D2 4A19            	   354: 	TST.B	(A1)+				; get to the end of the entry
02:000041D4 6AFC            	   355: 	BPL	EX1
02:000041D6 60D8            	   356: 	BRA	EXLP					; back for more matching
                            	   357: EXMAT
02:000041D8 74FF            	   358: 	MOVEQ	#-1,D2			; we've got a match so far
02:000041DA 4A19            	   359: 	TST.B	(A1)+				; end of table entry?
02:000041DC 6AD2            	   360: 	BPL	EXLP					; if not, go back for more
                            	   361: EXGO
02:000041DE 2652            	   362: 	MOVE.L (A2),A3		; execute the appropriate routine
02:000041E0 4ED3            	   363: 	JMP	(A3)
                            	   364: 
                            	   365: *******************************************************************
                            	   366: * Console redirection
                            	   367: * <COM will redirect input to the COM port
                            	   368: * >COM will redirect output to the COM port
                            	   369: * <CON will redirect input to the console
                            	   370: * >CON will redirect output to the console
                            	   371: * <>COM will redirect input and output to the COM port
                            	   372: * <>CON will redirect input and output to the console
                            	   373: *******************************************************************
                            	   374: INCON
02:000041E2 23FC000052F40000	   375: 	move.l	#INC1,INPPTR
02:000041EA 53AC
02:000041EC 600001C8        	   376: 	bra			FINISH
                            	   377: INCOM
02:000041F0 23FC0000531C0000	   378: 	move.l	#AUXIN,INPPTR
02:000041F8 53AC
02:000041FA 600001BA        	   379: 	bra			FINISH
                            	   380: IOCOM
02:000041FE 23FC0000531C0000	   381: 	move.l	#AUXIN,INPPTR
02:00004206 53AC
                            	   382: OUTCOM
02:00004208 13FC0002000400A8	   383: 	move.b #2,OutputDevice
02:00004210 600001A4        	   384: 	bra	FINISH
                            	   385: IOCON
02:00004214 23FC000052F40000	   386: 	move.l	#INC1,INPPTR
02:0000421C 53AC
                            	   387: OUTCON
02:0000421E 13FC0001000400A8	   388: 	move.b #1,OutputDevice
02:00004226 6000018E        	   389: 	bra	FINISH
                            	   390: 
                            	   391: *******************************************************************
                            	   392: *
                            	   393: * What follows is the code to execute direct and statement
                            	   394: * commands. Control is transferred to these points via the command
                            	   395: * table lookup code of 'DIRECT' and 'EXEC' in the last section.
                            	   396: * After the command is executed, control is transferred to other
                            	   397: * sections as follows:
                            	   398: *
                            	   399: * For 'LIST', 'NEW', and 'STOP': go back to the warm start point.
                            	   400: * For 'RUN': go execute the first stored line if any; else go
                            	   401: * back to the warm start point.
                            	   402: * For 'GOTO' and 'GOSUB': go execute the target line.
                            	   403: * For 'RETURN' and 'NEXT'; go back to saved return line.
                            	   404: * For all others: if 'CURRNT' is 0, go to warm start; else go
                            	   405: * execute next command. (This is done in 'FINISH'.)
                            	   406: *
                            	   407: *******************************************************************
                            	   408: *
                            	   409: * *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                            	   410: *
                            	   411: * 'NEW<CR>' sets TXTUNF to point to TXTBGN
                            	   412: *
                            	   413: * 'STOP<CR>' goes back to WSTART
                            	   414: *
                            	   415: * 'RUN<CR>' finds the first stored line, stores its address
                            	   416: * in CURRNT, and starts executing it. Note that only those
                            	   417: * commands in TAB2 are legal for a stored program.
                            	   418: *
                            	   419: * There are 3 more entries in 'RUN':
                            	   420: * 'RUNNXL' finds next line, stores it's address and executes it.
                            	   421: * 'RUNTSL' stores the address of this line and executes it.
                            	   422: * 'RUNSML' continues the execution on same line.
                            	   423: *
                            	   424: * 'GOTO expr<CR>' evaluates the expression, finds the target
                            	   425: * line, and jumps to 'RUNTSL' to do it.
                            	   426: *
                            	   427: NEW
02:0000422A 61000D70        	   428: 	bsr	ENDCHK
02:0000422E 23FAFC5A000053FC	   429: 	MOVE.L TXTBGN,TXTUNF	set the end pointer
02:00004236 6100FD84        	   430: 	bsr ClearStringArea
02:0000423A 6100FDA0        	   431: 	bsr ClearStringStack
                            	   432: 
                            	   433: STOP
02:0000423E 61000D5C        	   434: 	bsr	ENDCHK
02:00004242 6000FCB8        	   435: 	BRA	WSTART
                            	   436: 
                            	   437: RUN
02:00004246 427900005408    	   438: 	clr.w DIRFLG
02:0000424C 61000D4E        	   439: 	bsr	ENDCHK
02:00004250 207AFC38        	   440: 	MOVE.L	TXTBGN,A0	set pointer to beginning
02:00004254 23C8000053B4    	   441: 	MOVE.L	A0,CURRNT
                            	   442: 
                            	   443: RUNNXL
02:0000425A 4AB9000053B4    	   444: 	TST.L	CURRNT		; executing a program?
02:00004260 6700FC9A        	   445: 	beq	WSTART			; if not, we've finished a direct stat.
02:00004264 4AB9000053E8    	   446: 	tst.l	IRQROUT		; are we handling IRQ's ?
02:0000426A 672E            	   447: 	beq	RUN1
02:0000426C 4A39000400A0    	   448: 	tst.b IRQFlag		; was there an IRQ ?
02:00004272 6726            	   449: 	beq	RUN1
02:00004274 4239000400A0    	   450: 	clr.b IRQFlag
                            	   451: 
                            	   452: 	; same code as GOSUB	
                            	   453: ;	sub.l #128,sp		; allocate storage for local variables
                            	   454: ;	move.l STKFP,-(sp)
                            	   455: ;	move.l sp,STKFP
02:0000427A 61000EB4        	   456: 	bsr	PUSHA				; save the current 'FOR' parameters
02:0000427E 2F08            	   457: 	MOVE.L A0,-(SP)	; save text pointer
02:00004280 2F3A1132        	   458: 	MOVE.L CURRNT,-(SP)	found it, save old 'CURRNT'...
02:00004284 2F3A1136        	   459: 	MOVE.L STKGOS,-(SP)	and 'STKGOS'
02:00004288 42B9000053C4    	   460: 	CLR.L	LOPVAR		; load new values
02:0000428E 23CF000053BC    	   461: 	MOVE.L SP,STKGOS
                            	   462: 
02:00004294 227A1152        	   463: 	move.l IRQROUT,a1
02:00004298 600C            	   464: 	bra	RUNTSL
                            	   465: RUN1
02:0000429A 7200            	   466: 	CLR.L	D1			; else find the next line number
02:0000429C 2248            	   467: 	MOVE.L A0,A1
02:0000429E 61000E10        	   468: 	bsr	FNDLNP
02:000042A2 6500FC58        	   469: 	BCS	WSTART		; if we've fallen off the end, stop
                            	   470: 
                            	   471: RUNTSL
02:000042A6 23C9000053B4    	   472: 	MOVE.L	A1,CURRNT	set CURRNT to point to the line no.
02:000042AC 2049            	   473: 	MOVE.L	A1,A0		set the text pointer to
02:000042AE 5488            	   474: 	ADDQ.L	#2,A0		the start of the line text
                            	   475: 
                            	   476: RUNSML
02:000042B0 61000FFC        	   477: 	bsr	CHKIO		see if a control-C was pressed
02:000042B4 43FAFD69        	   478: 	LEA	TAB2,A1 	find command in TAB2
02:000042B8 45FAFE26        	   479: 	LEA	TAB2_1,A2
02:000042BC 6000FEEA        	   480: 	BRA	EXEC		and execute it
                            	   481: 
                            	   482: GOTO	
02:000042C0 610004E0        	   483: 	bsr	INT_EXPR	; evaluate the following expression
02:000042C4 61000CD6        	   484: 	bsr	ENDCHK		; must find end of line
02:000042C8 2200            	   485: 	move.l d0,d1
02:000042CA 61000DD6        	   486: 	bsr	FNDLN			; find the target line
02:000042CE 66000D26        	   487: 	bne	QHOW			; no such line no.
02:000042D2 60D2            	   488: 	bra	RUNTSL		; go do it
                            	   489: 
                            	   490: ;******************************************************************
                            	   491: ; ONIRQ <line number>
                            	   492: ; ONIRQ sets up an interrupt handler which acts like a specialized
                            	   493: ; subroutine call. ONIRQ is coded like a GOTO that never executes.
                            	   494: ;******************************************************************
                            	   495: 
                            	   496: ONIRQ:
02:000042D4 610004CC        	   497: 	bsr	INT_EXPR		; evaluate the following expression
02:000042D8 61000CC2        	   498: 	bsr ENDCHK			; must find end of line
02:000042DC 2200            	   499: 	move.l d0,d1
02:000042DE 61000DC2        	   500: 	bsr FNDLN				; find the target line
02:000042E2 660A            	   501: 	bne	ONIRQ1
02:000042E4 42B9000053E8    	   502: 	clr.l IRQROUT
02:000042EA 600000CA        	   503: 	bra	FINISH
                            	   504: ONIRQ1:
02:000042EE 23C9000053E8    	   505: 	move.l a1,IRQROUT
02:000042F4 600000C0        	   506: 	jmp	FINISH
                            	   507: 
                            	   508: 
                            	   509: WAITIRQ:
02:000042F8 61000FB4        	   510: 	jsr	CHKIO				; see if a control-C was pressed
02:000042FC 4A39000400A0    	   511: 	tst.b IRQFlag
02:00004302 67F4            	   512: 	beq	WAITIRQ
02:00004304 600000B0        	   513: 	jmp	FINISH
                            	   514: 
                            	   515: *******************************************************************
                            	   516: *
                            	   517: * *** LIST *** PRINT ***
                            	   518: *
                            	   519: * LIST has two forms:
                            	   520: * 'LIST<CR>' lists all saved lines
                            	   521: * 'LIST #<CR>' starts listing at the line #
                            	   522: * Control-S pauses the listing, control-C stops it.
                            	   523: *
                            	   524: * PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                            	   525: * where '....' is a list of expressions, formats, back-arrows,
                            	   526: * and strings.	These items a separated by commas.
                            	   527: *
                            	   528: * A format is a pound sign followed by a number.  It controls
                            	   529: * the number of spaces the value of an expression is going to
                            	   530: * be printed in.  It stays effective for the rest of the print
                            	   531: * command unless changed by another format.  If no format is
                            	   532: * specified, 11 positions will be used.
                            	   533: *
                            	   534: * A string is quoted in a pair of single- or double-quotes.
                            	   535: *
                            	   536: * An underline (back-arrow) means generate a <CR> without a <LF>
                            	   537: *
                            	   538: * A <CR LF> is generated after the entire list has been printed
                            	   539: * or if the list is empty.  If the list ends with a semicolon,
                            	   540: * however, no <CR LF> is generated.
                            	   541: *
                            	   542: 
                            	   543: LIST	
02:00004308 61000F04        	   544: 	bsr	TSTNUM		see if there's a line no.
02:0000430C 61000C8E        	   545: 	bsr	ENDCHK		if not, we get a zero
02:00004310 61000D90        	   546: 	bsr	FNDLN		find this or next line
                            	   547: LS1
02:00004314 650000A0        	   548: 	BCS	FINISH		warm start if we passed the end
02:00004318 61000EBE        	   549: 	bsr	PRTLN		print the line
02:0000431C 61000F90        	   550: 	bsr	CHKIO		check for listing halt request
02:00004320 670C            	   551: 	BEQ	LS3
02:00004322 B03C0013        	   552: 	CMP.B	#CTRLS,D0	pause the listing?
02:00004326 6606            	   553: 	BNE	LS3
                            	   554: LS2
02:00004328 61000F84        	   555: 	bsr	CHKIO		if so, wait for another keypress
02:0000432C 67FA            	   556: 	BEQ	LS2
                            	   557: LS3
02:0000432E 61000D80        	   558: 	bsr	FNDLNP		find the next line
02:00004332 60E0            	   559: 	BRA	LS1
                            	   560: 
                            	   561: PRINT	
02:00004334 780B            	   562: 	MOVE.L #11,D4		D4 = number of print spaces
02:00004336 61000EBE        	   563: 	bsr	TSTC		if null list and ":"
02:0000433A 3A              	   564: 	DC.B	':',PR2-*
02:0000433B 09
02:0000433C 6100154C        	   565: 	bsr	CRLF		give CR-LF and continue
02:00004340 6000FF6E        	   566: 	BRA	RUNSML		execution on the same line
                            	   567: PR2	
02:00004344 61000EB0        	   568: 	bsr	TSTC		if null list and <CR>
02:00004348 0D              	   569: 	DC.B	CR,PR0-*
02:00004349 09
02:0000434A 6100153E        	   570: 	bsr	CRLF		also give CR-LF and
02:0000434E 6000FF0A        	   571: 	BRA	RUNNXL		execute the next line
                            	   572: PR0
02:00004352 61000EA2        	   573: 	bsr	TSTC				; else is it a format?
02:00004356 23              	   574: 	dc.b '#',PR1-*
02:00004357 09
02:00004358 61000448        	   575: 	bsr	INT_EXPR		; yes, evaluate expression
02:0000435C 2800            	   576: 	move.l d0,d4		; and save it as print width
02:0000435E 600E            	   577: 	bra	PR3					; look for more to print
                            	   578: PR1
02:00004360 61000E94        	   579: 	bsr	TSTC				; is character expression? (MRL)
02:00004364 24              	   580: 	dc.b '$',PR8-*
02:00004365 1B
02:00004366 6100043A        	   581: 	bsr	INT_EXPR		; yep. Evaluate expression (MRL)
02:0000436A 6100FB0A        	   582: 	bsr	GOOUT				; print low byte (MRL)
                            	   583: 	bra	PR3					; look for more. (MRL)
                            	   584: PR3
02:0000436E 61000E86        	   585: 	bsr	TSTC						; if ",", go find next
02:00004372 2C              	   586: 	dc.b ',',PR6-*
02:00004373 07
02:00004374 61000C0C        	   587: 	bsr	FIN							; in the list.
02:00004378 60D8            	   588: 	BRA	PR0
                            	   589: PR6
02:0000437A 6100150E        	   590: 	bsr	CRLF						; list ends here
02:0000437E 6036            	   591: 	BRA	FINISH
                            	   592: PR8
02:00004380 2F04            	   593: 	move.l d4,-(SP)			; save the width value
02:00004382 61000430        	   594: 	bsr	EXPR						; evaluate the expression
02:00004386 281F            	   595: 	move.l (sp)+,d4			; restore the width
02:00004388 0C8000000002    	   596: 	cmpi.l #DT_STRING,d0	; is it a string?
02:0000438E 670C            	   597: 	beq PR9
02:00004390 F2000080        	   598: 	fmove fp0,fp1
02:00004394 7823            	   599: 	move.l #35,d4
02:00004396 61000DF6        	   600: 	bsr	PRTNUM					; print its value
02:0000439A 60D2            	   601: 	bra	PR3							; more to print?
                            	   602: 	; Print a string
                            	   603: PR9
02:0000439C F239680000040600	   604: 	fmove.x fp0,_fpWork
02:000043A4 323900040600    	   605: 	move.w _fpWork,d1
02:000043AA 227900040604    	   606: 	move.l _fpWork+4,a1
02:000043B0 61000DD6        	   607: 	bsr PRTSTR2
02:000043B4 60B8            	   608: 	bra PR3
                            	   609: 
                            	   610: FINISH
02:000043B6 61000BCA        	   611: 	bsr	FIN			; Check end of command
02:000043BA 60000BF2        	   612: 	BRA	QWHAT		; print "What?" if wrong
                            	   613: 
                            	   614: ;******************************************************************
                            	   615: ;
                            	   616: ; *** GOSUB *** & RETURN ***
                            	   617: ;
                            	   618: ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                            	   619: ; except that the current text pointer, stack pointer, etc. are
                            	   620: ; saved so that execution can be continued after the subroutine
                            	   621: ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                            	   622: ; recursive), the save area must be stacked.  The stack pointer
                            	   623: ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                            	   624: ; If we are in the main routine, 'STKGOS' is zero (this was done
                            	   625: ; in the initialization section of the interpreter), but we still
                            	   626: ; save it as a flag for no further 'RETURN's.
                            	   627: ;
                            	   628: ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                            	   629: ; returns the execution to the command after the most recent
                            	   630: ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                            	   631: ; a 'GOSUB' and is thus an error.
                            	   632: 
                            	   633: GOSUB:
02:000043BE 4FEFFF80        	   634: 	sub.l #128,sp		; allocate storage for local variables
02:000043C2 2F3A0FF4        	   635: 	move.l STKFP,-(sp)
02:000043C6 23CF000053B8    	   636: 	move.l sp,STKFP
02:000043CC 61000D62        	   637: 	bsr	PUSHA				; save the current 'FOR' parameters
02:000043D0 610003D0        	   638: 	bsr	INT_EXPR		; get line number
02:000043D4 2F08            	   639: 	MOVE.L	A0,-(SP)	save text pointer
02:000043D6 2200            	   640: 	move.l	d0,d1
02:000043D8 61000CC8        	   641: 	bsr	FNDLN		find the target line
02:000043DC 66000C1A        	   642: 	BNE	AHOW		if not there, say "How?"
02:000043E0 2F3A0FD2        	   643: 	MOVE.L	CURRNT,-(SP)	found it, save old 'CURRNT'...
02:000043E4 2F3A0FD6        	   644: 	MOVE.L	STKGOS,-(SP)	and 'STKGOS'
02:000043E8 42B9000053C4    	   645: 	CLR.L	LOPVAR		load new values
02:000043EE 23CF000053BC    	   646: 	MOVE.L	SP,STKGOS
02:000043F4 6000FEB0        	   647: 	BRA	RUNTSL
                            	   648: 
                            	   649: RETURN:
02:000043F8 61000BA2        	   650: 	bsr	ENDCHK					; there should be just a <CR>
02:000043FC 223A0FBE        	   651: 	MOVE.L	STKGOS,D1		; get old stack pointer
02:00004400 67000BAC        	   652: 	BEQ	QWHAT						; if zero, it doesn't exist
02:00004404 2E41            	   653: 	MOVE.L	D1,SP				; else restore it
02:00004406 23DF000053BC    	   654: 	MOVE.L	(SP)+,STKGOS	; and the old 'STKGOS'
02:0000440C 23DF000053B4    	   655: 	MOVE.L	(SP)+,CURRNT	; and the old 'CURRNT'
02:00004412 205F            	   656: 	MOVE.L	(SP)+,A0		; and the old text pointer
02:00004414 61000CDE        	   657: 	bsr	POPA						; and the old 'FOR' parameters
                            	   658: ;	move.l STKFP,sp
02:00004418 23DF000053B8    	   659: 	move.l (sp)+,STKFP
02:0000441E 4FEF0080        	   660: 	add.l #128,sp				; remove local variable storage
02:00004422 6092            	   661: 	BRA	FINISH					; and we are back home
                            	   662: 
                            	   663: *******************************************************************
                            	   664: *
                            	   665: * *** FOR *** & NEXT ***
                            	   666: *
                            	   667: * 'FOR' has two forms:
                            	   668: * 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                            	   669: * The second form means the same thing as the first form with a
                            	   670: * STEP of positive 1.  The interpreter will find the variable 'var'
                            	   671: * and set its value to the current value of 'exp1'.  It also
                            	   672: * evaluates 'exp2' and 'exp1' and saves all these together with
                            	   673: * the text pointer, etc. in the 'FOR' save area, which consisits of
                            	   674: * 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                            	   675: * already something in the save area (indicated by a non-zero
                            	   676: * 'LOPVAR'), then the old save area is saved on the stack before
                            	   677: * the new values are stored.  The interpreter will then dig in the
                            	   678: * stack and find out if this same variable was used in another
                            	   679: * currently active 'FOR' loop.  If that is the case, then the old
                            	   680: * 'FOR' loop is deactivated. (i.e. purged from the stack)
                            	   681: *
                            	   682: * 'NEXT var' serves as the logical (not necessarily physical) end
                            	   683: * of the 'FOR' loop.  The control variable 'var' is checked with
                            	   684: * the 'LOPVAR'.  If they are not the same, the interpreter digs in
                            	   685: * the stack to find the right one and purges all those that didn't
                            	   686: * match.  Either way, it then adds the 'STEP' to that variable and
                            	   687: * checks the result with against the limit value.  If it is within
                            	   688: * the limit, control loops back to the command following the
                            	   689: * 'FOR'.  If it's outside the limit, the save area is purged and
                            	   690: * execution continues.
                            	   691: 
                            	   692: FOR
02:00004424 61000D0A        	   693: 	bsr	PUSHA			; save the old 'FOR' save area
02:00004428 61000B38        	   694: 	bsr	SETVAL		; set the control variable
02:0000442C 23CE000053C4    	   695: 	move.l a6,LOPVAR		; save its address
02:00004432 43FAFC5A        	   696: 	LEA	TAB5,A1 	; use 'EXEC' to test for 'TO'
02:00004436 45FAFD1C        	   697: 	LEA	TAB5_1,A2
02:0000443A 6000FD6C        	   698: 	BRA	EXEC
                            	   699: FR1	
02:0000443E 61000354        	   700: 	bsr	NUM_EXPR		; evaluate the limit
02:00004442 F2396800000053D4	   701: 	FMOVE.X	FP0,LOPLMT	; save that
02:0000444A 43FAFC45        	   702: 	LEA	TAB6,A1 		; use 'EXEC' to look for the
02:0000444E 45FAFD0C        	   703: 	LEA	TAB6_1,A2		; word 'STEP'
02:00004452 6000FD54        	   704: 	BRA	EXEC
                            	   705: FR2
02:00004456 6100033C        	   706: 	bsr	NUM_EXPR		found it, get the step value
02:0000445A 6006            	   707: 	BRA	FR4
                            	   708: FR3
02:0000445C F23C58000001    	   709: 	FMOVE.B #1,FP0	; not found, step defaults to 1
                            	   710: FR4
02:00004462 F2396800000053C8	   711: 	FMOVE.X	FP0,LOPINC	save that too
                            	   712: FR5	
02:0000446A 23FA0F48000053E0	   713: 	MOVE.L	CURRNT,LOPLN	save address of current line number
02:00004472 23C8000053E4    	   714: 	MOVE.L	A0,LOPPT	and text pointer
02:00004478 2C4F            	   715: 	MOVE.L	SP,A6		dig into the stack to find 'LOPVAR'
02:0000447A 600C            	   716: 	BRA	FR7
                            	   717: FR6
02:0000447C 4DEE0024        	   718: 	lea 36(a6),a6			; look at next stack frame
02:00004480 BDFAFA0C        	   719: 	cmp.l ENDMEM,a6		; safety check
02:00004484 64000B28        	   720: 	bhs QWHAT
                            	   721: FR7
02:00004488 2016            	   722: 	MOVE.L	(A6),D0 	; is it zero?
02:0000448A 6714            	   723: 	BEQ	FR8						; if so, we're done
02:0000448C B0BA0F36        	   724: 	CMP.L	LOPVAR,D0		; same as current LOPVAR?
02:00004490 66EA            	   725: 	BNE	FR6						; nope, look some more
02:00004492 244F            	   726: 	MOVE.L	SP,A2			; Else remove 9 long words from...
02:00004494 224E            	   727: 	MOVE.L	A6,A1			; inside the stack.
02:00004496 47E90024        	   728: 	lea	36(a1),a3
02:0000449A 61000C50        	   729: 	bsr	MVDOWN
02:0000449E 2E4B            	   730: 	MOVE.L	A3,SP		set the SP 9 long words up
                            	   731: FR8
02:000044A0 6000FF14        	   732: 	BRA	FINISH		and continue execution
                            	   733: 
                            	   734: NEXT	
02:000044A4 6100078A        	   735: 	bsr	TSTV						; get address of variable
02:000044A8 65000B04        	   736: 	bcs	QWHAT						; if no variable, say "What?"
02:000044AC 2240            	   737: 	move.l d0,a1				; save variable's address
                            	   738: NX0
02:000044AE 203A0F14        	   739: 	move.l LOPVAR,D0		; If 'LOPVAR' is zero, we never...
02:000044B2 67000AFA        	   740: 	beq	QWHAT						; had a FOR loop, so say "What?"
02:000044B6 B3C0            	   741: 	cmp.l	d0,a1					; else we check them
02:000044B8 6706            	   742: 	beq	NX3							; OK, they agree
02:000044BA 61000C38        	   743: 	bsr	POPA						; nope, let's see the next frame
02:000044BE 60EE            	   744: 	bra	NX0
                            	   745: NX3	
02:000044C0 F22948000004    	   746: 	fmove.x	4(a1),fp0		; get control variable's value
02:000044C6 F23A48220EFE    	   747: 	fadd.x LOPINC,fp0		; add in loop increment
                            	   748: ;	BVS	QHOW		say "How?" for 32-bit overflow
02:000044CC F22968000004    	   749: 	fmove.x	fp0,4(a1)		; save control variable's new value
02:000044D2 F23A48800EFE    	   750: 	fmove.x	LOPLMT,fp1	; get loop's limit value
02:000044D8 F23A503A0EEC    	   751: 	ftst LOPINC
02:000044DE F293000E        	   752: 	FBGE NX1				; branch if loop increment is positive
02:000044E2 F2276800        	   753: 	FMOVE.X FP0,-(a7)	; exchange FP0,FP1
02:000044E6 F2000400        	   754: 	FMOVE.X FP1,FP0
02:000044EA F21F4880        	   755: 	FMOVE.X (a7)+,FP1
                            	   756: NX1	
02:000044EE F20000B8        	   757: 	FCMP FP0,FP1		;	test against limit
02:000044F2 F2940012        	   758: 	FBLT NX2				; branch if outside limit
02:000044F6 23FA0EE8000053B4	   759: 	MOVE.L LOPLN,CURRNT	Within limit, go back to the...
02:000044FE 207A0EE4        	   760: 	MOVE.L LOPPT,A0	saved 'CURRNT' and text pointer.
02:00004502 6000FEB2        	   761: 	BRA	FINISH
                            	   762: NX2
02:00004506 61000BEC        	   763: 	bsr	POPA		purge this loop
02:0000450A 6000FEAA        	   764: 	BRA	FINISH
                            	   765: 
                            	   766: *******************************************************************
                            	   767: *
                            	   768: * *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                            	   769: *
                            	   770: * 'REM' can be followed by anything and is ignored by the
                            	   771: * interpreter.
                            	   772: *
                            	   773: * 'IF' is followed by an expression, as a condition and one or
                            	   774: * more commands (including other 'IF's) separated by colons.
                            	   775: * Note that the word 'THEN' is not used.  The interpreter evaluates
                            	   776: * the expression.  If it is non-zero, execution continues.  If it
                            	   777: * is zero, the commands that follow are ignored and execution
                            	   778: * continues on the next line.
                            	   779: *
                            	   780: * 'INPUT' is like the 'PRINT' command, and is followed by a list
                            	   781: * of items.  If the item is a string in single or double quotes,
                            	   782: * or is an underline (back arrow), it has the same effect as in
                            	   783: * 'PRINT'.  If an item is a variable, this variable name is
                            	   784: * printed out followed by a colon, then the interpreter waits for
                            	   785: * an expression to be typed in.  The variable is then set to the
                            	   786: * value of this expression.  If the variable is preceeded by a
                            	   787: * string (again in single or double quotes), the string will be
                            	   788: * displayed followed by a colon.  The interpreter the waits for an
                            	   789: * expression to be entered and sets the variable equal to the
                            	   790: * expression's value.  If the input expression is invalid, the
                            	   791: * interpreter will print "What?", "How?", or "Sorry" and reprint
                            	   792: * the prompt and redo the input.  The execution will not terminate
                            	   793: * unless you press control-C.  This is handled in 'INPERR'.
                            	   794: *
                            	   795: * 'LET' is followed by a list of items separated by commas.
                            	   796: * Each item consists of a variable, an equals sign, and an
                            	   797: * expression.  The interpreter evaluates the expression and sets
                            	   798: * the variable to that value.  The interpreter will also handle
                            	   799: * 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                            	   800: 
                            	   801: REM
02:0000450E 600A            	   802: 	BRA	IF2		skip the rest of the line
                            	   803: 
                            	   804: IF
02:00004510 61000290        	   805: 	bsr	INT_EXPR		evaluate the expression
                            	   806: IF1
02:00004514 4A80            	   807: 	TST.L	d0		is it zero?
02:00004516 6600FD98        	   808: 	BNE	RUNSML		if not, continue
                            	   809: IF2
02:0000451A 2248            	   810: 	MOVE.L	A0,A1
02:0000451C 7200            	   811: 	CLR.L	D1
02:0000451E 61000BAA        	   812: 	bsr	FNDSKP		if so, skip the rest of the line
02:00004522 6400FD82        	   813: 	BCC	RUNTSL		and run the next line
02:00004526 6000F9D4        	   814: 	BRA	WSTART		if no next line, do a warm start
                            	   815: 
02:0000452A 2E7A0E94        	   816: INPERR	MOVE.L	STKINP,SP	restore the old stack pointer
02:0000452E 23DF000053B4    	   817: 	MOVE.L	(SP)+,CURRNT	and old 'CURRNT'
02:00004534 588F            	   818: 	ADDQ.L	#4,SP
02:00004536 205F            	   819: 	MOVE.L	(SP)+,A0	and old text pointer
                            	   820: 
                            	   821: INPUT	
02:00004538 2F08            	   822: 	MOVE.L	A0,-(SP)	save in case of error
02:0000453A 61000278        	   823: 	bsr EXPR
02:0000453E 0C000002        	   824: 	cmpi.b #DT_STRING,d0
02:00004542 6622            	   825: 	bne IP6
02:00004544 F239680000040600	   826: 	fmove.x fp0,_fpWork
02:0000454C 323900040600    	   827: 	move.w _fpWork,d1
02:00004552 227900040604    	   828: 	move.l _fpWork+4,a1
02:00004558 61000C2E        	   829: 	bsr PRTSTR2
                            	   830: ;	bsr	QTSTG		is next item a string?
                            	   831: ;	BRA.S	IP2		nope
                            	   832: IP7
02:0000455C 610006D2        	   833: 	bsr	TSTV		yes, but is it followed by a variable?
02:00004560 655C            	   834: 	BCS	IP4		if not, branch
02:00004562 2440            	   835: 	MOVE.L	D0,A2		put away the variable's address
02:00004564 601E            	   836: 	BRA	IP3		if so, input to variable
                            	   837: IP6
02:00004566 2057            	   838: 	move.l (sp),a0	; restore text pointer
02:00004568 60F2            	   839: 	bra IP7
                            	   840: IP2
02:0000456A 2F08            	   841: 	MOVE.L	A0,-(SP)	save for 'PRTSTG'
02:0000456C 610006C2        	   842: 	bsr	TSTV		must be a variable now
02:00004570 65000A3C        	   843: 	BCS	QWHAT		"What?" it isn't?
02:00004574 2440            	   844: 	MOVE.L	D0,A2		put away the variable's address
02:00004576 1410            	   845: 	MOVE.B	(A0),D2 	get ready for 'PRTSTG'
02:00004578 4200            	   846: 	CLR.B	D0
02:0000457A 1080            	   847: 	MOVE.B	D0,(A0)
02:0000457C 225F            	   848: 	MOVE.L	(SP)+,A1
02:0000457E 61000BE6        	   849: 	bsr	PRTSTG		print string as prompt
02:00004582 1082            	   850: 	MOVE.B	D2,(A0) 	restore text
                            	   851: IP3
02:00004584 2F08            	   852: 	MOVE.L	A0,-(SP)	save in case of error
02:00004586 2F3A0E2C        	   853: 	MOVE.L	CURRNT,-(SP)	also save 'CURRNT'
02:0000458A 23FCFFFFFFFF0000	   854: 	MOVE.L	#-1,CURRNT	flag that we are in INPUT
02:00004592 53B4
02:00004594 23CF000053C0    	   855: 	MOVE.L	SP,STKINP	save the stack pointer too
02:0000459A 2F0A            	   856: 	MOVE.L	A2,-(SP)	save the variable address
02:0000459C 103C003A        	   857: 	MOVE.B	#':',D0         print a colon first
02:000045A0 61000A62        	   858: 	bsr	GETLN		then get an input line
02:000045A4 41FA0E66        	   859: 	LEA	BUFFER,A0	point to the buffer
02:000045A8 6100020A        	   860: 	bsr	EXPR		evaluate the input
02:000045AC 245F            	   861: 	MOVE.L	(SP)+,A2	restore the variable address
02:000045AE 2480            	   862: 	move.l d0,(a2)			; save data type
02:000045B0 F22A68000004    	   863: 	FMOVE.X	FP0,4(A2) 	; save value in variable
02:000045B6 23DF000053B4    	   864: 	MOVE.L	(SP)+,CURRNT	restore old 'CURRNT'
02:000045BC 205F            	   865: 	MOVE.L	(SP)+,A0	and the old text pointer
                            	   866: IP4
02:000045BE 588F            	   867: 	ADDQ.L	#4,SP		clean up the stack
02:000045C0 61000C34        	   868: 	bsr	TSTC		is the next thing a comma?
02:000045C4 2C              	   869: 	DC.B	',',IP5-*
02:000045C5 05
02:000045C6 6000FF70        	   870: 	BRA	INPUT		yes, more items
                            	   871: IP5
02:000045CA 6000FDEA        	   872: 	BRA	FINISH
                            	   873: 
                            	   874: DEFLT
02:000045CE 0C10000D        	   875: 	CMP.B	#CR,(A0)	; empty line is OK
02:000045D2 6700FDE2        	   876: 	BEQ	FINISH			; else it is 'LET'
                            	   877: 
                            	   878: LET
02:000045D6 6100098A        	   879: 	bsr	SETVAL		 	; do the assignment
02:000045DA 61000C1A        	   880: 	bsr	TSTC				; check for more 'LET' items
02:000045DE 2C              	   881: 	DC.B	',',LT1-*
02:000045DF 03
02:000045E0 60F4            	   882: 	BRA	LET
                            	   883: LT1
02:000045E2 6000FDD2        	   884: 	BRA	FINISH			; until we are finished.
                            	   885: 
                            	   886: 
                            	   887: *******************************************************************
                            	   888: *
                            	   889: * *** LOAD *** & SAVE ***
                            	   890: *
                            	   891: * These two commands transfer a program to/from an auxiliary
                            	   892: * device such as a cassette, another computer, etc.  The program
                            	   893: * is converted to an easily-stored format: each line starts with
                            	   894: * a colon, the line no. as 4 hex digits, and the rest of the line.
                            	   895: * At the end, a line starting with an '@' sign is sent.  This
                            	   896: * format can be read back with a minimum of processing time by
                            	   897: * the 68000.
                            	   898: *
                            	   899: LOAD	
02:000045E6 207AF8A2        	   900: 	MOVE.L TXTBGN,A0	set pointer to start of prog. area
02:000045EA 103C000D        	   901: 	MOVE.B #CR,D0		For a CP/M host, tell it we're ready...
02:000045EE 6100F88E        	   902: 	BSR	GOAUXO		by sending a CR to finish PIP command.
                            	   903: LOD1	
02:000045F2 6100F88E        	   904: 	BSR	GOAUXI		look for start of line
02:000045F6 67FA            	   905: 	BEQ	LOD1
02:000045F8 B03C0040        	   906: 	CMP.B	#'@',D0         end of program?
02:000045FC 671E            	   907: 	BEQ	LODEND
02:000045FE B03C003A        	   908: 	CMP.B	#':',D0         if not, is it start of line?
02:00004602 66EE            	   909: 	BNE	LOD1		if not, wait for it
02:00004604 6120            	   910: 	BSR	GBYTE		get first byte of line no.
02:00004606 10C1            	   911: 	MOVE.B	D1,(A0)+	store it
02:00004608 611C            	   912: 	BSR	GBYTE		get 2nd bye of line no.
02:0000460A 10C1            	   913: 	MOVE.B	D1,(A0)+	store that, too
                            	   914: LOD2
02:0000460C 6100F874        	   915: 	BSR	GOAUXI		get another text char.
02:00004610 67FA            	   916: 	BEQ	LOD2
02:00004612 10C0            	   917: 	MOVE.B	D0,(A0)+	store it
02:00004614 B03C000D        	   918: 	CMP.B	#CR,D0		is it the end of the line?
02:00004618 66F2            	   919: 	BNE	LOD2		if not, go back for more
02:0000461A 60D6            	   920: 	BRA	LOD1		if so, start a new line
                            	   921: LODEND
02:0000461C 23C8000053FC    	   922: 	MOVE.L	A0,TXTUNF	set end-of program pointer
02:00004622 6000F8D8        	   923: 	BRA	WSTART		back to direct mode
                            	   924: 
                            	   925: GBYTE
02:00004626 7401            	   926: 	MOVEQ	#1,D2		get two hex characters from auxiliary
02:00004628 7200            	   927: 	CLR.L	D1		and store them as a byte in D1
                            	   928: GBYTE1	
02:0000462A 6100F856        	   929: 	BSR	GOAUXI		get a char.
02:0000462E 67FA            	   930: 	BEQ	GBYTE1
02:00004630 B03C0041        	   931: 	CMP.B	#'A',D0
02:00004634 6502            	   932: 	BCS	GBYTE2
02:00004636 5F00            	   933: 	SUBQ.B	#7,D0		if greater than 9, adjust
                            	   934: GBYTE2
02:00004638 C03C000F        	   935: 	AND.B	#$F,D0		strip ASCII
02:0000463C E909            	   936: 	LSL.B	#4,D1		put nybble into the result
02:0000463E 8200            	   937: 	OR.B	D0,D1
02:00004640 51CAFFE8        	   938: 	DBRA	D2,GBYTE1	get another char.
02:00004644 4E75            	   939: 	RTS
                            	   940: 
                            	   941: SAVE
02:00004646 207AF842        	   942: 	MOVE.L	TXTBGN,A0	set pointer to start of prog. area
02:0000464A 227A0DB0        	   943: 	MOVE.L	TXTUNF,A1	set pointer to end of prog. area
                            	   944: SAVE1	
02:0000464E 103C000D        	   945: 	MOVE.B	#CR,D0		send out a CR & LF (CP/M likes this)
02:00004652 6100F82A        	   946: 	BSR	GOAUXO
02:00004656 103C000A        	   947: 	MOVE.B	#LF,D0
02:0000465A 6100F822        	   948: 	BSR	GOAUXO
02:0000465E B3C8            	   949: 	CMP.L	A0,A1		are we finished?
02:00004660 631E            	   950: 	BLS	SAVEND
02:00004662 103C003A        	   951: 	MOVE.B	#':',D0         if not, start a line
02:00004666 6100F816        	   952: 	BSR	GOAUXO
02:0000466A 1218            	   953: 	MOVE.B	(A0)+,D1	send first half of line no.
02:0000466C 6136            	   954: 	BSR	PBYTE
02:0000466E 1218            	   955: 	MOVE.B	(A0)+,D1	and send 2nd half
02:00004670 6132            	   956: 	BSR	PBYTE
                            	   957: SAVE2
02:00004672 1018            	   958: 	MOVE.B	(A0)+,D0	get a text char.
02:00004674 B03C000D        	   959: 	CMP.B	#CR,D0		is it the end of the line?
02:00004678 67D4            	   960: 	BEQ	SAVE1		if so, send CR & LF and start new line
02:0000467A 6100F802        	   961: 	BSR	GOAUXO		send it out
02:0000467E 60F2            	   962: 	BRA	SAVE2		go back for more text
                            	   963: SAVEND
02:00004680 103C0040        	   964: 	MOVE.B	#'@',D0         send end-of-program indicator
02:00004684 6100F7F8        	   965: 	BSR	GOAUXO
02:00004688 103C000D        	   966: 	MOVE.B	#CR,D0		followed by a CR & LF
02:0000468C 6100F7F0        	   967: 	BSR	GOAUXO
02:00004690 103C000A        	   968: 	MOVE.B	#LF,D0
02:00004694 6100F7E8        	   969: 	BSR	GOAUXO
02:00004698 103C001A        	   970: 	MOVE.B	#$1A,D0 	and a control-Z to end the CP/M file
02:0000469C 6100F7E0        	   971: 	BSR	GOAUXO
02:000046A0 6000F85A        	   972: 	BRA	WSTART		then go do a warm start
                            	   973: 
02:000046A4 7401            	   974: PBYTE	MOVEQ	#1,D2		send two hex characters from D1's low byte
02:000046A6 E919            	   975: PBYTE1	ROL.B	#4,D1		get the next nybble
02:000046A8 1001            	   976: 	MOVE.B	D1,D0
02:000046AA C03C000F        	   977: 	AND.B	#$F,D0		strip off garbage
02:000046AE D03C0030        	   978: 	ADD.B	#'0',D0         make it into ASCII
02:000046B2 B03C0039        	   979: 	CMP.B	#'9',D0
02:000046B6 6302            	   980: 	BLS	PBYTE2
02:000046B8 5E00            	   981: 	ADDQ.B	#7,D0		adjust if greater than 9
02:000046BA 6100F7C2        	   982: PBYTE2	BSR	GOAUXO		send it out
02:000046BE 51CAFFE6        	   983: 	DBRA	D2,PBYTE1	then send the next nybble
02:000046C2 4E75            	   984: 	RTS
                            	   985: 
                            	   986: *******************************************************************
                            	   987: *
                            	   988: * *** POKE *** & CALL ***
                            	   989: *
                            	   990: * 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                            	   991: * address specified by 'expr1'.
                            	   992: *
                            	   993: * 'CALL expr' jumps to the machine language subroutine whose
                            	   994: * starting address is specified by 'expr'.  The subroutine can use
                            	   995: * all registers but must leave the stack the way it found it.
                            	   996: * The subroutine returns to the interpreter by executing an RTS.
                            	   997: *
                            	   998: POKE
02:000046C4 1E3C0042        	   999: 	move.b #'B',d7
02:000046C8 1210            	  1000: 	move.b (a0),d1
02:000046CA 0C01002E        	  1001: 	cmpi.b #'.',d1
02:000046CE 6620            	  1002: 	bne .0001
02:000046D0 5248            	  1003: 	addq #1,a0
02:000046D2 1210            	  1004: 	move.b (a0),d1
02:000046D4 0C010042        	  1005: 	cmpi.b #'B',d1
02:000046D8 6712            	  1006: 	beq .0002
02:000046DA 0C010057        	  1007: 	cmpi.b #'W',d1
02:000046DE 670C            	  1008: 	beq .0002
02:000046E0 0C01004C        	  1009: 	cmpi.b #'L',d1
02:000046E4 6706            	  1010: 	beq .0002
02:000046E6 0C010046        	  1011: 	cmpi.b #'F',d1
02:000046EA 664E            	  1012: 	bne	PKER
                            	  1013: .0002
02:000046EC 5248            	  1014: 	addq #1,a0
02:000046EE 1E01            	  1015: 	move.b d1,d7
                            	  1016: .0001
02:000046F0 610000B0        	  1017: 	BSR	INT_EXPR		get the memory address
02:000046F4 61000B00        	  1018: 	bsr	TSTC		it must be followed by a comma
02:000046F8 2C              	  1019: 	DC.B	',',PKER-*
02:000046F9 41
02:000046FA 2F00            	  1020: 	move.l d0,-(sp)		; save the address
02:000046FC 61000096        	  1021: 	BSR	NUM_EXPR			; get the value to be POKE'd
02:00004700 225F            	  1022: 	move.l	(sp)+,a1	; get the address back
02:00004702 0C070042        	  1023: 	CMPI.B #'B',D7
02:00004706 6608            	  1024: 	BNE .0003
02:00004708 F2117800        	  1025: 	FMOVE.B	FP0,(A1) 	store the byte in memory
02:0000470C 6000FCA8        	  1026: 	BRA	FINISH
                            	  1027: .0003
02:00004710 0C070057        	  1028: 	CMPI.B #'W',d7
02:00004714 6608            	  1029: 	BNE .0004
02:00004716 F2117000        	  1030: 	FMOVE.W FP0,(A1)
02:0000471A 6000FC9A        	  1031: 	BRA FINISH
                            	  1032: .0004
02:0000471E 0C07004C        	  1033: 	CMPI.B #'L',D7
02:00004722 6608            	  1034: 	BNE .0005
02:00004724 F2116000        	  1035: 	FMOVE.L FP0,(A1)
02:00004728 6000FC8C        	  1036: 	BRA FINISH
                            	  1037: .0005
02:0000472C 0C070046        	  1038: 	CMPI.B #'F',D7
02:00004730 6608            	  1039: 	BNE .0006
02:00004732 F2116800        	  1040: 	FMOVE.X FP0,(A1)
02:00004736 6000FC7E        	  1041: 	BRA FINISH
                            	  1042: .0006
                            	  1043: PKER
02:0000473A 60000872        	  1044: 	BRA	QWHAT		if no comma, say "What?"
                            	  1045: 
                            	  1046: CALL	
02:0000473E 6162            	  1047: 	BSR	INT_EXPR		; get the subroutine's address
02:00004740 4A80            	  1048: 	TST.l d0				; make sure we got a valid address
02:00004742 670008B2        	  1049: 	BEQ QHOW				; if not, say "How?"
02:00004746 2F08            	  1050: 	MOVE.L A0,-(SP)	; save the text pointer
02:00004748 2240            	  1051: 	MOVE.L D0,A1
02:0000474A 4E91            	  1052: 	JSR	(A1)				; jump to the subroutine
02:0000474C 205F            	  1053: 	MOVE.L (SP)+,A0	; restore the text pointer
02:0000474E 6000FC66        	  1054: 	BRA	FINISH
                            	  1055: 
                            	  1056: ;******************************************************************
                            	  1057: ;
                            	  1058: ; *** EXPR ***
                            	  1059: ;
                            	  1060: ; 'EXPR' evaluates arithmetical or logical expressions.
                            	  1061: ; <EXPR>::=<EXPR2>
                            	  1062: ;	   <EXPR2><rel.op.><EXPR2>
                            	  1063: ; where <rel.op.> is one of the operators in TAB8 and the result
                            	  1064: ; of these operations is 1 if true and 0 if false.
                            	  1065: ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                            	  1066: ; where () are optional and (... are optional repeats.
                            	  1067: ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                            	  1068: ; <EXPR4>::=<variable>
                            	  1069: ;	    <function>
                            	  1070: ;	    (<EXPR>)
                            	  1071: ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                            	  1072: ; as an index, functions can have an <EXPR> as arguments, and
                            	  1073: ; <EXPR4> can be an <EXPR> in parenthesis.
                            	  1074: 
                            	  1075: ;-------------------------------------------------------------------------------
                            	  1076: ; Push a value on the stack.
                            	  1077: ;-------------------------------------------------------------------------------
                            	  1078: 
                            	  1079: XP_PUSH:
02:00004752 225F            	  1080: 	move.l (sp)+,a1				; a1 = return address
02:00004754 2F3900040098    	  1081: 	move.l _canary,-(sp)	; push the canary
02:0000475A 4FEFFFF0        	  1082: 	sub.l #16,sp					; allocate for value
02:0000475E 2E80            	  1083: 	move.l d0,(sp)				; push data type
02:00004760 F22F68000004    	  1084: 	fmove.x fp0,4(sp)			; and value
02:00004766 4ED1            	  1085: 	jmp (a1)
                            	  1086: 
                            	  1087: ;-------------------------------------------------------------------------------
                            	  1088: ; Pop value from stack into first operand.
                            	  1089: ;-------------------------------------------------------------------------------
                            	  1090: 	
                            	  1091: XP_POP:
02:00004768 225F            	  1092: 	move.l (sp)+,a1			; get return address
02:0000476A 2017            	  1093: 	move.l (sp),d0			; pop data type
02:0000476C F22F48000004    	  1094: 	fmove.x 4(sp),fp0		; and data element
02:00004772 4FEF0010        	  1095: 	add.l #16,sp
02:00004776 A2970003        	  1096: 	cchk (sp)						; check the canary
02:0000477A 588F            	  1097: 	add.l #4,sp					; pop canary	
02:0000477C 4ED1            	  1098: 	jmp (a1)
                            	  1099: 
                            	  1100: ;-------------------------------------------------------------------------------
                            	  1101: ; Pop value from stack into second operand.
                            	  1102: ;-------------------------------------------------------------------------------
                            	  1103: 
                            	  1104: XP_POP1:
02:0000477E 225F            	  1105: 	move.l (sp)+,a1			; get return address
02:00004780 2217            	  1106: 	move.l (sp),d1			; pop data type
02:00004782 F22F48800004    	  1107: 	fmove.x 4(sp),fp1		; and data element
02:00004788 4FEF0010        	  1108: 	add.l #16,sp
02:0000478C A2970003        	  1109: 	cchk (sp)						; check the canary
02:00004790 588F            	  1110: 	add.l #4,sp					; pop canary
02:00004792 4ED1            	  1111: 	jmp (a1)
                            	  1112: 
                            	  1113: ;-------------------------------------------------------------------------------
                            	  1114: ; Get and expression and make sure it is numeric.
                            	  1115: ;-------------------------------------------------------------------------------
                            	  1116: 
                            	  1117: NUM_EXPR:
02:00004794 611E            	  1118: 	bsr EXPR
02:00004796 0C8000000001    	  1119: 	cmpi.l #DT_NUMERIC,d0
02:0000479C 66000860        	  1120: 	bne ETYPE
02:000047A0 4E75            	  1121: 	rts
                            	  1122: 
                            	  1123: ;-------------------------------------------------------------------------------
                            	  1124: ; Get and expression and make sure it is numeric. Convert to integer.
                            	  1125: ;-------------------------------------------------------------------------------
                            	  1126: 
                            	  1127: INT_EXPR:
02:000047A2 6110            	  1128: 	bsr EXPR
02:000047A4 0C8000000001    	  1129: 	cmpi.l #DT_NUMERIC,d0
02:000047AA 66000852        	  1130: 	bne ETYPE
02:000047AE F2006000        	  1131: 	fmove.l fp0,d0
02:000047B2 4E75            	  1132: 	rts
                            	  1133: 
                            	  1134: ;-------------------------------------------------------------------------------
                            	  1135: ; The top level of the expression parser.
                            	  1136: ; Get an expression, string or numeric.
                            	  1137: ;
                            	  1138: ; EXEC will smash a lot of regs, so push the current expression value before
                            	  1139: ; doing EXEC
                            	  1140: ;-------------------------------------------------------------------------------
                            	  1141: 
                            	  1142: EXPR:
                            	  1143: EXPR_OR:
02:000047B4 6124            	  1144: 	BSR EXPR_AND
02:000047B6 619A            	  1145: 	BSR XP_PUSH
02:000047B8 43FAF8EB        	  1146: 	LEA TAB10,A1
02:000047BC 45FAF9CA        	  1147: 	LEA TAB10_1,A2
02:000047C0 6000F9E6        	  1148: 	BRA EXEC
                            	  1149: 	
                            	  1150: ;-------------------------------------------------------------------------------
                            	  1151: ; Boolean 'Or' level
                            	  1152: ;-------------------------------------------------------------------------------
                            	  1153: 
                            	  1154: XP_OR:
02:000047C4 6114            	  1155: 	BSR EXPR_AND
02:000047C6 61B6            	  1156: 	bsr XP_POP1
02:000047C8 613E            	  1157: 	bsr CheckNumeric
02:000047CA F2016080        	  1158: 	FMOVE.L FP1,D1
02:000047CE F2006000        	  1159: 	FMOVE.L FP0,D0
02:000047D2 8081            	  1160: 	OR.L D1,D0
02:000047D4 F2004000        	  1161: 	FMOVE.L D0,FP0
02:000047D8 4E75            	  1162: 	rts
                            	  1163: 	
                            	  1164: ;-------------------------------------------------------------------------------
                            	  1165: ; Boolean 'And' level
                            	  1166: ;-------------------------------------------------------------------------------
                            	  1167: 
                            	  1168: EXPR_AND:
02:000047DA 613E            	  1169: 	bsr EXPR_REL
02:000047DC 6100FF74        	  1170: 	bsr XP_PUSH
02:000047E0 43FAF8BF        	  1171: 	LEA TAB9,A1
02:000047E4 45FAF99A        	  1172: 	LEA TAB9_1,A2
02:000047E8 6000F9BE        	  1173: 	BRA EXEC
                            	  1174: 
                            	  1175: XP_AND:
02:000047EC 612C            	  1176: 	BSR EXPR_REL
02:000047EE 618E            	  1177: 	bsr XP_POP1
02:000047F0 6116            	  1178: 	bsr CheckNumeric
02:000047F2 F2016080        	  1179: 	FMOVE.L FP1,D1
02:000047F6 F2006000        	  1180: 	FMOVE.L FP0,D0
02:000047FA C081            	  1181: 	AND.L D1,D0
02:000047FC F2004000        	  1182: 	FMOVE.L D0,FP0
02:00004800 4E75            	  1183: 	RTS
                            	  1184: 	
                            	  1185: XP_ANDX:
                            	  1186: XP_ORX
02:00004802 6100FF64        	  1187: 	bsr XP_POP
02:00004806 4E75            	  1188: 	rts
                            	  1189: 
                            	  1190: ;-------------------------------------------------------------------------------
                            	  1191: ; Check that two numeric values are being used.
                            	  1192: ;-------------------------------------------------------------------------------
                            	  1193: 
                            	  1194: CheckNumeric:
02:00004808 0C010001        	  1195: 	CMPI.B #DT_NUMERIC,D1
02:0000480C 660007F0        	  1196: 	BNE ETYPE
02:00004810 0C000001        	  1197: 	CMPI.B #DT_NUMERIC,D0
02:00004814 660007E8        	  1198: 	BNE ETYPE
02:00004818 4E75            	  1199: 	RTS
                            	  1200: 
                            	  1201: ;-------------------------------------------------------------------------------
                            	  1202: ; Relational operator level, <,<=,>=,>,=,<>
                            	  1203: ;-------------------------------------------------------------------------------
                            	  1204: 
                            	  1205: EXPR_REL:
02:0000481A 61000088        	  1206: 	bsr	EXPR2
02:0000481E 6100FF32        	  1207: 	bsr XP_PUSH
02:00004822 43FAF872        	  1208: 	LEA	TAB8,A1 				; look up a relational operator
02:00004826 45FAF93C        	  1209: 	LEA	TAB8_1,A2
02:0000482A 6000F97C        	  1210: 	bra	EXEC		go do it
                            	  1211: 
                            	  1212: XP11:
02:0000482E 6100FF38        	  1213: 	bsr XP_POP
02:00004832 615C            	  1214: 	BSR	XP18		is it ">="?
02:00004834 F2940044        	  1215: 	FBLT XPRT0		no, return D0=0
02:00004838 6048            	  1216: 	BRA	XPRT1		else return D0=1
                            	  1217: 
                            	  1218: XP12:
02:0000483A 6100FF2C        	  1219: 	bsr XP_POP
02:0000483E 6150            	  1220: 	BSR	XP18		is it "<>"?
02:00004840 F2810038        	  1221: 	FBEQ XPRT0		no, return D0=0
02:00004844 603C            	  1222: 	BRA	XPRT1		else return D0=1
                            	  1223: 
                            	  1224: XP13:
02:00004846 6100FF20        	  1225: 	bsr XP_POP
02:0000484A 6144            	  1226: 	BSR	XP18		is it ">"?
02:0000484C F295002C        	  1227: 	FBLE XPRT0		no, return D0=0
02:00004850 6030            	  1228: 	BRA	XPRT1		else return D0=1
                            	  1229: 
                            	  1230: XP14:
02:00004852 6100FF14        	  1231: 	bsr XP_POP
02:00004856 6138            	  1232: 	BSR	XP18		;is it "<="?
02:00004858 F2920020        	  1233: 	FBGT XPRT0	;	no, return D0=0
02:0000485C 6024            	  1234: 	BRA	XPRT1		;else return D0=1
                            	  1235: 
                            	  1236: XP15:
02:0000485E 6100FF08        	  1237: 	bsr XP_POP
02:00004862 612C            	  1238: 	BSR	XP18		; is it "="?
02:00004864 F28E0014        	  1239: 	FBNE XPRT0	;	if not, return D0=0
02:00004868 6018            	  1240: 	BRA	XPRT1		;else return D0=1
                            	  1241: XP15RT
02:0000486A 4E75            	  1242: 	RTS
                            	  1243: 
                            	  1244: XP16:
02:0000486C 6100FEFA        	  1245: 	bsr XP_POP
02:00004870 611E            	  1246: 	BSR	XP18		; is it "<"?
02:00004872 F2930006        	  1247: 	FBGE XPRT0	;	if not, return D0=0
02:00004876 600A            	  1248: 	BRA	XPRT1		; else return D0=1
02:00004878 4E75            	  1249: 	RTS
                            	  1250: 
                            	  1251: XPRT0:
02:0000487A F23C58000000    	  1252: 	FMOVE.B #0,FP0	; return fp0 = 0 (false)
02:00004880 4E75            	  1253: 	RTS
                            	  1254: 
                            	  1255: XPRT1:
02:00004882 F23C58000001    	  1256: 	FMOVE.B #1,FP0	; return fp0 = 1 (true)
02:00004888 4E75            	  1257: 	RTS
                            	  1258: 
                            	  1259: XP17:								; it's not a rel. operator
02:0000488A 6100FEDC        	  1260: 	bsr XP_POP				;	return FP0=<EXPR2>
02:0000488E 4E75            	  1261: 	rts
                            	  1262: 
                            	  1263: XP18:
02:00004890 6100FEC0        	  1264: 	bsr XP_PUSH
02:00004894 610E            	  1265: 	bsr	EXPR2					; do second <EXPR2>
02:00004896 6100FEE6        	  1266: 	bsr XP_POP1
02:0000489A 6100FF6C        	  1267: 	bsr CheckNumeric
02:0000489E F20000B8        	  1268: 	fcmp fp0,fp1			; compare with the first result
02:000048A2 4E75            	  1269: 	rts								; return the result
                            	  1270: 
                            	  1271: ;-------------------------------------------------------------------------------
                            	  1272: ; Add/Subtract operator level, +,-
                            	  1273: ;-------------------------------------------------------------------------------
                            	  1274: 
                            	  1275: EXPR2
02:000048A4 61000950        	  1276: 	bsr	TSTC		; negative sign?
02:000048A8 2D              	  1277: 	DC.B	'-',XP21-*
02:000048A9 09
02:000048AA F23C58000000    	  1278: 	FMOVE.B #0,FP0
02:000048B0 604C            	  1279: 	BRA	XP26
                            	  1280: XP21	
02:000048B2 61000942        	  1281: 	bsr	TSTC		; positive sign? ignore it
02:000048B6 2B              	  1282: 	DC.B	'+',XP22-*
02:000048B7 01
                            	  1283: XP22
02:000048B8 610000C8        	  1284: 	BSR	EXPR3		; first <EXPR3>
                            	  1285: XP23
02:000048BC 61000938        	  1286: 	bsr	TSTC		; add?
02:000048C0 2B              	  1287: 	DC.B	'+',XP25-*
02:000048C1 37
02:000048C2 6100FE8E        	  1288: 	bsr XP_PUSH
02:000048C6 610000BA        	  1289: 	BSR	EXPR3					; get the second <EXPR3>
                            	  1290: XP24
02:000048CA 6100FEB2        	  1291: 	bsr XP_POP1
02:000048CE B03C0001        	  1292: 	CMP.B #DT_NUMERIC,d0
02:000048D2 660C            	  1293: 	BNE .notNum
02:000048D4 B23C0001        	  1294: 	CMP.B #DT_NUMERIC,d1
02:000048D8 6606            	  1295: 	BNE .notNum
02:000048DA F2000422        	  1296: 	FADD FP1,FP0			; add it to the first <EXPR3>
                            	  1297: ;	FBVS	QHOW		branch if there's an overflow
02:000048DE 60DC            	  1298: 	BRA	XP23		else go back for more operations
                            	  1299: .notNum
02:000048E0 B0BC00000002    	  1300: 	cmp.l #DT_STRING,d0
02:000048E6 66000716        	  1301: 	bne ETYPE
02:000048EA B2BC00000002    	  1302: 	cmp.l #DT_STRING,d1
02:000048F0 6600070C        	  1303: 	bne ETYPE
02:000048F4 611E            	  1304: 	bsr ConcatString
02:000048F6 4E75            	  1305: 	rts
                            	  1306: 
                            	  1307: XP25
02:000048F8 610008FC        	  1308: 	bsr	TSTC							; subtract?
02:000048FC 2D              	  1309: 	dc.b	'-',XP27-*
02:000048FD 15
                            	  1310: XP26
02:000048FE 6100FE52        	  1311: 	bsr XP_PUSH
02:00004902 617E            	  1312: 	BSR	EXPR3					; get second <EXPR3>
02:00004904 0C000001        	  1313: 	cmpi.b #DT_NUMERIC,d0
02:00004908 660006F4        	  1314: 	bne ETYPE
02:0000490C F200001A        	  1315: 	FNEG FP0					; change its sign
02:00004910 60B8            	  1316: 	JMP	XP24					; and do an addition
                            	  1317: 
                            	  1318: XP27
02:00004912 4E75            	  1319: 	rts
                            	  1320: 
                            	  1321: ;-------------------------------------------------------------------------------
                            	  1322: ; Concatonate strings, for the '+' operator.
                            	  1323: ;
                            	  1324: ; Parameters:
                            	  1325: ;		fp0 = holds string descriptor for second string
                            	  1326: ;		fp1 = holds string descriptor for first string
                            	  1327: ;	Returns:
                            	  1328: ;		fp0 = string descriptor for combined strings
                            	  1329: ;-------------------------------------------------------------------------------
                            	  1330: 
                            	  1331: ConcatString:
02:00004914 F239688000040600	  1332: 	fmove.x fp1,_fpWork		; save first string descriptor to memory
02:0000491C F239680000040610	  1333: 	fmove.x fp0,_fpWork+16; save second string descriptor to memory
02:00004924 343900040600    	  1334: 	move.w _fpWork,d2			; d2 = length of first string
02:0000492A D47900040610    	  1335: 	add.w	_fpWork+16,d2		; add length of second string
02:00004930 48C2            	  1336: 	ext.l d2							; make d2 a long word
02:00004932 61000164        	  1337: 	bsr AllocateString		; allocate
02:00004936 2849            	  1338: 	move.l a1,a4					; a4 = allocated string, saved for later
02:00004938 2449            	  1339: 	move.l a1,a2					; a2 = allocated string
02:0000493A 3542FFFE        	  1340: 	move.w d2,-2(a2)			; save length of new string (a2)
02:0000493E 227900040604    	  1341: 	move.l _fpWork+4,a1		; a1 = pointer to string text of first string
02:00004944 2649            	  1342: 	move.l a1,a3					; compute pointer to end of first string
02:00004946 363900040600    	  1343: 	move.w _fpWork,d3			; d3 = length of first string
02:0000494C 48C3            	  1344: 	ext.l d3
02:0000494E D7C3            	  1345: 	add.l d3,a3						; add length of first string
02:00004950 61000786        	  1346: 	bsr MVUP							; move from A1 to A2 until A1=A3
02:00004954 227900040614    	  1347: 	move.l _fpWork+20,a1	; a1 = pointer to second string text
02:0000495A 2649            	  1348: 	move.l a1,a3
02:0000495C 363900040610    	  1349: 	move.w _fpWork+16,d3	; d3 = length of second string
02:00004962 48C3            	  1350: 	ext.l d3
02:00004964 D7C3            	  1351: 	add.l d3,a3						; a3 points to end of second string
02:00004966 61000770        	  1352: 	bsr MVUP							; concatonate on second string
02:0000496A 33C200040600    	  1353: 	move.w d2,_fpWork			; save total string length in fp work
02:00004970 23CC00040604    	  1354: 	move.l a4,_fpWork+4		; save pointer in fp work area
02:00004976 7002            	  1355: 	moveq #DT_STRING,d0		; set return data type = string
02:00004978 F239480000040600	  1356: 	fmove.x _fpWork,fp0		; fp0 = string descriptor
02:00004980 4E75            	  1357: 	rts
                            	  1358: 
                            	  1359: ;-------------------------------------------------------------------------------
                            	  1360: ; Multiply / Divide operator level, *,/,mod
                            	  1361: ;-------------------------------------------------------------------------------
                            	  1362: 
                            	  1363: EXPR3
02:00004982 6168            	  1364: 	bsr	EXPR4					; get first <EXPR4>
                            	  1365: XP36
02:00004984 6100FDCC        	  1366: 	bsr XP_PUSH
                            	  1367: XP30
02:00004988 43FAF71E        	  1368: 	lea TAB11,a1
02:0000498C 45FAF802        	  1369: 	lea TAB11_1,a2
02:00004990 6000F816        	  1370: 	bra EXEC
                            	  1371: XP31
02:00004994 61000860        	  1372: 	bsr	TSTC					; multiply?
02:00004998 2A              	  1373: 	dc.b	'*',XP34-*
02:00004999 11
02:0000499A 6150            	  1374: 	bsr	EXPR4					; get second <EXPR4>
02:0000499C 6100FDE0        	  1375: 	bsr XP_POP1
02:000049A0 6100FE66        	  1376: 	bsr CheckNumeric
02:000049A4 F2000423        	  1377: 	fmul fp1,fp0			; multiply the two
02:000049A8 60DA            	  1378: 	bra	XP36					; then look for more terms
                            	  1379: XP34
02:000049AA 6100084A        	  1380: 	bsr	TSTC					; divide?
02:000049AE 2F              	  1381: 	dc.b	'/',XP35-*
02:000049AF 15
02:000049B0 613A            	  1382: 	bsr	EXPR4					; get second <EXPR4>
02:000049B2 6100FDCA        	  1383: 	bsr XP_POP1
02:000049B6 6100FE50        	  1384: 	bsr CheckNumeric
02:000049BA F20000A0        	  1385: 	fdiv fp0,fp1			; do the division
02:000049BE F2000400        	  1386: 	fmove fp1,fp0
02:000049C2 60C0            	  1387: 	bra	XP36					; go back for any more terms
                            	  1388: XP35
02:000049C4 6100FDA2        	  1389: 	bsr XP_POP
02:000049C8 4E75            	  1390: 	rts
                            	  1391: XP_MOD:
02:000049CA 6120            	  1392: 	bsr EXPR4
02:000049CC 6100FDB0        	  1393: 	bsr XP_POP1
02:000049D0 F20000A0        	  1394: 	fdiv fp0,fp1			; divide
02:000049D4 F2006080        	  1395: 	fmove.l fp1,d0		; convert to integer
02:000049D8 F2004180        	  1396: 	fmove.l d0,fp3		; convert back to float
02:000049DC F20001A3        	  1397: 	fmul fp0,fp3			; multiply quotient times divisor
02:000049E0 F2000CA8        	  1398: 	fsub fp3,fp1			; subtract from original number
02:000049E4 F2000400        	  1399: 	fmove.x fp1,fp0		; return difference in fp0
02:000049E8 7001            	  1400: 	moveq #DT_NUMERIC,d0
02:000049EA 6098            	  1401: 	bra XP36					; go back and check for more multiply ops
                            	  1402: 	
                            	  1403: ;-------------------------------------------------------------------------------
                            	  1404: ; Lowest Level of expression evaluation.
                            	  1405: ;	Check for
                            	  1406: ;		a function or
                            	  1407: ;		a variable or
                            	  1408: ;		a number or
                            	  1409: ;		a string or
                            	  1410: ;		( expr )
                            	  1411: ;-------------------------------------------------------------------------------
                            	  1412: 
                            	  1413: EXPR4
02:000049EC 43FAF66E        	  1414: 	LEA	TAB4,A1 			; find possible function
02:000049F0 45FAF72E        	  1415: 	LEA	TAB4_1,A2
02:000049F4 6000F7B2        	  1416: 	BRA	EXEC
                            	  1417: XP40
02:000049F8 61000236        	  1418: 	bsr	TSTV					; nope, not a function
02:000049FC 650C            	  1419: 	bcs	XP41					; nor a variable
02:000049FE 2240            	  1420: 	move.l d0,a1			; a1 = variable address
02:00004A00 2011            	  1421: 	move.l (a1),d0		; return type in d0
02:00004A02 F22948000004    	  1422: 	fmove.x 4(a1),fp0	; if a variable, return its value in fp0
                            	  1423: EXP4RT
02:00004A08 4E75            	  1424: 	rts
                            	  1425: XP41
02:00004A0A 61000802        	  1426: 	bsr	TSTNUM				; or is it a number?
02:00004A0E F2000400        	  1427: 	fmove fp1,fp0
02:00004A12 0C8000000001    	  1428: 	cmpi.l #DT_NUMERIC,d0
02:00004A18 67EE            	  1429: 	beq	EXP4RT				; if so, return it in FP0
                            	  1430: XPSTNG
02:00004A1A 610007DA        	  1431: 	bsr TSTC					; is it a string constant?
02:00004A1E 22              	  1432: 	dc.b '"',XP44-*
02:00004A1F 57
02:00004A20 163C0022        	  1433: 	move.b #'"',d3
                            	  1434: XP45
02:00004A24 2248            	  1435: 	move.l a0,a1			; record start of string in a1
02:00004A26 243C000001FF    	  1436: 	move.l #511,d2		; max 512 characters
                            	  1437: .0003	
02:00004A2C 1018            	  1438: 	move.b (a0)+,d0		; get a character
02:00004A2E 670E            	  1439: 	beq .0001					; should not be a NULL
02:00004A30 0C00000D        	  1440: 	cmpi.b #CR,d0			; CR means the end of line was hit without a close quote
02:00004A34 6708            	  1441: 	beq .0001
02:00004A36 B003            	  1442: 	cmp.b d3,d0				; close quote?
02:00004A38 6708            	  1443: 	beq .0002
02:00004A3A 51CAFFF0        	  1444: 	dbra d2,.0003			; no close quote, go back for next char
                            	  1445: .0001
02:00004A3E 600005B6        	  1446: 	bra QHOW
                            	  1447: .0002
02:00004A42 2008            	  1448: 	move.l a0,d0				; d0 = end of string pointer
02:00004A44 9089            	  1449: 	sub.l a1,d0					; compute string length + 1
02:00004A46 5340            	  1450: 	subq #1,d0					; subtract out closing quote
02:00004A48 2400            	  1451: 	move.l d0,d2				; d2 = string length
02:00004A4A 2649            	  1452: 	move.l a1,a3				; a3 = pointer to string text
02:00004A4C 614A            	  1453: 	bsr AllocateString
02:00004A4E 2449            	  1454: 	move.l a1,a2				; a2 points to new text area
02:00004A50 2849            	  1455: 	move.l a1,a4				; save a1 for later
02:00004A52 224B            	  1456: 	move.l a3,a1				; a1 = pointer to string in program
02:00004A54 3542FFFE        	  1457: 	move.w d2,-2(a2)		; copy length into place
02:00004A58 D7C2            	  1458: 	add.l d2,a3					; a3 points to end of string
02:00004A5A 6100067C        	  1459: 	bsr MVUP						; move from A1 to A2 until A1=A3
02:00004A5E 33C200040600    	  1460: 	move.w d2,_fpWork		; copy length into place
02:00004A64 23CC00040604    	  1461: 	move.l a4,_fpWork+4	; copy pointer to text into place
02:00004A6A F239480000040600	  1462: 	fmove.x _fpWork,fp0	; put string descriptor into fp0
02:00004A72 7002            	  1463: 	moveq #DT_STRING,d0	; return string data type
02:00004A74 4E75            	  1464: 	rts
                            	  1465: XP44
02:00004A76 6100077E        	  1466: 	bsr TSTC					; alternate string constant?
02:00004A7A 27              	  1467: 	dc.b '''',PARN-*
02:00004A7B 07
02:00004A7C 163C0027        	  1468: 	move.b #'''',d3
02:00004A80 60A2            	  1469: 	bra XP45
                            	  1470: PARN
02:00004A82 61000772        	  1471: 	bsr	TSTC					; else look for ( EXPR )
02:00004A86 28              	  1472: 	dc.b '(',XP43-*
02:00004A87 0D
02:00004A88 6100FD2A        	  1473: 	bsr	EXPR
02:00004A8C 61000768        	  1474: 	bsr	TSTC
02:00004A90 29              	  1475: 	dc.b ')',XP43-*
02:00004A91 03
                            	  1476: XP42	
02:00004A92 4E75            	  1477: 	rts
                            	  1478: XP43
02:00004A94 60000518        	  1479: 	bra	QWHAT					; else say "What?"
                            	  1480: 
                            	  1481: ;-------------------------------------------------------------------------------	
                            	  1482: ; Allocate storage for a string variable.
                            	  1483: ;
                            	  1484: ; Parameters:
                            	  1485: ;		d2 = number of bytes needed
                            	  1486: ; Returns:
                            	  1487: ;		a1 = pointer to string text area
                            	  1488: ;-------------------------------------------------------------------------------	
                            	  1489: 
                            	  1490: AllocateString:
02:00004A98 48E7383C        	  1491: 	movem.l d2-d4/a2-a5,-(sp)
02:00004A9C 283A0962        	  1492: 	move.l VARBGN,d4
02:00004AA0 227A0956        	  1493: 	move.l LastStr,a1			; a1 = last string
02:00004AA4 3611            	  1494: 	move.w (a1),d3				; d3 = length of last string (0)
02:00004AA6 48C3            	  1495: 	ext.l d3
02:00004AA8 9883            	  1496: 	sub.l d3,d4						; subtract off length
02:00004AAA 5784            	  1497: 	subq.l #3,d4					; size of length field+1 for rounding
02:00004AAC 9889            	  1498: 	sub.l a1,d4						; and start position
02:00004AAE B484            	  1499: 	cmp.l d4,d2						; is there enough room?
02:00004AB0 6224            	  1500: 	bhi .needMoreRoom
                            	  1501: .0001
02:00004AB2 227A0944        	  1502: 	move.l LastStr,a1
02:00004AB6 2649            	  1503: 	move.l a1,a3
02:00004AB8 5489            	  1504: 	addq.l #2,a1					; point a1 to text part of string
02:00004ABA 3682            	  1505: 	move.w d2,(a3)				; save the length
02:00004ABC D7C2            	  1506: 	add.l d2,a3
02:00004ABE 568B            	  1507: 	addq.l #3,a3					; 2 for length field, 1 for rounding
02:00004AC0 260B            	  1508: 	move.l a3,d3
02:00004AC2 0283FFFFFFFE    	  1509: 	andi.l #$FFFFFFFE,d3	; make pointer even wyde
02:00004AC8 23CB000053F8    	  1510: 	move.l a3,LastStr			; set new last str position
02:00004ACE 4253            	  1511: 	clr.w (a3)						; set zero length
02:00004AD0 4CDF3C1C        	  1512: 	movem.l (sp)+,d2-d4/a2-a5
02:00004AD4 4E75            	  1513: 	rts
                            	  1514: .needMoreRoom
02:00004AD6 611E            	  1515: 	bsr GarbageCollectStrings
02:00004AD8 283A0926        	  1516: 	move.l VARBGN,d4			; d4 = start of variables
02:00004ADC 227A091A        	  1517: 	move.l LastStr,a1			; a1 = pointer to last string
02:00004AE0 3611            	  1518: 	move.w (a1),d3				; d3 = length of last string (likely 0)
02:00004AE2 48C3            	  1519: 	ext.l d3
02:00004AE4 D689            	  1520: 	add.l a1,d3						; d3 = pointer past end of last string
02:00004AE6 5683            	  1521: 	addq.l #3,d3					; 2 for length, 1 for rounding
02:00004AE8 9883            	  1522: 	sub.l d3,d4						; free = VARBGN - LastStr+length of (LastStr)
02:00004AEA B484            	  1523: 	cmp.l d4,d2						; request < free?
02:00004AEC 65C4            	  1524: 	blo .0001
02:00004AEE 4DFA089C        	  1525: 	lea NOSTRING,a6
02:00004AF2 600004C0        	  1526: 	bra ERROR
                            	  1527: 		
                            	  1528: ;-------------------------------------------------------------------------------	
                            	  1529: ; Garbage collect strings. This copies all strings in use to the lower end of
                            	  1530: ; the string area and adjusts the string pointers in variables and on the
                            	  1531: ; stack to point to the new location.
                            	  1532: ;
                            	  1533: ; Modifies:
                            	  1534: ;		none
                            	  1535: ;-------------------------------------------------------------------------------	
                            	  1536: 
                            	  1537: GarbageCollectStrings:
02:00004AF6 48E70074        	  1538: 	movem.l a1/a2/a3/a5,-(sp)
02:00004AFA 227A08F8        	  1539: 	move.l StrArea,a1			; source area pointer
02:00004AFE 247A08F4        	  1540: 	move.l StrArea,a2			; target area pointer
02:00004B02 2A7A08F4        	  1541: 	move.l LastStr,a5
                            	  1542: .0001
02:00004B06 6140            	  1543: 	bsr StringInVar				; check if the string is used by a variable
02:00004B08 6506            	  1544: 	bcs .moveString
02:00004B0A 610000A6        	  1545: 	bsr StringOnStack			; check if string is on string expression stack
02:00004B0E 641C            	  1546: 	bcc .nextString				; if not on stack or in a var then move to next string
                            	  1547: 	
                            	  1548: 	; The string is in use, copy to active string area
                            	  1549: .moveString:
02:00004B10 610000D0        	  1550: 	bsr UpdateStringPointers	; update pointer to string on stack or in variable
02:00004B14 611C            	  1551: 	bsr NextString				; a3 = pointer to next string
02:00004B16 610005CA        	  1552: 	bsr MVUPW							; will copy the length and string text
                            	  1553: .0005
02:00004B1A B3CD            	  1554: 	cmp.l a5,a1						; is it the last string?
02:00004B1C 63E8            	  1555: 	bls .0001
02:00004B1E 23CA000053F8    	  1556: 	move.l a2,LastStr			; update last string pointer
02:00004B24 4252            	  1557: 	clr.w (a2)						; set zero length
02:00004B26 4CDF2E00        	  1558: 	movem.l (sp)+,a1/a2/a3/a5
02:00004B2A 4E75            	  1559: 	rts
                            	  1560: .nextString:
02:00004B2C 6104            	  1561: 	bsr NextString
02:00004B2E 224B            	  1562: 	move.l a3,a1
02:00004B30 60E8            	  1563: 	bra .0005
                            	  1564: 
                            	  1565: ;-------------------------------------------------------------------------------	
                            	  1566: ; Parameters:
                            	  1567: ;		a1 - pointer to current string
                            	  1568: ; Returns:
                            	  1569: ;		a3 - pointer to next string
                            	  1570: ;-------------------------------------------------------------------------------	
                            	  1571: 
                            	  1572: NextString:
02:00004B32 2F04            	  1573: 	move.l d4,-(sp)
02:00004B34 3811            	  1574: 	move.w (a1),d4				; d4 = string length
02:00004B36 48C4            	  1575: 	ext.l d4							; make d4 long
02:00004B38 5684            	  1576: 	addq.l #3,d4					; plus 2 for length field, 1 for rounding
02:00004B3A D889            	  1577: 	add.l a1,d4
02:00004B3C 0284FFFFFFFE    	  1578: 	andi.l #$FFFFFFFE,d4	; make even wyde address
02:00004B42 2644            	  1579: 	move.l d4,a3
02:00004B44 281F            	  1580: 	move.l (sp)+,d4
02:00004B46 4E75            	  1581: 	rts
                            	  1582: 
                            	  1583: ;-------------------------------------------------------------------------------	
                            	  1584: ; Check if a variable is using a string
                            	  1585: ;
                            	  1586: ; Modifies:
                            	  1587: ;		d2,d3,a4
                            	  1588: ; Parameters:
                            	  1589: ;		a1 = pointer to string descriptor
                            	  1590: ; Returns:
                            	  1591: ;		cf = 1 if string in use, 0 otherwise
                            	  1592: ;-------------------------------------------------------------------------------	
                            	  1593: 
                            	  1594: StringInVar:
                            	  1595: 	; check global vars
02:00004B48 287A08B6        	  1596: 	move.l VARBGN,a4
02:00004B4C 761F            	  1597: 	moveq #31,d3			; 32 vars
02:00004B4E 6116            	  1598: 	bsr SIV1
                            	  1599: 	; now check local vars
02:00004B50 287A0866        	  1600: 	move.l STKFP,a4
                            	  1601: .0001
02:00004B54 588C            	  1602: 	addq.l #4,a4			; point to variable area
02:00004B56 7607            	  1603: 	moveq #7,d3
02:00004B58 610C            	  1604: 	bsr SIV1					; check variable area
02:00004B5A 286CFFFC        	  1605: 	move.l -4(a4),a4	; get previous frame pointer
02:00004B5E B9FAF32E        	  1606: 	cmp.l ENDMEM,a4
02:00004B62 65F0            	  1607: 	blo .0001
02:00004B64 4E75            	  1608: 	rts
                            	  1609: 
                            	  1610: ;-------------------------------------------------------------------------------	
                            	  1611: ; SIV1 - string in variable helper. This routine does a two-up return if the
                            	  1612: ; string is found in a variable. No need to keep searching.
                            	  1613: ;
                            	  1614: ; Modifies:
                            	  1615: ;		d2,d3,a4
                            	  1616: ; Parameters:
                            	  1617: ;		d3 = number of variables-1 to check
                            	  1618: ;		a4 = string space
                            	  1619: ;		a1 = pointer to string descriptor
                            	  1620: ; Returns:
                            	  1621: ;		cf = 1 if string in use, 0 otherwise
                            	  1622: ;-------------------------------------------------------------------------------	
                            	  1623: 
                            	  1624: SIV1:
                            	  1625: .0003
02:00004B66 0C9400000002    	  1626: 	cmp.l #DT_STRING,(a4)
02:00004B6C 6612            	  1627: 	bne .0004
02:00004B6E 242C0008        	  1628: 	move.l 8(a4),d2
02:00004B72 5582            	  1629: 	subq.l #2,d2
02:00004B74 B3C2            	  1630: 	cmp.l d2,a1
02:00004B76 6608            	  1631: 	bne .0004
02:00004B78 588F            	  1632: 	addq.l #4,sp			; pop return address
02:00004B7A 003C0001        	  1633: 	ori #1,ccr
02:00004B7E 4E75            	  1634: 	rts								; do two up return
                            	  1635: .0004
02:00004B80 508C            	  1636: 	addq.l #8,a4			;  increment pointer by 16
02:00004B82 508C            	  1637: 	addq.l #8,a4
02:00004B84 51CBFFE0        	  1638: 	dbra d3,.0003
02:00004B88 023C00FE        	  1639: 	andi #$FE,ccr
02:00004B8C 4E75            	  1640: 	rts
                            	  1641: 
                            	  1642: ;-------------------------------------------------------------------------------	
                            	  1643: ; Check if a value could be a pointer into the string area.
                            	  1644: ; Even if the data type indicated a string, it may not be. It could just be a
                            	  1645: ; coincidence. So check that the pointer portion is pointing into string
                            	  1646: ; memory. It is extremely unlikely to have a data type and a valid pointer
                            	  1647: ; match and it not be a string.
                            	  1648: ;
                            	  1649: ; Returns
                            	  1650: ;		d3 = pointer to string
                            	  1651: ;		cf=1 if points into string area, 0 otherwise
                            	  1652: ;-------------------------------------------------------------------------------	
                            	  1653: 
                            	  1654: PointsIntoStringArea:
02:00004B8E 0C9400000002    	  1655: 	cmp.l #DT_STRING,(a4)		; is it a string data type?
02:00004B94 6616            	  1656: 	bne .0001
02:00004B96 262C0008        	  1657: 	move.l 8(a4),d3					; likely a string if
02:00004B9A B6BA0858        	  1658: 	cmp.l StrArea,d3				; flagged as a string, and pointer is into string area
02:00004B9E 650C            	  1659: 	blo .0001
02:00004BA0 B6BA085E        	  1660: 	cmp.l VARBGN,d3
02:00004BA4 6406            	  1661: 	bhs .0001
02:00004BA6 003C0001        	  1662: 	ori #1,ccr
02:00004BAA 4E75            	  1663: 	rts
                            	  1664: .0001
02:00004BAC 023C00FE        	  1665: 	andi #$FE,ccr
02:00004BB0 4E75            	  1666: 	rts
                            	  1667: 
                            	  1668: ;-------------------------------------------------------------------------------	
                            	  1669: ; Check if the string is a temporary on stack
                            	  1670: ;
                            	  1671: ; Parameters:
                            	  1672: ;		a3 = pointer to old string text area
                            	  1673: ; Returns:
                            	  1674: ;		cf = 1 if string in use, 0 otherwise
                            	  1675: ;-------------------------------------------------------------------------------	
                            	  1676: 
                            	  1677: StringOnStack:
02:00004BB2 48E72028        	  1678: 	movem.l d2/a2/a4,-(sp)
02:00004BB6 7607            	  1679: 	moveq #7,d3
02:00004BB8 284F            	  1680: 	move.l sp,a4
                            	  1681: .0002
02:00004BBA 61D2            	  1682: 	bsr PointsIntoStringArea
02:00004BBC 6408            	  1683: 	bcc .0003
02:00004BBE 242C0008        	  1684: 	move.l 8(a4),d2			; d2 = string text pointer
02:00004BC2 B7C2            	  1685: 	cmp.l d2,a3					; compare string pointers
02:00004BC4 6712            	  1686: 	beq .0001						; same pointer?
                            	  1687: .0003
02:00004BC6 588C            	  1688: 	addq.l #4,a4				; bump pointer into stack
02:00004BC8 B9FAF2C4        	  1689: 	cmp.l ENDMEM,a4			; have we hit end of stack yet?
02:00004BCC 65EC            	  1690: 	blo .0002
02:00004BCE 4CDF1404        	  1691: 	movem.l (sp)+,d2/a2/a4
02:00004BD2 023C00FE        	  1692: 	andi #$FE,ccr
02:00004BD6 4E75            	  1693: 	rts
                            	  1694: .0001
02:00004BD8 4CDF1404        	  1695: 	movem.l (sp)+,d2/a2/a4
02:00004BDC 003C0001        	  1696: 	ori #1,ccr
02:00004BE0 4E75            	  1697: 	rts
                            	  1698: 	
                            	  1699: ;-------------------------------------------------------------------------------	
                            	  1700: ; Update pointers to string to point to new area. All string areas must be
                            	  1701: ; completely checked because there may be more than one pointer to the string.
                            	  1702: ;
                            	  1703: ; Modifies:
                            	  1704: ;		d2,d3,d4,a4
                            	  1705: ; Parameters:
                            	  1706: ;		a1 = old pointer to string
                            	  1707: ;		a2 = new pointer to string
                            	  1708: ;-------------------------------------------------------------------------------	
                            	  1709: 
                            	  1710: UpdateStringPointers:
02:00004BE2 2F0B            	  1711: 	move.l a3,-(sp)
02:00004BE4 47E90002        	  1712: 	lea 2(a1),a3						; a3 points to old string text area
                            	  1713: 	; check global variable space
02:00004BE8 287A0816        	  1714: 	move.l VARBGN,a4
02:00004BEC 761F            	  1715: 	moveq #31,d3						; 32 vars to check
02:00004BEE 611E            	  1716: 	bsr USP1
                            	  1717: 	; check stack for strings
02:00004BF0 284F            	  1718: 	move.l sp,a4						; start at stack bottom and work towards top
                            	  1719: .0002
02:00004BF2 619A            	  1720: 	bsr PointsIntoStringArea
02:00004BF4 640C            	  1721: 	bcc .0001
                            	  1722: 	; Here we probably have a string, one last check
02:00004BF6 B68A            	  1723: 	cmp.l a2,d3							; should be >= a2 as we are packing the space
02:00004BF8 6508            	  1724: 	blo .0001
02:00004BFA 294A0008        	  1725: 	move.l a2,8(a4)					; update pointer on stack with new address
02:00004BFE 546C0008        	  1726: 	addi.w #2,8(a4)					; bump up to text part of string
                            	  1727: .0001
02:00004C02 588C            	  1728: 	addq.l #4,a4
02:00004C04 B9FAF288        	  1729: 	cmp.l ENDMEM,a4
02:00004C08 65E8            	  1730: 	blo .0002
02:00004C0A 265F            	  1731: 	move.l (sp)+,a3
02:00004C0C 4E75            	  1732: 	rts
                            	  1733: 
                            	  1734: ;-------------------------------------------------------------------------------	
                            	  1735: ; Both global and local variable spaces are updated in the same manner.
                            	  1736: ;
                            	  1737: ; Parameters:
                            	  1738: ;		a1 = old pointer to string
                            	  1739: ;		a2 = new pointer to string
                            	  1740: ;		a4 = start of string space
                            	  1741: ;		d3 = number of string variables
                            	  1742: ;-------------------------------------------------------------------------------	
                            	  1743: 
                            	  1744: USP1:
                            	  1745: .0002
02:00004C0E 0C9400000002    	  1746: 	cmp.l #DT_STRING,(a4)		; check the data type
02:00004C14 6610            	  1747: 	bne .0001								; not a string, go to next
02:00004C16 242C0008        	  1748: 	move.l 8(a4),d2					; d2 = pointer to string text
02:00004C1A B7C2            	  1749: 	cmp.l d2,a3							; does pointer match old pointer?
02:00004C1C 6608            	  1750: 	bne .0001
02:00004C1E 294A0008        	  1751: 	move.l a2,8(a4)					; copy in new pointer
02:00004C22 54AC0008        	  1752: 	addi.l #2,8(a4)					; point to string text
                            	  1753: .0001
02:00004C26 508C            	  1754: 	addq.l #8,a4						; increment pointer by 16
02:00004C28 508C            	  1755: 	addq.l #8,a4
02:00004C2A 51CBFFE2        	  1756: 	dbra d3,.0002
02:00004C2E 4E75            	  1757: 	rts
                            	  1758: 
                            	  1759: ;-------------------------------------------------------------------------------	
                            	  1760: ; ===== Test for a valid variable name.  Returns Carry=1 if not
                            	  1761: ;	found, else returns Carry=0 and the address of the
                            	  1762: ;	variable in D0.
                            	  1763: 
                            	  1764: TSTV:
02:00004C30 61000628        	  1765: 	bsr	IGNBLK
02:00004C34 7000            	  1766: 	CLR.L	D0
02:00004C36 1010            	  1767: 	MOVE.B (A0),D0 	 	; look at the program text
02:00004C38 903C0040        	  1768: 	SUB.B	#'@',D0
02:00004C3C 6572            	  1769: 	BCS	TSTVRT				; C=1: not a variable
02:00004C3E 6638            	  1770: 	BNE	TV1						; branch if not "@" array
02:00004C40 5248            	  1771: 	ADDQ #1,A0				; If it is, it should be
02:00004C42 6100FE3E        	  1772: 	BSR	PARN					; followed by (EXPR) as its index.
02:00004C46 D080            	  1773: 	ADD.L	D0,D0
02:00004C48 650003AC        	  1774: 	BCS	QHOW					; say "How?" if index is too big
02:00004C4C D080            	  1775: 	ADD.L	D0,D0
02:00004C4E 650003A6        	  1776: 	BCS	QHOW
02:00004C52 D080            	  1777: 	ADD.L	D0,D0
02:00004C54 650003A0        	  1778: 	BCS	QHOW
02:00004C58 D080            	  1779: 	ADD.L	D0,D0
02:00004C5A 6500039A        	  1780: 	BCS	QHOW
02:00004C5E 2F00            	  1781: 	move.l d0,-(sp)		; save the index
02:00004C60 6100012A        	  1782: 	bsr	SIZE					; get amount of free memory
02:00004C64 221F            	  1783: 	move.l (sp)+,d1		; get back the index
02:00004C66 F2006000        	  1784: 	fmove.l fp0,d0		; convert to integer
02:00004C6A B081            	  1785: 	cmp.l	d1,d0				; see if there's enough memory
02:00004C6C 63000380        	  1786: 	bls	QSORRY				; if not, say "Sorry"
02:00004C70 203A078E        	  1787: 	move.l VARBGN,d0	; put address of array element...
02:00004C74 9081            	  1788: 	sub.l	d1,d0				; into D0
02:00004C76 4E75            	  1789: 	rts
                            	  1790: TV1
02:00004C78 B03C001B        	  1791: 	CMP.B	#27,D0			; if not @, is it A through Z?
02:00004C7C 0A3C0001        	  1792: 	EOR	#1,CCR
02:00004C80 652E            	  1793: 	BCS	TSTVRT				; if not, set Carry and return
02:00004C82 5248            	  1794: 	ADDQ #1,A0				; else bump the text pointer
02:00004C84 0C00004C        	  1795: 	cmpi.b #'L',d0		; is it a local? L0 to L7
02:00004C88 661E            	  1796: 	bne TV2
02:00004C8A 1010            	  1797: 	move.b (a0),d0
02:00004C8C 0C000030        	  1798: 	cmpi.b #'0',d0
02:00004C90 6516            	  1799: 	blo TV2
02:00004C92 0C000037        	  1800: 	cmpi.b #'7',d0
02:00004C96 6210            	  1801: 	bhi TV2
02:00004C98 903C0030        	  1802: 	sub.b #'0',d0
02:00004C9C 5248            	  1803: 	addq #1,a0			; bump text pointer
02:00004C9E E988            	  1804: 	lsl.l #4,d0			; *16 bytes per var
02:00004CA0 D0BA0716        	  1805: 	add.l STKFP,d0
02:00004CA4 5880            	  1806: 	add.l #4,d0
02:00004CA6 4E75            	  1807: 	rts
                            	  1808: TV2
02:00004CA8 E988            	  1809: 	LSL.L #4,D0			; compute the variable's address
02:00004CAA 223A0754        	  1810: 	MOVE.L VARBGN,D1
02:00004CAE D081            	  1811: 	ADD.L	D1,D0			; and return it in D0 with Carry=0
                            	  1812: TSTVRT
02:00004CB0 4E75            	  1813: 	RTS
                            	  1814: 
                            	  1815: 
                            	  1816: * ===== Divide the 32 bit value in D0 by the 32 bit value in D1.
                            	  1817: *	Returns the 32 bit quotient in D0, remainder in D1.
                            	  1818: *
                            	  1819: DIV32
02:00004CB2 4A81            	  1820: 	TST.L	D1		check for divide-by-zero
02:00004CB4 67000340        	  1821: 	BEQ	QHOW		if so, say "How?"
02:00004CB8 2401            	  1822: 	MOVE.L	D1,D2
02:00004CBA 2801            	  1823: 	MOVE.L	D1,D4
02:00004CBC B184            	  1824: 	EOR.L	D0,D4		see if the signs are the same
02:00004CBE 4A80            	  1825: 	TST.L	D0		take absolute value of D0
02:00004CC0 6A02            	  1826: 	BPL	DIV1
02:00004CC2 4480            	  1827: 	NEG.L	D0
02:00004CC4 4A81            	  1828: DIV1	TST.L	D1		take absolute value of D1
02:00004CC6 6A02            	  1829: 	BPL	DIV2
02:00004CC8 4481            	  1830: 	NEG.L	D1
02:00004CCA 761F            	  1831: DIV2	MOVEQ	#31,D3		iteration count for 32 bits
02:00004CCC 2200            	  1832: 	MOVE.L	D0,D1
02:00004CCE 7000            	  1833: 	CLR.L	D0
02:00004CD0 D281            	  1834: DIV3	ADD.L	D1,D1		(This algorithm was translated from
02:00004CD2 D180            	  1835: 	ADDX.L	D0,D0		; the divide routine in Ron Cain's
02:00004CD4 6708            	  1836: 	BEQ	DIV4		Small-C run time library.)
02:00004CD6 B082            	  1837: 	CMP.L	D2,D0
02:00004CD8 6B04            	  1838: 	BMI	DIV4
02:00004CDA 5281            	  1839: 	ADDQ.L	#1,D1
02:00004CDC 9082            	  1840: 	SUB.L	D2,D0
02:00004CDE 51CBFFF0        	  1841: DIV4	DBRA	D3,DIV3
02:00004CE2 C141            	  1842: 	EXG	D0,D1		put rem. & quot. in proper registers
02:00004CE4 4A84            	  1843: 	TST.L	D4		were the signs the same?
02:00004CE6 6A04            	  1844: 	BPL	DIVRT
02:00004CE8 4480            	  1845: 	NEG.L	D0		if not, results are negative
02:00004CEA 4481            	  1846: 	NEG.L	D1
02:00004CEC 4E75            	  1847: DIVRT	RTS
                            	  1848: 
                            	  1849: 
                            	  1850: ; ===== The PEEK function returns the byte stored at the address
                            	  1851: ;	contained in the following expression.
                            	  1852: 
                            	  1853: PEEK
02:00004CEE 1E3C0042        	  1854: 	MOVE.B #'B',d7
02:00004CF2 1210            	  1855: 	MOVE.B (a0),d1
02:00004CF4 0C01002E        	  1856: 	CMPI.B #'.',d1
02:00004CF8 6604            	  1857: 	BNE .0001
02:00004CFA 5248            	  1858: 	ADDQ #1,a0
02:00004CFC 1E18            	  1859: 	move.b (a0)+,d7
                            	  1860: .0001
02:00004CFE 6100FD82        	  1861: 	BSR	PARN		get the memory address
02:00004D02 0C8000000001    	  1862: 	cmpi.l #DT_NUMERIC,d0
02:00004D08 660002F4        	  1863: 	bne ETYPE
02:00004D0C F2006000        	  1864: 	FMOVE.L FP0,D0
02:00004D10 2240            	  1865: 	MOVE.L D0,A1
02:00004D12 0C070042        	  1866: 	cmpi.b #'B',d7
02:00004D16 660C            	  1867: 	bne .0002
                            	  1868: .0005
02:00004D18 7000            	  1869: 	CLR.L	D0				; upper 3 bytes will be zero
02:00004D1A 1011            	  1870: 	MOVE.B (A1),D0
02:00004D1C F2005800        	  1871: 	FMOVE.B	D0,FP0 	; get the addressed byte
02:00004D20 7001            	  1872: 	moveq #DT_NUMERIC,d0					; data type is a number
02:00004D22 4E75            	  1873: 	RTS							; and return it
                            	  1874: .0002
02:00004D24 0C070057        	  1875: 	cmpi.b #'W',d7
02:00004D28 660C            	  1876: 	bne .0003
02:00004D2A 7000            	  1877: 	CLR.L d0
02:00004D2C 3011            	  1878: 	MOVE.W (A1),D0
02:00004D2E F2005000        	  1879: 	FMOVE.W	D0,FP0	;	get the addressed word
02:00004D32 7001            	  1880: 	moveq #DT_NUMERIC,d0					; data type is a number
02:00004D34 4E75            	  1881: 	RTS							; and return it
                            	  1882: .0003
02:00004D36 0C07004C        	  1883: 	cmpi.b #'L',d7
02:00004D3A 660C            	  1884: 	bne .0004
02:00004D3C 7000            	  1885: 	CLR.L d0
02:00004D3E 2011            	  1886: 	MOVE.L (A1),D0
02:00004D40 F2004000        	  1887: 	FMOVE.L	D0,FP0 	; get the lword
02:00004D44 7001            	  1888: 	moveq #DT_NUMERIC,d0					; data type is a number
02:00004D46 4E75            	  1889: 	RTS							; and return it
                            	  1890: .0004
02:00004D48 0C070046        	  1891: 	cmpi.b #'F',d7
02:00004D4C 66CA            	  1892: 	bne .0005
02:00004D4E F2114800        	  1893: 	FMOVE.X	(A1),FP0 		; get the addressed float
02:00004D52 7001            	  1894: 	moveq #DT_NUMERIC,d0					; data type is a number
02:00004D54 4E75            	  1895: 	RTS			and return it
                            	  1896: 
                            	  1897: ;-------------------------------------------------------------------------------
                            	  1898: ; The RND function returns a random number from 0 to the value of the following
                            	  1899: ; expression in fp0.
                            	  1900: ;-------------------------------------------------------------------------------
                            	  1901: 
                            	  1902: RND:
02:00004D56 6100FD2A        	  1903: 	bsr	PARN								; get the upper limit
02:00004D5A 0C8000000001    	  1904: 	cmpi.l #DT_NUMERIC,d0		; must be numeric
02:00004D60 6600029C        	  1905: 	bne ETYPE
02:00004D64 F200003A        	  1906: 	ftst.x fp0							; it must be positive and non-zero
02:00004D68 F281028C        	  1907: 	fbeq QHOW
02:00004D6C F2940288        	  1908: 	fblt QHOW
02:00004D70 F2000100        	  1909: 	fmove fp0,fp2
02:00004D74 7028            	  1910: 	moveq #40,d0						; function #40 get random float
02:00004D76 4E4F            	  1911: 	trap #15
02:00004D78 F2000823        	  1912: 	fmul fp2,fp0
02:00004D7C 7001            	  1913: 	moveq #DT_NUMERIC,d0		; data type is a number
02:00004D7E 4E75            	  1914: 	rts
                            	  1915: 
                            	  1916: ; ===== The ABS function returns an absolute value in D0.
                            	  1917: 
                            	  1918: ABS:	
02:00004D80 6100FD00        	  1919: 	bsr	PARN			; get the following expr.'s value
02:00004D84 F2000018        	  1920: 	fabs.x fp0
02:00004D88 7001            	  1921: 	moveq #DT_NUMERIC,d0					; data type is a number
02:00004D8A 4E75            	  1922: 	rts
                            	  1923: 
                            	  1924: ; ===== The SIZE function returns the size of free memory in D0.
                            	  1925: 
                            	  1926: SIZE:
02:00004D8C 203A0666        	  1927: 	move.l StrArea,d0		; get the number of free bytes...
02:00004D90 90BA066A        	  1928: 	sub.l	 TXTUNF,d0		; between 'TXTUNF' and 'StrArea'
02:00004D94 F2004000        	  1929: 	fmove.l d0,fp0
02:00004D98 7001            	  1930: 	moveq #DT_NUMERIC,d0	; data type is a number
02:00004D9A 4E75            	  1931: 	rts										; return the number in fp0
                            	  1932: 	
                            	  1933: ; ===== The TICK function returns the processor tick register in D0.
                            	  1934: 
                            	  1935: TICK:
02:00004D9C 4E7A0FF0        	  1936: 	movec tick,d0
02:00004DA0 F2004000        	  1937: 	fmove.l d0,fp0
02:00004DA4 7001            	  1938: 	moveq #DT_NUMERIC,d0					; data type is a number
02:00004DA6 4E75            	  1939: 	rts
                            	  1940: 
                            	  1941: ; ===== The CORENO function returns the core number in D0.
                            	  1942: 
                            	  1943: CORENO:
02:00004DA8 4E7A0FE0        	  1944: 	movec coreno,d0
02:00004DAC F2004000        	  1945: 	fmove.l d0,fp0
02:00004DB0 7001            	  1946: 	moveq #DT_NUMERIC,d0					; data type is a number
02:00004DB2 4E75            	  1947: 	rts
                            	  1948: 
                            	  1949: ;-------------------------------------------------------------------------------
                            	  1950: ; Get a pair of argments for the LEFT$ and RIGHT$ functions.
                            	  1951: ; 	(STRING, NUM)
                            	  1952: ; Returns:
                            	  1953: ;		fp0 = number
                            	  1954: ;		fp1 = string
                            	  1955: ;-------------------------------------------------------------------------------
                            	  1956: 
                            	  1957: LorRArgs:
02:00004DB4 61000440        	  1958: 	bsr	TSTC						; else look for ( STRING EXPR, NUM EXPR )
02:00004DB8 28              	  1959: 	dc.b	'(',LorR1-*
02:00004DB9 33
02:00004DBA 6100F9F8        	  1960: 	bsr	EXPR
02:00004DBE 0C8000000002    	  1961: 	cmpi.l #DT_STRING,d0
02:00004DC4 66000238        	  1962: 	bne ETYPE
02:00004DC8 6100F988        	  1963: 	bsr XP_PUSH
02:00004DCC 61000428        	  1964: 	bsr TSTC
02:00004DD0 2C              	  1965: 	dc.b ',',LorR1-*
02:00004DD1 1B
02:00004DD2 6100F9E0        	  1966: 	bsr EXPR
02:00004DD6 0C8000000001    	  1967: 	cmpi.l #DT_NUMERIC,d0
02:00004DDC 66000220        	  1968: 	bne ETYPE
02:00004DE0 61000414        	  1969: 	bsr	TSTC
02:00004DE4 29              	  1970: 	dc.b	')',LorR1-*
02:00004DE5 07
02:00004DE6 6100F996        	  1971: 	bsr XP_POP1
02:00004DEA 4E75            	  1972: 	rts
                            	  1973: LorR1
02:00004DEC 60000208        	  1974: 	bra QHOW
                            	  1975: 	
                            	  1976: ;-------------------------------------------------------------------------------
                            	  1977: ; MID$ function gets a substring of characters from start position for
                            	  1978: ; requested length.
                            	  1979: ;-------------------------------------------------------------------------------
                            	  1980: 
                            	  1981: MID:
02:00004DF0 61000404        	  1982: 	bsr	TSTC						; look for ( STRING EXPR, NUM EXPR [, NUM_EXPR] )
02:00004DF4 28              	  1983: 	dc.b	'(',MID1-*
02:00004DF5 C1
02:00004DF6 6100F9BC        	  1984: 	bsr	EXPR
02:00004DFA 0C8000000002    	  1985: 	cmpi.l #DT_STRING,d0
02:00004E00 660001FC        	  1986: 	bne ETYPE
02:00004E04 6100F94C        	  1987: 	bsr XP_PUSH
02:00004E08 610003EC        	  1988: 	bsr TSTC
02:00004E0C 2C              	  1989: 	dc.b ',',MID1-*
02:00004E0D A9
02:00004E0E 6100F9A4        	  1990: 	bsr EXPR
02:00004E12 0C8000000001    	  1991: 	cmpi.l #DT_NUMERIC,d0
02:00004E18 660001E4        	  1992: 	bne ETYPE
02:00004E1C 6100F934        	  1993: 	bsr XP_PUSH
02:00004E20 7A02            	  1994: 	moveq #2,d5
02:00004E22 610003D2        	  1995: 	bsr	TSTC
02:00004E26 2C              	  1996: 	dc.b ',',MID2-*
02:00004E27 11
02:00004E28 6100F98A        	  1997: 	bsr EXPR
02:00004E2C 0C8000000001    	  1998: 	cmpi.l #DT_NUMERIC,d0
02:00004E32 660001CA        	  1999: 	bne ETYPE
02:00004E36 7A03            	  2000: 	moveq #3,d5					; d5 indicates 3 params
                            	  2001: MID2
02:00004E38 610003BC        	  2002: 	bsr TSTC
02:00004E3C 29              	  2003: 	dc.b ')',MID1-*
02:00004E3D 79
02:00004E3E 6100F93E        	  2004: 	bsr XP_POP1
02:00004E42 0C050003        	  2005: 	cmpi.b #3,d5				; did we have 3 arguments?
02:00004E46 6708            	  2006: 	beq MID5						; branch if did
02:00004E48 F23C40000000FFFF	  2007: 	fmove.l #$FFFF,fp0	; set length = max
                            	  2008: MID5
02:00004E50 F2000500        	  2009: 	fmove.x fp1,fp2			; fp2 = start pos
02:00004E54 6100F928        	  2010: 	bsr XP_POP1					; fp1 = string descriptor
                            	  2011: ;-------------------------------------------------------------------------------
                            	  2012: ; Perform MID$ function
                            	  2013: ; 	fp1 = string descriptor
                            	  2014: ; 	fp2 = starting position
                            	  2015: ; 	fp0 = length
                            	  2016: ;-------------------------------------------------------------------------------
                            	  2017: DOMID
02:00004E58 F239688000040600	  2018: 	fmove.x fp1,_fpWork	; _fpWork = string descriptor
02:00004E60 F2036100        	  2019: 	fmove.l fp2,d3			; d3 = start pos
02:00004E64 B67900040600    	  2020: 	cmp.w _fpWork,d3		; is start pos < length
02:00004E6A 6400018A        	  2021: 	bhs QHOW
02:00004E6E F2026000        	  2022: 	fmove.l fp0,d2			; d2=length
02:00004E72 D682            	  2023: 	add.l d2,d3					; start pos + length < string length?
02:00004E74 B47900040600    	  2024: 	cmp.w _fpWork,d2
02:00004E7A 6308            	  2025: 	bls MID4
02:00004E7C 343900040600    	  2026: 	move.w _fpWork,d2		; move string length to d2
02:00004E82 48C2            	  2027: 	ext.l d2
                            	  2028: MID4
02:00004E84 6100FC12        	  2029: 	bsr AllocateString	; a1 = pointer to new string
02:00004E88 2449            	  2030: 	move.l a1,a2				; a2 = pointer to new string
02:00004E8A 227900040604    	  2031: 	move.l _fpWork+4,a1	; a1 = pointer to string
02:00004E90 F2036100        	  2032: 	fmove.l fp2,d3			; d3 = start pos
02:00004E94 D3C3            	  2033: 	add.l d3,a1					; a1 = pointer to start pos
02:00004E96 33C200040600    	  2034: 	move.w d2,_fpWork		; length
02:00004E9C 23CA00040604    	  2035: 	move.l a2,_fpWork+4	; prep to return target string
02:00004EA2 2649            	  2036: 	move.l a1,a3				; a3 = pointer to start pos
02:00004EA4 D7C2            	  2037: 	add.l d2,a3					; a3 = pointer to end pos
02:00004EA6 61000230        	  2038: 	bsr MVUP						; move A1 to A2 until A1 = A3
02:00004EAA 7002            	  2039: 	moveq #DT_STRING,d0	; data type is a string
02:00004EAC F239480000040600	  2040: 	fmove.x _fpWork,fp0	; string descriptor in fp0
02:00004EB4 4E75            	  2041: 	rts
                            	  2042: MID1
02:00004EB6 6000013E        	  2043: 	bra QHOW
                            	  2044: 	
                            	  2045: ;-------------------------------------------------------------------------------
                            	  2046: ; LEFT$ function truncates the string after fp0 characters.
                            	  2047: ; Just like MID$ but with a zero starting postion.
                            	  2048: ;-------------------------------------------------------------------------------
                            	  2049: 	
                            	  2050: LEFT:
02:00004EBA 6100FEF8        	  2051: 	bsr LorRArgs				; get arguments
02:00004EBE F23C59000000    	  2052: 	fmove.b #0,fp2			; start pos = 0
02:00004EC4 6092            	  2053: 	bra DOMID
                            	  2054: 
                            	  2055: ;-------------------------------------------------------------------------------
                            	  2056: ; RIGHT$ function gets the rightmost characters.
                            	  2057: ; The start position must be calculated based on the number of characters
                            	  2058: ; requested and the string length.
                            	  2059: ;-------------------------------------------------------------------------------
                            	  2060: 
                            	  2061: RIGHT:
02:00004EC6 6100FEEC        	  2062: 	bsr LorRArgs				; get arguments
02:00004ECA F2026000        	  2063: 	fmove.l fp0,d2			; d2 = required length
02:00004ECE F239688000040600	  2064: 	fmove.x fp1,_fpWork	; _fpWork = string descriptor
02:00004ED6 363900040600    	  2065: 	move.w _fpWork,d3		; d3 = string length
02:00004EDC 48C3            	  2066: 	ext.l d3						; make d3 a long
02:00004EDE B682            	  2067: 	cmp.l d2,d3					; is length > right
02:00004EE0 6202            	  2068: 	bhi .0001
02:00004EE2 7400            	  2069: 	moveq #0,d2					; we want all the characters if length <= right
                            	  2070: .0001
02:00004EE4 9682            	  2071: 	sub.l d2,d3					; d3 = startpos = length - right
02:00004EE6 F2034100        	  2072: 	fmove.l d3,fp2			; fp2 = start position
02:00004EEA 6000FF6C        	  2073: 	bra DOMID
                            	  2074: 
                            	  2075: ;-------------------------------------------------------------------------------
                            	  2076: ; LEN( EXPR ) returns the length of a string expression.
                            	  2077: ;-------------------------------------------------------------------------------
                            	  2078: 
                            	  2079: LEN:
02:00004EEE 6100FB92        	  2080: 	bsr PARN
02:00004EF2 0C8000000002    	  2081: 	cmpi.l #DT_STRING,d0
02:00004EF8 66000104        	  2082: 	bne ETYPE
02:00004EFC F239680000040600	  2083: 	fmove.x fp0,_fpWork
02:00004F04 303900040600    	  2084: 	move.w _fpWork,d0
02:00004F0A 48C0            	  2085: 	ext.l d0
02:00004F0C F2005000        	  2086: 	fmove.w d0,fp0
02:00004F10 7001            	  2087: 	moveq #DT_NUMERIC,d0
02:00004F12 4E75            	  2088: 	rts
                            	  2089: 
                            	  2090: ;-------------------------------------------------------------------------------
                            	  2091: ; INT( EXPR ) returns the integer value of the expression.
                            	  2092: ; the expression must be in the range of a 32-bit integer.
                            	  2093: ;-------------------------------------------------------------------------------
                            	  2094: 
                            	  2095: INT:
02:00004F14 6100FB6C        	  2096: 	bsr PARN
02:00004F18 0C8000000001    	  2097: 	cmpi.l #DT_NUMERIC,d0
02:00004F1E 660000DE        	  2098: 	bne ETYPE
02:00004F22 F2000003        	  2099: 	fintrz fp0,fp0
                            	  2100: ;	fmove.l fp0,d0
                            	  2101: ;	fmove.l d0,fp0
02:00004F26 7001            	  2102: 	moveq #DT_NUMERIC,d0
02:00004F28 4E75            	  2103: 	rts
                            	  2104: 
                            	  2105: 
                            	  2106: ;-------------------------------------------------------------------------------
                            	  2107: ; CHR$( EXPR ) returns a one byte string containing the character.
                            	  2108: ;-------------------------------------------------------------------------------
                            	  2109: 
                            	  2110: CHR:
02:00004F2A 6100FB56        	  2111: 	bsr PARN
02:00004F2E 0C8000000001    	  2112: 	cmpi.l #DT_NUMERIC,d0
02:00004F34 660000C8        	  2113: 	bne ETYPE
02:00004F38 F2006000        	  2114: 	fmove.l fp0,d0
02:00004F3C 7401            	  2115: 	moveq #1,d2
02:00004F3E 6100FB58        	  2116: 	bsr AllocateString
02:00004F42 1280            	  2117: 	move.b d0,(a1)
02:00004F44 42290001        	  2118: 	clr.b 1(a1)
02:00004F48 7002            	  2119: 	moveq #DT_STRING,d0
02:00004F4A 23C900040604    	  2120: 	move.l a1,_fpWork+4
02:00004F50 33FC000100040600	  2121: 	move.w #1,_fpWork
02:00004F58 F239480000040600	  2122: 	fmove.x _fpWork,fp0
02:00004F60 4E75            	  2123: 	rts
                            	  2124: 
                            	  2125: ********************************************************************
                            	  2126: *
                            	  2127: * *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                            	  2128: *
                            	  2129: * 'SETVAL' expects a variable, followed by an equal sign and then
                            	  2130: * an expression.  It evaluates the expression and sets the variable
                            	  2131: * to that value.
                            	  2132: *
                            	  2133: * 'FIN' checks the end of a command.  If it ended with ":",
                            	  2134: * execution continues.	If it ended with a CR, it finds the
                            	  2135: * the next line and continues from there.
                            	  2136: *
                            	  2137: * 'ENDCHK' checks if a command is ended with a CR. This is
                            	  2138: * required in certain commands, such as GOTO, RETURN, STOP, etc.
                            	  2139: *
                            	  2140: * 'ERROR' prints the string pointed to by A0. It then prints the
                            	  2141: * line pointed to by CURRNT with a "?" inserted at where the
                            	  2142: * old text pointer (should be on top of the stack) points to.
                            	  2143: * Execution of Tiny BASIC is stopped and a warm start is done.
                            	  2144: * If CURRNT is zero (indicating a direct command), the direct
                            	  2145: * command is not printed. If CURRNT is -1 (indicating
                            	  2146: * 'INPUT' command in progress), the input line is not printed
                            	  2147: * and execution is not terminated but continues at 'INPERR'.
                            	  2148: *
                            	  2149: * Related to 'ERROR' are the following:
                            	  2150: * 'QWHAT' saves text pointer on stack and gets "What?" message.
                            	  2151: * 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                            	  2152: * 'QSORRY' and 'ASORRY' do the same kind of thing.
                            	  2153: * 'QHOW' and 'AHOW' also do this for "How?".
                            	  2154: 
                            	  2155: ; SETVAL
                            	  2156: ; Returns:
                            	  2157: ;		a6 pointer to variable
                            	  2158: 
                            	  2159: SETVAL	
02:00004F62 6100FCCC        	  2160: 	bsr	TSTV					; variable name?
02:00004F66 6546            	  2161: 	bcs	QWHAT					; if not, say "What?"
02:00004F68 2F00            	  2162: 	move.l d0,-(sp)		; save the variable's address
02:00004F6A 6100028A        	  2163: 	bsr	TSTC					; get past the "=" sign
02:00004F6E 3D              	  2164: 	dc.b	'=',SV1-*
02:00004F6F 11
02:00004F70 6100F842        	  2165: 	bsr	EXPR					; evaluate the expression
02:00004F74 2C5F            	  2166: 	move.l (sp)+,a6
02:00004F76 2C80            	  2167: 	move.l d0,(a6)		; save type
02:00004F78 F22E68000004    	  2168: 	fmove.x fp0,4(a6) ; and save its value in the variable
02:00004F7E 4E75            	  2169: 	rts
                            	  2170: SV1
02:00004F80 602C            	  2171: 	bra	QWHAT					; if no "=" sign
                            	  2172: 
                            	  2173: FIN
02:00004F82 61000272        	  2174: 	bsr	TSTC					; *** FIN ***
02:00004F86 3A              	  2175: 	DC.B ':',FI1-*
02:00004F87 07
02:00004F88 588F            	  2176: 	ADDQ.L #4,SP			; if ":", discard return address
02:00004F8A 6000F324        	  2177: 	BRA	RUNSML				; continue on the same line
                            	  2178: FI1
02:00004F8E 61000266        	  2179: 	bsr	TSTC					; not ":", is it a CR?
02:00004F92 0D              	  2180: 	DC.B	CR,FI2-*
02:00004F93 07
02:00004F94 588F            	  2181: 	ADDQ.L #4,SP			; yes, purge return address
02:00004F96 6000F2C2        	  2182: 	BRA	RUNNXL				; execute the next line
                            	  2183: FI2
02:00004F9A 4E75            	  2184: 	RTS								; else return to the caller
                            	  2185: 
                            	  2186: ENDCHK
02:00004F9C 610002BC        	  2187: 	bsr	IGNBLK
02:00004FA0 0C10003A        	  2188: 	CMP.B #':',(a0)
02:00004FA4 6706            	  2189: 	BEQ ENDCHK1
02:00004FA6 0C10000D        	  2190: 	CMP.B	#CR,(A0)		; does it end with a CR?
02:00004FAA 6602            	  2191: 	BNE	QWHAT					; if not, say "WHAT?"
                            	  2192: ENDCHK1:
02:00004FAC 4E75            	  2193: 	RTS
                            	  2194: 
                            	  2195: QWHAT
02:00004FAE 2F08            	  2196: 	MOVE.L A0,-(SP)
                            	  2197: AWHAT
02:00004FB0 4DFA03CA        	  2198: 	LEA	WHTMSG,A6
                            	  2199: ERROR
02:00004FB4 6100030A        	  2200: 	bsr	PRMESG		display the error message
02:00004FB8 205F            	  2201: 	MOVE.L	(SP)+,A0	restore the text pointer
02:00004FBA 203A03F8        	  2202: 	MOVE.L	CURRNT,D0	get the current line number
02:00004FBE 6700EF3C        	  2203: 	BEQ	WSTART		if zero, do a warm start
02:00004FC2 B0BCFFFFFFFF    	  2204: 	CMP.L	#-1,D0		is the line no. pointer = -1?
02:00004FC8 6700F560        	  2205: 	BEQ	INPERR		if so, redo input
02:00004FCC 1F10            	  2206: 	MOVE.B	(A0),-(SP)	save the char. pointed to
02:00004FCE 4210            	  2207: 	CLR.B	(A0)		put a zero where the error is
02:00004FD0 227A03E2        	  2208: 	MOVE.L	CURRNT,A1	point to start of current line
02:00004FD4 61000202        	  2209: 	bsr	PRTLN		display the line in error up to the 0
02:00004FD8 109F            	  2210: 	MOVE.B	(SP)+,(A0)	restore the character
02:00004FDA 103C003F        	  2211: 	MOVE.B	#'?',D0         display a "?"
02:00004FDE 6100EE96        	  2212: 	BSR	GOOUT
02:00004FE2 4240            	  2213: 	CLR	D0
02:00004FE4 5389            	  2214: 	SUBQ.L	#1,A1		point back to the error char.
02:00004FE6 6100017E        	  2215: 	bsr	PRTSTG		display the rest of the line
02:00004FEA 6000EF10        	  2216: 	BRA	WSTART		and do a warm start
                            	  2217: QSORRY
02:00004FEE 2F08            	  2218: 	MOVE.L	A0,-(SP)
                            	  2219: ASORRY
02:00004FF0 4DFA03AC        	  2220: 	LEA	SRYMSG,A6
02:00004FF4 60BE            	  2221: 	BRA	ERROR
                            	  2222: QHOW
02:00004FF6 2F08            	  2223: 	MOVE.L	A0,-(SP)	Error: "How?"
                            	  2224: AHOW
02:00004FF8 4DFA037B        	  2225: 	LEA	HOWMSG,A6
02:00004FFC 60B6            	  2226: 	BRA	ERROR
                            	  2227: ETYPE
02:00004FFE 4DFA0384        	  2228: 	lea TYPMSG,a6
02:00005002 60B0            	  2229: 	bra ERROR
                            	  2230: 
                            	  2231: *******************************************************************
                            	  2232: *
                            	  2233: * *** GETLN *** FNDLN (& friends) ***
                            	  2234: *
                            	  2235: * 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                            	  2236: * the character in D0 (given by the caller), then it fills the
                            	  2237: * buffer and echos. It ignores LF's but still echos
                            	  2238: * them back. Control-H is used to delete the last character
                            	  2239: * entered (if there is one), and control-X is used to delete the
                            	  2240: * whole line and start over again. CR signals the end of a line,
                            	  2241: * and causes 'GETLN' to return.
                            	  2242: *
                            	  2243: * 'FNDLN' finds a line with a given line no. (in D1) in the
                            	  2244: * text save area.  A1 is used as the text pointer. If the line
                            	  2245: * is found, A1 will point to the beginning of that line
                            	  2246: * (i.e. the high byte of the line no.), and flags are NC & Z.
                            	  2247: * If that line is not there and a line with a higher line no.
                            	  2248: * is found, A1 points there and flags are NC & NZ. If we reached
                            	  2249: * the end of the text save area and cannot find the line, flags
                            	  2250: * are C & NZ.
                            	  2251: * 'FNDLN' will initialize A1 to the beginning of the text save
                            	  2252: * area to start the search. Some other entries of this routine
                            	  2253: * will not initialize A1 and do the search.
                            	  2254: * 'FNDLNP' will start with A1 and search for the line no.
                            	  2255: * 'FNDNXT' will bump A1 by 2, find a CR and then start search.
                            	  2256: * 'FNDSKP' uses A1 to find a CR, and then starts the search.
                            	  2257: 
                            	  2258: GETLN
02:00005004 6100EE70        	  2259: 	BSR	GOOUT		display the prompt
02:00005008 103C0020        	  2260: 	MOVE.B	#' ',D0         and a space
02:0000500C 6100EE68        	  2261: 	BSR	GOOUT
02:00005010 41FA03FA        	  2262: 	LEA	BUFFER,A0	A0 is the buffer pointer
                            	  2263: GL1
02:00005014 61000298        	  2264: 	bsr	CHKIO		check keyboard
02:00005018 67FA            	  2265: 	BEQ	GL1		wait for a char. to come in
02:0000501A B03C0008        	  2266: 	CMP.B	#CTRLH,D0	delete last character?
02:0000501E 6726            	  2267: 	BEQ	GL3		if so
02:00005020 B03C0018        	  2268: 	CMP.B	#CTRLX,D0	delete the whole line?
02:00005024 6744            	  2269: 	BEQ	GL4		if so
02:00005026 B03C000D        	  2270: 	CMP.B	#CR,D0		accept a CR
02:0000502A 6706            	  2271: 	BEQ	GL2
02:0000502C B03C0020        	  2272: 	CMP.B	#' ',D0         if other control char., discard it
02:00005030 65E2            	  2273: 	BCS	GL1
                            	  2274: GL2
02:00005032 10C0            	  2275: 	MOVE.B	D0,(A0)+	save the char.
02:00005034 6100EE40        	  2276: 	BSR	GOOUT		echo the char back out
02:00005038 B03C000D        	  2277: 	CMP.B	#CR,D0		if it's a CR, end the line
02:0000503C 675C            	  2278: 	BEQ	GL7
02:0000503E B1FC0000545B    	  2279: 	CMP.L	#(BUFFER+BUFLEN-1),A0	any more room?
02:00005044 65CE            	  2280: 	BCS	GL1		yes: get some more, else delete last char.
                            	  2281: GL3
02:00005046 103C0008        	  2282: 	MOVE.B	#CTRLH,D0	delete a char. if possible
02:0000504A 6100EE2A        	  2283: 	BSR	GOOUT
02:0000504E 103C0020        	  2284: 	MOVE.B	#' ',D0
02:00005052 6100EE22        	  2285: 	BSR	GOOUT
02:00005056 B1FC0000540C    	  2286: 	CMP.L	#BUFFER,A0	any char.'s left?
02:0000505C 63B6            	  2287: 	BLS	GL1		if not
02:0000505E 103C0008        	  2288: 	MOVE.B	#CTRLH,D0	if so, finish the BS-space-BS sequence
02:00005062 6100EE12        	  2289: 	BSR	GOOUT
02:00005066 5388            	  2290: 	SUBQ.L	#1,A0		decrement the text pointer
02:00005068 60AA            	  2291: 	BRA	GL1		back for more
                            	  2292: GL4
02:0000506A 2208            	  2293: 	MOVE.L	A0,D1		delete the whole line
02:0000506C 92BC0000540C    	  2294: 	SUB.L	#BUFFER,D1	figure out how many backspaces we need
02:00005072 671E            	  2295: 	BEQ	GL6		if none needed, branch
02:00005074 5341            	  2296: 	SUBQ	#1,D1		adjust for DBRA
                            	  2297: GL5
02:00005076 103C0008        	  2298: 	MOVE.B	#CTRLH,D0	and display BS-space-BS sequences
02:0000507A 6100EDFA        	  2299: 	BSR	GOOUT
02:0000507E 103C0020        	  2300: 	MOVE.B	#' ',D0
02:00005082 6100EDF2        	  2301: 	BSR	GOOUT
02:00005086 103C0008        	  2302: 	MOVE.B	#CTRLH,D0
02:0000508A 6100EDEA        	  2303: 	BSR	GOOUT
02:0000508E 51C9FFE6        	  2304: 	DBRA	D1,GL5
                            	  2305: GL6
02:00005092 41FA0378        	  2306: 	LEA	BUFFER,A0	reinitialize the text pointer
02:00005096 6000FF7C        	  2307: 	BRA	GL1		and go back for more
                            	  2308: GL7
02:0000509A 103C000A        	  2309: 	MOVE.B	#LF,D0		echo a LF for the CR
02:0000509E 6000EDD6        	  2310: 	BRA	GOOUT
                            	  2311: 
                            	  2312: FNDLN
02:000050A2 B2BC0000FFFF    	  2313: 	CMP.L	#$FFFF,D1	line no. must be < 65535
02:000050A8 6400FF4C        	  2314: 	BCC	QHOW
02:000050AC 227AEDDC        	  2315: 	MOVE.L	TXTBGN,A1	init. the text save pointer
                            	  2316: 
                            	  2317: FNDLNP
02:000050B0 247A034A        	  2318: 	MOVE.L	TXTUNF,A2	check if we passed the end
02:000050B4 538A            	  2319: 	SUBQ.L	#1,A2
02:000050B6 B5C9            	  2320: 	CMP.L	A1,A2
02:000050B8 650C            	  2321: 	BCS	FNDRET		if so, return with Z=0 & C=1
02:000050BA 1411            	  2322: 	MOVE.B	(A1),D2	if not, get a line no.
02:000050BC E14A            	  2323: 	LSL	#8,D2
02:000050BE 14290001        	  2324: 	MOVE.B	1(A1),D2
02:000050C2 B441            	  2325: 	CMP.W	D1,D2		is this the line we want?
02:000050C4 6502            	  2326: 	BCS	FNDNXT		no, not there yet
                            	  2327: FNDRET
02:000050C6 4E75            	  2328: 	RTS			return the cond. codes
                            	  2329: 
                            	  2330: FNDNXT
02:000050C8 5489            	  2331: 	ADDQ.L	#2,A1		find the next line
                            	  2332: 
                            	  2333: FNDSKP	
02:000050CA 0C19000D        	  2334: 	CMP.B	#CR,(A1)+	try to find a CR
02:000050CE 67E0            	  2335: 	BEQ		FNDLNP
02:000050D0 B3FA032A        	  2336: 	CMP.L	TXTUNF,A1
02:000050D4 65F4            	  2337: 	BLO		FNDSKP
02:000050D6 60D8            	  2338: 	BRA		FNDLNP		check if end of text
                            	  2339: 
                            	  2340: ;******************************************************************
                            	  2341: ;
                            	  2342: ; *** MVUP *** MVDOWN *** POPA *** PUSHA ***
                            	  2343: ;
                            	  2344: ; 'MVUP' moves a block up from where A1 points to where A2 points
                            	  2345: ; until A1=A3
                            	  2346: ;
                            	  2347: ; 'MVDOWN' moves a block down from where A1 points to where A3
                            	  2348: ; points until A1=A2
                            	  2349: ;
                            	  2350: ; 'POPA' restores the 'FOR' loop variable save area from the stack
                            	  2351: ;
                            	  2352: ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                            	  2353: ;
                            	  2354: 
                            	  2355: MVUP
02:000050D8 B7C9            	  2356: 	CMP.L	A1,A3					; see the above description
02:000050DA 6304            	  2357: 	BLS	MVRET
02:000050DC 14D9            	  2358: 	MOVE.B	(A1)+,(A2)+
02:000050DE 60F8            	  2359: 	BRA	MVUP
                            	  2360: MVRET
02:000050E0 4E75            	  2361: 	RTS
                            	  2362: 
                            	  2363: ; For string movements only suitable in some circumstances
                            	  2364: 
                            	  2365: MVUPW
02:000050E2 B3CB            	  2366: 	cmp.l a3,a1
02:000050E4 6404            	  2367: 	bhs .0001
02:000050E6 34D9            	  2368: 	move.w (a1)+,(a2)+
02:000050E8 60F8            	  2369: 	bra MVUPW
                            	  2370: .0001
02:000050EA 4E75            	  2371: 	rts
                            	  2372: 
                            	  2373: MVDOWN
02:000050EC B5C9            	  2374: 	CMP.L	A1,A2		see the above description
02:000050EE 67F0            	  2375: 	BEQ	MVRET
02:000050F0 1721            	  2376: 	MOVE.B	-(A1),-(A3)
02:000050F2 60F8            	  2377: 	BRA	MVDOWN
                            	  2378: 
                            	  2379: POPA
02:000050F4 2C5F            	  2380: 	MOVE.L	(SP)+,A6			; A6 = return address
02:000050F6 23DF000053C4    	  2381: 	MOVE.L	(SP)+,LOPVAR	restore LOPVAR, but zero means no more
02:000050FC 6730            	  2382: 	BEQ	.0001
02:000050FE 23DF000053D0    	  2383: 	MOVE.L	(SP)+,LOPINC+8	if not zero, restore the rest
02:00005104 23DF000053CC    	  2384: 	MOVE.L	(SP)+,LOPINC+4
02:0000510A 23DF000053C8    	  2385: 	MOVE.L	(SP)+,LOPINC
02:00005110 23DF000053DC    	  2386: 	MOVE.L	(SP)+,LOPLMT+8
02:00005116 23DF000053D8    	  2387: 	MOVE.L	(SP)+,LOPLMT+4
02:0000511C 23DF000053D4    	  2388: 	MOVE.L	(SP)+,LOPLMT
02:00005122 23DF000053E0    	  2389: 	MOVE.L	(SP)+,LOPLN
02:00005128 23DF000053E4    	  2390: 	MOVE.L	(SP)+,LOPPT
                            	  2391: .0001
02:0000512E 4ED6            	  2392: 	JMP	(A6)		return
                            	  2393: 
                            	  2394: PUSHA
02:00005130 223A02D2        	  2395: 	MOVE.L	STKLMT,D1		; Are we running out of stack room?
02:00005134 928F            	  2396: 	SUB.L	SP,D1
02:00005136 6400FEB6        	  2397: 	BCC	QSORRY					; if so, say we're sorry
02:0000513A 2C5F            	  2398: 	MOVE.L	(SP)+,A6		; else get the return address
02:0000513C 223A0286        	  2399: 	MOVE.L	LOPVAR,D1		; save loop variables
02:00005140 6720            	  2400: 	BEQ	.0001						; if LOPVAR is zero, that's all
02:00005142 2F3A02A0        	  2401: 	MOVE.L	LOPPT,-(SP)	; else save all the others
02:00005146 2F3A0298        	  2402: 	MOVE.L	LOPLN,-(SP)
02:0000514A 2F3A0288        	  2403: 	MOVE.L	LOPLMT,-(SP)
02:0000514E 2F3A0288        	  2404: 	MOVE.L	LOPLMT+4,-(SP)
02:00005152 2F3A0288        	  2405: 	MOVE.L	LOPLMT+8,-(SP)
02:00005156 2F3A0270        	  2406: 	MOVE.L	LOPINC,-(SP)
02:0000515A 2F3A0270        	  2407: 	MOVE.L	LOPINC+4,-(SP)
02:0000515E 2F3A0270        	  2408: 	MOVE.L	LOPINC+8,-(SP)
                            	  2409: .0001
02:00005162 2F01            	  2410: 	MOVE.L	D1,-(SP)
02:00005164 4ED6            	  2411: 	JMP	(A6)		return
                            	  2412: 
                            	  2413: *******************************************************************
                            	  2414: *
                            	  2415: * *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                            	  2416: *
                            	  2417: * 'PRTSTG' prints a string pointed to by A1. It stops printing
                            	  2418: * and returns to the caller when either a CR is printed or when
                            	  2419: * the next byte is the same as what was passed in D0 by the
                            	  2420: * caller.
                            	  2421: *
                            	  2422: * 'QTSTG' looks for an underline (back-arrow on some systems),
                            	  2423: * single-quote, or double-quote.  If none of these are found, returns
                            	  2424: * to the caller.  If underline, outputs a CR without a LF.  If single
                            	  2425: * or double quote, prints the quoted string and demands a matching
                            	  2426: * end quote.  After the printing, the next 2 bytes of the caller are
                            	  2427: * skipped over (usually a short branch instruction).
                            	  2428: *
                            	  2429: * 'PRTNUM' prints the 32 bit number in D1, leading blanks are added if
                            	  2430: * needed to pad the number of spaces to the number in D4.
                            	  2431: * However, if the number of digits is larger than the no. in
                            	  2432: * D4, all digits are printed anyway. Negative sign is also
                            	  2433: * printed and counted in, positive sign is not.
                            	  2434: *
                            	  2435: * 'PRTLN' prints the saved text line pointed to by A1
                            	  2436: * with line no. and all.
                            	  2437: *
                            	  2438: PRTSTG:
02:00005166 1200            	  2439: 	MOVE.B	D0,D1		save the stop character
                            	  2440: PS1
02:00005168 1019            	  2441: 	MOVE.B	(A1)+,D0	get a text character
02:0000516A B200            	  2442: 	CMP.B	D0,D1		same as stop character?
02:0000516C 6712            	  2443: 	BEQ	PRTRET		if so, return
02:0000516E 6100ED06        	  2444: 	BSR	GOOUT		display the char.
02:00005172 B03C000D        	  2445: 	CMP.B	#CR,D0		is it a C.R.?
02:00005176 66F0            	  2446: 	BNE	PS1		no, go back for more
02:00005178 103C000A        	  2447: 	MOVE.B	#LF,D0		yes, add a L.F.
02:0000517C 6100ECF8        	  2448: 	BSR	GOOUT
                            	  2449: PRTRET
02:00005180 4E75            	  2450: 	RTS			then return
                            	  2451: 
                            	  2452: PRTSTR2a
02:00005182 1019            	  2453: 	move.b (a1)+,d0
02:00005184 6100ECF0        	  2454: 	bsr GOOUT
                            	  2455: PRTSTR2:
02:00005188 51C9FFF8        	  2456: 	dbra d1,PRTSTR2a
02:0000518C 4E75            	  2457: 	rts
                            	  2458: 	
                            	  2459: 	if 0
                            	  2460: QTSTG
                            	  2461: 	bsr	TSTC		*** QTSTG ***
                            	  2462: 	DC.B	'"',QT3-*
                            	  2463: 	MOVE.B	#'"',D0         it is a "
                            	  2464: QT1
                            	  2465: 	MOVE.L	A0,A1
                            	  2466: 	BSR	PRTSTG		print until another
                            	  2467: 	MOVE.L	A1,A0
                            	  2468: 	MOVE.L	(SP)+,A1	pop return address
                            	  2469: 	CMP.B	#LF,D0		was last one a CR?
                            	  2470: 	BEQ	RUNNXL		if so, run next line
                            	  2471: QT2
                            	  2472: 	ADDQ.L	#2,A1		skip 2 bytes on return
                            	  2473: 	JMP	(A1)		return
                            	  2474: QT3
                            	  2475: 	bsr	TSTC		is it a single quote?
                            	  2476: 	DC.B	'''',QT4-*
                            	  2477: 	MOVE.B	#'''',D0        if so, do same as above
                            	  2478: 	BRA	QT1
                            	  2479: QT4
                            	  2480: 	bsr	TSTC		is it an underline?
                            	  2481: 	DC.B	'_',QT5-*
                            	  2482: 	MOVE.B	#CR,D0		if so, output a CR without LF
                            	  2483: 	bsr	GOOUT
                            	  2484: 	MOVE.L	(SP)+,A1	pop return address
                            	  2485: 	BRA	QT2
                            	  2486: QT5
                            	  2487: 	RTS			none of the above
                            	  2488: 	endif
                            	  2489: 
                            	  2490: PRTNUM:
02:0000518E 4E52FFD0        	  2491: 	link a2,#-48
02:00005192 217900040098002C	  2492: 	move.l _canary,44(a0)
02:0000519A 48D7020F        	  2493: 	movem.l d0/d1/d2/d3/a1,(sp)
02:0000519E F22F68000014    	  2494: 	fmove.x fp0,20(sp)
02:000051A4 F22F68800020    	  2495: 	fmove.x fp1,32(sp)
02:000051AA F2000400        	  2496: 	fmove.x fp1,fp0					; fp0 = number to print
02:000051AE 43F900040520    	  2497: 	lea _fpBuf,a1						; a1 = pointer to buffer to use
02:000051B4 7027            	  2498: 	moveq #39,d0						; d0 = function #39 print float
02:000051B6 2204            	  2499: 	move.l d4,d1						; d1 = width
02:000051B8 2404            	  2500: 	move.l d4,d2						; d2 = precision max
02:000051BA 7665            	  2501: 	moveq #'e',d3
02:000051BC 4E4F            	  2502: 	trap #15
02:000051BE 4CD7020F        	  2503: 	movem.l (sp),d0/d1/d2/d3/a1
02:000051C2 F22F48000014    	  2504: 	fmove.x 20(sp),fp0
02:000051C8 F22F48800020    	  2505: 	fmove.x 32(sp),fp1
02:000051CE A2A80003002C    	  2506: 	cchk 44(a0)
02:000051D4 4E5A            	  2507: 	unlk a2
02:000051D6 4E75            	  2508: 	rts
                            	  2509: 
                            	  2510: ; Debugging
                            	  2511: 	if 0
                            	  2512: PRTFP0:
                            	  2513: 	link a2,#-48
                            	  2514: 	move.l _canary,44(a0)
                            	  2515: 	movem.l d0/d1/d2/d3/a1,(sp)
                            	  2516: 	fmove.x fp0,20(sp)
                            	  2517: 	lea _fpBuf,a1						; a1 = pointer to buffer to use
                            	  2518: 	moveq #39,d0						; d0 = function #39 print float
                            	  2519: 	moveq #30,d1						; d1 = width
                            	  2520: 	moveq #25,d2						; d2 = precision max
                            	  2521: 	moveq #'e',d3
                            	  2522: 	trap #15
                            	  2523: 	movem.l (sp),d0/d1/d2/d3/a1
                            	  2524: 	fmove.x 20(sp),fp0
                            	  2525: 	cchk 44(a0)
                            	  2526: 	unlk a2
                            	  2527: 	rts
                            	  2528: 	endif
                            	  2529: 
                            	  2530: PRTLN:
02:000051D8 7200            	  2531: 	CLR.L	D1
02:000051DA 1219            	  2532: 	MOVE.B (A1)+,D1	get the binary line number
02:000051DC E149            	  2533: 	LSL	#8,D1
02:000051DE 1219            	  2534: 	MOVE.B (A1)+,D1
02:000051E0 F2015080        	  2535: 	FMOVE.W D1,FP1
02:000051E4 7805            	  2536: 	MOVEQ	#5,D4			; display a 5 digit line no.
02:000051E6 61A6            	  2537: 	BSR	PRTNUM
02:000051E8 103C0020        	  2538: 	MOVE.B	#' ',D0         followed by a blank
02:000051EC 6100EC88        	  2539: 	BSR	GOOUT
02:000051F0 4240            	  2540: 	CLR	D0		stop char. is a zero
02:000051F2 6000FF72        	  2541: 	BRA	PRTSTG		display the rest of the line
                            	  2542: 
                            	  2543: 
                            	  2544: ; ===== Test text byte following the call to this subroutine. If it
                            	  2545: ; equals the byte pointed to by A0, return to the code following
                            	  2546: ; the call. If they are not equal, branch to the point
                            	  2547: ;	indicated by the offset byte following the text byte.
                            	  2548: 
                            	  2549: TSTC:
02:000051F6 6162            	  2550: 	BSR	IGNBLK				; ignore leading blanks
02:000051F8 225F            	  2551: 	MOVE.L (SP)+,A1		; get the return address
02:000051FA 1219            	  2552: 	MOVE.B (A1)+,D1		; get the byte to compare
02:000051FC B210            	  2553: 	CMP.B	(A0),D1 		;	is it = to what A0 points to?
02:000051FE 6708            	  2554: 	BEQ	TC1						; if so
02:00005200 7200            	  2555: 	CLR.L	D1					; If not, add the second
02:00005202 1211            	  2556: 	MOVE.B (A1),D1 		; byte following the call to
02:00005204 D3C1            	  2557: 	ADD.L	D1,A1				; the return address.
02:00005206 4ED1            	  2558: 	JMP	(A1)					; jump to the routine
                            	  2559: TC1
02:00005208 5288            	  2560: 	ADDQ.L #1,A0			; if equal, bump text pointer
02:0000520A 5289            	  2561: 	ADDQ.L #1,A1			; Skip the 2 bytes following
02:0000520C 4ED1            	  2562: 	JMP	(A1)					; the call and continue.
                            	  2563: 
                            	  2564: 
                            	  2565: ; ===== See if the text pointed to by A0 is a number. If so,
                            	  2566: ;	return the number in FP1 and the number of digits in D2,
                            	  2567: ;	else return zero in FP1 and D2.
                            	  2568: ; If text is not a number, then A0 is not updated, otherwise
                            	  2569: ; A0 is advanced past the number. Note A0 is always updated
                            	  2570: ; past leading spaces.
                            	  2571: 
                            	  2572: TSTNUM
02:0000520E 4E52FFE0        	  2573: 	link a2,#-32
02:00005212 2F7900040098001C	  2574: 	move.l _canary,28(sp)
02:0000521A 48D70202        	  2575: 	movem.l d1/a1,(sp)
02:0000521E F22F68000010    	  2576: 	fmove.x fp0,16(sp)
02:00005224 7029            	  2577: 	moveq #41,d0						; function #41, get float
02:00005226 7201            	  2578: 	moveq #1,d1							; d1 = input stride
02:00005228 2248            	  2579: 	move.l a0,a1						; a1 = pointer to input buffer
02:0000522A 4E4F            	  2580: 	trap #15								; call BIOS get float function
02:0000522C 2049            	  2581: 	move.l a1,a0						; set text pointer
02:0000522E 7001            	  2582: 	moveq #DT_NUMERIC,d0		; default data type = number
02:00005230 F2000080        	  2583: 	fmove.x fp0,fp1					; return expected in fp1
02:00005234 4A41            	  2584: 	tst.w d1								; check if a number (digits > 0?)
02:00005236 6706            	  2585: 	beq .0002
02:00005238 7400            	  2586: 	clr.l d2								; d2.l = 0
02:0000523A 3401            	  2587: 	move.w d1,d2						; d2 = number of digits
02:0000523C 6008            	  2588: 	bra .0001
                            	  2589: .0002											; not a number, return with orignal text pointer
02:0000523E 7000            	  2590: 	moveq #0,d0							; data type = not a number
02:00005240 7400            	  2591: 	moveq #0,d2							; d2 = 0
02:00005242 F2024080        	  2592: 	fmove.l d2,fp1					; return a zero
                            	  2593: .0001
02:00005246 4CD70202        	  2594: 	movem.l (sp),d1/a1
02:0000524A F22F48000010    	  2595: 	fmove.x 16(sp),fp0
02:00005250 A2AF0003001C    	  2596: 	cchk 28(sp)
02:00005256 4E5A            	  2597: 	unlk a2
02:00005258 4E75            	  2598: 	rts
                            	  2599: 		
                            	  2600: ; ===== Skip over blanks in the text pointed to by A0.
                            	  2601: 
                            	  2602: IGNBLK
02:0000525A 0C180020        	  2603: 	CMP.B	#' ',(A0)+		; see if it's a space
02:0000525E 67FA            	  2604: 	BEQ	IGNBLK					; if so, swallow it
02:00005260 5388            	  2605: 	SUBQ.L #1,A0				; decrement the text pointer
02:00005262 4E75            	  2606: 	RTS
                            	  2607: 
                            	  2608: *
                            	  2609: * ===== Convert the line of text in the input buffer to upper
                            	  2610: *	case (except for stuff between quotes).
                            	  2611: *
02:00005264 41FA01A6        	  2612: TOUPBUF LEA	BUFFER,A0	set up text pointer
02:00005268 4201            	  2613: 	CLR.B	D1		clear quote flag
                            	  2614: TOUPB1	
02:0000526A 1018            	  2615: 	MOVE.B	(A0)+,D0	get the next text char.
02:0000526C B03C000D        	  2616: 	CMP.B	#CR,D0		is it end of line?
02:00005270 6718            	  2617: 	BEQ	TOUPBRT 	if so, return
02:00005272 B03C0022        	  2618: 	CMP.B	#'"',D0         a double quote?
02:00005276 6714            	  2619: 	BEQ	DOQUO
02:00005278 B03C0027        	  2620: 	CMP.B	#'''',D0        or a single quote?
02:0000527C 670E            	  2621: 	BEQ	DOQUO
02:0000527E 4A01            	  2622: 	TST.B	D1		inside quotes?
02:00005280 66E8            	  2623: 	BNE	TOUPB1		if so, do the next one
02:00005282 6118            	  2624: 	BSR	TOUPPER 	convert to upper case
02:00005284 1100            	  2625: 	MOVE.B	D0,-(A0)	store it
02:00005286 5288            	  2626: 	ADDQ.L	#1,A0
02:00005288 60E0            	  2627: 	BRA	TOUPB1		and go back for more
                            	  2628: TOUPBRT
02:0000528A 4E75            	  2629: 	RTS
                            	  2630: 
02:0000528C 4A01            	  2631: DOQUO	TST.B	D1		are we inside quotes?
02:0000528E 6604            	  2632: 	BNE	DOQUO1
02:00005290 1200            	  2633: 	MOVE.B	D0,D1		if not, toggle inside-quotes flag
02:00005292 60D6            	  2634: 	BRA	TOUPB1
02:00005294 B200            	  2635: DOQUO1	CMP.B	D0,D1		make sure we're ending proper quote
02:00005296 66D2            	  2636: 	BNE	TOUPB1		if not, ignore it
02:00005298 4201            	  2637: 	CLR.B	D1		else clear quote flag
02:0000529A 60CE            	  2638: 	BRA	TOUPB1
                            	  2639: 
                            	  2640: *
                            	  2641: * ===== Convert the character in D0 to upper case
                            	  2642: *
02:0000529C B03C0061        	  2643: TOUPPER CMP.B	#'a',D0         is it < 'a'?
02:000052A0 650A            	  2644: 	BCS	TOUPRET
02:000052A2 B03C007A        	  2645: 	CMP.B	#'z',D0         or > 'z'?
02:000052A6 6204            	  2646: 	BHI	TOUPRET
02:000052A8 903C0020        	  2647: 	SUB.B	#32,D0		if not, make it upper case
02:000052AC 4E75            	  2648: TOUPRET RTS
                            	  2649: 
                            	  2650: *
                            	  2651: * 'CHKIO' checks the input. If there's no input, it will return
                            	  2652: * to the caller with the Z flag set. If there is input, the Z
                            	  2653: * flag is cleared and the input byte is in D0. However, if a
                            	  2654: * control-C is read, 'CHKIO' will warm-start BASIC and will not
                            	  2655: * return to the caller.
                            	  2656: *
                            	  2657: CHKIO
02:000052AE 6100EBCA        	  2658: 	bsr	GOIN		get input if possible
02:000052B2 670A            	  2659: 	BEQ	CHKRET		if Zero, no input
02:000052B4 B03C0003        	  2660: 	CMP.B	#CTRLC,D0	is it control-C?
02:000052B8 6604            	  2661: 	BNE	CHKRET		if not
02:000052BA 6000EC40        	  2662: 	BRA	WSTART		if so, do a warm start
                            	  2663: CHKRET
02:000052BE 4E75            	  2664: 	RTS
                            	  2665: 
                            	  2666: *
                            	  2667: * ===== Display a CR-LF sequence
                            	  2668: *
                            	  2669: ;CRLF	LEA	CLMSG,A6
                            	  2670: 
                            	  2671: 
                            	  2672: ; ===== Display a zero-ended string pointed to by register A6
                            	  2673: 
                            	  2674: PRMESG
02:000052C0 101E            	  2675: 	MOVE.B (A6)+,D0		; get the char.
02:000052C2 6706            	  2676: 	BEQ	PRMRET				; if it's zero, we're done
02:000052C4 6100EBB0        	  2677: 	BSR	GOOUT					; else display it
02:000052C8 60F6            	  2678: 	BRA	PRMESG
                            	  2679: PRMRET
02:000052CA 4E75            	  2680: 	RTS
                            	  2681: 
                            	  2682: ******************************************************
                            	  2683: * The following routines are the only ones that need *
                            	  2684: * to be changed for a different I/O environment.     *
                            	  2685: ******************************************************
                            	  2686: 
                            	  2687: ; ===== Clear screen and home cursor
                            	  2688: 
                            	  2689: CLS:
02:000052CC 700B            	  2690: 	moveq #11,d0			; set cursor position
02:000052CE 323CFF00        	  2691: 	move.w #$FF00,d1	; home cursor and clear screen
02:000052D2 4E4F            	  2692: 	trap #15
02:000052D4 6000F0E0        	  2693: 	bra FINISH
                            	  2694: 
                            	  2695: ; ===== Output character to the console (Port 1) from register D0
                            	  2696: ;(Preserves all registers.)
                            	  2697: 
                            	  2698: OUTC:
02:000052D8 48E7C000        	  2699: 	movem.l d0/d1,-(sp)
02:000052DC 2200            	  2700: 	move.l d0,d1
02:000052DE 7006            	  2701: 	moveq #6,d0
02:000052E0 4E4F            	  2702: 	trap #15
02:000052E2 4CDF0003        	  2703: 	movem.l (sp)+,d0/d1
02:000052E6 4E75            	  2704: 	rts
                            	  2705: 
                            	  2706: * ===== Input a character from the console into register D0 (or
                            	  2707: *	return Zero status if there's no character available).
                            	  2708: *
                            	  2709: INC
02:000052E8 2F0E            	  2710: 	move.l	a6,-(a7)
02:000052EA 2C7A00C0        	  2711: 	move.l	INPPTR,a6
02:000052EE 4E96            	  2712: 	jsr			(a6)
02:000052F0 2C5F            	  2713: 	move.l	(a7)+,a6
02:000052F2 4E75            	  2714: 	rts
                            	  2715: 
                            	  2716: INC1
02:000052F4 2F01            	  2717: 	move.l	d1,-(a7)
02:000052F6 7005            	  2718: 	moveq.l	#5,d0			* function 5 GetKey
02:000052F8 4E4F            	  2719: 	trap		#15
02:000052FA 2001            	  2720: 	move.l	d1,d0
02:000052FC 221F            	  2721: 	move.l	(a7)+,d1
02:000052FE 0C0000FF        	  2722: 	cmpi.b	#-1,d0
02:00005302 6602            	  2723: 	bne			.0001
02:00005304 4200            	  2724: 	clr.b		d0
                            	  2725: .0001:
02:00005306 4E75            	  2726: 	rts
                            	  2727: 
                            	  2728: *INC	BTST	#0,$10040	is character ready?
                            	  2729: *	BEQ	INCRET		if not, return Zero status
                            	  2730: *	MOVE.B	$10042,D0	else get the character
                            	  2731: *	AND.B	#$7F,D0 	zero out the high bit
                            	  2732: *INCRET	RTS
                            	  2733: 
                            	  2734: * ===== Output character to the host (Port 2) from register D0
                            	  2735: *	(Preserves all registers.)
                            	  2736: *
                            	  2737: AUXOUT:
02:00005308 13FC0002000400A8	  2738: 	move.b #2,OutputDevice
02:00005310 61C6            	  2739: 	bsr OUTC
02:00005312 13FC0001000400A8	  2740: 	move.b #1,OutputDevice
02:0000531A 4E75            	  2741: 	rts
                            	  2742: 
                            	  2743: *AUXOUT	BTST	#1,$10041	is port 2 ready for a character?
                            	  2744: *	BEQ	AUXOUT		if not, wait for it
                            	  2745: *	MOVE.B	D0,$10043	out it goes.
                            	  2746: *	RTS
                            	  2747: 
                            	  2748: *
                            	  2749: * ===== Input a character from the host into register D0 (or
                            	  2750: *	return Zero status if there's no character available).
                            	  2751: *
                            	  2752: AUXIN:
02:0000531C 2F01            	  2753: 	move.l	d1,-(a7)
02:0000531E 7024            	  2754: 	moveq		#36,d0				; serial get char from buffer
02:00005320 4E4F            	  2755: 	trap		#15
02:00005322 2001            	  2756: 	move.l	d1,d0
02:00005324 221F            	  2757: 	move.l	(a7)+,d1
02:00005326 0C40FFFF        	  2758: 	cmpi.w	#-1,d0
02:0000532A 670A            	  2759: 	beq			.0001
02:0000532C 0200007F        	  2760: 	andi.b	#$7F,d0				; clear high bit
02:00005330 4880            	  2761: 	ext.w		d0						; return character in d0
02:00005332 48C0            	  2762: 	ext.l		d0
02:00005334 4E75            	  2763: 	rts
                            	  2764: .0001:
02:00005336 7000            	  2765: 	moveq		#0,d0					; return zf=1 if no character available
02:00005338 4E75            	  2766: 	rts
                            	  2767: 
                            	  2768: ;AUXIN
                            	  2769: *AUXIN	BTST	#0,$10041	is character ready?
                            	  2770: *	BEQ	AXIRET		if not, return Zero status
                            	  2771: *	MOVE.B	$10043,D0	else get the character
                            	  2772: *	AND.B	#$7F,D0 	zero out the high bit
02:0000533A 4E75            	  2773: AXIRET	RTS
                            	  2774: 
                            	  2775: ; ===== Return to the resident monitor, operating system, etc.
                            	  2776: ;
                            	  2777: BYEBYE	
02:0000533C 23FC000000080004	  2778: 	move.l #8,_fpTextIncr
02:00005344 0094
02:00005346 60001378        	  2779: 	bra		Monitor
                            	  2780: ;	MOVE.B	#228,D7 	return to Tutor
                            	  2781: ;	TRAP	#14
                            	  2782: 
02:0000534A 0D              	  2783: INITMSG DC.B	CR,LF,'MC68000 Tiny Float BASIC, v1.0',CR,LF,LF,0
02:0000534B 0A
02:0000534C 4D43363830303020
02:00005354 54696E7920466C6F
02:0000535C 6174204241534943
02:00005364 2C2076312E30
02:0000536A 0D
02:0000536B 0A
02:0000536C 0A
02:0000536D 00
02:0000536E 0D              	  2784: OKMSG	DC.B	CR,LF,'OK',CR,LF,0
02:0000536F 0A
02:00005370 4F4B
02:00005372 0D
02:00005373 0A
02:00005374 00
02:00005375 486F773F        	  2785: HOWMSG	DC.B	'How?',CR,LF,0
02:00005379 0D
02:0000537A 0A
02:0000537B 00
02:0000537C 576861743F      	  2786: WHTMSG	DC.B	'What?',CR,LF,0
02:00005381 0D
02:00005382 0A
02:00005383 00
02:00005384 547970653F      	  2787: TYPMSG	DC.B	'Type?',CR,LF,0
02:00005389 0D
02:0000538A 0A
02:0000538B 00
02:0000538C 4E6F20737472696E	  2788: NOSTRING	DC.B 'No string space',CR,LF,0
02:00005394 67207370616365
02:0000539B 0D
02:0000539C 0A
02:0000539D 00
02:0000539E 536F7272792E    	  2789: SRYMSG	DC.B	'Sorry.'
02:000053A4 0D              	  2790: CLMSG	DC.B	CR,LF,0
02:000053A5 0A
02:000053A6 00
02:000053A7 00              	  2791: 	DC.B	0	<- for aligning on a word boundary
                            	  2792: LSTROM	EQU	*		end of possible ROM area
                            	  2793: *
                            	  2794: * Internal variables follow:
                            	  2795: *
                            	  2796: 	align 2
02:000053A8 00003E70        	  2797: RANPNT	DC.L	START		random number pointer
02:000053AC 00000000        	  2798: INPPTR	DS.L	1		input pointer
02:000053B0 00000000        	  2799: OUTPTR	DS.L	1 	output pointer
02:000053B4 00000000        	  2800: CURRNT	DS.L	1		; Current line pointer
02:000053B8 00000000        	  2801: STKFP		DS.L	1		; saves frame pointer
02:000053BC 00000000        	  2802: STKGOS	DS.L	1		Saves stack pointer in 'GOSUB'
02:000053C0 00000000        	  2803: STKINP	DS.L	1		Saves stack pointer during 'INPUT'
02:000053C4 00000000        	  2804: LOPVAR	DS.L	1		'FOR' loop save area
02:000053C8 00000000        	  2805: LOPINC	DS.L	3		increment
02:000053CC *
02:000053D4 00000000        	  2806: LOPLMT	DS.L	3		limit
02:000053D8 *
02:000053E0 00000000        	  2807: LOPLN	DS.L	1		line number
02:000053E4 00000000        	  2808: LOPPT	DS.L	1		text pointer
02:000053E8 00000000        	  2809: IRQROUT	DS.L	1
02:000053EC 00000000        	  2810: STRSTK	DS.L	1		; string pointer stack area, 8 entries
02:000053F0 00000000        	  2811: StrSp		DS.L	1		; string stack stack pointer
02:000053F4 00000000        	  2812: StrArea	DS.L	1		; pointer to string area
02:000053F8 00000000        	  2813: LastStr	DS.L	1		; pointer to last used string in area
02:000053FC 00000000        	  2814: TXTUNF	DS.L	1		points to unfilled text area
02:00005400 00000000        	  2815: VARBGN	DS.L	1		points to variable area
02:00005404 00000000        	  2816: STKLMT	DS.L	1		holds lower limit for stack growth
02:00005408 00000000        	  2817: DIRFLG	DS.L	1		; indicates 1=DIRECT mode
02:0000540C 00              	  2818: BUFFER	DS.B	BUFLEN		Keyboard input buffer
02:0000540D *
                            	  2819: TXT	EQU	*		Beginning of program area
                            	  2820: ;	END
                            	  2821: 

Source: "boot.x68"
                            	   889: 	include "..\Femtiki\FemtikiTop.x68"

Source: "..\Femtiki\FemtikiTop.x68"
                            	     1: 	include "..\Femtiki\const.x68"

Source: "..\Femtiki\const.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2020-2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: TS_NONE			EQU		0
                            	    38: TS_READY		EQU		1
                            	    39: TS_DEAD			EQU		2
                            	    40: TS_MSGRDY		EQU		4
                            	    41: TS_WAITMSG	EQU		8
                            	    42: TS_TIMEOUT	EQU		16
                            	    43: TS_PREEMPT	EQU		32
                            	    44: TS_RUNNING	EQU		128
                            	    45: 
                            	    46: ; error codes
                            	    47: E_Ok		EQU		$00
                            	    48: E_Arg		EQU		$01
                            	    49: E_Func  EQU    $02
                            	    50: E_BadMbx	EQU		$04
                            	    51: E_QueFull	EQU		$05
                            	    52: E_NoThread	EQU		$06
                            	    53: E_NotAlloc	EQU		$09
                            	    54: E_NoMsg		EQU		$0b
                            	    55: E_Timeout	EQU		$10
                            	    56: E_BadAlarm	EQU		$11
                            	    57: E_NotOwner	EQU		$12
                            	    58: E_QueStrategy EQU		$13
                            	    59: E_DCBInUse	EQU		$19
                            	    60: ; Device driver errors
                            	    61: E_BadDevNum	EQU		$20
                            	    62: E_NoDev		EQU		$21
                            	    63: E_BadDevOp	EQU		$22
                            	    64: E_ReadError	EQU		$23
                            	    65: E_WriteError EQU		$24
                            	    66: E_BadBlockNum	EQU	$25
                            	    67: E_TooManyBlocks	EQU	$26
                            	    68: 
                            	    69: ; resource errors
                            	    70: E_NoMoreMbx	EQU		$40
                            	    71: E_NoMoreMsgBlks	EQU	$41
                            	    72: E_NoMoreAlarmBlks	EQU $44
                            	    73: E_NoMoreTCBs	EQU	$45
                            	    74: E_NoMem		EQU 12
                            	    75: 
                            	    76: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     2: 	include "..\Femtiki\config.x68"

Source: "..\Femtiki\config.x68"
                            	     1: MAX_TID		EQU		4095
                            	     2: NR_TCB		EQU		4096
                            	     3: NTASK     EQU   4096    ; number of threads allowed
                            	     4: LOG_TCBSZ	EQU		8
                            	     5: LOG_PGSZ	EQU		10
                            	     6: LOG_ACBSZ EQU   12
                            	     7: OSPAGES		EQU		16			; pages of memory dedicated to OS
                            	     8: PAGESZ    EQU   16384  	; size of a page of memory
                            	     9: MEMSZ     EQU   32768   ; pages
                            	    10: MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                            	    11: NR_MSG		EQU		21842		; number of messages available
                            	    12: NR_MBX		EQU		9792
                            	    13: 
                            	    14: 
                            	    15: 
                            	    16: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     3: 	include "..\Femtiki\types.x68"

Source: "..\Femtiki\types.x68"
                            	     1: ; Thread Control Block
                            	     2: TCBMagic    EQU		$0000
                            	     3: TCBRegs  		EQU   $0004		; register set storage area
                            	     4: TCBUSP			EQU		$0044
                            	     5: TCBSSP			EQU		$0048
                            	     6: TCBSR				EQU		$004C
                            	     7: TCBPC				EQU		$0050
                            	     8: TCBStatus		EQU		$0054
                            	     9: TCBPriority	EQU		$0055
                            	    10: TCBWaitMbx	EQU		$0056
                            	    11: TCBHasFocus EQU   $005A
                            	    12: TCBStackBot	EQU		$005C
                            	    13: TCBMsgD1		EQU		$0060
                            	    14: TCBMsgD2		EQU		$0064
                            	    15: TCBMsgD3		EQU		$0068
                            	    16: TCBStartTick	EQU	$006C
                            	    17: TCBEndTick	EQU		$0070
                            	    18: TCBTicks		EQU		$0074
                            	    19: TCBException	EQU	$0078
                            	    20: TCBNext			EQU		$007C
                            	    21: TCBPrev			EQU		$0080
                            	    22: TCBAffinityBase	EQU	$0082
                            	    23: TCBAffinity	EQU		$0084
                            	    24: TCBTimeout	EQU		$0088
                            	    25: TCBtid      EQU   $008C
                            	    26: TCBmid      EQU   $0090
                            	    27: TCBappid    EQU   $0094
                            	    28: TCBOpMode   EQU   $0098
                            	    29: TCBMbxNext  EQU   $009C
                            	    30: TCBMbxPrev  EQU   $00A0
                            	    31: TCBThreadNum  EQU   $00A4
                            	    32: TCBAcbNext	EQU		$00A8
                            	    33: TCBAcbPrev	EQU		$00AC
                            	    34: TCBhMailboxes	EQU		$00B0
                            	    35: TCBName			EQU		$00C0
                            	    36: TCB_SIZE		EQU		$0100
                            	    37: 
                            	    38: MBX_MAGIC		equ		0
                            	    39: MBX_OWNER		equ		4		; tid of owning task
                            	    40: MBX_LINK    equ   8
                            	    41: MBX_TQHEAD  equ   12   ; link field for free list shared with task queue head
                            	    42: MBX_TQTAIL  equ   16
                            	    43: MBX_MQHEAD	equ		20
                            	    44: MBX_MQTAIL	equ		24
                            	    45: MBX_SIZE		equ		32
                            	    46: 
                            	    47: MSG_MAGIC   equ   0
                            	    48: MSG_LINK	  equ		4
                            	    49: MSG_RETADR  equ   8
                            	    50: MSG_TGTADR  equ   12
                            	    51: MSG_TYPE    equ   16
                            	    52: MSG_D1		  equ		20
                            	    53: MSG_D2		  equ		24
                            	    54: MSG_D3		  equ		28
                            	    55: MSG_SIZE	  equ		32
                            	    56: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     4: 
                            	     5: 	include "..\Femtiki\source\kernel\Femtiki_vars.x68"

Source: "..\Femtiki\source\kernel\Femtiki_vars.x68"
                            	     1: 
                            	     2: PAMShareCounts	EQU	$20000000	; one byte for each physical page of memory
                            	     3: tcbs						EQU	$20010000	; 4095*256 = 1MB
                            	     4: tcbs_end				EQU	$20020000
                            	     5: messages				EQU	$20020000	; 32*8192 (680*16=21760 messages)
                            	     6: messages_end		EQU	$20060000
                            	     7: mailboxes				EQU	$20060000
                            	     8: mailboxes_end		EQU	$20078000	;	12*8192 (816*12=9792 mailboxes)
                            	     9: acbs						EQU	$20080000	; 32*2*8192 =512kB
                            	    10: acbs_end				EQU	$20100000
                            	    11: 
                            	    12: 
                            	    13: sys_stacks			EQU	$DF0000
                            	    14: 
                            	    15: FemtikiVars			EQU	$00100200
                            	    16: PAMLastAllocate2	EQU		$00100218
                            	    17: RunningAID		EQU		$00100220
                            	    18: RunningTCB			EQU		$00100224
                            	    19: ACBPtrs				EQU		$00100228
                            	    20: MidStackBottoms	EQU		$00100264
                            	    21: FemtikiInited	EQU		$00100284
                            	    22: missed_ticks	EQU		$00100288
                            	    23: IOFocusList		EQU		$0010028C
                            	    24: IOFocusID			EQU		$001002AC
                            	    25: iof_switch		EQU		$001002AD
                            	    26: nMessage			EQU		$001002AE
                            	    27: nMailbox			EQU		$001002B0
                            	    28: hKeybdMbx			EQU		$001002BA
                            	    29: hFocusSwitchMbx		EQU		$001002BC
                            	    30: BIOS_RespMbx	EQU		$001002BE
                            	    31: hasUltraHighPriorityTasks	EQU		$001002C0
                            	    32: im_save				EQU		$001002C2
                            	    33: sp_tmp				EQU		$001002C4
                            	    34: startQNdx			EQU		$001002C6
                            	    35: NPAGES				EQU		$001002D8
                            	    36: syspages			EQU		$001002DA
                            	    37: mmu_FreeMaps	EQU		$001002E0
                            	    38: mmu_entries		EQU		$00100300
                            	    39: freelist			EQU		$00100302
                            	    40: hSearchMap		EQU		$00100304
                            	    41: OSActive			EQU		$00100305
                            	    42: FreeACB				EQU		$00100308
                            	    43: FreeTCB				EQU		$0010030C
                            	    44: FreeMSG				EQU		$00100310
                            	    45: FreeMBX				EQU		$00100314
                            	    46: TimeoutList		EQU		$00100318
                            	    47: QueueCycle    EQU   $0010031C
                            	    48: readyQ				EQU		$00100320		; 32 bytes per queue per core, 2 cores for now
                            	    49: readyQEnd			EQU		$00100360
                            	    50: FemtikiVars_end	EQU	$00100400
                            	    51: 
                            	    52: ;gc_stack		rmb		512
                            	    53: ;gc_pc				fcdw		0
                            	    54: ;gc_omapno		fcw			0
                            	    55: ;gc_mapno		fcw			0
                            	    56: ;gc_dl				fcw			0
                            	    57: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     6: 	code
                            	     7: 	even
                            	     8: 	include "..\Femtiki\source\kernel\tcb.x68"

Source: "..\Femtiki\source\kernel\tcb.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;------------------------------------------------------------------------------
                            	    38: ; Initialize variables related to TCBs.
                            	    39: ;------------------------------------------------------------------------------
                            	    40: 
                            	    41: TCBInit:
02:0000545C 41F920010000    	    42: 	lea tcbs,a0
02:00005462 4E7B8013        	    43: 	movec a0,tcba
02:00005466 700F            	    44: 	moveq #2*8-1,d0		; 2 cores, 32 bytes (8 lwords) per queue
02:00005468 72FF            	    45: 	moveq #-1,d1			; value to set
02:0000546A 41F900100320    	    46: 	lea readyQ,a0			; clear out ready queue
                            	    47: .0001
02:00005470 20C1            	    48: 	move.l d1,(a0)+
02:00005472 51C8FFFC        	    49: 	dbra d0,.0001
02:00005476 203C0003FFFF    	    50: 	move.l #TCB_SIZE*NR_TCB/4-1,d0
                            	    51: .clearTCBs
02:0000547C 4298            	    52: 	clr.l (a0)+
02:0000547E 51C8FFFC        	    53: 	dbra d0,.clearTCBs
02:00005482 4E75            	    54: 	rts
                            	    55: 
                            	    56: ;------------------------------------------------------------------------------
                            	    57: ; Convert a TCB handle into a pointer.
                            	    58: ;
                            	    59: ; Parameters:
                            	    60: ;		d0 = TCB handle
                            	    61: ; Returns:
                            	    62: ;		a0 = pointer to TCB
                            	    63: ;------------------------------------------------------------------------------
                            	    64: 
                            	    65: TCBHandleToPointer:
02:00005484 2F01            	    66: 	move.l d1,-(a7)
02:00005486 028000000FFF    	    67: 	andi.l #MAX_TID,d0		; limit to # threads
02:0000548C 4E7A1013        	    68: 	movec tcba,d1
02:00005490 E188            	    69: 	lsl.l #8,d0
02:00005492 D280            	    70: 	add.l d0,d1
02:00005494 2041            	    71: 	move.l d1,a0
02:00005496 E088            	    72: 	lsr.l #8,d0						; restore d0
02:00005498 221F            	    73: 	move.l (a7)+,d1
02:0000549A 4E75            	    74: 	rts
                            	    75: 
                            	    76: ;------------------------------------------------------------------------------
                            	    77: ; Convert a TCB pointer into a handle.
                            	    78: ;
                            	    79: ; Parameters:
                            	    80: ;		a0 = TCB pointer
                            	    81: ; Returns:
                            	    82: ;		d0 = TCB handle
                            	    83: ;------------------------------------------------------------------------------
                            	    84: 
                            	    85: TCBPointerToHandle:
02:0000549C 2F01            	    86: 	move.l d1,-(a7)				; save d1
02:0000549E 4E7A1013        	    87: 	movec tcba,d1
02:000054A2 91C1            	    88: 	sub.l d1,a0
02:000054A4 2008            	    89: 	move.l a0,d0
02:000054A6 E088            	    90: 	lsr.l #8,d0
02:000054A8 221F            	    91: 	move.l (a7)+,d1				; restore d1
02:000054AA 4E75            	    92: 	rts
                            	    93: 
                            	    94: ;------------------------------------------------------------------------------
                            	    95: ; Internal TCB allocation function.
                            	    96: ;
                            	    97: ; Parameters:
                            	    98: ;		none
                            	    99: ; Returns:
                            	   100: ;		d0 = handle for allocated TCB, NULL if none available
                            	   101: ;------------------------------------------------------------------------------
                            	   102: 
                            	   103: TCBIAlloc:
02:000054AC 30390010030C    	   104: 	move.w FreeTCB,d0				; d1 = Free handle
02:000054B2 6714            	   105: 	beq .0001
02:000054B4 2F08            	   106: 	move.l a0,-(sp)
02:000054B6 61CC            	   107: 	bsr TCBHandleToPointer	; convert to pointer
02:000054B8 3228007C        	   108: 	move.w TCBNext(a0),d1		; d1 = next on free list
02:000054BC 33C10010030C    	   109: 	move.w d1,FreeTCB				; update head of free list
02:000054C2 61D8            	   110: 	bsr TCBPointerToHandle	; convert pointer to handle
02:000054C4 205F            	   111: 	move.l (sp)+,a0
02:000054C6 4E75            	   112: 	rts
                            	   113: 	; Here there was no free TCB available. Return a NULL
                            	   114: .0001
02:000054C8 4E75            	   115: 	rts
                            	   116: 	
                            	   117: ;------------------------------------------------------------------------------
                            	   118: ; TCB allocation function. Locks the system semaphore during allocation.
                            	   119: ;
                            	   120: ; Parameters:
                            	   121: ;		none
                            	   122: ; Returns:
                            	   123: ;		d0 = handle for allocated TCB, NULL if none available
                            	   124: ;		d1 = E_Ok
                            	   125: ;------------------------------------------------------------------------------
                            	   126: 
                            	   127: TCBAlloc:
02:000054CA 61000326        	   128: 	bsr LockSysSemaphore
02:000054CE 61DC            	   129: 	bsr	TCBIAlloc
02:000054D0 61000330        	   130: 	bsr UnlockSysSemaphore
02:000054D4 7200            	   131: 	moveq #E_Ok,d1
02:000054D6 4E75            	   132: 	rts
                            	   133: 	
                            	   134: ;------------------------------------------------------------------------------
                            	   135: ; Internal TCB free function.
                            	   136: ;
                            	   137: ; Modifies:
                            	   138: ;		none
                            	   139: ; Parameters:
                            	   140: ;		d0 = handle to TCB
                            	   141: ; Returns:
                            	   142: ;		d0 = handle to TCB
                            	   143: ;------------------------------------------------------------------------------
                            	   144: 
                            	   145: TCBIFree:
02:000054D8 2F08            	   146: 	move.l a0,-(sp)
02:000054DA 61A8            	   147: 	bsr TCBHandleToPointer
02:000054DC 31790010030C007C	   148: 	move.w FreeTCB,TCBNext(a0)
02:000054E4 33C00010030C    	   149: 	move.w d0,FreeTCB
02:000054EA 205F            	   150: 	move.l (sp)+,a0
02:000054EC 4E75            	   151: 	rts
                            	   152: 
                            	   153: ;------------------------------------------------------------------------------
                            	   154: ; TCB free function. Locks the system sempaphore while freeing.
                            	   155: ;
                            	   156: ; Modifies:
                            	   157: ;		none
                            	   158: ; Parameters:
                            	   159: ;		d0 = handle to TCB
                            	   160: ; Returns:
                            	   161: ;		d0 = handle to TCB
                            	   162: ;		d1 = E_Ok
                            	   163: ;------------------------------------------------------------------------------
                            	   164: 
                            	   165: TCBFree:
02:000054EE 61000302        	   166: 	bsr LockSysSemaphore
02:000054F2 61E4            	   167: 	bsr TCBIFree
02:000054F4 6100030C        	   168: 	bsr UnlockSysSemaphore
02:000054F8 7200            	   169: 	moveq #E_Ok,d1
02:000054FA 4E75            	   170: 	rts
                            	   171: 
                            	   172: ;------------------------------------------------------------------------------
                            	   173: ; Given an affinity, chose the core number to run on.
                            	   174: ;
                            	   175: ; Parameters:
                            	   176: ;		a0 = pointer to TCB
                            	   177: ;	Returns:
                            	   178: ;		d0 = core number to run on
                            	   179: ;------------------------------------------------------------------------------
                            	   180: 
                            	   181: TCBAffineChose:
02:000054FC 48E75000        	   182: 	movem.l d1/d3,-(sp)
02:00005500 363C001F        	   183: 	move.w #31,d3										; limit number of bit selects to 32
02:00005504 12280082        	   184: 	move.b TCBAffinityBase(a0),d1		; d1 = starting bit
02:00005508 20280084        	   185: 	move.l TCBAffinity(a0),d0				; d0 = affinity mask
                            	   186: .0002
02:0000550C 0300            	   187: 	btst.l d1,d0										; is bit d1 set?
02:0000550E 6610            	   188: 	bne .0001												; if set, exit loop
02:00005510 5241            	   189: 	addq #1,d1
02:00005512 51CBFFF8        	   190: 	dbra d3,.0002
                            	   191: 	; no bits set? How?
02:00005516 117C00020082    	   192: 	move.b #2,TCBAffinityBase(a0)
02:0000551C 7000            	   193: 	moveq #0,d0											; just return core #2 (0)
02:0000551E 4E75            	   194: 	rts
                            	   195: .0001
02:00005520 1001            	   196: 	move.b d1,d0
02:00005522 5500            	   197: 	subi.b #2,d0										; cores start at #2
02:00005524 4880            	   198: 	ext.w d0
02:00005526 48C0            	   199: 	ext.l d0
02:00005528 5241            	   200: 	addq #1,d1											; increment bit selection for next time
02:0000552A 11410082        	   201: 	move.b d1,TCBAffinityBase(a0)		; and store in TCB
02:0000552E 4CDF000A        	   202: 	movem.l (sp)+,d1/d3
02:00005532 4E75            	   203: 	rts
                            	   204: 
                            	   205: ;------------------------------------------------------------------------------
                            	   206: ; Insert thread into ready queue. The thread is added at the tail of the 
                            	   207: ; queue. The queue is a doubly linked list.
                            	   208: ;
                            	   209: ; Stack Space:
                            	   210: ;		8 lwords
                            	   211: ; Modifies:
                            	   212: ;		none
                            	   213: ; Parameters:
                            	   214: ;		d0 = thread id to insert
                            	   215: ; Returns:
                            	   216: ;		d0 = TCB handle
                            	   217: ; ----------------------------------------------------------------------------
                            	   218: 
                            	   219: TCBInsertIntoReadyQueue:
02:00005534 48E770F0        	   220: 	movem.l d1-d3/a0-a3,-(sp)
02:00005538 2400            	   221: 	move.l d0,d2											; d2 = thread to insert
02:0000553A 6100FF48        	   222: 	bsr TCBHandleToPointer
02:0000553E 2648            	   223: 	move.l a0,a3											; a3 = TCB pointer of thread to insert
02:00005540 610002B0        	   224: 	bsr LockSysSemaphore
02:00005544 002800800054    	   225: 	ori.b #TS_RUNNING,TCBStatus(a0)
02:0000554A 61B0            	   226: 	bsr TCBAffineChose								; Chose which cores queue to use
02:0000554C EB88            	   227: 	lsl.l #5,d0												; 32 bytes per readyQ head/tail per core
02:0000554E 7200            	   228: 	clr.l d1
02:00005550 12280055        	   229: 	move.b TCBPriority(a0),d1					; d1 = priority
02:00005554 028100000007    	   230: 	andi.l #7,d1
02:0000555A E589            	   231: 	lsl.l #2,d1												; 4 bytes per priority level
02:0000555C D280            	   232: 	add.l d0,d1												; add in base queue
02:0000555E D2BC00100320    	   233: 	add.l #readyQ,d1									; add in start of ready queues
02:00005564 2241            	   234: 	move.l d1,a1
02:00005566 30290004        	   235: 	move.w 4(a1),d0										; d0 = tail entry
02:0000556A 3600            	   236: 	move.w d0,d3											; d3 = tail entry
02:0000556C 4A40            	   237: 	tst.w d0
02:0000556E 6D20            	   238: 	blt .qempty
02:00005570 6100FF12        	   239: 	bsr TCBHandleToPointer						; a0 = pointer to tail
02:00005574 2448            	   240: 	move.l a0,a2
02:00005576 2038007C        	   241: 	move.l TCBNext,d0
02:0000557A 6100FF08        	   242: 	bsr TCBHandleToPointer						; a0 = tail->next
02:0000557E 21420080        	   243: 	move.l d2,TCBPrev(a0)							; tail->next->prev = new entry
02:00005582 2542007C        	   244: 	move.l d2,TCBNext(a2)							; tail->next = new entry
02:00005586 2740007C        	   245: 	move.l d0,TCBNext(a3)							; new entry->next = tail->next
02:0000558A 27430080        	   246: 	move.l d3,TCBPrev(a3)							; new entry->prev = tail
02:0000558E 6012            	   247: 	bra .0002
                            	   248: .qempty
02:00005590 4A51            	   249: 	tst.w (a1)												; check if there is a list head
02:00005592 6C0E            	   250: 	bge .0002													; head with no tail -> list corrupt
02:00005594 33420004        	   251: 	move.w d2,4(a1)										; head and tail equal new entry
02:00005598 3282            	   252: 	move.w d2,(a1)
02:0000559A 3742007C        	   253: 	move.w d2,TCBNext(a3)							; next and prev of new entry point to self
02:0000559E 37420080        	   254: 	move.w d2,TCBPrev(a3)
                            	   255: 	; Head but no tail, list corrupt?
                            	   256: .0002
02:000055A2 6100025E        	   257: 	bsr UnlockSysSemaphore
02:000055A6 4CDF0F0E        	   258: 	movem.l (sp)+,d1-d3/a0-a3
02:000055AA 4E75            	   259: 	rts
                            	   260: 
                            	   261: ;------------------------------------------------------------------------------
                            	   262: ; Remove a thread from the ready queue. Actual removal is not done here, it
                            	   263: ; is done the next time the thread is selected to run. Just mark the thread as
                            	   264: ; not running.
                            	   265: ;
                            	   266: ; Parameters:
                            	   267: ;		d0 = thread id to remove
                            	   268: ; Returns:
                            	   269: ;		none
                            	   270: ; -----------------------------------------------------------------------------
                            	   271: 
                            	   272: TCBRemoveFromReadyQueue:
02:000055AC 4A40            	   273: 	cmpi.w #0,d0
02:000055AE 6D1C            	   274: 	blt .0001
02:000055B0 028000000FFF    	   275: 	andi.l #MAX_TID,d0									; limit to # of threads
02:000055B6 2F08            	   276: 	move.l a0,-(sp)
02:000055B8 6100FECA        	   277: 	bsr	TCBHandleToPointer
02:000055BC 61000234        	   278: 	bsr LockSysSemaphore
02:000055C0 0228007F0054    	   279: 	andi.b #TS_RUNNING^$FF,TCBStatus(a0)
02:000055C6 6100023A        	   280: 	bsr UnlockSysSemaphore
02:000055CA 205F            	   281: 	move.l (sp)+,a0
                            	   282: .0001
02:000055CC 4E75            	   283: 	rts
                            	   284: 	
                            	   285: ; ----------------------------------------------------------------------------
                            	   286: ; Register Usage
                            	   287: ;		d0 = temporary
                            	   288: ;		d1 = index into list of queues
                            	   289: ;		d2 = index to queue set
                            	   290: ;		d4 = queue counter, goes from 7 down to 0
                            	   291: ;		d5 = temporary
                            	   292: ;		d6 = next on list
                            	   293: ;		a0 = temporary pointer to TCB
                            	   294: ;		a1 = pointer to queue
                            	   295: ;		a2 = pointer to old head of list
                            	   296: ;		a3 = pointer to TCB at head of queue
                            	   297: ; Modifies:
                            	   298: ;		none
                            	   299: ; Parameters:
                            	   300: ;		none
                            	   301: ; Returns:
                            	   302: ;		a0 = pointer to TCB, NULL if none on list
                            	   303: ;		d0 = TCB handle
                            	   304: ; ----------------------------------------------------------------------------
                            	   305: 
                            	   306: StartQ
02:000055CE 01              	   307: 	dc.b 1,2,3,4,1,5,6,7
02:000055CF 02
02:000055D0 03
02:000055D1 04
02:000055D2 01
02:000055D3 05
02:000055D4 06
02:000055D5 07
                            	   308: 
                            	   309: 	even
                            	   310: TCBPopReadyQueue:
02:000055D6 48E77E70        	   311: 	movem.l	d1-d6/a1-a3,-(a7)
02:000055DA 4E7A2FE0        	   312: 	movec coreno,d2					; select the queue set based on the core number
02:000055DE 5502            	   313: 	subi.b #2,d2						; cores start at #2
02:000055E0 EB8A            	   314: 	lsl.l #5,d2							; d2 = index to queue set, 32 bytes per queue set
02:000055E2 7807            	   315: 	moveq #7,d4							; d4 = queue count
02:000055E4 6100020C        	   316: 	bsr LockSysSemaphore
                            	   317: 	; One in four tries pick a different priority to start searching from. 
02:000055E8 12390010031C    	   318: 	move.b QueueCycle,d1		; increment Queue cycle counter
02:000055EE 5201            	   319: 	addi.b #1,d1
02:000055F0 02010007        	   320: 	andi.b #7,d1
02:000055F4 13C10010031C    	   321: 	move.b d1,QueueCycle
02:000055FA 6612            	   322: 	bne	.0001
02:000055FC 43FAFFD0        	   323: 	lea StartQ,a1
02:00005600 4881            	   324: 	ext.w d1
02:00005602 12311000        	   325: 	move.b (a1,d1.w),d1
02:00005606 02410007        	   326: 	andi.w #7,d1						; limit to number of queues
02:0000560A E549            	   327: 	lsl.w #2,d1							; make into lword index
02:0000560C 6002            	   328: 	bra .0002
                            	   329: .0001
02:0000560E 7200            	   330: 	moveq #0,d1							; start at Queue #0
                            	   331: .0002
02:00005610 43F900100320    	   332: 	lea readyQ,a1						; a1 = pointer to list of ready queues
02:00005616 D3C2            	   333: 	add.l d2,a1							; a1 = pointer to queue set
02:00005618 36311000        	   334: 	move.w (a1,d1.w),d3			; d3 = old head of list
02:0000561C 6D4E            	   335: 	blt .nextQ							; anything on list?, if not go next queue
02:0000561E 3003            	   336: 	move.w d3,d0						; d0 = old head of list
02:00005620 6100FE62        	   337: 	bsr TCBHandleToPointer
02:00005624 2448            	   338: 	move.l a0,a2						; a2 = pointer to old head of list
02:00005626 3A2A007C        	   339: 	move.w TCBNext(a2),d5		; remove head of list from list
02:0000562A BA80            	   340: 	cmp.l d0,d5							; removing last TCB?
02:0000562C 6736            	   341: 	beq .removeLast
02:0000562E 3C05            	   342: 	move.w d5,d6						; d6 = next on list
02:00005630 3005            	   343: 	move.w d5,d0						; d0 = next on list
02:00005632 6100FE50        	   344: 	bsr TCBHandleToPointer	; a0 = pointer to next TCB on list
02:00005636 3A2A0080        	   345: 	move.w TCBPrev(a2),d5		; d5 = previous TCB from head
02:0000563A 31450080        	   346: 	move.w d5,TCBPrev(a0)		; next->prev = head->prev
02:0000563E 3005            	   347: 	move.w d5,d0
02:00005640 6100FE42        	   348: 	bsr TCBHandleToPointer	; a0 = pointer to previous TCB from head
02:00005644 3146007C        	   349: 	move.w d6,TCBNext(a0)		; head->prev->next = next
                            	   350: .0003
02:00005648 33861000        	   351: 	move.w d6,(a1,d1.w)			; reset head of list to next
02:0000564C 3543007C        	   352: 	move.w d3,TCBNext(a2)		; point links back to self
02:00005650 35430080        	   353: 	move.w d3,TCBPrev(a2)
02:00005654 3003            	   354: 	move.w d3,d0						; return handle in d0
02:00005656 48C0            	   355: 	ext.l d0
02:00005658 204A            	   356: 	move.l a2,a0						; return pointer in a0
                            	   357: .0004
02:0000565A 610001A6        	   358: 	bsr UnlockSysSemaphore
02:0000565E 4CDF0E7E        	   359: 	movem.l	(a7)+,d1-d6/a1-a3
02:00005662 4E75            	   360: 	rts
                            	   361: .removeLast
02:00005664 7CFF            	   362: 	moveq #-1,d6						; set head to negative when removing last
02:00005666 33861002        	   363: 	move.w d6,2(a1,d1.w)		; tail = negative
02:0000566A 60DC            	   364: 	bra .0003
                            	   365: .nextQ
02:0000566C 5841            	   366: 	addi.w #4,d1						; increment queue number by lword
02:0000566E 0241001C        	   367: 	andi.w #$1C,d1					; limit to number of queues
02:00005672 51CCFF9C        	   368: 	dbra d4,.0002						; go back and check the next queue
02:00005676 70FF            	   369: 	moveq #-1,d0						; return handle < 0 if nothing in any queue
02:00005678 91C8            	   370: 	suba.l a0,a0						; and NULL pointer
02:0000567A 60DE            	   371: 	bra	.0004								; return NULL pointer if nothing in any queue
                            	   372: 
                            	   373: ;------------------------------------------------------------------------------
                            	   374: ; Remove a thread from the timeout list.
                            	   375: ; Called when a mailbox is freed and a thread is waiting at the
                            	   376: ; mailbox.
                            	   377: ;
                            	   378: ; Parameters:
                            	   379: ;		B = task id to remove
                            	   380: ; Modifies:
                            	   381: ;		none
                            	   382: ; Returns:
                            	   383: ;		none
                            	   384: ;------------------------------------------------------------------------------
                            	   385: 	if 0
                            	   386: RemoveFromTimeoutList:
                            	   387: 	pshs	d,w,x,y,u
                            	   388: 	cmpb	TimeoutList			; head of list?
                            	   389: 	beq		0001f
                            	   390: 	lbsr	TCBHandleToPointer
                            	   391: 	tfr		d,x
                            	   392: 	ldb		TCBNext,x
                            	   393: 	clra
                            	   394: 	tfr		d,u
                            	   395: 	ldf		TCBPrev,x
                            	   396: 	lbsr	TCBHandleToPointer
                            	   397: 	tfr		d,y
                            	   398: 	stf		TCBPrev,y
                            	   399: 	tfr		f,b
                            	   400: 	clra
                            	   401: 	lbsr	TCBHandleToPointer
                            	   402: 	tfr		d,y
                            	   403: 	tfr		u,d
                            	   404: 	stb		TCBNext,y
                            	   405: 	bra		0002f
                            	   406: 	; Removing from head of timeout list
                            	   407: 0001:
                            	   408: 	lbsr	TCBHandleToPointer
                            	   409: 	tfr		d,x
                            	   410: 	ldb		TCBNext,x
                            	   411: 	stb		TimeoutList		; set new head of list
                            	   412: 	clra
                            	   413: 	lbsr	TCBHandleToPointer
                            	   414: 	tfr		d,y
                            	   415: 	clrb
                            	   416: 	stb		TCBPrev,y			; next->prev = NULL
                            	   417: 0002:
                            	   418: 	clrd
                            	   419: 	std		TCBNext,x			; next = NULL
                            	   420: 	std		TCBPrev,x			; prev = NULL
                            	   421: 	puls	d,w,x,y,u,pc
                            	   422: 	
                            	   423: ;// ----------------------------------------------------------------------------
                            	   424: ;// Pop the top entry from the timeout list.
                            	   425: ;// ----------------------------------------------------------------------------
                            	   426: ;
                            	   427: ;hTCB PopTimeoutList()
                            	   428: ;{
                            	   429: ;    TCB *p;
                            	   430: ;    hTCB h;
                            	   431: ;
                            	   432: ;    h = TimeoutList;
                            	   433: ;    if (TimeoutList > 0 && TimeoutList < NR_TCB) {
                            	   434: ;        TimeoutList = tcbs[TimeoutList].next;
                            	   435: ;        if (TimeoutList >= 0 && TimeoutList < NR_TCB) {
                            	   436: ;            tcbs[TimeoutList].prev = h->prev;
                            	   437: ;            h->prev->next = TimeoutList;
                            	   438: ;        }
                            	   439: ;    }
                            	   440: ;    return h;
                            	   441: ;}
                            	   442: ;
                            	   443: ; Returns:
                            	   444: ;		B = task at top of list
                            	   445: ;
                            	   446: 
                            	   447: PopTimeoutList:
                            	   448: 	pshs	w,x,y
                            	   449: 	ldb		TimeoutList
                            	   450: 	pshs	b
                            	   451: 	beq		0001f
                            	   452: 	cmpb	#NR_TCB
                            	   453: 	bhs		0001f
                            	   454: 	bsr		TCBHandleToPointer
                            	   455: 	tfr		d,x
                            	   456: 	ldb		TCBNext,x
                            	   457: 	tfr		b,f
                            	   458: 	lde		TCBPrev,x
                            	   459: 	stb		TimeoutList
                            	   460: 	beq		0001f
                            	   461: 	cmpb	#NR_TCB
                            	   462: 	bhs		0001f
                            	   463: 	bsr		TCBHandleToPointer
                            	   464: 	tfr		d,y
                            	   465: 	ste		TCBPrev,y
                            	   466: 	tfr		e,b
                            	   467: 	bsr		TCBHandleToPointer
                            	   468: 	tfr		d,y
                            	   469: 	stf		TCBNext,y
                            	   470: 	clr		TCBPrev,x
                            	   471: 	clr		TCBNext,x
                            	   472: 0001:
                            	   473: 	puls	b
                            	   474: 	puls	x,y,w,pc
                            	   475: 
                            	   476: ; ----------------------------------------------------------------------------
                            	   477: ; ----------------------------------------------------------------------------
                            	   478: DispTwoSpace:
                            	   479: 	bsr	DispSpace
                            	   480: DispSpace:
                            	   481: 	ldb		#' '
                            	   482: 	swi
                            	   483: 	fcb		MF_OUTCH
                            	   484: 	rts
                            	   485: 
                            	   486: DumpTCBs:
                            	   487: 	swi
                            	   488: 	fcb		MF_CRLF
                            	   489: 	ldb		#1
                            	   490: 0002:
                            	   491: 	lbsr	TCBHandleToPointer
                            	   492: 	tfr		d,x
                            	   493: 	ldb		TCBtid,x
                            	   494: 	swi
                            	   495: 	fcb		MF_DisplayByteAsHex
                            	   496: 	bsr		DispSpace
                            	   497: 	ldb		TCBStatus,x
                            	   498: 	swi
                            	   499: 	fcb		MF_DisplayByteAsHex
                            	   500: 	bsr		DispTwoSpace
                            	   501: 	swi
                            	   502: 	fcb		MF_CRLF
                            	   503: 	ldb		TCBNext,x
                            	   504: 	beq		0001f
                            	   505: 	bra		0002b
                            	   506: 0001:
                            	   507: 	rts
                            	   508: 	
                            	   509: fcb	"TID Stat"
                            	   510: 	endif
                            	   511: 
                            	   512: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     9: 	include "..\Femtiki\source\kernel\Femtiki.x68"

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     1: 	code
                            	     2: 	even
                            	     3: ;------------------------------------------------------------------------------
                            	     4: ; Initialize the Femtiki OS.
                            	     5: ;------------------------------------------------------------------------------
                            	     6: 
                            	     7: FemtikiInit:
02:0000567C 7000            	     8: 	moveq #0,d0
02:0000567E 4E7B0012        	     9: 	movec d0,tr
02:00005682 6100FDD8        	    10: 	bsr TCBInit
02:00005686 42390010031C    	    11: 	clr.b QueueCycle
                            	    12: FemtikiInitIRQ:
02:0000568C 43FA00DC        	    13: 	lea FemtikiTimerIRQ,a1						; Set timer IRQ vector to Femtiki
02:00005690 4E7A8801        	    14: 	movec vbr,a0
02:00005694 21490078        	    15: 	move.l a1,30*4(a0)								; vector #30
02:00005698 4E75            	    16: 	rts
                            	    17: 
                            	    18: ;------------------------------------------------------------------------------
                            	    19: ; Operating system call dispatcher.
                            	    20: ; On entry, the task state has been saved including the system stack pointer,
                            	    21: ; in the task control block.
                            	    22: ;------------------------------------------------------------------------------
                            	    23: 
                            	    24: OSCallTable
02:0000569A 0000            	    25: 	dc.w		0
                            	    26: 
                            	    27: 	even
                            	    28: CallOS:
02:0000569C 2F08            	    29: 	move.l	a0,-(a7)
02:0000569E 207900100224    	    30: 	move.l	RunningTCB,a0
02:000056A4 48E8FFFF0004    	    31: 	movem.l d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,TCBRegs(a0)
02:000056AA 225F            	    32: 	move.l	(a7)+,a1
02:000056AC 21490020        	    33: 	move.l	a1,32(a0)
02:000056B0 4E7A9800        	    34: 	movec		usp,a1
02:000056B4 21490044        	    35: 	move.l	a1,TCBUSP(a0)
02:000056B8 301F            	    36: 	move.w	(a7)+,d0					; pop the status register
02:000056BA 3140004C        	    37: 	move.w	d0,TCBSR(a0)			; save in TCB
02:000056BE 225F            	    38: 	move.l	(a7)+,a1					; pop the program counter
02:000056C0 5489            	    39: 	lea	2(a1),a1							; increment past inline callno argument
02:000056C2 21490050        	    40: 	move.l	a1,TCBPC(a0)			; save PC in TCB
02:000056C6 214F0048        	    41: 	move.l	a7,TCBSSP(a0)			; finally save SSP
02:000056CA 3029FFFE        	    42: 	move.w	-2(a1),d0					; d0 = call number
02:000056CE E548            	    43: 	lsl.w		#2,d0							; make into table index
02:000056D0 43FAFFC8        	    44: 	lea			OSCallTable,a1
02:000056D4 22710000        	    45: 	move.l	(a1,d0.w),a1
02:000056D8 4E91            	    46: 	jsr			(a1)							; call the OS function
                            	    47: 	; Restore the thread context and return
02:000056DA 207900100224    	    48: 	move.l	RunningTCB,a0
02:000056E0 2E780048        	    49: 	move.l	TCBSSP,a7
02:000056E4 2F280050        	    50: 	move.l	TCBPC(a0),-(a7)		; setup the PC and the SR on the stack
02:000056E8 3F28004C        	    51: 	move.w	TCBSR(a0),-(a7)		; prep for RTE
02:000056EC 20380044        	    52: 	move.l	TCBUSP,d0					; restore user stack pointer
02:000056F0 4E7B0800        	    53: 	movec		d0,usp
02:000056F4 4CE800FF0004    	    54: 	movem.l	TCBRegs(a0),d0/d1/d2/d3/d4/d5/d6/d7
02:000056FA 4CE87E00002C    	    55: 	movem.l TCBRegs+40(a0),a1/a2/a3/a4/a5/a6
02:00005700 20680024        	    56: 	move.l	TCBRegs+32(a0),a0
02:00005704 4E73            	    57: 	rte
                            	    58: 
                            	    59: ;------------------------------------------------------------------------------
                            	    60: ; Get a pointer to the currently running TCB.
                            	    61: ;
                            	    62: ; Returns:
                            	    63: ;		a0 = pointer to running TCB
                            	    64: ;------------------------------------------------------------------------------
                            	    65: 
                            	    66: GetRunningTCBPointer:
02:00005706 48E7C000        	    67: 	movem.l d0/d1,-(a7)
02:0000570A 4E7A0012        	    68: 	movec tr,d0
02:0000570E 6100FD74        	    69: 	bsr TCBHandleToPointer
02:00005712 028000000FFF    	    70: 	andi.l #MAX_TID,d0		; limit to # threads
02:00005718 4CDF0003        	    71: 	movem.l (a7)+,d0/d1
02:0000571C 4E75            	    72: 	rts
                            	    73: 
                            	    74: ; ----------------------------------------------------------------------------
                            	    75: ; Select a thread to run. Relatively easy. All that needs to be done is to
                            	    76: ; keep popping the queue until a valid running task is found. There should
                            	    77: ; always be at least one thread in the queue.
                            	    78: ;
                            	    79: ; Modifies:
                            	    80: ;		none
                            	    81: ; Returns:
                            	    82: ;		d0 = handle of the next thread to run
                            	    83: ; ----------------------------------------------------------------------------
                            	    84: 
                            	    85: SelectThreadToRun:
                            	    86: .0001										; keep popping tasks from the readyQ until a valid one
02:0000571E 6100FEB6        	    87: 	bsr	TCBPopReadyQueue	; is found.
02:00005722 4A40            	    88: 	tst.w d0
02:00005724 6B0C            	    89: 	bmi	.0002
02:00005726 0C2800800054    	    90: 	cmpi.b #TS_RUNNING,TCBStatus(a0)	; ensure the thread is to be running
02:0000572C 66F0            	    91: 	bne	.0001													; if not, go get the next thread
02:0000572E 6000FE04        	    92: 	bra	TCBInsertIntoReadyQueue				; insert thread back into queue
                            	    93: 	; Nothing in queues? There is supposed to be. Add the OS task to the queue.
                            	    94: .0002
02:00005732 4E7A8013        	    95: 	movec tcba,a0
02:00005736 117C00800054    	    96: 	move.b #TS_RUNNING,TCBStatus(a0)	; flag as RUNNING
02:0000573C 117C00040055    	    97: 	move.b #4,TCBPriority(a0)					; OS has normal priority
02:00005742 7000            	    98: 	moveq #0,d0												; fast pointer to handle
02:00005744 6000FDEE        	    99: 	bra TCBInsertIntoReadyQueue
                            	   100: 
                            	   101: ; ----------------------------------------------------------------------------
                            	   102: ; Update the IRQ live indicator on screen.
                            	   103: ; ----------------------------------------------------------------------------
                            	   104: 
                            	   105: UpdateIRQLive:
02:00005748 227900040004    	   106: 	move.l TextScr,a1					; a1 = screen address
02:0000574E 2411            	   107: 	move.l (a1),d2
02:00005750 E15A            	   108: 	rol.w	#8,d2								; reverse byte order of d2
02:00005752 4842            	   109: 	swap d2
02:00005754 E15A            	   110: 	rol.w	#8,d2
02:00005756 06010030        	   111: 	addi.b #'0',d1						; binary to ascii core number
02:0000575A D202            	   112: 	add.b	d2,d1
02:0000575C E159            	   113: 	rol.w	#8,d1								; put bytes back in order
02:0000575E 4841            	   114: 	swap d1
02:00005760 E159            	   115: 	rol.w	#8,d1
02:00005762 23410004        	   116: 	move.l d1,4(a1)						; update onscreen IRQ flag
02:00005766 5291            	   117: 	addi.l #1,(a1)						; flashy colors
02:00005768 4E75            	   118: 	rts
                            	   119: 
                            	   120: ; ----------------------------------------------------------------------------
                            	   121: ; Femtiki IRQ service routine. This is where a thread switch can occur so,
                            	   122: ; the thread context is saved and restored.
                            	   123: ; ----------------------------------------------------------------------------
                            	   124: 
                            	   125: FemtikiTimerIRQ:
02:0000576A 46FC2600        	   126: 	move.w #$2600,sr							; disable lower level IRQs
02:0000576E 2F00            	   127: 	move.l d0,-(a7)
02:00005770 2F08            	   128: 	move.l a0,-(a7)
02:00005772 6192            	   129: 	bsr GetRunningTCBPointer			; a0 = pointer to running TCB
02:00005774 48E8FFFF0004    	   130: 	movem.l #$FFFF,TCBRegs(a0)		; save all registers
02:0000577A 201F            	   131: 	move.l (a7)+,d0
02:0000577C 21400020        	   132: 	move.l d0,32(a0)							; save original a0 value
02:00005780 201F            	   133: 	move.l (a7)+,d0
02:00005782 2080            	   134: 	move.l d0,(a0)								; save original d0 value
02:00005784 4E7A0800        	   135: 	movec usp,d0									; save user stack pointer
02:00005788 21400044        	   136: 	move.l d0,TCBUSP(a0)
02:0000578C 2E7C00040BFC    	   137: 	move.l #TimerStack,a7					; reset stack pointer
02:00005792 4E7A1FE0        	   138: 	movec	coreno,d1								; d1 = core number
02:00005796 0C010002        	   139: 	cmpi.b #2,d1
02:0000579A 6612            	   140: 	bne.s	.0002
02:0000579C 23FC1D000000FD09	   141: 	move.l #$1D000000,PLIC+$14		; reset edge sense circuit
02:000057A4 0014
02:000057A6 13FC0001000400A0	   142: 	move.b #1,IRQFlag							; set IRQ flag for TinyBasic shell
                            	   143: .0002
02:000057AE 6198            	   144: 	bsr UpdateIRQLive							; Update IRQ live indicator
                            	   145: ;	bsr ReceiveMsg								; Check for RPC
02:000057B0 4E7A0FF0        	   146: 	movec tick,d0									; Update time accounting
02:000057B4 21400070        	   147: 	move.l d0,TCBEndTick(a0)			; compute number of ticks thread was running
02:000057B8 90A8006C        	   148: 	sub.l	TCBStartTick(a0),d0
02:000057BC D1A80074        	   149: 	add.l	d0,TCBTicks(a0)					; add to cumulative ticks
02:000057C0 117C00200054    	   150: 	move.b #TS_PREEMPT,TCBStatus(a0)	; set thread status to PREEMPT
02:000057C6 6100FF56        	   151: 	bsr	SelectThreadToRun					; d0 = TCB handle
02:000057CA 4E7B0012        	   152: 	movec d0,tr										; set running thread number in tr
02:000057CE 6100FF36        	   153: 	bsr GetRunningTCBPointer			; a0 = pointer to TCB
02:000057D2 117C00800054    	   154: 	move.b #TS_RUNNING,TCBStatus(a0)	; set thread status to RUNNING
02:000057D8 4E7A0FF0        	   155: 	movec	tick,d0
02:000057DC 2140006C        	   156: 	move.l d0,TCBStartTick(a0)		; record starting tick
02:000057E0 20280044        	   157: 	move.l TCBUSP(a0),d0					; restore user stack pointer
02:000057E4 4E7B0800        	   158: 	movec d0,usp
02:000057E8 4CE8FFFF0004    	   159: 	movem.l TCBRegs(a0),#$FFFF		; restore all registers
02:000057EE 504F            	   160: 	addq #8,sp										; "pop" d0/a0, saved stack pointer is off by 8
02:000057F0 4E73            	   161: 	rte														; and return
                            	   162: 
                            	   163: 	include "..\Femtiki\source\kernel\Semaphore.x68"

Source: "..\Femtiki\source\kernel\Semaphore.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;-------------------------------------------------------------------------------
                            	    38: ; Lock the system semaphore. Call the BIOS.
                            	    39: ;
                            	    40: ; Parameters:
                            	    41: ;		none
                            	    42: ; Returns:
                            	    43: ;		none
                            	    44: ;-------------------------------------------------------------------------------
                            	    45: 
                            	    46: LockSysSemaphore:
02:000057F2 48E7C000        	    47: 	movem.l d0/d1,-(sp)
02:000057F6 7025            	    48: 	moveq #37,d0				; lock semaphore
02:000057F8 7208            	    49: 	moveq #FMTK_SEMA,d1
02:000057FA 4E4F            	    50: 	trap #15
02:000057FC 4CDF0003        	    51: 	movem.l (sp)+,d0/d1
02:00005800 4E75            	    52: 	rts
                            	    53: 
                            	    54: 
                            	    55: ;-------------------------------------------------------------------------------
                            	    56: ; Unlock the system semaphore.
                            	    57: ;
                            	    58: ; Parameters:
                            	    59: ;		none
                            	    60: ; Returns:
                            	    61: ;		none
                            	    62: ;-------------------------------------------------------------------------------
                            	    63: 
                            	    64: UnlockSysSemaphore:
02:00005802 48E7C000        	    65: 	movem.l d0/d1,-(sp)
02:00005806 7026            	    66: 	moveq #38,d0				; unlock semaphore
02:00005808 7208            	    67: 	moveq #FMTK_SEMA,d1
02:0000580A 4E4F            	    68: 	trap #15
02:0000580C 4CDF0003        	    69: 	movem.l (sp)+,d0/d1
02:00005810 4E75            	    70: 	rts
                            	    71: 
                            	    72: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	   164: 
                            	   165: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	    10: 

Source: "boot.x68"
                            	   890: 
                            	   891: ; -----------------------------------------------------------------------------
                            	   892: ; Gets the screen color in d0 and d1.
                            	   893: ; -----------------------------------------------------------------------------
                            	   894: 
                            	   895: get_screen_color:
02:00005812 203900040084    	   896: 	move.l	fgColor,d0			; get foreground color
02:00005818 EB80            	   897: 	asl.l		#5,d0						; shift into position
02:0000581A 008040000000    	   898: 	ori.l		#$40000000,d0		; set priority
02:00005820 223900040088    	   899: 	move.l	bkColor,d1
02:00005826 E089            	   900: 	lsr.l		#8,d1
02:00005828 E089            	   901: 	lsr.l		#8,d1
02:0000582A 02810000001F    	   902: 	andi.l	#31,d1					; mask off extra bits
02:00005830 8081            	   903: 	or.l		d1,d0						; set background color bits in upper long word
02:00005832 223900040088    	   904: 	move.l	bkColor,d1			; get background color
02:00005838 E181            	   905: 	asl.l		#8,d1						; shift into position for display ram
02:0000583A E181            	   906: 	asl.l		#8,d1
02:0000583C 4E75            	   907: 	rts
                            	   908: 
                            	   909: ; -----------------------------------------------------------------------------
                            	   910: ; -----------------------------------------------------------------------------
                            	   911: 
                            	   912: get_screen_address:
02:0000583E 207900040004    	   913: 	move.l	TextScr,a0
02:00005844 4E75            	   914: 	rts
                            	   915: 	
                            	   916: ; -----------------------------------------------------------------------------
                            	   917: ; -----------------------------------------------------------------------------
                            	   918: 
                            	   919: clear_screen:
02:00005846 48E7E080        	   920: 	movem.l	d0/d1/d2/a0,-(a7)
02:0000584A 4E7A0FE0        	   921: 	movec		coreno,d0
02:0000584E 4840            	   922: 	swap		d0	
                            	   923: ;	moveq		#SCREEN_SEMA,d1
                            	   924: ;	bsr			LockSemaphore
02:00005850 61EC            	   925: 	bsr			get_screen_address	; a0 = pointer to screen area
02:00005852 10390004008C    	   926: 	move.b	TextRows,d0					; d0 = rows
02:00005858 14390004008D    	   927: 	move.b	TextCols,d2					; d2 = cols
02:0000585E 4880            	   928: 	ext.w		d0									; convert to word
02:00005860 4882            	   929: 	ext.w		d2									; convert to word
02:00005862 C4C0            	   930: 	mulu		d0,d2								; d2 = number of character cells to clear
02:00005864 61AC            	   931: 	bsr			get_screen_color		; get the color bits
02:00005866 00410020        	   932: 	ori.w		#32,d1							; load space character
02:0000586A E159            	   933: 	rol.w		#8,d1								; swap endian, text controller expects little endian
02:0000586C 4841            	   934: 	swap		d1
02:0000586E E159            	   935: 	rol.w		#8,d1
02:00005870 E158            	   936: 	rol.w		#8,d0								; swap endian
02:00005872 4840            	   937: 	swap		d0
02:00005874 E158            	   938: 	rol.w		#8,d0
                            	   939: loop3:
02:00005876 20C1            	   940: 	move.l d1,(a0)+							; copy char plus bkcolor to cell
02:00005878 20C0            	   941: 	move.l d0,(a0)+							; copy fgcolor to cell
02:0000587A 51CAFFFA        	   942: 	dbra d2,loop3
02:0000587E 4E7A0FE0        	   943: 	movec coreno,d0
02:00005882 4840            	   944: 	swap d0	
                            	   945: ;	moveq #SCREEN_SEMA,d1
                            	   946: ;	bsr UnlockSemaphore
02:00005884 4CDF0107        	   947: 	movem.l (a7)+,d0/d1/d2/a0
02:00005888 4E75            	   948: 	rts
                            	   949: 
                            	   950: CRLF:
02:0000588A 2F01            	   951: 	move.l	d1,-(a7)
02:0000588C 123C000D        	   952: 	move.b	#13,d1
02:00005890 6142            	   953: 	bsr			DisplayChar
02:00005892 123C000A        	   954: 	move.b	#10,d1
02:00005896 613C            	   955: 	bsr			DisplayChar
02:00005898 221F            	   956: 	move.l	(a7)+,d1
02:0000589A 4E75            	   957: 	rts
                            	   958: 
                            	   959: ;------------------------------------------------------------------------------
                            	   960: ;------------------------------------------------------------------------------
                            	   961: 
                            	   962: UpdateTextPos:
02:0000589C 103900040000    	   963: 	move.b	CursorRow,d0		; compute screen location
02:000058A2 0240007F        	   964: 	andi.w	#$7f,d0
02:000058A6 14390004008D    	   965: 	move.b	TextCols,d2
02:000058AC 4882            	   966: 	ext.w		d2
02:000058AE C0C2            	   967: 	mulu.w	d2,d0
02:000058B0 2600            	   968: 	move.l	d0,d3
02:000058B2 143900040001    	   969: 	move.b	CursorCol,d2
02:000058B8 024200FF        	   970: 	andi.w	#$ff,d2
02:000058BC D042            	   971: 	add.w		d2,d0
02:000058BE 33C000040002    	   972: 	move.w	d0,TextPos			; save cursor pos
02:000058C4 4E75            	   973: 	rts
                            	   974: 
                            	   975: ;------------------------------------------------------------------------------
                            	   976: ; Calculate screen memory location from CursorRow,CursorCol.
                            	   977: ; Destroys d0,d2,a0
                            	   978: ;------------------------------------------------------------------------------
                            	   979: 
                            	   980: CalcScreenLoc:
02:000058C6 61D4            	   981: 	bsr			UpdateTextPos
02:000058C8 48C0            	   982: 	ext.l		d0								; make it into a long
02:000058CA E780            	   983: 	asl.l		#3,d0							; 8 bytes per char
02:000058CC 6100FF70        	   984: 	bsr			get_screen_address
02:000058D0 D1C0            	   985: 	add.l		d0,a0							; a0 = screen location
02:000058D2 4E75            	   986: 	rts
                            	   987: 
                            	   988: ;------------------------------------------------------------------------------
                            	   989: ; Display a character on the screen
                            	   990: ; d1.b = char to display
                            	   991: ;------------------------------------------------------------------------------
                            	   992: 
                            	   993: DisplayChar:
02:000058D4 48E77000        	   994: 	movem.l	d1/d2/d3,-(a7)
02:000058D8 4E7A2FE0        	   995: 	movec		coreno,d2
02:000058DC 0C020002        	   996: 	cmpi.b	#2,d2
                            	   997: ;	bne.s		.0001
                            	   998: ;	bsr			SerialPutChar
                            	   999: .0001:
02:000058E0 0281000000FF    	  1000: 	andi.l	#$ff,d1				; zero out upper bytes of d1
02:000058E6 0C01000D        	  1001: 	cmpi.b	#13,d1				; carriage return ?
02:000058EA 6610            	  1002: 	bne			dccr
02:000058EC 423900040001    	  1003: 	clr.b		CursorCol			; just set cursor column to zero on a CR
                            	  1004: dcx14:
02:000058F2 610002B2        	  1005: 	bsr			SyncCursor		; set position in text controller
                            	  1006: dcx7:
02:000058F6 4CDF000E        	  1007: 	movem.l	(a7)+,d1/d2/d3
02:000058FA 4E75            	  1008: 	rts
                            	  1009: dccr:
02:000058FC 0C010091        	  1010: 	cmpi.b	#$91,d1			; cursor right ?
02:00005900 6618            	  1011: 	bne.s   dcx6
02:00005902 14390004008D    	  1012: 	move.b	TextCols,d2
02:00005908 5302            	  1013: 	sub.b		#1,d2
02:0000590A 943900040001    	  1014: 	sub.b		CursorCol,d2
02:00005910 67E4            	  1015: 	beq.s		dcx7
02:00005912 523900040001    	  1016: 	addi.b	#1,CursorCol
02:00005918 60D8            	  1017: 	bra.s		dcx14
                            	  1018: dcx6:
02:0000591A 0C010090        	  1019: 	cmpi.b	#$90,d1			; cursor up ?
02:0000591E 6610            	  1020: 	bne.s		dcx8
02:00005920 4A3900040000    	  1021: 	cmpi.b	#0,CursorRow
02:00005926 67CE            	  1022: 	beq.s		dcx7
02:00005928 533900040000    	  1023: 	subi.b	#1,CursorRow
02:0000592E 60C2            	  1024: 	bra.s		dcx14
                            	  1025: dcx8:
02:00005930 0C010093        	  1026: 	cmpi.b	#$93,d1			; cursor left?
02:00005934 6610            	  1027: 	bne.s		dcx9
02:00005936 4A3900040001    	  1028: 	cmpi.b	#0,CursorCol
02:0000593C 67B8            	  1029: 	beq.s		dcx7
02:0000593E 533900040001    	  1030: 	subi.b	#1,CursorCol
02:00005944 60AC            	  1031: 	bra.s		dcx14
                            	  1032: dcx9:
02:00005946 0C010092        	  1033: 	cmpi.b	#$92,d1			; cursor down ?
02:0000594A 6618            	  1034: 	bne.s		dcx10
02:0000594C 14390004008C    	  1035: 	move.b	TextRows,d2
02:00005952 5302            	  1036: 	sub.b		#1,d2
02:00005954 B43900040000    	  1037: 	cmp.b		CursorRow,d2
02:0000595A 679A            	  1038: 	beq.s		dcx7
02:0000595C 523900040000    	  1039: 	addi.b	#1,CursorRow
02:00005962 608E            	  1040: 	bra.s		dcx14
                            	  1041: dcx10:
02:00005964 0C010094        	  1042: 	cmpi.b	#$94,d1			; cursor home ?
02:00005968 661C            	  1043: 	bne.s		dcx11
02:0000596A 4A3900040001    	  1044: 	cmpi.b	#0,CursorCol
02:00005970 670A            	  1045: 	beq.s		dcx12
02:00005972 423900040001    	  1046: 	clr.b		CursorCol
02:00005978 6000FF78        	  1047: 	bra			dcx14
                            	  1048: dcx12:
02:0000597C 423900040000    	  1049: 	clr.b		CursorRow
02:00005982 6000FF6E        	  1050: 	bra			dcx14
                            	  1051: dcx11:
02:00005986 48E7E080        	  1052: 	movem.l	d0/d1/d2/a0,-(a7)
02:0000598A 0C010099        	  1053: 	cmpi.b	#$99,d1			; delete ?
02:0000598E 675A            	  1054: 	beq.s		doDelete
02:00005990 0C010008        	  1055: 	cmpi.b	#CTRLH,d1			; backspace ?
02:00005994 6746            	  1056: 	beq.s   doBackspace
02:00005996 0C010018        	  1057: 	cmpi.b	#CTRLX,d1			; delete line ?
02:0000599A 6700008E        	  1058: 	beq			doCtrlX
02:0000599E 0C01000A        	  1059: 	cmpi.b	#10,d1		; linefeed ?
02:000059A2 6726            	  1060: 	beq.s		dclf
                            	  1061: 
                            	  1062: 	; regular char
02:000059A4 6100FF20        	  1063: 	bsr			CalcScreenLoc	; a0 = screen location
02:000059A8 2401            	  1064: 	move.l	d1,d2					; d2 = char
02:000059AA 6100FE66        	  1065: 	bsr			get_screen_color	; d0,d1 = color
02:000059AE 8282            	  1066: 	or.l		d2,d1					; d1 = char + color
02:000059B0 E159            	  1067: 	rol.w		#8,d1					; text controller expects little endian data
02:000059B2 4841            	  1068: 	swap		d1
02:000059B4 E159            	  1069: 	rol.w		#8,d1
02:000059B6 20C1            	  1070: 	move.l d1,(a0)+
02:000059B8 E158            	  1071: 	rol.w		#8,d0					; swap bytes
02:000059BA 4840            	  1072: 	swap		d0						; swap halfs
02:000059BC E158            	  1073: 	rol.w		#8,d0					; swap remaining bytes
02:000059BE 20C0            	  1074: 	move.l d0,(a0)+
02:000059C0 6100008C        	  1075: 	bsr	IncCursorPos
02:000059C4 610001E0        	  1076: 	bsr	SyncCursor
02:000059C8 6008            	  1077: 	bra	dcx4
                            	  1078: dclf:
02:000059CA 610000A2        	  1079: 	bsr			IncCursorRow
                            	  1080: dcx16:
02:000059CE 610001D6        	  1081: 	bsr			SyncCursor
                            	  1082: dcx4:
02:000059D2 4CDF0107        	  1083: 	movem.l	(a7)+,d0/d1/d2/a0		; get back a0
02:000059D6 4CDF000E        	  1084: 	movem.l	(a7)+,d1/d2/d3
02:000059DA 4E75            	  1085: 	rts
                            	  1086: 
                            	  1087: 	;---------------------------
                            	  1088: 	; CTRL-H: backspace
                            	  1089: 	;---------------------------
                            	  1090: doBackspace:
02:000059DC 4A3900040001    	  1091: 	cmpi.b	#0,CursorCol		; if already at start of line
02:000059E2 67EE            	  1092: 	beq.s   dcx4						; nothing to do
02:000059E4 533900040001    	  1093: 	subi.b	#1,CursorCol		; decrement column
                            	  1094: 
                            	  1095: 	;---------------------------
                            	  1096: 	; Delete key
                            	  1097: 	;---------------------------
                            	  1098: doDelete:
02:000059EA 48E7C080        	  1099: 	movem.l	d0/d1/a0,-(a7)	; save off screen location
02:000059EE 6100FED6        	  1100: 	bsr	CalcScreenLoc				; a0 = screen location
02:000059F2 103900040001    	  1101: 	move.b CursorCol,d0
                            	  1102: .0001:
02:000059F8 22280008        	  1103: 	move.l 8(a0),d1					; pull remaining characters on line over 1
02:000059FC 2081            	  1104: 	move.l d1,(a0)
02:000059FE 2228000C        	  1105: 	move.l 12(a0),d1
02:00005A02 21410004        	  1106: 	move.l d1,4(a0)
02:00005A06 5088            	  1107: 	adda.l #8,a0
02:00005A08 5200            	  1108: 	addi.b #1,d0
02:00005A0A B0390004008D    	  1109: 	cmp.b	TextCols,d0
02:00005A10 65E6            	  1110: 	blo.s	.0001
02:00005A12 6100FDFE        	  1111: 	bsr	get_screen_color
02:00005A16 323C0020        	  1112: 	move.w #' ',d1					; terminate line with a space
02:00005A1A E159            	  1113: 	rol.w	#8,d1
02:00005A1C 4841            	  1114: 	swap d1
02:00005A1E E159            	  1115: 	rol.w	#8,d1
02:00005A20 2141FFF8        	  1116: 	move.l d1,-8(a0)
02:00005A24 4CDF0103        	  1117: 	movem.l	(a7)+,d0/d1/a0
02:00005A28 60A4            	  1118: 	bra.s		dcx16				; finished
                            	  1119: 
                            	  1120: 	;---------------------------
                            	  1121: 	; CTRL-X: erase line
                            	  1122: 	;---------------------------
                            	  1123: doCtrlX:
02:00005A2A 423900040001    	  1124: 	clr.b	CursorCol			; Reset cursor to start of line
02:00005A30 10390004008D    	  1125: 	move.b TextCols,d0	; and display TextCols number of spaces
02:00005A36 4880            	  1126: 	ext.w	d0
02:00005A38 48C0            	  1127: 	ext.l	d0
02:00005A3A 123C0020        	  1128: 	move.b #' ',d1			; d1 = space char
                            	  1129: .0001:
                            	  1130: 	; DisplayChar is called recursively here
                            	  1131: 	; It's safe to do because we know it won't recurse again due to the
                            	  1132: 	; fact we know the character being displayed is a space char
02:00005A3E 6100FE94        	  1133: 	bsr	DisplayChar			
02:00005A42 5340            	  1134: 	subq #1,d0
02:00005A44 66F8            	  1135: 	bne.s	.0001
02:00005A46 423900040001    	  1136: 	clr.b	CursorCol			; now really go back to start of line
02:00005A4C 6080            	  1137: 	bra	dcx16						; we're done
                            	  1138: 
                            	  1139: ;------------------------------------------------------------------------------
                            	  1140: ; Increment the cursor position, scroll the screen if needed.
                            	  1141: ;------------------------------------------------------------------------------
                            	  1142: 
                            	  1143: IncCursorPos:
02:00005A4E 527900040002    	  1144: 	addi.w	#1,TextCurpos
02:00005A54 523900040001    	  1145: 	addi.b	#1,CursorCol
02:00005A5A 10390004008D    	  1146: 	move.b	TextCols,d0
02:00005A60 B03900040001    	  1147: 	cmp.b		CursorCol,d0
02:00005A66 6438            	  1148: 	bhs.s		icc1
02:00005A68 423900040001    	  1149: 	clr.b		CursorCol
                            	  1150: IncCursorRow:
02:00005A6E 523900040000    	  1151: 	addi.b	#1,CursorRow
02:00005A74 10390004008C    	  1152: 	move.b	TextRows,d0
02:00005A7A B03900040000    	  1153: 	cmp.b		CursorRow,d0
02:00005A80 621E            	  1154: 	bhi.s		icc1
02:00005A82 10390004008C    	  1155: 	move.b	TextRows,d0
02:00005A88 13C000040000    	  1156: 	move.b	d0,CursorRow		; in case CursorRow is way over
02:00005A8E 533900040000    	  1157: 	subi.b	#1,CursorRow
02:00005A94 4880            	  1158: 	ext.w		d0
02:00005A96 D040            	  1159: 	asl.w		#1,d0
02:00005A98 917900040002    	  1160: 	sub.w		d0,TextCurpos
02:00005A9E 6102            	  1161: 	bsr			ScrollUp
                            	  1162: icc1:
02:00005AA0 4E75            	  1163: 	rts
                            	  1164: 
                            	  1165: ;------------------------------------------------------------------------------
                            	  1166: ; Scroll screen up.
                            	  1167: ;------------------------------------------------------------------------------
                            	  1168: 
                            	  1169: ScrollUp:
02:00005AA2 48E7C084        	  1170: 	movem.l	d0/d1/a0/a5,-(a7)		; save off some regs
02:00005AA6 4E7A0FE0        	  1171: 	movec	coreno,d0
02:00005AAA 4840            	  1172: 	swap d0	
02:00005AAC 7205            	  1173: 	moveq	#SCREEN_SEMA,d1
02:00005AAE 6100A7A8        	  1174: 	bsr	LockSemaphore
02:00005AB2 6100FD8A        	  1175: 	bsr	get_screen_address
02:00005AB6 2A48            	  1176: 	move.l	a0,a5								; a5 = pointer to text screen
                            	  1177: .0003:								
02:00005AB8 10390004008D    	  1178: 	move.b TextCols,d0					; d0 = columns
02:00005ABE 12390004008C    	  1179: 	move.b TextRows,d1					; d1 = rows
02:00005AC4 4880            	  1180: 	ext.w d0										;	make cols into a word value
02:00005AC6 4881            	  1181: 	ext.w	d1										; make rows into a word value
02:00005AC8 E740            	  1182: 	asl.w		#3,d0								; make into cell index
02:00005ACA 41F50000        	  1183: 	lea			0(a5,d0.w),a0				; a0 = pointer to second row of text screen
02:00005ACE E648            	  1184: 	lsr.w		#3,d0								; get back d0
02:00005AD0 5341            	  1185: 	subq		#1,d1								; number of rows-1
02:00005AD2 C0C1            	  1186: 	mulu		d1,d0								; d0 = count of characters to move
02:00005AD4 D080            	  1187: 	add.l d0,d0									; d0*2 2 longs per char
                            	  1188: .0001:
02:00005AD6 2218            	  1189: 	move.l (a0)+,d1
02:00005AD8 2AC1            	  1190: 	move.l d1,(a5)+
02:00005ADA 51C8FFFA        	  1191: 	dbra d0,.0001
02:00005ADE 4E7A0FE0        	  1192: 	movec coreno,d0
02:00005AE2 4840            	  1193: 	swap d0	
02:00005AE4 7205            	  1194: 	moveq #SCREEN_SEMA,d1
02:00005AE6 6100A7AC        	  1195: 	bsr UnlockSemaphore
02:00005AEA 4CDF2103        	  1196: 	movem.l (a7)+,d0/d1/a0/a5
                            	  1197: 	; Fall through into blanking out last line
                            	  1198: 
                            	  1199: ;------------------------------------------------------------------------------
                            	  1200: ; Blank out the last line on the screen.
                            	  1201: ;------------------------------------------------------------------------------
                            	  1202: 
                            	  1203: BlankLastLine:
02:00005AEE 48E7E080        	  1204: 	movem.l	d0/d1/d2/a0,-(a7)
02:00005AF2 4E7A0FE0        	  1205: 	movec	coreno,d0
02:00005AF6 4840            	  1206: 	swap d0	
02:00005AF8 7205            	  1207: 	moveq	#SCREEN_SEMA,d1
02:00005AFA 6100A75C        	  1208: 	bsr	LockSemaphore
02:00005AFE 6100FD3E        	  1209: 	bsr	get_screen_address
02:00005B02 10390004008C    	  1210: 	move.b TextRows,d0					; d0 = rows
02:00005B08 12390004008D    	  1211: 	move.b TextCols,d1					; d1 = columns
02:00005B0E 4880            	  1212: 	ext.w	d0
02:00005B10 4881            	  1213: 	ext.w	d1
02:00005B12 5340            	  1214: 	subq #1,d0									; last row = #rows-1
02:00005B14 C0C1            	  1215: 	mulu d1,d0									; d0 = index of last line
02:00005B16 E748            	  1216: 	lsl.w	#3,d0									; *8 bytes per char
02:00005B18 41F00000        	  1217: 	lea	(a0,d0.w),a0						; point a0 to last row
02:00005B1C 14390004008D    	  1218: 	move.b TextCols,d2					; number of text cells to clear
02:00005B22 4882            	  1219: 	ext.w	d2
02:00005B24 5342            	  1220: 	subi.w #1,d2								; count must be one less than desired
02:00005B26 6100FCEA        	  1221: 	bsr	get_screen_color				; d0,d1 = screen color
02:00005B2A 123C0020        	  1222: 	move.b #32,d1								; set the character for display in low 16 bits
02:00005B2E 61001BAA        	  1223: 	bsr	rbo											; reverse the byte order
02:00005B32 E158            	  1224: 	rol.w	#8,d0
02:00005B34 4840            	  1225: 	swap d0
02:00005B36 E158            	  1226: 	rol.w	#8,d0
                            	  1227: .0001:
02:00005B38 20C0            	  1228: 	move.l d0,(a0)+
02:00005B3A 20C1            	  1229: 	move.l d1,(a0)+
02:00005B3C 51CAFFFA        	  1230: 	dbra d2,.0001
02:00005B40 4E7A0FE0        	  1231: 	movec	coreno,d0
02:00005B44 4840            	  1232: 	swap d0	
02:00005B46 7205            	  1233: 	moveq #SCREEN_SEMA,d1
02:00005B48 6100A74A        	  1234: 	bsr UnlockSemaphore
02:00005B4C 4CDF0107        	  1235: 	movem.l	(a7)+,d0/d1/d2/a0
02:00005B50 4E75            	  1236: 	rts
                            	  1237: 
                            	  1238: ;------------------------------------------------------------------------------
                            	  1239: ; Display a string on standard output.
                            	  1240: ;------------------------------------------------------------------------------
                            	  1241: 
                            	  1242: DisplayString:
02:00005B52 48E7C040        	  1243: 	movem.l	d0/d1/a1,-(a7)
                            	  1244: dspj1:
02:00005B56 7200            	  1245: 	clr.l d1							; clear upper bits of d1
02:00005B58 1219            	  1246: 	move.b (a1)+,d1				; move string char into d1
02:00005B5A 6706            	  1247: 	beq.s dsret						; is it end of string ?
02:00005B5C 7006            	  1248: 	moveq #6,d0						; output character function
02:00005B5E 4E4F            	  1249: 	trap #15
02:00005B60 60F4            	  1250: 	bra.s	dspj1						; go back for next character
                            	  1251: dsret:
02:00005B62 4CDF0203        	  1252: 	movem.l	(a7)+,d0/d1/a1
02:00005B66 4E75            	  1253: 	rts
                            	  1254: 
                            	  1255: ;------------------------------------------------------------------------------
                            	  1256: ; Display a string on the screen followed by carriage return / linefeed.
                            	  1257: ;------------------------------------------------------------------------------
                            	  1258: 
                            	  1259: DisplayStringCRLF:
02:00005B68 61E8            	  1260: 	bsr		DisplayString
02:00005B6A 6000FD1E        	  1261: 	bra		CRLF
                            	  1262: 
                            	  1263: ;------------------------------------------------------------------------------
                            	  1264: ; Display a string on the screen limited to 255 chars max.
                            	  1265: ;------------------------------------------------------------------------------
                            	  1266: 
                            	  1267: DisplayStringLimited:
02:00005B6E 48E7E040        	  1268: 	movem.l	d0/d1/d2/a1,-(a7)
02:00005B72 3401            	  1269: 	move.w	d1,d2					; d2 = max count
02:00005B74 024200FF        	  1270: 	andi.w	#$00FF,d2			; limit to 255 chars
02:00005B78 600A            	  1271: 	bra.s		.0003					; enter loop at bottom
                            	  1272: .0001:
02:00005B7A 7200            	  1273: 	clr.l d1							; clear upper bits of d1
02:00005B7C 1219            	  1274: 	move.b (a1)+,d1				; move string char into d1
02:00005B7E 6708            	  1275: 	beq.s .0002						; is it end of string ?
02:00005B80 7006            	  1276: 	moveq #6,d0						; output character function
02:00005B82 4E4F            	  1277: 	trap #15
                            	  1278: .0003:
02:00005B84 51CAFFF4        	  1279: 	dbra		d2,.0001			; go back for next character
                            	  1280: .0002:
02:00005B88 4CDF0207        	  1281: 	movem.l	(a7)+,d0/d1/d2/a1
02:00005B8C 4E75            	  1282: 	rts
                            	  1283: 
                            	  1284: DisplayStringLimitedCRLF:
02:00005B8E 61DE            	  1285: 	bsr		DisplayStringLimited
02:00005B90 6000FCF8        	  1286: 	bra		CRLF
                            	  1287: 	
                            	  1288: ;------------------------------------------------------------------------------
                            	  1289: ; Set cursor position to top left of screen.
                            	  1290: ;
                            	  1291: ; Parameters:
                            	  1292: ;		<none>
                            	  1293: ; Returns:
                            	  1294: ;		<none>
                            	  1295: ; Registers Affected:
                            	  1296: ;		<none>
                            	  1297: ;------------------------------------------------------------------------------
                            	  1298: 
                            	  1299: HomeCursor:
02:00005B94 423900040000    	  1300: 	clr.b		CursorRow
02:00005B9A 423900040001    	  1301: 	clr.b		CursorCol
02:00005BA0 427900040002    	  1302: 	clr.w		TextPos
                            	  1303: 	; fall through
                            	  1304: 
                            	  1305: ;------------------------------------------------------------------------------
                            	  1306: ; SyncCursor:
                            	  1307: ;
                            	  1308: ; Sync the hardware cursor's position to the text cursor position but only for
                            	  1309: ; the core with the IO focus.
                            	  1310: ;
                            	  1311: ; Parameters:
                            	  1312: ;		<none>
                            	  1313: ; Returns:
                            	  1314: ;		<none>
                            	  1315: ; Registers Affected:
                            	  1316: ;		<none>
                            	  1317: ;------------------------------------------------------------------------------
                            	  1318: 
                            	  1319: SyncCursor:
02:00005BA6 48E7E080        	  1320: 	movem.l	d0/d1/d2/a0,-(a7)
02:00005BAA 6100FCF0        	  1321: 	bsr	UpdateTextPos
02:00005BAE 7200            	  1322: 	clr.l d1
02:00005BB0 3200            	  1323: 	move.w d0,d1
02:00005BB2 4E7A2FE0        	  1324: 	movec	coreno,d2
02:00005BB6 B43900100000    	  1325: 	cmp.b	IOFocus,d2
02:00005BBC 6616            	  1326: 	bne.s .0001
02:00005BBE 5542            	  1327: 	subi.w #2,d2				; factor in location of screen in controller
02:00005BC0 C4FC0800        	  1328: 	mulu #2048,d2				; 2048 cells per screen
02:00005BC4 D282            	  1329: 	add.l	d2,d1
02:00005BC6 E159            	  1330: 	rol.w	#8,d1					; swap byte order
02:00005BC8 4841            	  1331: 	swap d1
02:00005BCA E159            	  1332: 	rol.w #8,d1
02:00005BCC 41F9FD080024    	  1333: 	lea TEXTREG+$24,a0
02:00005BD2 2081            	  1334: 	move.l d1,(a0)
                            	  1335: .0001:	
02:00005BD4 4CDF0107        	  1336: 	movem.l	(a7)+,a0/d0/d1/d2
02:00005BD8 4E75            	  1337: 	rts
                            	  1338: 
                            	  1339: ;==============================================================================
                            	  1340: ; TRAP #15 handler
                            	  1341: ;
                            	  1342: ; Parameters:
                            	  1343: ;		d0.w = function number to perform
                            	  1344: ;==============================================================================
                            	  1345: 
                            	  1346: TRAP15:
02:00005BDA 558F            	  1347: 	subq.l #2,sp						; keep stack lword aligned
02:00005BDC 48E78080        	  1348: 	movem.l	d0/a0,-(a7)
02:00005BE0 41FA0012        	  1349: 	lea T15DispatchTable,a0
02:00005BE4 E580            	  1350: 	asl.l #2,d0
02:00005BE6 20700000        	  1351: 	move.l (a0,d0.w),a0
02:00005BEA 4E90            	  1352: 	jsr (a0)
02:00005BEC 4CDF0101        	  1353: 	movem.l (a7)+,d0/a0
02:00005BF0 548F            	  1354: 	addq.l #2,sp
02:00005BF2 4E73            	  1355: 	rte
                            	  1356: 
                            	  1357: 		align	2
                            	  1358: T15DispatchTable:
02:00005BF4 00005B8E        	  1359: 	dc.l	DisplayStringLimitedCRLF
02:00005BF8 00005B6E        	  1360: 	dc.l	DisplayStringLimited
02:00005BFC 00005CDC        	  1361: 	dc.l	StubRout
02:00005C00 00005CDC        	  1362: 	dc.l	StubRout
02:00005C04 00005CDC        	  1363: 	dc.l	StubRout
02:00005C08 00005F80        	  1364: 	dc.l	GetKey
02:00005C0C 00007CD2        	  1365: 	dc.l	OutputChar
02:00005C10 00005F74        	  1366: 	dc.l	CheckForKey
02:00005C14 00005CDC        	  1367: 	dc.l	StubRout
02:00005C18 00005CDC        	  1368: 	dc.l	StubRout
                            	  1369: 	; 10
02:00005C1C 00005CDC        	  1370: 	dc.l	StubRout
02:00005C20 00005CA4        	  1371: 	dc.l	Cursor1
02:00005C24 00005F6C        	  1372: 	dc.l	SetKeyboardEcho
02:00005C28 00005B68        	  1373: 	dc.l	DisplayStringCRLF
02:00005C2C 00005B52        	  1374: 	dc.l	DisplayString
02:00005C30 00005CDC        	  1375: 	dc.l	StubRout
02:00005C34 00005CDC        	  1376: 	dc.l	StubRout
02:00005C38 00005CDC        	  1377: 	dc.l	StubRout
02:00005C3C 00005CDC        	  1378: 	dc.l	StubRout
02:00005C40 00005CDC        	  1379: 	dc.l	StubRout
                            	  1380: 	; 20
02:00005C44 00005CDC        	  1381: 	dc.l	StubRout
02:00005C48 00005CDC        	  1382: 	dc.l	StubRout
02:00005C4C 00005CDC        	  1383: 	dc.l	StubRout
02:00005C50 00005CDC        	  1384: 	dc.l	StubRout
02:00005C54 00005CDC        	  1385: 	dc.l	StubRout
02:00005C58 00005CDC        	  1386: 	dc.l	StubRout
02:00005C5C 00005CDC        	  1387: 	dc.l	StubRout
02:00005C60 00005CDC        	  1388: 	dc.l	StubRout
02:00005C64 00005CDC        	  1389: 	dc.l	StubRout
02:00005C68 00005CDC        	  1390: 	dc.l	StubRout
                            	  1391: 	; 30
02:00005C6C 00005CDC        	  1392: 	dc.l	StubRout
02:00005C70 00005CDC        	  1393: 	dc.l	StubRout
02:00005C74 00005CF0        	  1394: 	dc.l	rotate_iofocus
02:00005C78 000077C4        	  1395: 	dc.l	SerialPeekCharDirect
02:00005C7C 000077DE        	  1396: 	dc.l	SerialPutChar
02:00005C80 0000778C        	  1397: 	dc.l	SerialPeekChar
02:00005C84 00007714        	  1398: 	dc.l	SerialGetChar
02:00005C88 000002B0        	  1399: 	dc.l	T15LockSemaphore
02:00005C8C 000002B6        	  1400: 	dc.l	T15UnlockSemaphore
02:00005C90 00007C4A        	  1401: 	dc.l	prtflt
                            	  1402: 	; 40
02:00005C94 000001FA        	  1403: 	dc.l  _GetRand
02:00005C98 000002BC        	  1404: 	dc.l	T15GetFloat
02:00005C9C 000002CA        	  1405: 	dc.l	T15Abort
02:00005CA0 00007C90        	  1406: 	dc.l	T15FloatToString
                            	  1407: 
                            	  1408: ;------------------------------------------------------------------------------
                            	  1409: ; Cursor positioning / Clear screen
                            	  1410: ; - out of range settings are ignored
                            	  1411: ;
                            	  1412: ; Parameters:
                            	  1413: ;		d1.w cursor position, bits 0 to 7 are row, bits 8 to 15 are column.
                            	  1414: ;	Returns:
                            	  1415: ;		none
                            	  1416: ;------------------------------------------------------------------------------
                            	  1417: 
                            	  1418: Cursor1:
02:00005CA4 2F01            	  1419: 	move.l d1,-(a7)
02:00005CA6 0C41FF00        	  1420: 	cmpi.w #$FF00,d1
02:00005CAA 660A            	  1421: 	bne.s .0002
02:00005CAC 6100FB98        	  1422: 	bsr	clear_screen
02:00005CB0 221F            	  1423: 	move.l (a7)+,d1
02:00005CB2 6000FEE0        	  1424: 	bra	HomeCursor
                            	  1425: .0002:
02:00005CB6 B2390004008C    	  1426: 	cmp.b TextRows,d1		; if cursor pos out of range, ignore setting
02:00005CBC 6406            	  1427: 	bhs.s	.0003
02:00005CBE 13C100040000    	  1428: 	move.b d1,CursorRow
                            	  1429: .0003:
02:00005CC4 E059            	  1430: 	ror.w	#8,d1
02:00005CC6 B2390004008D    	  1431: 	cmp.b	TextCols,d1
02:00005CCC 6406            	  1432: 	bhs.s	.0001
02:00005CCE 13C100040001    	  1433: 	move.b d1,CursorCol
                            	  1434: .0001:
02:00005CD4 6100FED0        	  1435: 	bsr SyncCursor			; update hardware cursor
02:00005CD8 221F            	  1436: 	move.l (a7)+,d1
02:00005CDA 4E75            	  1437: 	rts
                            	  1438: 
                            	  1439: ;------------------------------------------------------------------------------
                            	  1440: ; Stub routine for unimplemented functionality.
                            	  1441: ;------------------------------------------------------------------------------
                            	  1442: 
                            	  1443: StubRout:
02:00005CDC 4E75            	  1444: 	rts
                            	  1445: 
                            	  1446: ;------------------------------------------------------------------------------
                            	  1447: ; Select a specific IO focus.
                            	  1448: ;------------------------------------------------------------------------------
                            	  1449: 
                            	  1450: select_iofocus:
02:00005CDE 0C010002        	  1451: 	cmpi.b	#2,d1
02:00005CE2 650A            	  1452: 	blo.s		.0001
02:00005CE4 0C010009        	  1453: 	cmpi.b	#9,d1
02:00005CE8 6204            	  1454: 	bhi.s		.0001
02:00005CEA 2001            	  1455: 	move.l	d1,d0
02:00005CEC 6014            	  1456: 	bra.s		select_focus1
                            	  1457: .0001:
02:00005CEE 4E75            	  1458: 	rts
                            	  1459: 
                            	  1460: ;------------------------------------------------------------------------------
                            	  1461: ; Rotate the IO focus, done when ALT-Tab is pressed.
                            	  1462: ;
                            	  1463: ; Modifies:
                            	  1464: ;		d0, IOFocus BIOS variable
                            	  1465: ;		updates the PLIC to send IRQs to focus core
                            	  1466: ;		updates the text screen pointer
                            	  1467: ;------------------------------------------------------------------------------
                            	  1468: 
                            	  1469: rotate_iofocus:
02:00005CF0 103900100000    	  1470: 	move.b IOFocus,d0					; d0 = focus, we can trash d0
02:00005CF6 5200            	  1471: 	add.b	#1,d0								; increment the focus
02:00005CF8 B03C0009        	  1472: 	cmp.b	#9,d0								; limit to 2 to 9
02:00005CFC 6304            	  1473: 	bls.s	.0001
02:00005CFE 103C0002        	  1474: 	move.b #2,d0
                            	  1475: .0001:
                            	  1476: select_focus1:
02:00005D02 13C000100000    	  1477: 	move.b	d0,IOFocus				; set IO focus
                            	  1478: 	; reset keyboard processor to focus core
                            	  1479: ;	move.l #$3C060500,d0			; core=??,level sensitive,enabled,irq6,inta
                            	  1480: ;	or.b IOFocus,d0
                            	  1481: ;	move.l d0,PLIC+$80+4*30		; set register
                            	  1482: 	; Adjust text screen pointer
02:00005D08 5500            	  1483: 	subi.b #2,d0							; screen is 0 to 7, focus is 2 to 9
02:00005D0A 4880            	  1484: 	ext.w	d0									; make into word value
02:00005D0C C0FC0800        	  1485: 	mulu #2048,d0							; * 2048	cells per screen
02:00005D10 E158            	  1486: 	rol.w	#8,d0								; swap byte order
02:00005D12 4840            	  1487: 	swap d0										; get bits 16-31
02:00005D14 E158            	  1488: 	rol.w	#8,d0								; swap byte order
02:00005D16 23C0FD080028    	  1489: 	move.l d0,TEXTREG+$28			; update screen address in text controller
02:00005D1C 6000FE88        	  1490: 	bra	SyncCursor						; set cursor position
                            	  1491: 
                            	  1492: ;==============================================================================
                            	  1493: ; PLIC - platform level interrupt controller
                            	  1494: ;
                            	  1495: ; Register layout:
                            	  1496: ;   bits 0 to 7  = cause code to issue (vector number)
                            	  1497: ;   bits 8 to 11 = irq level to issue
                            	  1498: ;   bit 16 = irq enable
                            	  1499: ;   bit 17 = edge sensitivity
                            	  1500: ;   bit 18 = 0=vpa, 1=inta
                            	  1501: ;		bit 24 to 29 target core
                            	  1502: ;
                            	  1503: ; Note byte order must be reversed for PLIC.
                            	  1504: ;==============================================================================
                            	  1505: 
                            	  1506: init_plic:
02:00005D20 41F9FD090000    	  1507: 	lea	PLIC,a0							; a0 points to PLIC
02:00005D26 43E800F4        	  1508: 	lea	$80+4*29(a0),a1			; point to timer registers (29)
02:00005D2A 22BC0006033F    	  1509: 	move.l #$0006033F,(a1)	; initialize, core=63,edge sensitive,enabled,irq6,vpa
02:00005D30 5889            	  1510: 	lea	4(a1),a1						; point to keyboard registers (30)
02:00005D32 22BC3C060502    	  1511: 	move.l #$3C060502,(a1)	; core=2,level sensitive,enabled,irq6,inta
02:00005D38 5889            	  1512: 	lea	4(a1),a1						; point to nmi button register (31)
02:00005D3A 22BC00070302    	  1513: 	move.l #$00070302,(a1)	; initialize, core=2,edge sensitive,enabled,irq7,vpa
02:00005D40 43E800C0        	  1514: 	lea	$80+4*16(a0),a1			; a1 points to ACIA register
02:00005D44 22BC3D030502    	  1515: 	move.l #$3D030502,(a1)	; core=2,level sensitive,enabled,irq3,inta	
02:00005D4A 43E80090        	  1516: 	lea	$80+4*4(a0),a1			; a1 points to io_bitmap irq
02:00005D4E 22BC3B060702    	  1517: 	move.l #$3B060702,(a1)	; core=2,edge sensitive,enabled,irq6,inta	
02:00005D54 4E75            	  1518: 	rts
                            	  1519: 
                            	  1520: ;==============================================================================
                            	  1521: ; Keyboard stuff
                            	  1522: ;
                            	  1523: ; KeyState2_
                            	  1524: ; 876543210
                            	  1525: ; ||||||||+ = shift
                            	  1526: ; |||||||+- = alt
                            	  1527: ; ||||||+-- = control
                            	  1528: ; |||||+--- = numlock
                            	  1529: ; ||||+---- = capslock
                            	  1530: ; |||+----- = scrolllock
                            	  1531: ; ||+------ =
                            	  1532: ; |+------- = 
                            	  1533: ; +-------- = extended
                            	  1534: ;
                            	  1535: ;==============================================================================
                            	  1536: 
                            	  1537: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1538: ; Get ID - get the keyboards identifier code.
                            	  1539: ;
                            	  1540: ; Parameters: none
                            	  1541: ; Returns: d = $AB83, $00 on fail
                            	  1542: ; Modifies: d, KeybdID updated
                            	  1543: ; Stack Space: 2 words
                            	  1544: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1545: 
                            	  1546: KeybdGetID:
02:00005D56 323C00F2        	  1547: 	move.w	#$F2,d1
02:00005D5A 610004E4        	  1548: 	bsr			KeybdSendByte
02:00005D5E 610001E6        	  1549: 	bsr			KeybdWaitTx
02:00005D62 610001C0        	  1550: 	bsr			KeybdRecvByte
02:00005D66 08010007        	  1551: 	btst		#7,d1
02:00005D6A 6624            	  1552: 	bne			kgnotKbd
02:00005D6C 0C0100AB        	  1553: 	cmpi.b	#$AB,d1
02:00005D70 661E            	  1554: 	bne			kgnotKbd
02:00005D72 610001B0        	  1555: 	bsr			KeybdRecvByte
02:00005D76 08010007        	  1556: 	btst		#7,d1
02:00005D7A 6614            	  1557: 	bne			kgnotKbd
02:00005D7C 0C010083        	  1558: 	cmpi.b	#$83,d1
02:00005D80 660E            	  1559: 	bne			kgnotKbd
02:00005D82 223C0000AB83    	  1560: 	move.l	#$AB83,d1
                            	  1561: kgid1:
02:00005D88 33C100100016    	  1562: 	move.w	d1,KeybdID
02:00005D8E 4E75            	  1563: 	rts
                            	  1564: kgnotKbd:
02:00005D90 7200            	  1565: 	moveq		#0,d1
02:00005D92 60F4            	  1566: 	bra			kgid1
                            	  1567: 
                            	  1568: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1569: ; Set the LEDs on the keyboard.
                            	  1570: ;
                            	  1571: ; Parameters:
                            	  1572: ;		d1.b = LED state
                            	  1573: ;	Modifies:
                            	  1574: ;		none
                            	  1575: ; Returns:
                            	  1576: ;		none
                            	  1577: ; Stack Space:
                            	  1578: ;		1 long word
                            	  1579: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1580: 
                            	  1581: KeybdSetLED:
02:00005D94 2F01            	  1582: 	move.l	d1,-(a7)
02:00005D96 123C00ED        	  1583: 	move.b	#$ED,d1
02:00005D9A 610004A4        	  1584: 	bsr			KeybdSendByte
02:00005D9E 610001A6        	  1585: 	bsr			KeybdWaitTx
02:00005DA2 61000180        	  1586: 	bsr			KeybdRecvByte
02:00005DA6 4A01            	  1587: 	tst.b		d1
02:00005DA8 6B12            	  1588: 	bmi			.0001
02:00005DAA 0C0100FA        	  1589: 	cmpi.b	#$FA,d1
02:00005DAE 2217            	  1590: 	move.l	(a7),d1
02:00005DB0 6100048E        	  1591: 	bsr			KeybdSendByte
02:00005DB4 61000190        	  1592: 	bsr			KeybdWaitTx
02:00005DB8 6100016A        	  1593: 	bsr			KeybdRecvByte
                            	  1594: .0001:
02:00005DBC 221F            	  1595: 	move.l	(a7)+,d1
02:00005DBE 4E75            	  1596: 	rts
                            	  1597: 
                            	  1598: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1599: ; Initialize the keyboard.
                            	  1600: ;
                            	  1601: ; Parameters:
                            	  1602: ;		none
                            	  1603: ;	Modifies:
                            	  1604: ;		none
                            	  1605: ; Returns:
                            	  1606: ;		none
                            	  1607: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1608: 
                            	  1609: _KeybdInit:
                            	  1610: KeybdInit:
                            	  1611: ;	movem.l	d0/d1/d3/a1,-(a7)
02:00005DC0 42390010000F    	  1612: 	clr.b	_KeyState1		; records key up/down state
02:00005DC6 423900100010    	  1613: 	clr.b	_KeyState2		; records shift,ctrl,alt state
02:00005DCC 4E75            	  1614: 	rts
                            	  1615: 
02:00005DCE 61000494        	  1616: 	bsr			Wait300ms
02:00005DD2 610000FE        	  1617: 	bsr			_KeybdGetStatus	; wait for response from keyboard
02:00005DD6 4A01            	  1618: 	tst.b		d1
02:00005DD8 6A10            	  1619: 	bpl			.0001					; is input buffer full ? no, branch
02:00005DDA 61000114        	  1620: 	bsr	_KeybdGetScancode
02:00005DDE 6100012E        	  1621: 	bsr _KeybdClearIRQ
02:00005DE2 0C0100AA        	  1622: 	cmpi.b	#$AA,d1				; keyboard Okay
02:00005DE6 67000098        	  1623: 	beq			kbdi0005
                            	  1624: .0001:
02:00005DEA 760A            	  1625: 	moveq		#10,d3
                            	  1626: kbdi0002:
02:00005DEC 6100045A        	  1627: 	bsr			Wait10ms
02:00005DF0 4239FD0FFE01    	  1628: 	clr.b		KEYBD+1				; clear receive register (write $00 to status reg)
02:00005DF6 6100A340        	  1629: 	bsr net_delay
02:00005DFA 72FF            	  1630: 	moveq		#-1,d1				; send reset code to keyboard
02:00005DFC 13C1FD0FFE01    	  1631: 	move.b	d1,KEYBD+1		; write $FF to status reg to clear TX state
02:00005E02 6100A334        	  1632: 	bsr net_delay
02:00005E06 61000438        	  1633: 	bsr			KeybdSendByte	; now write ($FF) to transmit register for reset
02:00005E0A 6100013A        	  1634: 	bsr			KeybdWaitTx		; wait until no longer busy
02:00005E0E 4A81            	  1635: 	tst.l		d1
02:00005E10 6B000088        	  1636: 	bmi			kbdiXmitBusy
02:00005E14 6100010E        	  1637: 	bsr			KeybdRecvByte	; look for an ACK ($FA)
02:00005E18 0C0100FA        	  1638: 	cmpi.b	#$FA,d1
02:00005E1C 6604            	  1639: 	bne			.0001
02:00005E1E 61000104        	  1640: 	bsr			KeybdRecvByte	; look for BAT completion code ($AA)
                            	  1641: .0001:
02:00005E22 0C0100FC        	  1642: 	cmpi.b	#$FC,d1				; reset error ?
02:00005E26 672E            	  1643: 	beq			kbdiTryAgain
02:00005E28 0C0100AA        	  1644: 	cmpi.b	#$AA,d1				; reset complete okay ?
02:00005E2C 6628            	  1645: 	bne			kbdiTryAgain
                            	  1646: 
                            	  1647: 	; After a reset, scan code set #2 should be active
                            	  1648: .config:
02:00005E2E 323C00F0        	  1649: 	move.w	#$F0,d1			; send scan code select
02:00005E32 13C1FD0FFF00    	  1650: 	move.b	d1,leds
02:00005E38 6100A2FE        	  1651: 	bsr net_delay
02:00005E3C 61000402        	  1652: 	bsr			KeybdSendByte
02:00005E40 61000104        	  1653: 	bsr			KeybdWaitTx
02:00005E44 4A81            	  1654: 	tst.l		d1
02:00005E46 6B52            	  1655: 	bmi			kbdiXmitBusy
02:00005E48 610000DA        	  1656: 	bsr			KeybdRecvByte	; wait for response from keyboard
02:00005E4C 4A41            	  1657: 	tst.w		d1
02:00005E4E 6B06            	  1658: 	bmi			kbdiTryAgain
02:00005E50 0C0100FA        	  1659: 	cmpi.b	#$FA,d1				; ACK
02:00005E54 670E            	  1660: 	beq			kbdi0004
                            	  1661: kbdiTryAgain:
02:00005E56 51CBFF94        	  1662: 	dbra		d3,kbdi0002
                            	  1663: .keybdErr:
02:00005E5A 43FA004C        	  1664: 	lea			msgBadKeybd,a1
02:00005E5E 6100FD08        	  1665: 	bsr			DisplayStringCRLF
02:00005E62 6020            	  1666: 	bra			ledxit
                            	  1667: kbdi0004:
02:00005E64 7202            	  1668: 	moveq		#2,d1			; select scan code set #2
02:00005E66 610003D8        	  1669: 	bsr			KeybdSendByte
02:00005E6A 610000DA        	  1670: 	bsr			KeybdWaitTx
02:00005E6E 4A81            	  1671: 	tst.l		d1
02:00005E70 6B28            	  1672: 	bmi			kbdiXmitBusy
02:00005E72 610000B0        	  1673: 	bsr			KeybdRecvByte	; wait for response from keyboard
02:00005E76 4A41            	  1674: 	tst.w		d1
02:00005E78 6BDC            	  1675: 	bmi			kbdiTryAgain
02:00005E7A 0C0100FA        	  1676: 	cmpi.b	#$FA,d1
02:00005E7E 66D6            	  1677: 	bne			kbdiTryAgain
                            	  1678: kbdi0005:
02:00005E80 6100FED4        	  1679: 	bsr			KeybdGetID
                            	  1680: ledxit:
02:00005E84 7207            	  1681: 	moveq		#$07,d1
02:00005E86 6100FF0C        	  1682: 	bsr			KeybdSetLED
02:00005E8A 610003D8        	  1683: 	bsr			Wait300ms
02:00005E8E 7200            	  1684: 	moveq		#$00,d1
02:00005E90 6100FF02        	  1685: 	bsr			KeybdSetLED
02:00005E94 4CDF020B        	  1686: 	movem.l	(a7)+,d0/d1/d3/a1
02:00005E98 4E75            	  1687: 	rts
                            	  1688: kbdiXmitBusy:
02:00005E9A 43FA001B        	  1689: 	lea			msgXmitBusy,a1
02:00005E9E 6100FCC8        	  1690: 	bsr			DisplayStringCRLF
02:00005EA2 4CDF020B        	  1691: 	movem.l	(a7)+,d0/d1/d3/a1
02:00005EA6 4E75            	  1692: 	rts
                            	  1693: 	
                            	  1694: msgBadKeybd:
02:00005EA8 4B6579626F617264	  1695: 	dc.b		"Keyboard error",0
02:00005EB0 206572726F72
02:00005EB6 00
                            	  1696: msgXmitBusy:
02:00005EB7 4B6579626F617264	  1697: 	dc.b		"Keyboard transmitter stuck",0
02:00005EBF 207472616E736D69
02:00005EC7 7474657220737475
02:00005ECF 636B
02:00005ED1 00
                            	  1698: 
                            	  1699: 	even
                            	  1700: _KeybdGetStatus:
02:00005ED2 4E7A1FE0        	  1701: 	movec coreno,d1
02:00005ED6 0C010002        	  1702: 	cmpi.b #2,d1
02:00005EDA 660A            	  1703: 	bne .0001
02:00005EDC 7200            	  1704: 	moveq	#0,d1
02:00005EDE 1239FD0FFE01    	  1705: 	move.b KEYBD+1,d1
02:00005EE4 4E75            	  1706: 	rts
                            	  1707: .0001:
02:00005EE6 7200            	  1708: 	moveq #0,d1
02:00005EE8 1239FD0FFE03    	  1709: 	move.b KEYBD+3,d1
02:00005EEE 4E75            	  1710: 	rts
                            	  1711: 
                            	  1712: ; Get the scancode from the keyboard port
                            	  1713: 
                            	  1714: _KeybdGetScancode:
02:00005EF0 4E7A1FE0        	  1715: 	movec coreno,d1
02:00005EF4 0C010002        	  1716: 	cmpi.b #2,d1
02:00005EF8 660A            	  1717: 	bne .0001
02:00005EFA 7200            	  1718: 	moveq		#0,d1
02:00005EFC 1239FD0FFE00    	  1719: 	move.b	KEYBD,d1				; get the scan code
02:00005F02 4E75            	  1720: 	rts
                            	  1721: .0001:
02:00005F04 7200            	  1722: 	moveq #0,d1
02:00005F06 1239FD0FFE02    	  1723: 	move.b KEYBD+2,d1
02:00005F0C 4E75            	  1724: 	rts
                            	  1725: 
                            	  1726: _KeybdClearIRQ:
02:00005F0E 2F01            	  1727: 	move.l d1,-(a7)
02:00005F10 4E7A1FE0        	  1728: 	movec coreno,d1
02:00005F14 0C010002        	  1729: 	cmpi.b #2,d1
02:00005F18 6606            	  1730: 	bne .0001
02:00005F1A 4239FD0FFE01    	  1731: 	move.b	#0,KEYBD+1			; clear receive register
                            	  1732: .0001:
02:00005F20 221F            	  1733: 	move.l (a7)+,d1
02:00005F22 4E75            	  1734: 	rts
                            	  1735: 
                            	  1736: ; Recieve a byte from the keyboard, used after a command is sent to the
                            	  1737: ; keyboard in order to wait for a response.
                            	  1738: ;
                            	  1739: KeybdRecvByte:
02:00005F24 2F03            	  1740: 	move.l	d3,-(a7)
02:00005F26 363C0064        	  1741: 	move.w	#100,d3		; wait up to 1s
                            	  1742: .0003:
02:00005F2A 61A6            	  1743: 	bsr			_KeybdGetStatus	; wait for response from keyboard
02:00005F2C 4A01            	  1744: 	tst.b		d1
02:00005F2E 6B0E            	  1745: 	bmi			.0004			; is input buffer full ? yes, branch
02:00005F30 61000316        	  1746: 	bsr			Wait10ms	; wait a bit
02:00005F34 51CBFFF4        	  1747: 	dbra		d3,.0003	; go back and try again
02:00005F38 261F            	  1748: 	move.l	(a7)+,d3
02:00005F3A 72FF            	  1749: 	moveq		#-1,d1		; return -1
02:00005F3C 4E75            	  1750: 	rts
                            	  1751: .0004:
02:00005F3E 61B0            	  1752: 	bsr	_KeybdGetScancode
02:00005F40 61CC            	  1753: 	bsr _KeybdClearIRQ
02:00005F42 261F            	  1754: 	move.l	(a7)+,d3
02:00005F44 4E75            	  1755: 	rts
                            	  1756: 
                            	  1757: 
                            	  1758: ; Wait until the keyboard transmit is complete
                            	  1759: ; Returns -1 if timedout, 0 if transmit completed
                            	  1760: ;
                            	  1761: KeybdWaitTx:
02:00005F46 48E73000        	  1762: 	movem.l	d2/d3,-(a7)
02:00005F4A 7664            	  1763: 	moveq		#100,d3		; wait a max of 1s
                            	  1764: .0001:
02:00005F4C 6184            	  1765: 	bsr	_KeybdGetStatus
02:00005F4E 08010006        	  1766: 	btst #6,d1				; check for transmit complete bit
02:00005F52 6610            	  1767: 	bne	.0002					; branch if bit set
02:00005F54 610002F2        	  1768: 	bsr	Wait10ms			; delay a little bit
02:00005F58 51CBFFF2        	  1769: 	dbra d3,.0001			; go back and try again
02:00005F5C 4CDF000C        	  1770: 	movem.l	(a7)+,d2/d3
02:00005F60 72FF            	  1771: 	moveq	#-1,d1			; return -1
02:00005F62 4E75            	  1772: 	rts
                            	  1773: .0002:
02:00005F64 4CDF000C        	  1774: 	movem.l	(a7)+,d2/d3
02:00005F68 7200            	  1775: 	moveq	#0,d1		; return 0
02:00005F6A 4E75            	  1776: 	rts
                            	  1777: 
                            	  1778: ;------------------------------------------------------------------------------
                            	  1779: ; d1.b 0=echo off, non-zero = echo on
                            	  1780: ;------------------------------------------------------------------------------
                            	  1781: 
                            	  1782: SetKeyboardEcho:
02:00005F6C 13C10004000C    	  1783: 	move.b	d1,KeybdEcho
02:00005F72 4E75            	  1784: 	rts
                            	  1785: 
                            	  1786: ;------------------------------------------------------------------------------
                            	  1787: ; Get key pending status into d1.b
                            	  1788: ;
                            	  1789: ; Returns:
                            	  1790: ;		d1.b = 1 if a key is available, otherwise zero.
                            	  1791: ;------------------------------------------------------------------------------
                            	  1792: 
                            	  1793: CheckForKey:
02:00005F74 7200            	  1794: 	moveq.l	#0,d1					; clear high order bits
                            	  1795: ;	move.b	KEYBD+1,d1		; get keyboard port status
                            	  1796: ;	smi.b		d1						; set true/false
                            	  1797: ;	andi.b	#1,d1					; return true (1) if key available, 0 otherwise
02:00005F76 4A3900100013    	  1798: 	tst.b	_KeybdCnt
02:00005F7C 56C1            	  1799: 	sne.b	d1
02:00005F7E 4E75            	  1800: 	rts
                            	  1801: 
                            	  1802: ;------------------------------------------------------------------------------
                            	  1803: ; GetKey
                            	  1804: ; 	Get a character from the keyboard. 
                            	  1805: ;
                            	  1806: ; Modifies:
                            	  1807: ;		d1
                            	  1808: ; Returns:
                            	  1809: ;		d1 = -1 if no key available or not in focus, otherwise key
                            	  1810: ;------------------------------------------------------------------------------
                            	  1811: 
                            	  1812: GetKey:
02:00005F80 2F00            	  1813: 	move.l	d0,-(a7)					; push d0
02:00005F82 123900100000    	  1814: 	move.b	IOFocus,d1				; Check if the core has the IO focus
02:00005F88 4E7A0FE0        	  1815: 	movec.l	coreno,d0
02:00005F8C B200            	  1816: 	cmp.b	d0,d1
02:00005F8E 6622            	  1817: 	bne.s	.0004								; go return no key available, if not in focus
02:00005F90 6132            	  1818: 	bsr	KeybdGetCharNoWait		; get a character
02:00005F92 4A81            	  1819: 	tst.l	d1									; was a key available?
02:00005F94 6B1C            	  1820: 	bmi.s	.0004
02:00005F96 4A390004000C    	  1821: 	tst.b	KeybdEcho						; is keyboard echo on ?
02:00005F9C 6710            	  1822: 	beq.s	.0003								; no echo, just return the key
02:00005F9E 0C01000D        	  1823: 	cmpi.b #CR,d1							; convert CR keystroke into CRLF
02:00005FA2 6606            	  1824: 	bne.s	.0005
02:00005FA4 6100F8E4        	  1825: 	bsr	CRLF
02:00005FA8 6004            	  1826: 	bra.s	.0003
                            	  1827: .0005:
02:00005FAA 6100F928        	  1828: 	bsr	DisplayChar
                            	  1829: .0003:
02:00005FAE 201F            	  1830: 	move.l (a7)+,d0						; pop d0
02:00005FB0 4E75            	  1831: 	rts												; return key
                            	  1832: ; Return -1 indicating no char was available
                            	  1833: .0004:
02:00005FB2 201F            	  1834: 	move.l (a7)+,d0						; pop d0
02:00005FB4 72FF            	  1835: 	moveq	#-1,d1							; return no key available
02:00005FB6 4E75            	  1836: 	rts
                            	  1837: 
                            	  1838: CheckForCtrlC:
02:00005FB8 610A            	  1839: 	bsr	KeybdGetCharNoWait
02:00005FBA 0C010003        	  1840: 	cmpi.b #CTRLC,d1
02:00005FBE 67000700        	  1841: 	beq	Monitor
02:00005FC2 4E75            	  1842: 	rts
                            	  1843: 
                            	  1844: ;------------------------------------------------------------------------------
                            	  1845: ;------------------------------------------------------------------------------
                            	  1846: 
                            	  1847: KeybdGetCharNoWait:
02:00005FC4 42390004000D    	  1848: 	clr.b	KeybdWaitFlag
02:00005FCA 6008            	  1849: 	bra	KeybdGetChar
                            	  1850: 
                            	  1851: KeybdGetCharWait:
02:00005FCC 13FC00FF0004000D	  1852: 	move.b #-1,KeybdWaitFlag
                            	  1853: 
                            	  1854: KeybdGetChar:
02:00005FD4 48E7B080        	  1855: 	movem.l	d0/d2/d3/a0,-(a7)
                            	  1856: .0003:
02:00005FD8 4E7A0FE0        	  1857: 	movec	coreno,d0
02:00005FDC 4840            	  1858: 	swap d0
02:00005FDE 7203            	  1859: 	moveq	#KEYBD_SEMA,d1
02:00005FE0 6100A276        	  1860: 	bsr	LockSemaphore
02:00005FE4 143900100013    	  1861: 	move.b	_KeybdCnt,d2		; get count of buffered scan codes
02:00005FEA 673E            	  1862: 	beq.s		.0015						;
02:00005FEC 143900100011    	  1863: 	move.b	_KeybdHead,d2		; d2 = buffer head
02:00005FF2 4882            	  1864: 	ext.w		d2
02:00005FF4 41F900100020    	  1865: 	lea			_KeybdBuf,a0		; a0 = pointer to keyboard buffer
02:00005FFA 7200            	  1866: 	clr.l		d1
02:00005FFC 12302000        	  1867: 	move.b	(a0,d2.w),d1		; d1 = scan code from buffer
02:00006000 5202            	  1868: 	addi.b	#1,d2						; increment keyboard head index
02:00006002 0202001F        	  1869: 	andi.b	#31,d2					; and wrap around at buffer size
02:00006006 13C200100011    	  1870: 	move.b	d2,_KeybdHead
02:0000600C 533900100013    	  1871: 	subi.b	#1,_KeybdCnt		; decrement count of scan codes in buffer
02:00006012 C342            	  1872: 	exg			d1,d2						; save scancode value in d2
02:00006014 4E7A0FE0        	  1873: 	movec		coreno,d0
02:00006018 4840            	  1874: 	swap		d0
02:0000601A 7203            	  1875: 	moveq		#KEYBD_SEMA,d1
02:0000601C 6100A276        	  1876: 	bsr			UnlockSemaphore
02:00006020 C541            	  1877: 	exg			d2,d1						; restore scancode value
02:00006022 602A            	  1878: 	bra			.0001						; go process scan code
                            	  1879: .0014:
02:00006024 6100FEAC        	  1880: 	bsr		_KeybdGetStatus		; check keyboard status for key available
02:00006028 6B1C            	  1881: 	bmi		.0006							; yes, go process
                            	  1882: .0015:
02:0000602A 4E7A0FE0        	  1883: 	movec		coreno,d0
02:0000602E 4840            	  1884: 	swap		d0
02:00006030 7203            	  1885: 	moveq		#KEYBD_SEMA,d1
02:00006032 6100A260        	  1886: 	bsr			UnlockSemaphore
02:00006036 4A390004000D    	  1887: 	tst.b		KeybdWaitFlag			; are we willing to wait for a key ?
02:0000603C 6B9A            	  1888: 	bmi			.0003							; yes, branch back
02:0000603E 4CDF010D        	  1889: 	movem.l	(a7)+,d0/d2/d3/a0
02:00006042 72FF            	  1890: 	moveq		#-1,d1						; flag no char available
02:00006044 4E75            	  1891: 	rts
                            	  1892: .0006:
02:00006046 6100FEA8        	  1893: 	bsr	_KeybdGetScancode
02:0000604A 6100FEC2        	  1894: 	bsr _KeybdClearIRQ
                            	  1895: .0001:
02:0000604E 33FC0001FD0FFF00	  1896: 	move.w	#1,leds
02:00006056 B23C00F0        	  1897: 	cmp.b	#SC_KEYUP,d1
02:0000605A 670000C0        	  1898: 	beq		.doKeyup
02:0000605E B23C00E0        	  1899: 	cmp.b	#SC_EXTEND,d1
02:00006062 670000C4        	  1900: 	beq		.doExtend
02:00006066 B23C0014        	  1901: 	cmp.b	#SC_CTRL,d1
02:0000606A 670000C8        	  1902: 	beq		.doCtrl
02:0000606E B23C0012        	  1903: 	cmp.b	#SC_LSHIFT,d1
02:00006072 6700012A        	  1904: 	beq		.doShift
02:00006076 B23C0059        	  1905: 	cmp.b	#SC_RSHIFT,d1
02:0000607A 67000122        	  1906: 	beq		.doShift
02:0000607E B23C0077        	  1907: 	cmp.b	#SC_NUMLOCK,d1
02:00006082 67000142        	  1908: 	beq		.doNumLock
02:00006086 B23C0058        	  1909: 	cmp.b	#SC_CAPSLOCK,d1
02:0000608A 67000148        	  1910: 	beq		.doCapsLock
02:0000608E B23C007E        	  1911: 	cmp.b	#SC_SCROLLLOCK,d1
02:00006092 6700014E        	  1912: 	beq		.doScrollLock
02:00006096 B23C0011        	  1913: 	cmp.b   #SC_ALT,d1
02:0000609A 670000C0        	  1914: 	beq     .doAlt
02:0000609E 14390010000F    	  1915: 	move.b	_KeyState1,d2			; check key up/down
02:000060A4 42390010000F    	  1916: 	move.b	#0,_KeyState1			; clear keyup status
02:000060AA 4A02            	  1917: 	tst.b	d2
02:000060AC 6600FF2A        	  1918: 	bne	    .0003					; ignore key up
02:000060B0 B23C000D        	  1919: 	cmp.b   #SC_TAB,d1
02:000060B4 670000CE        	  1920: 	beq     .doTab
                            	  1921: .0013:
02:000060B8 143900100010    	  1922: 	move.b	_KeyState2,d2
02:000060BE 6A1A            	  1923: 	bpl		.0010					; is it extended code ?
02:000060C0 C43C007F        	  1924: 	and.b	#$7F,d2					; clear extended bit
02:000060C4 13C200100010    	  1925: 	move.b	d2,_KeyState2
02:000060CA 42390010000F    	  1926: 	move.b	#0,_KeyState1			; clear keyup
02:000060D0 41FA04C2        	  1927: 	lea		_keybdExtendedCodes,a0
02:000060D4 12301000        	  1928: 	move.b	(a0,d1.w),d1
02:000060D8 6034            	  1929: 	bra		.0008
                            	  1930: .0010:
02:000060DA 08020002        	  1931: 	btst	#2,d2					; is it CTRL code ?
02:000060DE 670E            	  1932: 	beq		.0009
02:000060E0 C27C007F        	  1933: 	and.w	#$7F,d1
02:000060E4 41FA042E        	  1934: 	lea		_keybdControlCodes,a0
02:000060E8 12301000        	  1935: 	move.b	(a0,d1.w),d1
02:000060EC 6020            	  1936: 	bra		.0008
                            	  1937: .0009:
02:000060EE 08020000        	  1938: 	btst	#0,d2					; is it shift down ?
02:000060F2 670A            	  1939: 	beq  	.0007
02:000060F4 41FA031E        	  1940: 	lea		_shiftedScanCodes,a0
02:000060F8 12301000        	  1941: 	move.b	(a0,d1.w),d1
02:000060FC 6010            	  1942: 	bra		.0008
                            	  1943: .0007:
02:000060FE 41FA0214        	  1944: 	lea		_unshiftedScanCodes,a0
02:00006102 12301000        	  1945: 	move.b	(a0,d1.w),d1
02:00006106 33FC0202FD0FFF00	  1946: 	move.w	#$0202,leds
                            	  1947: .0008:
02:0000610E 33FC0303FD0FFF00	  1948: 	move.w	#$0303,leds
02:00006116 4CDF010D        	  1949: 	movem.l	(a7)+,d0/d2/d3/a0
02:0000611A 4E75            	  1950: 	rts
                            	  1951: .doKeyup:
02:0000611C 13FC00FF0010000F	  1952: 	move.b	#-1,_KeyState1
02:00006124 6000FEB2        	  1953: 	bra		.0003
                            	  1954: .doExtend:
02:00006128 0039008000100010	  1955: 	or.b	#$80,_KeyState2
02:00006130 6000FEA6        	  1956: 	bra		.0003
                            	  1957: .doCtrl:
02:00006134 12390010000F    	  1958: 	move.b	_KeyState1,d1
02:0000613A 42390010000F    	  1959: 	clr.b	_KeyState1
02:00006140 4A01            	  1960: 	tst.b	d1
02:00006142 6A0C            	  1961: 	bpl.s	.0004
02:00006144 08B9000200100010	  1962: 	bclr	#2,_KeyState2
02:0000614C 6000FE8A        	  1963: 	bra		.0003
                            	  1964: .0004:
02:00006150 08F9000200100010	  1965: 	bset	#2,_KeyState2
02:00006158 6000FE7E        	  1966: 	bra		.0003
                            	  1967: .doAlt:
02:0000615C 12390010000F    	  1968: 	move.b	_KeyState1,d1
02:00006162 42390010000F    	  1969: 	clr.b	_KeyState1
02:00006168 4A01            	  1970: 	tst.b	d1
02:0000616A 6A0C            	  1971: 	bpl		.0011
02:0000616C 08B9000100100010	  1972: 	bclr	#1,_KeyState2
02:00006174 6000FE62        	  1973: 	bra		.0003
                            	  1974: .0011:
02:00006178 08F9000100100010	  1975: 	bset	#1,_KeyState2
02:00006180 6000FE56        	  1976: 	bra		.0003
                            	  1977: .doTab:
02:00006184 2F01            	  1978: 	move.l	d1,-(a7)
02:00006186 123900100010    	  1979:   move.b  _KeyState2,d1
02:0000618C 08010001        	  1980:   btst	#1,d1                 ; is ALT down ?
02:00006190 6706            	  1981:   beq     .0012
                            	  1982: ;    	inc     _iof_switch
02:00006192 221F            	  1983:   move.l	(a7)+,d1
02:00006194 6000FE42        	  1984:   bra     .0003
                            	  1985: .0012:
02:00006198 221F            	  1986:   move.l	(a7)+,d1
02:0000619A 6000FF1C        	  1987:   bra     .0013
                            	  1988: .doShift:
02:0000619E 12390010000F    	  1989: 	move.b	_KeyState1,d1
02:000061A4 42390010000F    	  1990: 	clr.b	_KeyState1
02:000061AA 4A01            	  1991: 	tst.b	d1
02:000061AC 6A0C            	  1992: 	bpl.s	.0005
02:000061AE 08B9000000100010	  1993: 	bclr	#0,_KeyState2
02:000061B6 6000FE20        	  1994: 	bra		.0003
                            	  1995: .0005:
02:000061BA 08F9000000100010	  1996: 	bset	#0,_KeyState2
02:000061C2 6000FE14        	  1997: 	bra		.0003
                            	  1998: .doNumLock:
02:000061C6 0879000400100010	  1999: 	bchg	#4,_KeyState2
02:000061CE 6120            	  2000: 	bsr		KeybdSetLEDStatus
02:000061D0 6000FE06        	  2001: 	bra		.0003
                            	  2002: .doCapsLock:
02:000061D4 0879000500100010	  2003: 	bchg	#5,_KeyState2
02:000061DC 6112            	  2004: 	bsr		KeybdSetLEDStatus
02:000061DE 6000FDF8        	  2005: 	bra		.0003
                            	  2006: .doScrollLock:
02:000061E2 0879000600100010	  2007: 	bchg	#6,_KeyState2
02:000061EA 6104            	  2008: 	bsr		KeybdSetLEDStatus
02:000061EC 6000FDEA        	  2009: 	bra		.0003
                            	  2010: 
                            	  2011: KeybdSetLEDStatus:
02:000061F0 48E73000        	  2012: 	movem.l	d2/d3,-(a7)
02:000061F4 42390010000E    	  2013: 	clr.b		KeybdLEDs
02:000061FA 0839000400100010	  2014: 	btst		#4,_KeyState2
02:00006202 6708            	  2015: 	beq.s		.0002
02:00006204 13FC00020010000E	  2016: 	move.b	#2,KeybdLEDs
                            	  2017: .0002:
02:0000620C 0839000500100010	  2018: 	btst		#5,_KeyState2
02:00006214 6708            	  2019: 	beq.s		.0003
02:00006216 08F900020010000E	  2020: 	bset		#2,KeybdLEDs
                            	  2021: .0003:
02:0000621E 0839000600100010	  2022: 	btst		#6,_KeyState2
02:00006226 6708            	  2023: 	beq.s		.0004
02:00006228 08F900000010000E	  2024: 	bset		#0,KeybdLEDs
                            	  2025: .0004:
02:00006230 12390010000E    	  2026: 	move.b	KeybdLEDs,d1
02:00006236 6100FB5C        	  2027: 	bsr			KeybdSetLED
02:0000623A 4CDF000C        	  2028: 	movem.l	(a7)+,d2/d3
02:0000623E 4E75            	  2029: 	rts
                            	  2030: 
                            	  2031: KeybdSendByte:
02:00006240 13C1FD0FFE00    	  2032: 	move.b d1,KEYBD
02:00006246 4E75            	  2033: 	rts
                            	  2034: 	
                            	  2035: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2036: ; Wait for 10 ms
                            	  2037: ;
                            	  2038: ; Parameters: none
                            	  2039: ; Returns: none
                            	  2040: ; Modifies: none
                            	  2041: ; Stack Space: 2 long words
                            	  2042: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2043: 
                            	  2044: Wait10ms:
02:00006248 48E7C000        	  2045: 	movem.l	d0/d1,-(a7)
02:0000624C 4E7A0FF0        	  2046: 	movec	tick,d0
02:00006250 068000061A80    	  2047: 	addi.l #400000,d0			; 400,000 cycles at 40MHz
                            	  2048: .0001:
02:00006256 4E7A1FF0        	  2049: 	movec	tick,d1
02:0000625A B081            	  2050: 	cmp.l	d1,d0
02:0000625C 62F8            	  2051: 	bhi	.0001
02:0000625E 4CDF0003        	  2052: 	movem.l	(a7)+,d0/d1
02:00006262 4E75            	  2053: 	rts
                            	  2054: 
                            	  2055: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2056: ; Wait for 300 ms
                            	  2057: ;
                            	  2058: ; Parameters: none
                            	  2059: ; Returns: none
                            	  2060: ; Modifies: none
                            	  2061: ; Stack Space: 2 long words
                            	  2062: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2063: 
                            	  2064: Wait300ms:
02:00006264 48E7C000        	  2065: 	movem.l	d0/d1,-(a7)
02:00006268 4E7A0FF0        	  2066: 	movec		tick,d0
02:0000626C 068000B71B00    	  2067: 	addi.l	#12000000,d0			; 12,000,000 cycles at 40MHz
                            	  2068: .0001:
02:00006272 4E7A1FF0        	  2069: 	movec		tick,d1
02:00006276 B081            	  2070: 	cmp.l		d1,d0
02:00006278 62F8            	  2071: 	bhi			.0001
02:0000627A 4CDF0003        	  2072: 	movem.l	(a7)+,d0/d1
02:0000627E 4E75            	  2073: 	rts
                            	  2074: 
                            	  2075: ;--------------------------------------------------------------------------
                            	  2076: ; Keyboard IRQ routine.
                            	  2077: ; - only core 2 processes keyboard interrupts.
                            	  2078: ; - the keyboard buffer is in shared global scratchpad space.
                            	  2079: ;
                            	  2080: ; Returns:
                            	  2081: ; 	d1 = -1 if keyboard routine handled interrupt, otherwise positive.
                            	  2082: ;--------------------------------------------------------------------------
                            	  2083: 
                            	  2084: KeybdIRQ:
02:00006280 46FC2600        	  2085: 	move.w #$2600,sr					; disable lower interrupts
02:00006284 48E7C080        	  2086: 	movem.l	d0/d1/a0,-(a7)
02:00006288 7200            	  2087: 	moveq	#0,d1								; check if keyboard IRQ
02:0000628A 1239FD0FFE01    	  2088: 	move.b KEYBD+1,d1					; get status reg
02:00006290 4A01            	  2089: 	tst.b	d1
02:00006292 6A7A            	  2090: 	bpl	.0001									; branch if not keyboard
02:00006294 4E7A0FE0        	  2091: 	movec	coreno,d0
02:00006298 4840            	  2092: 	swap d0
02:0000629A 7203            	  2093: 	moveq	#KEYBD_SEMA,d1
02:0000629C 61009FBA        	  2094: 	bsr LockSemaphore
02:000062A0 1239FD0FFE00    	  2095: 	move.b KEYBD,d1						; get scan code
02:000062A6 4239FD0FFE01    	  2096: 	move.b #0,KEYBD+1					; clear status register (clears IRQ AND scancode)
02:000062AC 0839000100100010	  2097: 	btst #1,_KeyState2				; Is Alt down?
02:000062B4 671E            	  2098: 	beq.s	.0003
02:000062B6 0C01000D        	  2099: 	cmpi.b #SC_TAB,d1					; is Alt-Tab?
02:000062BA 6618            	  2100: 	bne.s	.0003
02:000062BC 6100FA32        	  2101: 	bsr	rotate_iofocus
02:000062C0 423900100011    	  2102: 	clr.b	_KeybdHead					; clear keyboard buffer
02:000062C6 423900100012    	  2103: 	clr.b	_KeybdTail
02:000062CC 423900100013    	  2104: 	clr.b	_KeybdCnt
02:000062D2 602E            	  2105: 	bra	.0002									; do not store Alt-Tab
                            	  2106: .0003:
                            	  2107: 	; Insert keyboard scan code into raw keyboard buffer
02:000062D4 0C39002000100013	  2108: 	cmpi.b #32,_KeybdCnt			; see if keyboard buffer full
02:000062DC 6424            	  2109: 	bhs.s	.0002
02:000062DE 103900100012    	  2110: 	move.b _KeybdTail,d0			; keyboard buffer not full, add to tail
02:000062E4 4880            	  2111: 	ext.w	d0
02:000062E6 41F900100020    	  2112: 	lea	_KeybdBuf,a0					; a0 = pointer to buffer
02:000062EC 11810000        	  2113: 	move.b d1,(a0,d0.w)				; put scancode in buffer
02:000062F0 5200            	  2114: 	addi.b #1,d0							; increment tail index
02:000062F2 0200001F        	  2115: 	andi.b #31,d0							; wrap at buffer limit
02:000062F6 13C000100012    	  2116: 	move.b d0,_KeybdTail			; update tail index
02:000062FC 523900100013    	  2117: 	addi.b #1,_KeybdCnt				; increment buffer count
                            	  2118: .0002:
02:00006302 4E7A0FE0        	  2119: 	movec	coreno,d0
02:00006306 4840            	  2120: 	swap d0
02:00006308 7203            	  2121: 	moveq	#KEYBD_SEMA,d1
02:0000630A 61009F88        	  2122: 	bsr	UnlockSemaphore
                            	  2123: .0001:
02:0000630E 4CDF0103        	  2124: 	movem.l	(a7)+,d0/d1/a0		; return
02:00006312 4E73            	  2125: 	rte
                            	  2126: 
                            	  2127: ;--------------------------------------------------------------------------
                            	  2128: ; PS2 scan codes to ascii conversion tables.
                            	  2129: ;--------------------------------------------------------------------------
                            	  2130: ;
                            	  2131: _unshiftedScanCodes:
02:00006314 2E              	  2132: 	dc.b	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
02:00006315 A9
02:00006316 2E
02:00006317 A5
02:00006318 A3
02:00006319 A1
02:0000631A A2
02:0000631B AC
02:0000631C 2E              	  2133: 	dc.b	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
02:0000631D AA
02:0000631E A8
02:0000631F A6
02:00006320 A4
02:00006321 09
02:00006322 60
02:00006323 2E
02:00006324 2E              	  2134: 	dc.b	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
02:00006325 2E
02:00006326 2E
02:00006327 2E
02:00006328 2E
02:00006329 71
02:0000632A 31
02:0000632B 2E
02:0000632C 2E              	  2135: 	dc.b	$2e,$2e,$7a,$73,$61,$77,$32,$2e
02:0000632D 2E
02:0000632E 7A
02:0000632F 73
02:00006330 61
02:00006331 77
02:00006332 32
02:00006333 2E
02:00006334 2E              	  2136: 	dc.b	$2e,$63,$78,$64,$65,$34,$33,$2e
02:00006335 63
02:00006336 78
02:00006337 64
02:00006338 65
02:00006339 34
02:0000633A 33
02:0000633B 2E
02:0000633C 2E              	  2137: 	dc.b	$2e,$20,$76,$66,$74,$72,$35,$2e
02:0000633D 20
02:0000633E 76
02:0000633F 66
02:00006340 74
02:00006341 72
02:00006342 35
02:00006343 2E
02:00006344 2E              	  2138: 	dc.b	$2e,$6e,$62,$68,$67,$79,$36,$2e
02:00006345 6E
02:00006346 62
02:00006347 68
02:00006348 67
02:00006349 79
02:0000634A 36
02:0000634B 2E
02:0000634C 2E              	  2139: 	dc.b	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
02:0000634D 2E
02:0000634E 6D
02:0000634F 6A
02:00006350 75
02:00006351 37
02:00006352 38
02:00006353 2E
02:00006354 2E              	  2140: 	dc.b	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
02:00006355 2C
02:00006356 6B
02:00006357 69
02:00006358 6F
02:00006359 30
02:0000635A 39
02:0000635B 2E
02:0000635C 2E              	  2141: 	dc.b	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
02:0000635D 2E
02:0000635E 2F
02:0000635F 6C
02:00006360 3B
02:00006361 70
02:00006362 2D
02:00006363 2E
02:00006364 2E              	  2142: 	dc.b	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
02:00006365 2E
02:00006366 27
02:00006367 2E
02:00006368 5B
02:00006369 3D
02:0000636A 2E
02:0000636B 2E
02:0000636C AD              	  2143: 	dc.b	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
02:0000636D 2E
02:0000636E 0D
02:0000636F 5D
02:00006370 2E
02:00006371 5C
02:00006372 2E
02:00006373 2E
02:00006374 2E              	  2144: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
02:00006375 2E
02:00006376 2E
02:00006377 2E
02:00006378 2E
02:00006379 2E
02:0000637A 08
02:0000637B 2E
02:0000637C 2E              	  2145: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
02:0000637D 95
02:0000637E 2E
02:0000637F 93
02:00006380 94
02:00006381 2E
02:00006382 2E
02:00006383 2E
02:00006384 98              	  2146: 	dc.b	$98,$7f,$92,$2e,$91,$90,$1b,$af
02:00006385 7F
02:00006386 92
02:00006387 2E
02:00006388 91
02:00006389 90
02:0000638A 1B
02:0000638B AF
02:0000638C AB              	  2147: 	dc.b	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
02:0000638D 2E
02:0000638E 97
02:0000638F 2E
02:00006390 2E
02:00006391 96
02:00006392 AE
02:00006393 2E
                            	  2148: 
02:00006394 2E              	  2149: 	dc.b	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
02:00006395 2E
02:00006396 2E
02:00006397 A7
02:00006398 2E
02:00006399 2E
02:0000639A 2E
02:0000639B 2E
02:0000639C 2E              	  2150: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:0000639D 2E
02:0000639E 2E
02:0000639F 2E
02:000063A0 2E
02:000063A1 2E
02:000063A2 2E
02:000063A3 2E
02:000063A4 2E              	  2151: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063A5 2E
02:000063A6 2E
02:000063A7 2E
02:000063A8 2E
02:000063A9 2E
02:000063AA 2E
02:000063AB 2E
02:000063AC 2E              	  2152: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063AD 2E
02:000063AE 2E
02:000063AF 2E
02:000063B0 2E
02:000063B1 2E
02:000063B2 2E
02:000063B3 2E
02:000063B4 2E              	  2153: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063B5 2E
02:000063B6 2E
02:000063B7 2E
02:000063B8 2E
02:000063B9 2E
02:000063BA 2E
02:000063BB 2E
02:000063BC 2E              	  2154: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063BD 2E
02:000063BE 2E
02:000063BF 2E
02:000063C0 2E
02:000063C1 2E
02:000063C2 2E
02:000063C3 2E
02:000063C4 2E              	  2155: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063C5 2E
02:000063C6 2E
02:000063C7 2E
02:000063C8 2E
02:000063C9 2E
02:000063CA 2E
02:000063CB 2E
02:000063CC 2E              	  2156: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063CD 2E
02:000063CE 2E
02:000063CF 2E
02:000063D0 2E
02:000063D1 2E
02:000063D2 2E
02:000063D3 2E
02:000063D4 2E              	  2157: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063D5 2E
02:000063D6 2E
02:000063D7 2E
02:000063D8 2E
02:000063D9 2E
02:000063DA 2E
02:000063DB 2E
02:000063DC 2E              	  2158: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063DD 2E
02:000063DE 2E
02:000063DF 2E
02:000063E0 2E
02:000063E1 2E
02:000063E2 2E
02:000063E3 2E
02:000063E4 2E              	  2159: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063E5 2E
02:000063E6 2E
02:000063E7 2E
02:000063E8 2E
02:000063E9 2E
02:000063EA 2E
02:000063EB 2E
02:000063EC 2E              	  2160: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063ED 2E
02:000063EE 2E
02:000063EF 2E
02:000063F0 2E
02:000063F1 2E
02:000063F2 2E
02:000063F3 2E
02:000063F4 2E              	  2161: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063F5 2E
02:000063F6 2E
02:000063F7 2E
02:000063F8 2E
02:000063F9 2E
02:000063FA 2E
02:000063FB 2E
02:000063FC 2E              	  2162: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063FD 2E
02:000063FE 2E
02:000063FF 2E
02:00006400 2E
02:00006401 2E
02:00006402 2E
02:00006403 2E
02:00006404 2E              	  2163: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00006405 2E
02:00006406 2E
02:00006407 2E
02:00006408 2E
02:00006409 2E
02:0000640A 2E
02:0000640B 2E
02:0000640C 2E              	  2164: 	dc.b	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
02:0000640D 2E
02:0000640E FA
02:0000640F 2E
02:00006410 2E
02:00006411 2E
02:00006412 2E
02:00006413 2E
                            	  2165: 
                            	  2166: _shiftedScanCodes:
02:00006414 2E              	  2167: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00006415 2E
02:00006416 2E
02:00006417 2E
02:00006418 2E
02:00006419 2E
02:0000641A 2E
02:0000641B 2E
02:0000641C 2E              	  2168: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
02:0000641D 2E
02:0000641E 2E
02:0000641F 2E
02:00006420 2E
02:00006421 09
02:00006422 7E
02:00006423 2E
02:00006424 2E              	  2169: 	dc.b	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
02:00006425 2E
02:00006426 2E
02:00006427 2E
02:00006428 2E
02:00006429 51
02:0000642A 21
02:0000642B 2E
02:0000642C 2E              	  2170: 	dc.b	$2e,$2e,$5a,$53,$41,$57,$40,$2e
02:0000642D 2E
02:0000642E 5A
02:0000642F 53
02:00006430 41
02:00006431 57
02:00006432 40
02:00006433 2E
02:00006434 2E              	  2171: 	dc.b	$2e,$43,$58,$44,$45,$24,$23,$2e
02:00006435 43
02:00006436 58
02:00006437 44
02:00006438 45
02:00006439 24
02:0000643A 23
02:0000643B 2E
02:0000643C 2E              	  2172: 	dc.b	$2e,$20,$56,$46,$54,$52,$25,$2e
02:0000643D 20
02:0000643E 56
02:0000643F 46
02:00006440 54
02:00006441 52
02:00006442 25
02:00006443 2E
02:00006444 2E              	  2173: 	dc.b	$2e,$4e,$42,$48,$47,$59,$5e,$2e
02:00006445 4E
02:00006446 42
02:00006447 48
02:00006448 47
02:00006449 59
02:0000644A 5E
02:0000644B 2E
02:0000644C 2E              	  2174: 	dc.b	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
02:0000644D 2E
02:0000644E 4D
02:0000644F 4A
02:00006450 55
02:00006451 26
02:00006452 2A
02:00006453 2E
02:00006454 2E              	  2175: 	dc.b	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
02:00006455 3C
02:00006456 4B
02:00006457 49
02:00006458 4F
02:00006459 29
02:0000645A 28
02:0000645B 2E
02:0000645C 2E              	  2176: 	dc.b	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
02:0000645D 3E
02:0000645E 3F
02:0000645F 4C
02:00006460 3A
02:00006461 50
02:00006462 5F
02:00006463 2E
02:00006464 2E              	  2177: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
02:00006465 2E
02:00006466 22
02:00006467 2E
02:00006468 7B
02:00006469 2B
02:0000646A 2E
02:0000646B 2E
02:0000646C 2E              	  2178: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
02:0000646D 2E
02:0000646E 0D
02:0000646F 7D
02:00006470 2E
02:00006471 7C
02:00006472 2E
02:00006473 2E
02:00006474 2E              	  2179: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
02:00006475 2E
02:00006476 2E
02:00006477 2E
02:00006478 2E
02:00006479 2E
02:0000647A 08
02:0000647B 2E
02:0000647C 2E              	  2180: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:0000647D 2E
02:0000647E 2E
02:0000647F 2E
02:00006480 2E
02:00006481 2E
02:00006482 2E
02:00006483 2E
02:00006484 2E              	  2181: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
02:00006485 7F
02:00006486 2E
02:00006487 2E
02:00006488 2E
02:00006489 2E
02:0000648A 1B
02:0000648B 2E
02:0000648C 2E              	  2182: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:0000648D 2E
02:0000648E 2E
02:0000648F 2E
02:00006490 2E
02:00006491 2E
02:00006492 2E
02:00006493 2E
                            	  2183: 
02:00006494 2E              	  2184: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00006495 2E
02:00006496 2E
02:00006497 2E
02:00006498 2E
02:00006499 2E
02:0000649A 2E
02:0000649B 2E
02:0000649C 2E              	  2185: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:0000649D 2E
02:0000649E 2E
02:0000649F 2E
02:000064A0 2E
02:000064A1 2E
02:000064A2 2E
02:000064A3 2E
02:000064A4 2E              	  2186: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064A5 2E
02:000064A6 2E
02:000064A7 2E
02:000064A8 2E
02:000064A9 2E
02:000064AA 2E
02:000064AB 2E
02:000064AC 2E              	  2187: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064AD 2E
02:000064AE 2E
02:000064AF 2E
02:000064B0 2E
02:000064B1 2E
02:000064B2 2E
02:000064B3 2E
02:000064B4 2E              	  2188: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064B5 2E
02:000064B6 2E
02:000064B7 2E
02:000064B8 2E
02:000064B9 2E
02:000064BA 2E
02:000064BB 2E
02:000064BC 2E              	  2189: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064BD 2E
02:000064BE 2E
02:000064BF 2E
02:000064C0 2E
02:000064C1 2E
02:000064C2 2E
02:000064C3 2E
02:000064C4 2E              	  2190: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064C5 2E
02:000064C6 2E
02:000064C7 2E
02:000064C8 2E
02:000064C9 2E
02:000064CA 2E
02:000064CB 2E
02:000064CC 2E              	  2191: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064CD 2E
02:000064CE 2E
02:000064CF 2E
02:000064D0 2E
02:000064D1 2E
02:000064D2 2E
02:000064D3 2E
02:000064D4 2E              	  2192: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064D5 2E
02:000064D6 2E
02:000064D7 2E
02:000064D8 2E
02:000064D9 2E
02:000064DA 2E
02:000064DB 2E
02:000064DC 2E              	  2193: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064DD 2E
02:000064DE 2E
02:000064DF 2E
02:000064E0 2E
02:000064E1 2E
02:000064E2 2E
02:000064E3 2E
02:000064E4 2E              	  2194: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064E5 2E
02:000064E6 2E
02:000064E7 2E
02:000064E8 2E
02:000064E9 2E
02:000064EA 2E
02:000064EB 2E
02:000064EC 2E              	  2195: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064ED 2E
02:000064EE 2E
02:000064EF 2E
02:000064F0 2E
02:000064F1 2E
02:000064F2 2E
02:000064F3 2E
02:000064F4 2E              	  2196: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064F5 2E
02:000064F6 2E
02:000064F7 2E
02:000064F8 2E
02:000064F9 2E
02:000064FA 2E
02:000064FB 2E
02:000064FC 2E              	  2197: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064FD 2E
02:000064FE 2E
02:000064FF 2E
02:00006500 2E
02:00006501 2E
02:00006502 2E
02:00006503 2E
02:00006504 2E              	  2198: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00006505 2E
02:00006506 2E
02:00006507 2E
02:00006508 2E
02:00006509 2E
02:0000650A 2E
02:0000650B 2E
02:0000650C 2E              	  2199: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:0000650D 2E
02:0000650E 2E
02:0000650F 2E
02:00006510 2E
02:00006511 2E
02:00006512 2E
02:00006513 2E
                            	  2200: 
                            	  2201: ; control
                            	  2202: _keybdControlCodes:
02:00006514 2E              	  2203: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00006515 2E
02:00006516 2E
02:00006517 2E
02:00006518 2E
02:00006519 2E
02:0000651A 2E
02:0000651B 2E
02:0000651C 2E              	  2204: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
02:0000651D 2E
02:0000651E 2E
02:0000651F 2E
02:00006520 2E
02:00006521 09
02:00006522 7E
02:00006523 2E
02:00006524 2E              	  2205: 	dc.b	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
02:00006525 2E
02:00006526 2E
02:00006527 2E
02:00006528 2E
02:00006529 11
02:0000652A 21
02:0000652B 2E
02:0000652C 2E              	  2206: 	dc.b	$2e,$2e,$1a,$13,$01,$17,$40,$2e
02:0000652D 2E
02:0000652E 1A
02:0000652F 13
02:00006530 01
02:00006531 17
02:00006532 40
02:00006533 2E
02:00006534 2E              	  2207: 	dc.b	$2e,$03,$18,$04,$05,$24,$23,$2e
02:00006535 03
02:00006536 18
02:00006537 04
02:00006538 05
02:00006539 24
02:0000653A 23
02:0000653B 2E
02:0000653C 2E              	  2208: 	dc.b	$2e,$20,$16,$06,$14,$12,$25,$2e
02:0000653D 20
02:0000653E 16
02:0000653F 06
02:00006540 14
02:00006541 12
02:00006542 25
02:00006543 2E
02:00006544 2E              	  2209: 	dc.b	$2e,$0e,$02,$08,$07,$19,$5e,$2e
02:00006545 0E
02:00006546 02
02:00006547 08
02:00006548 07
02:00006549 19
02:0000654A 5E
02:0000654B 2E
02:0000654C 2E              	  2210: 	dc.b	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
02:0000654D 2E
02:0000654E 0D
02:0000654F 0A
02:00006550 15
02:00006551 26
02:00006552 2A
02:00006553 2E
02:00006554 2E              	  2211: 	dc.b	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
02:00006555 3C
02:00006556 0B
02:00006557 09
02:00006558 0F
02:00006559 29
02:0000655A 28
02:0000655B 2E
02:0000655C 2E              	  2212: 	dc.b	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
02:0000655D 3E
02:0000655E 3F
02:0000655F 0C
02:00006560 3A
02:00006561 10
02:00006562 5F
02:00006563 2E
02:00006564 2E              	  2213: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
02:00006565 2E
02:00006566 22
02:00006567 2E
02:00006568 7B
02:00006569 2B
02:0000656A 2E
02:0000656B 2E
02:0000656C 2E              	  2214: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
02:0000656D 2E
02:0000656E 0D
02:0000656F 7D
02:00006570 2E
02:00006571 7C
02:00006572 2E
02:00006573 2E
02:00006574 2E              	  2215: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
02:00006575 2E
02:00006576 2E
02:00006577 2E
02:00006578 2E
02:00006579 2E
02:0000657A 08
02:0000657B 2E
02:0000657C 2E              	  2216: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:0000657D 2E
02:0000657E 2E
02:0000657F 2E
02:00006580 2E
02:00006581 2E
02:00006582 2E
02:00006583 2E
02:00006584 2E              	  2217: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
02:00006585 7F
02:00006586 2E
02:00006587 2E
02:00006588 2E
02:00006589 2E
02:0000658A 1B
02:0000658B 2E
02:0000658C 2E              	  2218: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:0000658D 2E
02:0000658E 2E
02:0000658F 2E
02:00006590 2E
02:00006591 2E
02:00006592 2E
02:00006593 2E
                            	  2219: 
                            	  2220: _keybdExtendedCodes:
02:00006594 2E              	  2221: 	dc.b	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
02:00006595 2E
02:00006596 2E
02:00006597 2E
02:00006598 A3
02:00006599 A1
02:0000659A A2
02:0000659B 2E
02:0000659C 2E              	  2222: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:0000659D 2E
02:0000659E 2E
02:0000659F 2E
02:000065A0 2E
02:000065A1 2E
02:000065A2 2E
02:000065A3 2E
02:000065A4 2E              	  2223: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065A5 2E
02:000065A6 2E
02:000065A7 2E
02:000065A8 2E
02:000065A9 2E
02:000065AA 2E
02:000065AB 2E
02:000065AC 2E              	  2224: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065AD 2E
02:000065AE 2E
02:000065AF 2E
02:000065B0 2E
02:000065B1 2E
02:000065B2 2E
02:000065B3 2E
02:000065B4 2E              	  2225: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065B5 2E
02:000065B6 2E
02:000065B7 2E
02:000065B8 2E
02:000065B9 2E
02:000065BA 2E
02:000065BB 2E
02:000065BC 2E              	  2226: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065BD 2E
02:000065BE 2E
02:000065BF 2E
02:000065C0 2E
02:000065C1 2E
02:000065C2 2E
02:000065C3 2E
02:000065C4 2E              	  2227: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065C5 2E
02:000065C6 2E
02:000065C7 2E
02:000065C8 2E
02:000065C9 2E
02:000065CA 2E
02:000065CB 2E
02:000065CC 2E              	  2228: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065CD 2E
02:000065CE 2E
02:000065CF 2E
02:000065D0 2E
02:000065D1 2E
02:000065D2 2E
02:000065D3 2E
02:000065D4 2E              	  2229: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065D5 2E
02:000065D6 2E
02:000065D7 2E
02:000065D8 2E
02:000065D9 2E
02:000065DA 2E
02:000065DB 2E
02:000065DC 2E              	  2230: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065DD 2E
02:000065DE 2E
02:000065DF 2E
02:000065E0 2E
02:000065E1 2E
02:000065E2 2E
02:000065E3 2E
02:000065E4 2E              	  2231: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065E5 2E
02:000065E6 2E
02:000065E7 2E
02:000065E8 2E
02:000065E9 2E
02:000065EA 2E
02:000065EB 2E
02:000065EC 2E              	  2232: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065ED 2E
02:000065EE 2E
02:000065EF 2E
02:000065F0 2E
02:000065F1 2E
02:000065F2 2E
02:000065F3 2E
02:000065F4 2E              	  2233: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065F5 2E
02:000065F6 2E
02:000065F7 2E
02:000065F8 2E
02:000065F9 2E
02:000065FA 2E
02:000065FB 2E
02:000065FC 2E              	  2234: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
02:000065FD 95
02:000065FE 2E
02:000065FF 93
02:00006600 94
02:00006601 2E
02:00006602 2E
02:00006603 2E
02:00006604 98              	  2235: 	dc.b	$98,$99,$92,$2e,$91,$90,$2e,$2e
02:00006605 99
02:00006606 92
02:00006607 2E
02:00006608 91
02:00006609 90
02:0000660A 2E
02:0000660B 2E
02:0000660C 2E              	  2236: 	dc.b	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
02:0000660D 2E
02:0000660E 97
02:0000660F 2E
02:00006610 2E
02:00006611 96
02:00006612 2E
02:00006613 2E
                            	  2237: 
                            	  2238: ;==============================================================================
                            	  2239: ;==============================================================================
                            	  2240: ; Monitor
                            	  2241: ;==============================================================================
                            	  2242: ;==============================================================================
                            	  2243: 
                            	  2244: cmdString:
02:00006614 BF              	  2245: 	dc.b	'?'+$80						; ? display help
02:00006615 CC              	  2246: 	dc.b	'L'+$80						; L load S19 file
02:00006616 46              	  2247: 	dc.b	'F','B'+$80				; FB fill with byte
02:00006617 C2
02:00006618 46              	  2248: 	dc.b	'F','W'+$80				; FW fill with wyde
02:00006619 D7
02:0000661A 46              	  2249: 	dc.b	'F','L'+$80				; FL fill with long wyde
02:0000661B CC
02:0000661C 464D54          	  2250: 	dc.b	'FMT','K'+$80			; FMTK run Femtiki OS
02:0000661F CB
02:00006620 42              	  2251: 	dc.b	'B','A'+$80				; BA start Tiny Basic
02:00006621 C1
02:00006622 42              	  2252: 	dc.b	'B','R'+$80				; BR breakpoint
02:00006623 D2
02:00006624 44              	  2253: 	dc.b	'D','R'+$80				; DR dump registers
02:00006625 D2
02:00006626 C4              	  2254: 	dc.b	'D'+$80						; D dump memory
02:00006627 CA              	  2255: 	dc.b	'J'+$80						; J jump to code
02:00006628 BA              	  2256: 	dc.b	':'+$80						; : edit memory
02:00006629 434C            	  2257: 	dc.b	"CL",'S'+$80			; CLS clear screen
02:0000662B D3
02:0000662C 434F52          	  2258: 	dc.b	"COR",'E'+$80			; CORE <n> switch to core
02:0000662F C5
02:00006630 5446            	  2259: 	dc.b	"TF",'P'+$80			; TFP test fp
02:00006632 D0
02:00006633 5447            	  2260: 	dc.b  "TG",'F'+$80			; TGF test get float
02:00006635 C6
02:00006636 545241          	  2261: 	dc.b  "TRA",'M'+$80			; TRAM test RAM
02:00006639 CD
02:0000663A 54              	  2262: 	dc.b	'T','R'+$80				; TR test serial receive
02:0000663B D2
02:0000663C D4              	  2263: 	dc.b	'T'+$80						; T test CPU
02:0000663D D3              	  2264: 	dc.b	'S'+$80						; S send serial
02:0000663E 52455345        	  2265: 	dc.b	"RESE",'T'+$80		; RESET <n>
02:00006642 D4
02:00006643 434C4F43        	  2266: 	dc.b	"CLOC",'K'+$80		; CLOCK <n>
02:00006647 CB
02:00006648 D2              	  2267: 	dc.b	'R'+$80						; R receive serial
                            	  2268: 
                            	  2269: 	align	2
                            	  2270: cmdTable:
02:0000664C 000068F0        	  2271: 	dc.l	cmdHelp
02:00006650 000074C2        	  2272: 	dc.l	cmdLoadS19
02:00006654 00006B90        	  2273: 	dc.l	cmdFillB
02:00006658 00006BB4        	  2274: 	dc.l	cmdFillW
02:0000665C 00006BD8        	  2275: 	dc.l	cmdFillL
02:00006660 000067BE        	  2276: 	dc.l	cmdFMTK
02:00006664 0000677A        	  2277: 	dc.l	cmdTinyBasic
02:00006668 00006756        	  2278: 	dc.l	cmdBreakpoint
02:0000666C 00006D0A        	  2279: 	dc.l	cmdDumpRegs
02:00006670 00006C7C        	  2280: 	dc.l	cmdDumpMemory
02:00006674 00006C6E        	  2281: 	dc.l	cmdJump
02:00006678 00006C0E        	  2282: 	dc.l	cmdEditMemory
02:0000667C 0000678E        	  2283: 	dc.l	cmdClearScreen
02:00006680 0000679A        	  2284: 	dc.l	cmdCore
02:00006684 000067C6        	  2285: 	dc.l  cmdTestFP
02:00006688 00006852        	  2286: 	dc.l	cmdTestGF
02:0000668C 00007400        	  2287: 	dc.l  cmdTestRAM
02:00006690 00006DB4        	  2288: 	dc.l	cmdTestSerialReceive
02:00006694 0000677E        	  2289: 	dc.l	cmdTestCPU
02:00006698 00006B2C        	  2290: 	dc.l	cmdSendSerial
02:0000669C 0000689E        	  2291: 	dc.l	cmdReset
02:000066A0 00006880        	  2292: 	dc.l	cmdClock
02:000066A4 00006B5C        	  2293: 	dc.l	cmdReceiveSerial	
02:000066A8 000066C0        	  2294: 	dc.l	cmdMonitor
                            	  2295: 
                            	  2296: ; Get a word from screen memory and swap byte order
                            	  2297: 
                            	  2298: FromScreen:
02:000066AC 2210            	  2299: 	move.l	(a0),d1
02:000066AE 6100102A        	  2300: 	bsr			rbo
02:000066B2 5088            	  2301: 	lea			8(a0),a0	; increment screen pointer
02:000066B4 4E75            	  2302: 	rts
                            	  2303: 
                            	  2304: StartMon:
02:000066B6 427900040202    	  2305: 	clr.w		NumSetBreakpoints
02:000066BC 610014F8        	  2306: 	bsr			ClearBreakpointList
                            	  2307: cmdMonitor:
                            	  2308: Monitor:
                            	  2309: 	; Reset the stack pointer on each entry into the monitor
02:000066C0 2E7C00040FFC    	  2310: 	move.l	#$40FFC,sp	; reset core's stack
02:000066C6 46FC2200        	  2311: 	move.w	#$2200,sr		; enable level 2 and higher interrupts
02:000066CA 4E7A0FE0        	  2312: 	movec		coreno,d0
02:000066CE 4840            	  2313: 	swap		d0
02:000066D0 7201            	  2314: 	moveq		#1,d1
02:000066D2 61009BC0        	  2315: 	bsr			UnlockSemaphore
02:000066D6 42390004000C    	  2316: 	clr.b		KeybdEcho		; turn off keyboard echo
                            	  2317: PromptLn:
02:000066DC 6100F1AC        	  2318: 	bsr			CRLF
02:000066E0 123C0024        	  2319: 	move.b	#'$',d1
02:000066E4 6100F1EE        	  2320: 	bsr			DisplayChar
                            	  2321: 
                            	  2322: ; Get characters until a CR is keyed
                            	  2323: ;
                            	  2324: Prompt3:
02:000066E8 6100F896        	  2325: 	bsr			GetKey
02:000066EC 0C0100FF        	  2326: 	cmpi.b	#-1,d1
02:000066F0 67F6            	  2327: 	beq.s		Prompt3
02:000066F2 0C01000D        	  2328: 	cmpi.b	#CR,d1
02:000066F6 6706            	  2329: 	beq.s		Prompt1
02:000066F8 6100F1DA        	  2330: 	bsr			DisplayChar
02:000066FC 60EA            	  2331: 	bra.s		Prompt3
                            	  2332: 
                            	  2333: ; Process the screen line that the CR was keyed on
                            	  2334: 
                            	  2335: Prompt1:
02:000066FE 423900040001    	  2336: 	clr.b		CursorCol			; go back to the start of the line
02:00006704 6100F1C0        	  2337: 	bsr			CalcScreenLoc	; a0 = screen memory location
                            	  2338: .0001:
02:00006708 61A2            	  2339: 	bsr			FromScreen		; grab character off screen
02:0000670A 0C010024        	  2340: 	cmpi.b	#'$',d1				; skip over '$' prompt character
02:0000670E 67F8            	  2341: 	beq.s		.0001
                            	  2342: 	
                            	  2343: ; Dispatch based on command string
                            	  2344: 
                            	  2345: cmdDispatch:
02:00006710 45FAFF02        	  2346: 	lea			cmdString,a2
02:00006714 7800            	  2347: 	clr.l		d4						; command counter
02:00006716 5188            	  2348: 	lea			-8(a0),a0			; backup a character
02:00006718 2648            	  2349: 	move.l	a0,a3					; a3 = start of command on screen
                            	  2350: .checkNextCmd:
02:0000671A 6190            	  2351: 	bsr			FromScreen		; d1 = char from input screen
02:0000671C 1A1A            	  2352: 	move.b	(a2)+,d5
02:0000671E BB01            	  2353: 	eor.b		d5,d1					; does it match with command string?
02:00006720 67F8            	  2354: 	beq.s		.checkNextCmd	; If it does, keep matching for longest match
02:00006722 0C010080        	  2355: 	cmpi.b	#$80,d1				; didn't match, was it the end of the command?
02:00006726 6724            	  2356: 	beq.s		.foundCmd
02:00006728 4A2AFFFF        	  2357: 	tst.b		-1(a2)				; was end of table hit?
02:0000672C 6712            	  2358: 	beq.s		.endOfTable
02:0000672E 5844            	  2359: 	addi.w	#4,d4					; increment command counter
02:00006730 204B            	  2360: 	move.l	a3,a0					; reset input pointer
02:00006732 4A2AFFFF        	  2361: 	tst.b		-1(a2)				; were we at the end of the command?
02:00006736 6BE2            	  2362: 	bmi.s		.checkNextCmd	; if were at end continue, otherwise scan for enf of cmd
                            	  2363: .scanToEndOfCmd
02:00006738 4A1A            	  2364: 	tst.b		(a2)+					; scan to end of command
02:0000673A 6704            	  2365: 	beq.s		.endOfTable
02:0000673C 6AFA            	  2366: 	bpl.s		.scanToEndOfCmd
02:0000673E 6BDA            	  2367: 	bmi.s		.checkNextCmd
                            	  2368: .endOfTable
02:00006740 43FA0325        	  2369: 	lea			msgUnknownCmd,a1
02:00006744 6100F422        	  2370: 	bsr			DisplayStringCRLF
02:00006748 6000FF76        	  2371: 	bra			Monitor
                            	  2372: .foundCmd:
02:0000674C 43FAFEFE        	  2373: 	lea			cmdTable,a1		; a1 = pointer to command address table
02:00006750 22714000        	  2374: 	move.l	(a1,d4.w),a1	; fetch command routine address from table
02:00006754 4ED1            	  2375: 	jmp			(a1)					; go execute command
                            	  2376: 
                            	  2377: cmdBreakpoint:
02:00006756 610004A4        	  2378: 	bsr			ignBlanks
02:0000675A 6100FF50        	  2379: 	bsr			FromScreen
02:0000675E 0C01002B        	  2380: 	cmpi.b	#'+',d1
02:00006762 67001360        	  2381: 	beq			ArmBreakpoint
02:00006766 0C01002D        	  2382: 	cmpi.b	#'-',d1
02:0000676A 670013D6        	  2383: 	beq			DisarmBreakpoint
02:0000676E 0C01004C        	  2384: 	cmpi.b	#'L',d1
02:00006772 67001422        	  2385: 	beq			ListBreakpoints
02:00006776 6000FF48        	  2386: 	bra			Monitor
                            	  2387: 
                            	  2388: cmdTinyBasic:
02:0000677A 6000D716        	  2389: 	bra			CSTART
                            	  2390: 
                            	  2391: cmdTestCPU:
02:0000677E 61009BAE        	  2392: 	bsr			cpu_test
02:00006782 43FA171D        	  2393: 	lea			msg_test_done,a1
02:00006786 6100F3E0        	  2394: 	bsr			DisplayStringCRLF
02:0000678A 6000FF34        	  2395: 	bra			Monitor
                            	  2396: 
                            	  2397: cmdClearScreen:
02:0000678E 61000F44        	  2398: 	bsr			ClearScreen
02:00006792 6100F400        	  2399: 	bsr			HomeCursor
02:00006796 6000FF28        	  2400: 	bra			Monitor
                            	  2401: 
                            	  2402: cmdCore:
02:0000679A 61000460        	  2403: 	bsr			ignBlanks
02:0000679E 6100FF0C        	  2404: 	bsr			FromScreen
02:000067A2 0C010032        	  2405: 	cmpi.b	#'2',d1					; check range
02:000067A6 6500FF18        	  2406: 	blo			Monitor
02:000067AA 0C010039        	  2407: 	cmpi.b	#'9',d1
02:000067AE 6200FF10        	  2408: 	bhi			Monitor
02:000067B2 04010030        	  2409: 	subi.b	#'0',d1					; convert ascii to binary
02:000067B6 6100F526        	  2410: 	bsr			select_iofocus
02:000067BA 6000FF04        	  2411: 	bra			Monitor
                            	  2412: 
                            	  2413: cmdFMTK:
02:000067BE 6100EEBC        	  2414: 	bsr FemtikiInit
02:000067C2 6000FEFC        	  2415: 	bra Monitor
                            	  2416: 
                            	  2417: cmdTestFP:
02:000067C6 7029            	  2418: 	moveq #41,d0						; function #41, get float
02:000067C8 7208            	  2419: 	moveq #8,d1							; d1 = input stride
02:000067CA 2248            	  2420: 	move.l a0,a1						; a1 = pointer to input buffer
02:000067CC 4E4F            	  2421: 	trap #15
02:000067CE 2049            	  2422: 	move.l a1,a0
02:000067D0 F2000200        	  2423: 	fmove.x fp0,fp4
02:000067D4 61000426        	  2424: 	bsr ignBlanks
02:000067D8 6100FED2        	  2425: 	bsr FromScreen
02:000067DC 1E01            	  2426: 	move.b d1,d7
02:000067DE 7029            	  2427: 	moveq #41,d0						; function #41, get float
02:000067E0 7208            	  2428: 	move.l #8,d1						; d1 = input stride
02:000067E2 2248            	  2429: 	move.l a0,a1						; a1 = pointer to input buffer
02:000067E4 4E4F            	  2430: 	trap #15
02:000067E6 2049            	  2431: 	move.l a1,a0
02:000067E8 F2000100        	  2432: 	fmove.x fp0,fp2
02:000067EC 6100F09C        	  2433: 	bsr CRLF
                            	  2434: ;	moveq #39,d0
                            	  2435: ;	moveq #40,d1
                            	  2436: ;	moveq #30,d2
                            	  2437: ;	moveq #'e',d3
                            	  2438: ;	trap #15
                            	  2439: ;	bsr CRLF
02:000067F0 F2396A00000402C0	  2440: 	fmove.x fp4,fpBuf
02:000067F8 F2396900000402D0	  2441: 	fmove.x fp2,fpBuf+16
02:00006800 0C07002B        	  2442: 	cmpi.b #'+',d7
02:00006804 6606            	  2443: 	bne .0001
02:00006806 F2000A22        	  2444: 	fadd fp2,fp4
02:0000680A 6022            	  2445: 	bra .0002
                            	  2446: .0001
02:0000680C 0C07002D        	  2447: 	cmpi.b #'-',d7
02:00006810 6606            	  2448: 	bne .0003
02:00006812 F2000A28        	  2449: 	fsub fp2,fp4
02:00006816 6016            	  2450: 	bra .0002
                            	  2451: .0003
02:00006818 0C07002A        	  2452: 	cmpi.b #'*',d7
02:0000681C 6606            	  2453: 	bne .0004
02:0000681E F2000A23        	  2454: 	fmul fp2,fp4
02:00006822 600A            	  2455: 	bra .0002
                            	  2456: .0004
02:00006824 0C07002F        	  2457: 	cmpi.b #'/',d7
02:00006828 6620            	  2458: 	bne .0005
02:0000682A F2000A20        	  2459: 	fdiv fp2,fp4
                            	  2460: 	bra .0002
                            	  2461: .0002
02:0000682E F2396A00000402E0	  2462: 	fmove.x fp4,fpBuf+32
02:00006836 F2001000        	  2463: 	fmove.x fp4,fp0
02:0000683A 43F900040520    	  2464: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
02:00006840 7027            	  2465: 	moveq #39,d0						; function #39 print float
02:00006842 7228            	  2466: 	moveq #40,d1						; width
02:00006844 741E            	  2467: 	moveq #30,d2						; precision
02:00006846 7665            	  2468: 	moveq #'e',d3
02:00006848 4E4F            	  2469: 	trap #15
                            	  2470: .0005
02:0000684A 6100F03E        	  2471: 	bsr CRLF
02:0000684E 6000FE70        	  2472: 	bra Monitor
                            	  2473: 
                            	  2474: cmdTestGF:
02:00006852 6100F036        	  2475: 	bsr CRLF
02:00006856 7029            	  2476: 	moveq #41,d0						; function #41, get float
02:00006858 7208            	  2477: 	move.l #8,d1						; d1 = input stride
02:0000685A 2248            	  2478: 	move.l a0,a1						; a1 = pointer to input buffer
02:0000685C 4E4F            	  2479: 	trap #15
02:0000685E F2396800000402E0	  2480: 	fmove.x fp0,fpBuf+32
02:00006866 43F900040520    	  2481: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
02:0000686C 7027            	  2482: 	moveq #39,d0
02:0000686E 7228            	  2483: 	moveq #40,d1
02:00006870 741E            	  2484: 	moveq #30,d2
02:00006872 7665            	  2485: 	moveq #'e',d3
02:00006874 4E4F            	  2486: 	trap #15
02:00006876 2049            	  2487: 	move.l a1,a0
02:00006878 6100F010        	  2488: 	bsr CRLF
02:0000687C 6000FE42        	  2489: 	bra Monitor
                            	  2490: 		
                            	  2491: ;-------------------------------------------------------------------------------
                            	  2492: ; CLOCK <n>
                            	  2493: ;    Set the clock register to n which will turn off or on clocks to the CPUs.
                            	  2494: ;-------------------------------------------------------------------------------
                            	  2495: 
                            	  2496: cmdClock:
02:00006880 6100037A        	  2497: 	bsr			ignBlanks
02:00006884 6100054E        	  2498: 	bsr			GetHexNumber
02:00006888 4A00            	  2499: 	tst.b		d0							; was there a number?
02:0000688A 6700FE34        	  2500: 	beq			Monitor
02:0000688E 00400004        	  2501: 	ori.w		#4,d0						; primary core's clock cannot be turned off
02:00006892 E159            	  2502: 	rol.w		#8,d1						; switch byte order
02:00006894 33C1FD0FFC02    	  2503: 	move.w	d1,RST_REG+2
02:0000689A 6000FE24        	  2504: 	bra			Monitor
                            	  2505: 
                            	  2506: ;-------------------------------------------------------------------------------
                            	  2507: ; RESET <n>
                            	  2508: ;    Reset the specified core. Resetting the core automatically turns on the 
                            	  2509: ; core's clock.
                            	  2510: ;-------------------------------------------------------------------------------
                            	  2511: 
                            	  2512: cmdReset:
02:0000689E 6100035C        	  2513: 	bsr			ignBlanks
02:000068A2 6100FE08        	  2514: 	bsr			FromScreen
02:000068A6 0C010032        	  2515: 	cmpi.b	#'2',d1					; check range
02:000068AA 6500FE14        	  2516: 	blo			Monitor
02:000068AE 0C010039        	  2517: 	cmpi.b	#'9',d1
02:000068B2 6200FE0C        	  2518: 	bhi			Monitor
02:000068B6 04010030        	  2519: 	subi.b	#'0',d1					; convert ascii to binary
02:000068BA E349            	  2520: 	lsl.w		#1,d1						; make into index
02:000068BC 43FA0012        	  2521: 	lea			tblPow2,a1
02:000068C0 32311000        	  2522: 	move.w	(a1,d1.w),d1
02:000068C4 E159            	  2523: 	rol.w		#8,d1						; reverse byte order
02:000068C6 33C1FD0FFC00    	  2524: 	move.w	d1,RST_REG
02:000068CC 6000FDF2        	  2525: 	bra			Monitor
                            	  2526: 
                            	  2527: tblPow2:
02:000068D0 0001            	  2528: 	dc.w		1
02:000068D2 0002            	  2529: 	dc.w		2
02:000068D4 0004            	  2530: 	dc.w		4
02:000068D6 0008            	  2531: 	dc.w		8
02:000068D8 0010            	  2532: 	dc.w		16
02:000068DA 0020            	  2533: 	dc.w		32
02:000068DC 0040            	  2534: 	dc.w		64
02:000068DE 0080            	  2535: 	dc.w		128
02:000068E0 0100            	  2536: 	dc.w		256
02:000068E2 0200            	  2537: 	dc.w		512
02:000068E4 0400            	  2538: 	dc.w		1024
02:000068E6 0800            	  2539: 	dc.w		2048
02:000068E8 1000            	  2540: 	dc.w		4096
02:000068EA 2000            	  2541: 	dc.w		8192
02:000068EC 4000            	  2542: 	dc.w		16384
02:000068EE 8000            	  2543: 	dc.w		32768
                            	  2544: 	even
                            	  2545: 	
                            	  2546: cmdHelp:
                            	  2547: DisplayHelp:
02:000068F0 43FA000A        	  2548: 	lea			HelpMsg,a1
02:000068F4 6100F25C        	  2549: 	bsr			DisplayString
02:000068F8 6000FDC6        	  2550: 	bra			Monitor
                            	  2551: 
                            	  2552: HelpMsg:
02:000068FC 3F203D2044697370	  2553: 	dc.b	"? = Display help",LF,CR
02:00006904 6C61792068656C70
02:0000690C 0A
02:0000690D 0D
02:0000690E 434F5245206E203D	  2554: 	dc.b  "CORE n = switch to core n, n = 2 to 9",LF,CR
02:00006916 2073776974636820
02:0000691E 746F20636F726520
02:00006926 6E2C206E203D2032
02:0000692E 20746F2039
02:00006933 0A
02:00006934 0D
02:00006935 5245534554206E20	  2555: 	dc.b  "RESET n = reset core n",LF,CR
02:0000693D 3D20726573657420
02:00006945 636F7265206E
02:0000694B 0A
02:0000694C 0D
02:0000694D 434C53203D20636C	  2556: 	dc.b	"CLS = clear screen",LF,CR
02:00006955 6561722073637265
02:0000695D 656E
02:0000695F 0A
02:00006960 0D
02:00006961 3A203D2045646974	  2557: 	dc.b	": = Edit memory bytes",LF,CR
02:00006969 206D656D6F727920
02:00006971 6279746573
02:00006976 0A
02:00006977 0D
02:00006978 4642203D2046696C	  2558: 	dc.b	"FB = Fill memory bytes, FW, FL",LF,CR
02:00006980 6C206D656D6F7279
02:00006988 2062797465732C20
02:00006990 46572C20464C
02:00006996 0A
02:00006997 0D
02:00006998 464D544B203D2072	  2559: 	dc.b	"FMTK = run Femtiki OS",LF,CR
02:000069A0 756E2046656D7469
02:000069A8 6B69204F53
02:000069AD 0A
02:000069AE 0D
02:000069AF 4C203D204C6F6164	  2560: 	dc.b	"L = Load S19 file",LF,CR
02:000069B7 205331392066696C
02:000069BF 65
02:000069C0 0A
02:000069C1 0D
02:000069C2 44203D2044756D70	  2561: 	dc.b	"D = Dump memory, DR = dump registers",LF,CR
02:000069CA 206D656D6F72792C
02:000069D2 204452203D206475
02:000069DA 6D70207265676973
02:000069E2 74657273
02:000069E6 0A
02:000069E7 0D
02:000069E8 4241203D20737461	  2562: 	dc.b	"BA = start tiny basic",LF,CR
02:000069F0 72742074696E7920
02:000069F8 6261736963
02:000069FD 0A
02:000069FE 0D
02:000069FF 4252203D20736574	  2563: 	dc.b  "BR = set breakpoint",LF,CR
02:00006A07 20627265616B706F
02:00006A0F 696E74
02:00006A12 0A
02:00006A13 0D
02:00006A14 4A203D204A756D70	  2564: 	dc.b	"J = Jump to code",LF,CR
02:00006A1C 20746F20636F6465
02:00006A24 0A
02:00006A25 0D
02:00006A26 53203D2073656E64	  2565: 	dc.b  "S = send to serial port",LF,CR
02:00006A2E 20746F2073657269
02:00006A36 616C20706F7274
02:00006A3D 0A
02:00006A3E 0D
02:00006A3F 54203D2063707520	  2566: 	dc.b	"T = cpu test program",LF,CR
02:00006A47 746573742070726F
02:00006A4F 6772616D
02:00006A53 0A
02:00006A54 0D
02:00006A55 5452414D203D2074	  2567: 	dc.b	"TRAM = test RAM",LF,CR,0
02:00006A5D 6573742052414D
02:00006A64 0A
02:00006A65 0D
02:00006A66 00
                            	  2568: 
                            	  2569: msgUnknownCmd:
02:00006A67 636F6D6D616E6420	  2570: 	dc.b	"command unknown",0
02:00006A6F 756E6B6E6F776E
02:00006A76 00
                            	  2571: 
                            	  2572: msgHello:
02:00006A77 0A              	  2573: 	dc.b	LF,CR,"Hello World!",LF,CR,0
02:00006A78 0D
02:00006A79 48656C6C6F20576F
02:00006A81 726C6421
02:00006A85 0A
02:00006A86 0D
02:00006A87 00
                            	  2574: 	even
                            	  2575: 
                            	  2576: ;------------------------------------------------------------------------------
                            	  2577: ; This routine borrowed from Gordo's Tiny Basic interpreter.
                            	  2578: ; Used to fetch a command line. (Not currently used).
                            	  2579: ;
                            	  2580: ; d0.b	- command prompt
                            	  2581: ;------------------------------------------------------------------------------
                            	  2582: 
                            	  2583: GetCmdLine:
02:00006A88 6100EE4A        	  2584: 		bsr		DisplayChar		; display prompt
02:00006A8C 103C0020        	  2585: 		move.b	#' ',d0
02:00006A90 6100EE42        	  2586: 		bsr		DisplayChar
02:00006A94 41F900040040    	  2587: 		lea		CmdBuf,a0
                            	  2588: .0001:
02:00006A9A 6100F4E4        	  2589: 		bsr		GetKey
02:00006A9E B03C0008        	  2590: 		cmp.b	#CTRLH,d0
02:00006AA2 6728            	  2591: 		beq.s	.0003
02:00006AA4 B03C0018        	  2592: 		cmp.b	#CTRLX,d0
02:00006AA8 6746            	  2593: 		beq.s	.0004
02:00006AAA B03C000D        	  2594: 		cmp.b	#CR,d0
02:00006AAE 6706            	  2595: 		beq.s	.0002
02:00006AB0 B03C0020        	  2596: 		cmp.b	#' ',d0
02:00006AB4 65E4            	  2597: 		bcs.s	.0001
                            	  2598: .0002:
02:00006AB6 1080            	  2599: 		move.b	d0,(a0)
02:00006AB8 5088            	  2600: 		lea			8(a0),a0
02:00006ABA 6100EE18        	  2601: 		bsr		DisplayChar
02:00006ABE B03C000D        	  2602: 		cmp.b	#CR,d0
02:00006AC2 675E            	  2603: 		beq		.0007
02:00006AC4 B1FC0004007F    	  2604: 		cmp.l	#CmdBufEnd-1,a0
02:00006ACA 65CE            	  2605: 		bcs.s	.0001
                            	  2606: .0003:
02:00006ACC 103C0008        	  2607: 		move.b	#CTRLH,d0
02:00006AD0 6100EE02        	  2608: 		bsr		DisplayChar
02:00006AD4 103C0020        	  2609: 		move.b	#' ',d0
02:00006AD8 6100EDFA        	  2610: 		bsr		DisplayChar
02:00006ADC B1FC00040040    	  2611: 		cmp.l	#CmdBuf,a0
02:00006AE2 63B6            	  2612: 		bls.s	.0001
02:00006AE4 103C0008        	  2613: 		move.b	#CTRLH,d0
02:00006AE8 6100EDEA        	  2614: 		bsr		DisplayChar
02:00006AEC 5388            	  2615: 		subq.l	#1,a0
02:00006AEE 60AA            	  2616: 		bra.s	.0001
                            	  2617: .0004:
02:00006AF0 2208            	  2618: 		move.l	a0,d1
02:00006AF2 92BC00040040    	  2619: 		sub.l	#CmdBuf,d1
02:00006AF8 671E            	  2620: 		beq.s	.0006
02:00006AFA 5341            	  2621: 		subq	#1,d1
                            	  2622: .0005:
02:00006AFC 103C0008        	  2623: 		move.b	#CTRLH,d0
02:00006B00 6100EDD2        	  2624: 		bsr		DisplayChar
02:00006B04 103C0020        	  2625: 		move.b	#' ',d0
02:00006B08 6100EDCA        	  2626: 		bsr		DisplayChar
02:00006B0C 103C0008        	  2627: 		move.b	#CTRLH,d0
02:00006B10 6100EDC2        	  2628: 		bsr		DisplayChar
02:00006B14 51C9FFE6        	  2629: 		dbra	d1,.0005
                            	  2630: .0006:
02:00006B18 41F900040040    	  2631: 		lea		CmdBuf,a0
02:00006B1E 6000FF7A        	  2632: 		bra		.0001
                            	  2633: .0007:
02:00006B22 103C000A        	  2634: 		move.b	#LF,d0
02:00006B26 6100EDAC        	  2635: 		bsr		DisplayChar
02:00006B2A 4E75            	  2636: 		rts
                            	  2637: 
                            	  2638: ;------------------------------------------------------------------------------
                            	  2639: ; S <address> <length>
                            	  2640: ; Send data buffer to serial port
                            	  2641: ; S 40000 40
                            	  2642: ;------------------------------------------------------------------------------
                            	  2643: 
                            	  2644: cmdSendSerial:
02:00006B2C 610000CE        	  2645: 	bsr			ignBlanks
02:00006B30 610002A2        	  2646: 	bsr			GetHexNumber
02:00006B34 6700FB8A        	  2647: 	beq			Monitor
02:00006B38 2C01            	  2648: 	move.l	d1,d6					; d6 points to buffer
02:00006B3A 610000C0        	  2649: 	bsr			ignBlanks
02:00006B3E 61000294        	  2650: 	bsr			GetHexNumber
02:00006B42 6602            	  2651: 	bne.s		.0003
02:00006B44 7210            	  2652: 	moveq		#16,d1
                            	  2653: .0003:
02:00006B46 2246            	  2654: 	move.l	d6,a1					; a1 points to buffer
02:00006B48 2401            	  2655: 	move.l	d1,d2					; d2 = count of bytes to send
02:00006B4A 6008            	  2656: 	bra.s		.0002					; enter loop at bottom
                            	  2657: .0001:
02:00006B4C 1219            	  2658: 	move.b	(a1)+,d1
02:00006B4E 303C0022        	  2659: 	move.w	#34,d0				; serial putchar
02:00006B52 4E4F            	  2660: 	trap		#15
                            	  2661: .0002:
02:00006B54 51CAFFF6        	  2662: 	dbra		d2,.0001
02:00006B58 6000FB66        	  2663: 	bra			Monitor
                            	  2664: 		
                            	  2665: ;------------------------------------------------------------------------------
                            	  2666: ; R <address> <length>
                            	  2667: ; Send data buffer to serial port
                            	  2668: ; R 10000 40
                            	  2669: ;------------------------------------------------------------------------------
                            	  2670: 
                            	  2671: cmdReceiveSerial:
02:00006B5C 6100009E        	  2672: 	bsr			ignBlanks
02:00006B60 61000272        	  2673: 	bsr			GetHexNumber
02:00006B64 6700FB5A        	  2674: 	beq			Monitor
02:00006B68 2C01            	  2675: 	move.l	d1,d6					; d6 points to buffer
02:00006B6A 61000090        	  2676: 	bsr			ignBlanks
02:00006B6E 61000264        	  2677: 	bsr			GetHexNumber
02:00006B72 6602            	  2678: 	bne.s		.0003
02:00006B74 7210            	  2679: 	moveq		#16,d1
                            	  2680: .0003:
02:00006B76 2246            	  2681: 	move.l	d6,a1					; a1 points to buffer
02:00006B78 2401            	  2682: 	move.l	d1,d2					; d2 = count of bytes to send
02:00006B7A 600C            	  2683: 	bra.s		.0002					; enter loop at bottom
                            	  2684: .0001:
02:00006B7C 303C0024        	  2685: 	move.w	#36,d0				; serial peek char
02:00006B80 4E4F            	  2686: 	trap		#15
02:00006B82 4A81            	  2687: 	tst.l		d1
02:00006B84 6BF6            	  2688: 	bmi.s		.0001
02:00006B86 12C1            	  2689: 	move.b	d1,(a1)+
                            	  2690: .0002:
02:00006B88 51CAFFF2        	  2691: 	dbra		d2,.0001
02:00006B8C 6000FB32        	  2692: 	bra			Monitor
                            	  2693: 		
                            	  2694: ;------------------------------------------------------------------------------
                            	  2695: ; Fill memory
                            	  2696: ;
                            	  2697: ; FB = fill bytes		FB 00000010 100 FF	; fill starting at 10 for 256 bytes
                            	  2698: ; FW = fill words
                            	  2699: ; FL = fill longs
                            	  2700: ; F = fill bytes
                            	  2701: ;------------------------------------------------------------------------------
                            	  2702: 
                            	  2703: cmdFillB:
02:00006B90 616A            	  2704: 	bsr			ignBlanks
02:00006B92 61000240        	  2705: 	bsr			GetHexNumber
02:00006B96 2241            	  2706: 	move.l	d1,a1					; a1 = start
02:00006B98 6162            	  2707: 	bsr			ignBlanks
02:00006B9A 61000238        	  2708: 	bsr			GetHexNumber
02:00006B9E 2601            	  2709: 	move.l	d1,d3					; d3 = count
02:00006BA0 6700FB1E        	  2710: 	beq			Monitor
02:00006BA4 6156            	  2711: 	bsr			ignBlanks
02:00006BA6 6100022C        	  2712: 	bsr			GetHexNumber	; fill value
                            	  2713: .fmem:
02:00006BAA 12C1            	  2714: 	move.b	d1,(a1)+
02:00006BAC 5383            	  2715: 	sub.l		#1,d3
02:00006BAE 66FA            	  2716: 	bne.s		.fmem
02:00006BB0 6000FB0E        	  2717: 	bra			Monitor
                            	  2718: 	
                            	  2719: cmdFillW:
02:00006BB4 6146            	  2720: 	bsr			ignBlanks
02:00006BB6 6100021C        	  2721: 	bsr			GetHexNumber
02:00006BBA 2241            	  2722: 	move.l	d1,a1					; a1 = start
02:00006BBC 613E            	  2723: 	bsr			ignBlanks
02:00006BBE 61000214        	  2724: 	bsr			GetHexNumber
02:00006BC2 2601            	  2725: 	move.l	d1,d3					; d3 = count
02:00006BC4 6700FAFA        	  2726: 	beq			Monitor
02:00006BC8 6132            	  2727: 	bsr			ignBlanks
02:00006BCA 61000208        	  2728: 	bsr			GetHexNumber	; fill value
                            	  2729: .fmem:
02:00006BCE 32C1            	  2730: 	move.w	d1,(a1)+
02:00006BD0 5383            	  2731: 	sub.l		#1,d3
02:00006BD2 66FA            	  2732: 	bne.s		.fmem
02:00006BD4 6000FAEA        	  2733: 	bra			Monitor
                            	  2734: 	
                            	  2735: cmdFillL:
02:00006BD8 6122            	  2736: 	bsr			ignBlanks
02:00006BDA 610001F8        	  2737: 	bsr			GetHexNumber
02:00006BDE 2241            	  2738: 	move.l	d1,a1					; a1 = start
02:00006BE0 611A            	  2739: 	bsr			ignBlanks
02:00006BE2 610001F0        	  2740: 	bsr			GetHexNumber
02:00006BE6 2601            	  2741: 	move.l	d1,d3					; d3 = count
02:00006BE8 6700FAD6        	  2742: 	beq			Monitor
02:00006BEC 610E            	  2743: 	bsr			ignBlanks
02:00006BEE 610001E4        	  2744: 	bsr			GetHexNumber	; fill value
                            	  2745: .fmem:
02:00006BF2 22C1            	  2746: 	move.l	d1,(a1)+
02:00006BF4 5383            	  2747: 	sub.l		#1,d3
02:00006BF6 66FA            	  2748: 	bne.s		.fmem
02:00006BF8 6000FAC6        	  2749: 	bra			Monitor
                            	  2750: 	
                            	  2751: ;------------------------------------------------------------------------------
                            	  2752: ; Modifies:
                            	  2753: ;	a0	- text pointer
                            	  2754: ;------------------------------------------------------------------------------
                            	  2755: 
                            	  2756: ignBlanks:
02:00006BFC 2F01            	  2757: 	move.l	d1,-(a7)
                            	  2758: .0001:
02:00006BFE 6100FAAC        	  2759: 	bsr			FromScreen
02:00006C02 0C010020        	  2760: 	cmpi.b	#' ',d1
02:00006C06 67F6            	  2761: 	beq.s		.0001
02:00006C08 5188            	  2762: 	lea			-8(a0),a0
02:00006C0A 221F            	  2763: 	move.l	(a7)+,d1
02:00006C0C 4E75            	  2764: 	rts
                            	  2765: 
                            	  2766: ;------------------------------------------------------------------------------
                            	  2767: ; Edit memory byte.
                            	  2768: ;    Bytes are built into long words in case the memory is only longword
                            	  2769: ; accessible.
                            	  2770: ;------------------------------------------------------------------------------
                            	  2771: 
                            	  2772: cmdEditMemory:
02:00006C0E 61EC            	  2773: 	bsr			ignBlanks
02:00006C10 610001C2        	  2774: 	bsr			GetHexNumber
02:00006C14 2241            	  2775: 	move.l	d1,a1
                            	  2776: edtmem1:
02:00006C16 7400            	  2777: 	clr.l		d2
02:00006C18 61E2            	  2778: 	bsr			ignBlanks
02:00006C1A 610001B8        	  2779: 	bsr			GetHexNumber
02:00006C1E 1401            	  2780: 	move.b	d1,d2
                            	  2781: ;	move.b	d1,(a1)+
02:00006C20 61DA            	  2782: 	bsr			ignBlanks
02:00006C22 610001B0        	  2783: 	bsr			GetHexNumber
02:00006C26 E18A            	  2784: 	lsl.l		#8,d2
02:00006C28 1401            	  2785: 	move.b	d1,d2
                            	  2786: ;	move.b	d1,(a1)+
02:00006C2A 61D0            	  2787: 	bsr			ignBlanks
02:00006C2C 610001A6        	  2788: 	bsr			GetHexNumber
02:00006C30 E18A            	  2789: 	lsl.l		#8,d2
02:00006C32 1401            	  2790: 	move.b	d1,d2
                            	  2791: ;	move.b	d1,(a1)+
02:00006C34 61C6            	  2792: 	bsr			ignBlanks
02:00006C36 6100019C        	  2793: 	bsr			GetHexNumber
02:00006C3A E18A            	  2794: 	lsl.l		#8,d2
02:00006C3C 1401            	  2795: 	move.b	d1,d2
02:00006C3E 22C2            	  2796: 	move.l	d2,(a1)+
                            	  2797: ;	move.b	d1,(a1)+
02:00006C40 7400            	  2798: 	clr.l		d2
02:00006C42 61B8            	  2799: 	bsr			ignBlanks
02:00006C44 6100018E        	  2800: 	bsr			GetHexNumber
02:00006C48 1401            	  2801: 	move.b	d1,d2
                            	  2802: ;	move.b	d1,(a1)+
02:00006C4A 61B0            	  2803: 	bsr			ignBlanks
02:00006C4C 61000186        	  2804: 	bsr			GetHexNumber
02:00006C50 E18A            	  2805: 	lsl.l		#8,d2
02:00006C52 1401            	  2806: 	move.b	d1,d2
                            	  2807: ;	move.b	d1,(a1)+
02:00006C54 61A6            	  2808: 	bsr			ignBlanks
02:00006C56 6100017C        	  2809: 	bsr			GetHexNumber
02:00006C5A E18A            	  2810: 	lsl.l		#8,d2
02:00006C5C 1401            	  2811: 	move.b	d1,d2
                            	  2812: ;	move.b	d1,(a1)+
02:00006C5E 619C            	  2813: 	bsr			ignBlanks
02:00006C60 61000172        	  2814: 	bsr			GetHexNumber
02:00006C64 E18A            	  2815: 	lsl.l		#8,d2
02:00006C66 1401            	  2816: 	move.b	d1,d2
                            	  2817: ;	move.b	d1,(a1)+
02:00006C68 22C2            	  2818: 	move.l	d2,(a1)+
02:00006C6A 6000FA54        	  2819: 	bra			Monitor
                            	  2820: 
                            	  2821: ;------------------------------------------------------------------------------
                            	  2822: ; Execute code at the specified address.
                            	  2823: ;------------------------------------------------------------------------------
                            	  2824: 
                            	  2825: cmdJump:
                            	  2826: ExecuteCode:
02:00006C6E 618C            	  2827: 	bsr			ignBlanks
02:00006C70 61000162        	  2828: 	bsr			GetHexNumber
02:00006C74 2041            	  2829: 	move.l	d1,a0
02:00006C76 4E90            	  2830: 	jsr			(a0)
02:00006C78 6000FA46        	  2831: 	bra     Monitor
                            	  2832: 
                            	  2833: ;------------------------------------------------------------------------------
                            	  2834: ; Do a memory dump of the requested location.
                            	  2835: ; D 0800 0850
                            	  2836: ;------------------------------------------------------------------------------
                            	  2837: 
                            	  2838: cmdDumpMemory:
02:00006C7C 6100FF7E        	  2839: 	bsr			ignBlanks
02:00006C80 61000152        	  2840: 	bsr			GetHexNumber
02:00006C84 6700FA3A        	  2841: 	beq			Monitor			; was there a number ? no, other garbage, just ignore
02:00006C88 2601            	  2842: 	move.l	d1,d3				; save off start of range
02:00006C8A 6100FF70        	  2843: 	bsr			ignBlanks
02:00006C8E 61000144        	  2844: 	bsr			GetHexNumber
02:00006C92 6608            	  2845: 	bne.s		DumpMem1
02:00006C94 2203            	  2846: 	move.l	d3,d1
02:00006C96 068100000040    	  2847: 	addi.l	#64,d1			; no end specified, just dump 64 bytes
                            	  2848: DumpMem1:
02:00006C9C 2043            	  2849: 	move.l	d3,a0
02:00006C9E 2241            	  2850: 	move.l	d1,a1
02:00006CA0 6100EBE8        	  2851: 	bsr			CRLF
                            	  2852: .0001:
02:00006CA4 B3C8            	  2853: 	cmpa.l	a0,a1
02:00006CA6 6300FA18        	  2854: 	bls			Monitor
02:00006CAA 6102            	  2855: 	bsr			DisplayMem
02:00006CAC 60F6            	  2856: 	bra.s		.0001
                            	  2857: 
                            	  2858: ;------------------------------------------------------------------------------
                            	  2859: ; Display memory dump in a format suitable for edit.
                            	  2860: ;
                            	  2861: ;	:12345678 00 11 22 33 44 55 66 77  "........"
                            	  2862: ;
                            	  2863: ; Modifies:
                            	  2864: ;		d1,d2,a0
                            	  2865: ;------------------------------------------------------------------------------
                            	  2866: 
                            	  2867: DisplayMem:
02:00006CAE 123C003A        	  2868: 	move.b	#':',d1
02:00006CB2 6100EC20        	  2869: 	bsr			DisplayChar
02:00006CB6 2208            	  2870: 	move.l	a0,d1
02:00006CB8 610006FA        	  2871: 	bsr			DisplayTetra
02:00006CBC 7407            	  2872: 	moveq		#7,d2
                            	  2873: dspmem1:
02:00006CBE 123C0020        	  2874: 	move.b	#' ',d1
02:00006CC2 6100EC10        	  2875: 	bsr			DisplayChar
02:00006CC6 1218            	  2876: 	move.b	(a0)+,d1
02:00006CC8 610006F6        	  2877: 	bsr			DisplayByte
02:00006CCC 51CAFFF0        	  2878: 	dbra		d2,dspmem1
02:00006CD0 610006C8        	  2879: 	bsr			DisplayTwoSpaces
02:00006CD4 123C0022        	  2880: 	move.b	#34,d1
02:00006CD8 6100EBFA        	  2881: 	bsr			DisplayChar
02:00006CDC 5188            	  2882: 	lea			-8(a0),a0
02:00006CDE 7407            	  2883: 	moveq		#7,d2
                            	  2884: .0002:	
02:00006CE0 1218            	  2885: 	move.b	(a0)+,d1
02:00006CE2 B23C0020        	  2886: 	cmp.b		#' ',d1
02:00006CE6 6506            	  2887: 	blo.s		.0003
02:00006CE8 B23C007F        	  2888: 	cmp.b		#127,d1
02:00006CEC 6304            	  2889: 	bls.s		.0001
                            	  2890: .0003:
02:00006CEE 123C002E        	  2891: 	move.b	#'.',d1
                            	  2892: .0001:
02:00006CF2 6100EBE0        	  2893: 	bsr			DisplayChar
02:00006CF6 51CAFFE8        	  2894: 	dbra		d2,.0002
02:00006CFA 123C0022        	  2895: 	move.b	#34,d1
02:00006CFE 6100EBD4        	  2896: 	bsr			DisplayChar
02:00006D02 6100F2B4        	  2897: 	bsr			CheckForCtrlC
02:00006D06 6000EB82        	  2898: 	bra			CRLF
                            	  2899: 
                            	  2900: ;------------------------------------------------------------------------------
                            	  2901: ; Dump Registers
                            	  2902: ;    The dump is in a format that allows the register value to be edited.
                            	  2903: ;
                            	  2904: ; RegD0 12345678
                            	  2905: ; RegD1 77777777
                            	  2906: ;	... etc
                            	  2907: ;------------------------------------------------------------------------------
                            	  2908: 
                            	  2909: cmdDumpRegs:
02:00006D0A 6100EB7E        	  2910: 	bsr			CRLF
02:00006D0E 303C000F        	  2911: 	move.w	#15,d0					; number of registers-1
02:00006D12 41FA007A        	  2912: 	lea			msg_reglist,a0	;
02:00006D16 43FA0072        	  2913: 	lea			msg_regs,a1
02:00006D1A 45F900040100    	  2914: 	lea			Regsave,a2			; a2 points to register save area
                            	  2915: .0001:
02:00006D20 6100EE30        	  2916: 	bsr			DisplayString
02:00006D24 1218            	  2917: 	move.b	(a0)+,d1
02:00006D26 6100EBAC        	  2918: 	bsr			DisplayChar
02:00006D2A 1218            	  2919: 	move.b	(a0)+,d1
02:00006D2C 6100EBA6        	  2920: 	bsr			DisplayChar
02:00006D30 6100067A        	  2921: 	bsr			DisplaySpace
02:00006D34 221A            	  2922: 	move.l	(a2)+,d1
02:00006D36 6100067C        	  2923: 	bsr			DisplayTetra
02:00006D3A 6100EB4E        	  2924: 	bsr			CRLF
02:00006D3E 51C8FFE0        	  2925: 	dbra		d0,.0001
02:00006D42 6100EE0E        	  2926: 	bsr			DisplayString
02:00006D46 1218            	  2927: 	move.b	(a0)+,d1
02:00006D48 6100EB8A        	  2928: 	bsr			DisplayChar
02:00006D4C 1218            	  2929: 	move.b	(a0)+,d1
02:00006D4E 6100EB84        	  2930: 	bsr			DisplayChar
02:00006D52 61000658        	  2931: 	bsr			DisplaySpace
02:00006D56 223900040144    	  2932: 	move.l	Regsave+$44,d1
02:00006D5C 61000656        	  2933: 	bsr			DisplayTetra
02:00006D60 6100EB28        	  2934: 	bsr			CRLF
02:00006D64 6100EDEC        	  2935: 	bsr			DisplayString
02:00006D68 1218            	  2936: 	move.b	(a0)+,d1
02:00006D6A 6100EB68        	  2937: 	bsr			DisplayChar
02:00006D6E 1218            	  2938: 	move.b	(a0)+,d1
02:00006D70 6100EB62        	  2939: 	bsr			DisplayChar
02:00006D74 61000636        	  2940: 	bsr			DisplaySpace
02:00006D78 323900040140    	  2941: 	move.w	Regsave+$40,d1
02:00006D7E 6100063A        	  2942: 	bsr			DisplayWyde
02:00006D82 6100EB06        	  2943: 	bsr			CRLF
02:00006D86 6000F938        	  2944: 	bra			Monitor
                            	  2945: 
                            	  2946: msg_regs:
02:00006D8A 526567          	  2947: 	dc.b	"Reg",0
02:00006D8D 00
                            	  2948: msg_reglist:
02:00006D8E 4430443144324433	  2949: 	dc.b	"D0D1D2D3D4D5D6D7A0A1A2A3A4A5A6A7PCSR",0
02:00006D96 4434443544364437
02:00006D9E 4130413141324133
02:00006DA6 4134413541364137
02:00006DAE 50435352
02:00006DB2 00
                            	  2950: 
                            	  2951: 	align	1
                            	  2952: 
                            	  2953: ;------------------------------------------------------------------------------
                            	  2954: ;------------------------------------------------------------------------------
                            	  2955: 
                            	  2956: cmdTestSerialReceive:
                            	  2957: .0002:
02:00006DB4 7024            	  2958: 	moveq		#36,d0				; serial get char from buffer
02:00006DB6 4E4F            	  2959: 	trap		#15
                            	  2960: ;	bsr			SerialPeekCharDirect
02:00006DB8 4A41            	  2961: 	tst.w		d1
02:00006DBA 6B0A            	  2962: 	bmi.s		.0001
02:00006DBC 0C01001A        	  2963: 	cmpi.b	#CTRLZ,d1
02:00006DC0 670A            	  2964: 	beq			.0003
02:00006DC2 6100EB10        	  2965: 	bsr			DisplayChar
                            	  2966: .0001:	
02:00006DC6 6100F1F0        	  2967: 	bsr			CheckForCtrlC
02:00006DCA 60E8            	  2968: 	bra			.0002
                            	  2969: .0003:
02:00006DCC 6100EFF2        	  2970: 	bsr			_KeybdInit
02:00006DD0 6000F8EE        	  2971: 	bra			Monitor
                            	  2972: 
                            	  2973: ;------------------------------------------------------------------------------
                            	  2974: ; Get a hexidecimal number. Maximum of eight digits.
                            	  2975: ;
                            	  2976: ; Returns:
                            	  2977: ;		d0 = number of digits
                            	  2978: ;		d1 = value of number
                            	  2979: ;		zf = number of digits == 0
                            	  2980: ;------------------------------------------------------------------------------
                            	  2981: 
                            	  2982: GetHexNumber:
02:00006DD4 2F02            	  2983: 	move.l	d2,-(a7)
02:00006DD6 7400            	  2984: 	clr.l		d2
02:00006DD8 7000            	  2985: 	moveq		#0,d0
                            	  2986: .0002
02:00006DDA 6100F8D0        	  2987: 	bsr			FromScreen
02:00006DDE 61000580        	  2988: 	bsr			AsciiToHexNybble
02:00006DE2 0C0100FF        	  2989: 	cmpi.b	#$ff,d1
02:00006DE6 6712            	  2990: 	beq.s		.0001
02:00006DE8 E98A            	  2991: 	lsl.l		#4,d2
02:00006DEA 02810000000F    	  2992: 	andi.l	#$0f,d1
02:00006DF0 8481            	  2993: 	or.l		d1,d2
02:00006DF2 5240            	  2994: 	addq		#1,d0
02:00006DF4 0C000008        	  2995: 	cmpi.b	#8,d0
02:00006DF8 65E0            	  2996: 	blo.s		.0002
                            	  2997: .0001
02:00006DFA 2202            	  2998: 	move.l	d2,d1
02:00006DFC 241F            	  2999: 	move.l	(a7)+,d2
02:00006DFE 4A00            	  3000: 	tst.b		d0
02:00006E00 4E75            	  3001: 	rts	
                            	  3002: 
                            	  3003: GetDecNumber:
02:00006E02 48E73000        	  3004: 	movem.l d2/d3,-(a7)
02:00006E06 7400            	  3005: 	clr.l d2
02:00006E08 7000            	  3006: 	clr.l d0
                            	  3007: .0002
02:00006E0A 6100F8A0        	  3008: 	bsr FromScreen					; grab a character off the screen
02:00006E0E 61000550        	  3009: 	bsr	AsciiToHexNybble		; convert to an ascii nybble
02:00006E12 0C0100FF        	  3010: 	cmpi.b #$ff,d1
02:00006E16 6718            	  3011: 	beq.s	.0001
02:00006E18 02810000000F    	  3012: 	andi.l #$0F,d1					; d1 = 0 to 9
02:00006E1E 2602            	  3013: 	move.l d2,d3						; d3 = current number
02:00006E20 D683            	  3014: 	add.l d3,d3							; d3*2
02:00006E22 E78A            	  3015: 	lsl.l #3,d2							; current number * 8
02:00006E24 D483            	  3016: 	add.l d3,d2							; current number * 10
02:00006E26 D481            	  3017: 	add.l d1,d2							; add in new digit
02:00006E28 5240            	  3018: 	addq #1,d0							; increment number of digits
02:00006E2A 0C000009        	  3019: 	cmpi.b #9,d0						; make sure 9 or fewer
02:00006E2E 65DA            	  3020: 	blo .0002
                            	  3021: .0001
02:00006E30 2202            	  3022: 	move.l d2,d1						; return number in d1
02:00006E32 4CDF000C        	  3023: 	movem.l (a7)+,d2/d3
02:00006E36 4A00            	  3024: 	tst.b d0
02:00006E38 4E75            	  3025: 	rts
                            	  3026: 	
                            	  3027: 	include "FloatToString.asm"

Source: "FloatToString.asm"
                            	     1: 	code
                            	     2: ;==============================================================================
                            	     3: ; Decimal-Floating point to string conversion routine.
                            	     4: ;
                            	     5: ; Modifies
                            	     6: ;		_fpWork work area
                            	     7: ; Register Usage:
                            	     8: ; 	fp0 = input decimal-float to convert
                            	     9: ;		fp1 = constant holder, 1.0, 10.0
                            	    10: ;		fp2 = 1.0e<fp0 exponent> value for conversion
                            	    11: ;		fp3 = holds digit value during significand conversion
                            	    12: ; 	a0 = pointer to string buffer, updated to point to NULL at end of string
                            	    13: ;		a1 = pointer to "Nan" or "Inf" message string
                            	    14: ;		d0 = temporary
                            	    15: ;		d1 = digit value during exponent, significand conversion
                            	    16: ; 	d6 = exponent
                            	    17: ;==============================================================================
                            	    18: 	align 4
02:00006E40 25FF0000        	    19: _dfOne	dc.l $25ff0000,$00000000,$00000000
02:00006E44 00000000
02:00006E48 00000000
02:00006E4C 2600C000        	    20: _dfTen	dc.l $2600C000,$00000000,$00000000
02:00006E50 00000000
02:00006E54 00000000
02:00006E58 2606DDFA        	    21: _dfMil  dc.l $2606DDFA,$1C000000,$00000000
02:00006E5C 1C000000
02:00006E60 00000000
                            	    22: 
02:00006E64 4E614E          	    23: _msgNan	dc.b "NaN",0
02:00006E67 00
02:00006E68 496E66          	    24: _msgInf dc.b "Inf",0
02:00006E6B 00
                            	    25: 	even
                            	    26: 
                            	    27: ;------------------------------------------------------------------------------
                            	    28: ; Check for the special Nan and infinity values. Output the appropriate string.
                            	    29: ;
                            	    30: ; Modifies
                            	    31: ;		_fpWork area
                            	    32: ;		a0
                            	    33: ; Parameters:
                            	    34: ;		fp0 = dbl
                            	    35: ;------------------------------------------------------------------------------
                            	    36: 
                            	    37: _CheckNan:
02:00006E6C 4E52FFF4        	    38: 	link a2,#-12
02:00006E70 48D70201        	    39: 	movem.l d0/a1,(sp)
02:00006E74 2F79000400980008	    40: 	move.l _canary,8(sp)
02:00006E7C F239680000040600	    41: 	fmove.x fp0,_fpWork
02:00006E84 103900040600    	    42: 	move.b _fpWork,d0				; get sign+combo
02:00006E8A 0200007C        	    43: 	andi.b #$7C,d0					; mask for combo bits
02:00006E8E 0C00007C        	    44: 	cmpi.b #$7C,d0					; is it the Nan combo?
02:00006E92 6606            	    45: 	bne .notNan
02:00006E94 43FAFFCE        	    46: 	lea _msgNan,a1					; output "Nan"
02:00006E98 600A            	    47: 	bra .outStr
                            	    48: .notNan
02:00006E9A 0C000078        	    49: 	cmpi.b #$78,d0					; is it infinity combo?
02:00006E9E 661E            	    50: 	bne .notInf
02:00006EA0 43FAFFC6        	    51: 	lea _msgInf,a1
                            	    52: .outStr
02:00006EA4 10D9            	    53: 	move.b (a1)+,(a0)+			; output "Inf"
02:00006EA6 10D9            	    54: 	move.b (a1)+,(a0)+
02:00006EA8 10D9            	    55: 	move.b (a1)+,(a0)+
02:00006EAA 4210            	    56: 	clr.b (a0)
02:00006EAC 4CD70201        	    57: 	movem.l (sp),d0/a1
02:00006EB0 A2AF00030008    	    58: 	cchk 8(sp)
02:00006EB6 4E5A            	    59: 	unlk a2
02:00006EB8 003C0001        	    60: 	ori #1,ccr							; set carry and return
02:00006EBC 4E75            	    61: 	rts
                            	    62: .notInf
02:00006EBE 4CD70201        	    63: 	movem.l (sp),d0/a1
02:00006EC2 A2AF00030008    	    64: 	cchk 8(sp)
02:00006EC8 4E5A            	    65: 	unlk a2
02:00006ECA 023C00FE        	    66: 	andi #$FE,ccr						; clear carry and return
02:00006ECE 4E75            	    67: 	rts
                            	    68: 
                            	    69: ;------------------------------------------------------------------------------
                            	    70: ; Check for a zero value. Output a single "0" if zero,
                            	    71: ;
                            	    72: ; Modifies:
                            	    73: ;		a0
                            	    74: ; Parameters:
                            	    75: ;		fp0 = dbl
                            	    76: ;------------------------------------------------------------------------------
                            	    77: 
                            	    78: _CheckZero:
02:00006ED0 F200003A        	    79: 	ftst fp0								; check if number is zero
02:00006ED4 F28E000E        	    80: 	fbne .0003
02:00006ED8 10FC0030        	    81: 	move.b #'0',(a0)+				; if zero output "0"
02:00006EDC 4210            	    82: 	clr.b (a0)
02:00006EDE 003C0004        	    83: 	ori #4,ccr							; set zf
02:00006EE2 4E75            	    84: 	rts
                            	    85: .0003
02:00006EE4 023C00FB        	    86: 	andi #$FB,ccr						; clear zf
02:00006EE8 4E75            	    87: 	rts
                            	    88: 
                            	    89: ;------------------------------------------------------------------------------
                            	    90: ; Check for a negative number. This includes Nans and Infinities. Output a "-"
                            	    91: ; if negative.
                            	    92: ;
                            	    93: ;	Modifies
                            	    94: ;		a0
                            	    95: ; Parameters:
                            	    96: ;		fp0 = dbl
                            	    97: ;------------------------------------------------------------------------------
                            	    98: 
                            	    99: _CheckNegative:
02:00006EEA F200003A        	   100: 	ftst fp0								; is number negative?
02:00006EEE F293000A        	   101: 	fbge .0002
02:00006EF2 10FC002D        	   102: 	move.b #'-',(a0)+				; yes, output '-'
02:00006EF6 F200001A        	   103: 	fneg fp0								; make fp0 positive
                            	   104: .0002
02:00006EFA 4E75            	   105: 	rts
                            	   106: 
                            	   107: ;------------------------------------------------------------------------------
                            	   108: ; Make the input value larger so that digits may appear before the decimal
                            	   109: ; point.
                            	   110: ;
                            	   111: ; Modifies:
                            	   112: ;		fp0,fp1,d6
                            	   113: ; Parameters:
                            	   114: ;		fp0 = dbl
                            	   115: ;------------------------------------------------------------------------------
                            	   116: 
                            	   117: ;	if (dbl < 1.0) {
                            	   118: ;		while (dbl < 1.0) {
                            	   119: ;			dbl *= 1000000.0;
                            	   120: ;			exp -= 6;  
                            	   121: ;		}
                            	   122: ;	}
                            	   123: 
                            	   124: _MakeBig:
02:00006EFC F23C50800001    	   125: 	fmove.w #1,fp1
                            	   126: .0002
02:00006F02 F2000438        	   127: 	fcmp fp1,fp0						; is fp0 > 1?
02:00006F06 F293000E        	   128: 	fbge .0001							; yes, return
02:00006F0A F23C402600000006	   129: 	fscale.l #6,fp0					; multiply fp0 by a million
02:00006F12 5D46            	   130: 	subi.w #6,d6						; decrement exponent by six
02:00006F14 60EC            	   131: 	bra .0002								; keep trying until number is > 1
                            	   132: .0001
02:00006F16 4E75            	   133: 	rts
                            	   134: 	
                            	   135: ;------------------------------------------------------------------------------
                            	   136: ;	Create a number dbl2 on the same order of magnitude as dbl, but
                            	   137: ;	less than dbl. The number will be 1.0e<dbl's exponent>
                            	   138: ;
                            	   139: ; Modifies:
                            	   140: ;		d6,fp2
                            	   141: ; Parameters:
                            	   142: ;		fp0 = dbl
                            	   143: ;------------------------------------------------------------------------------
                            	   144: 
                            	   145: ;	// The following is similar to using log10() and pow() functions.
                            	   146: ;	// Now dbl is >= 1.0
                            	   147: ;	// Create a number dbl2 on the same order of magnitude as dbl, but
                            	   148: ;	// less than dbl.
                            	   149: ;	dbl2 = 1.0;
                            	   150: ;	dbla = dbl2;
                            	   151: ;	if (dbl > dbl2) {	// dbl > 1.0 ?
                            	   152: ;		while (dbl2 <= dbl) {
                            	   153: ;			dbla = dbl2;
                            	   154: ;			dbl2 *= 10.0;	// increase power of 10
                            	   155: ;			exp++;
                            	   156: ;		}
                            	   157: ;		// The above loop goes one too far, we want the last value less
                            	   158: ;		// than dbl.
                            	   159: ;		dbl2 = dbla;
                            	   160: ;		exp--;
                            	   161: ;	}
                            	   162: 
                            	   163: _LessThanDbl:
02:00006F18 F23C51000001    	   164: 	fmove.w #1,fp2			; setup fp2 = 1
02:00006F1E F2000838        	   165: 	fcmp fp2,fp0				; if (dbl > dbl2)
02:00006F22 F295001E        	   166: 	fble .0004
                            	   167: .0006
02:00006F26 F2000138        	   168: 	fcmp fp0,fp2				; while (dbl2 <= dbl)
02:00006F2A F292000C        	   169: 	fbgt .0005
02:00006F2E F23C51260001    	   170: 	fscale.w #1,fp2			; dbl2 *= 10 (increase exponent by one)
02:00006F34 5246            	   171: 	addi.w #1,d6				; exp++
02:00006F36 60EE            	   172: 	bra .0006
                            	   173: .0005
02:00006F38 F23C4126FFFFFFFF	   174: 	fscale.l #-1,fp2		; dbl2 /= 10 (decrease exponent by one)
02:00006F40 5346            	   175: 	subi.w #1,d6				; exp--;
                            	   176: .0004	
                            	   177: ;	fmove.x fp0,_fpWork	; debugging
                            	   178: ;	fmove.x fp2,_fpWork+12
02:00006F42 4E75            	   179: 	rts
                            	   180: 
                            	   181: ;------------------------------------------------------------------------------
                            	   182: ; Compute the number of digits before the decimal point.
                            	   183: ;
                            	   184: ; Modifies:
                            	   185: ;		d0,d6,_digits_before_decpt
                            	   186: ; Parameters:
                            	   187: ;		d6 = exponent
                            	   188: ;------------------------------------------------------------------------------
                            	   189: 
                            	   190: ; if (exp >= 0 && exp < 6) {
                            	   191: ;   digits_before_decpt = exp+1;
                            	   192: ;		exp = 0;
                            	   193: ;	}
                            	   194: ;	else if (exp >= -7)
                            	   195: ;		digits_before_decpt = 1;
                            	   196: ;	else
                            	   197: ;		digits_before_decpt = -1;
                            	   198: 
                            	   199: _ComputeDigitsBeforeDecpt:
02:00006F44 2F00            	   200: 	move.l d0,-(a7)
02:00006F46 4A46            	   201: 	tst.w d6
02:00006F48 6B16            	   202: 	bmi .0007
02:00006F4A 0C460006        	   203: 	cmpi.w #6,d6
02:00006F4E 6C10            	   204: 	bge .0007
02:00006F50 3006            	   205: 	move.w d6,d0
02:00006F52 5240            	   206: 	addi.w #1,d0
02:00006F54 33C000040510    	   207: 	move.w d0,_digits_before_decpt	
02:00006F5A 4246            	   208: 	clr.w d6
02:00006F5C 201F            	   209: 	move.l (a7)+,d0
02:00006F5E 4E75            	   210: 	rts
                            	   211: .0007
02:00006F60 0C46FFF9        	   212: 	cmpi.w #-7,d6
02:00006F64 6D0C            	   213: 	blt .0009
02:00006F66 33FC000100040510	   214: 	move.w #1,_digits_before_decpt
02:00006F6E 201F            	   215: 	move.l (a7)+,d0
02:00006F70 4E75            	   216: 	rts
                            	   217: .0009
02:00006F72 33FCFFFF00040510	   218: 	move.w #-1,_digits_before_decpt
02:00006F7A 201F            	   219: 	move.l (a7)+,d0
02:00006F7C 4E75            	   220: 	rts
                            	   221: 
                            	   222: ;------------------------------------------------------------------------------
                            	   223: ;	Spit out a leading zero before the decimal point for a small number.
                            	   224: ;
                            	   225: ; Modifies:
                            	   226: ;		a0
                            	   227: ; Parameters:
                            	   228: ;		d6 = exponent
                            	   229: ;------------------------------------------------------------------------------
                            	   230: 
                            	   231: ;  if (exp < -7) {
                            	   232: ;		 buf[ndx] = '0';
                            	   233: ;		 ndx++;
                            	   234: ;    buf[ndx] = '.';
                            	   235: ;    ndx++;
                            	   236: ;  }
                            	   237: 
                            	   238: _LeadingZero:
02:00006F7E 0C46FFF9        	   239: 	cmpi.w #-7,d6
02:00006F82 6C08            	   240: 	bge .0010
02:00006F84 10FC0030        	   241: 	move.b #'0',(a0)+
02:00006F88 10FC002E        	   242: 	move.b #'.',(a0)+
                            	   243: .0010
02:00006F8C 4E75            	   244: 	rts
                            	   245: 
                            	   246: ;------------------------------------------------------------------------------
                            	   247: ; Extract the digits of the significand.
                            	   248: ;
                            	   249: ; Modifies:
                            	   250: ;		_precision variable
                            	   251: ; Register Usage
                            	   252: ;		d0 = counter
                            	   253: ;		d1 = digit
                            	   254: ;		fp0 = dbl
                            	   255: ;		fp2 = dbl2
                            	   256: ;		fp3 = digit as decimal float
                            	   257: ;		fp7 = dbla
                            	   258: ; Parameters:
                            	   259: ;		fp0, fp2
                            	   260: ;------------------------------------------------------------------------------
                            	   261: 
                            	   262: ;	// Now loop processing one digit at a time.
                            	   263: ;  for (nn = 0; nn < 25 && precision > 0; nn++) {
                            	   264: ;    digit = 0;
                            	   265: ;		dbla = dbl;
                            	   266: ;		// dbl is on the same order of magnitude as dbl2 so
                            	   267: ;		// a repeated subtract can be used to find the digit.
                            	   268: ;    while (dbl >= dbl2) {
                            	   269: ;      dbl -= dbl2;
                            	   270: ;      digit++;
                            	   271: ;    }
                            	   272: ;    buf[ndx] = digit + '0';
                            	   273: ;		// Now go back and perform just a single subtract and
                            	   274: ;		// a multiply to find out how much to reduce dbl by.
                            	   275: ;		// This should improve the accuracy
                            	   276: ;		if (digit > 2)
                            	   277: ;			dbl = dbla - dbl2 * digit;
                            	   278: ;    ndx++;
                            	   279: ;    digits_before_decpt--;
                            	   280: ;    if (digits_before_decpt==0) {
                            	   281: ;			buf[ndx] = '.';
                            	   282: ;			ndx++;
                            	   283: ;    }
                            	   284: ;    else if (digits_before_decpt < 0)
                            	   285: ;      precision--;
                            	   286: ;		// Shift the next digit to be tested into position.
                            	   287: ;    dbl *= 10.0;
                            	   288: ;  }
                            	   289: 	
                            	   290: _SpitOutDigits:
02:00006F8E 4E52FFE8        	   291: 	link a2,#-24
02:00006F92 2F79000400980014	   292: 	move.l _canary,20(sp)
02:00006F9A F2176B80        	   293: 	fmove.x fp7,(sp)
02:00006F9E 48EF0003000C    	   294: 	movem.l d0/d1,12(sp)
02:00006FA4 303C0018        	   295: 	move.w #24,d0			; d0 = nn
                            	   296: .0017	
02:00006FA8 4AB900040514    	   297: 	tst.l _precision
02:00006FAE 6F46            	   298: 	ble .0011
02:00006FB0 7200            	   299: 	moveq #0,d1				; digit = 0
02:00006FB2 F2000380        	   300: 	fmove fp0,fp7			; dbla = dbl
                            	   301: .0013
02:00006FB6 F2000838        	   302: 	fcmp fp2,fp0
02:00006FBA F294000A        	   303: 	fblt .0012
02:00006FBE F2000828        	   304: 	fsub fp2,fp0			; dbl -= dbl2
02:00006FC2 5201            	   305: 	addi.b #1,d1			; digit++
02:00006FC4 60F0            	   306: 	bra .0013
                            	   307: .0012
02:00006FC6 06010030        	   308: 	addi.b #'0',d1		; convert digit to ascii
02:00006FCA 10C1            	   309: 	move.b d1,(a0)+		; and store
02:00006FCC 04010030        	   310: 	subi.b #'0',d1		; d1 = binary digit again
                            	   311: ;	cmpi.b #2,d1
                            	   312: ;	ble .0014
                            	   313: 
                            	   314: ;	ext.w d1
                            	   315: ;	ext.l d1
                            	   316: ;	fmove.l d1,fp3		; fp3 = digit
                            	   317: ;	fmul fp2,fp3			; fp3 = dbl2 * digit
                            	   318: ;	fmove fp7,fp0
                            	   319: ;	fsub fp3,fp0			; dbl = dbla - dbl2 * digit
                            	   320: .0014
02:00006FD0 537900040510    	   321: 	subi.w #1,_digits_before_decpt
02:00006FD6 6604            	   322: 	bne .0015
02:00006FD8 10FC002E        	   323: 	move.b #'.',(a0)+
                            	   324: .0015
02:00006FDC 4A7900040510    	   325: 	tst.w _digits_before_decpt
02:00006FE2 6C06            	   326: 	bge .0016
02:00006FE4 53B900040514    	   327: 	subi.l #1,_precision
                            	   328: .0016
02:00006FEA F23C4126FFFFFFFF	   329: 	fscale.l #-1,fp2		; dbl *= 10.0
02:00006FF2 51C8FFB4        	   330: 	dbra d0,.0017
                            	   331: .0011
02:00006FF6 4CEF0003000C    	   332: 	movem.l 12(sp),d0/d1
02:00006FFC F2174B80        	   333: 	fmove.x (sp),fp7
02:00007000 A2AF00030014    	   334: 	cchk 20(sp)
02:00007006 4E5A            	   335: 	unlk a2
02:00007008 4E75            	   336: 	rts
                            	   337: 
                            	   338: ;------------------------------------------------------------------------------
                            	   339: ; If the number ends in a decimal point, trim off the point.
                            	   340: ;
                            	   341: ; Registers Modified:
                            	   342: ;		none
                            	   343: ; Parameters:
                            	   344: ;		a0 = pointer to end of number
                            	   345: ; Returns:
                            	   346: ;		a0 = updated to point just past last digit.
                            	   347: ;------------------------------------------------------------------------------
                            	   348: 
                            	   349: _TrimTrailingPoint:
02:0000700A 0C28002EFFFF    	   350: 	cmpi.b #'.',-1(a0)
02:00007010 6604            	   351: 	bne .0001
02:00007012 4220            	   352: 	clr.b -(a0)
02:00007014 4E75            	   353: 	rts
                            	   354: .0001
02:00007016 0C10002E        	   355: 	cmpi.b #'.',(a0)
02:0000701A 660A            	   356: 	bne .0002
02:0000701C 4A280001        	   357: 	cmpi.b #0,1(a0)
02:00007020 6604            	   358: 	bne .0002
02:00007022 4210            	   359: 	clr.b (a0)
02:00007024 5348            	   360: 	subq #1,a0
                            	   361: .0002
02:00007026 4E75            	   362: 	rts
                            	   363: 	
                            	   364: ;------------------------------------------------------------------------------
                            	   365: ; If the number ends in .0 get rid of the .0
                            	   366: ;
                            	   367: ; Registers Modified:
                            	   368: ;		none
                            	   369: ; Parameters:
                            	   370: ;		a0 = pointer to last digits of number
                            	   371: ; Returns:
                            	   372: ;		a0 = updated to point just past last digit.
                            	   373: ;------------------------------------------------------------------------------
                            	   374: 
                            	   375: _TrimDotZero:
02:00007028 4A10            	   376: 	tst.b (a0)
02:0000702A 6616            	   377: 	bne .0004
02:0000702C 0C280030FFFF    	   378: 	cmpi.b #'0',-1(a0)
02:00007032 660E            	   379: 	bne .0004
02:00007034 0C28002EFFFE    	   380: 	cmpi.b #'.',-2(a0)
02:0000703A 6606            	   381: 	bne .0004
02:0000703C 4228FFFE        	   382: 	clr.b -2(a0)
02:00007040 5548            	   383: 	subq #2,a0
                            	   384: .0004
02:00007042 4E75            	   385: 	rts
                            	   386: 
                            	   387: ;------------------------------------------------------------------------------
                            	   388: ; Trim trailing zeros from the number. Generally there is no need to display
                            	   389: ; trailing zeros.
                            	   390: ; Turns a number like 652.000000000000000000000 into 650.0
                            	   391: ;
                            	   392: ; Registers Modified:
                            	   393: ;		none
                            	   394: ; Parameters:
                            	   395: ;		a0 = pointer to last digits of number
                            	   396: ; Returns:
                            	   397: ;		a0 = updated to point just past last digit.
                            	   398: ;------------------------------------------------------------------------------
                            	   399: 
                            	   400: ;	// Trim trailing zeros from the number
                            	   401: ;  do {
                            	   402: ;      ndx--;
                            	   403: ;  } while(buf[ndx]=='0');
                            	   404: ;  ndx++;
                            	   405: 
                            	   406: _TrimTrailingZeros:
                            	   407: .0018	
02:00007044 0C200030        	   408: 	cmpi.b #'0',-(a0)		; if the last digit was a zero, backup
02:00007048 67FA            	   409: 	beq .0018
02:0000704A 5248            	   410: 	addq #1,a0					; now advance by one
02:0000704C 4210            	   411: 	move.b #0,(a0)			; NULL terminate string
02:0000704E 4E75            	   412: 	rts
                            	   413: 
                            	   414: ;------------------------------------------------------------------------------
                            	   415: ; Output 'e+' or 'e-'
                            	   416: ;
                            	   417: ; Registers Modified:
                            	   418: ;		d6.w (if negative)
                            	   419: ; Parameters:
                            	   420: ;		a0 = pointer to last digits of number
                            	   421: ; Returns:
                            	   422: ;		a0 = updated to point just past '+' or '-'.
                            	   423: ;------------------------------------------------------------------------------
                            	   424: 
                            	   425: ;	// Spit out +/-E
                            	   426: ;  buf[ndx] = E;
                            	   427: ;  ndx++;
                            	   428: ;  if (exp < 0) {
                            	   429: ;    buf[ndx]='-';
                            	   430: ;    ndx++;
                            	   431: ;    exp = -exp;
                            	   432: ;  }
                            	   433: ;  else {
                            	   434: ;		buf[ndx]='+';
                            	   435: ;		ndx++;
                            	   436: ;  }
                            	   437: 
                            	   438: _SpitOutE:	
02:00007050 10F90004050C    	   439: 	move.b _E,(a0)+
02:00007056 4A46            	   440: 	tst.w d6
02:00007058 6C08            	   441: 	bge .0021
02:0000705A 10FC002D        	   442: 	move.b #'-',(a0)+
02:0000705E 4446            	   443: 	neg.w d6
02:00007060 6004            	   444: 	bra .0022
                            	   445: .0021
02:00007062 10FC002B        	   446: 	move.b #'+',(a0)+
                            	   447: .0022
02:00007066 4E75            	   448: 	rts
                            	   449: 
                            	   450: ;------------------------------------------------------------------------------
                            	   451: ; Extract a single digit of the exponent. Extract works from the leftmost digit
                            	   452: ; to the rightmost.
                            	   453: ;
                            	   454: ; Register Usage
                            	   455: ;		d2 = history of zeros
                            	   456: ;		d3 = digit
                            	   457: ; Modifies
                            	   458: ;		d2,d6,a0
                            	   459: ; Parameter
                            	   460: ; 	d1.w = power of ten
                            	   461: ;		d6.w = exponent
                            	   462: ;------------------------------------------------------------------------------
                            	   463: 
                            	   464: _ExtExpDigit:
02:00007068 2F03            	   465: 	move.l d3,-(a7)
02:0000706A 48C6            	   466: 	ext.l d6				; make d6 a long
02:0000706C 8CC1            	   467: 	divu d1,d6			; divide by power of ten
02:0000706E 1606            	   468: 	move.b d6,d3		; d3 = quotient (0 to 9)
02:00007070 4846            	   469: 	swap d6					; d6 = remainder, setup for next digit
02:00007072 8403            	   470: 	or.b d3,d2
02:00007074 4A03            	   471: 	tst.b d3
02:00007076 6604            	   472: 	bne .0003
02:00007078 4A02            	   473: 	tst.b d2	
02:0000707A 6706            	   474: 	beq .0004
                            	   475: .0003
02:0000707C 06030030        	   476: 	addi.b #'0',d3	; convert to ascii
02:00007080 10C3            	   477: 	move.b d3,(a0)+
                            	   478: .0004
02:00007082 261F            	   479: 	move.l (a7)+,d3
02:00007084 4E75            	   480: 	rts
                            	   481: 
                            	   482: ;------------------------------------------------------------------------------
                            	   483: ; Extract all the digits of the exponent.
                            	   484: ;
                            	   485: ; Register Usage
                            	   486: ;		d1 = power of 10
                            	   487: ;		d2 = history of zeros
                            	   488: ; Parameters
                            	   489: ;		a0 = pointer to string buffer
                            	   490: ;		d6 = exponent
                            	   491: ;------------------------------------------------------------------------------
                            	   492: 
                            	   493: ;	// If the number is times 10^0 don't output the exponent
                            	   494: ;  if (exp==0) {
                            	   495: ;    buf[ndx]='\0';
                            	   496: ;    goto prt;
                            	   497: ;  }
                            	   498: 
                            	   499: _ExtExpDigits:
02:00007086 2F01            	   500: 	move.l d1,-(a7)
02:00007088 4A46            	   501: 	tst.w d6							; is exponent zero?
02:0000708A 671C            	   502: 	beq .0002
02:0000708C 61C2            	   503: 	bsr _SpitOutE					; exponent is non-zero e+
02:0000708E 4202            	   504: 	clr.b d2							; d2 = history of zeros
02:00007090 323C03E8        	   505: 	move.w #1000,d1
02:00007094 61D2            	   506: 	bsr _ExtExpDigit
02:00007096 323C0064        	   507: 	move.w #100,d1
02:0000709A 61CC            	   508: 	bsr _ExtExpDigit
02:0000709C 323C000A        	   509: 	move.w #10,d1
02:000070A0 61C6            	   510: 	bsr _ExtExpDigit
02:000070A2 323C0001        	   511: 	move.w #1,d1
02:000070A6 61C0            	   512: 	bsr _ExtExpDigit
                            	   513: .0002:
02:000070A8 221F            	   514: 	move.l (a7)+,d1
02:000070AA 4210            	   515: 	move.b #0,(a0)				; NULL terminate string
02:000070AC 4E75            	   516: 	rts										; and return
                            	   517: 
                            	   518: ;------------------------------------------------------------------------------
                            	   519: ; Pad the left side of the output string.
                            	   520: ;
                            	   521: ; Modifies:
                            	   522: ;		d0,d1,d2,d3
                            	   523: ;------------------------------------------------------------------------------
                            	   524: 
                            	   525: ;  // pad left
                            	   526: ;  if (width > 0) {
                            	   527: ;    if (ndx < width) {
                            	   528: ;      for (nn = 39; nn >= width-ndx; nn--)
                            	   529: ;        buf[nn] = buf[nn-(width-ndx)];
                            	   530: ;      for (; nn >= 0; nn--)
                            	   531: ;        buf[nn] = ' ';
                            	   532: ;    }
                            	   533: ;  }
                            	   534: 	
                            	   535: _PadLeft:
02:000070AE 48E7F000        	   536: 	movem.l d0/d1/d2/d3,-(a7)
02:000070B2 4A3900040508    	   537: 	tst.b _width
02:000070B8 6F3E            	   538: 	ble .0041
02:000070BA 2008            	   539: 	move.l a0,d0
02:000070BC 90BC00040520    	   540: 	sub.l #_fpBuf,d0	; d0 = ndx
02:000070C2 B03900040508    	   541: 	cmp.b _width,d0
02:000070C8 6C2E            	   542: 	bge .0041
02:000070CA 323C0031        	   543: 	move.w #49,d1			; d1 = nn
                            	   544: .0040
02:000070CE 143900040508    	   545: 	move.b _width,d2
02:000070D4 4882            	   546: 	ext.w d2
02:000070D6 9440            	   547: 	sub.w d0,d2				; d2 = width-ndx
02:000070D8 B242            	   548: 	cmp.w d2,d1
02:000070DA 6D0E            	   549: 	blt .0039
02:000070DC 3601            	   550: 	move.w d1,d3			; d3 = nn
02:000070DE 9642            	   551: 	sub.w d2,d3				; d3 = nn-(width-ndx)
02:000070E0 11B030001000    	   552: 	move.b (a0,d3.w),(a0,d1.w)
02:000070E6 5341            	   553: 	subi.w #1,d1
02:000070E8 60E4            	   554: 	bra .0040
                            	   555: .0039
02:000070EA 4A41            	   556: 	tst.w d1
02:000070EC 6B0A            	   557: 	bmi .0041
02:000070EE 11BC00201000    	   558: 	move.b #' ',(a0,d1.w)
02:000070F4 5341            	   559: 	subi.w #1,d1
02:000070F6 60F2            	   560: 	bra .0039
                            	   561: .0041
02:000070F8 4CDF000F        	   562: 	movem.l (a7)+,d0/d1/d2/d3
02:000070FC 4E75            	   563: 	rts
                            	   564: 
                            	   565: ;------------------------------------------------------------------------------
                            	   566: ; Pad the right side of the output string.
                            	   567: ;
                            	   568: ; Parameters:
                            	   569: ;		a0 = pointer to end of string
                            	   570: ; Modifies:
                            	   571: ;		none
                            	   572: ; Returns:
                            	   573: ;		none
                            	   574: ;------------------------------------------------------------------------------
                            	   575: 
                            	   576: ;  // pad right
                            	   577: ;  if (width < 0) {
                            	   578: ;    width = -width;
                            	   579: ;    while (ndx < width) {
                            	   580: ;      buf[ndx]=' ';
                            	   581: ;      ndx++;
                            	   582: ;    }
                            	   583: ;    buf[ndx]='\0';
                            	   584: ;  }
                            	   585: ;  return (ndx);
                            	   586: 
                            	   587: _PadRight:
02:000070FE 2F00            	   588: 	move.l d0,-(a7)
02:00007100 4A3900040508    	   589: 	tst.b _width
02:00007106 6A24            	   590: 	bpl .0042
02:00007108 443900040508    	   591: 	neg.b _width
02:0000710E 2008            	   592: 	move.l a0,d0
02:00007110 90BC00040520    	   593: 	sub.l #_fpBuf,d0	; d0 = ndx
                            	   594: .0044
02:00007116 B03900040508    	   595: 	cmp.b _width,d0
02:0000711C 6C0A            	   596: 	bge .0043
02:0000711E 11BC00200000    	   597: 	move.b #' ',(a0,d0.w)
02:00007124 5240            	   598: 	addi.w #1,d0
02:00007126 60EE            	   599: 	bra .0044
                            	   600: .0043
02:00007128 42300000        	   601: 	move.b #0,(a0,d0.w)
                            	   602: .0042
02:0000712C 201F            	   603: 	move.l (a7)+,d0
02:0000712E 4E75            	   604: 	rts
                            	   605: 
                            	   606: ;------------------------------------------------------------------------------
                            	   607: ; Output a string representation of a decimal floating point number to a 
                            	   608: ; buffer.
                            	   609: ;
                            	   610: ; Register Usage
                            	   611: ;		a0 = pointer to string buffer
                            	   612: ;		d6 = exponent
                            	   613: ; Modifies:
                            	   614: ;		a0 = points to end of string
                            	   615: ; Parameters:
                            	   616: ;		fp0 = number to convert
                            	   617: ; Returns:
                            	   618: ;		none
                            	   619: ;------------------------------------------------------------------------------
                            	   620: 
                            	   621: _FloatToString:
02:00007130 2F06            	   622: 	move.l d6,-(a7)
02:00007132 6100FDB6        	   623: 	bsr _CheckNegative			; is number negative?
02:00007136 6100FD98        	   624: 	bsr _CheckZero					; check for zero
02:0000713A 6732            	   625: 	beq .0001								; branch since already output "0"
02:0000713C 6100FD2E        	   626: 	bsr _CheckNan						; check for Nan or infinity
02:00007140 652C            	   627: 	bcs .0001								; branch if nan/inf string output
                            	   628: 	; Now the fun begins
02:00007142 7C00            	   629: 	clr.l d6								; exponent = 0
02:00007144 6100FDB6        	   630: 	bsr _MakeBig
02:00007148 6100FDCE        	   631: 	bsr _LessThanDbl
02:0000714C 6100FDF6        	   632: 	bsr _ComputeDigitsBeforeDecpt
02:00007150 6100FE2C        	   633: 	bsr _LeadingZero
02:00007154 6100FE38        	   634: 	bsr _SpitOutDigits
02:00007158 6100FEEA        	   635: 	bsr _TrimTrailingZeros
02:0000715C 6100FEAC        	   636: 	bsr _TrimTrailingPoint
02:00007160 6100FEC6        	   637: 	bsr _TrimDotZero
02:00007164 6100FF20        	   638: 	bsr _ExtExpDigits				; extract exponent digits
02:00007168 6100FF44        	   639: 	bsr _PadLeft						; pad the number to the left or right
02:0000716C 6190            	   640: 	bsr _PadRight
                            	   641: .0001
02:0000716E 2C1F            	   642: 	move.l (a7)+,d6
02:00007170 4E75            	   643: 	rts
                            	   644: 
                            	   645: 

Source: "boot.x68"
                            	  3028: 	include "GetFloat.asm"

Source: "GetFloat.asm"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;
                            	    37: ; Get a floating point number
                            	    38: ;
                            	    39: _GetFloatGetChar:
02:00007172 1210            	    40: 	move.b (a0),d1
02:00007174 D1C0            	    41: 	add.l d0,a0
02:00007176 4E75            	    42: 	rts
                            	    43: _GetFloatIgnBlanks:
                            	    44: .0001
02:00007178 61F8            	    45: 	bsr _GetFloatGetChar
02:0000717A 0C010020        	    46: 	cmpi.b #' ',d1
02:0000717E 67F8            	    47: 	beq .0001
                            	    48: _GetFloatBackupChar:
02:00007180 91C0            	    49: 	sub.l d0,a0
02:00007182 4E75            	    50: 	rts
                            	    51: 
                            	    52: ;-------------------------------------------------------------------------------
                            	    53: ; Get fractional part of a number, 25 digits max, into a float register.
                            	    54: ;
                            	    55: ; Register Usage:
                            	    56: ;		d1 = digit from input screen
                            	    57: ;		d4 = digit count
                            	    58: ;		d6 = digit scaling factor
                            	    59: ;		fp1 = digit as float number
                            	    60: ; Returns:
                            	    61: ;		fp0 = fraction
                            	    62: ;-------------------------------------------------------------------------------
                            	    63: 
                            	    64: _GetFraction:
02:00007184 4E52FFE4        	    65: 	link a2,#-28
02:00007188 2F79000400980018	    66: 	move.l _canary,24(sp)
02:00007190 48D70052        	    67: 	movem.l d1/d4/d6,(sp)
02:00007194 F22F6880000C    	    68: 	fmove.x fp1,12(sp)
02:0000719A 7C00            	    69: 	clr.l d6							; d6 = scale factor
02:0000719C F23C50000000    	    70: 	fmove.w #0,fp0				; fract = 0.0
02:000071A2 7818            	    71: 	moveq #24,d4
                            	    72: .0002
02:000071A4 61CC            	    73: 	bsr _GetFloatGetChar
02:000071A6 0C010030        	    74: 	cmpi.b #'0',d1
02:000071AA 6520            	    75: 	blo .0001
02:000071AC 0C010039        	    76: 	cmpi.b #'9',d1				; make sure between 0 and 9
02:000071B0 621A            	    77: 	bhi .0001
02:000071B2 04010030        	    78: 	subi.b #'0',d1
02:000071B6 F23C50260001    	    79: 	fscale.w #1,fp0				; fract * 10.0
02:000071BC 5246            	    80: 	addq #1,d6						; record scaling
02:000071BE F2015880        	    81: 	fmove.b d1,fp1				; fp1 = digit
02:000071C2 F2000422        	    82: 	fadd fp1,fp0					; fract += digit
02:000071C6 5245            	    83: 	addq.w #1,d5					; increment number of digits in number
02:000071C8 51CCFFDA        	    84: 	dbra d4,.0002
                            	    85: .0001
02:000071CC 61B2            	    86: 	bsr _GetFloatBackupChar
02:000071CE 4446            	    87: 	neg d6
02:000071D0 F2064026        	    88: 	fscale.l d6,fp0				; fract /= scale
02:000071D4 4CD70052        	    89: 	movem.l (sp),d1/d4/d6
02:000071D8 F22F4880000C    	    90: 	fmove.x 12(sp),fp1
02:000071DE A2AF00030018    	    91: 	cchk 24(sp)
02:000071E4 4E5A            	    92: 	unlk a2
02:000071E6 4E75            	    93: 	rts
                            	    94: 
                            	    95: ;-------------------------------------------------------------------------------
                            	    96: ; Get exponent part of a number, 4 digits max, into a float register.
                            	    97: ;
                            	    98: ; Register Usage:
                            	    99: ;		d1 = digit from input screen
                            	   100: ;		d2 = exponent
                            	   101: ;		d3 = temp, number times 2
                            	   102: ;		d4 = digit counter
                            	   103: ; Parameters:
                            	   104: ;		fp0 = float number
                            	   105: ; Returns:
                            	   106: ;		fp0 = float number with exponent factored in
                            	   107: ;-------------------------------------------------------------------------------
                            	   108: 
                            	   109: _GetExponent:
02:000071E8 4E52FFE0        	   110: 	link a2,#-32
02:000071EC 2F7900040098001C	   111: 	move.l _canary,28(sp)
02:000071F4 48D7001E        	   112: 	movem.l d1/d2/d3/d4,(sp)
02:000071F8 F22F69000010    	   113: 	fmove.x fp2,16(sp)
02:000071FE 7400            	   114: 	clr.l d2							; d2 = number = 0
02:00007200 F23C51000000    	   115: 	fmove.w #0,fp2				; fp2 = exp = 0.0
02:00007206 7601            	   116: 	moveq #1,d3						; d3 = exscale = 1
02:00007208 6100FF68        	   117: 	bsr _GetFloatGetChar
02:0000720C 0C01002D        	   118: 	cmpi.b #'-',d1
02:00007210 6608            	   119: 	bne .0001
02:00007212 4483            	   120: 	neg.l d3							; exscale = -1
                            	   121: .0006
02:00007214 6100FF62        	   122: 	bsr _GetFloatIgnBlanks
02:00007218 600A            	   123: 	bra .0002
                            	   124: .0001
02:0000721A 0C01002B        	   125: 	cmpi.b #'+',d1
02:0000721E 67F4            	   126: 	beq .0006
02:00007220 6100FF5E        	   127: 	bsr _GetFloatBackupChar
                            	   128: .0002	
02:00007224 7803            	   129: 	moveq #3,d4						; d4 = max 4 digits
                            	   130: .0004
02:00007226 6100FF4A        	   131: 	bsr _GetFloatGetChar	; d1 = digit char
02:0000722A 0C010030        	   132: 	cmpi.b #'0',d1
02:0000722E 651E            	   133: 	blo .0003
02:00007230 0C010039        	   134: 	cmpi.b #'9',d1				; ensure between 0 and 9
02:00007234 6218            	   135: 	bhi .0003
02:00007236 04010030        	   136: 	subi.b #'0',d1
02:0000723A D482            	   137: 	add.l d2,d2						; number *2
02:0000723C 2602            	   138: 	move.l d2,d3
02:0000723E E58A            	   139: 	lsl.l #2,d2						; number *8
02:00007240 D483            	   140: 	add.l d3,d2						; number *10	
02:00007242 4881            	   141: 	ext.w d1
02:00007244 48C1            	   142: 	ext.l d1
02:00007246 D481            	   143: 	add.l d1,d2						; number + digit
02:00007248 5245            	   144: 	addq.w #1,d5					; increment number of digits in number
02:0000724A 51CCFFDA        	   145: 	dbra d4,.0004
                            	   146: .0003
02:0000724E 6100FF30        	   147: 	bsr _GetFloatBackupChar	; backup a character
02:00007252 C4C3            	   148: 	mulu d3,d2						; *1 or *-1
02:00007254 48C2            	   149: 	ext.l d2
02:00007256 F2024126        	   150: 	fscale.l d2,fp2				; exp * exmul
02:0000725A F2000823        	   151: 	fmul fp2,fp0					; rval *= exp
02:0000725E 4CD7001E        	   152: 	movem.l (sp),d1/d2/d3/d4
02:00007262 F22F49000010    	   153: 	fmove.x 16(sp),fp2
02:00007268 A2AF0003001C    	   154: 	cchk 28(sp)
02:0000726E 4E5A            	   155: 	unlk a2
02:00007270 4E75            	   156: 	rts	
                            	   157: 
                            	   158: ;-------------------------------------------------------------------------------
                            	   159: ; Get an integer number, positive or negative, 25 digits max, into a float
                            	   160: ; register.
                            	   161: ;
                            	   162: ; Register Usage:
                            	   163: ;		d1 = digit from input screen
                            	   164: ;		d2 = digit down counter
                            	   165: ;		d3 = sign of number '+' or '-'
                            	   166: ;		fp1 = digit
                            	   167: ; Modifies:
                            	   168: ;		a0,fp0
                            	   169: ; Returns:
                            	   170: ;		a0 = updated buffer pointer
                            	   171: ;		fp0 = integer number
                            	   172: ;-------------------------------------------------------------------------------
                            	   173: 
                            	   174: _GetInteger:
02:00007272 4E52FFE4        	   175: 	link a2,#-28
02:00007276 2F79000400980018	   176: 	move.l _canary,24(sp)
02:0000727E 48D7000E        	   177: 	movem.l d1/d2/d3,(sp)
02:00007282 F22F6880000C    	   178: 	fmove.x fp1,12(sp)
02:00007288 F23C50000000    	   179: 	fmove.w #0,fp0
02:0000728E 7418            	   180: 	moveq #24,d2					; d2 = digit count (25 max)
02:00007290 6100FEE6        	   181: 	bsr _GetFloatIgnBlanks
02:00007294 6100FEDC        	   182: 	bsr _GetFloatGetChar	; get the sign of the number
02:00007298 0C01002B        	   183: 	cmpi.b #'+',d1
02:0000729C 670A            	   184: 	beq .0002
                            	   185: .0003
02:0000729E 0C01002D        	   186: 	cmpi.b #'-',d1
02:000072A2 6608            	   187: 	bne .0004
02:000072A4 1E3C002D        	   188: 	move.b #'-',d7
                            	   189: .0002
02:000072A8 6100FEC8        	   190: 	bsr _GetFloatGetChar
                            	   191: .0004
02:000072AC 0C010030        	   192: 	cmpi.b #'0',d1				; only characters 0 to 9 valid
02:000072B0 651E            	   193: 	blo .0001
02:000072B2 0C010039        	   194: 	cmpi.b #'9',d1
02:000072B6 6218            	   195: 	bhi .0001
02:000072B8 04010030        	   196: 	subi.b #'0',d1
02:000072BC F23C50260001    	   197: 	fscale.w #1,fp0				; number *10
02:000072C2 F2015880        	   198: 	fmove.b d1,fp1				; fp1 = digit
02:000072C6 F2000422        	   199: 	fadd fp1,fp0
02:000072CA 5245            	   200: 	addq.w #1,d5
02:000072CC 51CAFFDA        	   201: 	dbra d2,.0002
                            	   202: .0001
02:000072D0 6100FEAE        	   203: 	bsr _GetFloatBackupChar
02:000072D4 4CD7000E        	   204: 	movem.l (sp),d1/d2/d3
02:000072D8 F22F4880000C    	   205: 	fmove.x 12(sp),fp1
02:000072DE A2AF00030018    	   206: 	cchk 24(sp)
02:000072E4 4E5A            	   207: 	unlk a2
02:000072E6 4E75            	   208: 	rts
                            	   209: 		
                            	   210: ;-------------------------------------------------------------------------------
                            	   211: ; Get a floating point number off the input screen.
                            	   212: ;
                            	   213: ; Parameters:
                            	   214: ;		a0 = pointer to buffer containing string
                            	   215: ;		d0 = stride of buffer (increment / decrement amount)
                            	   216: ; Register Usage:
                            	   217: ;		d1 = character from input screen
                            	   218: ;		d5.lo = number of digits in number, d5.hi = number of characters fetched
                            	   219: ; Returns:
                            	   220: ;		fp0 = number
                            	   221: ;		a0 = updated buffer pointer
                            	   222: ;		d0 = length of number >0 if a number
                            	   223: ;-------------------------------------------------------------------------------
                            	   224: 
                            	   225: _GetFloat:
02:000072E8 4E52FFE0        	   226: 	link a2,#-32
02:000072EC 2F7900040098001C	   227: 	move.l _canary,28(sp)
02:000072F4 48D702A2        	   228: 	movem.l d1/d5/d7/a1,(sp)
02:000072F8 F22F69000010    	   229: 	fmove.x fp2,16(sp)
02:000072FE 7A00            	   230: 	clr.l d5
02:00007300 1E3C002B        	   231: 	move.b #'+',d7				; assume a positive number
02:00007304 2248            	   232: 	move.l a0,a1					; a1 = copy of pointer to buffer
02:00007306 6100FF6A        	   233: 	bsr _GetInteger				; rval = integer
02:0000730A F2000100        	   234: 	fmove.x fp0,fp2
02:0000730E 6100FE62        	   235: 	bsr _GetFloatGetChar
02:00007312 0C01002E        	   236: 	cmpi.b #'.',d1
02:00007316 6706            	   237: 	beq .0004
                            	   238: .0005
02:00007318 6100FE66        	   239: 	bsr _GetFloatBackupChar
02:0000731C 601C            	   240: 	bra .0002
                            	   241: .0004
02:0000731E 6100FE64        	   242: 	bsr _GetFraction
02:00007322 F2000822        	   243: 	fadd fp2,fp0					; rval += fraction
02:00007326 6100FE4A        	   244: 	bsr _GetFloatGetChar
02:0000732A 0C010065        	   245: 	cmpi.b #'e',d1				; accept either 'e' or 'E' indicating exponent
02:0000732E 6706            	   246: 	beq .0001
02:00007330 0C010045        	   247: 	cmpi.b #'E',d1
02:00007334 66E2            	   248: 	bne .0005
                            	   249: .0001
02:00007336 6100FEB0        	   250: 	bsr _GetExponent			; factor exponent into fp0
                            	   251: .0002
02:0000733A 0C07002D        	   252: 	cmpi.b #'-',d7				; adjust number for sign
02:0000733E 6604            	   253: 	bne .0003
02:00007340 F200001A        	   254: 	fneg fp0
                            	   255: .0003
02:00007344 93C8            	   256: 	suba.l a0,a1					; compute number of characters fetched
02:00007346 3009            	   257: 	move.w a1,d0					; move it to d0.hi
02:00007348 4840            	   258: 	swap d0
02:0000734A 3005            	   259: 	move.w d5,d0					; return digit/character count in d0 (non zero for a number)
02:0000734C 4CD702A2        	   260: 	movem.l (sp),d1/d5/d7/a1
02:00007350 F22F49000010    	   261: 	fmove.x 16(sp),fp2
02:00007356 A2AF0003001C    	   262: 	cchk 28(sp)
02:0000735C 4E5A            	   263: 	unlk a2
02:0000735E 4E75            	   264: 	rts	
                            	   265: 
                            	   266: 		

Source: "boot.x68"
                            	  3029: 
                            	  3030: ;------------------------------------------------------------------------------
                            	  3031: ; Convert ASCII character in the range '0' to '9', 'a' tr 'f' or 'A' to 'F'
                            	  3032: ; to a hex nybble.
                            	  3033: ;------------------------------------------------------------------------------
                            	  3034: 
                            	  3035: AsciiToHexNybble:
02:00007360 0C010030        	  3036: 	cmpi.b	#'0',d1
02:00007364 6530            	  3037: 	blo.s		gthx3
02:00007366 0C010039        	  3038: 	cmpi.b	#'9',d1
02:0000736A 6206            	  3039: 	bhi.s		gthx5
02:0000736C 04010030        	  3040: 	subi.b	#'0',d1
02:00007370 4E75            	  3041: 	rts
                            	  3042: gthx5:
02:00007372 0C010041        	  3043: 	cmpi.b	#'A',d1
02:00007376 651E            	  3044: 	blo.s		gthx3
02:00007378 0C010046        	  3045: 	cmpi.b	#'F',d1
02:0000737C 6206            	  3046: 	bhi.s		gthx6
02:0000737E 060100C9        	  3047: 	addi.b	#10-'A',d1
02:00007382 4E75            	  3048: 	rts
                            	  3049: gthx6:
02:00007384 0C010061        	  3050: 	cmpi.b	#'a',d1
02:00007388 650C            	  3051: 	blo.s		gthx3
02:0000738A 0C010066        	  3052: 	cmpi.b	#'f',d1
02:0000738E 6206            	  3053: 	bhi.s		gthx3
02:00007390 060100A9        	  3054: 	addi.b	#10-'a',d1
02:00007394 4E75            	  3055: 	rts
                            	  3056: gthx3:
02:00007396 72FF            	  3057: 	moveq	#-1,d1		; not a hex number
02:00007398 4E75            	  3058: 	rts
                            	  3059: 
                            	  3060: ;------------------------------------------------------------------------------
                            	  3061: ;------------------------------------------------------------------------------
                            	  3062: 
                            	  3063: DisplayTwoSpaces:
02:0000739A 2F01            	  3064: 	move.l	d1,-(a7)
02:0000739C 123C0020        	  3065: 	move.b	#' ',d1
02:000073A0 6100E532        	  3066: 	bsr			DisplayChar
                            	  3067: dspspc1:
02:000073A4 6100E52E        	  3068: 	bsr			DisplayChar
02:000073A8 221F            	  3069: 	move.l	(a7)+,d1
02:000073AA 4E75            	  3070: 	rts
                            	  3071: 
                            	  3072: DisplaySpace:
02:000073AC 2F01            	  3073: 	move.l	d1,-(a7)
02:000073AE 123C0020        	  3074: 	move.b	#' ',d1
02:000073B2 60F0            	  3075: 	bra			dspspc1
                            	  3076: 
                            	  3077: ;------------------------------------------------------------------------------
                            	  3078: ; Display the 32 bit word in D1.L
                            	  3079: ;------------------------------------------------------------------------------
                            	  3080: 
                            	  3081: DisplayTetra:
02:000073B4 4841            	  3082: 	swap	d1
02:000073B6 6102            	  3083: 	bsr		DisplayWyde
02:000073B8 4841            	  3084: 	swap	d1
                            	  3085: 
                            	  3086: ;------------------------------------------------------------------------------
                            	  3087: ; Display the byte in D1.W
                            	  3088: ;------------------------------------------------------------------------------
                            	  3089: 
                            	  3090: DisplayWyde:
02:000073BA E059            	  3091: 	ror.w		#8,d1
02:000073BC 6102            	  3092: 	bsr			DisplayByte
02:000073BE E159            	  3093: 	rol.w		#8,d1
                            	  3094: 
                            	  3095: ;------------------------------------------------------------------------------
                            	  3096: ; Display the byte in D1.B
                            	  3097: ;------------------------------------------------------------------------------
                            	  3098: 
                            	  3099: DisplayByte:
02:000073C0 E819            	  3100: 	ror.b		#4,d1
02:000073C2 6102            	  3101: 	bsr			DisplayNybble
02:000073C4 E919            	  3102: 	rol.b		#4,d1
                            	  3103: 
                            	  3104: ;------------------------------------------------------------------------------
                            	  3105: ; Display nybble in D1.B
                            	  3106: ;------------------------------------------------------------------------------
                            	  3107: 
                            	  3108: DisplayNybble:
02:000073C6 2F01            	  3109: 	move.l	d1,-(a7)
02:000073C8 0201000F        	  3110: 	andi.b	#$F,d1
02:000073CC 06010030        	  3111: 	addi.b	#'0',d1
02:000073D0 0C010039        	  3112: 	cmpi.b	#'9',d1
02:000073D4 6302            	  3113: 	bls.s		.0001
02:000073D6 5E01            	  3114: 	addi.b	#7,d1
                            	  3115: .0001:
02:000073D8 6100E4FA        	  3116: 	bsr			DisplayChar
02:000073DC 221F            	  3117: 	move.l	(a7)+,d1
02:000073DE 4E75            	  3118: 	rts
                            	  3119: 
                            	  3120: ;------------------------------------------------------------------------------
                            	  3121: ;------------------------------------------------------------------------------
                            	  3122: ;
                            	  3123: ;DisplayHexNumber:
                            	  3124: ;	move.w	#$A6A6,leds		; diagnostics
                            	  3125: ;	move.l	#VDGREG,a6
                            	  3126: ;	move.w	#7,d2		; number-1 of digits to display
                            	  3127: ;disphnum1:
                            	  3128: ;	move.b	d1,d0		; get digit into d0.b
                            	  3129: ;	andi.w	#$0f,d0
                            	  3130: ;	cmpi.w	#$09,d0
                            	  3131: ;	bls.s	disphnum2
                            	  3132: ;	addi.w	#7,d0
                            	  3133: ;disphnum2:
                            	  3134: ;	addi.w	#$30,d0	; convert to display char
                            	  3135: ;	move.w	d2,d3		; char count into d3
                            	  3136: ;	asl.w	#3,d3		; scale * 8
                            	  3137: ;disphnum3:
                            	  3138: ;	move.w	$42C(a6),d4			; read character queue index into d4
                            	  3139: ;	cmp.w	#28,d4					; allow up 28 entries to be in progress
                            	  3140: ;	bhs.s	disphnum3				; branch if too many chars queued
                            	  3141: ;	ext.w	d0						; zero out high order bits
                            	  3142: ;	move.w	d0,$420(a6)			; set char code
                            	  3143: ;	move.w	#WHITE,$422(a6)		; set fg color
                            	  3144: ;	move.w	#DARK_BLUE,$424(a6)	; set bk color
                            	  3145: ;	move.w	d3,$426(a6)			; set x pos
                            	  3146: ;	move.w	#8,$428(a6)			; set y pos
                            	  3147: ;	move.w	#$0707,$42A(a6)		; set font x,y extent
                            	  3148: ;	move.w	#0,$42E(a6)			; pulse character queue write signal
                            	  3149: ;	ror.l	#4,d1					; rot to next digit
                            	  3150: ;	dbeq	d2,disphnum1
                            	  3151: ;	jmp		(a5)
                            	  3152: 
                            	  3153: 	include "ramtest.x68"

Source: "ramtest.x68"
                            	     1: ;===============================================================================
                            	     2: ;    Perform ram test. (Uses checkerboard testing).
                            	     3: ; 
                            	     4: ;    Local ram, which does not get tested, is used for the stack.
                            	     5: ;===============================================================================
                            	     6: 	code
                            	     7: 	even
                            	     8: DisplayAddr:
02:000073E0 2208            	     9: 	move.l a0,d1
02:000073E2 E089            	    10: 	lsr.l #8,d1
02:000073E4 E089            	    11: 	lsr.l #8,d1
02:000073E6 E889            	    12: 	lsr.l #4,d1
02:000073E8 04410400        	    13: 	subi.w #1024,d1
02:000073EC A2C10000        	    14: 	bin2bcd d1
02:000073F0 61C8            	    15: 	bsr	DisplayWyde
02:000073F2 61B8            	    16: 	bsr DisplaySpace
02:000073F4 123C000D        	    17: 	move.b #CR,d1
02:000073F8 6000E4DA        	    18: 	bra DisplayChar
02:000073FC 08000083        	    19: 	btst #$83,d0
                            	    20: 	
                            	    21: cmdTestRAM:
                            	    22: ramtest:
02:00007400 33FCA5A5FD0FFF00	    23: 	move.w	#$A5A5,leds		; diagnostics
02:00007408 263CAAAAAAAA    	    24:   move.l #$aaaaaaaa,d3
02:0000740E 283C55555555    	    25:   move.l #$55555555,d4
02:00007414 6134            	    26:   bsr ramtest0
                            	    27:   ; switch checkerboard pattern and repeat test.
02:00007416 C744            	    28:   exg d3,d4
02:00007418 6130            	    29:   bsr ramtest0
                            	    30: 	; Save last ram address in end of memory pointer.
                            	    31: rmtst5:
02:0000741A 7025            	    32: 	moveq #37,d0					; lock semaphore
02:0000741C 7206            	    33: 	moveq #MEMORY_SEMA,d1
                            	    34: ;	trap #15
02:0000741E 207C7FFFFFF8    	    35:   movea.l #$7FFFFFF8,a0
02:00007424 23C800100004    	    36:   move.l a0,memend
                            	    37: 	; Create very first memory block.
02:0000742A 207C3FFFFFF4    	    38:   movea.l #$3FFFFFF4,a0
02:00007430 23C840000004    	    39:   move.l a0,$40000004		; length of block
02:00007436 23FC465245454000	    40:   move.l #$46524545,$40000000
02:0000743E 0000
02:00007440 7026            	    41: 	moveq #38,d0					; unlock semaphore
02:00007442 7206            	    42: 	moveq #MEMORY_SEMA,d1
02:00007444 4E4F            	    43: 	trap #15
02:00007446 6000F278        	    44: 	bra Monitor
                            	    45: ;  rts
                            	    46: 
                            	    47: ramtest0:
02:0000744A 2003            	    48: 	move.l d3,d0
02:0000744C 207C40000000    	    49:   movea.l #$40000000,a0
                            	    50: ;-----------------------------------------------------------
                            	    51: ;   Write checkerboard pattern to ram then read it back to
                            	    52: ; find the highest usable ram address (maybe). This address
                            	    53: ; must be lower than the start of the rom (0xe00000).
                            	    54: ;-----------------------------------------------------------
                            	    55: ramtest1:
02:00007452 20C3            	    56:   move.l d3,(a0)+
02:00007454 20C4            	    57:   move.l d4,(a0)+
02:00007456 2208            	    58:   move.l a0,d1
02:00007458 4A41            	    59:   tst.w	d1
02:0000745A 6606            	    60:   bne.s rmtst1
02:0000745C 6182            	    61:   bsr DisplayAddr
02:0000745E 6100EB58        	    62:   bsr CheckForCtrlC
                            	    63: rmtst1:
02:00007462 B1FC7FFFFFF8    	    64:   cmpa.l #$7FFFFFF8,a0
02:00007468 65E8            	    65:   blo.s ramtest1
02:0000746A 6100E41E        	    66:   bsr	CRLF
                            	    67: ;------------------------------------------------------
                            	    68: ;   Save maximum useable address for later comparison.
                            	    69: ;------------------------------------------------------
                            	    70: ramtest6:
02:0000746E 33FCA7A7FD0FFF00	    71: 	move.w	#$A7A7,leds		; diagnostics
02:00007476 2448            	    72:   movea.l a0,a2
02:00007478 207C40000000    	    73:   movea.l #$40000000,a0
                            	    74: ;--------------------------------------------
                            	    75: ;   Read back checkerboard pattern from ram.
                            	    76: ;--------------------------------------------
                            	    77: ramtest2
02:0000747E 2A18            	    78:   move.l (a0)+,d5
02:00007480 2C18            	    79:   move.l (a0)+,d6
02:00007482 B1CA            	    80:   cmpa.l a2,a0
02:00007484 643A            	    81:   bhs.s	ramtest3
02:00007486 2208            	    82:   move.l a0,d1
02:00007488 4A41            	    83:   tst.w	d1
02:0000748A 6608            	    84:   bne.s	rmtst2
02:0000748C 6100FF52        	    85:   bsr	DisplayAddr
02:00007490 6100EB26        	    86: 	bsr CheckForCtrlC
                            	    87: rmtst2
02:00007494 BA83            	    88:   cmp.l d3,d5
02:00007496 6604            	    89:   bne.s rmtst3
02:00007498 BC84            	    90:   cmp.l d4,d6
02:0000749A 67E2            	    91:   beq.s ramtest2
                            	    92: ;----------------------------------
                            	    93: ; Report error in ram.
                            	    94: ;----------------------------------
                            	    95: rmtst3
02:0000749C 6100E3EC        	    96: 	bsr CRLF
02:000074A0 7245            	    97: 	moveq	#'E',d1
02:000074A2 6100E430        	    98: 	bsr DisplayChar
02:000074A6 6100FF04        	    99: 	bsr DisplaySpace
02:000074AA 2208            	   100: 	move.l a0,d1
02:000074AC 6100FF06        	   101: 	bsr DisplayTetra
02:000074B0 6100FEFA        	   102: 	bsr DisplaySpace
02:000074B4 2205            	   103: 	move.l d5,d1
02:000074B6 6100FEFC        	   104: 	bsr DisplayTetra
02:000074BA 6100EAFC        	   105: 	bsr CheckForCtrlC
02:000074BE 60BE            	   106: 	bra ramtest2
                            	   107: ramtest3
02:000074C0 4E75            	   108: 	rts
                            	   109: 

Source: "boot.x68"
                            	  3154: 	include "LoadS19.x68"

Source: "LoadS19.x68"
                            	     1: ;==============================================================================
                            	     2: ; Load an S19 format file
                            	     3: ;==============================================================================
                            	     4: 	code
                            	     5: 	even
                            	     6: cmdLoadS19:
02:000074C2 6100E3C6        	     7: 	bsr			CRLF					; move display to next line
02:000074C6 6012            	     8: 	bra			ProcessRec
                            	     9: NextRec:
02:000074C8 610001DC        	    10: 	bsr			sGetChar			; get character from serial port routines
02:000074CC 0C01000A        	    11: 	cmpi.b	#LF,d1				; look for a line-feed
02:000074D0 66F6            	    12: 	bne			NextRec
02:000074D2 123C002E        	    13: 	move.b	#'.',d1				; progress display
02:000074D6 6100E3FC        	    14: 	bsr			DisplayChar
                            	    15: ProcessRec:
02:000074DA 6100EADC        	    16: 	bsr			CheckForCtrlC	; check for CTRL-C once per record
02:000074DE 610001C6        	    17: 	bsr			sGetChar
02:000074E2 0C01000D        	    18: 	cmpi.b	#CR,d1
02:000074E6 67F2            	    19: 	beq.s		ProcessRec
02:000074E8 423900100150    	    20: 	clr.b		S19Checksum		; clear the checksum
02:000074EE 1801            	    21: 	move.b	d1,d4
02:000074F0 0C04001A        	    22: 	cmpi.b	#CTRLZ,d4			; CTRL-Z ?
02:000074F4 6700F1CA        	    23: 	beq			Monitor
02:000074F8 0C040053        	    24: 	cmpi.b	#'S',d4				; All records must begin with an 'S'
02:000074FC 66CA            	    25: 	bne.s		NextRec
02:000074FE 610001A6        	    26: 	bsr			sGetChar
02:00007502 1801            	    27: 	move.b	d1,d4
02:00007504 0C040030        	    28: 	cmpi.b	#'0',d4				; Record type must be between '0' and '9'
02:00007508 65BE            	    29: 	blo.s		NextRec
02:0000750A 0C040039        	    30: 	cmpi.b	#'9',d4				; d4 = record type
02:0000750E 62B8            	    31: 	bhi.s		NextRec
02:00007510 61000194        	    32: 	bsr			sGetChar			; get byte count for record
02:00007514 6100FE4A        	    33: 	bsr			AsciiToHexNybble
02:00007518 1401            	    34: 	move.b	d1,d2
02:0000751A 6100018A        	    35: 	bsr			sGetChar
02:0000751E 6100FE40        	    36: 	bsr			AsciiToHexNybble
02:00007522 E90A            	    37: 	lsl.b		#4,d2
02:00007524 8202            	    38: 	or.b		d2,d1					; d1 = byte count
02:00007526 1601            	    39: 	move.b	d1,d3					; d3 = byte count
02:00007528 D73900100150    	    40: 	add.b		d3,S19Checksum
02:0000752E 0C040030        	    41: 	cmpi.b	#'0',d4				; manufacturer ID record, ignore
02:00007532 6794            	    42: 	beq			NextRec
02:00007534 0C040031        	    43: 	cmpi.b	#'1',d4
02:00007538 670000A2        	    44: 	beq			ProcessS1
02:0000753C 0C040032        	    45: 	cmpi.b	#'2',d4
02:00007540 6700009E        	    46: 	beq			ProcessS2
02:00007544 0C040033        	    47: 	cmpi.b	#'3',d4
02:00007548 6700009A        	    48: 	beq			ProcessS3
02:0000754C 0C040035        	    49: 	cmpi.b	#'5',d4				; record count record, ignore
02:00007550 6700FF76        	    50: 	beq			NextRec
02:00007554 0C040037        	    51: 	cmpi.b	#'7',d4
02:00007558 6700008E        	    52: 	beq			ProcessS7
02:0000755C 0C040038        	    53: 	cmpi.b	#'8',d4
02:00007560 67000096        	    54: 	beq			ProcessS8
02:00007564 0C040039        	    55: 	cmpi.b	#'9',d4
02:00007568 6700009E        	    56: 	beq			ProcessS9
02:0000756C 6000FF5A        	    57: 	bra			NextRec
                            	    58: 
                            	    59: pcssxa:
02:00007570 2209            	    60: 	move.l	a1,d1
02:00007572 6100FE40        	    61: 	bsr			DisplayTetra
02:00007576 123C000D        	    62: 	move.b	#CR,d1
02:0000757A 6100E358        	    63: 	bsr			DisplayChar
02:0000757E 024300FF        	    64: 	andi.w	#$ff,d3
02:00007582 5343            	    65: 	subi.w	#1,d3			; one less for dbra
                            	    66: .0001:
02:00007584 7400            	    67: 	clr.l		d2
02:00007586 6100011E        	    68: 	bsr			sGetChar
02:0000758A 6100FDD4        	    69: 	bsr			AsciiToHexNybble
02:0000758E E98A            	    70: 	lsl.l		#4,d2
02:00007590 8401            	    71: 	or.b		d1,d2
02:00007592 61000112        	    72: 	bsr			sGetChar
02:00007596 6100FDC8        	    73: 	bsr			AsciiToHexNybble
02:0000759A E98A            	    74: 	lsl.l		#4,d2
02:0000759C 8401            	    75: 	or.b		d1,d2
02:0000759E D53900100150    	    76: 	add.b		d2,S19Checksum
02:000075A4 12C2            	    77: 	move.b	d2,(a1)+			; move byte to memory
02:000075A6 51CBFFDC        	    78: 	dbra		d3,.0001
                            	    79: 	; Get the checksum byte
02:000075AA 7400            	    80: 	clr.l		d2
02:000075AC 610000F8        	    81: 	bsr			sGetChar
02:000075B0 6100FDAE        	    82: 	bsr			AsciiToHexNybble
02:000075B4 E98A            	    83: 	lsl.l		#4,d2
02:000075B6 8401            	    84: 	or.b		d1,d2
02:000075B8 610000EC        	    85: 	bsr			sGetChar
02:000075BC 6100FDA2        	    86: 	bsr			AsciiToHexNybble
02:000075C0 E98A            	    87: 	lsl.l		#4,d2
02:000075C2 8401            	    88: 	or.b		d1,d2
02:000075C4 4602            	    89: 	eor.b		#$FF,d2
02:000075C6 B43900100150    	    90: 	cmp.b		S19Checksum,d2
02:000075CC 6700FEFA        	    91: 	beq			NextRec
02:000075D0 123C0045        	    92: 	move.b	#'E',d1
02:000075D4 6100E2FE        	    93: 	bsr			DisplayChar
02:000075D8 6000FEEE        	    94: 	bra			NextRec
                            	    95: 
                            	    96: ProcessS1:
02:000075DC 613A            	    97: 	bsr			S19Get16BitAddress
02:000075DE 6090            	    98: 	bra			pcssxa
                            	    99: ProcessS2:
02:000075E0 6144            	   100: 	bsr			S19Get24BitAddress
02:000075E2 608C            	   101: 	bra			pcssxa
                            	   102: ProcessS3:
02:000075E4 614C            	   103: 	bsr			S19Get32BitAddress
02:000075E6 6088            	   104: 	bra			pcssxa
                            	   105: ProcessS7:
02:000075E8 6148            	   106: 	bsr			S19Get32BitAddress
02:000075EA 23C900040008    	   107: 	move.l	a1,S19StartAddress
02:000075F0 6100E7CE        	   108: 	bsr			_KeybdInit
02:000075F4 6000F0CA        	   109: 	bra			Monitor
                            	   110: ProcessS8:
02:000075F8 612C            	   111: 	bsr			S19Get24BitAddress
02:000075FA 23C900040008    	   112: 	move.l	a1,S19StartAddress
02:00007600 6100E7BE        	   113: 	bsr			_KeybdInit
02:00007604 6000F0BA        	   114: 	bra			Monitor
                            	   115: ProcessS9:
02:00007608 610E            	   116: 	bsr			S19Get16BitAddress
02:0000760A 23C900040008    	   117: 	move.l	a1,S19StartAddress
02:00007610 6100E7AE        	   118: 	bsr			_KeybdInit
02:00007614 6000F0AA        	   119: 	bra			Monitor
                            	   120: 
                            	   121: S19Get16BitAddress:
02:00007618 7400            	   122: 	clr.l		d2
02:0000761A 6100008A        	   123: 	bsr			sGetChar
02:0000761E 6100FD40        	   124: 	bsr			AsciiToHexNybble
02:00007622 1401            	   125: 	move.b	d1,d2
02:00007624 603E            	   126: 	bra			S1932b
                            	   127: 
                            	   128: S19Get24BitAddress:
02:00007626 7400            	   129: 	clr.l		d2
02:00007628 617C            	   130: 	bsr			sGetChar
02:0000762A 6100FD34        	   131: 	bsr			AsciiToHexNybble
02:0000762E 1401            	   132: 	move.b	d1,d2
02:00007630 601E            	   133: 	bra			S1932a
                            	   134: 
                            	   135: S19Get32BitAddress:
02:00007632 7400            	   136: 	clr.l		d2
02:00007634 6170            	   137: 	bsr			sGetChar
02:00007636 6100FD28        	   138: 	bsr			AsciiToHexNybble
02:0000763A 1401            	   139: 	move.b	d1,d2
02:0000763C 6168            	   140: 	bsr			sGetChar
02:0000763E 6100FD20        	   141: 	bsr			AsciiToHexNybble
02:00007642 E98A            	   142: 	lsl.l		#4,d2
02:00007644 8401            	   143: 	or.b		d1,d2
02:00007646 615E            	   144: 	bsr			sGetChar
02:00007648 6100FD16        	   145: 	bsr			AsciiToHexNybble
02:0000764C E98A            	   146: 	lsl.l		#4,d2
02:0000764E 8401            	   147: 	or.b		d1,d2
                            	   148: S1932a:
02:00007650 6154            	   149: 	bsr			sGetChar
02:00007652 6100FD0C        	   150: 	bsr			AsciiToHexNybble
02:00007656 E98A            	   151: 	lsl.l		#4,d2
02:00007658 8401            	   152: 	or.b		d1,d2
02:0000765A 614A            	   153: 	bsr			sGetChar
02:0000765C 6100FD02        	   154: 	bsr			AsciiToHexNybble
02:00007660 E98A            	   155: 	lsl.l		#4,d2
02:00007662 8401            	   156: 	or.b		d1,d2
                            	   157: S1932b:
02:00007664 6140            	   158: 	bsr			sGetChar
02:00007666 6100FCF8        	   159: 	bsr			AsciiToHexNybble
02:0000766A E98A            	   160: 	lsl.l		#4,d2
02:0000766C 8401            	   161: 	or.b		d1,d2
02:0000766E 6136            	   162: 	bsr			sGetChar
02:00007670 6100FCEE        	   163: 	bsr			AsciiToHexNybble
02:00007674 E98A            	   164: 	lsl.l		#4,d2
02:00007676 8401            	   165: 	or.b		d1,d2
02:00007678 612C            	   166: 	bsr			sGetChar
02:0000767A 6100FCE4        	   167: 	bsr			AsciiToHexNybble
02:0000767E E98A            	   168: 	lsl.l		#4,d2
02:00007680 8401            	   169: 	or.b		d1,d2
02:00007682 7800            	   170: 	clr.l		d4
02:00007684 2242            	   171: 	move.l	d2,a1
                            	   172: 	; Add bytes from address value to checksum
02:00007686 D53900100150    	   173: 	add.b		d2,S19Checksum
02:0000768C E08A            	   174: 	lsr.l		#8,d2
02:0000768E D53900100150    	   175: 	add.b		d2,S19Checksum
02:00007694 E08A            	   176: 	lsr.l		#8,d2
02:00007696 D53900100150    	   177: 	add.b		d2,S19Checksum
02:0000769C E08A            	   178: 	lsr.l		#8,d2
02:0000769E D53900100150    	   179: 	add.b		d2,S19Checksum
02:000076A4 4E75            	   180: 	rts
                            	   181: 
                            	   182: ;------------------------------------------------------------------------------
                            	   183: ; Get a character from auxillary input. Waiting for a character is limited to
                            	   184: ; 32000 tries. If a character is not available within the limit, then a return
                            	   185: ; to the monitor is done.
                            	   186: ;
                            	   187: ;	Parameters:
                            	   188: ;		none
                            	   189: ; Returns:
                            	   190: ;		d1 = character from receive buffer or -1 if no char available
                            	   191: ;------------------------------------------------------------------------------
                            	   192: 
                            	   193: sGetChar:
02:000076A6 48E7A000        	   194: 	movem.l	d0/d2,-(a7)
02:000076AA 343C7D00        	   195: 	move.w	#32000,d2
                            	   196: .0001:
02:000076AE 7024            	   197: 	moveq		#36,d0				; serial get char from buffer
02:000076B0 4E4F            	   198: 	trap		#15
02:000076B2 4A41            	   199: 	tst.w		d1						; was there a char available?
02:000076B4 6A0C            	   200: 	bpl.s		.0002
02:000076B6 51CAFFF6        	   201: 	dbra		d2,.0001			; no - try again
02:000076BA 4CDF0005        	   202: 	movem.l	(a7)+,d0/d2
                            	   203: .0003:
                            	   204: ;	bsr			_KeybdInit
02:000076BE 6000F000        	   205: 	bra			Monitor				; ran out of tries
                            	   206: .0002:
02:000076C2 4CDF0005        	   207: 	movem.l	(a7)+,d0/d2
02:000076C6 0C01001A        	   208: 	cmpi.b	#CTRLZ,d1			; receive end of file?
02:000076CA 67F2            	   209: 	beq			.0003
02:000076CC 4E75            	   210: 	rts
                            	   211: 
                            	   212: 

Source: "boot.x68"
                            	  3155: 	
                            	  3156: AudioInputTest:
02:000076CE 4E75            	  3157: 	rts
                            	  3158: BouncingBalls:
02:000076D0 4E75            	  3159: 	rts
                            	  3160: GraphicsDemo:
02:000076D2 4E75            	  3161: 	rts
                            	  3162: ClearScreen:
02:000076D4 6000E170        	  3163: 	bra		clear_screen
02:000076D8 4E75            	  3164: 	rts
                            	  3165: 
                            	  3166: ;------------------------------------------------------------------------------
                            	  3167: ; Reverse the order of bytes in d1.
                            	  3168: ;------------------------------------------------------------------------------
                            	  3169: 
                            	  3170: rbo:
02:000076DA E159            	  3171: 	rol.w		#8,d1
02:000076DC 4841            	  3172: 	swap		d1
02:000076DE E159            	  3173: 	rol.w		#8,d1
02:000076E0 4E75            	  3174: 	rts
                            	  3175: 
                            	  3176: ;==============================================================================
                            	  3177: ; Serial I/O routines
                            	  3178: ;==============================================================================
                            	  3179: 
                            	  3180: ;------------------------------------------------------------------------------
                            	  3181: ; Initialize the serial port an enhanced 6551 circuit.
                            	  3182: ;
                            	  3183: ; Select internal baud rate clock divider for 9600 baud
                            	  3184: ; Reset fifos, set threshold to 3/4 full on transmit and 3/4 empty on receive
                            	  3185: ; Note that the byte order is swapped.
                            	  3186: ;------------------------------------------------------------------------------
                            	  3187: 
                            	  3188: SerialInit:
02:000076E2 427900100162    	  3189: 	clr.w		SerHeadRcv					; clear receive buffer indexes
02:000076E8 427900100160    	  3190: 	clr.w		SerTailRcv
02:000076EE 423900100164    	  3191: 	clr.b		SerRcvXon						; and Xon,Xoff flags
02:000076F4 423900100165    	  3192: 	clr.b		SerRcvXoff
02:000076FA 203C09000000    	  3193: 	move.l	#$09000000,d0				; dtr,rts active, rxint enabled, no parity
02:00007700 23C0FD060008    	  3194: 	move.l	d0,ACIA+ACIA_CMD
                            	  3195: ;	move.l	#$1E00F700,d0				; fifos enabled
02:00007706 203C1E000000    	  3196: 	move.l	#$1E000000,d0				; fifos disabled
02:0000770C 23C0FD06000C    	  3197: 	move.l	d0,ACIA+ACIA_CTRL
02:00007712 4E75            	  3198: 	rts
                            	  3199: ;	move.l	#$0F000000,d0				; transmit a break for a while
                            	  3200: ;	move.l	d0,ACIA+ACIA_CMD
                            	  3201: ;	move.l	#300000,d2					; wait 100 ms
                            	  3202: ;	bra			.0001
                            	  3203: ;.0003:
                            	  3204: ;	swap		d2
                            	  3205: ;.0001:
                            	  3206: ;	nop
                            	  3207: ;	dbra		d2,.0001
                            	  3208: ;.0002:
                            	  3209: ;	swap		d2
                            	  3210: ;	dbra		d2,.0003
                            	  3211: ;	move.l	#$07000000,d0				; clear break
                            	  3212: ;	move.l	d0,ACIA+ACIA_CMD
                            	  3213: ;	rts
                            	  3214: 	
                            	  3215: ;------------------------------------------------------------------------------
                            	  3216: ; SerialGetChar
                            	  3217: ;
                            	  3218: ; Check the serial port buffer to see if there's a char available. If there's
                            	  3219: ; a char available then return it. If the buffer is almost empty then send an
                            	  3220: ; XON.
                            	  3221: ;
                            	  3222: ; Stack Space:
                            	  3223: ;		2 long words
                            	  3224: ; Parameters:
                            	  3225: ;		none
                            	  3226: ; Modifies:
                            	  3227: ;		d0,a0
                            	  3228: ; Returns:
                            	  3229: ;		d1 = character or -1
                            	  3230: ;------------------------------------------------------------------------------
                            	  3231: 
                            	  3232: SerialGetChar:
02:00007714 2F02            	  3233: 	move.l		d2,-(a7)
02:00007716 4E7A0FE0        	  3234: 	movec			coreno,d0
02:0000771A 4840            	  3235: 	swap			d0
02:0000771C 7202            	  3236: 	moveq			#SERIAL_SEMA,d1
02:0000771E 61008B38        	  3237: 	bsr				LockSemaphore
02:00007722 610000DE        	  3238: 	bsr				SerialRcvCount			; check number of chars in receive buffer
02:00007726 0C400008        	  3239: 	cmpi.w		#8,d0								; less than 8?
02:0000772A 621C            	  3240: 	bhi				.sgc2
02:0000772C 4A3900100164    	  3241: 	tst.b			SerRcvXon						; skip sending XON if already sent
02:00007732 6614            	  3242: 	bne	  		.sgc2            		; XON already sent?
02:00007734 123C0011        	  3243: 	move.b		#XON,d1							; if <8 send an XON
02:00007738 423900100165    	  3244: 	clr.b			SerRcvXoff					; clear XOFF status
02:0000773E 13C100100164    	  3245: 	move.b		d1,SerRcvXon				; flag so we don't send it multiple times
02:00007744 61000098        	  3246: 	bsr				SerialPutChar				; send it
                            	  3247: .sgc2:
02:00007748 323900100162    	  3248: 	move.w		SerHeadRcv,d1				; check if anything is in buffer
02:0000774E B27900100160    	  3249: 	cmp.w			SerTailRcv,d1
02:00007754 6720            	  3250: 	beq				.NoChars						; no?
02:00007756 41F900101000    	  3251: 	lea				SerRcvBuf,a0
02:0000775C 12301000        	  3252: 	move.b		(a0,d1.w),d1				; get byte from buffer
02:00007760 527900100162    	  3253: 	addi.w		#1,SerHeadRcv
02:00007766 02790FFF00100162	  3254: 	andi.w		#$FFF,SerHeadRcv		; 4k wrap around
02:0000776E 0281000000FF    	  3255: 	andi.l		#$FF,d1
02:00007774 6002            	  3256: 	bra				.Xit
                            	  3257: .NoChars:
02:00007776 72FF            	  3258: 	moveq			#-1,d1
                            	  3259: .Xit:
02:00007778 C342            	  3260: 	exg				d1,d2
02:0000777A 4E7A0FE0        	  3261: 	movec			coreno,d0
02:0000777E 4840            	  3262: 	swap			d0
02:00007780 7202            	  3263: 	moveq			#SERIAL_SEMA,d1
02:00007782 61008B10        	  3264: 	bsr				UnlockSemaphore
02:00007786 C541            	  3265: 	exg				d2,d1
02:00007788 241F            	  3266: 	move.l		(a7)+,d2
02:0000778A 4E75            	  3267: 	rts
                            	  3268: 
                            	  3269: ;------------------------------------------------------------------------------
                            	  3270: ; SerialPeekChar
                            	  3271: ;
                            	  3272: ; Check the serial port buffer to see if there's a char available. If there's
                            	  3273: ; a char available then return it. But don't update the buffer indexes. No need
                            	  3274: ; to send an XON here.
                            	  3275: ;
                            	  3276: ; Stack Space:
                            	  3277: ;		0 words
                            	  3278: ; Parameters:
                            	  3279: ;		none
                            	  3280: ; Modifies:
                            	  3281: ;		d0,d2,a0
                            	  3282: ; Returns:
                            	  3283: ;		d1 = character or -1
                            	  3284: ;------------------------------------------------------------------------------
                            	  3285: 
                            	  3286: SerialPeekChar:
02:0000778C 4E7A0FE0        	  3287: 	movec		coreno,d0
02:00007790 4840            	  3288: 	swap		d0
02:00007792 7202            	  3289: 	moveq		#SERIAL_SEMA,d1
02:00007794 61008AC2        	  3290: 	bsr			LockSemaphore
02:00007798 343900100162    	  3291: 	move.w	SerHeadRcv,d2		; check if anything is in buffer
02:0000779E B47900100160    	  3292: 	cmp.w		SerTailRcv,d2
02:000077A4 670C            	  3293: 	beq			.NoChars				; no?
02:000077A6 41F900101000    	  3294: 	lea			SerRcvBuf,a0
02:000077AC 14302000        	  3295: 	move.b	(a0,d2.w),d2		; get byte from buffer
02:000077B0 6002            	  3296: 	bra			.Xit
                            	  3297: .NoChars:
02:000077B2 74FF            	  3298: 	moveq		#-1,d2
                            	  3299: .Xit:
02:000077B4 4E7A0FE0        	  3300: 	movec		coreno,d0
02:000077B8 4840            	  3301: 	swap		d0
02:000077BA 7202            	  3302: 	moveq		#SERIAL_SEMA,d1
02:000077BC 61008A9A        	  3303: 	bsr			LockSemaphore
02:000077C0 3202            	  3304: 	move		d2,d1
02:000077C2 4E75            	  3305: 	rts
                            	  3306: 
                            	  3307: ;------------------------------------------------------------------------------
                            	  3308: ; SerialPeekChar
                            	  3309: ;		Get a character directly from the I/O port. This bypasses the input
                            	  3310: ; buffer.
                            	  3311: ;
                            	  3312: ; Stack Space:
                            	  3313: ;		0 words
                            	  3314: ; Parameters:
                            	  3315: ;		none
                            	  3316: ; Modifies:
                            	  3317: ;		d
                            	  3318: ; Returns:
                            	  3319: ;		d1 = character or -1
                            	  3320: ;------------------------------------------------------------------------------
                            	  3321: 
                            	  3322: SerialPeekCharDirect:
02:000077C4 1239FD060004    	  3323: 	move.b	ACIA+ACIA_STAT,d1	; get serial status
02:000077CA 08010003        	  3324: 	btst		#3,d1							; look for Rx not empty
02:000077CE 670A            	  3325: 	beq.s		.0001
02:000077D0 7200            	  3326: 	moveq.l	#0,d1							; clear upper bits of return value
02:000077D2 1239FD060000    	  3327: 	move.b	ACIA+ACIA_RX,d1		; get data from ACIA
02:000077D8 4E75            	  3328: 	rts												; return
                            	  3329: .0001:
02:000077DA 72FF            	  3330: 	moveq		#-1,d1
02:000077DC 4E75            	  3331: 	rts
                            	  3332: 
                            	  3333: ;------------------------------------------------------------------------------
                            	  3334: ; SerialPutChar
                            	  3335: ;    Put a character to the serial transmitter. This routine blocks until the
                            	  3336: ; transmitter is empty. 
                            	  3337: ;
                            	  3338: ; Stack Space
                            	  3339: ;		0 words
                            	  3340: ; Parameters:
                            	  3341: ;		d1.b = character to put
                            	  3342: ; Modifies:
                            	  3343: ;		none
                            	  3344: ;------------------------------------------------------------------------------
                            	  3345: 
                            	  3346: SerialPutChar:
02:000077DE 48E7C000        	  3347: 	movem.l	d0/d1,-(a7)				; push d0,d1
                            	  3348: .0001:
02:000077E2 1039FD060004    	  3349: 	move.b	ACIA+ACIA_STAT,d0	; wait until the uart indicates tx empty
02:000077E8 08000004        	  3350: 	btst		#4,d0							; bit #4 of the status reg
02:000077EC 67F4            	  3351: 	beq.s		.0001			    		; branch if transmitter is not empty
02:000077EE 13C1FD060000    	  3352: 	move.b	d1,ACIA+ACIA_TX		; send the byte
02:000077F4 4CDF0003        	  3353: 	movem.l	(a7)+,d0/d1				; pop d0,d1
02:000077F8 4E75            	  3354: 	rts
                            	  3355: 	
                            	  3356: ;------------------------------------------------------------------------------
                            	  3357: ; Reverse the order of bytes in d1.
                            	  3358: ;------------------------------------------------------------------------------
                            	  3359: 
                            	  3360: SerialRbo:
02:000077FA E159            	  3361: 	rol.w		#8,d1
02:000077FC 4841            	  3362: 	swap		d1
02:000077FE E159            	  3363: 	rol.w		#8,d1
02:00007800 4E75            	  3364: 	rts
                            	  3365: 
                            	  3366: ;------------------------------------------------------------------------------
                            	  3367: ; Calculate number of character in input buffer
                            	  3368: ;
                            	  3369: ; Returns:
                            	  3370: ;		d0 = number of bytes in buffer.
                            	  3371: ;------------------------------------------------------------------------------
                            	  3372: 
                            	  3373: SerialRcvCount:
02:00007802 303900100160    	  3374: 	move.w	SerTailRcv,d0
02:00007808 907900100162    	  3375: 	sub.w		SerHeadRcv,d0
02:0000780E 6C10            	  3376: 	bge			.0001
02:00007810 303C1000        	  3377: 	move.w	#$1000,d0
02:00007814 907900100162    	  3378: 	sub.w		SerHeadRcv,d0
02:0000781A D07900100160    	  3379: 	add.w		SerTailRcv,d0
                            	  3380: .0001:
02:00007820 4E75            	  3381: 	rts
                            	  3382: 
                            	  3383: ;------------------------------------------------------------------------------
                            	  3384: ; Serial IRQ routine
                            	  3385: ;
                            	  3386: ; Keeps looping as long as it finds characters in the ACIA recieve buffer/fifo.
                            	  3387: ; Received characters are buffered. If the buffer becomes full, new characters
                            	  3388: ; will be lost.
                            	  3389: ;
                            	  3390: ; Parameters:
                            	  3391: ;		none
                            	  3392: ; Modifies:
                            	  3393: ;		none
                            	  3394: ; Returns:
                            	  3395: ;		d1 = -1 if IRQ handled, otherwise zero
                            	  3396: ;------------------------------------------------------------------------------
                            	  3397: 
                            	  3398: SerialIRQ:
02:00007822 46FC2300        	  3399: 	move.w	#$2300,sr						; disable lower level IRQs
02:00007826 48E7E080        	  3400: 	movem.l	d0/d1/d2/a0,-(a7)
02:0000782A 4E7A0FE0        	  3401: 	movec		coreno,d0
02:0000782E 4840            	  3402: 	swap		d0
02:00007830 7202            	  3403: 	moveq		#SERIAL_SEMA,d1
02:00007832 61008A24        	  3404: 	bsr			LockSemaphore
                            	  3405: sirqNxtByte:
02:00007836 1239FD060004    	  3406: 	move.b	ACIA+ACIA_STAT,d1		; check the status
02:0000783C 08010003        	  3407: 	btst		#3,d1								; bit 3 = rx full
02:00007840 6756            	  3408: 	beq			notRxInt
02:00007842 1239FD060000    	  3409: 	move.b	ACIA+ACIA_RX,d1
                            	  3410: sirq0001:
02:00007848 303900100160    	  3411: 	move.w	SerTailRcv,d0				; check if recieve buffer full
02:0000784E 5240            	  3412: 	addi.w	#1,d0
02:00007850 02400FFF        	  3413: 	andi.w	#$FFF,d0
02:00007854 B07900100162    	  3414: 	cmp.w		SerHeadRcv,d0
02:0000785A 673C            	  3415: 	beq			sirqRxFull
02:0000785C 33C000100160    	  3416: 	move.w	d0,SerTailRcv				; update tail pointer
02:00007862 5340            	  3417: 	subi.w	#1,d0								; backup
02:00007864 02400FFF        	  3418: 	andi.w	#$FFF,d0
02:00007868 41F900101000    	  3419: 	lea			SerRcvBuf,a0				; a0 = buffer address
02:0000786E 11810000        	  3420: 	move.b	d1,(a0,d0.w)				; store recieved byte in buffer
02:00007872 4A3900100165    	  3421: 	tst.b		SerRcvXoff					; check if xoff already sent
02:00007878 66BC            	  3422: 	bne			sirqNxtByte
02:0000787A 6186            	  3423: 	bsr			SerialRcvCount			; if more than 4080 chars in buffer
02:0000787C 0C400FF0        	  3424: 	cmpi.w	#4080,d0
02:00007880 65B4            	  3425: 	blo			sirqNxtByte
02:00007882 123C0013        	  3426: 	move.b	#XOFF,d1						; send an XOFF
02:00007886 423900100164    	  3427: 	clr.b		SerRcvXon						; clear XON status
02:0000788C 13C100100165    	  3428: 	move.b	d1,SerRcvXoff				; set XOFF status
02:00007892 6100FF4A        	  3429: 	bsr			SerialPutChar				; send XOFF
02:00007896 609E            	  3430: 	bra			sirqNxtByte     		; check the status for another byte
                            	  3431: sirqRxFull:
                            	  3432: notRxInt:
02:00007898 4E7A0FE0        	  3433: 	movec		coreno,d0
02:0000789C 4840            	  3434: 	swap		d0
02:0000789E 7202            	  3435: 	moveq		#SERIAL_SEMA,d1
02:000078A0 610089F2        	  3436: 	bsr			UnlockSemaphore
02:000078A4 4CDF0107        	  3437: 	movem.l	(a7)+,d0/d1/d2/a0
02:000078A8 4E73            	  3438: 	rte
                            	  3439: 
                            	  3440: nmeSerial:
02:000078AA 53657269616C    	  3441: 	dc.b		"Serial",0
02:000078B0 00
                            	  3442: 
                            	  3443: ;===============================================================================
                            	  3444: ; Generic I2C routines
                            	  3445: ;===============================================================================
                            	  3446: 
                            	  3447: 	even
                            	  3448: ; i2c
                            	  3449: i2c_setup:
                            	  3450: ;		lea		I2C,a6				
                            	  3451: ;		move.w	#19,I2C_PREL(a6)	; setup prescale for 400kHz clock
                            	  3452: ;		move.w	#0,I2C_PREH(a6)
                            	  3453: init_i2c:
02:000078B2 4DF9FD069000    	  3454: 	lea	I2C2,a6				
02:000078B8 1CBC0013        	  3455: 	move.b #19,I2C_PREL(a6)	; setup prescale for 400kHz clock, 40MHz master
02:000078BC 422E0001        	  3456: 	move.b #0,I2C_PREH(a6)
02:000078C0 4E75            	  3457: 	rts
                            	  3458: 
                            	  3459: ; Wait for I2C transfer to complete
                            	  3460: ;
                            	  3461: ; Parameters
                            	  3462: ; 	a6 - I2C controller base address
                            	  3463: 
                            	  3464: i2c_wait_tip:
02:000078C2 2F00            	  3465: 	move.l d0,-(a7)
                            	  3466: .0001				
02:000078C4 102E0004        	  3467: 	move.b I2C_STAT(a6),d0		; wait for tip to clear
02:000078C8 08000001        	  3468: 	btst #1,d0
02:000078CC 66F6            	  3469: 	bne.s	.0001
02:000078CE 201F            	  3470: 	move.l (a7)+,d0
02:000078D0 4E75            	  3471: 	rts
                            	  3472: 
                            	  3473: ; Parameters
                            	  3474: ;	d0.b - data to transmit
                            	  3475: ;	d1.b - command value
                            	  3476: ;	a6	 - I2C controller base address
                            	  3477: ;
                            	  3478: i2c_wr_cmd:
02:000078D2 1D400003        	  3479: 	move.b d0,I2C_TXR(a6)
02:000078D6 1D410004        	  3480: 	move.b d1,I2C_CMD(a6)
02:000078DA 61E6            	  3481: 	bsr	i2c_wait_tip
02:000078DC 102E0004        	  3482: 	move.b I2C_STAT(a6),d0
02:000078E0 4E75            	  3483: 	rts
                            	  3484: 
                            	  3485: i2c_xmit1:
02:000078E2 2F00            	  3486: 	move.l d0,-(a7)
02:000078E4 1D7C00010002    	  3487: 	move.b #1,I2C_CTRL(a6)		; enable the core
02:000078EA 7076            	  3488: 	moveq	#$76,d0				; set slave address = %0111011
02:000078EC 323C0090        	  3489: 	move.w #$90,d1				; set STA, WR
02:000078F0 61E0            	  3490: 	bsr i2c_wr_cmd
02:000078F2 610C            	  3491: 	bsr	i2c_wait_rx_nack
02:000078F4 201F            	  3492: 	move.l (a7)+,d0
02:000078F6 323C0050        	  3493: 	move.w #$50,d1				; set STO, WR
02:000078FA 61D6            	  3494: 	bsr i2c_wr_cmd
02:000078FC 61000002        	  3495: 	bsr	i2c_wait_rx_nack
                            	  3496: 
                            	  3497: i2c_wait_rx_nack:
02:00007900 2F00            	  3498: 	move.l d0,-(a7)
                            	  3499: .0001						
02:00007902 102E0004        	  3500: 	move.b I2C_STAT(a6),d0		; wait for RXack = 0
02:00007906 08000007        	  3501: 	btst #7,d0
02:0000790A 66F6            	  3502: 	bne.s	.0001
02:0000790C 201F            	  3503: 	move.l (a7)+,d0
02:0000790E 4E75            	  3504: 	rts
                            	  3505: 
                            	  3506: ;===============================================================================
                            	  3507: ; Realtime clock routines
                            	  3508: ;===============================================================================
                            	  3509: 
                            	  3510: rtc_read:
02:00007910 2C7CFD069000    	  3511: 	movea.l	#I2C2,a6
02:00007916 4BF900100200    	  3512: 	lea	RTCBuf,a5
02:0000791C 1D7C00800002    	  3513: 	move.b	#$80,I2C_CTRL(a6)	; enable I2C
02:00007922 103C00DE        	  3514: 	move.b	#$DE,d0				; read address, write op
02:00007926 123C0090        	  3515: 	move.b	#$90,d1				; STA + wr bit
02:0000792A 61A6            	  3516: 	bsr	i2c_wr_cmd
02:0000792C 4A00            	  3517: 	tst.b	d0
02:0000792E 6B66            	  3518: 	bmi	.rxerr
02:00007930 4200            	  3519: 	move.b #$00,d0				; address zero
02:00007932 123C0010        	  3520: 	move.b #$10,d1				; wr bit
02:00007936 619A            	  3521: 	bsr	i2c_wr_cmd
02:00007938 4A00            	  3522: 	tst.b	d0
02:0000793A 6B5A            	  3523: 	bmi	.rxerr
02:0000793C 103C00DF        	  3524: 	move.b #$DF,d0				; read address, read op
02:00007940 123C0090        	  3525: 	move.b #$90,d1				; STA + wr bit
02:00007944 618C            	  3526: 	bsr i2c_wr_cmd
02:00007946 4A00            	  3527: 	tst.b	d0
02:00007948 6B4C            	  3528: 	bmi	.rxerr
                            	  3529: 		
02:0000794A 343C0020        	  3530: 	move.w #$20,d2
                            	  3531: .0001
02:0000794E 1D7C00200004    	  3532: 	move.b #$20,I2C_CMD(a6)	; rd bit
02:00007954 6100FF6C        	  3533: 	bsr	i2c_wait_tip
02:00007958 61A6            	  3534: 	bsr	i2c_wait_rx_nack
02:0000795A 102E0004        	  3535: 	move.b I2C_STAT(a6),d0
02:0000795E 4A00            	  3536: 	tst.b	d0
02:00007960 6B34            	  3537: 	bmi	.rxerr
02:00007962 102E0003        	  3538: 	move.b I2C_RXR(a6),d0
02:00007966 1B802000        	  3539: 	move.b d0,(a5,d2.w)
02:0000796A 5242            	  3540: 	addi.w #1,d2
02:0000796C 0C42005F        	  3541: 	cmpi.w #$5F,d2
02:00007970 66DC            	  3542: 	bne	.0001
02:00007972 1D7C00680004    	  3543: 	move.b #$68,I2C_CMD(a6)	; STO, rd bit + nack
02:00007978 6100FF48        	  3544: 	bsr i2c_wait_tip
02:0000797C 6182            	  3545: 	bsr i2c_wait_rx_nack
02:0000797E 102E0004        	  3546: 	move.b I2C_STAT(a6),d0
02:00007982 4A00            	  3547: 	tst.b	d0
02:00007984 6B10            	  3548: 	bmi	.rxerr
02:00007986 102E0003        	  3549: 	move.b I2C_RXR(a6),d0
02:0000798A 1B802000        	  3550: 	move.b d0,(a5,d2.w)
02:0000798E 422E0002        	  3551: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
02:00007992 7000            	  3552: 	moveq	#0,d0
02:00007994 4E75            	  3553: 	rts
                            	  3554: .rxerr
02:00007996 422E0002        	  3555: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
02:0000799A 4E75            	  3556: 	rts
                            	  3557: 
                            	  3558: rtc_write:
02:0000799C 2C7CFD069000    	  3559: 	movea.l	#I2C2,a6
02:000079A2 4BF900100200    	  3560: 	lea	RTCBuf,a5
02:000079A8 1D7C00800002    	  3561: 	move.b #$80,I2C_CTRL(a6)	; enable I2C
02:000079AE 103C00DE        	  3562: 	move.b #$DE,d0				; read address, write op
02:000079B2 123C0090        	  3563: 	move.b #$90,d1				; STA + wr bit
02:000079B6 6100FF1A        	  3564: 	bsr	i2c_wr_cmd
02:000079BA 4A00            	  3565: 	tst.b	d0
02:000079BC 6B42            	  3566: 	bmi	.rxerr
02:000079BE 4200            	  3567: 	move.b #$00,d0				; address zero
02:000079C0 123C0010        	  3568: 	move.b #$10,d1				; wr bit
02:000079C4 6100FF0C        	  3569: 	bsr	i2c_wr_cmd
02:000079C8 4A00            	  3570: 	tst.b	d0
02:000079CA 6B34            	  3571: 	bmi	.rxerr
02:000079CC 343C0020        	  3572: 	move.w #$20,d2
                            	  3573: .0001
02:000079D0 10352000        	  3574: 	move.b (a5,d2.w),d0
02:000079D4 123C0010        	  3575: 	move.b #$10,d1
02:000079D8 6100FEF8        	  3576: 	bsr	i2c_wr_cmd
02:000079DC 4A00            	  3577: 	tst.b	d0
02:000079DE 6B20            	  3578: 	bmi	.rxerr
02:000079E0 5242            	  3579: 	addi.w #1,d2
02:000079E2 0C42005F        	  3580: 	cmpi.w #$5F,d2
02:000079E6 66E8            	  3581: 	bne.s	.0001
02:000079E8 10352000        	  3582: 	move.b (a5,d2.w),d0
02:000079EC 123C0050        	  3583: 	move.b #$50,d1				; STO, wr bit
02:000079F0 6100FEE0        	  3584: 	bsr	i2c_wr_cmd
02:000079F4 4A00            	  3585: 	tst.b	d0
02:000079F6 6B08            	  3586: 	bmi	.rxerr
02:000079F8 422E0002        	  3587: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
02:000079FC 7000            	  3588: 	moveq	#0,d0
02:000079FE 4E75            	  3589: 	rts
                            	  3590: .rxerr:
02:00007A00 422E0002        	  3591: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
02:00007A04 4E75            	  3592: 	rts
                            	  3593: 
                            	  3594: msgRtcReadFail:
02:00007A06 5254432072656164	  3595: 	dc.b	"RTC read/write failed.",$0A,$0D,$00
02:00007A0E 2F77726974652066
02:00007A16 61696C65642E
02:00007A1C 0A
02:00007A1D 0D
02:00007A1E 00
                            	  3596: 
                            	  3597: 	even
                            	  3598: 
                            	  3599: ;------------------------------------------------------------------------------
                            	  3600: ;------------------------------------------------------------------------------
                            	  3601: 	even
                            	  3602: 
                            	  3603: bus_err:
                            	  3604: .0001:
02:00007A20 4E71            	  3605: 	nop
02:00007A22 60FC            	  3606: 	bra			.0001
                            	  3607: 
                            	  3608: trap3:
                            	  3609: 	; First save all registers
02:00007A24 48F9FFFF00040100	  3610: 	movem.l		d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
02:00007A2C 33DF00040140    	  3611: 	move.w		(a7)+,Regsave+$40
02:00007A32 23DF00040144    	  3612: 	move.l		(a7)+,Regsave+$44
02:00007A38 2E7C00040FFC    	  3613: 	move.l		#$40FFC,a7			; reset stack pointer
02:00007A3E 46FC2500        	  3614: 	move.w		#$2500,sr				; enable interrupts
02:00007A42 303900040202    	  3615: 	move.w		NumSetBreakpoints,d0
02:00007A48 5340            	  3616: 	subi.w		#1,d0
02:00007A4A 41F900040220    	  3617: 	lea				Breakpoints,a0
02:00007A50 223900040144    	  3618: 	move.l		Regsave+$44,d1
                            	  3619: .0001:
02:00007A56 B298            	  3620: 	cmp.l			(a0)+,d1
02:00007A58 6708            	  3621: 	beq.s			ProcessBreakpoint
02:00007A5A 51C8FFFA        	  3622: 	dbra			d0,.0001
02:00007A5E 6000EC60        	  3623: 	bra				Monitor					; not a breakpoint
                            	  3624: ProcessBreakpoint:
02:00007A62 6104            	  3625: 	bsr				DisarmAllBreakpoints
02:00007A64 6000F2A4        	  3626: 	bra				cmdDumpRegs
                            	  3627: 
                            	  3628: ;------------------------------------------------------------------------------
                            	  3629: ; DisarmAllBreakpoints, used when entering the monitor.
                            	  3630: ;------------------------------------------------------------------------------
                            	  3631: 
                            	  3632: DisarmAllBreakpoints:
02:00007A68 48E780E0        	  3633: 	movem.l	d0/a0/a1/a2,-(a7)			; stack some regs
02:00007A6C 303900040202    	  3634: 	move.w	NumSetBreakpoints,d0	; d0 = number of breakpoints that are set
02:00007A72 0C400008        	  3635: 	cmpi.w	#numBreakpoints,d0		; check for valid number
02:00007A76 641A            	  3636: 	bhs.s		.0001
02:00007A78 45F900040220    	  3637: 	lea			Breakpoints,a2				; a2 = pointer to breakpoint address table
02:00007A7E 41F900040280    	  3638: 	lea			BreakpointWords,a0		; a0 = pointer to breakpoint instruction word table
02:00007A84 6004            	  3639: 	bra.s		.0003									; enter loop at bottom
                            	  3640: .0002:
02:00007A86 225A            	  3641: 	move.l	(a2)+,a1							; a1 = address of breakpoint
02:00007A88 3298            	  3642: 	move.w	(a0)+,(a1)						; copy instruction word back to code
                            	  3643: .0003:
02:00007A8A 51C8FFFA        	  3644: 	dbra		d0,.0002
02:00007A8E 4CDF0701        	  3645: 	movem.l	(a7)+,d0/a0/a1/a2			; restore regs
                            	  3646: .0001:
02:00007A92 4E75            	  3647: 	rts	
                            	  3648: 
                            	  3649: ;------------------------------------------------------------------------------
                            	  3650: ; ArmAllBreakpoints, used when entering the monitor.
                            	  3651: ;------------------------------------------------------------------------------
                            	  3652: 
                            	  3653: ArmAllBreakpoints:
02:00007A94 48E780E0        	  3654: 	movem.l		d0/a0/a1/a2,-(a7)			; stack some regs
02:00007A98 303900040202    	  3655: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
02:00007A9E 0C400008        	  3656: 	cmpi.w		#numBreakpoints,d0		; is the number valid?
02:00007AA2 641E            	  3657: 	bhs.s			.0001
02:00007AA4 45F900040220    	  3658: 	lea				Breakpoints,a2				; a2 = pointer to breakpoint address table
02:00007AAA 41F900040280    	  3659: 	lea				BreakpointWords,a0		; a0 = pointer to instruction word table
02:00007AB0 6008            	  3660: 	bra.s			.0003									; enter loop at bottom
                            	  3661: .0002:
02:00007AB2 225A            	  3662: 	move.l		(a2)+,a1							; a1 = address of breakpoint
02:00007AB4 3091            	  3663: 	move.w		(a1),(a0)							; copy instruction word to table
02:00007AB6 30FC4E43        	  3664: 	move.w		#$4E43,(a0)+					; set instruction = TRAP3
                            	  3665: .0003:
02:00007ABA 51C8FFF6        	  3666: 	dbra			d0,.0002
02:00007ABE 4CDF0701        	  3667: 	movem.l		(a7)+,d0/a0/a1/a2			; restore regs
                            	  3668: .0001:
02:00007AC2 4E75            	  3669: 	rts	
                            	  3670: 
                            	  3671: ;------------------------------------------------------------------------------
                            	  3672: ;------------------------------------------------------------------------------
                            	  3673: 
                            	  3674: ArmBreakpoint:
02:00007AC4 48E7E0E0        	  3675: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
02:00007AC8 303900040202    	  3676: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
02:00007ACE 0C400008        	  3677: 	cmpi.w		#numBreakpoints,d0		; check if too many
02:00007AD2 645A            	  3678: 	bhs.s			.0001
02:00007AD4 527900040202    	  3679: 	addi.w		#1,NumSetBreakpoints	; increment number of breakpoints
02:00007ADA 2400            	  3680: 	move.l		d0,d2
02:00007ADC 6100F11E        	  3681: 	bsr				ignBlanks
02:00007AE0 6100F2F2        	  3682: 	bsr				GetHexNumber
02:00007AE4 6748            	  3683: 	beq.s			.0001									; was there an address?
02:00007AE6 08010000        	  3684: 	btst			#0,d1									; address value must be even
02:00007AEA 6642            	  3685: 	bne.s			.0001
                            	  3686: 	; See if the breakpoint is in the table already
02:00007AEC 43F900040220    	  3687: 	lea				Breakpoints,a1				; a1 points to breakpoint table
02:00007AF2 343C0007        	  3688: 	move.w		#numBreakpoints-1,d2
                            	  3689: .0002:
02:00007AF6 B299            	  3690: 	cmp.l			(a1)+,d1
02:00007AF8 673A            	  3691: 	beq.s			.0003									; breakpoint is in table already
02:00007AFA 51CAFFFA        	  3692: 	dbra			d2,.0002
                            	  3693: 	; Add breakpoint to table
                            	  3694: 	; Search for empty entry
02:00007AFE 43F900040220    	  3695: 	lea				Breakpoints,a1				; a1 = pointer to breakpoint address table
02:00007B04 4242            	  3696: 	clr.w			d2										; d2 = count
                            	  3697: .0006:
02:00007B06 4A91            	  3698: 	tst.l			(a1)									; is the entry empty?
02:00007B08 670C            	  3699: 	beq.s			.0005									; branch if found empty entry
02:00007B0A 5889            	  3700: 	lea				4(a1),a1							; point to next entry
02:00007B0C 5242            	  3701: 	addi.w		#1,d2									; increment count
02:00007B0E 0C420008        	  3702: 	cmpi.w		#numBreakpoints,d2		; safety: check against max number
02:00007B12 65F2            	  3703: 	blo.s			.0006
02:00007B14 6018            	  3704: 	bra.s			.0001									; what? no empty entries found, table corrupt?
                            	  3705: .0005:
02:00007B16 E542            	  3706: 	asl.w			#2,d2									; d2 = long word index
02:00007B18 23812000        	  3707: 	move.l		d1,(a1,d2.w)					; move breakpoint address to table
02:00007B1C 2441            	  3708: 	move.l		d1,a2
02:00007B1E E24A            	  3709: 	lsr.w			#1,d2									; d2 = word index
                            	  3710: .0004:
02:00007B20 43F900040280    	  3711: 	lea				BreakpointWords,a1
02:00007B26 33922000        	  3712: 	move.w		(a2),(a1,d2.w)				; copy instruction word to table
02:00007B2A 34BC4E43        	  3713: 	move.w		#$4E43,(a2)						; replace word with TRAP3
                            	  3714: .0001:
02:00007B2E 4CDF0707        	  3715: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
02:00007B32 4E75            	  3716: 	rts
                            	  3717: .0003:
02:00007B34 2469FFFC        	  3718: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
02:00007B38 0C524E43        	  3719: 	cmpi.w		#$4E43,(a2)						; see if breakpoint already armed
02:00007B3C 67F0            	  3720: 	beq.s			.0001
02:00007B3E D482            	  3721: 	asl.l			#1,d2									; d2 = word index
02:00007B40 60DE            	  3722: 	bra.s			.0004
                            	  3723: 
                            	  3724: 
                            	  3725: ;------------------------------------------------------------------------------
                            	  3726: ;------------------------------------------------------------------------------
                            	  3727: 
                            	  3728: DisarmBreakpoint:
02:00007B42 48E7E0E0        	  3729: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
02:00007B46 303900040202    	  3730: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
02:00007B4C 0C400008        	  3731: 	cmpi.w		#numBreakpoints,d0		; check if too many
02:00007B50 623E            	  3732: 	bhi.s			.0001
02:00007B52 2400            	  3733: 	move.l		d0,d2
02:00007B54 6100F0A6        	  3734: 	bsr				ignBlanks
02:00007B58 6100F27A        	  3735: 	bsr				GetHexNumber
02:00007B5C 6732            	  3736: 	beq.s			.0001									; was there an address?
02:00007B5E 08010000        	  3737: 	btst			#0,d1									; address value must be even
02:00007B62 662C            	  3738: 	bne.s			.0001
                            	  3739: 	; See if the breakpoint is in the table already
02:00007B64 43F900040220    	  3740: 	lea				Breakpoints,a1				; a1 points to breakpoint table
02:00007B6A 5342            	  3741: 	subi.w		#1,d2
                            	  3742: .0002:
02:00007B6C B299            	  3743: 	cmp.l			(a1)+,d1
02:00007B6E 6706            	  3744: 	beq.s			.0003									; breakpoint is in table already
02:00007B70 51CAFFFA        	  3745: 	dbra			d2,.0002
02:00007B74 601A            	  3746: 	bra				.0001									; breakpoint was not in table
                            	  3747: .0003:
                            	  3748: 	; Remove breakpoint from table
02:00007B76 537900040202    	  3749: 	subi.w		#1,NumSetBreakpoints	; decrement number of breakpoints
02:00007B7C 2469FFFC        	  3750: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
02:00007B80 42A9FFFC        	  3751: 	clr.l			-4(a1)								; empty out breakpoint
02:00007B84 43F900040280    	  3752: 	lea				BreakpointWords,a1
02:00007B8A D482            	  3753: 	asl.l			#1,d2									; d2 = word index
02:00007B8C 34B12000        	  3754: 	move.w		(a1,d2.w),(a2)				; copy instruction from table back to code
                            	  3755: .0001:
02:00007B90 4CDF0707        	  3756: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
02:00007B94 4E75            	  3757: 	rts
                            	  3758: 
                            	  3759: ;------------------------------------------------------------------------------
                            	  3760: ;------------------------------------------------------------------------------
                            	  3761: 
                            	  3762: ListBreakpoints:
02:00007B96 6100DCF2        	  3763: 	bsr			CRLF
02:00007B9A 343C0008        	  3764: 	move.w	#numBreakpoints,d2
02:00007B9E 43F900040220    	  3765: 	lea			Breakpoints,a1
                            	  3766: .0001:
02:00007BA4 2219            	  3767: 	move.l	(a1)+,d1
02:00007BA6 6100F80C        	  3768: 	bsr			DisplayTetra
02:00007BAA 6100DCDE        	  3769: 	bsr			CRLF
02:00007BAE 51CAFFF4        	  3770: 	dbra		d2,.0001
02:00007BB2 6000EB0C        	  3771: 	bra			Monitor
                            	  3772: 
                            	  3773: ;------------------------------------------------------------------------------
                            	  3774: ;------------------------------------------------------------------------------
                            	  3775: 
                            	  3776: ClearBreakpointList:
02:00007BB6 343C0008        	  3777: 	move.w	#numBreakpoints,d2
02:00007BBA 43F900040220    	  3778: 	lea			Breakpoints,a1
                            	  3779: .0001:
02:00007BC0 4299            	  3780: 	clr.l		(a1)+
02:00007BC2 51CAFFFC        	  3781: 	dbra		d2,.0001
02:00007BC6 4E75            	  3782: 	rts
                            	  3783: 
                            	  3784: ;------------------------------------------------------------------------------
                            	  3785: ; SendMsg
                            	  3786: ; 00100xy0
                            	  3787: ;
                            	  3788: ; Parameters:
                            	  3789: ;		d1 = target core number
                            	  3790: ;		d2 = argument 1
                            	  3791: ;		d3 = argument 2
                            	  3792: ;		d4 = argument 3
                            	  3793: ;
                            	  3794: ;------------------------------------------------------------------------------
                            	  3795: 
                            	  3796: SendMsg:
02:00007BC8 48E70440        	  3797: 	movem.l	d5/a1,-(a7)
02:00007BCC E149            	  3798: 	lsl.w		#8,d1
02:00007BCE 4E7A5FE0        	  3799: 	movec		coreno,d5
02:00007BD2 E94D            	  3800: 	lsl.w		#4,d5
02:00007BD4 8245            	  3801: 	or.w		d5,d1
02:00007BD6 43F900100000    	  3802: 	lea			$00100000,a1
02:00007BDC 4AB11000        	  3803: 	tst.l		0(a1,d1.w)
02:00007BE0 661C            	  3804: 	bne			.msgFull
02:00007BE2 4E7A5FE0        	  3805: 	movec		coreno,d5
02:00007BE6 23851000        	  3806: 	move.l	d5,0(a1,d1.w)
02:00007BEA 23821004        	  3807: 	move.l	d2,4(a1,d1.w)
02:00007BEE 23831008        	  3808: 	move.l	d3,8(a1,d1.w)
02:00007BF2 2384100C        	  3809: 	move.l	d4,12(a1,d1.w)
02:00007BF6 4CDF0220        	  3810: 	movem.l	(a7)+,d5/a1
02:00007BFA 7200            	  3811: 	moveq		#0,d1
02:00007BFC 4E75            	  3812: 	rts
                            	  3813: .msgFull:
02:00007BFE 4CDF0220        	  3814: 	movem.l	(a7)+,d5/a1
02:00007C02 72FF            	  3815: 	moveq		#-1,d1
02:00007C04 4E75            	  3816: 	rts
                            	  3817: 
                            	  3818: ;------------------------------------------------------------------------------
                            	  3819: ; ReceiveMsg
                            	  3820: ;		Scan the message table for messages and dispatch them.
                            	  3821: ; 00100xy0
                            	  3822: ;
                            	  3823: ; Parameters:
                            	  3824: ;------------------------------------------------------------------------------
                            	  3825: 
                            	  3826: ReceiveMsg:
02:00007C06 48E77F40        	  3827: 	movem.l		d1/d2/d3/d4/d5/d6/d7/a1,-(a7)
02:00007C0A 43F900100000    	  3828: 	lea				$00100000,a1
02:00007C10 4E7A5FE0        	  3829: 	movec			coreno,d5
02:00007C14 E14D            	  3830: 	lsl.w			#8,d5
02:00007C16 7C02            	  3831: 	moveq			#2,d6
                            	  3832: .nextCore:
02:00007C18 3E06            	  3833: 	move.w		d6,d7
02:00007C1A E94F            	  3834: 	lsl.w			#4,d7
02:00007C1C DE45            	  3835: 	add.w			d5,d7
02:00007C1E 4AB17000        	  3836: 	tst.l			0(a1,d7.w)			; Is there a message from core d6?
02:00007C22 6716            	  3837: 	beq.s			.noMsg
02:00007C24 22317000        	  3838: 	move.l		0(a1,d7.w),d1
02:00007C28 24317004        	  3839: 	move.l		4(a1,d7.w),d2
02:00007C2C 26317008        	  3840: 	move.l		8(a1,d7.w),d3
02:00007C30 2831700C        	  3841: 	move.l		12(a1,d7.w),d4
02:00007C34 42B17000        	  3842: 	clr.l			0(a1,d7.w)			; indicate message was received
02:00007C38 610E            	  3843: 	bsr				DispatchMsg
                            	  3844: .noMsg:
02:00007C3A 5246            	  3845: 	addq			#1,d6
02:00007C3C BC7C0009        	  3846: 	cmp.w			#9,d6
02:00007C40 63D6            	  3847: 	bls				.nextCore
02:00007C42 4CDF02FE        	  3848: 	movem.l		(a7)+,d1/d2/d3/d4/d5/d6/d7/a1
02:00007C46 4E75            	  3849: 	rts
                            	  3850: 
                            	  3851: ;------------------------------------------------------------------------------
                            	  3852: ;------------------------------------------------------------------------------
                            	  3853: 
                            	  3854: DispatchMsg:
02:00007C48 4E75            	  3855: 	rts
                            	  3856: 
                            	  3857: ;------------------------------------------------------------------------------
                            	  3858: ; Trap #15, function 39 - convert floating-point to string and display
                            	  3859: ;
                            	  3860: ; Parameters
                            	  3861: ;		a1 = pointer to buffer
                            	  3862: ;		fp0 = number to print
                            	  3863: ;		d1 = width of print field
                            	  3864: ;		d2 = precision
                            	  3865: ;		d3 = 'E' or 'e'
                            	  3866: ;------------------------------------------------------------------------------
                            	  3867: 
                            	  3868: prtflt:
02:00007C4A 4E52FFD0        	  3869: 	link a2,#-48
02:00007C4E 2F7900040098002C	  3870: 	move.l _canary,44(sp)
02:00007C56 48D7074F        	  3871: 	movem.l d0/d1/d2/d3/d6/a0/a1/a2,(sp)
02:00007C5A F22F68000020    	  3872: 	fmove.x fp0,32(sp)
02:00007C60 2049            	  3873: 	move.l a1,a0						; a0 = pointer to buffer to use
02:00007C62 13C100040508    	  3874: 	move.b d1,_width
02:00007C68 23C200040514    	  3875: 	move.l d2,_precision
02:00007C6E 13C30004050C    	  3876: 	move.b d3,_E
02:00007C74 6100F4BA        	  3877: 	bsr _FloatToString
02:00007C78 6100DED8        	  3878: 	bsr DisplayString
02:00007C7C F22F48000020    	  3879: 	fmove.x 32(sp),fp0
02:00007C82 4CD7074F        	  3880: 	movem.l (sp),d0/d1/d2/d3/d6/a0/a1/a2
02:00007C86 A2AF0003002C    	  3881: 	cchk 44(sp)
02:00007C8C 4E5A            	  3882: 	unlk a2
02:00007C8E 4E75            	  3883: 	rts
                            	  3884: 
                            	  3885: T15FloatToString:
02:00007C90 4E52FFD4        	  3886: 	link a2,#-44
02:00007C94 2F79000400980028	  3887: 	move.l _canary,40(sp)
02:00007C9C 48D7034F        	  3888: 	movem.l d0/d1/d2/d3/d6/a0/a1,(sp)
02:00007CA0 F22F6800001C    	  3889: 	fmove.x fp0,28(sp)
02:00007CA6 2049            	  3890: 	move.l a1,a0						; a0 = pointer to buffer to use
02:00007CA8 13C100040508    	  3891: 	move.b d1,_width
02:00007CAE 23C200040514    	  3892: 	move.l d2,_precision
02:00007CB4 13C30004050C    	  3893: 	move.b d3,_E
02:00007CBA 6100F474        	  3894: 	bsr _FloatToString
02:00007CBE F22F4800001C    	  3895: 	fmove.x 28(sp),fp0
02:00007CC4 4CD7034F        	  3896: 	movem.l (sp),d0/d1/d2/d3/d6/a0/a1
02:00007CC8 A2AF00030028    	  3897: 	cchk 40(sp)
02:00007CCE 4E5A            	  3898: 	unlk a2
02:00007CD0 4E75            	  3899: 	rts
                            	  3900: 
                            	  3901: ;==============================================================================
                            	  3902: ;==============================================================================
                            	  3903: 
                            	  3904: OutputChar:
02:00007CD2 0C390001000400A8	  3905: 	cmpi.b #1,OutputDevice	; stdout
02:00007CDA 6604            	  3906: 	bne .0001
02:00007CDC 6000DBF6        	  3907: 	bra DisplayChar
                            	  3908: .0001
02:00007CE0 0C390002000400A8	  3909: 	cmpi.b #2,OutputDevice
02:00007CE8 6604            	  3910: 	bne .0002
02:00007CEA 6000FAF2        	  3911: 	bra	SerialPutChar
                            	  3912: .0002
02:00007CEE 4E75            	  3913: 	rts
                            	  3914: 
                            	  3915: ;------------------------------------------------------------------------------
                            	  3916: ;------------------------------------------------------------------------------
                            	  3917: 
                            	  3918: InitIRQ:
02:00007CF0 7006            	  3919: 	moveq		#6,d0
02:00007CF2 41FAE58C        	  3920: 	lea			KeybdIRQ,a0
02:00007CF6 610C            	  3921: 	bsr			InstallIRQ
02:00007CF8 41FA003A        	  3922: 	lea			TickIRQ,a0
02:00007CFC 6106            	  3923: 	bsr			InstallIRQ
02:00007CFE 7003            	  3924: 	moveq		#3,d0
02:00007D00 41FAFB20        	  3925: 	lea			SerialIRQ,a0
                            	  3926: 	; fall through
                            	  3927: 
                            	  3928: ;------------------------------------------------------------------------------
                            	  3929: ; Install an IRQ handler.
                            	  3930: ;
                            	  3931: ; Parameters:
                            	  3932: ;		d0 = IRQ level
                            	  3933: ;		a0 = pointer to IRQ routine
                            	  3934: ; Returns:
                            	  3935: ;		d1 = -1 if successfully added, 0 otherwise
                            	  3936: ;		nf = 1, zf = 0 if successfully added, otherwise nf = 0, zf = 1
                            	  3937: ;------------------------------------------------------------------------------
                            	  3938: 
                            	  3939: InstallIRQ:
02:00007D04 2F00            	  3940: 	move.l	d0,-(a7)					; save working register
02:00007D06 43F80400        	  3941: 	lea			InstalledIRQ,a1		; a1 points to installed IRQ list
02:00007D0A EB48            	  3942: 	lsl.w		#5,d0							; multiply by 8 long words per IRQ level
                            	  3943: .nextSpot:
02:00007D0C B1F10000        	  3944: 	cmpa.l	(a1,d0.w),a0			; Is the IRQ already installed?
02:00007D10 6716            	  3945: 	beq.s		.found
02:00007D12 4AB10000        	  3946: 	tst.l		(a1,d0.w)					; test for an empty spot
02:00007D16 670C            	  3947: 	beq.s		.foundSpot
02:00007D18 5840            	  3948: 	addi.w	#4,d0							; increment to next slot
02:00007D1A 3200            	  3949: 	move.w	d0,d1
02:00007D1C 0241001F        	  3950: 	andi.w	#$1F,d1						; check to see if spots exhausted
02:00007D20 670C            	  3951: 	beq.s		.noEmpties
02:00007D22 60E8            	  3952: 	bra.s		.nextSpot
                            	  3953: .foundSpot:
02:00007D24 23880000        	  3954: 	move.l	a0,(a1,d0.w)			; add IRQ routine to table
                            	  3955: .found:
02:00007D28 201F            	  3956: 	move.l	(a7)+,d0
02:00007D2A 72FF            	  3957: 	moveq		#-1,d1						; return success
02:00007D2C 4E75            	  3958: 	rts
                            	  3959: .noEmpties:
02:00007D2E 201F            	  3960: 	move.l	(a7)+,d0
02:00007D30 7200            	  3961: 	moveq		#0,d1							; return failed to add
02:00007D32 4E75            	  3962: 	rts
                            	  3963: 	
                            	  3964: 
                            	  3965: ;------------------------------------------------------------------------------
                            	  3966: ; TickIRQ
                            	  3967: ; - this IRQ is processed by all cores.
                            	  3968: ; - core 2 is responsible for resetting the edge circuit.
                            	  3969: ; - an IRQ live indicator is updated on the text screen for the core
                            	  3970: ;------------------------------------------------------------------------------
                            	  3971: 
                            	  3972: TickIRQ:
02:00007D34 46FC2600        	  3973: 	move.w	#$2600,sr					; disable lower level IRQs
02:00007D38 48E77080        	  3974: 	movem.l	d1/d2/d3/a0,-(a7)
02:00007D3C 13FC0001000400A0	  3975: 	move.b #1,IRQFlag					; tick interrupt indicator in local memory
                            	  3976: 	; ToDo: detect a tick interrupt
                            	  3977: ;	move.l	PLIC+$00,d1
                            	  3978: ;	rol.l		#8,d1
                            	  3979: ;	cmpi.b	#29,d1
                            	  3980: ;	bne.s		.notTick
02:00007D44 4E7A1FE0        	  3981: 	movec	coreno,d1						; d1 = core number
02:00007D48 2601            	  3982: 	move.l d1,d3
02:00007D4A E783            	  3983: 	asl.l #3,d3								; 8 bytes per text cell
                            	  3984: ;	cmpi.b #2,d1
                            	  3985: ;	bne.s	.0001
02:00007D4C 23FC1D000000FD09	  3986: 	move.l #$1D000000,PLIC+$14	; reset edge sense circuit
02:00007D54 0014
                            	  3987: .0001:	
                            	  3988: ;	move.l TextScr,a0					; a0 = screen address
02:00007D56 41F9FD000000    	  3989: 	lea $FD000000,a0
02:00007D5C 41E800A0        	  3990: 	adda.l #160,a0						; move over to display field
02:00007D60 24303004        	  3991: 	move.l 4(a0,d3.w),d2			; get char from screen
02:00007D64 E19A            	  3992: 	rol.l #8,d2								; extract char field
02:00007D66 4202            	  3993: 	clr.b d2									; clear char field
02:00007D68 06010030        	  3994: 	addi.b #'0',d1						; binary to ascii core number
02:00007D6C 8401            	  3995: 	or.b	d1,d2								; insert core number
02:00007D6E E09A            	  3996: 	ror.l #8,d2								; reposition to proper place
02:00007D70 5242            	  3997: 	addi.w #1,d2							; flashy colors
02:00007D72 4842            	  3998: 	swap d2
02:00007D74 5202            	  3999: 	addi.b #1,d2
02:00007D76 4842            	  4000: 	swap d2
02:00007D78 21823004        	  4001: 	move.l d2,4(a0,d3.w)			; update onscreen IRQ flag
                            	  4002: ; addi.l	#1,40(a0)					; nice effect
02:00007D7C 6100FE88        	  4003: 	bsr	ReceiveMsg
02:00007D80 4CDF010E        	  4004: 	movem.l	(a7)+,d1/d2/d3/a0
02:00007D84 4E73            	  4005: 	rte
                            	  4006: ;.notTick:
                            	  4007: ;	movem.l	(a7)+,d1/a0
                            	  4008: ;	rte
                            	  4009: ;------------------------------------------------------------------------------
                            	  4010: ;------------------------------------------------------------------------------
                            	  4011: 
                            	  4012: irq3_rout:
02:00007D86 48E7C0C0        	  4013: 	movem.l	d0/d1/a0/a1,-(a7)
02:00007D8A 41F80460        	  4014: 	lea			InstalledIRQ+8*4*3,a0
02:00007D8E 6008            	  4015: 	bra			irq_rout
                            	  4016: 
                            	  4017: irq6_rout:
02:00007D90 48E7C0C0        	  4018: 	movem.l	d0/d1/a0/a1,-(a7)
02:00007D94 41F804C0        	  4019: 	lea			InstalledIRQ+8*4*6,a0
                            	  4020: irq_rout:
02:00007D98 7007            	  4021: 	moveq		#7,d0
                            	  4022: .nextHandler:
02:00007D9A 2258            	  4023: 	move.l	(a0)+,a1
02:00007D9C 6706            	  4024: 	beq.s		.0003
02:00007D9E 4E91            	  4025: 	jsr			(a1)
02:00007DA0 4A81            	  4026: 	tst.l		d1								; was IRQ handled?
02:00007DA2 6B04            	  4027: 	bmi.s		.0002							; first one to return handled quits loop
                            	  4028: .0003:
02:00007DA4 51C8FFF4        	  4029: 	dbra		d0,.nextHandler
                            	  4030: .0002:
02:00007DA8 4CDF0303        	  4031: 	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  4032: 
                            	  4033: SpuriousIRQ:
02:00007DAC 4E73            	  4034: 	rte
                            	  4035: 
                            	  4036: ;	bsr			KeybdIRQ
                            	  4037: ;	tst.l		d1								; handled by KeybdIRQ?
                            	  4038: ;	bmi.s		.0002							; if yes, go return
                            	  4039: ;.0001:
                            	  4040: ;	move.l	#$1D000000,PLIC+$14	; reset edge sense circuit
                            	  4041: ;	move.l	TextScr,a0				; a0 = screen address
                            	  4042: ;	addi.l	#1,40(a0)					; update onscreen IRQ flag
                            	  4043: ;.0002:	
                            	  4044: ;	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  4045: ;	rte
                            	  4046: 
                            	  4047: nmi_rout:
02:00007DAE 48E7C080        	  4048: 	movem.l	d0/d1/a0,-(a7)
02:00007DB2 123C004E        	  4049: 	move.b	#'N',d1
02:00007DB6 6100DB1C        	  4050: 	bsr			DisplayChar
02:00007DBA 4CDF0103        	  4051: 	movem.l	(a7)+,d0/d1/a0		; return
02:00007DBE 4E73            	  4052: 	rte
                            	  4053: 
                            	  4054: addr_err:
02:00007DC0 544F            	  4055: 	addq		#2,sp						; get rid of sr
02:00007DC2 221F            	  4056: 	move.l	(sp)+,d1				; pop exception address
02:00007DC4 6100F5EE        	  4057: 	bsr			DisplayTetra		; and display it
02:00007DC8 43FA00A6        	  4058: 	lea			msgAddrErr,a1	; followed by message
02:00007DCC 6100DD9A        	  4059: 	bsr			DisplayStringCRLF
                            	  4060: .0001:
02:00007DD0 60FE            	  4061: 	bra			.0001
02:00007DD2 6000E8EC        	  4062: 	bra			Monitor
                            	  4063: 	
                            	  4064: brdisp_trap:
02:00007DD6 48F9FFFF00040100	  4065: 	movem.l	d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
02:00007DDE 33DF00040140    	  4066: 	move.w	(a7)+,Regsave+$40
02:00007DE4 23DF00040144    	  4067: 	move.l	(a7)+,Regsave+$44
02:00007DEA 2E7C00040FFC    	  4068: 	move.l	#$40FFC,a7			; reset stack pointer
02:00007DF0 46FC2500        	  4069: 	move.w	#$2500,sr				; enable interrupts
02:00007DF4 43FA0099        	  4070: 	lea			msg_bad_branch_disp,a1
02:00007DF8 6100DD58        	  4071: 	bsr			DisplayString
02:00007DFC 6100F5AE        	  4072: 	bsr			DisplaySpace
02:00007E00 223900040144    	  4073: 	move.l	Regsave+$44,d1	; exception address
02:00007E06 6100F5AC        	  4074: 	bsr			DisplayTetra		; and display it
                            	  4075: ;	move.l	(sp)+,d1				; pop format word 68010 mode only
02:00007E0A 6000EEFE        	  4076: 	bra			cmdDumpRegs
                            	  4077: 
                            	  4078: illegal_trap:
02:00007E0E 544F            	  4079: 	addq		#2,sp						; get rid of sr
02:00007E10 221F            	  4080: 	move.l	(sp)+,d1				; pop exception address
02:00007E12 6100F5A0        	  4081: 	bsr			DisplayTetra		; and display it
02:00007E16 43FA0065        	  4082: 	lea			msg_illegal,a1	; followed by message
02:00007E1A 6100DD36        	  4083: 	bsr			DisplayString
                            	  4084: .0001:
02:00007E1E 60FE            	  4085: 	bra			.0001
02:00007E20 6000E89E        	  4086: 	bra			Monitor
                            	  4087: 	
                            	  4088: io_irq:
02:00007E24 544F            	  4089: 	addq #2,sp
02:00007E26 221F            	  4090: 	move.l (sp)+,d1
02:00007E28 6100F58A        	  4091: 	bsr DisplayTetra
02:00007E2C 43FA0083        	  4092: 	lea msg_io_access,a1
02:00007E30 6100DD20        	  4093: 	bsr DisplayString
02:00007E34 6000EED4        	  4094: 	bra cmdDumpRegs
                            	  4095: 
                            	  4096: ; -----------------------------------------------------------------------------
                            	  4097: ; -----------------------------------------------------------------------------
                            	  4098: 
                            	  4099: msg_start:
02:00007E38 46656D74696B6920	  4100: 	dc.b	"Femtiki rf68k Multi-core OS Starting",LF,CR,0
02:00007E40 726636386B204D75
02:00007E48 6C74692D636F7265
02:00007E50 204F532053746172
02:00007E58 74696E67
02:00007E5C 0A
02:00007E5D 0D
02:00007E5E 00
                            	  4101: ;	dc.b	"rf68k System Starting",CR,LF,0
                            	  4102: msg_core_start:
02:00007E5F 20636F7265207374	  4103: 	dc.b	" core starting",CR,LF,0
02:00007E67 617274696E67
02:00007E6D 0D
02:00007E6E 0A
02:00007E6F 00
                            	  4104: msgAddrErr
02:00007E70 2061646472657373	  4105: 	dc.b	" address err",0
02:00007E78 20657272
02:00007E7C 00
                            	  4106: msg_illegal:
02:00007E7D 20696C6C6567616C	  4107: 	dc.b	" illegal opcode",CR,LF,0
02:00007E85 206F70636F6465
02:00007E8C 0D
02:00007E8D 0A
02:00007E8E 00
                            	  4108: msg_bad_branch_disp:
02:00007E8F 206272616E636820	  4109: 	dc.b	" branch selfref: ",0
02:00007E97 73656C667265663A
02:00007E9F 20
02:00007EA0 00
                            	  4110: msg_test_done:
02:00007EA1 2043505520746573	  4111: 	dc.b	" CPU test done.",0
02:00007EA9 7420646F6E652E
02:00007EB0 00
                            	  4112: msg_io_access
02:00007EB1 20756E7065726D69	  4113: 	dc.b " unpermitted access to I/O",0
02:00007EB9 7474656420616363
02:00007EC1 65737320746F2049
02:00007EC9 2F4F
02:00007ECB 00
                            	  4114: msgChk
02:00007ECC 20636865636B2066	  4115: 	dc.b " check failed",0
02:00007ED4 61696C6564
02:00007ED9 00
                            	  4116: msgStackCanary
02:00007EDA 20737461636B2063	  4117: 	dc.b " stack canary overwritten",0
02:00007EE2 616E617279206F76
02:00007EEA 6572777269747465
02:00007EF2 6E
02:00007EF3 00
                            	  4118: 


Symbols by name:
ABCD_INNER1                     02:0000269E
ABCD_INNER2                     02:0000270C
ABCD_NO_C1                      02:000026BA
ABCD_NO_C2                      02:000026C2
ABCD_NO_C3                      02:00002728
ABCD_NO_C4                      02:00002730
ABCD_OUTER1                     02:0000269C
ABCD_OUTER2                     02:0000270A
ABS                             02:00004D80
ACIA                             E:FD060000
ACIA_CMD                         E:00000008
ACIA_CTRL                        E:0000000C
ACIA_RX                          E:00000000
ACIA_STAT                        E:00000004
ACIA_TX                          E:00000000
ADDA_OUTER1                     02:0000320C
ADDQ_LOOP1                      02:00002A26
ADDQ_LOOP2                      02:00002A64
ADDQ_LOOP3                      02:00002A9A
ADDX_LOOP3                      02:00003332
ADDX_LOOP4                      02:0000334E
ADDX_LOOP5                      02:0000336A
ADDX_OUTER1                     02:0000329E
ADD_OUTER1                      02:00003032
ADD_OUTER2                      02:000030A6
AHOW                            02:00004FF8
ALL_DONE                        02:00000410
AND_OUTER1                      02:00002D50
AND_OUTER2                      02:00002DC4
ASORRY                          02:00004FF0
AUXIN                           02:0000531C
AUXOUT                          02:00005308
AWHAT                           02:00004FB0
AXIRET                          02:0000533A
AllocateString                  02:00004A98
ArmAllBreakpoints               02:00007A94
ArmBreakpoint                   02:00007AC4
AsciiToHexNybble                02:00007360
AudioInputTest                  02:000076CE
BCC1                            02:00002944
BCC10                           02:00002996
BCC11                           02:0000299E
BCC12                           02:000029A8
BCC13                           02:000029B0
BCC14                           02:000029BA
BCC2                            02:0000294E
BCC3                            02:00002956
BCC4                            02:00002960
BCC5                            02:00002968
BCC6                            02:00002972
BCC7                            02:0000297A
BCC8                            02:00002984
BCC9                            02:0000298C
BSR_CLOSE1                      02:000014E4
BSR_CLOSE2                      02:0000151A
BSR_FAR1                        02:00000412
BSR_FAR2                        02:00002934
BUFFER                          02:0000540C
BUFLEN                           E:00000050
BYEBYE                          02:0000533C
BlankLastLine                   02:00005AEE
BouncingBalls                   02:000076D0
BreakpointWords                  E:00040280
Breakpoints                      E:00040220
CALL                            02:0000473E
CHKIO                           02:000052AE
CHKRET                          02:000052BE
CHR                             02:00004F2A
CLMSG                           02:000053A4
CLS                             02:000052CC
CMPA_OUTER1                     02:00002F26
CMPM_LOOP1                      02:00002FB4
CMPM_LOOP2                      02:00002FCE
CMPM_LOOP3                      02:00002FE8
CMP_OUTER1                      02:00002EB0
CORENO                          02:00004DA8
CR                               E:0000000D
CRLF                            02:0000588A
CSTART                          02:00003E92
CTRLC                            E:00000003
CTRLH                            E:00000008
CTRLS                            E:00000013
CTRLX                            E:00000018
CTRLZ                            E:0000001A
CURRNT                          02:000053B4
CalcScreenLoc                   02:000058C6
CallOS                          02:0000569C
CheckForCtrlC                   02:00005FB8
CheckForKey                     02:00005F74
CheckNumeric                    02:00004808
ClearBreakpointList             02:00007BB6
ClearScreen                     02:000076D4
ClearStringArea                 02:00003FBC
ClearStringStack                02:00003FDC
CmdBuf                           E:00040040
CmdBufEnd                        E:00040080
ConcatString                    02:00004914
Cursor1                         02:00005CA4
CursorCol                        E:00040001
CursorRow                        E:00040000
DBCC_LOOP1                      02:000029C4
DBCC_LOOP2                      02:000029D2
DEFLT                           02:000045CE
DIRECT                          02:00004198
DIRFLG                          02:00005408
DIV1                            02:00004CC4
DIV2                            02:00004CCA
DIV3                            02:00004CD0
DIV32                           02:00004CB2
DIV4                            02:00004CDE
DIVRT                           02:00004CEC
DIVS_OUTER1                     02:00002C10
DIVU_OUTER1                     02:00002BBE
DOMID                           02:00004E58
DOQUO                           02:0000528C
DOQUO1                          02:00005294
DT_NUMERIC                       E:00000001
DT_STRING                        E:00000002
Delay3s                         02:000002EE
Delay3s2                        02:00000312
DisarmAllBreakpoints            02:00007A68
DisarmBreakpoint                02:00007B42
DispatchMsg                     02:00007C48
DisplayAddr                     02:000073E0
DisplayByte                     02:000073C0
DisplayChar                     02:000058D4
DisplayHelp                     02:000068F0
DisplayMem                      02:00006CAE
DisplayNybble                   02:000073C6
DisplaySpace                    02:000073AC
DisplayString                   02:00005B52
DisplayStringCRLF               02:00005B68
DisplayStringLimited            02:00005B6E
DisplayStringLimitedCRLF        02:00005B8E
DisplayTetra                    02:000073B4
DisplayTwoSpaces                02:0000739A
DisplayWyde                     02:000073BA
DumpMem1                        02:00006C9C
ENDCHK                          02:00004F9C
ENDCHK1                         02:00004FAC
ENDMEM                          02:00003E8E
EOR_OUTER2                      02:00002E3A
ERROR                           02:00004FB4
ETYPE                           02:00004FFE
EX1                             02:000041D2
EXCEPTION_6                     02:0000041A
EXCEPTION_7                     02:00000422
EXEC                            02:000041A8
EXGO                            02:000041DE
EXLP                            02:000041B0
EXMAT                           02:000041D8
EXNGO                           02:000041BA
EXP4RT                          02:00004A08
EXPR                            02:000047B4
EXPR2                           02:000048A4
EXPR3                           02:00004982
EXPR4                           02:000049EC
EXPR_AND                        02:000047DA
EXPR_OR                         02:000047B4
EXPR_REL                        02:0000481A
E_Ok                             E:00000000
ExecuteCode                     02:00006C6E
FI1                             02:00004F8E
FI2                             02:00004F9A
FIN                             02:00004F82
FINISH                          02:000043B6
FMTK_SEMA                        E:00000008
FNDLN                           02:000050A2
FNDLNP                          02:000050B0
FNDNXT                          02:000050C8
FNDRET                          02:000050C6
FNDSKP                          02:000050CA
FOR                             02:00004424
FR1                             02:0000443E
FR2                             02:00004456
FR3                             02:0000445C
FR4                             02:00004462
FR5                             02:0000446A
FR6                             02:0000447C
FR7                             02:00004488
FR8                             02:000044A0
FemtikiInit                     02:0000567C
FemtikiInitIRQ                  02:0000568C
FemtikiTimerIRQ                 02:0000576A
ForceUnlockSemaphore            02:0000027A
FreeTCB                          E:0010030C
FromScreen                      02:000066AC
GBYTE                           02:00004626
GBYTE1                          02:0000462A
GBYTE2                          02:00004638
GETLN                           02:00005004
GL1                             02:00005014
GL2                             02:00005032
GL3                             02:00005046
GL4                             02:0000506A
GL5                             02:00005076
GL6                             02:00005092
GL7                             02:0000509A
GOAUXI                          02:00003E82
GOAUXO                          02:00003E7E
GOBYE                           02:00003E86
GOIN                            02:00003E7A
GOOUT                           02:00003E76
GOSUB                           02:000043BE
GOTO                            02:000042C0
GOWARM                          02:00003E72
GarbageCollectStrings           02:00004AF6
GetCmdLine                      02:00006A88
GetDecNumber                    02:00006E02
GetHexNumber                    02:00006DD4
GetKey                          02:00005F80
GetRunningTCBPointer            02:00005706
GlobalReadLong                  02:0000012E
GlobalWriteLong                 02:00000134
GraphicsDemo                    02:000076D2
HAS_MMU                          E:00000000
HOWMSG                          02:00005375
HelpMsg                         02:000068FC
HomeCursor                      02:00005B94
I2C2                             E:FD069000
I2C_CMD                          E:00000004
I2C_CTRL                         E:00000002
I2C_PREH                         E:00000001
I2C_PREL                         E:00000000
I2C_RXR                          E:00000003
I2C_STAT                         E:00000004
I2C_TXR                          E:00000003
IF                              02:00004510
IF1                             02:00004514
IF2                             02:0000451A
IGNBLK                          02:0000525A
INC                             02:000052E8
INC1                            02:000052F4
INCOM                           02:000041F0
INCON                           02:000041E2
INITMSG                         02:0000534A
INPERR                          02:0000452A
INPPTR                          02:000053AC
INPUT                           02:00004538
INT                             02:00004F14
INT_EXPR                        02:000047A2
IOCOM                           02:000041FE
IOCON                           02:00004214
IOFocus                          E:00100000
IP2                             02:0000456A
IP3                             02:00004584
IP4                             02:000045BE
IP5                             02:000045CA
IP6                             02:00004566
IP7                             02:0000455C
IRQFlag                          E:000400A0
IRQROUT                         02:000053E8
IncCursorPos                    02:00005A4E
IncCursorRow                    02:00005A6E
InitIOPBitmap                   02:0000013C
InitIRQ                         02:00007CF0
InitRand                        02:0000018C
InitSemaphores                  02:00000232
InputDevice                      E:000400A4
InstallIRQ                      02:00007D04
InstalledIRQ                     A:00000400
KEYBD                            E:FD0FFE00
KEYBD_SEMA                       E:00000003
KeybdEcho                        E:0004000C
KeybdGetChar                    02:00005FD4
KeybdGetCharNoWait              02:00005FC4
KeybdGetCharWait                02:00005FCC
KeybdGetID                      02:00005D56
KeybdID                          E:00100016
KeybdIRQ                        02:00006280
KeybdInit                       02:00005DC0
KeybdLEDs                        E:0010000E
KeybdRecvByte                   02:00005F24
KeybdSendByte                   02:00006240
KeybdSetLED                     02:00005D94
KeybdSetLEDStatus               02:000061F0
KeybdWaitFlag                    E:0004000D
KeybdWaitTx                     02:00005F46
LEA1                            02:00001EF0
LEFT                            02:00004EBA
LEN                             02:00004EEE
LET                             02:000045D6
LF                               E:0000000A
LIST                            02:00004308
LOAD                            02:000045E6
LOD1                            02:000045F2
LOD2                            02:0000460C
LODEND                          02:0000461C
LOPINC                          02:000053C8
LOPLMT                          02:000053D4
LOPLN                           02:000053E0
LOPPT                           02:000053E4
LOPVAR                          02:000053C4
LS1                             02:00004314
LS2                             02:00004328
LS3                             02:0000432E
LSTROM                          02:000053A8
LT1                             02:000045E2
LastStr                         02:000053F8
ListBreakpoints                 02:00007B96
LockSemaphore                   02:00000258
LockSysSemaphore                02:000057F2
LorR1                           02:00004DEC
LorRArgs                        02:00004DB4
MAX_TID                          E:00000FFF
MEMORY_SEMA                      E:00000006
MID                             02:00004DF0
MID1                            02:00004EB6
MID2                            02:00004E38
MID4                            02:00004E84
MID5                            02:00004E50
MMU                              E:FDC00000
MOVE1                           02:00001B5E
MOVE2                           02:00001AE2
MOVE3                           02:00001BDE
MOVE4                           02:00001D38
MULS_OUTER1                     02:00003506
MULU_OUTER1                     02:000034BA
MVDOWN                          02:000050EC
MVRET                           02:000050E0
MVUP                            02:000050D8
MVUPW                           02:000050E2
Monitor                         02:000066C0
NBCD_LOOP                       02:00002884
NBCD_LOOP1                      02:000028CA
NBCD_NO_C                       02:00002890
NBCD_NO_C1                      02:000028DE
NBCD_NO_Z                       02:00002894
NBCD_NO_Z1                      02:000028E2
NEW                             02:0000422A
NEXT                            02:000044A4
NOSTRING                        02:0000538C
NR_TCB                           E:00001000
NUM_EXPR                        02:00004794
NX0                             02:000044AE
NX1                             02:000044EE
NX2                             02:00004506
NX3                             02:000044C0
NextRec                         02:000074C8
NextString                      02:00004B32
NumSetBreakpoints                E:00040202
OKMSG                           02:0000536E
ONIRQ                           02:000042D4
ONIRQ1                          02:000042EE
OR_OUTER1                       02:00002C66
OR_OUTER2                       02:00002CDA
OSCallTable                     02:0000569A
OUTC                            02:000052D8
OUTCOM                          02:00004208
OUTCON                          02:0000421E
OUTPTR                          02:000053B0
OutputChar                      02:00007CD2
OutputDevice                     E:000400A8
PARN                            02:00004A82
PBYTE                           02:000046A4
PBYTE1                          02:000046A6
PBYTE2                          02:000046BA
PEEK                            02:00004CEE
PKER                            02:0000473A
PLIC                             E:FD090000
POKE                            02:000046C4
POPA                            02:000050F4
PR0                             02:00004352
PR1                             02:00004360
PR2                             02:00004344
PR3                             02:0000436E
PR6                             02:0000437A
PR8                             02:00004380
PR9                             02:0000439C
PRINT                           02:00004334
PRMESG                          02:000052C0
PRMRET                          02:000052CA
PRTLN                           02:000051D8
PRTNUM                          02:0000518E
PRTRET                          02:00005180
PRTSTG                          02:00005166
PRTSTR2                         02:00005188
PRTSTR2a                        02:00005182
PS1                             02:00005168
PUSHA                           02:00005130
PointsIntoStringArea            02:00004B8E
ProcessBreakpoint               02:00007A62
ProcessRec                      02:000074DA
ProcessS1                       02:000075DC
ProcessS2                       02:000075E0
ProcessS3                       02:000075E4
ProcessS7                       02:000075E8
ProcessS8                       02:000075F8
ProcessS9                       02:00007608
Prompt1                         02:000066FE
Prompt3                         02:000066E8
PromptLn                        02:000066DC
QHOW                            02:00004FF6
QSORRY                          02:00004FEE
QWHAT                           02:00004FAE
QueueCycle                       E:0010031C
RAND_MW                          E:FD0FFD0C
RAND_MZ                          E:FD0FFD08
RAND_NUM                         E:FD0FFD00
RAND_SEMA                        E:00000004
RAND_STRM                        E:FD0FFD04
RANPNT                          02:000053A8
REM                             02:0000450E
RETURN                          02:000043F8
RIGHT                           02:00004EC6
RND                             02:00004D56
ROXx_FLAGS                      02:000037CE
ROXx_LOOP1                      02:000037E4
ROXx_LOOP2                      02:00003804
ROXx_LOOP3                      02:00003824
ROXx_LOOP4                      02:00003844
ROXx_LOOP5                      02:00003864
ROXx_LOOP6                      02:00003886
ROx_FLAGS                       02:00003598
ROx_LOOP1                       02:000035AE
ROx_LOOP2                       02:000035CE
ROx_LOOP3                       02:000035EE
ROx_LOOP4                       02:0000360E
ROx_LOOP5                       02:0000362E
ROx_LOOP6                       02:00003650
RST_REG                          E:FD0FFC00
RTCBuf                           E:00100200
RTR_DONE                        02:00002926
RUN                             02:00004246
RUN1                            02:0000429A
RUNNXL                          02:0000425A
RUNSML                          02:000042B0
RUNTSL                          02:000042A6
RandGetNum                      02:000001CC
RandInit                        02:0000018C
RandWait                        02:0000021C
ReceiveMsg                      02:00007C06
Regsave                          E:00040100
RunningTCB                       E:00100224
S1932a                          02:00007650
S1932b                          02:00007664
S19Checksum                      E:00100150
S19Get16BitAddress              02:00007618
S19Get24BitAddress              02:00007626
S19Get32BitAddress              02:00007632
S19StartAddress                  E:00040008
SAVE                            02:00004646
SAVE1                           02:0000464E
SAVE2                           02:00004672
SAVEND                          02:00004680
SBCD_INNER1                     02:00002796
SBCD_INNER2                     02:00002804
SBCD_NO_C1                      02:000027B2
SBCD_NO_C2                      02:000027BA
SBCD_NO_C3                      02:00002820
SBCD_NO_C4                      02:00002828
SBCD_OUTER1                     02:00002794
SBCD_OUTER2                     02:00002802
SCREEN_SEMA                      E:00000005
SC_ALT                           E:00000011
SC_CAPSLOCK                      E:00000058
SC_CTRL                          E:00000014
SC_EXTEND                        E:000000E0
SC_KEYUP                         E:000000F0
SC_LSHIFT                        E:00000012
SC_NUMLOCK                       E:00000077
SC_RSHIFT                        E:00000059
SC_SCROLLLOCK                    E:0000007E
SC_TAB                           E:0000000D
SERIAL_SEMA                      E:00000002
SETVAL                          02:00004F62
SHIFTS2_FLAGS                   02:00003C46
SHIFTS2_LOOP1                   02:00003C5C
SHIFTS2_LOOP2                   02:00003C78
SHIFTS2_LOOP3                   02:00003C94
SHIFTS2_LOOP4                   02:00003CB0
SHIFTS2_LOOP5                   02:00003CCC
SHIFTS2_LOOP6                   02:00003CEA
SHIFTS_FLAGS                    02:00003A04
SHIFTS_LOOP1                    02:00003A1A
SHIFTS_LOOP2                    02:00003A3A
SHIFTS_LOOP3                    02:00003A5A
SHIFTS_LOOP4                    02:00003A7A
SHIFTS_LOOP5                    02:00003A9A
SHIFTS_LOOP6                    02:00003ABC
SIV1                            02:00004B66
SIZE                            02:00004D8C
SRYMSG                          02:0000539E
ST3                             02:00003F30
ST4                             02:00003F82
START                           02:00003E70
STKFP                           02:000053B8
STKGOS                          02:000053BC
STKINP                          02:000053C0
STKLMT                          02:00005404
STOP                            02:0000423E
STRAREASIZE                      E:00000800
STRSTK                          02:000053EC
SUBA_OUTER1                     02:00003258
SUBQ_LOOP1                      02:00002AE4
SUBQ_LOOP2                      02:00002B1E
SUBQ_LOOP3                      02:00002B54
SUBX_LOOP3                      02:00003442
SUBX_LOOP4                      02:0000345E
SUBX_LOOP5                      02:0000347A
SUBX_OUTER1                     02:000033AE
SUB_OUTER1                      02:0000311C
SUB_OUTER2                      02:00003190
SV1                             02:00004F80
ScrollUp                        02:00005AA2
SelectThreadToRun               02:0000571E
SendMsg                         02:00007BC8
SerHeadRcv                       E:00100162
SerRcvBuf                        E:00101000
SerRcvXoff                       E:00100165
SerRcvXon                        E:00100164
SerTailRcv                       E:00100160
SerialGetChar                   02:00007714
SerialIRQ                       02:00007822
SerialInit                      02:000076E2
SerialPeekChar                  02:0000778C
SerialPeekCharDirect            02:000077C4
SerialPutChar                   02:000077DE
SerialRbo                       02:000077FA
SerialRcvCount                  02:00007802
SetKeyboardEcho                 02:00005F6C
SpuriousIRQ                     02:00007DAC
StartMon                        02:000066B6
StartQ                          02:000055CE
StrArea                         02:000053F4
StrSp                           02:000053F0
StringInVar                     02:00004B48
StringOnStack                   02:00004BB2
StubRout                        02:00005CDC
SyncCursor                      02:00005BA6
T15Abort                        02:000002CA
T15DispatchTable                02:00005BF4
T15FloatToString                02:00007C90
T15GetFloat                     02:000002BC
T15LockSemaphore                02:000002B0
T15UnlockSemaphore              02:000002B6
TAB1                            02:00003FF0
TAB10                           02:000040A5
TAB10_1                         02:00004188
TAB11                           02:000040A8
TAB11_1                         02:00004190
TAB1_1                          02:000040B0
TAB2                            02:0000401F
TAB2_1                          02:000040E0
TAB4                            02:0000405C
TAB4_1                          02:00004120
TAB5                            02:0000408E
TAB5_1                          02:00004154
TAB6                            02:00004091
TAB6_1                          02:0000415C
TAB8                            02:00004096
TAB8_1                          02:00004164
TAB9                            02:000040A1
TAB9_1                          02:00004180
TC1                             02:00005208
TCBAffineChose                  02:000054FC
TCBAffinity                      E:00000084
TCBAffinityBase                  E:00000082
TCBAlloc                        02:000054CA
TCBEndTick                       E:00000070
TCBFree                         02:000054EE
TCBHandleToPointer              02:00005484
TCBIAlloc                       02:000054AC
TCBIFree                        02:000054D8
TCBInit                         02:0000545C
TCBInsertIntoReadyQueue         02:00005534
TCBNext                          E:0000007C
TCBPC                            E:00000050
TCBPointerToHandle              02:0000549C
TCBPopReadyQueue                02:000055D6
TCBPrev                          E:00000080
TCBPriority                      E:00000055
TCBRegs                          E:00000004
TCBRemoveFromReadyQueue         02:000055AC
TCBSR                            E:0000004C
TCBSSP                           E:00000048
TCBStartTick                     E:0000006C
TCBStatus                        E:00000054
TCBTicks                         E:00000074
TCBUSP                           E:00000044
TCB_SIZE                         E:00000100
TEXTREG                          E:FD080000
TICK                            02:00004D9C
TOUPB1                          02:0000526A
TOUPBRT                         02:0000528A
TOUPBUF                         02:00005264
TOUPPER                         02:0000529C
TOUPRET                         02:000052AC
TRAP15                          02:00005BDA
TSTC                            02:000051F6
TSTNUM                          02:0000520E
TSTV                            02:00004C30
TSTVRT                          02:00004CB0
TS_PREEMPT                       E:00000020
TS_RUNNING                       E:00000080
TV1                             02:00004C78
TV2                             02:00004CA8
TXT                             02:0000545C
TXTBGN                          02:00003E8A
TXTUNF                          02:000053FC
TYPMSG                          02:00005384
TextCols                         E:0004008D
TextCurpos                       E:00040002
TextPos                          E:00040002
TextRows                         E:0004008C
TextScr                          E:00040004
TickIRQ                         02:00007D34
TimerStack                       E:00040BFC
USP1                            02:00004C0E
UnlockSemaphore                 02:00000294
UnlockSysSemaphore              02:00005802
UpdateIRQLive                   02:00005748
UpdateStringPointers            02:00004BE2
UpdateTextPos                   02:0000589C
VARBGN                          02:00005400
WAITIRQ                         02:000042F8
WHTMSG                          02:0000537C
WSTART                          02:00003EFC
Wait10ms                        02:00006248
Wait300ms                       02:00006264
XOFF                             E:00000013
XON                              E:00000011
XP11                            02:0000482E
XP12                            02:0000483A
XP13                            02:00004846
XP14                            02:00004852
XP15                            02:0000485E
XP15RT                          02:0000486A
XP16                            02:0000486C
XP17                            02:0000488A
XP18                            02:00004890
XP21                            02:000048B2
XP22                            02:000048B8
XP23                            02:000048BC
XP24                            02:000048CA
XP25                            02:000048F8
XP26                            02:000048FE
XP27                            02:00004912
XP30                            02:00004988
XP31                            02:00004994
XP34                            02:000049AA
XP35                            02:000049C4
XP36                            02:00004984
XP40                            02:000049F8
XP41                            02:00004A0A
XP42                            02:00004A92
XP43                            02:00004A94
XP44                            02:00004A76
XP45                            02:00004A24
XPRT0                           02:0000487A
XPRT1                           02:00004882
XPSTNG                          02:00004A1A
XP_AND                          02:000047EC
XP_ANDX                         02:00004802
XP_MOD                          02:000049CA
XP_OR                           02:000047C4
XP_ORX                          02:00004802
XP_POP                          02:00004768
XP_POP1                         02:0000477E
XP_PUSH                         02:00004752
_CheckNan                       02:00006E6C
_CheckNegative                  02:00006EEA
_CheckZero                      02:00006ED0
_ComputeDigitsBeforeDecpt       02:00006F44
_E                               E:0004050C
_ExtExpDigit                    02:00007068
_ExtExpDigits                   02:00007086
_FloatToString                  02:00007130
_GetExponent                    02:000071E8
_GetFloat                       02:000072E8
_GetFloatBackupChar             02:00007180
_GetFloatGetChar                02:00007172
_GetFloatIgnBlanks              02:00007178
_GetFraction                    02:00007184
_GetInteger                     02:00007272
_GetRand                        02:000001FA
_KeyState1                       E:0010000F
_KeyState2                       E:00100010
_KeybdBuf                        E:00100020
_KeybdClearIRQ                  02:00005F0E
_KeybdCnt                        E:00100013
_KeybdGetScancode               02:00005EF0
_KeybdGetStatus                 02:00005ED2
_KeybdHead                       E:00100011
_KeybdInit                      02:00005DC0
_KeybdTail                       E:00100012
_LeadingZero                    02:00006F7E
_LessThanDbl                    02:00006F18
_MakeBig                        02:00006EFC
_PadLeft                        02:000070AE
_PadRight                       02:000070FE
_SpitOutDigits                  02:00006F8E
_SpitOutE                       02:00007050
_TrimDotZero                    02:00007028
_TrimTrailingPoint              02:0000700A
_TrimTrailingZeros              02:00007044
_canary                          E:00040098
_dfMil                          02:00006E58
_dfOne                          02:00006E40
_dfTen                          02:00006E4C
_digits_before_decpt             E:00040510
_fpBuf                           E:00040520
_fpTextIncr                      E:00040094
_fpWork                          E:00040600
_keybdControlCodes              02:00006514
_keybdExtendedCodes             02:00006594
_msgInf                         02:00006E68
_msgNan                         02:00006E64
_precision                       E:00040514
_shiftedScanCodes               02:00006414
_unshiftedScanCodes             02:00006314
_width                           E:00040508
addr_err                        02:00007DC0
bkColor                          E:00040088
brdisp_trap                     02:00007DD6
bus_err                         02:00007A20
chk_exception                   02:000002DA
clear_screen                    02:00005846
cmdBreakpoint                   02:00006756
cmdClearScreen                  02:0000678E
cmdClock                        02:00006880
cmdCore                         02:0000679A
cmdDispatch                     02:00006710
cmdDumpMemory                   02:00006C7C
cmdDumpRegs                     02:00006D0A
cmdEditMemory                   02:00006C0E
cmdFMTK                         02:000067BE
cmdFillB                        02:00006B90
cmdFillL                        02:00006BD8
cmdFillW                        02:00006BB4
cmdHelp                         02:000068F0
cmdJump                         02:00006C6E
cmdLoadS19                      02:000074C2
cmdMonitor                      02:000066C0
cmdReceiveSerial                02:00006B5C
cmdReset                        02:0000689E
cmdSendSerial                   02:00006B2C
cmdString                       02:00006614
cmdTable                        02:0000664C
cmdTestCPU                      02:0000677E
cmdTestFP                       02:000067C6
cmdTestGF                       02:00006852
cmdTestRAM                      02:00007400
cmdTestSerialReceive            02:00006DB4
cmdTinyBasic                    02:0000677A
cpu_test                        02:0000032E
dccr                            02:000058FC
dclf                            02:000059CA
dcx10                           02:00005964
dcx11                           02:00005986
dcx12                           02:0000597C
dcx14                           02:000058F2
dcx16                           02:000059CE
dcx4                            02:000059D2
dcx6                            02:0000591A
dcx7                            02:000058F6
dcx8                            02:00005930
dcx9                            02:00005946
dly3s1                          02:000002FE
dly3s2                          02:000002FC
doBackspace                     02:000059DC
doCtrlX                         02:00005A2A
doDelete                        02:000059EA
do_nothing                      02:00000128
dspj1                           02:00005B56
dspmem1                         02:00006CBE
dspspc1                         02:000073A4
dsret                           02:00005B62
edtmem1                         02:00006C16
fgColor                          E:00040084
fpBuf                            E:000402C0
get_screen_address              02:0000583E
get_screen_color                02:00005812
gthx3                           02:00007396
gthx5                           02:00007372
gthx6                           02:00007384
i2c_setup                       02:000078B2
i2c_wait_rx_nack                02:00007900
i2c_wait_tip                    02:000078C2
i2c_wr_cmd                      02:000078D2
i2c_xmit1                       02:000078E2
icc1                            02:00005AA0
ignBlanks                       02:00006BFC
illegal_trap                    02:00007E0E
init_i2c                        02:000078B2
init_plic                       02:00005D20
io_irq                          02:00007E24
irq3_rout                       02:00007D86
irq6_rout                       02:00007D90
irq_rout                        02:00007D98
kbdi0002                        02:00005DEC
kbdi0004                        02:00005E64
kbdi0005                        02:00005E80
kbdiTryAgain                    02:00005E56
kbdiXmitBusy                    02:00005E9A
kgid1                           02:00005D88
kgnotKbd                        02:00005D90
leds                             E:FD0FFF00
ledxit                          02:00005E84
loop1                           02:000000F6
loop2                           02:000000F4
loop3                           02:00005876
memend                           E:00100004
msgAddrErr                      02:00007E70
msgBadKeybd                     02:00005EA8
msgChk                          02:00007ECC
msgHello                        02:00006A77
msgRtcReadFail                  02:00007A06
msgStackCanary                  02:00007EDA
msgUnknownCmd                   02:00006A67
msgXmitBusy                     02:00005EB7
msg_bad_branch_disp             02:00007E8F
msg_core_start                  02:00007E5F
msg_illegal                     02:00007E7D
msg_io_access                   02:00007EB1
msg_reglist                     02:00006D8E
msg_regs                        02:00006D8A
msg_start                       02:00007E38
msg_test_done                   02:00007EA1
nd1                             02:00000138
nd2                             02:00000138
nd3                             02:00000138
nd4                             02:00000138
net_delay                       02:00000138
nmeSerial                       02:000078AA
nmi_rout                        02:00007DAE
notRxInt                        02:00007898
numBreakpoints                   E:00000008
op_ABCD                         02:0000267C
op_ADD                          02:00003012
op_ADDA                         02:000031E6
op_ADDQ                         02:00002A12
op_ADDX                         02:0000327E
op_ADD_I                        02:0000170A
op_AND                          02:00002D30
op_ANDI_TO_CCR                  02:000004BA
op_ANDI_TO_SR                   02:000004E0
op_BCC                          02:0000293C
op_BCHG                         02:000008B0
op_BCLR                         02:00000C18
op_BOOL_I                       02:0000133A
op_BSET                         02:00000F66
op_BSR                          02:000014EC
op_BTST                         02:00000506
op_BTST0                        02:00000690
op_BTST1                        02:0000069C
op_BTST10                       02:000006E4
op_BTST11                       02:000006EC
op_BTST12                       02:000006F2
op_BTST2                        02:000006A4
op_BTST20                       02:0000084A
op_BTST21                       02:00000854
op_BTST22                       02:0000085A
op_BTST23                       02:00000860
op_BTST24                       02:00000866
op_BTST25                       02:0000086C
op_BTST26                       02:00000872
op_BTST27                       02:00000878
op_BTST28                       02:0000087E
op_BTST29                       02:00000884
op_BTST3                        02:000006AC
op_BTST30                       02:0000088A
op_BTST31                       02:00000890
op_BTST32                       02:00000894
op_BTST4                        02:000006B4
op_BTST5                        02:000006BC
op_BTST6                        02:000006C4
op_BTST7                        02:000006CC
op_BTST8                        02:000006D4
op_BTST9                        02:000006DC
op_CHK                          02:00001F96
op_CMP                          02:00002E90
op_CMPA                         02:00002F06
op_CMPM                         02:00002F6C
op_CMP_I                        02:00001522
op_DBCC                         02:000029BC
op_DIVS                         02:00002BF4
op_DIVU                         02:00002BA2
op_EOR                          02:00002E1A
op_EORI_TO_CCR                  02:0000046E
op_EORI_TO_SR                   02:00000494
op_EXG                          02:00003536
op_EXT                          02:00001E16
op_LEAPEA                       02:00001E58
op_LINKS                        02:00001F68
op_MOVE                         02:00001A16
op_MOVEM                        02:0000235E
op_MOVEP                        02:000012AE
op_MOVEQ                        02:00002B86
op_MOVE_USP                     02:00001F86
op_MOVE_xxx_FLAGS               02:00001C22
op_MULS                         02:000034EA
op_MULU                         02:0000349E
op_NBCD                         02:0000286C
op_NEGS                         02:00001FD0
op_OR                           02:00002C46
op_ORI_TO_CCR                   02:0000042A
op_ORI_TO_SR                    02:0000044C
op_ROXx                         02:000037DA
op_ROx                          02:000035A4
op_RTR                          02:0000291A
op_SBCD                         02:00002774
op_SCC                          02:000029E2
op_SHIFTS                       02:00003A10
op_SHIFTS2                      02:00003C52
op_SUB                          02:000030FC
op_SUBA                         02:00003232
op_SUBQ                         02:00002ACC
op_SUBX                         02:0000338E
op_SUB_I                        02:00001890
op_SWAP                         02:00001E42
op_TAS                          02:00001F04
op_TRAPV                        02:000028FE
op_TST                          02:00001F2A
pcssxa                          02:00007570
prtflt                          02:00007C4A
ramtest                         02:00007400
ramtest0                        02:0000744A
ramtest1                        02:00007452
ramtest2                        02:0000747E
ramtest3                        02:000074C0
ramtest6                        02:0000746E
rbo                             02:000076DA
readyQ                           E:00100320
rmtst1                          02:00007462
rmtst2                          02:00007494
rmtst3                          02:0000749C
rmtst5                          02:0000741A
rotate_iofocus                  02:00005CF0
rtc_read                        02:00007910
rtc_write                       02:0000799C
sGetChar                        02:000076A6
select_focus1                   02:00005D02
select_iofocus                  02:00005CDE
semamem                          E:FD050000
sirq0001                        02:00007848
sirqNxtByte                     02:00007836
sirqRxFull                      02:00007898
start                           02:00000000
start_other                     02:00000108
tblPow2                         02:000068D0
tcbs                             E:20010000
trap3                           02:00007A24

Symbols by value:
FD050000 semamem
FD060000 ACIA
FD069000 I2C2
FD080000 TEXTREG
FD090000 PLIC
FD0FFC00 RST_REG
FD0FFD00 RAND_NUM
FD0FFD04 RAND_STRM
FD0FFD08 RAND_MZ
FD0FFD0C RAND_MW
FD0FFE00 KEYBD
FD0FFF00 leds
FDC00000 MMU
00000000 ACIA_TX
00000000 start
00000000 E_Ok
00000000 I2C_PREL
00000000 HAS_MMU
00000000 ACIA_RX
00000001 I2C_PREH
00000001 DT_NUMERIC
00000002 SERIAL_SEMA
00000002 DT_STRING
00000002 I2C_CTRL
00000003 I2C_TXR
00000003 I2C_RXR
00000003 KEYBD_SEMA
00000003 CTRLC
00000004 RAND_SEMA
00000004 I2C_STAT
00000004 TCBRegs
00000004 ACIA_STAT
00000004 I2C_CMD
00000005 SCREEN_SEMA
00000006 MEMORY_SEMA
00000008 ACIA_CMD
00000008 numBreakpoints
00000008 CTRLH
00000008 FMTK_SEMA
0000000A LF
0000000C ACIA_CTRL
0000000D SC_TAB
0000000D CR
00000011 XON
00000011 SC_ALT
00000012 SC_LSHIFT
00000013 XOFF
00000013 CTRLS
00000014 SC_CTRL
00000018 CTRLX
0000001A CTRLZ
00000020 TS_PREEMPT
00000044 TCBUSP
00000048 TCBSSP
0000004C TCBSR
00000050 BUFLEN
00000050 TCBPC
00000054 TCBStatus
00000055 TCBPriority
00000058 SC_CAPSLOCK
00000059 SC_RSHIFT
0000006C TCBStartTick
00000070 TCBEndTick
00000074 TCBTicks
00000077 SC_NUMLOCK
0000007C TCBNext
0000007E SC_SCROLLLOCK
00000080 TCBPrev
00000080 TS_RUNNING
00000082 TCBAffinityBase
00000084 TCBAffinity
000000E0 SC_EXTEND
000000F0 SC_KEYUP
000000F4 loop2
000000F6 loop1
00000100 TCB_SIZE
00000108 start_other
00000128 do_nothing
0000012E GlobalReadLong
00000134 GlobalWriteLong
00000138 nd2
00000138 nd1
00000138 nd4
00000138 net_delay
00000138 nd3
0000013C InitIOPBitmap
0000018C RandInit
0000018C InitRand
000001CC RandGetNum
000001FA _GetRand
0000021C RandWait
00000232 InitSemaphores
00000258 LockSemaphore
0000027A ForceUnlockSemaphore
00000294 UnlockSemaphore
000002B0 T15LockSemaphore
000002B6 T15UnlockSemaphore
000002BC T15GetFloat
000002CA T15Abort
000002DA chk_exception
000002EE Delay3s
000002FC dly3s2
000002FE dly3s1
00000312 Delay3s2
0000032E cpu_test
00000400 InstalledIRQ
00000410 ALL_DONE
00000412 BSR_FAR1
0000041A EXCEPTION_6
00000422 EXCEPTION_7
0000042A op_ORI_TO_CCR
0000044C op_ORI_TO_SR
0000046E op_EORI_TO_CCR
00000494 op_EORI_TO_SR
000004BA op_ANDI_TO_CCR
000004E0 op_ANDI_TO_SR
00000506 op_BTST
00000690 op_BTST0
0000069C op_BTST1
000006A4 op_BTST2
000006AC op_BTST3
000006B4 op_BTST4
000006BC op_BTST5
000006C4 op_BTST6
000006CC op_BTST7
000006D4 op_BTST8
000006DC op_BTST9
000006E4 op_BTST10
000006EC op_BTST11
000006F2 op_BTST12
00000800 STRAREASIZE
0000084A op_BTST20
00000854 op_BTST21
0000085A op_BTST22
00000860 op_BTST23
00000866 op_BTST24
0000086C op_BTST25
00000872 op_BTST26
00000878 op_BTST27
0000087E op_BTST28
00000884 op_BTST29
0000088A op_BTST30
00000890 op_BTST31
00000894 op_BTST32
000008B0 op_BCHG
00000C18 op_BCLR
00000F66 op_BSET
00000FFF MAX_TID
00001000 NR_TCB
000012AE op_MOVEP
0000133A op_BOOL_I
000014E4 BSR_CLOSE1
000014EC op_BSR
0000151A BSR_CLOSE2
00001522 op_CMP_I
0000170A op_ADD_I
00001890 op_SUB_I
00001A16 op_MOVE
00001AE2 MOVE2
00001B5E MOVE1
00001BDE MOVE3
00001C22 op_MOVE_xxx_FLAGS
00001D38 MOVE4
00001E16 op_EXT
00001E42 op_SWAP
00001E58 op_LEAPEA
00001EF0 LEA1
00001F04 op_TAS
00001F2A op_TST
00001F68 op_LINKS
00001F86 op_MOVE_USP
00001F96 op_CHK
00001FD0 op_NEGS
0000235E op_MOVEM
0000267C op_ABCD
0000269C ABCD_OUTER1
0000269E ABCD_INNER1
000026BA ABCD_NO_C1
000026C2 ABCD_NO_C2
0000270A ABCD_OUTER2
0000270C ABCD_INNER2
00002728 ABCD_NO_C3
00002730 ABCD_NO_C4
00002774 op_SBCD
00002794 SBCD_OUTER1
00002796 SBCD_INNER1
000027B2 SBCD_NO_C1
000027BA SBCD_NO_C2
00002802 SBCD_OUTER2
00002804 SBCD_INNER2
00002820 SBCD_NO_C3
00002828 SBCD_NO_C4
0000286C op_NBCD
00002884 NBCD_LOOP
00002890 NBCD_NO_C
00002894 NBCD_NO_Z
000028CA NBCD_LOOP1
000028DE NBCD_NO_C1
000028E2 NBCD_NO_Z1
000028FE op_TRAPV
0000291A op_RTR
00002926 RTR_DONE
00002934 BSR_FAR2
0000293C op_BCC
00002944 BCC1
0000294E BCC2
00002956 BCC3
00002960 BCC4
00002968 BCC5
00002972 BCC6
0000297A BCC7
00002984 BCC8
0000298C BCC9
00002996 BCC10
0000299E BCC11
000029A8 BCC12
000029B0 BCC13
000029BA BCC14
000029BC op_DBCC
000029C4 DBCC_LOOP1
000029D2 DBCC_LOOP2
000029E2 op_SCC
00002A12 op_ADDQ
00002A26 ADDQ_LOOP1
00002A64 ADDQ_LOOP2
00002A9A ADDQ_LOOP3
00002ACC op_SUBQ
00002AE4 SUBQ_LOOP1
00002B1E SUBQ_LOOP2
00002B54 SUBQ_LOOP3
00002B86 op_MOVEQ
00002BA2 op_DIVU
00002BBE DIVU_OUTER1
00002BF4 op_DIVS
00002C10 DIVS_OUTER1
00002C46 op_OR
00002C66 OR_OUTER1
00002CDA OR_OUTER2
00002D30 op_AND
00002D50 AND_OUTER1
00002DC4 AND_OUTER2
00002E1A op_EOR
00002E3A EOR_OUTER2
00002E90 op_CMP
00002EB0 CMP_OUTER1
00002F06 op_CMPA
00002F26 CMPA_OUTER1
00002F6C op_CMPM
00002FB4 CMPM_LOOP1
00002FCE CMPM_LOOP2
00002FE8 CMPM_LOOP3
00003012 op_ADD
00003032 ADD_OUTER1
000030A6 ADD_OUTER2
000030FC op_SUB
0000311C SUB_OUTER1
00003190 SUB_OUTER2
000031E6 op_ADDA
0000320C ADDA_OUTER1
00003232 op_SUBA
00003258 SUBA_OUTER1
0000327E op_ADDX
0000329E ADDX_OUTER1
00003332 ADDX_LOOP3
0000334E ADDX_LOOP4
0000336A ADDX_LOOP5
0000338E op_SUBX
000033AE SUBX_OUTER1
00003442 SUBX_LOOP3
0000345E SUBX_LOOP4
0000347A SUBX_LOOP5
0000349E op_MULU
000034BA MULU_OUTER1
000034EA op_MULS
00003506 MULS_OUTER1
00003536 op_EXG
00003598 ROx_FLAGS
000035A4 op_ROx
000035AE ROx_LOOP1
000035CE ROx_LOOP2
000035EE ROx_LOOP3
0000360E ROx_LOOP4
0000362E ROx_LOOP5
00003650 ROx_LOOP6
000037CE ROXx_FLAGS
000037DA op_ROXx
000037E4 ROXx_LOOP1
00003804 ROXx_LOOP2
00003824 ROXx_LOOP3
00003844 ROXx_LOOP4
00003864 ROXx_LOOP5
00003886 ROXx_LOOP6
00003A04 SHIFTS_FLAGS
00003A10 op_SHIFTS
00003A1A SHIFTS_LOOP1
00003A3A SHIFTS_LOOP2
00003A5A SHIFTS_LOOP3
00003A7A SHIFTS_LOOP4
00003A9A SHIFTS_LOOP5
00003ABC SHIFTS_LOOP6
00003C46 SHIFTS2_FLAGS
00003C52 op_SHIFTS2
00003C5C SHIFTS2_LOOP1
00003C78 SHIFTS2_LOOP2
00003C94 SHIFTS2_LOOP3
00003CB0 SHIFTS2_LOOP4
00003CCC SHIFTS2_LOOP5
00003CEA SHIFTS2_LOOP6
00003E70 START
00003E72 GOWARM
00003E76 GOOUT
00003E7A GOIN
00003E7E GOAUXO
00003E82 GOAUXI
00003E86 GOBYE
00003E8A TXTBGN
00003E8E ENDMEM
00003E92 CSTART
00003EFC WSTART
00003F30 ST3
00003F82 ST4
00003FBC ClearStringArea
00003FDC ClearStringStack
00003FF0 TAB1
0000401F TAB2
0000405C TAB4
0000408E TAB5
00004091 TAB6
00004096 TAB8
000040A1 TAB9
000040A5 TAB10
000040A8 TAB11
000040B0 TAB1_1
000040E0 TAB2_1
00004120 TAB4_1
00004154 TAB5_1
0000415C TAB6_1
00004164 TAB8_1
00004180 TAB9_1
00004188 TAB10_1
00004190 TAB11_1
00004198 DIRECT
000041A8 EXEC
000041B0 EXLP
000041BA EXNGO
000041D2 EX1
000041D8 EXMAT
000041DE EXGO
000041E2 INCON
000041F0 INCOM
000041FE IOCOM
00004208 OUTCOM
00004214 IOCON
0000421E OUTCON
0000422A NEW
0000423E STOP
00004246 RUN
0000425A RUNNXL
0000429A RUN1
000042A6 RUNTSL
000042B0 RUNSML
000042C0 GOTO
000042D4 ONIRQ
000042EE ONIRQ1
000042F8 WAITIRQ
00004308 LIST
00004314 LS1
00004328 LS2
0000432E LS3
00004334 PRINT
00004344 PR2
00004352 PR0
00004360 PR1
0000436E PR3
0000437A PR6
00004380 PR8
0000439C PR9
000043B6 FINISH
000043BE GOSUB
000043F8 RETURN
00004424 FOR
0000443E FR1
00004456 FR2
0000445C FR3
00004462 FR4
0000446A FR5
0000447C FR6
00004488 FR7
000044A0 FR8
000044A4 NEXT
000044AE NX0
000044C0 NX3
000044EE NX1
00004506 NX2
0000450E REM
00004510 IF
00004514 IF1
0000451A IF2
0000452A INPERR
00004538 INPUT
0000455C IP7
00004566 IP6
0000456A IP2
00004584 IP3
000045BE IP4
000045CA IP5
000045CE DEFLT
000045D6 LET
000045E2 LT1
000045E6 LOAD
000045F2 LOD1
0000460C LOD2
0000461C LODEND
00004626 GBYTE
0000462A GBYTE1
00004638 GBYTE2
00004646 SAVE
0000464E SAVE1
00004672 SAVE2
00004680 SAVEND
000046A4 PBYTE
000046A6 PBYTE1
000046BA PBYTE2
000046C4 POKE
0000473A PKER
0000473E CALL
00004752 XP_PUSH
00004768 XP_POP
0000477E XP_POP1
00004794 NUM_EXPR
000047A2 INT_EXPR
000047B4 EXPR_OR
000047B4 EXPR
000047C4 XP_OR
000047DA EXPR_AND
000047EC XP_AND
00004802 XP_ANDX
00004802 XP_ORX
00004808 CheckNumeric
0000481A EXPR_REL
0000482E XP11
0000483A XP12
00004846 XP13
00004852 XP14
0000485E XP15
0000486A XP15RT
0000486C XP16
0000487A XPRT0
00004882 XPRT1
0000488A XP17
00004890 XP18
000048A4 EXPR2
000048B2 XP21
000048B8 XP22
000048BC XP23
000048CA XP24
000048F8 XP25
000048FE XP26
00004912 XP27
00004914 ConcatString
00004982 EXPR3
00004984 XP36
00004988 XP30
00004994 XP31
000049AA XP34
000049C4 XP35
000049CA XP_MOD
000049EC EXPR4
000049F8 XP40
00004A08 EXP4RT
00004A0A XP41
00004A1A XPSTNG
00004A24 XP45
00004A76 XP44
00004A82 PARN
00004A92 XP42
00004A94 XP43
00004A98 AllocateString
00004AF6 GarbageCollectStrings
00004B32 NextString
00004B48 StringInVar
00004B66 SIV1
00004B8E PointsIntoStringArea
00004BB2 StringOnStack
00004BE2 UpdateStringPointers
00004C0E USP1
00004C30 TSTV
00004C78 TV1
00004CA8 TV2
00004CB0 TSTVRT
00004CB2 DIV32
00004CC4 DIV1
00004CCA DIV2
00004CD0 DIV3
00004CDE DIV4
00004CEC DIVRT
00004CEE PEEK
00004D56 RND
00004D80 ABS
00004D8C SIZE
00004D9C TICK
00004DA8 CORENO
00004DB4 LorRArgs
00004DEC LorR1
00004DF0 MID
00004E38 MID2
00004E50 MID5
00004E58 DOMID
00004E84 MID4
00004EB6 MID1
00004EBA LEFT
00004EC6 RIGHT
00004EEE LEN
00004F14 INT
00004F2A CHR
00004F62 SETVAL
00004F80 SV1
00004F82 FIN
00004F8E FI1
00004F9A FI2
00004F9C ENDCHK
00004FAC ENDCHK1
00004FAE QWHAT
00004FB0 AWHAT
00004FB4 ERROR
00004FEE QSORRY
00004FF0 ASORRY
00004FF6 QHOW
00004FF8 AHOW
00004FFE ETYPE
00005004 GETLN
00005014 GL1
00005032 GL2
00005046 GL3
0000506A GL4
00005076 GL5
00005092 GL6
0000509A GL7
000050A2 FNDLN
000050B0 FNDLNP
000050C6 FNDRET
000050C8 FNDNXT
000050CA FNDSKP
000050D8 MVUP
000050E0 MVRET
000050E2 MVUPW
000050EC MVDOWN
000050F4 POPA
00005130 PUSHA
00005166 PRTSTG
00005168 PS1
00005180 PRTRET
00005182 PRTSTR2a
00005188 PRTSTR2
0000518E PRTNUM
000051D8 PRTLN
000051F6 TSTC
00005208 TC1
0000520E TSTNUM
0000525A IGNBLK
00005264 TOUPBUF
0000526A TOUPB1
0000528A TOUPBRT
0000528C DOQUO
00005294 DOQUO1
0000529C TOUPPER
000052AC TOUPRET
000052AE CHKIO
000052BE CHKRET
000052C0 PRMESG
000052CA PRMRET
000052CC CLS
000052D8 OUTC
000052E8 INC
000052F4 INC1
00005308 AUXOUT
0000531C AUXIN
0000533A AXIRET
0000533C BYEBYE
0000534A INITMSG
0000536E OKMSG
00005375 HOWMSG
0000537C WHTMSG
00005384 TYPMSG
0000538C NOSTRING
0000539E SRYMSG
000053A4 CLMSG
000053A8 RANPNT
000053A8 LSTROM
000053AC INPPTR
000053B0 OUTPTR
000053B4 CURRNT
000053B8 STKFP
000053BC STKGOS
000053C0 STKINP
000053C4 LOPVAR
000053C8 LOPINC
000053D4 LOPLMT
000053E0 LOPLN
000053E4 LOPPT
000053E8 IRQROUT
000053EC STRSTK
000053F0 StrSp
000053F4 StrArea
000053F8 LastStr
000053FC TXTUNF
00005400 VARBGN
00005404 STKLMT
00005408 DIRFLG
0000540C BUFFER
0000545C TXT
0000545C TCBInit
00005484 TCBHandleToPointer
0000549C TCBPointerToHandle
000054AC TCBIAlloc
000054CA TCBAlloc
000054D8 TCBIFree
000054EE TCBFree
000054FC TCBAffineChose
00005534 TCBInsertIntoReadyQueue
000055AC TCBRemoveFromReadyQueue
000055CE StartQ
000055D6 TCBPopReadyQueue
0000567C FemtikiInit
0000568C FemtikiInitIRQ
0000569A OSCallTable
0000569C CallOS
00005706 GetRunningTCBPointer
0000571E SelectThreadToRun
00005748 UpdateIRQLive
0000576A FemtikiTimerIRQ
000057F2 LockSysSemaphore
00005802 UnlockSysSemaphore
00005812 get_screen_color
0000583E get_screen_address
00005846 clear_screen
00005876 loop3
0000588A CRLF
0000589C UpdateTextPos
000058C6 CalcScreenLoc
000058D4 DisplayChar
000058F2 dcx14
000058F6 dcx7
000058FC dccr
0000591A dcx6
00005930 dcx8
00005946 dcx9
00005964 dcx10
0000597C dcx12
00005986 dcx11
000059CA dclf
000059CE dcx16
000059D2 dcx4
000059DC doBackspace
000059EA doDelete
00005A2A doCtrlX
00005A4E IncCursorPos
00005A6E IncCursorRow
00005AA0 icc1
00005AA2 ScrollUp
00005AEE BlankLastLine
00005B52 DisplayString
00005B56 dspj1
00005B62 dsret
00005B68 DisplayStringCRLF
00005B6E DisplayStringLimited
00005B8E DisplayStringLimitedCRLF
00005B94 HomeCursor
00005BA6 SyncCursor
00005BDA TRAP15
00005BF4 T15DispatchTable
00005CA4 Cursor1
00005CDC StubRout
00005CDE select_iofocus
00005CF0 rotate_iofocus
00005D02 select_focus1
00005D20 init_plic
00005D56 KeybdGetID
00005D88 kgid1
00005D90 kgnotKbd
00005D94 KeybdSetLED
00005DC0 KeybdInit
00005DC0 _KeybdInit
00005DEC kbdi0002
00005E56 kbdiTryAgain
00005E64 kbdi0004
00005E80 kbdi0005
00005E84 ledxit
00005E9A kbdiXmitBusy
00005EA8 msgBadKeybd
00005EB7 msgXmitBusy
00005ED2 _KeybdGetStatus
00005EF0 _KeybdGetScancode
00005F0E _KeybdClearIRQ
00005F24 KeybdRecvByte
00005F46 KeybdWaitTx
00005F6C SetKeyboardEcho
00005F74 CheckForKey
00005F80 GetKey
00005FB8 CheckForCtrlC
00005FC4 KeybdGetCharNoWait
00005FCC KeybdGetCharWait
00005FD4 KeybdGetChar
000061F0 KeybdSetLEDStatus
00006240 KeybdSendByte
00006248 Wait10ms
00006264 Wait300ms
00006280 KeybdIRQ
00006314 _unshiftedScanCodes
00006414 _shiftedScanCodes
00006514 _keybdControlCodes
00006594 _keybdExtendedCodes
00006614 cmdString
0000664C cmdTable
000066AC FromScreen
000066B6 StartMon
000066C0 Monitor
000066C0 cmdMonitor
000066DC PromptLn
000066E8 Prompt3
000066FE Prompt1
00006710 cmdDispatch
00006756 cmdBreakpoint
0000677A cmdTinyBasic
0000677E cmdTestCPU
0000678E cmdClearScreen
0000679A cmdCore
000067BE cmdFMTK
000067C6 cmdTestFP
00006852 cmdTestGF
00006880 cmdClock
0000689E cmdReset
000068D0 tblPow2
000068F0 DisplayHelp
000068F0 cmdHelp
000068FC HelpMsg
00006A67 msgUnknownCmd
00006A77 msgHello
00006A88 GetCmdLine
00006B2C cmdSendSerial
00006B5C cmdReceiveSerial
00006B90 cmdFillB
00006BB4 cmdFillW
00006BD8 cmdFillL
00006BFC ignBlanks
00006C0E cmdEditMemory
00006C16 edtmem1
00006C6E ExecuteCode
00006C6E cmdJump
00006C7C cmdDumpMemory
00006C9C DumpMem1
00006CAE DisplayMem
00006CBE dspmem1
00006D0A cmdDumpRegs
00006D8A msg_regs
00006D8E msg_reglist
00006DB4 cmdTestSerialReceive
00006DD4 GetHexNumber
00006E02 GetDecNumber
00006E40 _dfOne
00006E4C _dfTen
00006E58 _dfMil
00006E64 _msgNan
00006E68 _msgInf
00006E6C _CheckNan
00006ED0 _CheckZero
00006EEA _CheckNegative
00006EFC _MakeBig
00006F18 _LessThanDbl
00006F44 _ComputeDigitsBeforeDecpt
00006F7E _LeadingZero
00006F8E _SpitOutDigits
0000700A _TrimTrailingPoint
00007028 _TrimDotZero
00007044 _TrimTrailingZeros
00007050 _SpitOutE
00007068 _ExtExpDigit
00007086 _ExtExpDigits
000070AE _PadLeft
000070FE _PadRight
00007130 _FloatToString
00007172 _GetFloatGetChar
00007178 _GetFloatIgnBlanks
00007180 _GetFloatBackupChar
00007184 _GetFraction
000071E8 _GetExponent
00007272 _GetInteger
000072E8 _GetFloat
00007360 AsciiToHexNybble
00007372 gthx5
00007384 gthx6
00007396 gthx3
0000739A DisplayTwoSpaces
000073A4 dspspc1
000073AC DisplaySpace
000073B4 DisplayTetra
000073BA DisplayWyde
000073C0 DisplayByte
000073C6 DisplayNybble
000073E0 DisplayAddr
00007400 ramtest
00007400 cmdTestRAM
0000741A rmtst5
0000744A ramtest0
00007452 ramtest1
00007462 rmtst1
0000746E ramtest6
0000747E ramtest2
00007494 rmtst2
0000749C rmtst3
000074C0 ramtest3
000074C2 cmdLoadS19
000074C8 NextRec
000074DA ProcessRec
00007570 pcssxa
000075DC ProcessS1
000075E0 ProcessS2
000075E4 ProcessS3
000075E8 ProcessS7
000075F8 ProcessS8
00007608 ProcessS9
00007618 S19Get16BitAddress
00007626 S19Get24BitAddress
00007632 S19Get32BitAddress
00007650 S1932a
00007664 S1932b
000076A6 sGetChar
000076CE AudioInputTest
000076D0 BouncingBalls
000076D2 GraphicsDemo
000076D4 ClearScreen
000076DA rbo
000076E2 SerialInit
00007714 SerialGetChar
0000778C SerialPeekChar
000077C4 SerialPeekCharDirect
000077DE SerialPutChar
000077FA SerialRbo
00007802 SerialRcvCount
00007822 SerialIRQ
00007836 sirqNxtByte
00007848 sirq0001
00007898 notRxInt
00007898 sirqRxFull
000078AA nmeSerial
000078B2 i2c_setup
000078B2 init_i2c
000078C2 i2c_wait_tip
000078D2 i2c_wr_cmd
000078E2 i2c_xmit1
00007900 i2c_wait_rx_nack
00007910 rtc_read
0000799C rtc_write
00007A06 msgRtcReadFail
00007A20 bus_err
00007A24 trap3
00007A62 ProcessBreakpoint
00007A68 DisarmAllBreakpoints
00007A94 ArmAllBreakpoints
00007AC4 ArmBreakpoint
00007B42 DisarmBreakpoint
00007B96 ListBreakpoints
00007BB6 ClearBreakpointList
00007BC8 SendMsg
00007C06 ReceiveMsg
00007C48 DispatchMsg
00007C4A prtflt
00007C90 T15FloatToString
00007CD2 OutputChar
00007CF0 InitIRQ
00007D04 InstallIRQ
00007D34 TickIRQ
00007D86 irq3_rout
00007D90 irq6_rout
00007D98 irq_rout
00007DAC SpuriousIRQ
00007DAE nmi_rout
00007DC0 addr_err
00007DD6 brdisp_trap
00007E0E illegal_trap
00007E24 io_irq
00007E38 msg_start
00007E5F msg_core_start
00007E70 msgAddrErr
00007E7D msg_illegal
00007E8F msg_bad_branch_disp
00007EA1 msg_test_done
00007EB1 msg_io_access
00007ECC msgChk
00007EDA msgStackCanary
00040000 CursorRow
00040001 CursorCol
00040002 TextCurpos
00040002 TextPos
00040004 TextScr
00040008 S19StartAddress
0004000C KeybdEcho
0004000D KeybdWaitFlag
00040040 CmdBuf
00040080 CmdBufEnd
00040084 fgColor
00040088 bkColor
0004008C TextRows
0004008D TextCols
00040094 _fpTextIncr
00040098 _canary
000400A0 IRQFlag
000400A4 InputDevice
000400A8 OutputDevice
00040100 Regsave
00040202 NumSetBreakpoints
00040220 Breakpoints
00040280 BreakpointWords
000402C0 fpBuf
00040508 _width
0004050C _E
00040510 _digits_before_decpt
00040514 _precision
00040520 _fpBuf
00040600 _fpWork
00040BFC TimerStack
00100000 IOFocus
00100004 memend
0010000E KeybdLEDs
0010000F _KeyState1
00100010 _KeyState2
00100011 _KeybdHead
00100012 _KeybdTail
00100013 _KeybdCnt
00100016 KeybdID
00100020 _KeybdBuf
00100150 S19Checksum
00100160 SerTailRcv
00100162 SerHeadRcv
00100164 SerRcvXon
00100165 SerRcvXoff
00100200 RTCBuf
00100224 RunningTCB
0010030C FreeTCB
0010031C QueueCycle
00100320 readyQ
00101000 SerRcvBuf
20010000 tcbs

Sections:
00: "DATA" (0-218)
01: "seg500" (500-500)
02: "CODE" (0-7EE2)


Source: "boot.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;-------------------------------------------------------------------------------
                            	    37: ;
                            	    38: ; system memory map
                            	    39: ;
                            	    40: ;
                            	    41: ; 00000000 +----------------+      <+
                            	    42: ;          | startup sp,pc  | 8 B   |
                            	    43: ; 00000008 +----------------+       |
                            	    44: ;					 |    vectors     | pair shared+
                            	    45: ; 00000400 +----------------+       |
                            	    46: ;					 |   bios mem     |       |
                            	    47: ; 00001000 +----------------+       |
                            	    48: ;					 |   bios code    |       |
                            	    49: ; 00020000 +----------------+      <+
                            	    50: ;					 |    unused      |
                            	    51: ; 00040000 +----------------+
                            	    52: ;					 |   local ram    |
                            	    53: ; 00042000 +----------------+
                            	    54: ;					 |    unused      |
                            	    55: ; 00100000 +----------------+
                            	    56: ;					 |   global ram   |
                            	    57: ; 00101000 +----------------+
                            	    58: ;					 | serial rcvbuf  |
                            	    59: ; 00102000 +----------------+
                            	    60: ;					 |    unused      |
                            	    61: ; 40000000 +----------------+
                            	    62: ;          |                |
                            	    63: ;          |                |
                            	    64: ;          |                |
                            	    65: ;          :  dram memory   : 1GB MB
                            	    66: ;          |                |
                            	    67: ;          |                |
                            	    68: ;          |                |
                            	    69: ; 80000000 +----------------+
                            	    70: ;          |                |
                            	    71: ;          :     unused     :
                            	    72: ;          |                |
                            	    73: ; FD000000 +----------------+
                            	    74: ;          |                |
                            	    75: ;          :    I/O area    : 1.0 M
                            	    76: ;          |                |
                            	    77: ; FFE00000 +----------------+
                            	    78: ;          |                |
                            	    79: ;          :     unused     :
                            	    80: ;          |                |
                            	    81: ; FFFFFFFF +----------------+
                            	    82: ;
                            	    83: ;-------------------------------------------------------------------------------
                            	    84: ;
                            	    85: HAS_MMU equ 0
                            	    86: 
                            	    87: CTRLC	EQU		$03
                            	    88: CTRLH	EQU		$08
                            	    89: CTRLS	EQU		$13
                            	    90: CTRLX	EQU		$18
                            	    91: CTRLZ	EQU		$1A
                            	    92: LF		EQU		$0A
                            	    93: CR		EQU		$0D
                            	    94: XON		EQU		$11
                            	    95: XOFF	EQU		$13
                            	    96: 
                            	    97: SC_F12  EQU    $07
                            	    98: SC_C    EQU    $21
                            	    99: SC_T    EQU    $2C
                            	   100: SC_Z    EQU    $1A
                            	   101: SC_KEYUP	EQU		$F0
                            	   102: SC_EXTEND   EQU		$E0
                            	   103: SC_CTRL		EQU		$14
                            	   104: SC_RSHIFT	EQU		$59
                            	   105: SC_NUMLOCK	EQU		$77
                            	   106: SC_SCROLLLOCK	EQU	$7E
                            	   107: SC_CAPSLOCK		EQU	$58
                            	   108: SC_ALT		EQU		$11
                            	   109: SC_LSHIFT	EQU		$12
                            	   110: SC_DEL		EQU		$71		; extend
                            	   111: SC_LCTRL	EQU		$58
                            	   112: SC_TAB      EQU		$0D
                            	   113: 
                            	   114: 	if HAS_MMU
                            	   115: TEXTREG		EQU	$1E3FF00	; virtual addresses
                            	   116: txtscreen	EQU	$1E00000
                            	   117: semamem		EQU	$1E50000
                            	   118: ACIA			EQU	$1E60000
                            	   119: ACIA_RX		EQU	0
                            	   120: ACIA_TX		EQU	0
                            	   121: ACIA_STAT	EQU	4
                            	   122: ACIA_CMD	EQU	8
                            	   123: ACIA_CTRL	EQU	12
                            	   124: I2C2 			equ $01E69000
                            	   125: I2C_PREL 	equ 0
                            	   126: I2C_PREH 	equ 1
                            	   127: I2C_CTRL 	equ 2
                            	   128: I2C_RXR 	equ 3
                            	   129: I2C_TXR 	equ 3
                            	   130: I2C_CMD 	equ 4
                            	   131: I2C_STAT 	equ 4
                            	   132: PLIC			EQU	$1E90000
                            	   133: MMU				EQU $FDC00000	; physical address
                            	   134: leds			EQU	$1EFFF00	; virtual addresses
                            	   135: keybd			EQU	$1EFFE00
                            	   136: KEYBD			EQU	$1EFFE00
                            	   137: RAND			EQU	$1EFFD00
                            	   138: RAND_NUM	EQU	$1EFFD00
                            	   139: RAND_STRM	EQU	$1EFFD04
                            	   140: RAND_MZ		EQU $1EFFD08
                            	   141: RAND_MW		EQU	$1EFFD0C
                            	   142: RST_REG		EQU	$1EFFC00
                            	   143: IO_BITMAP	EQU $1F00000
                            	   144: 	else
                            	   145: TEXTREG		EQU	$FD080000
                            	   146: txtscreen	EQU	$FD000000
                            	   147: semamem		EQU	$FD050000
                            	   148: ACIA			EQU	$FD060000
                            	   149: ACIA_RX		EQU	0
                            	   150: ACIA_TX		EQU	0
                            	   151: ACIA_STAT	EQU	4
                            	   152: ACIA_CMD	EQU	8
                            	   153: ACIA_CTRL	EQU	12
                            	   154: I2C2 			equ $FD069000
                            	   155: I2C_PREL 	equ 0
                            	   156: I2C_PREH 	equ 1
                            	   157: I2C_CTRL 	equ 2
                            	   158: I2C_RXR 	equ 3
                            	   159: I2C_TXR 	equ 3
                            	   160: I2C_CMD 	equ 4
                            	   161: I2C_STAT 	equ 4
                            	   162: PLIC			EQU	$FD090000
                            	   163: MMU				EQU $FDC00000	; physical address
                            	   164: leds			EQU	$FD0FFF00	; virtual addresses
                            	   165: keybd			EQU	$FD0FFE00
                            	   166: KEYBD			EQU	$FD0FFE00
                            	   167: RAND			EQU	$FD0FFD00
                            	   168: RAND_NUM	EQU	$FD0FFD00
                            	   169: RAND_STRM	EQU	$FD0FFD04
                            	   170: RAND_MZ		EQU $FD0FFD08
                            	   171: RAND_MW		EQU	$FD0FFD0C
                            	   172: RST_REG		EQU	$FD0FFC00
                            	   173: IO_BITMAP	EQU $FD100000
                            	   174: 	endif
                            	   175: 
                            	   176: SERIAL_SEMA	EQU	2
                            	   177: KEYBD_SEMA	EQU	3
                            	   178: RAND_SEMA		EQU	4
                            	   179: SCREEN_SEMA	EQU	5
                            	   180: MEMORY_SEMA EQU 6
                            	   181: TCB_SEMA 		EQU	7
                            	   182: FMTK_SEMA		EQU	8
                            	   183: 
                            	   184: 	data
00:00000000 00040FFC        	   185: 	dc.l		$00040FFC
00:00000004 00000000        	   186: 	dc.l		start
00:00000008 00007A12        	   187: 	dc.l		bus_err
00:0000000C 00007DAE        	   188: 	dc.l		addr_err
00:00000010 00007DFC        	   189: 	dc.l		illegal_trap		* ILLEGAL instruction
00:00000014 00000000        	   190: 	dc.l		0
00:00000018 000002DA        	   191: 	dc.l		chk_exception		; CHK
00:0000001C 00000422        	   192: 	dc.l		EXCEPTION_7			* TRAPV
00:00000020 00000000        	   193: 	dc.l		0
00:00000024 00000000        	   194: 	dc.l		0
                            	   195: 	
                            	   196: 	; 10
00:00000028 00000000        	   197: 	dc.l		0
00:0000002C 00000000        	   198: 	dc.l		0
00:00000030 00000000        	   199: 	dc.l		0
00:00000034 00000000        	   200: 	dc.l		0
00:00000038 00000000        	   201: 	dc.l		0
00:0000003C 00000000        	   202: 	dc.l		0
00:00000040 00000000        	   203: 	dc.l		0
00:00000044 00000000        	   204: 	dc.l		0
00:00000048 00000000        	   205: 	dc.l		0
00:0000004C 00000000        	   206: 	dc.l		0
                            	   207: 	
                            	   208: 	; 20
00:00000050 00000000        	   209: 	dc.l		0
00:00000054 00000000        	   210: 	dc.l		0
00:00000058 00000000        	   211: 	dc.l		0
00:0000005C 00000000        	   212: 	dc.l		0
00:00000060 00007D9A        	   213: 	dc.l		SpuriousIRQ
00:00000064 00000000        	   214: 	dc.l		0
00:00000068 00000000        	   215: 	dc.l		0
00:0000006C 00007D74        	   216: 	dc.l		irq3_rout
00:00000070 00000000        	   217: 	dc.l		0
00:00000074 00000000        	   218: 	dc.l		0
                            	   219: 	
                            	   220: 	; 30
00:00000078 00007D26        	   221: 	dc.l		TickIRQ						; IRQ 30 - timer / keyboard
00:0000007C 00007D9C        	   222: 	dc.l		nmi_rout
00:00000080 00000000        	   223: 	dc.l		0
00:00000084 00000000        	   224: 	dc.l		0
00:00000088 00000000        	   225: 	dc.l		0
00:0000008C 00007A16        	   226: 	dc.l		trap3							; breakpoint
00:00000090 00000000        	   227: 	dc.l		0
00:00000094 00000000        	   228: 	dc.l		0
00:00000098 00000000        	   229: 	dc.l		0
00:0000009C 00000000        	   230: 	dc.l		0
                            	   231: 
                            	   232: 	; 40
00:000000A0 00000000        	   233: 	dc.l		0
00:000000A4 00000000        	   234: 	dc.l		0
00:000000A8 00000000        	   235: 	dc.l		0
00:000000AC 00000000        	   236: 	dc.l		0
00:000000B0 00000000        	   237: 	dc.l		0
00:000000B4 00000000        	   238: 	dc.l		0
00:000000B8 00000000        	   239: 	dc.l		0
00:000000BC 00005C18        	   240: 	dc.l		TRAP15
00:000000C0 00000000        	   241: 	dc.l		0
00:000000C4 00000000        	   242: 	dc.l		0
                            	   243: 
                            	   244: 	; 50	
00:000000C8 00000000        	   245: 	dc.l		0
00:000000CC 00000000        	   246: 	dc.l		0
00:000000D0 00000000        	   247: 	dc.l		0
00:000000D4 00000000        	   248: 	dc.l		0
00:000000D8 00000000        	   249: 	dc.l		0
00:000000DC 00000000        	   250: 	dc.l		0
00:000000E0 00000000        	   251: 	dc.l		0
00:000000E4 00000000        	   252: 	dc.l		0
00:000000E8 00000000        	   253: 	dc.l		0
00:000000EC 00007E12        	   254: 	dc.l		io_irq
                            	   255: 
                            	   256: 	; 60
00:000000F0 00006286        	   257: 	dc.l		KeybdIRQ
00:000000F4 00007814        	   258: 	dc.l		SerialIRQ
00:000000F8 00000000        	   259: 	dc.l		0
00:000000FC 00007DC4        	   260: 	dc.l		brdisp_trap
00:00000100 00000000        	   261: 	dc.l		0
00:00000104 00000000        	   262: 	dc.l		0
00:00000108 00000000        	   263: 	dc.l		0
00:0000010C 00000000        	   264: 	dc.l		0
00:00000110 00000000        	   265: 	dc.l		0
00:00000114 00000000        	   266: 	dc.l		0
                            	   267: 
                            	   268: 	org			$400
                            	   269: 
                            	   270: InstalledIRQ:
00:00000400 00000000        	   271: 	dc.l		0
00:00000404 00000000        	   272: 	dc.l		0
00:00000408 00000000        	   273: 	dc.l		0
00:0000040C 00000000        	   274: 	dc.l		0
00:00000410 00000000        	   275: 	dc.l		0
00:00000414 00000000        	   276: 	dc.l		0
00:00000418 00000000        	   277: 	dc.l		0
00:0000041C 00000000        	   278: 	dc.l		0
                            	   279: 
00:00000420 00000000        	   280: 	dc.l		0
00:00000424 00000000        	   281: 	dc.l		0
00:00000428 00000000        	   282: 	dc.l		0
00:0000042C 00000000        	   283: 	dc.l		0
00:00000430 00000000        	   284: 	dc.l		0
00:00000434 00000000        	   285: 	dc.l		0
00:00000438 00000000        	   286: 	dc.l		0
00:0000043C 00000000        	   287: 	dc.l		0
                            	   288: 
00:00000440 00000000        	   289: 	dc.l		0
00:00000444 00000000        	   290: 	dc.l		0
00:00000448 00000000        	   291: 	dc.l		0
00:0000044C 00000000        	   292: 	dc.l		0
00:00000450 00000000        	   293: 	dc.l		0
00:00000454 00000000        	   294: 	dc.l		0
00:00000458 00000000        	   295: 	dc.l		0
00:0000045C 00000000        	   296: 	dc.l		0
                            	   297: 
00:00000460 00000000        	   298: 	dc.l		0
00:00000464 00000000        	   299: 	dc.l		0
00:00000468 00000000        	   300: 	dc.l		0
00:0000046C 00000000        	   301: 	dc.l		0
00:00000470 00000000        	   302: 	dc.l		0
00:00000474 00000000        	   303: 	dc.l		0
00:00000478 00000000        	   304: 	dc.l		0
00:0000047C 00000000        	   305: 	dc.l		0
                            	   306: 
00:00000480 00000000        	   307: 	dc.l		0
00:00000484 00000000        	   308: 	dc.l		0
00:00000488 00000000        	   309: 	dc.l		0
00:0000048C 00000000        	   310: 	dc.l		0
00:00000490 00000000        	   311: 	dc.l		0
00:00000494 00000000        	   312: 	dc.l		0
00:00000498 00000000        	   313: 	dc.l		0
00:0000049C 00000000        	   314: 	dc.l		0
                            	   315: 
00:000004A0 00000000        	   316: 	dc.l		0
00:000004A4 00000000        	   317: 	dc.l		0
00:000004A8 00000000        	   318: 	dc.l		0
00:000004AC 00000000        	   319: 	dc.l		0
00:000004B0 00000000        	   320: 	dc.l		0
00:000004B4 00000000        	   321: 	dc.l		0
00:000004B8 00000000        	   322: 	dc.l		0
00:000004BC 00000000        	   323: 	dc.l		0
                            	   324: 
00:000004C0 00000000        	   325: 	dc.l		0
00:000004C4 00000000        	   326: 	dc.l		0
00:000004C8 00000000        	   327: 	dc.l		0
00:000004CC 00000000        	   328: 	dc.l		0
00:000004D0 00000000        	   329: 	dc.l		0
00:000004D4 00000000        	   330: 	dc.l		0
00:000004D8 00000000        	   331: 	dc.l		0
00:000004DC 00000000        	   332: 	dc.l		0
                            	   333: 
00:000004E0 00000000        	   334: 	dc.l		0
00:000004E4 00000000        	   335: 	dc.l		0
00:000004E8 00000000        	   336: 	dc.l		0
00:000004EC 00000000        	   337: 	dc.l		0
00:000004F0 00000000        	   338: 	dc.l		0
00:000004F4 00000000        	   339: 	dc.l		0
00:000004F8 00000000        	   340: 	dc.l		0
00:000004FC 00000000        	   341: 	dc.l		0
                            	   342: 
                            	   343: 	org			$500
                            	   344: 
                            	   345: ;-------------------------------------------------------------------------------
                            	   346: ;-------------------------------------------------------------------------------
                            	   347: 
                            	   348: ; BIOS variables which must be local (not shared) to each core
                            	   349: 
                            	   350: CursorRow	equ		$40000
                            	   351: CursorCol	equ		$40001
                            	   352: TextPos		equ		$40002
                            	   353: TextCurpos	equ	$40002
                            	   354: TextScr			equ	$40004
                            	   355: S19StartAddress	equ	$40008
                            	   356: KeybdEcho		equ	$4000C
                            	   357: KeybdWaitFlag	equ	$4000D
                            	   358: CmdBuf			equ $40040
                            	   359: CmdBufEnd		equ	$40080
                            	   360: fgColor			equ	$40084
                            	   361: bkColor			equ	$40088
                            	   362: TextRows		equ	$4008C
                            	   363: TextCols		equ	$4008D
                            	   364: _fpTextIncr	equ $40094
                            	   365: _canary			equ $40098
                            	   366: IRQFlag			equ $400A0
                            	   367: InputDevice	equ $400A4
                            	   368: OutputDevice	equ $400A8
                            	   369: Regsave			equ	$40100
                            	   370: numBreakpoints	equ		8
                            	   371: BreakpointFlag	equ		$40200
                            	   372: NumSetBreakpoints	equ	$40202	; to $40203
                            	   373: Breakpoints			equ		$40220	; to $40240
                            	   374: BreakpointWords	equ		$40280	; to $402A0
                            	   375: fpBuf       equ $402C0
                            	   376: ;RunningTCB  equ $40300
                            	   377: _exp equ $40500
                            	   378: _digit equ $40504
                            	   379: _width equ $40508
                            	   380: _E equ $4050C
                            	   381: _digits_before_decpt equ $40510
                            	   382: _precision equ $40514
                            	   383: _fpBuf equ $40520	; to $40560
                            	   384: _fpWork equ $40600
                            	   385: TimerStack	equ	$40BFC
                            	   386: 
                            	   387: ; Keyboard buffer is in shared memory
                            	   388: IOFocus			EQU	$00100000
                            	   389: memend			equ $00100004
                            	   390: KeybdLEDs		equ	$0010000E
                            	   391: _KeyState1	equ	$0010000F
                            	   392: _KeyState2	equ	$00100010
                            	   393: _KeybdHead	equ	$00100011
                            	   394: _KeybdTail	equ	$00100012
                            	   395: _KeybdCnt		equ	$00100013
                            	   396: KeybdID			equ	$00100016
                            	   397: _KeybdBuf		equ	$00100020
                            	   398: S19Checksum	equ	$00100150
                            	   399: SerTailRcv	equ	$00100160
                            	   400: SerHeadRcv	equ	$00100162
                            	   401: SerRcvXon		equ	$00100164
                            	   402: SerRcvXoff	equ	$00100165
                            	   403: SerRcvBuf		equ	$00101000
                            	   404: RTCBuf			equ $00100200	; to $0010023F
                            	   405: 
                            	   406: 	code
                            	   407: 	align		2
                            	   408: start:
                            	   409: ;	fadd (a0)+,fp2
02:00000000 46FC2700        	   410: 	move.w #$2700,sr					; enable level 6 and higher interrupts
02:00000004 7000            	   411: 	moveq #0,d0								; set address space zero
02:00000006 4E7B0003        	   412: 	movec d0,asid
                            	   413: 	; Setup circuit select signals
02:0000000A 203CFDC00000    	   414: 	move.l #MMU,d0
02:00000010 4E7B0014        	   415: 	movec d0,mmus
                            	   416: 	if HAS_MMU
                            	   417: 		move.l #$01F00000,d0			; set virtual address for iop bitmap
                            	   418: 		movec d0,iops
                            	   419: 		move.l #$01E00000,d0			; set virtual address for io block
                            	   420: 		movec d0,ios
                            	   421: 	else
02:00000014 203CFD100000    	   422: 		move.l #$FD100000,d0			; set virtual address for iop bitmap
02:0000001A 4E7B0016        	   423: 		movec d0,iops
02:0000001E 203CFD000000    	   424: 		move.l #$FD000000,d0			; set virtual address for io block
02:00000024 4E7B0015        	   425: 		movec d0,ios
                            	   426: 	endif
02:00000028 4E7A0FE0        	   427: 	movec coreno,d0							; set initial value of thread register
02:0000002C 4840            	   428: 	swap d0											; coreno in high eight bits
02:0000002E E188            	   429: 	lsl.l #8,d0
02:00000030 4E7B0012        	   430: 	movec d0,tr
                            	   431: 	; Prepare local variable storage
02:00000034 303C03FF        	   432: 	move.w #1023,d0						; 1024 longs to clear
02:00000038 41F900040000    	   433: 	lea	$40000,a0							; non shared local memory address
                            	   434: .0111:
02:0000003E 4298            	   435: 	clr.l	(a0)+								; clear the memory area
02:00000040 51C8FFFC        	   436: 	dbra d0,.0111
02:00000044 13FC0001000400A8	   437: 	move.b #1,OutputDevice		; select stdout
02:0000004C 23FC001FFFFF0004	   438: 	move.l #$1fffff,fgColor		; set foreground / background color
02:00000054 0084
02:00000056 23FC0000003F0004	   439: 	move.l #$00003f,bkColor
02:0000005E 0088
02:00000060 4E7A0FE0        	   440: 	movec.l	coreno,d0					; get core number (2 to 9)
02:00000064 5500            	   441: 	subi.b #2,d0							; adjust (0 to 7)
02:00000066 C0FC4000        	   442: 	mulu #16384,d0						; compute screen location
                            	   443: 	if HAS_MMU
                            	   444: 		addi.l #$01E00000,d0
                            	   445: 	else
02:0000006A 0680FD000000    	   446: 		addi.l #$FD000000,d0
                            	   447: 	endif
02:00000070 23C000040004    	   448: 	move.l d0,TextScr
02:00000076 13FC00400004008D	   449: 	move.b #64,TextCols				; set rows and columns
02:0000007E 13FC00200004008C	   450: 	move.b #32,TextRows
02:00000086 4E7A0FE0        	   451: 	movec.l	coreno,d0					; get core number
02:0000008A 0C000002        	   452: 	cmpi.b #2,d0
02:0000008E 667C            	   453: 	bne	start_other
02:00000090 13C000100000    	   454: 	move.b d0,IOFocus					; Set the IO focus in global memory
                            	   455: 	if HAS_MMU
                            	   456: 		bsr InitMMU							; Can't access anything till this is done'
                            	   457: 	endif
02:00000096 610000A4        	   458: 	bsr	InitIOPBitmap					; not going to get far without this
02:0000009A 61000196        	   459: 	bsr	InitSemaphores
02:0000009E 610000EC        	   460: 	bsr	InitRand
02:000000A2 61000128        	   461: 	bsr RandGetNum
02:000000A6 0281FFFFFF00    	   462: 	andi.l #$FFFFFF00,d1
02:000000AC 23C100040098    	   463: 	move.l d1,_canary
02:000000B2 4E7B1020        	   464: 	movec d1,canary
02:000000B6 61000236        	   465: 	bsr	Delay3s						; give devices time to reset
02:000000BA 6100578A        	   466: 	bsr	clear_screen
                            	   467: 
02:000000BE 61005D44        	   468: 	bsr	_KeybdInit
                            	   469: ;	bsr	InitIRQ
02:000000C2 61007610        	   470: 	bsr	SerialInit
02:000000C6 610077DC        	   471: 	bsr init_i2c
                            	   472: ;	bsr rtc_read
                            	   473: 
                            	   474: 	; Write startup message to screen
                            	   475: 
02:000000CA 43FA7D5A        	   476: 	lea	msg_start,a1
02:000000CE 61005ABE        	   477: 	bsr	DisplayString
                            	   478: ;	bsr	FemtikiInit
02:000000D2 4E7A0FE0        	   479: 	movec	coreno,d0
02:000000D6 4840            	   480: 	swap d0
02:000000D8 7201            	   481: 	moveq	#1,d1
02:000000DA 610001B8        	   482: 	bsr	UnlockSemaphore	; allow another cpu access
02:000000DE 7200            	   483: 	moveq	#0,d1
02:000000E0 610001B2        	   484: 	bsr	UnlockSemaphore	; allow other cpus to proceed
02:000000E4 33FCA4A4FD0FFF00	   485: 	move.w #$A4A4,leds			; diagnostics
02:000000EC 61005C76        	   486: 	bsr	init_plic				; initialize platform level interrupt controller
02:000000F0 6000659C        	   487: 	bra	StartMon
02:000000F4 61000238        	   488: 	bsr	cpu_test
                            	   489: ;	lea	brdisp_trap,a0	; set brdisp trap vector
                            	   490: ;	move.l	a0,64*4
                            	   491: 
                            	   492: loop2:
02:000000F8 70FF            	   493: 	move.l	#-1,d0
                            	   494: loop1:
02:000000FA 2200            	   495: 	move.l	d0,d1
02:000000FC E089            	   496: 	lsr.l		#8,d1
02:000000FE E089            	   497: 	lsr.l		#8,d1
02:00000100 13C1FD0FFF00    	   498: 	move.b	d1,leds
02:00000106 51C8FFF2        	   499: 	dbra		d0,loop1
02:0000010A 60EC            	   500: 	bra			loop2
                            	   501: 
                            	   502: start_other:
02:0000010C 61000204        	   503: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
02:00000110 61000200        	   504: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
02:00000114 610001FC        	   505: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
02:00000118 6100572C        	   506: 	bsr			clear_screen
02:0000011C 4E7A1FE0        	   507: 	movec		coreno,d1
02:00000120 6100727E        	   508: 	bsr			DisplayByte
02:00000124 43FA7D27        	   509: 	lea			msg_core_start,a1
02:00000128 61005A64        	   510: 	bsr			DisplayString
                            	   511: ;	bsr			FemtikiInitIRQ
                            	   512: do_nothing:	
02:0000012C 60006560        	   513: 	bra			StartMon
02:00000130 60FA            	   514: 	bra			do_nothing
                            	   515: 
                            	   516: ;------------------------------------------------------------------------------
                            	   517: ; Initialize the MMU to allow thread #0 access to IO
                            	   518: ;------------------------------------------------------------------------------
                            	   519: 	if HAS_MMU
                            	   520: 	align 2
                            	   521: mmu_adrtbl:	; virtual address[24:16], physical address[31:16] bytes reversed!
                            	   522: 	dc.l	$0010,$10000300	; global scratch pad
                            	   523: 	dc.l	$01E0,$00FD0300	
                            	   524: 	dc.l	$01E1,$01FD0300
                            	   525: 	dc.l	$01E2,$02FD0300
                            	   526: 	dc.l  $01E3,$03FD0300
                            	   527: 	dc.l	$01E5,$05FD0300
                            	   528: 	dc.l	$01E6,$06FD0300
                            	   529: 	dc.l	$01E9,$09FD0300
                            	   530: 	dc.l	$01EF,$0FFD0300
                            	   531: 	dc.l	$01F0,$10FD0300
                            	   532: 	dc.l  $01FF,$FFFF0300	; all ones output for IRQ ack needed
                            	   533: 
                            	   534: 	even
                            	   535: InitMMU:
                            	   536: 	lea MMU+8,a0				; first 128kB is local RAM
                            	   537: 	move.l #$32000,d2		; map all pages to DRAM
                            	   538: 	move.l #510,d0			; then override for IO later
                            	   539: .0002
                            	   540: 	move.l d2,d1
                            	   541: 	bsr rbo
                            	   542: 	move.l d1,(a0)+
                            	   543: 	addi.w #1,d2				; increment DRAM page number
                            	   544: 	dbra d0,.0002
                            	   545: 	lea MMU,a0					; now program IO access
                            	   546: 	lea mmu_adrtbl,a1
                            	   547: 	moveq #10,d0
                            	   548: .0001
                            	   549: 	move.l (a1)+,d2
                            	   550: 	lsl.l #2,d2
                            	   551: 	move.l (a1)+,(a0,d2.w)
                            	   552: 	dbra d0,.0001
                            	   553: 	rts	
                            	   554: 	endif
                            	   555: 
                            	   556: ;------------------------------------------------------------------------------
                            	   557: ;------------------------------------------------------------------------------
                            	   558: 
                            	   559: ;------------------------------------------------------------------------------
                            	   560: ;------------------------------------------------------------------------------
                            	   561: 
                            	   562: GlobalReadLong:
02:00000132 2210            	   563: 		move.l (a0),d1
02:00000134 6002            	   564: 		bra nd1
                            	   565: GlobalWriteLong:
02:00000136 2081            	   566: 		move.l d1,(a0)
                            	   567: net_delay:
                            	   568: 		bra nd1
                            	   569: nd1	bra nd2
                            	   570: nd2 bra nd3
                            	   571: nd3 bra nd4
02:00000138 4E71            	   572: nd4	nop
02:0000013A 4E75            	   573: 		rts
                            	   574: 	
                            	   575: 
                            	   576: ;------------------------------------------------------------------------------
                            	   577: ; The IO bitmap needs to be initialized to allow access to IO.
                            	   578: ;------------------------------------------------------------------------------
                            	   579: 
                            	   580: InitIOPBitmap:
02:0000013C 7600            	   581: 	moveq #0,d3				; d3 = asid value
02:0000013E 303C003F        	   582: 	move.w #63,d0			; 64 bitmaps to setup
02:00000142 4E7A8016        	   583: 	movec iops,a0			; a0 = IOP bitmap address
02:00000146 2248            	   584: 	movea.l a0,a1			; a1 = table address
                            	   585: .0004
02:00000148 4A03            	   586: 	tst.b d3
02:0000014A 57C1            	   587: 	seq d1						; set entire bitmap for asid 0, otherwise clear entire bitmap
02:0000014C 4881            	   588: 	ext.w	d1					; make into a long value
02:0000014E 48C1            	   589: 	ext.l d1
02:00000150 383C007F        	   590: 	move.w #127,d4
                            	   591: .0001
02:00000154 22C1            	   592: 	move.l d1,(a1)+		; set or clear entire table
02:00000156 51CCFFFC        	   593: 	dbra d4,.0001
02:0000015A 72FF            	   594: 	moveq #-1,d1
02:0000015C 214100A0        	   595: 	move.l d1,160(a0)	; all cores have access to semaphores
02:00000160 214100A4        	   596: 	move.l d1,164(a0)
02:00000164 214100A8        	   597: 	move.l d1,168(a0)
02:00000168 214100AC        	   598: 	move.l d1,172(a0)
02:0000016C 217C0000000201FC	   599: 	move.l #2,508(a0)	; all cores access random # generator
02:00000174 4840            	   600: 	swap d0
02:00000176 303C001F        	   601: 	move.w #31,d0			; 32 long words for the screen area per bitmap
                            	   602: .0003
02:0000017A 20C1            	   603: 	move.l d1,(a0)+		; all cores have access to a screen
02:0000017C 51C8FFFC        	   604: 	dbra d0,.0003
02:00000180 4840            	   605: 	swap d0
02:00000182 5203            	   606: 	addi.b #1,d3			; do next address space
02:00000184 2049            	   607: 	movea.l a1,a0			; a0 points to area for next address space
02:00000186 51C8FFC0        	   608: 	dbra d0,.0004
02:0000018A 4E75            	   609: 	rts	
                            	   610: 	
                            	   611: ;------------------------------------------------------------------------------
                            	   612: ; RandInit
                            	   613: ; 	Initialize random number generator.
                            	   614: ;
                            	   615: ; Modifies:
                            	   616: ;		none
                            	   617: ; Parameters:
                            	   618: ;		none
                            	   619: ;	Returns:
                            	   620: ;		none
                            	   621: ;------------------------------------------------------------------------------
                            	   622: 
                            	   623: InitRand:
                            	   624: RandInit:
02:0000018C 48E7C000        	   625: 	movem.l	d0/d1,-(a7)
02:00000190 7025            	   626: 	moveq #37,d0								; lock semaphore
02:00000192 7204            	   627: 	moveq	#RAND_SEMA,d1
02:00000194 4E4F            	   628: 	trap #15
02:00000196 4E7A0FE0        	   629: 	movec coreno,d0							; d0 = core number
02:0000019A ED88            	   630: 	lsl.l	#6,d0									; allow 64 streams per core
02:0000019C 23C0FD0FFD04    	   631: 	move.l d0,RAND_STRM					; select the stream
02:000001A2 23FC12345678FD0F	   632: 	move.l #$12345678,RAND_MZ		; initialize to some value
02:000001AA FD08
02:000001AC 23FC98765432FD0F	   633: 	move.l #$98765432,RAND_MW
02:000001B4 FD0C
02:000001B6 23FC2E5BF271FD0F	   634: 	move.l #777777777,RAND_NUM	; generate first number
02:000001BE FD00
02:000001C0 7026            	   635: 	moveq #38,d0								; unlock semaphore
02:000001C2 7204            	   636: 	moveq	#RAND_SEMA,d1
02:000001C4 4E4F            	   637: 	trap #15
02:000001C6 4CDF0003        	   638: 	movem.l	(a7)+,d0/d1
02:000001CA 4E75            	   639: 	rts
                            	   640: 
                            	   641: ;------------------------------------------------------------------------------
                            	   642: ; Returns
                            	   643: ;		d1 = random integer
                            	   644: ;------------------------------------------------------------------------------
                            	   645: 
                            	   646: RandGetNum:
02:000001CC 48E7A000        	   647: 	movem.l	d0/d2,-(a7)
02:000001D0 7204            	   648: 	moveq #RAND_SEMA,d1
02:000001D2 610000DC        	   649: 	bsr T15LockSemaphore
02:000001D6 4E7A0FE0        	   650: 	movec	coreno,d0
02:000001DA ED88            	   651: 	lsl.l	#6,d0
02:000001DC 23C0FD0FFD04    	   652: 	move.l d0,RAND_STRM					; select the stream
02:000001E2 2439FD0FFD00    	   653: 	move.l RAND_NUM,d2					; d2 = random number
02:000001E8 42B9FD0FFD00    	   654: 	clr.l	RAND_NUM							; generate next number
02:000001EE 610000C6        	   655: 	bsr T15UnlockSemaphore
02:000001F2 2202            	   656: 	move.l d2,d1
02:000001F4 4CDF0005        	   657: 	movem.l	(a7)+,d0/d2
02:000001F8 4E75            	   658: 	rts
                            	   659: 
                            	   660: ;------------------------------------------------------------------------------
                            	   661: ; Modifies:
                            	   662: ;		none
                            	   663: ; Returns
                            	   664: ;		fp0 = random float between 0 and 1.
                            	   665: ;------------------------------------------------------------------------------
                            	   666: 
                            	   667: _GetRand:
02:000001FA 2F01            	   668: 	move.l d1,-(sp)
02:000001FC F2276880        	   669: 	fmove.x fp1,-(sp)
02:00000200 61CA            	   670: 	bsr RandGetNum
02:00000202 E289            	   671: 	lsr.l #1,d1									; make number between 0 and 2^31
02:00000204 F2014000        	   672: 	fmove.l d1,fp0
02:00000208 F23C40807FFFFFFF	   673: 	fmove.l #$7FFFFFFF,fp1			; divide by 2^31
02:00000210 F2000420        	   674: 	fdiv fp1,fp0
02:00000214 F21F4880        	   675: 	fmove.x (sp)+,fp1
02:00000218 221F            	   676: 	move.l (sp)+,d1
02:0000021A 4E75            	   677: 	rts
                            	   678: 
                            	   679: ;------------------------------------------------------------------------------
                            	   680: ; RandWait
                            	   681: ;    Wait some random number of clock cycles before returning.
                            	   682: ;------------------------------------------------------------------------------
                            	   683: 
                            	   684: RandWait:
02:0000021C 48E7C000        	   685: 	movem.l	d0/d1,-(a7)
02:00000220 61AA            	   686: 	bsr			RandGetNum
02:00000222 0241000F        	   687: 	andi.w	#15,d1
                            	   688: .0001:
02:00000226 4E71            	   689: 	nop
02:00000228 51C9FFFC        	   690: 	dbra		d1,.0001
02:0000022C 4CDF0003        	   691: 	movem.l	(a7)+,d0/d1
02:00000230 4E75            	   692: 	rts
                            	   693: 
                            	   694: ;------------------------------------------------------------------------------
                            	   695: ; Initialize semaphores
                            	   696: ; - all semaphores are set to unlocked except the first one, which is locked
                            	   697: ; for core #2.
                            	   698: ;
                            	   699: ; Parameters:
                            	   700: ;		<none>
                            	   701: ; Modifies:
                            	   702: ;		<none>
                            	   703: ; Returns:
                            	   704: ;		<none>
                            	   705: ;------------------------------------------------------------------------------
                            	   706: 
                            	   707: InitSemaphores:
02:00000232 48E74080        	   708: 	movem.l	d1/a0,-(a7)
02:00000236 41F9FD050000    	   709: 	lea			semamem,a0
02:0000023C 217C000200002000	   710: 	move.l	#$20000,$2000(a0)	; lock the first semaphore for core #2, thread #0
02:00000244 323C00FE        	   711: 	move.w	#254,d1
                            	   712: .0001:
02:00000248 5888            	   713: 	lea			4(a0),a0
02:0000024A 42A82000        	   714: 	clr.l		$2000(a0)					; write zeros to unlock
02:0000024E 51C9FFF8        	   715: 	dbra		d1,.0001
02:00000252 4CDF0102        	   716: 	movem.l	(a7)+,d1/a0
02:00000256 4E75            	   717: 	rts
                            	   718: 
                            	   719: ; -----------------------------------------------------------------------------
                            	   720: ; Parameters:
                            	   721: ;		d1 semaphore number
                            	   722: ;
                            	   723: ; Side Effects:
                            	   724: ;		increments semaphore, saturates at 255
                            	   725: ;
                            	   726: ; Returns:	
                            	   727: ; 	z flag set if semaphore was zero
                            	   728: ; -----------------------------------------------------------------------------
                            	   729: 
                            	   730: ;IncrementSemaphore:
                            	   731: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   732: ;	lea			semamem,a0			; point to semaphore memory
                            	   733: ;	ext.w		d1							; make d1 word value
                            	   734: ;	asl.w		#4,d1						; align to memory
                            	   735: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   736: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   737: ;	rts
                            	   738: 	
                            	   739: ; -----------------------------------------------------------------------------
                            	   740: ; Parameters:
                            	   741: ;		d1 semaphore number
                            	   742: ;
                            	   743: ; Side Effects:
                            	   744: ;		decrements semaphore, saturates at zero
                            	   745: ;
                            	   746: ; Returns:	
                            	   747: ; 	z flag set if semaphore was zero
                            	   748: ; -----------------------------------------------------------------------------
                            	   749: 
                            	   750: ;DecrementSemaphore:
                            	   751: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   752: ;	lea			semamem,a0			; point to semaphore memory
                            	   753: ;	andi.w	#255,d1					; make d1 word value
                            	   754: ;	asl.w		#4,d1						; align to memory
                            	   755: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   756: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   757: ;	rts
                            	   758: 
                            	   759: ; -----------------------------------------------------------------------------
                            	   760: ; Lock a semaphore
                            	   761: ;
                            	   762: ; Parameters:
                            	   763: ;		d0 = key
                            	   764: ;		d1 = semaphore number
                            	   765: ; -----------------------------------------------------------------------------
                            	   766: 
                            	   767: LockSemaphore:
02:00000258 4E75            	   768: 	rts
02:0000025A 48E74080        	   769: 	movem.l	d1/a0,-(a7)			; save registers
02:0000025E 41F9FD050000    	   770: 	lea			semamem,a0			; point to semaphore memory lock area
02:00000264 024100FF        	   771: 	andi.w	#255,d1					; make d1 word value
02:00000268 E549            	   772: 	lsl.w		#2,d1						; align to memory
                            	   773: .0001
02:0000026A 21801000        	   774: 	move.l	d0,(a0,d1.w)		; try and write the semaphore
02:0000026E B0B01000        	   775: 	cmp.l		(a0,d1.w),d0		; did it lock?
02:00000272 66F6            	   776: 	bne.s		.0001						; no, try again
02:00000274 4CDF0102        	   777: 	movem.l	(a7)+,a0/d1			; restore regs
02:00000278 4E75            	   778: 	rts
                            	   779: 	
                            	   780: ; -----------------------------------------------------------------------------
                            	   781: ; Unlocks a semaphore even if not the owner.
                            	   782: ;
                            	   783: ; Parameters:
                            	   784: ;		d1 semaphore number
                            	   785: ; -----------------------------------------------------------------------------
                            	   786: 
                            	   787: ForceUnlockSemaphore:
02:0000027A 48E74080        	   788: 	movem.l	d1/a0,-(a7)				; save registers
02:0000027E 41F9FD053000    	   789: 	lea			semamem+$3000,a0	; point to semaphore memory read/write area
02:00000284 024100FF        	   790: 	andi.w	#255,d1						; make d1 word value
02:00000288 E549            	   791: 	lsl.w		#2,d1							; align to memory
02:0000028A 42B01000        	   792: 	clr.l		(a0,d1.w)					; write zero to unlock
02:0000028E 4CDF0102        	   793: 	movem.l	(a7)+,a0/d1				; restore regs
02:00000292 4E75            	   794: 	rts
                            	   795: 
                            	   796: ; -----------------------------------------------------------------------------
                            	   797: ; Unlocks a semaphore. Must be the owner to have effect.
                            	   798: ; Three cases:
                            	   799: ;	1) the owner, the semaphore will be reset to zero
                            	   800: ;	2) not the owner, the write will be ignored
                            	   801: ; 3) already unlocked, the write will be ignored
                            	   802: ;
                            	   803: ; Parameters:
                            	   804: ;		d0 = key
                            	   805: ;		d1 = semaphore number
                            	   806: ; -----------------------------------------------------------------------------
                            	   807: 
                            	   808: UnlockSemaphore:
02:00000294 60E4            	   809: 	bra ForceUnlockSemaphore
02:00000296 48E74080        	   810: 	movem.l	d1/a0,-(a7)				; save registers
02:0000029A 41F9FD051000    	   811: 	lea			semamem+$1000,a0	; point to semaphore memory unlock area
02:000002A0 024100FF        	   812: 	andi.w	#255,d1						; make d1 word value
02:000002A4 E549            	   813: 	lsl.w		#2,d1							; align to memory
02:000002A6 21801000        	   814: 	move.l	d0,(a0,d1.w)			; write matching value to unlock
02:000002AA 4CDF0102        	   815: 	movem.l	(a7)+,a0/d1				; restore regs
02:000002AE 4E75            	   816: 	rts
                            	   817: 
                            	   818: ; -----------------------------------------------------------------------------
                            	   819: ; Parameters:
                            	   820: ;		d1 = semaphore to lock / unlock
                            	   821: ; -----------------------------------------------------------------------------
                            	   822: 
                            	   823: T15LockSemaphore:	
02:000002B0 4E7A0012        	   824: 	movec tr,d0
02:000002B4 60A2            	   825: 	bra LockSemaphore
                            	   826: 
                            	   827: T15UnlockSemaphore:
02:000002B6 4E7A0012        	   828: 	movec tr,d0
02:000002BA 60D8            	   829: 	bra UnlockSemaphore
                            	   830: 
                            	   831: T15GetFloat:
02:000002BC 2049            	   832: 	move.l a1,a0
02:000002BE 2001            	   833: 	move.l d1,d0
02:000002C0 61007006        	   834: 	bsr _GetFloat
02:000002C4 2248            	   835: 	move.l a0,a1
02:000002C6 2200            	   836: 	move.l d0,d1
02:000002C8 4E75            	   837: 	rts
                            	   838: 
                            	   839: T15Abort:
02:000002CA 610070D4        	   840: 	bsr DisplayByte
02:000002CE 43FA7BF8        	   841: 	lea msgStackCanary,a1
02:000002D2 610058D0        	   842: 	bsr DisplayStringCRLF
02:000002D6 600063C0        	   843: 	bra Monitor
                            	   844: 
                            	   845: chk_exception:
02:000002DA 222F0002        	   846: 	move.l 2(sp),d1
02:000002DE 610070B4        	   847: 	bsr DisplayTetra
02:000002E2 43FA7BD6        	   848: 	lea msgChk,a1
02:000002E6 610058BC        	   849: 	bsr DisplayStringCRLF
02:000002EA 600063AC        	   850: 	bra Monitor
                            	   851: 
                            	   852: ; -----------------------------------------------------------------------------
                            	   853: ; Delay for a few seconds to allow some I/O reset operations to take place.
                            	   854: ; -----------------------------------------------------------------------------
                            	   855: 
                            	   856: Delay3s:
02:000002EE 203C002DC6C0    	   857: 	move.l	#3000000,d0		; this should take a few seconds to loop
02:000002F4 41F9FD0FFF00    	   858: 	lea			leds,a0				; a0 = address of LED output register
02:000002FA 6002            	   859: 	bra			dly3s1				; branch to the loop
                            	   860: dly3s2:	
02:000002FC 4840            	   861: 	swap		d0						; loop is larger than 16-bits
                            	   862: dly3s1:
02:000002FE 2200            	   863: 	move.l	d0,d1					; the counter cycles fast, so use upper bits for display
02:00000300 E199            	   864: 	rol.l		#8,d1					; could use swap here, but lets test rol
02:00000302 E199            	   865: 	rol.l		#8,d1
02:00000304 1081            	   866: 	move.b	d1,(a0)				; set the LEDs
02:00000306 51C8FFF6        	   867: 	dbra		d0,dly3s1			; decrement and branch back
02:0000030A 4840            	   868: 	swap		d0
02:0000030C 51C8FFEE        	   869: 	dbra		d0,dly3s2
02:00000310 4E75            	   870: 	rts
                            	   871: 
                            	   872: Delay3s2:
02:00000312 4E7A0FE0        	   873: 	movec		coreno,d0			; vary delay by core to stagger startup
02:00000316 E188            	   874: 	lsl.l		#8,d0
02:00000318 0680002DC6C0    	   875: 	addi.l	#3000000,d0		; this should take a few seconds to loop
02:0000031E 6002            	   876: 	bra			.0001					; branch to the loop
                            	   877: .0002	
02:00000320 4840            	   878: 	swap		d0						; loop is larger than 16-bits
                            	   879: .0001
02:00000322 51C8FFFE        	   880: 	dbra		d0,.0001			; decrement and branch back
02:00000326 4840            	   881: 	swap		d0
02:00000328 51C8FFF6        	   882: 	dbra		d0,.0002
02:0000032C 4E75            	   883: 	rts
                            	   884: 
                            	   885: 	include "cputest.asm"

Source: "cputest.asm"
                            	     1: ** @name cputest.s Tests 68000 cpu
                            	     2: *
                            	     3: * Based on https://github.com/MicroCoreLabs/Projects/blob/master/MCL68/MC68000_Test_Code/MC68000_test_all_opcodes.X68
                            	     4: *
                            	     5: * Converted into a CD-i system ROM image by CD-i Fan:
                            	     6: * - comment lines must start in first column
                            	     7: * - replaced org instructions by suitable rept
                            	     8: * - copy vectors to low memory at startup
                            	     9: * - replaced jsr/jmp by bsr/bra for position independence
                            	    10: * - replaced move.l by moveq whenever possible
                            	    11: * - converted branches to short form whenever possible (e.g. beq => beq.s)
                            	    12: * - added immediate suffix to opcodes where required (e.g. and => andi)
                            	    13: * The last three modifications are required to make the test work;
                            	    14: * apparently the original assembler was somewhat smarter then
                            	    15: * the Microware OS-9 assembler and did this automatically.
                            	    16: *
                            	    17: * In some cases the opcodes of the test are used as test data!
                            	    18: *
                            	    19: * Original file header follows.
                            	    20: *
                            	    21: *  File Name   :  MCL68 Opcode Tests
                            	    22: *  Used on     :
                            	    23: *  Author      :  Ted Fried, MicroCore Labs
                            	    24: *  Creation    :  7/14/2020
                            	    25: *
                            	    26: *   Description:
                            	    27: *   ============
                            	    28: *
                            	    29: *  Program to test all of the Motorola 68000's opcodes.
                            	    30: *
                            	    31: *  If failures are detected, the code will immediately loop on itself.
                            	    32: *  All addressing modes, data sizes, and opcode combinations are tested.
                            	    33: *
                            	    34: *  This code was developed using the Easy68K simulator where all tests passed!
                            	    35: *
                            	    36: *------------------------------------------------------------------------
                            	    37: *
                            	    38: * Modification History:
                            	    39: * =====================
                            	    40: *
                            	    41: * Revision 1 7/14/2020
                            	    42: * Initial revision
                            	    43: *
                            	    44: *
                            	    45: *------------------------------------------------------------------------
                            	    46: *
                            	    47: * Copyright (c) 2020 Ted Fried
                            	    48: *
                            	    49: * Permission is hereby granted, free of charge, to any person obtaining a copy
                            	    50: * of this software and associated documentation files (the "Software"), to deal
                            	    51: * in the Software without restriction, including without limitation the rights
                            	    52: * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                            	    53: * copies of the Software, and to permit persons to whom the Software is
                            	    54: * furnished to do so, subject to the following conditions:
                            	    55: *
                            	    56: * The above copyright notice and this permission notice shall be included in all
                            	    57: * copies or substantial portions of the Software.
                            	    58: *
                            	    59: * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            	    60: * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            	    61: * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            	    62: * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            	    63: * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                            	    64: * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                            	    65: * SOFTWARE.
                            	    66: 
                            	    67: * Modified for rf68000 project (c) 2022 Robert Finch
                            	    68: 
                            	    69: *	data
                            	    70: *	dc.l		$0001FFFC						; top of local ram area
                            	    71: *	dc.l		start
                            	    72: 
                            	    73: *    org $1000												; code starts at $400 in local ram
                            	    74: *start:
                            	    75: *	move.l	$FFFFFFE0,d0		; get core number
                            	    76: *	cmpi.b	#2,d0
                            	    77: *	bne			do_nothing
                            	    78: 
                            	    79: *	lea			EXCEPTION_6,a0	* check exception vector
                            	    80: *	move.l	a0,6*4
                            	    81: *	lea			EXCEPTION_7,a0	* TRAPV exception vector
                            	    82: *	move.l	a0,7*4
                            	    83: 
                            	    84: cpu_test:
02:0000032E 610000FA        	    85: 	bsr	op_ORI_TO_CCR
02:00000332 61000118        	    86: 	bsr	op_ORI_TO_SR
02:00000336 61000136        	    87: 	bsr	op_EORI_TO_CCR
02:0000033A 61000158        	    88: 	bsr	op_EORI_TO_SR
02:0000033E 6100017A        	    89: 	bsr	op_ANDI_TO_CCR
02:00000342 6100019C        	    90: 	bsr	op_ANDI_TO_SR
02:00000346 610001BE        	    91: 	bsr	op_BTST
02:0000034A 61000564        	    92: 	bsr	op_BCHG
02:0000034E 610008C8        	    93: 	bsr	op_BCLR
02:00000352 61000C12        	    94: 	bsr	op_BSET
02:00000356 61000F56        	    95: 	bsr op_MOVEP
02:0000035A 61000FDE        	    96: 	bsr op_BOOL_I
02:0000035E 610011C2        	    97: 	bsr op_CMP_I
02:00000362 610013A6        	    98: 	bsr op_ADD_I
02:00000366 61001528        	    99: 	bsr op_SUB_I
02:0000036A 610016AA        	   100: 	bsr op_MOVE
02:0000036E 610018B2        	   101: 	bsr op_MOVE_xxx_FLAGS
02:00000372 61001AA2        	   102: 	bsr op_EXT
02:00000376 61001ACA        	   103: 	bsr op_SWAP
02:0000037A 61001ADC        	   104: 	bsr op_LEAPEA
02:0000037E 61001B84        	   105: 	bsr op_TAS
02:00000382 61001BA6        	   106: 	bsr op_TST
02:00000386 61001BE0        	   107: 	bsr op_LINKS
02:0000038A 61001BFA        	   108: 	bsr op_MOVE_USP
02:0000038E 61001C06        	   109: 	bsr op_CHK
02:00000392 61001C3C        	   110: 	bsr op_NEGS
02:00000396 61001FC6        	   111: 	bsr op_MOVEM
                            	   112: *	bsr op_ABCD
                            	   113: *	bsr op_SBCD
                            	   114: *	bsr op_NBCD
02:0000039A 61002562        	   115: 	bsr op_TRAPV
02:0000039E 6100257A        	   116: 	bsr op_RTR
02:000003A2 61001148        	   117: 	bsr op_BSR
02:000003A6 61002594        	   118: 	bsr op_BCC
02:000003AA 61002610        	   119: 	bsr op_DBCC
02:000003AE 61002632        	   120: 	bsr op_SCC
02:000003B2 6100265E        	   121: 	bsr op_ADDQ
02:000003B6 61002714        	   122: 	bsr op_SUBQ
02:000003BA 610027CA        	   123: 	bsr op_MOVEQ
02:000003BE 610027E2        	   124: 	bsr op_DIVU
                            	   125: *	bsr op_DIVS
02:000003C2 61002882        	   126: 	bsr op_OR
02:000003C6 61002968        	   127: 	bsr op_AND
02:000003CA 61002A4E        	   128: 	bsr op_EOR
02:000003CE 61002AC0        	   129: 	bsr op_CMP
02:000003D2 61002B32        	   130: 	bsr op_CMPA
02:000003D6 61002B94        	   131: 	bsr op_CMPM
02:000003DA 61002C36        	   132: 	bsr op_ADD
02:000003DE 61002D1C        	   133: 	bsr op_SUB
02:000003E2 61002E02        	   134: 	bsr op_ADDA
02:000003E6 61002E4A        	   135: 	bsr op_SUBA
02:000003EA 61002E92        	   136: 	bsr op_ADDX	
02:000003EE 61002F9E        	   137: 	bsr op_SUBX
02:000003F2 610030AA        	   138: 	bsr op_MULU
02:000003F6 610030F2        	   139: 	bsr op_MULS
02:000003FA 6100313A        	   140: 	bsr op_EXG
02:000003FE 610031A4        	   141: 	bsr op_ROx
02:00000402 610033D6        	   142: 	bsr op_ROXx
02:00000406 61003608        	   143: 	bsr op_SHIFTS
02:0000040A 61003846        	   144: 	bsr op_SHIFTS2
                            	   145: 
02:0000040E 4E75            	   146: 	rts
                            	   147: 	bra ALL_DONE
                            	   148: 
                            	   149: * Loop here when all tests pass
                            	   150: *
                            	   151: 
02:00000410 60FE            	   152: ALL_DONE: bra.s ALL_DONE
                            	   153: 
02:00000412 263C33333333    	   154: BSR_FAR1:       move.l #$33333333,d3
02:00000418 4E75            	   155:                 rts
                            	   156: 
                            	   157: ;	moveq		#-1,d0
                            	   158: ;	move.l	d0,$FD0FFF00
                            	   159: ;do_nothing:
                            	   160: ;	bra			*		
                            	   161: 
                            	   162: 
                            	   163: * Exception Vector = 6   CHK Instruction
                            	   164: *
                            	   165: *	align	4
                            	   166: EXCEPTION_6:
02:0000041A 2C3CEEEE0006    	   167: 	move.l #$EEEE0006,d6      * Set d6 to the exception vector
02:00000420 4E73            	   168: 	rte
                            	   169: 
                            	   170: * Exception Vector = 7   TRAPV Instruction
                            	   171: *
                            	   172: *	align	4
                            	   173: EXCEPTION_7:
02:00000422 203C12345678    	   174: 	move.l #$12345678,d0      * Set d6 to the exception vector
02:00000428 4E73            	   175: 	rte
                            	   176: 
                            	   177: ;-----------------------------------------------------------
                            	   178: ;-----------------------------------------------------------
                            	   179: ; OPCODE : ORI_TO_CCR
                            	   180: ;-----------------------------------------------------------
                            	   181: ;-----------------------------------------------------------
                            	   182: op_ORI_TO_CCR:
                            	   183: 
02:0000042A 003C00FF        	   184:     ori.b #$FF,CCR
02:0000042E 6AFE            	   185:     bpl.s *                   ; branch if Z clear
02:00000430 66FE            	   186:     bne.s *                   ; branch if N clear
02:00000432 68FE            	   187:     bvc.s *                   ; branch if V clear
02:00000434 64FE            	   188:     bcc.s *                   ; branch if C clear
                            	   189: 
02:00000436 44FC0000        	   190:     move #$00,CCR
02:0000043A 003C0000        	   191:     ori.b #$00,CCR
02:0000043E 67FE            	   192:     beq.s *                   ; branch if Z set
02:00000440 6BFE            	   193:     bmi.s *                   ; branch if N set
02:00000442 69FE            	   194:     bvs.s *                   ; branch if V set
02:00000444 65FE            	   195:     bcs.s *                   ; branch if C set
                            	   196: 
02:00000446 46FC2700        	   197:     move.w #$2700,SR          ; Put flags back to initial value
                            	   198: 
02:0000044A 4E75            	   199:     rts
                            	   200: 
                            	   201: ;-----------------------------------------------------------
                            	   202: ;-----------------------------------------------------------
                            	   203: ; OPCODE : ORI_TO_SR
                            	   204: ;-----------------------------------------------------------
                            	   205: ;-----------------------------------------------------------
                            	   206: 
                            	   207: op_ORI_TO_SR:
                            	   208: 
02:0000044C 007C2FFF        	   209:     ori.w #$2FFF,SR
02:00000450 6AFE            	   210:     bpl.s *                   * branch if Z clear
02:00000452 66FE            	   211:     bne.s *                   * branch if N clear
02:00000454 68FE            	   212:     bvc.s *                   * branch if V clear
02:00000456 64FE            	   213:     bcc.s *                   * branch if C clear
                            	   214: 
02:00000458 46FC2000        	   215:     move.w #$2000,SR
02:0000045C 007C0000        	   216:     ori.w #$0000,SR
02:00000460 67FE            	   217:     beq.s *                   * branch if Z set
02:00000462 6BFE            	   218:     bmi.s *                   * branch if N set
02:00000464 69FE            	   219:     bvs.s *                   * branch if V set
02:00000466 65FE            	   220:     bcs.s *                   * branch if C set
                            	   221: 
02:00000468 46FC2700        	   222:     move.w #$2700,sr         * Put flags back to initial value
                            	   223: 
02:0000046C 4E75            	   224:     rts
                            	   225: ; 
                            	   226: ;-----------------------------------------------------------
                            	   227: ;-----------------------------------------------------------
                            	   228: ; OPCODE : EORI_TO_CCR
                            	   229: ;-----------------------------------------------------------
                            	   230: ;-----------------------------------------------------------
                            	   231: op_EORI_TO_CCR:
                            	   232: 
02:0000046E 44FC0000        	   233:     move #$00,CCR
02:00000472 0A3C00FF        	   234:     eori.b #$FF,CCR
02:00000476 6AFE            	   235:     bpl.s *                   ; branch if Z clear
02:00000478 66FE            	   236:     bne.s *                   ; branch if N clear
02:0000047A 68FE            	   237:     bvc.s *                   ; branch if V clear
02:0000047C 64FE            	   238:     bcc.s *                   ; branch if C clear
                            	   239: 
02:0000047E 44FC0000        	   240:     move #$00,CCR
02:00000482 0A3C0000        	   241:     eori.b #$00,CCR
02:00000486 67FE            	   242:     beq.s *                   ; branch if Z set
02:00000488 6BFE            	   243:     bmi.s *                   ; branch if N set
02:0000048A 69FE            	   244:     bvs.s *                   ; branch if V set
02:0000048C 65FE            	   245:     bcs.s *                   ; branch if C set
                            	   246: 
02:0000048E 46FC2700        	   247:     move.w #$2700,sr           ; Put flags back to initial value
                            	   248: 
02:00000492 4E75            	   249:     rts
                            	   250: 
                            	   251: 
                            	   252: 
                            	   253: *-----------------------------------------------------------
                            	   254: *-----------------------------------------------------------
                            	   255: * OPCODE : EORI_TO_SR
                            	   256: *-----------------------------------------------------------
                            	   257: *-----------------------------------------------------------
                            	   258: op_EORI_TO_SR:
                            	   259: 
02:00000494 46FC2000        	   260:     move.w #$2000,SR
02:00000498 0A7C0FFF        	   261:     eori.w #$0FFF,SR
02:0000049C 6AFE            	   262:     bpl.s *                   * branch if Z clear
02:0000049E 66FE            	   263:     bne.s *                   * branch if N clear
02:000004A0 68FE            	   264:     bvc.s *                   * branch if V clear
02:000004A2 64FE            	   265:     bcc.s *                   * branch if C clear
                            	   266: 
02:000004A4 46FC2000        	   267:     move.w #$2000,SR
02:000004A8 0A7C0000        	   268:     eori.w #$0000,SR
02:000004AC 67FE            	   269:     beq.s *                   * branch if Z set
02:000004AE 6BFE            	   270:     bmi.s *                   * branch if N set
02:000004B0 69FE            	   271:     bvs.s *                   * branch if V set
02:000004B2 65FE            	   272:     bcs.s *                   * branch if C set
                            	   273: 
02:000004B4 46FC2700        	   274:     move.w #$2700,sr          * Put flags back to initial value
                            	   275: 
02:000004B8 4E75            	   276:     rts
                            	   277: 
                            	   278: 
                            	   279: 
                            	   280: *-----------------------------------------------------------
                            	   281: *-----------------------------------------------------------
                            	   282: * OPCODE : ANDI_TO_CCR
                            	   283: *-----------------------------------------------------------
                            	   284: *-----------------------------------------------------------
                            	   285: op_ANDI_TO_CCR:
                            	   286: 
02:000004BA 44FC00FF        	   287:     move #$FF,CCR
02:000004BE 023C00FF        	   288:     andi.b #$FF,CCR
02:000004C2 6AFE            	   289:     bpl.s *                   * branch if Z clear
02:000004C4 66FE            	   290:     bne.s *                   * branch if N clear
02:000004C6 68FE            	   291:     bvc.s *                   * branch if V clear
02:000004C8 64FE            	   292:     bcc.s *                   * branch if C clear
                            	   293: 
02:000004CA 44FC00FF        	   294:     move #$FF,CCR
02:000004CE 023C0000        	   295:     andi.b #$00,CCR
02:000004D2 67FE            	   296:     beq.s *                   * branch if Z set
02:000004D4 6BFE            	   297:     bmi.s *                   * branch if N set
02:000004D6 69FE            	   298:     bvs.s *                   * branch if V set
02:000004D8 65FE            	   299:     bcs.s *                   * branch if C set
                            	   300: 
02:000004DA 46FC2700        	   301:     move #$2700,SR           * Put flags back to initial value
                            	   302: 
02:000004DE 4E75            	   303:     rts
                            	   304: 
                            	   305: 
                            	   306: 
                            	   307: *-----------------------------------------------------------
                            	   308: *-----------------------------------------------------------
                            	   309: * OPCODE : ANDI_TO_SR
                            	   310: *-----------------------------------------------------------
                            	   311: *-----------------------------------------------------------
                            	   312: op_ANDI_TO_SR:
02:000004E0 46FC20FF        	   313:     move.w #$20FF,SR
02:000004E4 027CFFFF        	   314:     andi.w #$FFFF,SR
02:000004E8 6AFE            	   315:     bpl.s *                   * branch if Z clear
02:000004EA 66FE            	   316:     bne.s *                   * branch if N clear
02:000004EC 68FE            	   317:     bvc.s *                   * branch if V clear
02:000004EE 64FE            	   318:     bcc.s *                   * branch if C clear
                            	   319: 
02:000004F0 46FC20FF        	   320:     move.w #$20FF,SR
02:000004F4 027CFF00        	   321:     andi.w #$FF00,SR
02:000004F8 67FE            	   322:     beq.s *                   * branch if Z set
02:000004FA 6BFE            	   323:     bmi.s *                   * branch if N set
02:000004FC 69FE            	   324:     bvs.s *                   * branch if V set
02:000004FE 65FE            	   325:     bcs.s *                   * branch if C set
                            	   326: 
02:00000500 46FC2700        	   327:     move.w #$2700,sr           * Put flags back to initial value
                            	   328: 
02:00000504 4E75            	   329:     rts
                            	   330: 
                            	   331: 
                            	   332: *-----------------------------------------------------------
                            	   333: *-----------------------------------------------------------
                            	   334: * OPCODE : BTST
                            	   335: *-----------------------------------------------------------
                            	   336: *-----------------------------------------------------------
                            	   337: op_BTST:
                            	   338: 
                            	   339: *  Bit Number.s Static
                            	   340: 
                            	   341: *             EA = Dn  - LONG only
02:00000506 203C80000001    	   342:             move.l #$80000001,d0      * populate test data
02:0000050C 08000000        	   343:             btst.l #0,d0
02:00000510 67FE            	   344:             beq.s *               * branch if Z set
02:00000512 08000001        	   345:             btst.l #1,d0              *
02:00000516 66FE            	   346:             bne.s *               * branch if Z clear
02:00000518 0800001F        	   347:             btst.l #31,d0             *
02:0000051C 67FE            	   348:             beq.s *               * branch if Z set
                            	   349: 
                            	   350: 
                            	   351: *             EA = (An)  - BYTE only
02:0000051E 307C0100        	   352:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000522 10BC0081        	   353:             move.b #$81,(a0)          * populate test data
02:00000526 1210            	   354:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:00000528 08100000        	   355:             btst.b #0,(a0)
02:0000052C 67FE            	   356:             beq.s *               * branch if Z set
02:0000052E 08100001        	   357:             btst.b #1,(a0)            *
02:00000532 66FE            	   358:             bne.s *               * branch if Z clear
02:00000534 08100007        	   359:             btst.b #7,(a0)            *
02:00000538 67FE            	   360:             beq.s *               * branch if Z set
                            	   361: 
                            	   362: 
                            	   363: *             EA = (An)+  - BYTE only
02:0000053A 307C0100        	   364:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000053E 10FC0001        	   365:             move.b #$01,(a0)+         * populate test data
02:00000542 10FC00FC        	   366:             move.b #$FC,(a0)+         * populate test data
02:00000546 10FC0080        	   367:             move.b #$80,(a0)+         * populate test data
02:0000054A 307C0100        	   368:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000054E 08180000        	   369:             btst.b #0,(a0)+
02:00000552 67FE            	   370:             beq.s *               * branch if Z set
02:00000554 08180001        	   371:             btst.b #1,(a0)+           *
02:00000558 66FE            	   372:             bne.s *               * branch if Z clear
02:0000055A 08180007        	   373:             btst.b #7,(a0)+           *
02:0000055E 67FE            	   374:             beq.s *               * branch if Z set
                            	   375: 
                            	   376: 
                            	   377: *             EA = -(An)  - BYTE only
02:00000560 307C0100        	   378:             move.l #$00000100,a0      * point to memory to address
02:00000564 10FC0080        	   379:             move.b #$80,(a0)+         * populate test data
02:00000568 10FC00FC        	   380:             move.b #$FC,(a0)+         * populate test data
02:0000056C 10FC0001        	   381:             move.b #$01,(a0)+         * populate test data
02:00000570 307C0103        	   382:             move.l #$00000103,a0      * point to memory to address
02:00000574 08200000        	   383:             btst.b #0,-(a0)
02:00000578 67FE            	   384:             beq.s *               * branch if Z set
02:0000057A 08200001        	   385:             btst.b #1,-(a0)           *
02:0000057E 66FE            	   386:             bne.s *               * branch if Z clear
02:00000580 08200007        	   387:             btst.b #7,-(a0)           *
02:00000584 67FE            	   388:             beq.s *               * branch if Z set
                            	   389: 
                            	   390: 
                            	   391: *             EA = n(An)  - BYTE only
02:00000586 307C0100        	   392:             move.l #$00000100,a0      * point to memory to address
02:0000058A 10FC0001        	   393:             move.b #$01,(a0)+         * populate test data
02:0000058E 10FC00FC        	   394:             move.b #$FC,(a0)+         * populate test data
02:00000592 10FC0080        	   395:             move.b #$80,(a0)+         * populate test data
02:00000596 307C0100        	   396:             move.l #$00000100,a0      * point to memory to address
02:0000059A 08100000        	   397:             btst.b #0,0(a0)
02:0000059E 67FE            	   398:             beq.s *               * branch if Z set
02:000005A0 082800010001    	   399:             btst.b #1,1(a0)           *
02:000005A6 66FE            	   400:             bne.s *               * branch if Z clear
02:000005A8 082800070002    	   401:             btst.b #7,2(a0)           *
02:000005AE 67FE            	   402:             beq.s *               * branch if Z set
                            	   403: 
                            	   404: 
                            	   405: *             EA = n(An,R.W)  - BYTE only
02:000005B0 307C0100        	   406:             move.l #$00000100,a0      * point to memory to address
02:000005B4 93C9            	   407:             move.l #$00000000,a1      * point to memory to address
02:000005B6 347C0001        	   408:             move.l #$00000001,a2      * point to memory to address
02:000005BA 7000            	   409:             moveq  #$00000000,d0      * point to memory to address
02:000005BC 7201            	   410:             moveq  #$00000001,d1      * point to memory to address
02:000005BE 083000000000    	   411:             btst.b #0,0(a0,d0.w)
02:000005C4 67FE            	   412:             beq.s *               * branch if Z set
02:000005C6 083000011000    	   413:             btst.b #1,0(a0,d1.w)      *
02:000005CC 66FE            	   414:             bne.s *               * branch if Z clear
02:000005CE 083000071001    	   415:             btst.b #7,1(a0,d1.w)      *
02:000005D4 67FE            	   416:             beq.s *               * branch if Z set
                            	   417: *             EA = n(An,R.L)  - BYTE only
02:000005D6 083000000800    	   418:             btst.b #0,0(a0,d0.l)
02:000005DC 67FE            	   419:             beq.s *               * branch if Z set
02:000005DE 083000011800    	   420:             btst.b #1,0(a0,d1.l)      *
02:000005E4 66FE            	   421:             bne.s *               * branch if Z clear
02:000005E6 083000071801    	   422:             btst.b #7,1(a0,d1.l)      *
02:000005EC 67FE            	   423:             beq.s *               * branch if Z set
                            	   424: *             EA = n(An,A.W)  - BYTE only
02:000005EE 083000009000    	   425:             btst.b #0,0(a0,a1.w)
02:000005F4 67FE            	   426:             beq.s *               * branch if Z set
02:000005F6 08300001A000    	   427:             btst.b #1,0(a0,a2.w)      *
02:000005FC 66FE            	   428:             bne.s *               * branch if Z clear
02:000005FE 08300007A001    	   429:             btst.b #7,1(a0,a2.w)      *
02:00000604 67FE            	   430:             beq.s *               * branch if Z set
                            	   431: *             EA = n(An,A.L)  - BYTE only
02:00000606 083000009800    	   432:             btst.b #0,0(a0,a1.l)
02:0000060C 67FE            	   433:             beq.s *               * branch if Z set
02:0000060E 08300001A800    	   434:             btst.b #1,0(a0,a2.l)      *
02:00000614 66FE            	   435:             bne.s *               * branch if Z clear
02:00000616 08300007A801    	   436:             btst.b #7,1(a0,a2.l)      *
02:0000061C 67FE            	   437:             beq.s *               * branch if Z set
                            	   438: 
                            	   439: 
                            	   440: *             EA = x.W  - BYTE only
02:0000061E 083800000100    	   441:             btst.b #0,$0100
02:00000624 67FE            	   442:             beq.s *               * branch if Z set
02:00000626 083800010101    	   443:             btst.b #1,$0101           *
02:0000062C 66FE            	   444:             bne.s *               * branch if Z clear
02:0000062E 083800070102    	   445:             btst.b #7,$0102           *
02:00000634 67FE            	   446:             beq.s *               * branch if Z set
                            	   447: 
                            	   448: 
                            	   449: *             EA = x.L  - BYTE only
02:00000636 207C0000F100    	   450:             move.l #$F100,a0      * point to memory to address 0x100
02:0000063C 10FC0001        	   451:             move.b #$01,(a0)+         * populate test data
02:00000640 10FC00FC        	   452:             move.b #$FC,(a0)+         * populate test data
02:00000644 10FC0080        	   453:             move.b #$80,(a0)+         * populate test data
02:00000648 083900000000F100	   454:             btst.b #0,$F100
02:00000650 67FE            	   455:             beq.s *               * branch if Z set
02:00000652 083900010000F101	   456:             btst.b #1,$F101       *
02:0000065A 66FE            	   457:             bne.s *               * branch if Z clear
02:0000065C 083900070000F102	   458:             btst.b #7,$F102       *
02:00000664 67FE            	   459:             beq.s *               * branch if Z set
                            	   460: 
                            	   461: 
                            	   462: *             EA = x(PC)  - BYTE only
02:00000666 4BFAFE9E        	   463:             lea op_BTST(pc),a5
02:0000066A 083A0000FE98    	   464:             btst.b #0,op_BTST(pc)
02:00000670 66FE            	   465:             bne.s *               * branch if Z clear
02:00000672 083A0003001A    	   466:             btst.b #3,op_BTST0(pc)     *
02:00000678 67FE            	   467:             beq.s *               * branch if Z set
02:0000067A 083A00060074    	   468:             btst.b #6,op_BTST12(pc)    *
02:00000680 67FE            	   469:             beq.s *               * branch if Z set
                            	   470: 
                            	   471: 
                            	   472: *             EA = n(PC,R.W)  - BYTE only
02:00000682 307C0100        	   473:             move.l #$00000100,a0      * point to memory to address
02:00000686 93C9            	   474:             move.l #$00000000,a1      * point to memory to address
02:00000688 347C0001        	   475:             move.l #$00000001,a2      * point to memory to address
02:0000068C 7000            	   476:             moveq  #$00000000,d0      * point to memory to address
02:0000068E 7201            	   477:             moveq  #$00000001,d1      * point to memory to address
                            	   478: 
02:00000690 083B000000FC    	   479: op_BTST0:   btst.b #0,op_BTST0(pc,d0.w)
02:00000696 66FE            	   480:             bne.s *               * branch if Z clear
                            	   481: 
02:00000698 4BFB1002        	   482:             lea op_BTST1(pc,d1.w),a5
02:0000069C 083B000110FC    	   483: op_BTST1:   btst.b #1,op_BTST1(pc,d1.w)      *
02:000006A2 67FE            	   484:             beq.s *               * branch if Z set
02:000006A4 083B000710FC    	   485: op_BTST2:   btst.b #7,op_BTST2(pc,d1.w)      *
02:000006AA 66FE            	   486:             bne.s *               * branch if Z clear
                            	   487: *             EA = n(PC,R.L)  - BYTE only
02:000006AC 083B000008FC    	   488: op_BTST3:   btst.b #0,op_BTST3(pc,d0.l)
02:000006B2 66FE            	   489:             bne.s *               * branch if Z clear
02:000006B4 083B000118FC    	   490: op_BTST4:   btst.b #1,op_BTST4(pc,d1.l)      *
02:000006BA 67FE            	   491:             beq.s *               * branch if Z set
02:000006BC 083B000718FC    	   492: op_BTST5:   btst.b #7,op_BTST5(pc,d1.l)      *
02:000006C2 66FE            	   493:             bne.s *               * branch if Z clear
                            	   494: *             EA = n(PC,A.W)  - BYTE only
02:000006C4 083B000090FC    	   495: op_BTST6    btst.b #0,op_BTST6(pc,a1.w)
02:000006CA 66FE            	   496:             bne.s *               * branch if Z clear
02:000006CC 083B0001A0FC    	   497: op_BTST7:   btst.b #1,op_BTST7(pc,a2.w)      *
02:000006D2 67FE            	   498:             beq.s *               * branch if Z set
02:000006D4 083B0007A0FC    	   499: op_BTST8:   btst.b #7,op_BTST8(pc,a2.w)      *
02:000006DA 66FE            	   500:             bne.s *               * branch if Z clear
                            	   501: *             EA = n(PC,A.L)  - BYTE only
02:000006DC 083B000098FC    	   502: op_BTST9:   btst.b #0,op_BTST9(pc,a1.l)
02:000006E2 66FE            	   503:             bne.s *               * branch if Z clear
02:000006E4 083B0001A8FC    	   504: op_BTST10:  btst.b #1,op_BTST10(pc,a2.l)      *
02:000006EA 67FE            	   505:             beq.s *               * branch if Z set
02:000006EC 083B0007A8FC    	   506: op_BTST11:  btst.b #7,op_BTST11(pc,a2.l)      *
02:000006F2 66FE            	   507: op_BTST12:  bne.s *               * branch if Z clear
                            	   508: 
                            	   509: 
                            	   510: 
                            	   511: * Bit Number.s Dynamic
                            	   512: 
                            	   513: *             EA = Dn  - LONG only
02:000006F4 203C80000001    	   514:             move.l #$80000001,d0      * populate test data
02:000006FA 7A00            	   515:             move.l #0,d5              * populate bit.s number to test
02:000006FC 7C01            	   516:             move.l #1,d6              * populate bit.s number to test
02:000006FE 7E1F            	   517:             move.l #31,d7              * populate bit.s number to test
                            	   518: 
02:00000700 0B00            	   519:             btst.l d5,d0
02:00000702 67FE            	   520:             beq.s *               * branch if Z set
02:00000704 0D00            	   521:             btst.l d6,d0              *
02:00000706 66FE            	   522:             bne.s *               * branch if Z clear
02:00000708 0F00            	   523:             btst.l d7,d0             *
02:0000070A 67FE            	   524:             beq.s *               * branch if Z set
                            	   525: 
                            	   526: 
                            	   527: *             EA = (An)  - BYTE only
02:0000070C 7A00            	   528:             move.l #0,d5              * populate bit.s number to test
02:0000070E 7C01            	   529:             move.l #1,d6              * populate bit.s number to test
02:00000710 7E07            	   530:             move.l #7,d7              * populate bit.s number to test
02:00000712 307C0100        	   531:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000716 10BC0081        	   532:             move.b #$81,(a0)          * populate test data
02:0000071A 1210            	   533:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:0000071C 0B10            	   534:             btst.b d5,(a0)
02:0000071E 67FE            	   535:             beq.s *               * branch if Z set
02:00000720 0D10            	   536:             btst.b d6,(a0)            *
02:00000722 66FE            	   537:             bne.s *               * branch if Z clear
02:00000724 0F10            	   538:             btst.b d7,(a0)            *
02:00000726 67FE            	   539:             beq.s *               * branch if Z set
                            	   540: 
                            	   541: * ---
                            	   542: 
                            	   543: 
                            	   544: *             EA = (An)+  - BYTE only
02:00000728 307C0100        	   545:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000072C 10FC0001        	   546:             move.b #$01,(a0)+         * populate test data
02:00000730 10FC00FC        	   547:             move.b #$FC,(a0)+         * populate test data
02:00000734 10FC0080        	   548:             move.b #$80,(a0)+         * populate test data
02:00000738 307C0100        	   549:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000073C 0B18            	   550:             btst.b d5,(a0)+
02:0000073E 67FE            	   551:             beq.s *               * branch if Z set
02:00000740 0D18            	   552:             btst.b d6,(a0)+           *
02:00000742 66FE            	   553:             bne.s *               * branch if Z clear
02:00000744 0F18            	   554:             btst.b d7,(a0)+           *
02:00000746 67FE            	   555:             beq.s *               * branch if Z set
                            	   556: 
                            	   557: 
                            	   558: *             EA = -(An)  - BYTE only
02:00000748 307C0100        	   559:             move.l #$00000100,a0      * point to memory to address
02:0000074C 10FC0080        	   560:             move.b #$80,(a0)+         * populate test data
02:00000750 10FC00FC        	   561:             move.b #$FC,(a0)+         * populate test data
02:00000754 10FC0001        	   562:             move.b #$01,(a0)+         * populate test data
02:00000758 307C0103        	   563:             move.l #$00000103,a0      * point to memory to address
02:0000075C 0B20            	   564:             btst.b d5,-(a0)
02:0000075E 67FE            	   565:             beq.s *               * branch if Z set
02:00000760 0D20            	   566:             btst.b d6,-(a0)           *
02:00000762 66FE            	   567:             bne.s *               * branch if Z clear
02:00000764 0F20            	   568:             btst.b d7,-(a0)           *
02:00000766 67FE            	   569:             beq.s *               * branch if Z set
                            	   570: 
                            	   571: 
                            	   572: *             EA = n(An)  - BYTE only
02:00000768 307C0100        	   573:             move.l #$00000100,a0      * point to memory to address
02:0000076C 10FC0001        	   574:             move.b #$01,(a0)+         * populate test data
02:00000770 10FC00FC        	   575:             move.b #$FC,(a0)+         * populate test data
02:00000774 10FC0080        	   576:             move.b #$80,(a0)+         * populate test data
02:00000778 307C0100        	   577:             move.l #$00000100,a0      * point to memory to address
02:0000077C 0B10            	   578:             btst.b d5,0(a0)
02:0000077E 67FE            	   579:             beq.s *               * branch if Z set
02:00000780 0D280001        	   580:             btst.b d6,1(a0)           *
02:00000784 66FE            	   581:             bne.s *               * branch if Z clear
02:00000786 0F280002        	   582:             btst.b d7,2(a0)           *
02:0000078A 67FE            	   583:             beq.s *               * branch if Z set
                            	   584: 
                            	   585: 
                            	   586: *             EA = n(An,R.W)  - BYTE only
02:0000078C 307C0100        	   587:             move.l #$00000100,a0      * point to memory to address
02:00000790 93C9            	   588:             move.l #$00000000,a1      * point to memory to address
02:00000792 347C0001        	   589:             move.l #$00000001,a2      * point to memory to address
02:00000796 7000            	   590:             moveq  #$00000000,d0      * point to memory to address
02:00000798 7201            	   591:             moveq  #$00000001,d1      * point to memory to address
02:0000079A 0B300000        	   592:             btst.b d5,0(a0,d0.w)
02:0000079E 67FE            	   593:             beq.s *               * branch if Z set
02:000007A0 0D301000        	   594:             btst.b d6,0(a0,d1.w)      *
02:000007A4 66FE            	   595:             bne.s *               * branch if Z clear
02:000007A6 0F301001        	   596:             btst.b d7,1(a0,d1.w)      *
02:000007AA 67FE            	   597:             beq.s *               * branch if Z set
                            	   598: *             EA = n(An,R.L)  - BYTE only
02:000007AC 0B300800        	   599:             btst.b d5,0(a0,d0.l)
02:000007B0 67FE            	   600:             beq.s *               * branch if Z set
02:000007B2 0D301800        	   601:             btst.b d6,0(a0,d1.l)      *
02:000007B6 66FE            	   602:             bne.s *               * branch if Z clear
02:000007B8 0F301801        	   603:             btst.b d7,1(a0,d1.l)      *
02:000007BC 67FE            	   604:             beq.s *               * branch if Z set
                            	   605: *             EA = n(An,A.W)  - BYTE only
02:000007BE 0B309000        	   606:             btst.b d5,0(a0,a1.w)
02:000007C2 67FE            	   607:             beq.s *               * branch if Z set
02:000007C4 0D30A000        	   608:             btst.b d6,0(a0,a2.w)      *
02:000007C8 66FE            	   609:             bne.s *               * branch if Z clear
02:000007CA 0F30A001        	   610:             btst.b d7,1(a0,a2.w)      *
02:000007CE 67FE            	   611:             beq.s *               * branch if Z set
                            	   612: *             EA = n(An,A.L)  - BYTE only
02:000007D0 0B309800        	   613:             btst.b d5,0(a0,a1.l)
02:000007D4 67FE            	   614:             beq.s *               * branch if Z set
02:000007D6 0D30A800        	   615:             btst.b d6,0(a0,a2.l)      *
02:000007DA 66FE            	   616:             bne.s *               * branch if Z clear
02:000007DC 0F30A801        	   617:             btst.b d7,1(a0,a2.l)      *
02:000007E0 67FE            	   618:             beq.s *               * branch if Z set
                            	   619: 
                            	   620: 
                            	   621: *             EA = x.W  - BYTE only
02:000007E2 0B380100        	   622:             btst.b d5,$0100
02:000007E6 67FE            	   623:             beq.s *               * branch if Z set
02:000007E8 0D380101        	   624:             btst.b d6,$0101           *
02:000007EC 66FE            	   625:             bne.s *               * branch if Z clear
02:000007EE 0F380102        	   626:             btst.b d7,$0102           *
02:000007F2 67FE            	   627:             beq.s *               * branch if Z set
                            	   628: 
                            	   629: 
                            	   630: *             EA = x.L  - BYTE only
02:000007F4 207C0000F100    	   631:             move.l #$F100,a0      * point to memory to address 0x100
02:000007FA 10FC0001        	   632:             move.b #$01,(a0)+         * populate test data
02:000007FE 10FC00FC        	   633:             move.b #$FC,(a0)+         * populate test data
02:00000802 10FC0080        	   634:             move.b #$80,(a0)+         * populate test data
02:00000806 0B390000F100    	   635:             btst.b d5,$F100
02:0000080C 67FE            	   636:             beq.s *               * branch if Z set
02:0000080E 0D390000F101    	   637:             btst.b d6,$F101       *
02:00000814 66FE            	   638:             bne.s *               * branch if Z clear
02:00000816 0F390000F102    	   639:             btst.b d7,$F102       *
02:0000081C 67FE            	   640:             beq.s *               * branch if Z set
                            	   641: 
                            	   642: 
                            	   643: *             EA = x(PC)  - BYTE only
02:0000081E 7C03            	   644:             move.l #3,d6              * populate bit.s number to test
02:00000820 7E06            	   645:             move.l #6,d7              * populate bit.s number to test
02:00000822 4BFAFCE2        	   646:             lea op_BTST(pc),a5
02:00000826 0B3AFCDE        	   647:             btst.b d5,op_BTST(pc)
02:0000082A 66FE            	   648:             bne.s *               * branch if Z clear
02:0000082C 0D3AFE62        	   649:             btst.b d6,op_BTST0(pc)     *
02:00000830 67FE            	   650:             beq.s *               * branch if Z set
02:00000832 0F3AFEBE        	   651:             btst.b d7,op_BTST12(pc)    *
02:00000836 67FE            	   652:             beq.s *               * branch if Z set
                            	   653: 
                            	   654: 
                            	   655: *             EA = n(PC,R.W)  - BYTE only
02:00000838 307C0100        	   656:             move.l #$00000100,a0      * point to memory to address
02:0000083C 93C9            	   657:             move.l #$00000000,a1      * point to memory to address
02:0000083E 347C0001        	   658:             move.l #$00000001,a2      * point to memory to address
02:00000842 7000            	   659:             moveq  #$00000000,d0      * point to memory to address
02:00000844 7201            	   660:             moveq  #$00000001,d1      * point to memory to address
02:00000846 7C01            	   661:             move.l #1,d6              * populate bit.s number to test
02:00000848 7E07            	   662:             move.l #7,d7              * populate bit.s number to test
                            	   663: 
02:0000084A 0B3B00FE        	   664: op_BTST20:  btst.b d5,op_BTST20(pc,d0.w)
02:0000084E 67FE            	   665:             beq.s *               * branch if Z set
02:00000850 4BFB1002        	   666:             lea op_BTST21(pc,d1.w),a5
02:00000854 0D3B10FE        	   667: op_BTST21:  btst.b d6,op_BTST21(pc,d1.w)      *
02:00000858 67FE            	   668:             beq.s *               * branch if Z set
02:0000085A 0F3B10FE        	   669: op_BTST22:  btst.b d7,op_BTST22(pc,d1.w)      *
02:0000085E 66FE            	   670:             bne.s *               * branch if Z clear
                            	   671: *             EA = n(PC,R.L)  - BYTE only
02:00000860 0B3B08FE        	   672: op_BTST23:  btst.b d5,op_BTST23(pc,d0.l)
02:00000864 67FE            	   673:             beq.s *               * branch if Z set
02:00000866 0D3B18FE        	   674: op_BTST24: btst.b d6,op_BTST24(pc,d1.l)      *
02:0000086A 67FE            	   675:             beq.s *               * branch if Z set
02:0000086C 0F3B18FE        	   676: op_BTST25  btst.b d7,op_BTST25(pc,d1.l)      *
02:00000870 66FE            	   677:             bne.s *               * branch if Z clear
                            	   678: *             EA = n(PC,A.W)  - BYTE only
02:00000872 0B3B90FE        	   679: op_BTST26   btst.b d5,op_BTST26(pc,a1.w)
02:00000876 67FE            	   680:             beq.s *               * branch if Z set
02:00000878 0D3BA0FE        	   681: op_BTST27:  btst.b d6,op_BTST27(pc,a2.w)      *
02:0000087C 67FE            	   682:             beq.s *               * branch if Z set
02:0000087E 0F3BA0FE        	   683: op_BTST28:  btst.b d7,op_BTST28(pc,a2.w)      *
02:00000882 66FE            	   684:             bne.s *               * branch if Z clear
                            	   685: *             EA = n(PC,A.L)  - BYTE only
02:00000884 0B3B98FE        	   686: op_BTST29:  btst.b d5,op_BTST29(pc,a1.l)
02:00000888 67FE            	   687:             beq.s *               * branch if Z set
02:0000088A 0D3BA8FE        	   688: op_BTST30:  btst.b d6,op_BTST30(pc,a2.l)      *
02:0000088E 67FE            	   689:             beq.s *               * branch if Z set
02:00000890 0F3BA8FE        	   690: op_BTST31:  btst.b d7,op_BTST31(pc,a2.l)      *
02:00000894 66FE            	   691: op_BTST32:  bne.s *               * branch if Z clear
                            	   692: 
                            	   693: *             EA = #x  - BYTE only
                            	   694: 
02:00000896 7A00            	   695:             move.l #0,d5              * populate bit.s number to test
02:00000898 7C03            	   696:             move.l #3,d6              * populate bit.s number to test
02:0000089A 7E07            	   697:             move.l #7,d7              * populate bit.s number to test
                            	   698: 
02:0000089C 0B3C0088        	   699:             btst.b d5,#$88
02:000008A0 66FE            	   700:             bne.s *               * branch if Z clear
02:000008A2 0D3C0088        	   701:             btst.b d6,#$88
02:000008A6 67FE            	   702:             beq.s *               * branch if Z set
02:000008A8 0F3C0088        	   703:             btst.b d7,#$88
02:000008AC 67FE            	   704:             beq.s *               * branch if Z set
                            	   705: 
                            	   706: 
02:000008AE 4E75            	   707:     rts
                            	   708: 
                            	   709: *-----------------------------------------------------------
                            	   710: *-----------------------------------------------------------
                            	   711: * OPCODE : BCHG
                            	   712: *-----------------------------------------------------------
                            	   713: *-----------------------------------------------------------
                            	   714: op_BCHG:
                            	   715: 
                            	   716: 
                            	   717: *  Bit Number.s Static
                            	   718: 
                            	   719: *             EA = Dn  - LONG only
02:000008B0 203C80000001    	   720:             move.l #$80000001,d0      * populate test data
02:000008B6 08400000        	   721:             bchg.l #0,d0
02:000008BA 67FE            	   722:             beq.s *               * branch if Z set
02:000008BC 08400001        	   723:             bchg.l #1,d0              *
02:000008C0 66FE            	   724:             bne.s *               * branch if Z clear
02:000008C2 0840001F        	   725:             bchg.l #31,d0             *
02:000008C6 67FE            	   726:             beq.s *               * branch if Z set
02:000008C8 0C8000000002    	   727:             cmpi.l #$00000002,d0
02:000008CE 66FE            	   728:             bne.s *               * branch if Z clear
                            	   729: 
                            	   730: 
                            	   731: *             EA = (An)  - BYTE only
02:000008D0 307C0100        	   732:             move.l #$00000100,a0      * point to memory to address 0x100
02:000008D4 10BC0081        	   733:             move.b #$81,(a0)          * populate test data
02:000008D8 1210            	   734:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:000008DA 08500000        	   735:             bchg.b #0,(a0)
02:000008DE 67FE            	   736:             beq.s *               * branch if Z set
02:000008E0 08500001        	   737:             bchg.b #1,(a0)            *
02:000008E4 66FE            	   738:             bne.s *               * branch if Z clear
02:000008E6 08500007        	   739:             bchg.b #7,(a0)            *
02:000008EA 67FE            	   740:             beq.s *               * branch if Z set
02:000008EC 0C100002        	   741:             cmpi.b #$02,(a0)
02:000008F0 66FE            	   742:             bne.s *               * branch if Z clear
                            	   743: 
                            	   744: *             EA = (An)+  - BYTE only
02:000008F2 307C0100        	   745:             move.l #$00000100,a0      * point to memory to address 0x100
02:000008F6 10FC0001        	   746:             move.b #$01,(a0)+         * populate test data
02:000008FA 10FC00FC        	   747:             move.b #$FC,(a0)+         * populate test data
02:000008FE 10FC0080        	   748:             move.b #$80,(a0)+         * populate test data
02:00000902 307C0100        	   749:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000906 08580000        	   750:             bchg.b #0,(a0)+
02:0000090A 67FE            	   751:             beq.s *               * branch if Z set
02:0000090C 08580001        	   752:             bchg.b #1,(a0)+           *
02:00000910 66FE            	   753:             bne.s *               * branch if Z clear
02:00000912 08580007        	   754:             bchg.b #7,(a0)+           *
02:00000916 67FE            	   755:             beq.s *               * branch if Z set
02:00000918 307C0100        	   756:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000091C 4A18            	   757:             cmpi.b #$00,(a0)+
02:0000091E 66FE            	   758:             bne.s *               * branch if Z clear
02:00000920 0C1800FE        	   759:             cmpi.b #$FE,(a0)+
02:00000924 66FE            	   760:             bne.s *               * branch if Z clear
02:00000926 4A18            	   761:             cmpi.b #$00,(a0)+
02:00000928 66FE            	   762:             bne.s *               * branch if Z clear
                            	   763: 
                            	   764: *             EA = -(An)  - BYTE only
02:0000092A 307C0100        	   765:             move.l #$00000100,a0      * point to memory to address
02:0000092E 10FC0080        	   766:             move.b #$80,(a0)+         * populate test data
02:00000932 10FC00FC        	   767:             move.b #$FC,(a0)+         * populate test data
02:00000936 10FC0001        	   768:             move.b #$01,(a0)+         * populate test data
02:0000093A 307C0103        	   769:             move.l #$00000103,a0      * point to memory to address
02:0000093E 08600000        	   770:             bchg.b #0,-(a0)
02:00000942 67FE            	   771:             beq.s *               * branch if Z set
02:00000944 08600001        	   772:             bchg.b #1,-(a0)           *
02:00000948 66FE            	   773:             bne.s *               * branch if Z clear
02:0000094A 08600007        	   774:             bchg.b #7,-(a0)           *
02:0000094E 67FE            	   775:             beq.s *               * branch if Z set
02:00000950 307C0103        	   776:             move.l #$00000103,a0      * point to memory to address 0x100
02:00000954 4A20            	   777:             cmpi.b #$00,-(a0)
02:00000956 66FE            	   778:             bne.s *               * branch if Z clear
02:00000958 0C2000FE        	   779:             cmpi.b #$FE,-(a0)
02:0000095C 66FE            	   780:             bne.s *               * branch if Z clear
02:0000095E 4A20            	   781:             cmpi.b #$00,-(a0)
02:00000960 66FE            	   782:             bne.s *               * branch if Z clear
                            	   783: 
                            	   784: 
                            	   785: *             EA = n(An)  - BYTE only
02:00000962 307C0100        	   786:             move.l #$00000100,a0      * point to memory to address
02:00000966 10FC0001        	   787:             move.b #$01,(a0)+         * populate test data
02:0000096A 10FC00FC        	   788:             move.b #$FC,(a0)+         * populate test data
02:0000096E 10FC0080        	   789:             move.b #$80,(a0)+         * populate test data
02:00000972 307C0100        	   790:             move.l #$00000100,a0      * point to memory to address
02:00000976 08500000        	   791:             bchg.b #0,0(a0)
02:0000097A 67FE            	   792:             beq.s *               * branch if Z set
02:0000097C 086800010001    	   793:             bchg.b #1,1(a0)           *
02:00000982 66FE            	   794:             bne.s *               * branch if Z clear
02:00000984 086800070002    	   795:             bchg.b #7,2(a0)           *
02:0000098A 67FE            	   796:             beq.s *               * branch if Z set
02:0000098C 307C0100        	   797:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000990 4A18            	   798:             cmpi.b #$00,(a0)+
02:00000992 66FE            	   799:             bne.s *               * branch if Z clear
02:00000994 0C1800FE        	   800:             cmpi.b #$FE,(a0)+
02:00000998 66FE            	   801:             bne.s *               * branch if Z clear
02:0000099A 4A18            	   802:             cmpi.b #$00,(a0)+
02:0000099C 66FE            	   803:             bne.s *               * branch if Z clear
                            	   804: 
                            	   805: 
                            	   806: *             EA = n(An,D.W)  - BYTE only
02:0000099E 307C0100        	   807:             move.l #$00000100,a0      * point to memory to address
02:000009A2 93C9            	   808:             move.l #$00000000,a1      * point to memory to address
02:000009A4 347C0001        	   809:             move.l #$00000001,a2      * point to memory to address
02:000009A8 7000            	   810:             moveq  #$00000000,d0      * point to memory to address
02:000009AA 7201            	   811:             moveq  #$00000001,d1      * point to memory to address
02:000009AC 087000000000    	   812:             bchg.b #0,0(a0,d0.w)
02:000009B2 66FE            	   813:             bne.s *               * branch if Z clear
02:000009B4 087000011000    	   814:             bchg.b #1,0(a0,d1.w)      *
02:000009BA 67FE            	   815:             beq.s *               * branch if Z set
02:000009BC 087000071001    	   816:             bchg.b #7,1(a0,d1.w)      *
02:000009C2 66FE            	   817:             bne.s *               * branch if Z clear
                            	   818: *             EA = n(An,D.L)  - BYTE only
02:000009C4 087000000800    	   819:             bchg.b #0,0(a0,d0.l)
02:000009CA 67FE            	   820:             beq.s *               * branch if Z set
02:000009CC 087000011800    	   821:             bchg.b #1,0(a0,d1.l)      *
02:000009D2 66FE            	   822:             bne.s *               * branch if Z clear
02:000009D4 087000071801    	   823:             bchg.b #7,1(a0,d1.l)      *
02:000009DA 67FE            	   824:             beq.s *               * branch if Z set
                            	   825: *             EA = n(An,A.W)  - BYTE only
02:000009DC 087000009000    	   826:             bchg.b #0,0(a0,a1.w)
02:000009E2 66FE            	   827:             bne.s *               * branch if Z clear
02:000009E4 08700001A000    	   828:             bchg.b #1,0(a0,a2.w)      *
02:000009EA 67FE            	   829:             beq.s *               * branch if Z set
02:000009EC 08700007A001    	   830:             bchg.b #7,1(a0,a2.w)      *
02:000009F2 66FE            	   831:             bne.s *               * branch if Z clear
                            	   832: *             EA = n(An,A.L)  - BYTE only
02:000009F4 087000009800    	   833:             bchg.b #0,0(a0,a1.l)
02:000009FA 67FE            	   834:             beq.s *               * branch if Z set
02:000009FC 08700001A800    	   835:             bchg.b #1,0(a0,a2.l)      *
02:00000A02 66FE            	   836:             bne.s *               * branch if Z clear
02:00000A04 08700007A801    	   837:             bchg.b #7,1(a0,a2.l)      *
02:00000A0A 67FE            	   838:             beq.s *               * branch if Z set
02:00000A0C 307C0100        	   839:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A10 4A18            	   840:             cmpi.b #$00,(a0)+
02:00000A12 66FE            	   841:             bne.s *               * branch if Z clear
02:00000A14 0C1800FE        	   842:             cmpi.b #$FE,(a0)+
02:00000A18 66FE            	   843:             bne.s *               * branch if Z clear
02:00000A1A 4A18            	   844:             cmpi.b #$00,(a0)+
02:00000A1C 66FE            	   845:             bne.s *               * branch if Z clear
                            	   846: 
                            	   847: 
                            	   848: *             EA = x.W  - BYTE only
02:00000A1E 087800000100    	   849:             bchg.b #0,$0100
02:00000A24 66FE            	   850:             bne.s *               * branch if Z clear
02:00000A26 087800010101    	   851:             bchg.b #1,$0101           *
02:00000A2C 67FE            	   852:             beq.s *               * branch if Z set
02:00000A2E 087800070102    	   853:             bchg.b #7,$0102           *
02:00000A34 66FE            	   854:             bne.s *               * branch if Z clear
02:00000A36 307C0100        	   855:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A3A 0C180001        	   856:             cmpi.b #$01,(a0)+
02:00000A3E 66FE            	   857:             bne.s *               * branch if Z clear
02:00000A40 0C1800FC        	   858:             cmpi.b #$FC,(a0)+
02:00000A44 66FE            	   859:             bne.s *               * branch if Z clear
02:00000A46 0C180080        	   860:             cmpi.b #$80,(a0)+
02:00000A4A 66FE            	   861:             bne.s *               * branch if Z clear
                            	   862: 
                            	   863: *             EA = x.L  - BYTE only
02:00000A4C 207C0000F100    	   864:             move.l #$F100,a0      * point to memory to address 0x100
02:00000A52 10FC0001        	   865:             move.b #$01,(a0)+         * populate test data
02:00000A56 10FC00FC        	   866:             move.b #$FC,(a0)+         * populate test data
02:00000A5A 10FC0080        	   867:             move.b #$80,(a0)+         * populate test data
02:00000A5E 087900000000F100	   868:             bchg.b #0,$F100
02:00000A66 67FE            	   869:             beq.s *               * branch if Z set
02:00000A68 087900010000F101	   870:             bchg.b #1,$F101       *
02:00000A70 66FE            	   871:             bne.s *               * branch if Z clear
02:00000A72 087900070000F102	   872:             bchg.b #7,$F102       *
02:00000A7A 67FE            	   873:             beq.s *               * branch if Z set
02:00000A7C 307C0100        	   874:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A80 0C180001        	   875:             cmpi.b #$01,(a0)+
02:00000A84 66FE            	   876:             bne.s *               * branch if Z clear
02:00000A86 0C1800FC        	   877:             cmpi.b #$FC,(a0)+
02:00000A8A 66FE            	   878:             bne.s *               * branch if Z clear
02:00000A8C 0C180080        	   879:             cmpi.b #$80,(a0)+
02:00000A90 66FE            	   880:             bne.s *               * branch if Z clear
                            	   881: 
                            	   882: 
                            	   883: * Bit Number.s Dynamic
                            	   884: 
                            	   885: *             EA = Dn  - LONG only
02:00000A92 203C80000001    	   886:             move.l #$80000001,d0      * populate test data
02:00000A98 7A00            	   887:             move.l #0,d5              * populate bit.s number to test
02:00000A9A 7C01            	   888:             move.l #1,d6              * populate bit.s number to test
02:00000A9C 7E1F            	   889:             move.l #31,d7              * populate bit.s number to test
                            	   890: 
02:00000A9E 0B40            	   891:             bchg.l d5,d0
02:00000AA0 67FE            	   892:             beq.s *               * branch if Z set
02:00000AA2 0D40            	   893:             bchg.l d6,d0              *
02:00000AA4 66FE            	   894:             bne.s *               * branch if Z clear
02:00000AA6 0F40            	   895:             bchg.l d7,d0             *
02:00000AA8 67FE            	   896:             beq.s *               * branch if Z set
02:00000AAA 0C8000000002    	   897:             cmpi.l #$00000002,d0
02:00000AB0 66FE            	   898:             bne.s *               * branch if Z clear
                            	   899: 
                            	   900: 
                            	   901: *             EA = (An)  - BYTE only
02:00000AB2 7A00            	   902:             move.l #0,d5              * populate bit.s number to test
02:00000AB4 7C01            	   903:             move.l #1,d6              * populate bit.s number to test
02:00000AB6 7E07            	   904:             move.l #7,d7              * populate bit.s number to test
02:00000AB8 307C0100        	   905:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000ABC 10BC0081        	   906:             move.b #$81,(a0)          * populate test data
02:00000AC0 1210            	   907:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:00000AC2 0B50            	   908:             bchg.b d5,(a0)
02:00000AC4 67FE            	   909:             beq.s *               * branch if Z set
02:00000AC6 0D50            	   910:             bchg.b d6,(a0)            *
02:00000AC8 66FE            	   911:             bne.s *               * branch if Z clear
02:00000ACA 0F50            	   912:             bchg.b d7,(a0)            *
02:00000ACC 67FE            	   913:             beq.s *               * branch if Z set
02:00000ACE 0C100002        	   914:             cmpi.b #$02,(a0)
02:00000AD2 66FE            	   915:             bne.s *               * branch if Z clear
                            	   916: 
                            	   917: 
                            	   918: *             EA = (An)+  - BYTE only
02:00000AD4 307C0100        	   919:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000AD8 10FC0001        	   920:             move.b #$01,(a0)+         * populate test data
02:00000ADC 10FC00FC        	   921:             move.b #$FC,(a0)+         * populate test data
02:00000AE0 10FC0080        	   922:             move.b #$80,(a0)+         * populate test data
02:00000AE4 307C0100        	   923:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000AE8 0B58            	   924:             bchg.b d5,(a0)+
02:00000AEA 67FE            	   925:             beq.s *               * branch if Z set
02:00000AEC 0D58            	   926:             bchg.b d6,(a0)+           *
02:00000AEE 66FE            	   927:             bne.s *               * branch if Z clear
02:00000AF0 0F58            	   928:             bchg.b d7,(a0)+           *
02:00000AF2 67FE            	   929:             beq.s *               * branch if Z set
02:00000AF4 307C0100        	   930:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000AF8 4A18            	   931:             cmpi.b #$00,(a0)+
02:00000AFA 66FE            	   932:             bne.s *               * branch if Z clear
02:00000AFC 0C1800FE        	   933:             cmpi.b #$FE,(a0)+
02:00000B00 66FE            	   934:             bne.s *               * branch if Z clear
02:00000B02 4A18            	   935:             cmpi.b #$00,(a0)+
02:00000B04 66FE            	   936:             bne.s *               * branch if Z clear
                            	   937: 
                            	   938: *             EA = -(An)  - BYTE only
02:00000B06 307C0100        	   939:             move.l #$00000100,a0      * point to memory to address
02:00000B0A 10FC0080        	   940:             move.b #$80,(a0)+         * populate test data
02:00000B0E 10FC00FC        	   941:             move.b #$FC,(a0)+         * populate test data
02:00000B12 10FC0001        	   942:             move.b #$01,(a0)+         * populate test data
02:00000B16 307C0103        	   943:             move.l #$00000103,a0      * point to memory to address
02:00000B1A 0B60            	   944:             bchg.b d5,-(a0)
02:00000B1C 67FE            	   945:             beq.s *               * branch if Z set
02:00000B1E 0D60            	   946:             bchg.b d6,-(a0)           *
02:00000B20 66FE            	   947:             bne.s *               * branch if Z clear
02:00000B22 0F60            	   948:             bchg.b d7,-(a0)           *
02:00000B24 67FE            	   949:             beq.s *               * branch if Z set
02:00000B26 307C0103        	   950:             move.l #$00000103,a0      * point to memory to address 0x100
02:00000B2A 4A20            	   951:             cmpi.b #$00,-(a0)
02:00000B2C 66FE            	   952:             bne.s *               * branch if Z clear
02:00000B2E 0C2000FE        	   953:             cmpi.b #$FE,-(a0)
02:00000B32 66FE            	   954:             bne.s *               * branch if Z clear
02:00000B34 4A20            	   955:             cmpi.b #$00,-(a0)
02:00000B36 66FE            	   956:             bne.s *               * branch if Z clear
                            	   957: 
                            	   958: *             EA = n(An)  - BYTE only
02:00000B38 307C0100        	   959:             move.l #$00000100,a0      * point to memory to address
02:00000B3C 10FC0001        	   960:             move.b #$01,(a0)+         * populate test data
02:00000B40 10FC00FC        	   961:             move.b #$FC,(a0)+         * populate test data
02:00000B44 10FC0080        	   962:             move.b #$80,(a0)+         * populate test data
02:00000B48 307C0100        	   963:             move.l #$00000100,a0      * point to memory to address
02:00000B4C 0B50            	   964:             bchg.b d5,0(a0)
02:00000B4E 67FE            	   965:             beq.s *               * branch if Z set
02:00000B50 0D680001        	   966:             bchg.b d6,1(a0)           *
02:00000B54 66FE            	   967:             bne.s *               * branch if Z clear
02:00000B56 0F680002        	   968:             bchg.b d7,2(a0)           *
02:00000B5A 67FE            	   969:             beq.s *               * branch if Z set
02:00000B5C 307C0100        	   970:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000B60 4A18            	   971:             cmpi.b #$00,(a0)+
02:00000B62 66FE            	   972:             bne.s *               * branch if Z clear
02:00000B64 0C1800FE        	   973:             cmpi.b #$FE,(a0)+
02:00000B68 66FE            	   974:             bne.s *               * branch if Z clear
02:00000B6A 4A18            	   975:             cmpi.b #$00,(a0)+
02:00000B6C 66FE            	   976:             bne.s *               * branch if Z clear
                            	   977: 
                            	   978: *             EA = n(An,R.W)  - BYTE only
02:00000B6E 307C0100        	   979:             move.l #$00000100,a0      * point to memory to address
02:00000B72 93C9            	   980:             move.l #$00000000,a1      * point to memory to address
02:00000B74 347C0001        	   981:             move.l #$00000001,a2      * point to memory to address
02:00000B78 7000            	   982:             moveq  #$00000000,d0      * point to memory to address
02:00000B7A 7201            	   983:             moveq  #$00000001,d1      * point to memory to address
02:00000B7C 0B700000        	   984:             bchg.b d5,0(a0,d0.w)
02:00000B80 66FE            	   985:             bne.s *               * branch if Z clear
02:00000B82 0D701000        	   986:             bchg.b d6,0(a0,d1.w)      *
02:00000B86 67FE            	   987:             beq.s *               * branch if Z set
02:00000B88 0F701001        	   988:             bchg.b d7,1(a0,d1.w)      *
02:00000B8C 66FE            	   989:             bne.s *               * branch if Z clear
                            	   990: *             EA = n(An,R.L)  - BYTE only
02:00000B8E 0B700800        	   991:             bchg.b d5,0(a0,d0.l)
02:00000B92 67FE            	   992:             beq.s *               * branch if Z set
02:00000B94 0D701800        	   993:             bchg.b d6,0(a0,d1.l)      *
02:00000B98 66FE            	   994:             bne.s *               * branch if Z clear
02:00000B9A 0F701801        	   995:             bchg.b d7,1(a0,d1.l)      *
02:00000B9E 67FE            	   996:             beq.s *               * branch if Z set
                            	   997: *             EA = n(An,A.W)  - BYTE only
02:00000BA0 0B709000        	   998:             bchg.b d5,0(a0,a1.w)
02:00000BA4 66FE            	   999:             bne.s *               * branch if Z clear
02:00000BA6 0D70A000        	  1000:             bchg.b d6,0(a0,a2.w)      *
02:00000BAA 67FE            	  1001:             beq.s *               * branch if Z set
02:00000BAC 0F70A001        	  1002:             bchg.b d7,1(a0,a2.w)      *
02:00000BB0 66FE            	  1003:             bne.s *               * branch if Z clear
                            	  1004: *             EA = n(An,A.L)  - BYTE only
02:00000BB2 0B709800        	  1005:             bchg.b d5,0(a0,a1.l)
02:00000BB6 67FE            	  1006:             beq.s *               * branch if Z set
02:00000BB8 0D70A800        	  1007:             bchg.b d6,0(a0,a2.l)      *
02:00000BBC 66FE            	  1008:             bne.s *               * branch if Z clear
02:00000BBE 0F70A801        	  1009:             bchg.b d7,1(a0,a2.l)      *
02:00000BC2 67FE            	  1010:             beq.s *               * branch if Z set
02:00000BC4 4A18            	  1011:             cmpi.b #$00,(a0)+
02:00000BC6 66FE            	  1012:             bne.s *               * branch if Z clear
                            	  1013: 
                            	  1014: *             EA = x.W  - BYTE only
02:00000BC8 0B780100        	  1015:             bchg.b d5,$0100
02:00000BCC 66FE            	  1016:             bne.s *               * branch if Z clear
02:00000BCE 0D780101        	  1017:             bchg.b d6,$0101           *
02:00000BD2 67FE            	  1018:             beq.s *               * branch if Z set
02:00000BD4 0F780102        	  1019:             bchg.b d7,$0102           *
02:00000BD8 66FE            	  1020:             bne.s *               * branch if Z clear
02:00000BDA 0C1800FC        	  1021:             cmpi.b #$FC,(a0)+
02:00000BDE 66FE            	  1022:             bne.s *               * branch if Z clear
                            	  1023: 
                            	  1024: *             EA = x.L  - BYTE only
02:00000BE0 207C0000F100    	  1025:             move.l #$F100,a0      * point to memory to address 0x100
02:00000BE6 10FC0001        	  1026:             move.b #$01,(a0)+         * populate test data
02:00000BEA 10FC00FC        	  1027:             move.b #$FC,(a0)+         * populate test data
02:00000BEE 10FC0080        	  1028:             move.b #$80,(a0)+         * populate test data
02:00000BF2 0B790000F100    	  1029:             bchg.b d5,$F100
02:00000BF8 67FE            	  1030:             beq.s *               * branch if Z set
02:00000BFA 0D790000F101    	  1031:             bchg.b d6,$F101       *
02:00000C00 66FE            	  1032:             bne.s *               * branch if Z clear
02:00000C02 0F790000F102    	  1033:             bchg.b d7,$F102       *
02:00000C08 67FE            	  1034:             beq.s *               * branch if Z set
02:00000C0A 207C0000F101    	  1035:             move.l #$F101,a0      * point to memory to address 0x100
02:00000C10 0C1000FE        	  1036:             cmpi.b #$FE,(a0)
02:00000C14 66FE            	  1037:             bne.s *               * branch if Z clear
                            	  1038: 
                            	  1039: 
02:00000C16 4E75            	  1040:     rts
                            	  1041: 
                            	  1042: *-----------------------------------------------------------
                            	  1043: *-----------------------------------------------------------
                            	  1044: * OPCODE : BCLR
                            	  1045: *-----------------------------------------------------------
                            	  1046: *-----------------------------------------------------------
                            	  1047: op_BCLR:
                            	  1048: 
                            	  1049: 
                            	  1050: *  Bit Number.s Static
                            	  1051: 
                            	  1052: *             EA = Dn  - LONG only
02:00000C18 203CFF0000FF    	  1053:             move.l #$FF0000FF,d0      * populate test data
02:00000C1E 08800000        	  1054:             bclr.l #0,d0
02:00000C22 67FE            	  1055:             beq.s *               * branch if Z set
02:00000C24 08800001        	  1056:             bclr.l #1,d0              *
02:00000C28 67FE            	  1057:             beq.s *               * branch if Z set
02:00000C2A 0880000F        	  1058:             bclr.l #15,d0             *
02:00000C2E 66FE            	  1059:             bne.s *               * branch if Z clear
02:00000C30 0880001F        	  1060:             bclr.l #31,d0             *
02:00000C34 67FE            	  1061:             beq.s *               * branch if Z set
02:00000C36 0C807F0000FC    	  1062:             cmpi.l #$7F0000FC,d0
02:00000C3C 66FE            	  1063:             bne.s *               * branch if Z clear
                            	  1064: 
                            	  1065: 
                            	  1066: *             EA = (An)  - BYTE only
02:00000C3E 307C0100        	  1067:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C42 10BC000F        	  1068:             move.b #$0F,(a0)          * populate test data
02:00000C46 08900000        	  1069:             bclr.b #0,(a0)
02:00000C4A 67FE            	  1070:             beq.s *               * branch if Z set
02:00000C4C 08900007        	  1071:             bclr.b #7,(a0)            *
02:00000C50 66FE            	  1072:             bne.s *               * branch if Z clear
02:00000C52 0C10000E        	  1073:             cmpi.b #$0E,(a0)
02:00000C56 66FE            	  1074:             bne.s *               * branch if Z clear
                            	  1075: 
                            	  1076: *             EA = (An)+  - BYTE only
02:00000C58 307C0100        	  1077:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C5C 10FC0001        	  1078:             move.b #$01,(a0)+         * populate test data
02:00000C60 4218            	  1079:             move.b #$00,(a0)+         * populate test data
02:00000C62 307C0100        	  1080:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C66 08980000        	  1081:             bclr.b #0,(a0)+
02:00000C6A 67FE            	  1082:             beq.s *               * branch if Z set
02:00000C6C 08980001        	  1083:             bclr.b #1,(a0)+           *
02:00000C70 66FE            	  1084:             bne.s *               * branch if Z clear
02:00000C72 307C0100        	  1085:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C76 4A18            	  1086:             cmpi.b #$00,(a0)+
02:00000C78 66FE            	  1087:             bne.s *               * branch if Z clear
02:00000C7A 4A18            	  1088:             cmpi.b #$00,(a0)+
02:00000C7C 66FE            	  1089:             bne.s *               * branch if Z clear
                            	  1090: 
                            	  1091: 
                            	  1092: *             EA = -(An)  - BYTE only
02:00000C7E 307C0100        	  1093:             move.l #$00000100,a0      * point to memory to address
02:00000C82 10FC0001        	  1094:             move.b #$01,(a0)+         * populate test data
02:00000C86 10FC0080        	  1095:             move.b #$80,(a0)+         * populate test data
02:00000C8A 08A00007        	  1096:             bclr.b #7,-(a0)
02:00000C8E 67FE            	  1097:             beq.s *               * branch if Z set
02:00000C90 08A00000        	  1098:             bclr.b #0,-(a0)           *
02:00000C94 67FE            	  1099:             beq.s *               * branch if Z set
02:00000C96 307C0102        	  1100:             move.l #$00000102,a0      * point to memory to address 0x100
02:00000C9A 4A20            	  1101:             cmpi.b #$00,-(a0)
02:00000C9C 66FE            	  1102:             bne.s *               * branch if Z clear
02:00000C9E 4A20            	  1103:             cmpi.b #$00,-(a0)
02:00000CA0 66FE            	  1104:             bne.s *               * branch if Z clear
                            	  1105: 
                            	  1106: 
                            	  1107: *             EA = n(An)  - BYTE only
02:00000CA2 307C0100        	  1108:             move.l #$00000100,a0      * point to memory to address
02:00000CA6 10FC00FF        	  1109:             move.b #$FF,(a0)+         * populate test data
02:00000CAA 10FC00FF        	  1110:             move.b #$FF,(a0)+         * populate test data
02:00000CAE 307C0100        	  1111:             move.l #$00000100,a0      * point to memory to address
02:00000CB2 08900000        	  1112:             bclr.b #0,0(a0)
02:00000CB6 67FE            	  1113:             beq.s *               * branch if Z set
02:00000CB8 08A800040001    	  1114:             bclr.b #4,1(a0)           *
02:00000CBE 67FE            	  1115:             beq.s *               * branch if Z set
02:00000CC0 307C0100        	  1116:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000CC4 0C1800FE        	  1117:             cmpi.b #$FE,(a0)+
02:00000CC8 66FE            	  1118:             bne.s *               * branch if Z clear
02:00000CCA 0C1800EF        	  1119:             cmpi.b #$EF,(a0)+
02:00000CCE 66FE            	  1120:             bne.s *               * branch if Z clear
                            	  1121: 
                            	  1122: 
                            	  1123: *             EA = n(An,D.W)  - BYTE only
02:00000CD0 307C0100        	  1124:             move.l #$00000100,a0      * point to memory to address
02:00000CD4 93C9            	  1125:             move.l #$00000000,a1      * point to memory to address
02:00000CD6 347C0001        	  1126:             move.l #$00000001,a2      * point to memory to address
02:00000CDA 7000            	  1127:             moveq  #$00000000,d0      * point to memory to address
02:00000CDC 7201            	  1128:             moveq  #$00000001,d1      * point to memory to address
02:00000CDE 10FC00FF        	  1129:             move.b #$FF,(a0)+         * populate test data
02:00000CE2 10FC00FF        	  1130:             move.b #$FF,(a0)+         * populate test data
02:00000CE6 307C0100        	  1131:             move.l #$00000100,a0      * point to memory to address
02:00000CEA 08B000000000    	  1132:             bclr.b #0,0(a0,d0.w)
02:00000CF0 67FE            	  1133:             beq.s *               * branch if Z set
02:00000CF2 08B000011000    	  1134:             bclr.b #1,0(a0,d1.w)      *
02:00000CF8 67FE            	  1135:             beq.s *               * branch if Z set
02:00000CFA 08B000021001    	  1136:             bclr.b #2,1(a0,d1.w)      *
02:00000D00 66FE            	  1137:             bne.s *               * branch if Z clear
                            	  1138: *             EA = n(An,D.L)  - BYTE only
02:00000D02 08B000030800    	  1139:             bclr.b #3,0(a0,d0.l)
02:00000D08 67FE            	  1140:             beq.s *               * branch if Z set
02:00000D0A 08B000041800    	  1141:             bclr.b #4,0(a0,d1.l)      *
02:00000D10 67FE            	  1142:             beq.s *               * branch if Z set
02:00000D12 08B000051801    	  1143:             bclr.b #5,1(a0,d1.l)      *
02:00000D18 66FE            	  1144:             bne.s *               * branch if Z clear
                            	  1145: *             EA = n(An,A.W)  - BYTE only
02:00000D1A 08B000069000    	  1146:             bclr.b #6,0(a0,a1.w)
02:00000D20 67FE            	  1147:             beq.s *               * branch if Z set
02:00000D22 08B00001A000    	  1148:             bclr.b #1,0(a0,a2.w)      *
02:00000D28 66FE            	  1149:             bne.s *               * branch if Z clear
02:00000D2A 08B00007A001    	  1150:             bclr.b #7,1(a0,a2.w)      *
02:00000D30 67FE            	  1151:             beq.s *               * branch if Z set
                            	  1152: *             EA = n(An,A.L)  - BYTE only
02:00000D32 08B000009800    	  1153:             bclr.b #0,0(a0,a1.l)
02:00000D38 66FE            	  1154:             bne.s *               * branch if Z clear
02:00000D3A 08B00000A800    	  1155:             bclr.b #0,0(a0,a2.l)      *
02:00000D40 67FE            	  1156:             beq.s *               * branch if Z set
02:00000D42 08B00001A801    	  1157:             bclr.b #1,1(a0,a2.l)      *
02:00000D48 66FE            	  1158:             bne.s *               * branch if Z clear
02:00000D4A 307C0100        	  1159:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000D4E 0C1800B6        	  1160:             cmpi.b #$B6,(a0)+
02:00000D52 66FE            	  1161:             bne.s *               * branch if Z clear
02:00000D54 0C1800EC        	  1162:             cmpi.b #$EC,(a0)+
02:00000D58 66FE            	  1163:             bne.s *               * branch if Z clear
02:00000D5A 0C180059        	  1164:             cmpi.b #$59,(a0)+
02:00000D5E 67FE            	  1165:             beq.s *               * branch if Z set
                            	  1166: 
                            	  1167: 
                            	  1168: *             EA = x.W  - BYTE only
02:00000D60 307C0100        	  1169:             move.l #$00000100,a0      * point to memory to address
02:00000D64 10FC00FF        	  1170:             move.b #$FF,(a0)+         * populate test data
02:00000D68 08B800000100    	  1171:             bclr.b #0,$0100
02:00000D6E 67FE            	  1172:             beq.s *               * branch if Z set
02:00000D70 08B800010100    	  1173:             bclr.b #1,$0100           *
02:00000D76 67FE            	  1174:             beq.s *               * branch if Z set
02:00000D78 307C0100        	  1175:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000D7C 0C1800FC        	  1176:             cmpi.b #$FC,(a0)+
02:00000D80 66FE            	  1177:             bne.s *               * branch if Z clear
                            	  1178: 
                            	  1179: 
                            	  1180: *             EA = x.L  - BYTE only
02:00000D82 207C0000F100    	  1181:             move.l #$F100,a0      * point to memory to address 0x100
02:00000D88 10BC00FF        	  1182:             move.b #$FF,(a0)          * populate test data
02:00000D8C 08B900000000F100	  1183:             bclr.b #0,$F100
02:00000D94 67FE            	  1184:             beq.s *               * branch if Z set
02:00000D96 08B900010000F100	  1185:             bclr.b #1,$F100       *
02:00000D9E 67FE            	  1186:             beq.s *               * branch if Z set
02:00000DA0 08B900020000F100	  1187:             bclr.b #2,$F100       *
02:00000DA8 67FE            	  1188:             beq.s *               * branch if Z set
02:00000DAA 207C0000F100    	  1189:             move.l #$F100,a0      * point to memory to address 0x100
02:00000DB0 0C1800F8        	  1190:             cmpi.b #$F8,(a0)+
02:00000DB4 66FE            	  1191:             bne.s *               * branch if Z clear
                            	  1192: 
                            	  1193: 
                            	  1194: * Bit Number.s Dynamic
                            	  1195: 
                            	  1196: *             EA = Dn  - LONG only
02:00000DB6 203CFF00FF00    	  1197:             move.l #$FF00FF00,d0      * populate test data
02:00000DBC 7A00            	  1198:             move.l #0,d5              * populate bit.s number to test
02:00000DBE 7C01            	  1199:             move.l #1,d6              * populate bit.s number to test
02:00000DC0 7E1F            	  1200:             move.l #31,d7              * populate bit.s number to test
                            	  1201: 
02:00000DC2 0B80            	  1202:             bclr.l d5,d0
02:00000DC4 66FE            	  1203:             bne.s *               * branch if Z clear
02:00000DC6 0D80            	  1204:             bclr.l d6,d0              *
02:00000DC8 66FE            	  1205:             bne.s *               * branch if Z clear
02:00000DCA 0F80            	  1206:             bclr.l d7,d0             *
02:00000DCC 67FE            	  1207:             beq.s *               * branch if Z set
02:00000DCE 0C807F00FF00    	  1208:             cmpi.l #$7F00FF00,d0
02:00000DD4 66FE            	  1209:             bne.s *               * branch if Z clear
                            	  1210: 
                            	  1211: 
                            	  1212: *             EA = (An)  - BYTE only
02:00000DD6 7A00            	  1213:             move.l #0,d5              * populate bit.s number to test
02:00000DD8 7C01            	  1214:             move.l #1,d6              * populate bit.s number to test
02:00000DDA 7E07            	  1215:             move.l #7,d7              * populate bit.s number to test
02:00000DDC 307C0100        	  1216:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000DE0 10BC0081        	  1217:             move.b #$81,(a0)          * populate test data
02:00000DE4 0B90            	  1218:             bclr.b d5,(a0)
02:00000DE6 67FE            	  1219:             beq.s *               * branch if Z set
02:00000DE8 0D90            	  1220:             bclr.b d6,(a0)            *
02:00000DEA 66FE            	  1221:             bne.s *               * branch if Z clear
02:00000DEC 0F90            	  1222:             bclr.b d7,(a0)            *
02:00000DEE 67FE            	  1223:             beq.s *               * branch if Z set
02:00000DF0 4A10            	  1224:             cmpi.b #$00,(a0)
02:00000DF2 66FE            	  1225:             bne.s *               * branch if Z clear
                            	  1226: 
                            	  1227: 
                            	  1228: *             EA = (An)+  - BYTE only
02:00000DF4 307C0100        	  1229:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000DF8 10FC0001        	  1230:             move.b #$01,(a0)+         * populate test data
02:00000DFC 10FC00FC        	  1231:             move.b #$FC,(a0)+         * populate test data
02:00000E00 10FC0080        	  1232:             move.b #$80,(a0)+         * populate test data
02:00000E04 307C0100        	  1233:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000E08 0B98            	  1234:             bclr.b d5,(a0)+
02:00000E0A 67FE            	  1235:             beq.s *               * branch if Z set
02:00000E0C 0D98            	  1236:             bclr.b d6,(a0)+           *
02:00000E0E 66FE            	  1237:             bne.s *               * branch if Z clear
02:00000E10 0F98            	  1238:             bclr.b d7,(a0)+           *
02:00000E12 67FE            	  1239:             beq.s *               * branch if Z set
02:00000E14 307C0100        	  1240:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000E18 4A18            	  1241:             cmpi.b #$00,(a0)+
02:00000E1A 66FE            	  1242:             bne.s *               * branch if Z clear
02:00000E1C 0C1800FC        	  1243:             cmpi.b #$FC,(a0)+
02:00000E20 66FE            	  1244:             bne.s *               * branch if Z clear
02:00000E22 4A18            	  1245:             cmpi.b #$00,(a0)+
02:00000E24 66FE            	  1246:             bne.s *               * branch if Z clear
                            	  1247: 
                            	  1248: *             EA = -(An)  - BYTE only
02:00000E26 307C0100        	  1249:             move.l #$00000100,a0      * point to memory to address
02:00000E2A 10FC0080        	  1250:             move.b #$80,(a0)+         * populate test data
02:00000E2E 10FC00FC        	  1251:             move.b #$FC,(a0)+         * populate test data
02:00000E32 10FC0001        	  1252:             move.b #$01,(a0)+         * populate test data
02:00000E36 307C0103        	  1253:             move.l #$00000103,a0      * point to memory to address
02:00000E3A 0BA0            	  1254:             bclr.b d5,-(a0)
02:00000E3C 67FE            	  1255:             beq.s *               * branch if Z set
02:00000E3E 0DA0            	  1256:             bclr.b d6,-(a0)           *
02:00000E40 66FE            	  1257:             bne.s *               * branch if Z clear
02:00000E42 0FA0            	  1258:             bclr.b d7,-(a0)           *
02:00000E44 67FE            	  1259:             beq.s *               * branch if Z set
02:00000E46 307C0103        	  1260:             move.l #$00000103,a0      * point to memory to address 0x100
02:00000E4A 4A20            	  1261:             cmpi.b #$00,-(a0)
02:00000E4C 66FE            	  1262:             bne.s *               * branch if Z clear
02:00000E4E 0C2000FC        	  1263:             cmpi.b #$FC,-(a0)
02:00000E52 66FE            	  1264:             bne.s *               * branch if Z clear
02:00000E54 4A20            	  1265:             cmpi.b #$00,-(a0)
02:00000E56 66FE            	  1266:             bne.s *               * branch if Z clear
                            	  1267: 
                            	  1268: *             EA = n(An)  - BYTE only
02:00000E58 307C0100        	  1269:             move.l #$00000100,a0      * point to memory to address
02:00000E5C 10FC0001        	  1270:             move.b #$01,(a0)+         * populate test data
02:00000E60 10FC00FC        	  1271:             move.b #$FC,(a0)+         * populate test data
02:00000E64 10FC0080        	  1272:             move.b #$80,(a0)+         * populate test data
02:00000E68 307C0100        	  1273:             move.l #$00000100,a0      * point to memory to address
02:00000E6C 0B90            	  1274:             bclr.b d5,0(a0)
02:00000E6E 67FE            	  1275:             beq.s *               * branch if Z set
02:00000E70 0DA80001        	  1276:             bclr.b d6,1(a0)           *
02:00000E74 66FE            	  1277:             bne.s *               * branch if Z clear
02:00000E76 0FA80002        	  1278:             bclr.b d7,2(a0)           *
02:00000E7A 67FE            	  1279:             beq.s *               * branch if Z set
02:00000E7C 307C0100        	  1280:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000E80 4A18            	  1281:             cmpi.b #$00,(a0)+
02:00000E82 66FE            	  1282:             bne.s *               * branch if Z clear
02:00000E84 0C1800FC        	  1283:             cmpi.b #$FC,(a0)+
02:00000E88 66FE            	  1284:             bne.s *               * branch if Z clear
02:00000E8A 4A18            	  1285:             cmpi.b #$00,(a0)+
02:00000E8C 66FE            	  1286:             bne.s *               * branch if Z clear
                            	  1287: 
                            	  1288: *             EA = n(An,R.W)  - BYTE only
02:00000E8E 307C0100        	  1289:             move.l #$00000100,a0      * point to memory to address
02:00000E92 10FC00FF        	  1290:             move.b #$FF,(a0)+         * populate test data
02:00000E96 10FC00FF        	  1291:             move.b #$FF,(a0)+         * populate test data
02:00000E9A 10FC00FF        	  1292:             move.b #$FF,(a0)+         * populate test data
02:00000E9E 307C0103        	  1293:             move.l #$00000103,a0      * point to memory to address
02:00000EA2 307C0100        	  1294:             move.l #$00000100,a0      * point to memory to address
02:00000EA6 93C9            	  1295:             move.l #$00000000,a1      * point to memory to address
02:00000EA8 347C0001        	  1296:             move.l #$00000001,a2      * point to memory to address
02:00000EAC 7000            	  1297:             moveq  #$00000000,d0      * point to memory to address
02:00000EAE 7201            	  1298:             moveq  #$00000001,d1      * point to memory to address
02:00000EB0 0BB00000        	  1299:             bclr.b d5,0(a0,d0.w)
02:00000EB4 67FE            	  1300:             beq.s *               * branch if Z set
02:00000EB6 0DB01000        	  1301:             bclr.b d6,0(a0,d1.w)      *
02:00000EBA 67FE            	  1302:             beq.s *               * branch if Z set
02:00000EBC 0FB01001        	  1303:             bclr.b d7,1(a0,d1.w)      *
02:00000EC0 67FE            	  1304:             beq.s *               * branch if Z set
                            	  1305: *             EA = n(An,R.L)  - BYTE only
02:00000EC2 0BB00800        	  1306:             bclr.b d5,0(a0,d0.l)
02:00000EC6 66FE            	  1307:             bne.s *               * branch if Z clear
02:00000EC8 0DB01800        	  1308:             bclr.b d6,0(a0,d1.l)      *
02:00000ECC 66FE            	  1309:             bne.s *               * branch if Z clear
02:00000ECE 0FB01801        	  1310:             bclr.b d7,1(a0,d1.l)      *
02:00000ED2 66FE            	  1311:             bne.s *               * branch if Z clear
                            	  1312: *             EA = n(An,A.W)  - BYTE only
02:00000ED4 0BB09000        	  1313:             bclr.b d5,0(a0,a1.w)
02:00000ED8 66FE            	  1314:             bne.s *               * branch if Z clear
02:00000EDA 0DB0A000        	  1315:             bclr.b d6,0(a0,a2.w)      *
02:00000EDE 66FE            	  1316:             bne.s *               * branch if Z clear
02:00000EE0 0FB0A001        	  1317:             bclr.b d7,1(a0,a2.w)      *
02:00000EE4 66FE            	  1318:             bne.s *               * branch if Z clear
                            	  1319: *             EA = n(An,A.L)  - BYTE only
02:00000EE6 0BB09800        	  1320:             bclr.b d5,0(a0,a1.l)
02:00000EEA 66FE            	  1321:             bne.s *               * branch if Z clear
02:00000EEC 0DB0A800        	  1322:             bclr.b d6,0(a0,a2.l)      *
02:00000EF0 66FE            	  1323:             bne.s *               * branch if Z clear
02:00000EF2 0FB0A801        	  1324:             bclr.b d7,1(a0,a2.l)      *
02:00000EF6 66FE            	  1325:             bne.s *               * branch if Z clear
02:00000EF8 307C0100        	  1326:             move.l #$00000100,a0      * point to memory to address
02:00000EFC 0C1000FE        	  1327:             cmpi.b #$FE,(a0)
02:00000F00 66FE            	  1328:             bne.s *               * branch if Z clear
                            	  1329: 
                            	  1330: *             EA = x.W  - BYTE only
02:00000F02 307C0100        	  1331:             move.l #$00000100,a0      * point to memory to address
02:00000F06 10FC00FF        	  1332:             move.b #$FF,(a0)+         * populate test data
02:00000F0A 10FC00FF        	  1333:             move.b #$FF,(a0)+         * populate test data
02:00000F0E 10FC00FF        	  1334:             move.b #$FF,(a0)+         * populate test data
02:00000F12 0BB80100        	  1335:             bclr.b d5,$0100
02:00000F16 67FE            	  1336:             beq.s *               * branch if Z set
02:00000F18 0DB80101        	  1337:             bclr.b d6,$0101           *
02:00000F1C 67FE            	  1338:             beq.s *               * branch if Z set
02:00000F1E 0FB80102        	  1339:             bclr.b d7,$0102           *
02:00000F22 67FE            	  1340:             beq.s *               * branch if Z set
02:00000F24 307C0100        	  1341:             move.l #$00000100,a0      * point to memory to address
02:00000F28 0C1800FE        	  1342:             cmpi.b #$FE,(a0)+
02:00000F2C 66FE            	  1343:             bne.s *               * branch if Z clear
                            	  1344: 
                            	  1345: *             EA = x.L  - BYTE only
02:00000F2E 207C0000F100    	  1346:             move.l #$F100,a0      * point to memory to address 0x100
02:00000F34 10FC0001        	  1347:             move.b #$01,(a0)+         * populate test data
02:00000F38 10FC00FC        	  1348:             move.b #$FC,(a0)+         * populate test data
02:00000F3C 10FC0080        	  1349:             move.b #$80,(a0)+         * populate test data
02:00000F40 0BB90000F100    	  1350:             bclr.b d5,$F100
02:00000F46 67FE            	  1351:             beq.s *               * branch if Z set
02:00000F48 0DB90000F101    	  1352:             bclr.b d6,$F101       *
02:00000F4E 66FE            	  1353:             bne.s *               * branch if Z clear
02:00000F50 0FB90000F102    	  1354:             bclr.b d7,$F102       *
02:00000F56 67FE            	  1355:             beq.s *               * branch if Z set
02:00000F58 207C0000F101    	  1356:             move.l #$F101,a0      * point to memory to address 0x100
02:00000F5E 0C1000FC        	  1357:             cmpi.b #$FC,(a0)
02:00000F62 66FE            	  1358:             bne.s *               * branch if Z clear
                            	  1359: 
                            	  1360: 
                            	  1361: 
02:00000F64 4E75            	  1362:     rts
                            	  1363: 
                            	  1364: *-----------------------------------------------------------
                            	  1365: *-----------------------------------------------------------
                            	  1366: * OPCODE : BSET
                            	  1367: *-----------------------------------------------------------
                            	  1368: *-----------------------------------------------------------
                            	  1369: op_BSET:
                            	  1370: 
                            	  1371: 
                            	  1372: *  Bit Number.s Static
                            	  1373: 
                            	  1374: *             EA = Dn  - LONG only
02:00000F66 7000            	  1375:             moveq  #$00000000,d0      * populate test data
02:00000F68 08C00000        	  1376:             bset.l #0,d0
02:00000F6C 66FE            	  1377:             bne.s *               * branch if Z clear
02:00000F6E 08C00001        	  1378:             bset.l #1,d0              *
02:00000F72 66FE            	  1379:             bne.s *               * branch if Z clear
02:00000F74 08C0000F        	  1380:             bset.l #15,d0             *
02:00000F78 66FE            	  1381:             bne.s *               * branch if Z clear
02:00000F7A 08C0001F        	  1382:             bset.l #31,d0             *
02:00000F7E 66FE            	  1383:             bne.s *               * branch if Z clear
02:00000F80 0C8080008003    	  1384:             cmpi.l #$80008003,d0
02:00000F86 66FE            	  1385:             bne.s *               * branch if Z clear
                            	  1386: 
                            	  1387: 
                            	  1388: *             EA = (An)  - BYTE only
02:00000F88 307C0100        	  1389:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000F8C 4210            	  1390:             move.b #$00,(a0)          * populate test data
02:00000F8E 08D00000        	  1391:             bset.b #0,(a0)
02:00000F92 66FE            	  1392:             bne.s *               * branch if Z clear
02:00000F94 08D00007        	  1393:             bset.b #7,(a0)            *
02:00000F98 66FE            	  1394:             bne.s *               * branch if Z clear
02:00000F9A 0C100081        	  1395:             cmpi.b #$81,(a0)
02:00000F9E 66FE            	  1396:             bne.s *               * branch if Z clear
                            	  1397: 
                            	  1398: *             EA = (An)+  - BYTE only
02:00000FA0 307C0100        	  1399:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000FA4 4218            	  1400:             move.b #$00,(a0)+         * populate test data
02:00000FA6 4218            	  1401:             move.b #$00,(a0)+         * populate test data
02:00000FA8 307C0100        	  1402:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000FAC 08D80000        	  1403:             bset.b #0,(a0)+
02:00000FB0 66FE            	  1404:             bne.s *               * branch if Z clear
02:00000FB2 08D80001        	  1405:             bset.b #1,(a0)+           *
02:00000FB6 66FE            	  1406:             bne.s *               * branch if Z clear
02:00000FB8 307C0100        	  1407:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000FBC 0C180001        	  1408:             cmpi.b #$01,(a0)+
02:00000FC0 66FE            	  1409:             bne.s *               * branch if Z clear
02:00000FC2 0C180002        	  1410:             cmpi.b #$02,(a0)+
02:00000FC6 66FE            	  1411:             bne.s *               * branch if Z clear
                            	  1412: 
                            	  1413: 
                            	  1414: *             EA = -(An)  - BYTE only
02:00000FC8 307C0100        	  1415:             move.l #$00000100,a0      * point to memory to address
02:00000FCC 4218            	  1416:             move.b #$00,(a0)+         * populate test data
02:00000FCE 4218            	  1417:             move.b #$00,(a0)+         * populate test data
02:00000FD0 08E00007        	  1418:             bset.b #7,-(a0)
02:00000FD4 66FE            	  1419:             bne.s *               * branch if Z clear
02:00000FD6 08E00000        	  1420:             bset.b #0,-(a0)           *
02:00000FDA 66FE            	  1421:             bne.s *               * branch if Z clear
02:00000FDC 307C0102        	  1422:             move.l #$00000102,a0      * point to memory to address 0x100
02:00000FE0 0C200080        	  1423:             cmpi.b #$80,-(a0)
02:00000FE4 66FE            	  1424:             bne.s *               * branch if Z clear
02:00000FE6 0C200001        	  1425:             cmpi.b #$01,-(a0)
02:00000FEA 66FE            	  1426:             bne.s *               * branch if Z clear
                            	  1427: 
                            	  1428: 
                            	  1429: *             EA = n(An)  - BYTE only
02:00000FEC 307C0100        	  1430:             move.l #$00000100,a0      * point to memory to address
02:00000FF0 4218            	  1431:             move.b #$00,(a0)+         * populate test data
02:00000FF2 4218            	  1432:             move.b #$00,(a0)+         * populate test data
02:00000FF4 307C0100        	  1433:             move.l #$00000100,a0      * point to memory to address
02:00000FF8 08D00000        	  1434:             bset.b #0,0(a0)
02:00000FFC 66FE            	  1435:             bne.s *               * branch if Z clear
02:00000FFE 08E800040001    	  1436:             bset.b #4,1(a0)           *
02:00001004 66FE            	  1437:             bne.s *               * branch if Z clear
02:00001006 307C0100        	  1438:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000100A 0C180001        	  1439:             cmpi.b #$01,(a0)+
02:0000100E 66FE            	  1440:             bne.s *               * branch if Z clear
02:00001010 0C180010        	  1441:             cmpi.b #$10,(a0)+
02:00001014 66FE            	  1442:             bne.s *               * branch if Z clear
                            	  1443: 
                            	  1444: 
                            	  1445: *             EA = n(An,D.W)  - BYTE only
02:00001016 307C0100        	  1446:             move.l #$00000100,a0      * point to memory to address
02:0000101A 93C9            	  1447:             move.l #$00000000,a1      * point to memory to address
02:0000101C 347C0004        	  1448:             move.l #$00000004,a2      * point to memory to address
02:00001020 7000            	  1449:             moveq  #$00000000,d0      * point to memory to address
02:00001022 7201            	  1450:             moveq  #$00000001,d1      * point to memory to address
02:00001024 4218            	  1451:             move.b #$00,(a0)+         * populate test data
02:00001026 4218            	  1452:             move.b #$00,(a0)+         * populate test data
02:00001028 4218            	  1453:             move.b #$00,(a0)+         * populate test data
02:0000102A 4218            	  1454:             move.b #$00,(a0)+         * populate test data
02:0000102C 4218            	  1455:             move.b #$00,(a0)+         * populate test data
02:0000102E 4218            	  1456:             move.b #$00,(a0)+         * populate test data
02:00001030 4218            	  1457:             move.b #$00,(a0)+         * populate test data
02:00001032 4218            	  1458:             move.b #$00,(a0)+         * populate test data
02:00001034 4218            	  1459:             move.b #$00,(a0)+         * populate test data
02:00001036 4218            	  1460:             move.b #$00,(a0)+         * populate test data
02:00001038 307C0100        	  1461:             move.l #$00000100,a0      * point to memory to address
02:0000103C 08F000000000    	  1462:             bset.b #0,0(a0,d0.w)
02:00001042 66FE            	  1463:             bne.s *               * branch if Z clear
02:00001044 08F000011000    	  1464:             bset.b #1,0(a0,d1.w)      *
02:0000104A 66FE            	  1465:             bne.s *               * branch if Z clear
02:0000104C 08F000021001    	  1466:             bset.b #2,1(a0,d1.w)      *
02:00001052 66FE            	  1467:             bne.s *               * branch if Z clear
                            	  1468: *             EA = n(An,D.L)  - BYTE only
02:00001054 08F000030802    	  1469:             bset.b #3,2(a0,d0.l)
02:0000105A 66FE            	  1470:             bne.s *               * branch if Z clear
02:0000105C 08F000041800    	  1471:             bset.b #4,0(a0,d1.l)      *
02:00001062 66FE            	  1472:             bne.s *               * branch if Z clear
02:00001064 08F000051801    	  1473:             bset.b #5,1(a0,d1.l)      *
02:0000106A 66FE            	  1474:             bne.s *               * branch if Z clear
                            	  1475: *             EA = n(An,A.W)  - BYTE only
02:0000106C 08F000069000    	  1476:             bset.b #6,0(a0,a1.w)
02:00001072 66FE            	  1477:             bne.s *               * branch if Z clear
02:00001074 08F00001A000    	  1478:             bset.b #1,0(a0,a2.w)      *
02:0000107A 66FE            	  1479:             bne.s *               * branch if Z clear
02:0000107C 08F00007A001    	  1480:             bset.b #7,1(a0,a2.w)      *
02:00001082 66FE            	  1481:             bne.s *               * branch if Z clear
                            	  1482: *             EA = n(An,A.L)  - BYTE only
02:00001084 08F00000A802    	  1483:             bset.b #0,2(a0,a2.l)
02:0000108A 66FE            	  1484:             bne.s *               * branch if Z clear
02:0000108C 08F00000A803    	  1485:             bset.b #0,3(a0,a2.l)      *
02:00001092 66FE            	  1486:             bne.s *               * branch if Z clear
02:00001094 08F00001A804    	  1487:             bset.b #1,4(a0,a2.l)      *
02:0000109A 66FE            	  1488:             bne.s *               * branch if Z clear
02:0000109C 307C0100        	  1489:             move.l #$00000100,a0      * point to memory to address 0x100
02:000010A0 0C9841122C00    	  1490:             cmpi.l #$41122C00,(a0)+
02:000010A6 66FE            	  1491:             bne.s *               * branch if Z clear
02:000010A8 0C9802800101    	  1492:             cmpi.l #$02800101,(a0)+
02:000010AE 66FE            	  1493:             bne.s *
                            	  1494: 
                            	  1495: 
                            	  1496: 
                            	  1497: *             EA = x.W  - BYTE only
02:000010B0 307C0100        	  1498:             move.l #$00000100,a0      * point to memory to address
02:000010B4 4218            	  1499:             move.b #$00,(a0)+         * populate test data
02:000010B6 08F800000100    	  1500:             bset.b #0,$0100
02:000010BC 66FE            	  1501:             bne.s *               * branch if Z clear
02:000010BE 08F800010100    	  1502:             bset.b #1,$0100           *
02:000010C4 66FE            	  1503:             bne.s *               * branch if Z clear
02:000010C6 307C0100        	  1504:             move.l #$00000100,a0      * point to memory to address 0x100
02:000010CA 0C180003        	  1505:             cmpi.b #$03,(a0)+
02:000010CE 66FE            	  1506:             bne.s *
                            	  1507: 
                            	  1508: 
                            	  1509: *             EA = x.L  - BYTE only
02:000010D0 207C0000F100    	  1510:             move.l #$F100,a0      * point to memory to address 0x100
02:000010D6 4210            	  1511:             move.b #$00,(a0)          * populate test data
02:000010D8 08F900000000F100	  1512:             bset.b #0,$F100
02:000010E0 66FE            	  1513:             bne.s *               * branch if Z clear
02:000010E2 08F900010000F100	  1514:             bset.b #1,$F100       *
02:000010EA 66FE            	  1515:             bne.s *               * branch if Z clear
02:000010EC 08F900020000F100	  1516:             bset.b #2,$F100       *
02:000010F4 66FE            	  1517:             bne.s *               * branch if Z clear
02:000010F6 207C0000F100    	  1518:             move.l #$F100,a0      * point to memory to address 0x100
02:000010FC 0C180007        	  1519:             cmpi.b #$07,(a0)+
02:00001100 66FE            	  1520:             bne.s *
                            	  1521: 
                            	  1522: 
                            	  1523: * Bit Number.s Dynamic
                            	  1524: 
                            	  1525: *             EA = Dn  - LONG only
02:00001102 7000            	  1526:             moveq  #$00000000,d0      * populate test data
02:00001104 7A00            	  1527:             move.l #0,d5              * populate bit.s number to test
02:00001106 7C01            	  1528:             move.l #1,d6              * populate bit.s number to test
02:00001108 7E1F            	  1529:             move.l #31,d7              * populate bit.s number to test
                            	  1530: 
02:0000110A 0BC0            	  1531:             bset.l d5,d0
02:0000110C 66FE            	  1532:             bne.s *               * branch if Z clear
02:0000110E 0DC0            	  1533:             bset.l d6,d0              *
02:00001110 66FE            	  1534:             bne.s *               * branch if Z clear
02:00001112 0FC0            	  1535:             bset.l d7,d0             *
02:00001114 66FE            	  1536:             bne.s *               * branch if Z clear
02:00001116 0C8080000003    	  1537:             cmpi.l #$80000003,d0
02:0000111C 66FE            	  1538:             bne.s *               * branch if Z clear
                            	  1539: 
                            	  1540: 
                            	  1541: *             EA = (An)  - BYTE only
02:0000111E 7A00            	  1542:             move.l #0,d5              * populate bit.s number to test
02:00001120 7C01            	  1543:             move.l #1,d6              * populate bit.s number to test
02:00001122 7E07            	  1544:             move.l #7,d7              * populate bit.s number to test
02:00001124 307C0100        	  1545:             move.l #$00000100,a0      * point to memory to address 0x100
02:00001128 4210            	  1546:             move.b #$00,(a0)          * populate test data
02:0000112A 0BD0            	  1547:             bset.b d5,(a0)
02:0000112C 66FE            	  1548:             bne.s *               * branch if Z clear
02:0000112E 0DD0            	  1549:             bset.b d6,(a0)            *
02:00001130 66FE            	  1550:             bne.s *               * branch if Z clear
02:00001132 0FD0            	  1551:             bset.b d7,(a0)            *
02:00001134 66FE            	  1552:             bne.s *               * branch if Z clear
02:00001136 0C100083        	  1553:             cmpi.b #$83,(a0)
02:0000113A 66FE            	  1554:             bne.s *               * branch if Z clear
                            	  1555: 
                            	  1556: 
                            	  1557: *             EA = (An)+  - BYTE only
02:0000113C 307C0100        	  1558:             move.l #$00000100,a0      * point to memory to address 0x100
02:00001140 4218            	  1559:             move.b #$00,(a0)+         * populate test data
02:00001142 4218            	  1560:             move.b #$00,(a0)+         * populate test data
02:00001144 4218            	  1561:             move.b #$00,(a0)+         * populate test data
02:00001146 307C0100        	  1562:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000114A 0BD8            	  1563:             bset.b d5,(a0)+
02:0000114C 66FE            	  1564:             bne.s *               * branch if Z clear
02:0000114E 0DD8            	  1565:             bset.b d6,(a0)+           *
02:00001150 66FE            	  1566:             bne.s *               * branch if Z clear
02:00001152 0FD8            	  1567:             bset.b d7,(a0)+           *
02:00001154 66FE            	  1568:             bne.s *               * branch if Z clear
02:00001156 307C0100        	  1569:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000115A 0C180001        	  1570:             cmpi.b #$01,(a0)+
02:0000115E 66FE            	  1571:             bne.s *               * branch if Z clear
02:00001160 0C180002        	  1572:             cmpi.b #$02,(a0)+
02:00001164 66FE            	  1573:             bne.s *               * branch if Z clear
02:00001166 0C180080        	  1574:             cmpi.b #$80,(a0)+
02:0000116A 66FE            	  1575:             bne.s *               * branch if Z clear
                            	  1576: 
                            	  1577: *             EA = -(An)  - BYTE only
02:0000116C 307C0100        	  1578:             move.l #$00000100,a0      * point to memory to address
02:00001170 4218            	  1579:             move.b #$00,(a0)+         * populate test data
02:00001172 4218            	  1580:             move.b #$00,(a0)+         * populate test data
02:00001174 4218            	  1581:             move.b #$00,(a0)+         * populate test data
02:00001176 307C0103        	  1582:             move.l #$00000103,a0      * point to memory to address
02:0000117A 0BE0            	  1583:             bset.b d5,-(a0)
02:0000117C 66FE            	  1584:             bne.s *               * branch if Z clear
02:0000117E 0DE0            	  1585:             bset.b d6,-(a0)           *
02:00001180 66FE            	  1586:             bne.s *               * branch if Z clear
02:00001182 0FE0            	  1587:             bset.b d7,-(a0)           *
02:00001184 66FE            	  1588:             bne.s *               * branch if Z clear
02:00001186 307C0103        	  1589:             move.l #$00000103,a0      * point to memory to address 0x100
02:0000118A 0C200001        	  1590:             cmpi.b #$01,-(a0)
02:0000118E 66FE            	  1591:             bne.s *               * branch if Z clear
02:00001190 0C200002        	  1592:             cmpi.b #$02,-(a0)
02:00001194 66FE            	  1593:             bne.s *               * branch if Z clear
02:00001196 0C200080        	  1594:             cmpi.b #$80,-(a0)
02:0000119A 66FE            	  1595:             bne.s *               * branch if Z clear
                            	  1596: 
                            	  1597: *             EA = n(An)  - BYTE only
02:0000119C 307C0100        	  1598:             move.l #$00000100,a0      * point to memory to address
02:000011A0 4218            	  1599:             move.b #$00,(a0)+         * populate test data
02:000011A2 4218            	  1600:             move.b #$00,(a0)+         * populate test data
02:000011A4 4218            	  1601:             move.b #$00,(a0)+         * populate test data
02:000011A6 307C0100        	  1602:             move.l #$00000100,a0      * point to memory to address
02:000011AA 0BD0            	  1603:             bset.b d5,0(a0)
02:000011AC 66FE            	  1604:             bne.s *               * branch if Z clear
02:000011AE 0DE80001        	  1605:             bset.b d6,1(a0)           *
02:000011B2 66FE            	  1606:             bne.s *               * branch if Z clear
02:000011B4 0FE80002        	  1607:             bset.b d7,2(a0)           *
02:000011B8 66FE            	  1608:             bne.s *               * branch if Z clear
02:000011BA 307C0100        	  1609:             move.l #$00000100,a0      * point to memory to address 0x100
02:000011BE 0C180001        	  1610:             cmpi.b #$01,(a0)+
02:000011C2 66FE            	  1611:             bne.s *               * branch if Z clear
02:000011C4 0C180002        	  1612:             cmpi.b #$02,(a0)+
02:000011C8 66FE            	  1613:             bne.s *               * branch if Z clear
02:000011CA 0C180080        	  1614:             cmpi.b #$80,(a0)+
02:000011CE 66FE            	  1615:             bne.s *               * branch if Z clear
                            	  1616: 
                            	  1617: *             EA = n(An,R.W)  - BYTE only
02:000011D0 307C0100        	  1618:             move.l #$00000100,a0      * point to memory to address
02:000011D4 4218            	  1619:             move.b #$00,(a0)+         * populate test data
02:000011D6 4218            	  1620:             move.b #$00,(a0)+         * populate test data
02:000011D8 4218            	  1621:             move.b #$00,(a0)+         * populate test data
02:000011DA 4218            	  1622:             move.b #$00,(a0)+         * populate test data
02:000011DC 4218            	  1623:             move.b #$00,(a0)+         * populate test data
02:000011DE 4218            	  1624:             move.b #$00,(a0)+         * populate test data
02:000011E0 4218            	  1625:             move.b #$00,(a0)+         * populate test data
02:000011E2 4218            	  1626:             move.b #$00,(a0)+         * populate test data
02:000011E4 4218            	  1627:             move.b #$00,(a0)+         * populate test data
02:000011E6 4218            	  1628:             move.b #$00,(a0)+         * populate test data
02:000011E8 4218            	  1629:             move.b #$00,(a0)+         * populate test data
02:000011EA 4218            	  1630:             move.b #$00,(a0)+         * populate test data
02:000011EC 307C0100        	  1631:             move.l #$00000100,a0      * point to memory to address
02:000011F0 93C9            	  1632:             move.l #$00000000,a1      * point to memory to address
02:000011F2 347C0001        	  1633:             move.l #$00000001,a2      * point to memory to address
02:000011F6 7000            	  1634:             moveq  #$00000000,d0      * point to memory to address
02:000011F8 7201            	  1635:             moveq  #$00000001,d1      * point to memory to address
02:000011FA 0BF00000        	  1636:             bset.b d5,0(a0,d0.w)
02:000011FE 66FE            	  1637:             bne.s *               * branch if Z clear
02:00001200 0DF01000        	  1638:             bset.b d6,0(a0,d1.w)      *
02:00001204 66FE            	  1639:             bne.s *               * branch if Z clear
02:00001206 0FF01001        	  1640:             bset.b d7,1(a0,d1.w)      *
02:0000120A 66FE            	  1641:             bne.s *               * branch if Z clear
                            	  1642: *             EA = n(An,R.L)  - BYTE only
02:0000120C 0BF00802        	  1643:             bset.b d5,2(a0,d0.l)
02:00001210 66FE            	  1644:             bne.s *               * branch if Z clear
02:00001212 0DF01803        	  1645:             bset.b d6,3(a0,d1.l)      *
02:00001216 66FE            	  1646:             bne.s *               * branch if Z clear
02:00001218 0FF01804        	  1647:             bset.b d7,4(a0,d1.l)      *
02:0000121C 66FE            	  1648:             bne.s *               * branch if Z clear
                            	  1649: *             EA = n(An,A.W)  - BYTE only
02:0000121E 0BF09005        	  1650:             bset.b d5,5(a0,a1.w)
02:00001222 66FE            	  1651:             bne.s *               * branch if Z clear
02:00001224 0DF0A006        	  1652:             bset.b d6,6(a0,a2.w)      *
02:00001228 66FE            	  1653:             bne.s *               * branch if Z clear
02:0000122A 0FF0A007        	  1654:             bset.b d7,7(a0,a2.w)      *
02:0000122E 66FE            	  1655:             bne.s *               * branch if Z clear
                            	  1656: *             EA = n(An,A.L)  - BYTE only
02:00001230 0BF09808        	  1657:             bset.b d5,8(a0,a1.l)
02:00001234 66FE            	  1658:             bne.s *               * branch if Z clear
02:00001236 0DF0A809        	  1659:             bset.b d6,9(a0,a2.l)      *
02:0000123A 66FE            	  1660:             bne.s *               * branch if Z clear
02:0000123C 0FF0A80A        	  1661:             bset.b d7,10(a0,a2.l)      *
02:00001240 66FE            	  1662:             bne.s *               * branch if Z clear
02:00001242 307C0100        	  1663:             move.l #$00000100,a0      * point to memory to address 0x100
02:00001246 0C9801028100    	  1664:             cmpi.l #$01028100,(a0)+
02:0000124C 66FE            	  1665:             bne.s *               * branch if Z clear
02:0000124E 0C9802810002    	  1666:             cmpi.l #$02810002,(a0)+
02:00001254 66FE            	  1667:             bne.s *
                            	  1668: 
                            	  1669: 
                            	  1670: *             EA = x.W  - BYTE only
02:00001256 307C0100        	  1671:             move.l #$00000100,a0      * point to memory to address
02:0000125A 4218            	  1672:             move.b #$00,(a0)+         * populate test data
02:0000125C 4218            	  1673:             move.b #$00,(a0)+         * populate test data
02:0000125E 4218            	  1674:             move.b #$00,(a0)+         * populate test data
02:00001260 0BF80100        	  1675:             bset.b d5,$0100
02:00001264 66FE            	  1676:             bne.s *               * branch if Z clear
02:00001266 0DF80100        	  1677:             bset.b d6,$0100           *
02:0000126A 66FE            	  1678:             bne.s *               * branch if Z clear
02:0000126C 0FF80100        	  1679:             bset.b d7,$0100           *
02:00001270 66FE            	  1680:             bne.s *               * branch if Z clear
02:00001272 307C0100        	  1681:             move.l #$00000100,a0      * point to memory to address
02:00001276 0C180083        	  1682:             cmpi.b #$83,(a0)+
02:0000127A 66FE            	  1683:             bne.s *               * branch if Z clear
                            	  1684: 
                            	  1685: *             EA = x.L  - BYTE only
02:0000127C 207C0000F100    	  1686:             move.l #$F100,a0      * point to memory to address 0x100
02:00001282 4218            	  1687:             move.b #$00,(a0)+         * populate test data
02:00001284 4218            	  1688:             move.b #$00,(a0)+         * populate test data
02:00001286 4218            	  1689:             move.b #$00,(a0)+         * populate test data
02:00001288 0BF90000F100    	  1690:             bset.b d5,$F100
02:0000128E 66FE            	  1691:             bne.s *               * branch if Z clear
02:00001290 0DF90000F100    	  1692:             bset.b d6,$F100       *
02:00001296 66FE            	  1693:             bne.s *               * branch if Z clear
02:00001298 0FF90000F100    	  1694:             bset.b d7,$F100       *
02:0000129E 66FE            	  1695:             bne.s *               * branch if Z clear
02:000012A0 207C0000F100    	  1696:             move.l #$F100,a0      * point to memory to address 0x100
02:000012A6 0C100083        	  1697:             cmpi.b #$83,(a0)
02:000012AA 66FE            	  1698:             bne.s *               * branch if Z clear
                            	  1699: 
                            	  1700: 
02:000012AC 4E75            	  1701:     rts
                            	  1702: 
                            	  1703: *-----------------------------------------------------------
                            	  1704: *-----------------------------------------------------------
                            	  1705: * OPCODE : MOVEP
                            	  1706: *-----------------------------------------------------------
                            	  1707: *-----------------------------------------------------------
                            	  1708: op_MOVEP:
                            	  1709: 
                            	  1710: * Dn --> x(An)
02:000012AE 307C0100        	  1711:             move.l #$00000100,a0
02:000012B2 203C12345678    	  1712:             move.l #$12345678,d0
02:000012B8 223CAABBCCDD    	  1713:             move.l #$AABBCCDD,d1
02:000012BE 4290            	  1714:             move.l #0,(a0)
02:000012C0 42A80004        	  1715:             move.l #0,4(a0)
                            	  1716: 
02:000012C4 01880000        	  1717:             movep.w d0,0(a0)      * even offset
02:000012C8 03880001        	  1718:             movep.w d1,1(a0)      * odd offset
                            	  1719: 
02:000012CC 01C80004        	  1720:             movep.l d0,4(a0)      * even offset
02:000012D0 03C80005        	  1721:             movep.l d1,5(a0)      * odd offset
                            	  1722: 
02:000012D4 0C9056CC78DD    	  1723:             cmpi.l #$56CC78DD,(a0)
02:000012DA 66FE            	  1724:             bne.s *
02:000012DC 0CA812AA34BB0004	  1725:             cmpi.l #$12AA34BB,4(a0)
02:000012E4 66FE            	  1726:             bne.s *
02:000012E6 0CA856CC78DD0008	  1727:             cmpi.l #$56CC78DD,8(a0)
02:000012EE 66FE            	  1728:             bne.s *
                            	  1729: 
                            	  1730: 
                            	  1731: * x(An)--> Dn
02:000012F0 203C5A5A5A5A    	  1732:             move.l #$5a5a5a5a,d0
02:000012F6 223C5A5A5A5A    	  1733:             move.l #$5a5a5a5a,d1
02:000012FC 243C5A5A5A5A    	  1734:             move.l #$5a5a5a5a,d2
02:00001302 263C5A5A5A5A    	  1735:             move.l #$5a5a5a5a,d3
                            	  1736: 
02:00001308 01080000        	  1737:             movep.w 0(a0),d0      * even offset
02:0000130C 03080001        	  1738:             movep.w 1(a0),d1      * odd offset
                            	  1739: 
02:00001310 05480004        	  1740:             movep.l 4(a0),d2      * even offset
02:00001314 07480005        	  1741:             movep.l 5(a0),d3      * odd offset
                            	  1742: 
02:00001318 0C805A5A5678    	  1743:             cmpi.l #$5a5a5678,d0
02:0000131E 66FE            	  1744:             bne.s *
02:00001320 0C815A5ACCDD    	  1745:             cmpi.l #$5a5aCCDD,d1
02:00001326 66FE            	  1746:             bne.s *
02:00001328 0C8212345678    	  1747:             cmpi.l #$12345678,d2
02:0000132E 66FE            	  1748:             bne.s *
02:00001330 0C83AABBCCDD    	  1749:             cmpi.l #$AABBCCDD,d3
02:00001336 66FE            	  1750:             bne.s *
                            	  1751: 
02:00001338 4E75            	  1752:             rts
                            	  1753: 
                            	  1754: 
                            	  1755: 
                            	  1756: *-----------------------------------------------------------
                            	  1757: *-----------------------------------------------------------
                            	  1758: * OPCODE : BOOL_I
                            	  1759: *-----------------------------------------------------------
                            	  1760: *-----------------------------------------------------------
                            	  1761: op_BOOL_I:
                            	  1762: 
                            	  1763: *     Dn -- BYTE
02:0000133A 203C12345678    	  1764:             move.l #$12345678,d0
02:00001340 44FC000F        	  1765:             move.w #$000F,CCR          * pre-set Flags
02:00001344 000000FF        	  1766:             ori.b  #$FF,d0
02:00001348 0A00005A        	  1767:             eori.b #$5A,d0
02:0000134C 020000F0        	  1768:             andi.b #$F0,d0
02:00001350 69FE            	  1769:             bvs.s *                       * Check V,C are cleared
02:00001352 65FE            	  1770:             bcs.s *
02:00001354 6AFE            	  1771:             bpl.s *                       * Verify if N flag is set
02:00001356 4200            	  1772:             andi.b #$00,d0
02:00001358 6BFE            	  1773:             bmi.s *                       * Verify if N flag is cleared
02:0000135A 66FE            	  1774:             bne.s *                       * Verify if Z flag is set
                            	  1775: 
                            	  1776: *     Dn -- WORD
02:0000135C 223C12345678    	  1777:             move.l #$12345678,d1
02:00001362 44FC000F        	  1778:             move.w #$000F,CCR          * pre-set Flags
02:00001366 0041FFFF        	  1779:             ori.w  #$FFFF,d1
02:0000136A 0A415A5A        	  1780:             eori.w #$5A5A,d1
02:0000136E 0241F0F0        	  1781:             andi.w #$F0F0,d1
02:00001372 69FE            	  1782:             bvs.s *                       * Check V,C are cleared
02:00001374 65FE            	  1783:             bcs.s *
02:00001376 6AFE            	  1784:             bpl.s *                       * Verify if N flag is set
02:00001378 4241            	  1785:             andi.w #$0000,d1
02:0000137A 6BFE            	  1786:             bmi.s *                       * Verify if N flag is cleared
02:0000137C 66FE            	  1787:             bne.s *                       * Verify if Z flag is set
                            	  1788: 
                            	  1789: *     Dn -- LONG
02:0000137E 243C12345678    	  1790:             move.l #$12345678,d2
02:00001384 44FC000F        	  1791:             move.w #$000F,CCR          * pre-set Flags
02:00001388 0082FFFFFFFF    	  1792:             ori.l  #$FFFFFFFF,d2
02:0000138E 0A825A5A5A5A    	  1793:             eori.l #$5A5A5A5A,d2
02:00001394 0282F0F0F0F0    	  1794:             andi.l #$F0F0F0F0,d2
02:0000139A 69FE            	  1795:             bvs.s *                       * Check V,C are cleared
02:0000139C 65FE            	  1796:             bcs.s *
02:0000139E 6AFE            	  1797:             bpl.s *                       * Verify if N flag is set
02:000013A0 4282            	  1798:             andi.l #$00000000,d2
02:000013A2 6BFE            	  1799:             bmi.s *                       * Verify if N flag is cleared
02:000013A4 66FE            	  1800:             bne.s *                       * Verify if Z flag is set
                            	  1801: 
                            	  1802: 
                            	  1803: *     (An) -- BYTE
02:000013A6 307C0100        	  1804:             move.l #$00000100,a0
02:000013AA 20BC12345678    	  1805:             move.l #$12345678,(a0)
02:000013B0 44FC000F        	  1806:             move.w #$000F,CCR          * pre-set Flags
02:000013B4 001000FF        	  1807:             ori.b  #$FF,(a0)
02:000013B8 0A10005A        	  1808:             eori.b #$5A,(a0)
02:000013BC 021000F0        	  1809:             andi.b #$F0,(a0)
02:000013C0 69FE            	  1810:             bvs.s *                       * Check V,C are cleared
02:000013C2 65FE            	  1811:             bcs.s *
02:000013C4 6AFE            	  1812:             bpl.s *                       * Verify if N flag is set
02:000013C6 4210            	  1813:             andi.b #$00,(a0)
02:000013C8 6BFE            	  1814:             bmi.s *                       * Verify if N flag is cleared
02:000013CA 66FE            	  1815:             bne.s *                       * Verify if Z flag is set
02:000013CC 4A10            	  1816:             cmpi.b #$00,(a0)
02:000013CE 66FE            	  1817:             bne.s *                       * Verify if Z flag is set
                            	  1818: 
                            	  1819: *     (An) -- WORD
02:000013D0 20BC12345678    	  1820:             move.l #$12345678,(a0)
02:000013D6 44FC000F        	  1821:             move.w #$000F,CCR          * pre-set Flags
02:000013DA 0050FFFF        	  1822:             ori.w  #$FFFF,(a0)
02:000013DE 0A505A5A        	  1823:             eori.w #$5A5A,(a0)
02:000013E2 0250F0F0        	  1824:             andi.w #$F0F0,(a0)
02:000013E6 69FE            	  1825:             bvs.s *                       * Check V,C are cleared
02:000013E8 65FE            	  1826:             bcs.s *
02:000013EA 6AFE            	  1827:             bpl.s *                       * Verify if N flag is set
02:000013EC 4250            	  1828:             andi.w #$0000,(a0)
02:000013EE 6BFE            	  1829:             bmi.s *                       * Verify if N flag is cleared
02:000013F0 66FE            	  1830:             bne.s *                       * Verify if Z flag is set
02:000013F2 4A50            	  1831:             cmpi.w #$00,(a0)
02:000013F4 66FE            	  1832:             bne.s *                       * Verify if Z flag is set
                            	  1833: 
                            	  1834: *     (An) -- LONG
02:000013F6 20BC12345678    	  1835:             move.l #$12345678,(a0)
02:000013FC 44FC000F        	  1836:             move.w #$000F,CCR          * pre-set Flags
02:00001400 0090FFFFFFFF    	  1837:             ori.l  #$FFFFFFFF,(a0)
02:00001406 0A905A5A5A5A    	  1838:             eori.l #$5A5A5A5A,(a0)
02:0000140C 0290F0F0F0F0    	  1839:             andi.l #$F0F0F0F0,(a0)
02:00001412 69FE            	  1840:             bvs.s *                       * Check V,C are cleared
02:00001414 65FE            	  1841:             bcs.s *
02:00001416 6AFE            	  1842:             bpl.s *                       * Verify if N flag is set
02:00001418 4290            	  1843:             andi.l #$00000000,(a0)
02:0000141A 6BFE            	  1844:             bmi.s *                       * Verify if N flag is cleared
02:0000141C 66FE            	  1845:             bne.s *                       * Verify if Z flag is set
02:0000141E 4A90            	  1846:             cmpi.l #$00,(a0)
02:00001420 66FE            	  1847:             bne.s *                       * Verify if Z flag is set
                            	  1848: 
                            	  1849: 
                            	  1850: 
                            	  1851: *     (An)+ -- BYTE
02:00001422 307C0100        	  1852:             move.l #$00000100,a0
02:00001426 20BC00A5FF88    	  1853:             move.l #$00A5FF88,(a0)
02:0000142C 44FC000F        	  1854:             move.w #$000F,CCR          * pre-set Flags
                            	  1855: 
02:00001430 001800F5        	  1856:             ori.b  #$F5,(a0)+
02:00001434 6AFE            	  1857:             bpl.s *                       * Verify if N flag is set
02:00001436 67FE            	  1858:             beq.s *                       * Verify if Z flag is cleared
                            	  1859: 
02:00001438 4618            	  1860:             eori.b #$FF,(a0)+
02:0000143A 6BFE            	  1861:             bmi.s *                       * Verify if N flag is cleared
02:0000143C 67FE            	  1862:             beq.s *                       * Verify if Z flag is cleared
                            	  1863: 
02:0000143E 021800AA        	  1864:             andi.b #$AA,(a0)+
02:00001442 6AFE            	  1865:             bpl.s *                       * Verify if N flag is set
02:00001444 67FE            	  1866:             beq.s *                       * Verify if Z flag is cleared
                            	  1867: 
02:00001446 307C0100        	  1868:             move.l #$00000100,a0
02:0000144A 0C90F55AAA88    	  1869:             cmpi.l #$F55AAA88,(a0)
02:00001450 66FE            	  1870:             bne.s *                       * Verify if Z flag is set
                            	  1871: 
                            	  1872: 
                            	  1873: *     (An)+ -- WORD
02:00001452 307C0100        	  1874:             move.l #$00000100,a0
02:00001456 327C0104        	  1875:             move.l #$00000104,a1
02:0000145A 20BC00005A5A    	  1876:             move.l #$00005a5a,(a0)
02:00001460 22BC12345678    	  1877:             move.l #$12345678,(a1)
02:00001466 44FC000F        	  1878:             move.w #$000F,CCR          * pre-set Flags
                            	  1879: 
02:0000146A 00585678        	  1880:             ori.w  #$5678,(a0)+
02:0000146E 6BFE            	  1881:             bmi.s *                       * Verify if N flag is cleared
02:00001470 67FE            	  1882:             beq.s *                       * Verify if Z flag is cleared
                            	  1883: 
02:00001472 4658            	  1884:             eori.w #$FFFF,(a0)+
02:00001474 6AFE            	  1885:             bpl.s *                       * Verify if N flag is set
02:00001476 67FE            	  1886:             beq.s *                       * Verify if Z flag is cleared
                            	  1887: 
02:00001478 0258A55A        	  1888:             andi.w #$A55A,(a0)+
02:0000147C 6BFE            	  1889:             bmi.s *                       * Verify if N flag is cleared
02:0000147E 67FE            	  1890:             beq.s *                       * Verify if Z flag is cleared
                            	  1891: 
02:00001480 307C0100        	  1892:             move.l #$00000100,a0
02:00001484 0C905678A5A5    	  1893:             cmpi.l #$5678a5a5,(a0)
02:0000148A 307C0104        	  1894:             move.l #$00000104,a0
02:0000148E 0C9000105678    	  1895:             cmpi.l #$00105678,(a0)
02:00001494 66FE            	  1896:             bne.s *                       * Verify if Z flag is set
                            	  1897: 
                            	  1898: *     (An)+ -- LONG
02:00001496 307C0100        	  1899:             move.l #$00000100,a0
02:0000149A 4298            	  1900:             move.l #$00000000,(a0)+
02:0000149C 20FC5A5A5A5A    	  1901:             move.l #$5a5a5a5a,(a0)+
02:000014A2 20FCFFFFFFFF    	  1902:             move.l #$FFFFFFFF,(a0)+
02:000014A8 307C0100        	  1903:             move.l #$00000100,a0
02:000014AC 44FC000F        	  1904:             move.w #$000F,CCR          * pre-set Flags
                            	  1905: 
02:000014B0 009812345678    	  1906:             ori.l  #$12345678,(a0)+
02:000014B6 6BFE            	  1907:             bmi.s *                       * Verify if N flag is cleared
02:000014B8 67FE            	  1908:             beq.s *                       * Verify if Z flag is cleared
                            	  1909: 
02:000014BA 4698            	  1910:             eori.l #$FFFFFFFF,(a0)+
02:000014BC 6AFE            	  1911:             bpl.s *                       * Verify if N flag is set
02:000014BE 67FE            	  1912:             beq.s *                       * Verify if Z flag is cleared
                            	  1913: 
02:000014C0 0298A5A5A55A    	  1914:             andi.l #$A5A5A55A,(a0)+
02:000014C6 6AFE            	  1915:             bpl.s *                       * Verify if N flag is set
02:000014C8 67FE            	  1916:             beq.s *                       * Verify if Z flag is cleared
                            	  1917: 
02:000014CA 307C0100        	  1918:             move.l #$00000100,a0
02:000014CE 0C9812345678    	  1919:             cmpi.l #$12345678,(a0)+
02:000014D4 0C98A5A5A5A5    	  1920:             cmpi.l #$a5a5a5a5,(a0)+
02:000014DA 0C98A5A5A55A    	  1921:             cmpi.l #$a5a5a55a,(a0)+
02:000014E0 66FE            	  1922:             bne.s *                       * Verify if Z flag is set
                            	  1923: 
02:000014E2 4E75            	  1924:             rts
                            	  1925: 
                            	  1926: 
                            	  1927: *-----------------------------------------------------------
                            	  1928: *-----------------------------------------------------------
                            	  1929: * OPCODE : BSR
                            	  1930: *-----------------------------------------------------------
                            	  1931: *-----------------------------------------------------------
                            	  1932: 
                            	  1933: 
02:000014E4 223C11111111    	  1934: BSR_CLOSE1:     move.l #$11111111,d1
02:000014EA 4E75            	  1935:                 rts
                            	  1936: 
                            	  1937: 
                            	  1938: 
02:000014EC 61F6            	  1939: op_BSR:         bsr BSR_CLOSE1        * Negative 8-bit.s displacement
02:000014EE 612A            	  1940:                 bsr BSR_CLOSE2        * Positive 8-bit.s displacement
02:000014F0 6100EF20        	  1941:                 bsr.w BSR_FAR1          * Negative 16-bit.s displacement
02:000014F4 6100143E        	  1942:                 bsr.w BSR_FAR2          * Positive 16-bit.s displacement
                            	  1943: 
02:000014F8 0C8111111111    	  1944:                 cmpi.l #$11111111,d1
02:000014FE 66FE            	  1945:                 bne.s *
02:00001500 0C8222222222    	  1946:                 cmpi.l #$22222222,d2
02:00001506 66FE            	  1947:                 bne.s *
02:00001508 0C8333333333    	  1948:                 cmpi.l #$33333333,d3
02:0000150E 66FE            	  1949:                 bne.s *
02:00001510 0C8444444444    	  1950:                 cmpi.l #$44444444,d4
02:00001516 66FE            	  1951:                 bne.s *
                            	  1952: 
02:00001518 4E75            	  1953:                 rts
                            	  1954: 
                            	  1955: 
02:0000151A 243C22222222    	  1956: BSR_CLOSE2:     move.l #$22222222,d2
02:00001520 4E75            	  1957:                 rts
                            	  1958: 
                            	  1959: *-----------------------------------------------------------
                            	  1960: *-----------------------------------------------------------
                            	  1961: * OPCODE : op_CMP_I
                            	  1962: *-----------------------------------------------------------
                            	  1963: *-----------------------------------------------------------
                            	  1964: op_CMP_I:
                            	  1965: 
02:00001522 307C0100        	  1966:             move.l #$00000100,a0
02:00001526 20BC00000100    	  1967:             move.l #$00000100,(a0)
                            	  1968: 
                            	  1969: *     REGISTER - BYTE
02:0000152C 7080            	  1970:             move.l #$FFFFFF80,d0
02:0000152E 0C000080        	  1971:             cmpi.b #$80,d0
02:00001532 66FE            	  1972:             bne.s *                       * Check Z Flag  beq/bne
02:00001534 6BFE            	  1973:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001536 65FE            	  1974:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001538 69FE            	  1975:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1976: 
02:0000153A 223CFFFFF000    	  1977:             move.l #$FFFFF000,d1
02:00001540 4A01            	  1978:             cmpi.b #$00,d1
02:00001542 66FE            	  1979:             bne.s *                       * Check Z Flag  beq/bne
02:00001544 6BFE            	  1980:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001546 65FE            	  1981:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001548 69FE            	  1982:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1983: 
02:0000154A 7481D442        	  1984:             move.l #$FFFFFF02,d2
02:0000154E 0C0200FF        	  1985:             cmpi.b #$FF,d2
02:00001552 67FE            	  1986:             beq.s *                       * Check Z Flag  beq/bne
02:00001554 6BFE            	  1987:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001556 64FE            	  1988:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001558 69FE            	  1989:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1990: 
02:0000155A 263CFFFFFF7F    	  1991:             move.l #$FFFFFF7F,d3
02:00001560 0C0300FF        	  1992:             cmpi.b #$FF,d3
02:00001564 67FE            	  1993:             beq.s *                       * Check Z Flag  beq/bne
02:00001566 6AFE            	  1994:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001568 64FE            	  1995:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000156A 68FE            	  1996:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  1997: 
                            	  1998: 
                            	  1999: *     REGISTER - WORD
02:0000156C 203CFFFF8000    	  2000:             move.l #$FFFF8000,d0
02:00001572 0C408000        	  2001:             cmpi.w #$8000,d0
02:00001576 66FE            	  2002:             bne.s *                       * Check Z Flag  beq/bne
02:00001578 6BFE            	  2003:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000157A 65FE            	  2004:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000157C 69FE            	  2005:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2006: 
02:0000157E 223CFFF00000    	  2007:             move.l #$FFF00000,d1
02:00001584 4A41            	  2008:             cmpi.w #$0000,d1
02:00001586 66FE            	  2009:             bne.s *                       * Check Z Flag  beq/bne
02:00001588 6BFE            	  2010:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000158A 65FE            	  2011:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000158C 69FE            	  2012:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2013: 
02:0000158E 243CFFFF0002    	  2014:             move.l #$FFFF0002,d2
02:00001594 0C42FFFF        	  2015:             cmpi.w #$FFFF,d2
02:00001598 67FE            	  2016:             beq.s *                       * Check Z Flag  beq/bne
02:0000159A 6BFE            	  2017:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000159C 64FE            	  2018:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000159E 69FE            	  2019:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2020: 
02:000015A0 263CFFFF7FFF    	  2021:             move.l #$FFFF7FFF,d3
02:000015A6 0C43FFFF        	  2022:             cmpi.w #$FFFF,d3
02:000015AA 67FE            	  2023:             beq.s *                       * Check Z Flag  beq/bne
02:000015AC 6AFE            	  2024:             bpl.s *                       * Check N Flag  bmi/bpl
02:000015AE 64FE            	  2025:             bcc.s *                       * Check C Flag  bcc/bcs
02:000015B0 68FE            	  2026:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2027: 
                            	  2028: *     REGISTER - LONG
02:000015B2 203C80000000    	  2029:             move.l #$80000000,d0
02:000015B8 0C8080000000    	  2030:             cmpi.l #$80000000,d0
02:000015BE 66FE            	  2031:             bne.s *                       * Check Z Flag  beq/bne
02:000015C0 6BFE            	  2032:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015C2 65FE            	  2033:             bcs.s *                       * Check C Flag  bcc/bcs
02:000015C4 69FE            	  2034:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2035: 
02:000015C6 7200            	  2036:             moveq  #$00000000,d1
02:000015C8 4A81            	  2037:             cmpi.l #$00000000,d1
02:000015CA 66FE            	  2038:             bne.s *                       * Check Z Flag  beq/bne
02:000015CC 6BFE            	  2039:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015CE 65FE            	  2040:             bcs.s *                       * Check C Flag  bcc/bcs
02:000015D0 69FE            	  2041:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2042: 
02:000015D2 7402            	  2043:             moveq  #$00000002,d2
02:000015D4 0C82FFFFFFFF    	  2044:             cmpi.l #$FFFFFFFF,d2
02:000015DA 67FE            	  2045:             beq.s *                       * Check Z Flag  beq/bne
02:000015DC 6BFE            	  2046:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015DE 64FE            	  2047:             bcc.s *                       * Check C Flag  bcc/bcs
02:000015E0 69FE            	  2048:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2049: 
02:000015E2 263C7FFFFFFF    	  2050:             move.l #$7FFFFFFF,d3
02:000015E8 0C83FFFFFFFF    	  2051:             cmpi.l #$FFFFFFFF,d3
02:000015EE 67FE            	  2052:             beq.s *                       * Check Z Flag  beq/bne
02:000015F0 6AFE            	  2053:             bpl.s *                       * Check N Flag  bmi/bpl
02:000015F2 64FE            	  2054:             bcc.s *                       * Check C Flag  bcc/bcs
02:000015F4 68FE            	  2055:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2056: 
                            	  2057: 
                            	  2058: 
                            	  2059: 
                            	  2060: *     EA=x(An,Dn) - BYTE
02:000015F6 307C0100        	  2061:             move.l #$00000100,a0
02:000015FA 7E04            	  2062:             moveq  #$00000004,d7
                            	  2063: 
02:000015FC 21BCFFFFFF80700C	  2064:             move.l #$FFFFFF80,12(a0,d7)
02:00001604 21BCFFFFFF80700C	  2065:             move.l #$FFFFFF80,12(a0,d7)
02:0000160C 0C300080700F    	  2066:             cmpi.b #$80,15(a0,d7)
02:00001612 66FE            	  2067:             bne.s *                       * Check Z Flag  beq/bne
02:00001614 6BFE            	  2068:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001616 65FE            	  2069:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001618 69FE            	  2070:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2071: 
02:0000161A 21BCFFFFF000700C	  2072:             move.l #$FFFFF000,12(a0,d7)
02:00001622 4A30700F        	  2073:             cmpi.b #$00,15(a0,d7)
02:00001626 66FE            	  2074:             bne.s *                       * Check Z Flag  beq/bne
02:00001628 6BFE            	  2075:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000162A 65FE            	  2076:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000162C 69FE            	  2077:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2078: 
02:0000162E 21BCFFFFFF02700C	  2079:             move.l #$FFFFFF02,12(a0,d7)
02:00001636 0C3000FF700F    	  2080:             cmpi.b #$FF,15(a0,d7)
02:0000163C 67FE            	  2081:             beq.s *                       * Check Z Flag  beq/bne
02:0000163E 6BFE            	  2082:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001640 64FE            	  2083:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001642 69FE            	  2084:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2085: 
02:00001644 21BCFFFFFF7F700C	  2086:             move.l #$FFFFFF7F,12(a0,d7)
02:0000164C 0C3000FF700F    	  2087:             cmpi.b #$FF,15(a0,d7)
02:00001652 67FE            	  2088:             beq.s *                       * Check Z Flag  beq/bne
02:00001654 6AFE            	  2089:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001656 64FE            	  2090:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001658 68FE            	  2091:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2092: 
                            	  2093: 
                            	  2094: *     EA=x(An,Dn) - WORD
02:0000165A 21BCFFFF8000700C	  2095:             move.l #$FFFF8000,12(a0,d7)
02:00001662 0C708000700E    	  2096:             cmpi.w #$8000,14(a0,d7)
02:00001668 66FE            	  2097:             bne.s *                       * Check Z Flag  beq/bne
02:0000166A 6BFE            	  2098:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000166C 65FE            	  2099:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000166E 69FE            	  2100:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2101: 
02:00001670 21BCFFF00000700C	  2102:             move.l #$FFF00000,12(a0,d7)
02:00001678 4A70700E        	  2103:             cmpi.w #$0000,14(a0,d7)
02:0000167C 66FE            	  2104:             bne.s *                       * Check Z Flag  beq/bne
02:0000167E 6BFE            	  2105:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001680 65FE            	  2106:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001682 69FE            	  2107:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2108: 
02:00001684 21BCFFFF0002700C	  2109:             move.l #$FFFF0002,12(a0,d7)
02:0000168C 0C70FFFF700E    	  2110:             cmpi.w #$FFFF,14(a0,d7)
02:00001692 67FE            	  2111:             beq.s *                       * Check Z Flag  beq/bne
02:00001694 6BFE            	  2112:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001696 64FE            	  2113:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001698 69FE            	  2114:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2115: 
02:0000169A 21BCFFFF7FFF700C	  2116:             move.l #$FFFF7FFF,12(a0,d7)
02:000016A2 0C70FFFF700E    	  2117:             cmpi.w #$FFFF,14(a0,d7)
02:000016A8 67FE            	  2118:             beq.s *                       * Check Z Flag  beq/bne
02:000016AA 6AFE            	  2119:             bpl.s *                       * Check N Flag  bmi/bpl
02:000016AC 64FE            	  2120:             bcc.s *                       * Check C Flag  bcc/bcs
02:000016AE 68FE            	  2121:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2122: 
                            	  2123: *     EA=x(An,Dn) - LONG
02:000016B0 21BC80000000700C	  2124:             move.l #$80000000,12(a0,d7)
02:000016B8 0CB080000000700C	  2125:             cmpi.l #$80000000,12(a0,d7)
02:000016C0 66FE            	  2126:             bne.s *                       * Check Z Flag  beq/bne
02:000016C2 6BFE            	  2127:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016C4 65FE            	  2128:             bcs.s *                       * Check C Flag  bcc/bcs
02:000016C6 69FE            	  2129:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2130: 
02:000016C8 42B0700C        	  2131:             move.l #$00000000,12(a0,d7)
02:000016CC 4AB0700C        	  2132:             cmpi.l #$00000000,12(a0,d7)
02:000016D0 66FE            	  2133:             bne.s *                       * Check Z Flag  beq/bne
02:000016D2 6BFE            	  2134:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016D4 65FE            	  2135:             bcs.s *                       * Check C Flag  bcc/bcs
02:000016D6 69FE            	  2136:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2137: 
02:000016D8 21BC00000002700C	  2138:             move.l #$00000002,12(a0,d7)
02:000016E0 0CB0FFFFFFFF700C	  2139:             cmpi.l #$FFFFFFFF,12(a0,d7)
02:000016E8 67FE            	  2140:             beq.s *                       * Check Z Flag  beq/bne
02:000016EA 6BFE            	  2141:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016EC 64FE            	  2142:             bcc.s *                       * Check C Flag  bcc/bcs
02:000016EE 69FE            	  2143:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2144: 
02:000016F0 21BC7FFFFFFF700C	  2145:             move.l #$7FFFFFFF,12(a0,d7)
02:000016F8 0CB0FFFFFFFF700C	  2146:             cmpi.l #$FFFFFFFF,12(a0,d7)
02:00001700 67FE            	  2147:             beq.s *                       * Check Z Flag  beq/bne
02:00001702 6AFE            	  2148:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001704 64FE            	  2149:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001706 68FE            	  2150:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2151: 
                            	  2152: 
                            	  2153: 
                            	  2154: 
02:00001708 4E75            	  2155:             rts
                            	  2156: 
                            	  2157: 
                            	  2158: 
                            	  2159: *-----------------------------------------------------------
                            	  2160: *-----------------------------------------------------------
                            	  2161: * OPCODE : ADD_I
                            	  2162: *-----------------------------------------------------------
                            	  2163: *-----------------------------------------------------------
                            	  2164: op_ADD_I:
                            	  2165: 
                            	  2166: *     EA = Dn  - Byte
02:0000170A 203C12345678    	  2167:             move.l #$12345678,d0      * populate test data
02:00001710 06000000        	  2168:             addi.b #0,d0
02:00001714 67FE            	  2169:             beq.s *                       * Check Z Flag  beq/bne
02:00001716 6BFE            	  2170:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001718 65FE            	  2171:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000171A 69FE            	  2172:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000171C 06000010        	  2173:             addi.b #$10,d0
02:00001720 67FE            	  2174:             beq.s *                       * Check Z Flag  beq/bne
02:00001722 6AFE            	  2175:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001724 65FE            	  2176:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001726 68FE            	  2177:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001728 060000A5        	  2178:             addi.b #$A5,d0
02:0000172C 67FE            	  2179:             beq.s *                       * Check Z Flag  beq/bne
02:0000172E 6BFE            	  2180:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001730 64FE            	  2181:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001732 68FE            	  2182:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001734 0C00002D        	  2183:             cmpi.b #$2D,d0
02:00001738 66FE            	  2184:             bne.s *                       * Check Z Flag  beq/bne
                            	  2185: 
                            	  2186: *     EA = Dn  - WORD
02:0000173A 203C12345678    	  2187:             move.l #$12345678,d0      * populate test data
02:00001740 06400000        	  2188:             addi.w #0,d0
02:00001744 67FE            	  2189:             beq.s *                       * Check Z Flag  beq/bne
02:00001746 6BFE            	  2190:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001748 65FE            	  2191:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000174A 69FE            	  2192:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000174C 06407000        	  2193:             addi.w #$7000,d0
02:00001750 67FE            	  2194:             beq.s *                       * Check Z Flag  beq/bne
02:00001752 6AFE            	  2195:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001754 65FE            	  2196:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001756 68FE            	  2197:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001758 0640A55A        	  2198:             addi.w #$A55A,d0
02:0000175C 67FE            	  2199:             beq.s *                       * Check Z Flag  beq/bne
02:0000175E 6BFE            	  2200:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001760 64FE            	  2201:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001762 68FE            	  2202:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001764 0C406BD2        	  2203:             cmpi.w #$6BD2,d0
02:00001768 66FE            	  2204:             bne.s *                       * Check Z Flag  beq/bne
                            	  2205: 
                            	  2206: *     EA = Dn  - LONG
02:0000176A 203C12345678    	  2207:             move.l #$12345678,d0      * populate test data
02:00001770 068000000000    	  2208:             addi.l #0,d0
02:00001776 67FE            	  2209:             beq.s *                       * Check Z Flag  beq/bne
02:00001778 6BFE            	  2210:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000177A 65FE            	  2211:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000177C 69FE            	  2212:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000177E 0680F0000000    	  2213:             addi.l #$F0000000,d0
02:00001784 67FE            	  2214:             beq.s *                       * Check Z Flag  beq/bne
02:00001786 6BFE            	  2215:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001788 64FE            	  2216:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000178A 69FE            	  2217:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000178C 0680855AA55A    	  2218:             addi.l #$855AA55A,d0
02:00001792 67FE            	  2219:             beq.s *                       * Check Z Flag  beq/bne
02:00001794 6AFE            	  2220:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001796 65FE            	  2221:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001798 69FE            	  2222:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000179A 0680A0000000    	  2223:             addi.l #$A0000000,d0
02:000017A0 68FE            	  2224:             bvc.s *                       * Check V Flag  bvc/bvs
02:000017A2 0C80278EFBD2    	  2225:             cmpi.l #$278EFBD2,d0
02:000017A8 66FE            	  2226:             bne.s *                       * Check Z Flag  beq/bne
                            	  2227: 
                            	  2228: 
                            	  2229: 
                            	  2230: *     EA = x.L  - Byte
02:000017AA 207C0000F100    	  2231:             move.l #$F100,a0      * populate test data
02:000017B0 20BC12345678    	  2232:             move.l #$12345678,(a0)     * populate test data
02:000017B6 063900000000F103	  2233:             addi.b #0,$F103
02:000017BE 67FE            	  2234:             beq.s *                       * Check Z Flag  beq/bne
02:000017C0 6BFE            	  2235:             bmi.s *                       * Check N Flag  bmi/bpl
02:000017C2 65FE            	  2236:             bcs.s *                       * Check C Flag  bcc/bcs
02:000017C4 69FE            	  2237:             bvs.s *                       * Check V Flag  bvc/bvs
02:000017C6 063900100000F103	  2238:             addi.b #$10,$F103
02:000017CE 67FE            	  2239:             beq.s *                       * Check Z Flag  beq/bne
02:000017D0 6AFE            	  2240:             bpl.s *                       * Check N Flag  bmi/bpl
02:000017D2 65FE            	  2241:             bcs.s *                       * Check C Flag  bcc/bcs
02:000017D4 68FE            	  2242:             bvc.s *                       * Check V Flag  bvc/bvs
02:000017D6 063900A50000F103	  2243:             addi.b #$A5,$F103
02:000017DE 67FE            	  2244:             beq.s *                       * Check Z Flag  beq/bne
02:000017E0 6BFE            	  2245:             bmi.s *                       * Check N Flag  bmi/bpl
02:000017E2 64FE            	  2246:             bcc.s *                       * Check C Flag  bcc/bcs
02:000017E4 68FE            	  2247:             bvc.s *                       * Check V Flag  bvc/bvs
02:000017E6 0C39002D0000F103	  2248:             cmpi.b #$2D,$F103
02:000017EE 66FE            	  2249:             bne.s *                       * Check Z Flag  beq/bne
                            	  2250: 
                            	  2251: *     EA = x.L- WORD
02:000017F0 207C0000F100    	  2252:             move.l #$F100,a0      * populate test data
02:000017F6 20BC12345678    	  2253:             move.l #$12345678,(a0)     * populate test data
02:000017FC 067900000000F100	  2254:             addi.w #0,$F100
02:00001804 67FE            	  2255:             beq.s *                       * Check Z Flag  beq/bne
02:00001806 6BFE            	  2256:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001808 65FE            	  2257:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000180A 69FE            	  2258:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000180C 067970000000F100	  2259:             addi.w #$7000,$F100
02:00001814 67FE            	  2260:             beq.s *                       * Check Z Flag  beq/bne
02:00001816 6AFE            	  2261:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001818 65FE            	  2262:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000181A 68FE            	  2263:             bvc.s *                       * Check V Flag  bvc/bvs
02:0000181C 0679A55A0000F100	  2264:             addi.w #$A55A,$F100
02:00001824 67FE            	  2265:             beq.s *                       * Check Z Flag  beq/bne
02:00001826 6BFE            	  2266:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001828 64FE            	  2267:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000182A 68FE            	  2268:             bvc.s *                       * Check V Flag  bvc/bvs
02:0000182C 0C79278E0000F100	  2269:             cmpi.w #$278E,$F100
02:00001834 66FE            	  2270:             bne.s *                       * Check Z Flag  beq/bne
                            	  2271: 
                            	  2272: *     EA = x.L- LONG
02:00001836 23FC123456780000	  2273:             move.l #$12345678,$F100  * populate test data
02:0000183E F100
02:00001840 06B9000000000000	  2274:             addi.l #0,$F100
02:00001848 F100
02:0000184A 67FE            	  2275:             beq.s *                       * Check Z Flag  beq/bne
02:0000184C 6BFE            	  2276:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000184E 65FE            	  2277:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001850 69FE            	  2278:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001852 06B9F00000000000	  2279:             addi.l #$F0000000,$F100
02:0000185A F100
02:0000185C 67FE            	  2280:             beq.s *                       * Check Z Flag  beq/bne
02:0000185E 6BFE            	  2281:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001860 64FE            	  2282:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001862 69FE            	  2283:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001864 06B9855AA55A0000	  2284:             addi.l #$855AA55A,$F100
02:0000186C F100
02:0000186E 67FE            	  2285:             beq.s *                       * Check Z Flag  beq/bne
02:00001870 6AFE            	  2286:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001872 65FE            	  2287:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001874 69FE            	  2288:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001876 06B9A00000000000	  2289:             addi.l #$A0000000,$F100
02:0000187E F100
02:00001880 68FE            	  2290:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001882 0CB9278EFBD20000	  2291:             cmpi.l #$278EFBD2,$F100
02:0000188A F100
02:0000188C 66FE            	  2292:             bne.s *                       * Check Z Flag  beq/bne
                            	  2293: 
02:0000188E 4E75            	  2294:             rts
                            	  2295: 
                            	  2296: 
                            	  2297: *-----------------------------------------------------------
                            	  2298: *-----------------------------------------------------------
                            	  2299: * OPCODE : SUB_I
                            	  2300: *-----------------------------------------------------------
                            	  2301: *-----------------------------------------------------------
                            	  2302: op_SUB_I:
                            	  2303: 
                            	  2304: *     EA = Dn  - Byte
02:00001890 203C12345678    	  2305:             move.l #$12345678,d0      * populate test data
02:00001896 04000000        	  2306:             subi.b #0,d0
02:0000189A 67FE            	  2307:             beq.s *                       * Check Z Flag  beq/bne
02:0000189C 6BFE            	  2308:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000189E 65FE            	  2309:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018A0 69FE            	  2310:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018A2 04000010        	  2311:             subi.b #$10,d0
02:000018A6 67FE            	  2312:             beq.s *                       * Check Z Flag  beq/bne
02:000018A8 6BFE            	  2313:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018AA 65FE            	  2314:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018AC 69FE            	  2315:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018AE 040000A5        	  2316:             subi.b #$A5,d0
02:000018B2 67FE            	  2317:             beq.s *                       * Check Z Flag  beq/bne
02:000018B4 6AFE            	  2318:             bpl.s *                       * Check N Flag  bmi/bpl
02:000018B6 64FE            	  2319:             bcc.s *                       * Check C Flag  bcc/bcs
02:000018B8 68FE            	  2320:             bvc.s *                       * Check V Flag  bvc/bvs
02:000018BA 0C0000C3        	  2321:             cmpi.b #$C3,d0
02:000018BE 66FE            	  2322:             bne.s *                       * Check Z Flag  beq/bne
                            	  2323: 
                            	  2324: *     EA = Dn  - WORD
02:000018C0 203C12345678    	  2325:             move.l #$12345678,d0      * populate test data
02:000018C6 04400000        	  2326:             subi.w #0,d0
02:000018CA 67FE            	  2327:             beq.s *                       * Check Z Flag  beq/bne
02:000018CC 6BFE            	  2328:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018CE 65FE            	  2329:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018D0 69FE            	  2330:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018D2 04407000        	  2331:             subi.w #$7000,d0
02:000018D6 67FE            	  2332:             beq.s *                       * Check Z Flag  beq/bne
02:000018D8 6AFE            	  2333:             bpl.s *                       * Check N Flag  bmi/bpl
02:000018DA 64FE            	  2334:             bcc.s *                       * Check C Flag  bcc/bcs
02:000018DC 69FE            	  2335:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018DE 0440A55A        	  2336:             subi.w #$A55A,d0
02:000018E2 67FE            	  2337:             beq.s *                       * Check Z Flag  beq/bne
02:000018E4 6BFE            	  2338:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018E6 65FE            	  2339:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018E8 69FE            	  2340:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018EA 0C40411E        	  2341:             cmpi.w #$411E,d0
02:000018EE 66FE            	  2342:             bne.s *                       * Check Z Flag  beq/bne
                            	  2343: 
                            	  2344: *     EA = Dn  - LONG
02:000018F0 203C12345678    	  2345:             move.l #$12345678,d0      * populate test data
02:000018F6 048000000000    	  2346:             subi.l #0,d0
02:000018FC 67FE            	  2347:             beq.s *                       * Check Z Flag  beq/bne
02:000018FE 6BFE            	  2348:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001900 65FE            	  2349:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001902 69FE            	  2350:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001904 0480F0000000    	  2351:             subi.l #$F0000000,d0
02:0000190A 67FE            	  2352:             beq.s *                       * Check Z Flag  beq/bne
02:0000190C 6BFE            	  2353:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000190E 64FE            	  2354:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001910 69FE            	  2355:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001912 0480855AA55A    	  2356:             subi.l #$855AA55A,d0
02:00001918 67FE            	  2357:             beq.s *                       * Check Z Flag  beq/bne
02:0000191A 6AFE            	  2358:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000191C 64FE            	  2359:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000191E 68FE            	  2360:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001920 0480A0000000    	  2361:             subi.l #$A0000000,d0
02:00001926 69FE            	  2362:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001928 0C80FCD9B11E    	  2363:             cmpi.l #$FCD9B11E,d0
02:0000192E 66FE            	  2364:             bne.s *                       * Check Z Flag  beq/bne
                            	  2365: 
                            	  2366: 
                            	  2367: 
                            	  2368: *     EA = x.L  - Byte
02:00001930 207C0000F100    	  2369:             move.l #$F100,a0      * populate test data
02:00001936 20BC12345678    	  2370:             move.l #$12345678,(a0)     * populate test data
02:0000193C 043900000000F103	  2371:             subi.b #0,$F103
02:00001944 67FE            	  2372:             beq.s *                       * Check Z Flag  beq/bne
02:00001946 6BFE            	  2373:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001948 65FE            	  2374:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000194A 69FE            	  2375:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000194C 043900100000F103	  2376:             subi.b #$10,$F103
02:00001954 67FE            	  2377:             beq.s *                       * Check Z Flag  beq/bne
02:00001956 6BFE            	  2378:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001958 65FE            	  2379:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000195A 69FE            	  2380:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000195C 043900A50000F103	  2381:             subi.b #$A5,$F103
02:00001964 67FE            	  2382:             beq.s *                       * Check Z Flag  beq/bne
02:00001966 6AFE            	  2383:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001968 64FE            	  2384:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000196A 68FE            	  2385:             bvc.s *                       * Check V Flag  bvc/bvs
02:0000196C 0C3900C30000F103	  2386:             cmpi.b #$C3,$F103
02:00001974 66FE            	  2387:             bne.s *                       * Check Z Flag  beq/bne
                            	  2388: 
                            	  2389: *     EA = x.L- WORD
02:00001976 207C0000F100    	  2390:             move.l #$F100,a0      * populate test data
02:0000197C 20BC12345678    	  2391:             move.l #$12345678,(a0)     * populate test data
02:00001982 047900000000F100	  2392:             subi.w #0,$F100
02:0000198A 67FE            	  2393:             beq.s *                       * Check Z Flag  beq/bne
02:0000198C 6BFE            	  2394:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000198E 65FE            	  2395:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001990 69FE            	  2396:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001992 047970000000F100	  2397:             subi.w #$7000,$F100
02:0000199A 67FE            	  2398:             beq.s *                       * Check Z Flag  beq/bne
02:0000199C 6AFE            	  2399:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000199E 64FE            	  2400:             bcc.s *                       * Check C Flag  bcc/bcs
02:000019A0 69FE            	  2401:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019A2 0479A55A0000F100	  2402:             subi.w #$A55A,$F100
02:000019AA 67FE            	  2403:             beq.s *                       * Check Z Flag  beq/bne
02:000019AC 6AFE            	  2404:             bpl.s *                       * Check N Flag  bmi/bpl
02:000019AE 64FE            	  2405:             bcc.s *                       * Check C Flag  bcc/bcs
02:000019B0 69FE            	  2406:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019B2 0C79FCDA0000F100	  2407:             cmpi.w #$FCDA,$F100
02:000019BA 66FE            	  2408:             bne.s *                       * Check Z Flag  beq/bne
                            	  2409: 
                            	  2410: *     EA = x.L- LONG
02:000019BC 23FC123456780000	  2411:             move.l #$12345678,$F100  * populate test data
02:000019C4 F100
02:000019C6 04B9000000000000	  2412:             subi.l #0,$F100
02:000019CE F100
02:000019D0 67FE            	  2413:             beq.s *                       * Check Z Flag  beq/bne
02:000019D2 6BFE            	  2414:             bmi.s *                       * Check N Flag  bmi/bpl
02:000019D4 65FE            	  2415:             bcs.s *                       * Check C Flag  bcc/bcs
02:000019D6 69FE            	  2416:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019D8 04B9F00000000000	  2417:             subi.l #$F0000000,$F100
02:000019E0 F100
02:000019E2 67FE            	  2418:             beq.s *                       * Check Z Flag  beq/bne
02:000019E4 6BFE            	  2419:             bmi.s *                       * Check N Flag  bmi/bpl
02:000019E6 64FE            	  2420:             bcc.s *                       * Check C Flag  bcc/bcs
02:000019E8 69FE            	  2421:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019EA 04B9855AA55A0000	  2422:             subi.l #$855AA55A,$F100
02:000019F2 F100
02:000019F4 67FE            	  2423:             beq.s *                       * Check Z Flag  beq/bne
02:000019F6 6AFE            	  2424:             bpl.s *                       * Check N Flag  bmi/bpl
02:000019F8 64FE            	  2425:             bcc.s *                       * Check C Flag  bcc/bcs
02:000019FA 68FE            	  2426:             bvc.s *                       * Check V Flag  bvc/bvs
02:000019FC 04B9A00000000000	  2427:             subi.l #$A0000000,$F100
02:00001A04 F100
02:00001A06 69FE            	  2428:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001A08 0CB9FCD9B11E0000	  2429:             cmpi.l #$FCD9B11E,$F100
02:00001A10 F100
02:00001A12 66FE            	  2430:             bne.s *                       * Check Z Flag  beq/bne
                            	  2431: 
02:00001A14 4E75            	  2432:             rts
                            	  2433: 
                            	  2434: 
                            	  2435: 
                            	  2436: *-----------------------------------------------------------
                            	  2437: *-----------------------------------------------------------
                            	  2438: * OPCODE : MOVE
                            	  2439: *-----------------------------------------------------------
                            	  2440: *-----------------------------------------------------------
                            	  2441: op_MOVE:
02:00001A16 203C11223344    	  2442:             move.l #$11223344,d0
02:00001A1C 223C55667788    	  2443:             move.l #$55667788,d1
02:00001A22 243C8899AABB    	  2444:             move.l #$8899aabb,d2
02:00001A28 263CCCDDEEFF    	  2445:             move.l #$ccddeeff,d3
02:00001A2E 7800            	  2446:             moveq  #$00000000,d4
02:00001A30 7A00            	  2447:             moveq  #$00000000,d5
02:00001A32 7C00            	  2448:             moveq  #$00000000,d6
02:00001A34 7E00            	  2449:             moveq  #$00000000,d7
02:00001A36 207C44332211    	  2450:             move.l #$44332211,a0
02:00001A3C 227C88776655    	  2451:             move.l #$88776655,a1
02:00001A42 247CBBAA9988    	  2452:             move.l #$bbaa9988,a2
02:00001A48 267CFFEEDDCC    	  2453:             move.l #$ffeeddcc,a3
                            	  2454: 
02:00001A4E 1800            	  2455:             move.b d0,d4              * BYTE - DATA REGISTER
02:00001A50 67FE            	  2456:             beq.s *                       * Check Z Flag  beq/bne
02:00001A52 6BFE            	  2457:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A54 0C8400000044    	  2458:             cmpi.l #$00000044,d4
02:00001A5A 66FE            	  2459:             bne.s *                       * Check Z Flag  beq/bne
                            	  2460: 
02:00001A5C 3A01            	  2461:             move.w d1,d5              * WORD - DATA REGISTER
02:00001A5E 67FE            	  2462:             beq.s *                       * Check Z Flag  beq/bne
02:00001A60 6BFE            	  2463:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A62 0C8500007788    	  2464:             cmpi.l #$00007788,d5
02:00001A68 66FE            	  2465:             bne.s *                       * Check Z Flag  beq/bne
                            	  2466: 
02:00001A6A 2C02            	  2467:             move.l d2,d6              * LONG - DATA REGISTER
02:00001A6C 67FE            	  2468:             beq.s *                       * Check Z Flag  beq/bne
02:00001A6E 6AFE            	  2469:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001A70 0C868899AABB    	  2470:             cmpi.l #$8899aabb,d6
02:00001A76 66FE            	  2471:             bne.s *                       * Check Z Flag  beq/bne
                            	  2472: 
02:00001A78 3A09            	  2473:             move.w a1,d5              * WORD - ADDRESS REGISTER
02:00001A7A 67FE            	  2474:             beq.s *                       * Check Z Flag  beq/bne
02:00001A7C 6BFE            	  2475:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A7E 0C8500006655    	  2476:             cmpi.l #$00006655,d5
02:00001A84 66FE            	  2477:             bne.s *                       * Check Z Flag  beq/bne
                            	  2478: 
02:00001A86 2C0A            	  2479:             move.l a2,d6              * LONG - ADDRESS REGISTER
02:00001A88 67FE            	  2480:             beq.s *                       * Check Z Flag  beq/bne
02:00001A8A 6AFE            	  2481:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001A8C 0C86BBAA9988    	  2482:             cmpi.l #$bbaa9988,d6
02:00001A92 66FE            	  2483:             bne.s *                       * Check Z Flag  beq/bne
                            	  2484: 
                            	  2485: 
02:00001A94 3842            	  2486:             movea.w d2,a4             * WORD - ADDRESS REGISTER as SOURCE ## MOVEA
02:00001A96 B9C2            	  2487:             cmpa.l d2,a4
02:00001A98 67FE            	  2488:             beq.s *                       * Check Z Flag  beq/bne ## comopare fails because A4 was sign extended
                            	  2489: 
02:00001A9A 2A41            	  2490:             movea.l d1,a5             * LONG - ADDRESS REGISTER as SOURCE ## MOVEA
02:00001A9C BBC1            	  2491:             cmpa.l d1,a5
02:00001A9E 66FE            	  2492:             bne.s *                       * Check Z Flag  beq/bne
                            	  2493: 
                            	  2494: 
                            	  2495: 
                            	  2496: *   Too mamy EA combinations to test,so we focus on a few of the more complicted EA's
                            	  2497: 
02:00001AA0 203C11223344    	  2498:             move.l #$11223344,d0
02:00001AA6 223C00010100    	  2499:             move.l #$00010100,d1
02:00001AAC 243C8899AABB    	  2500:             move.l #$8899aabb,d2
02:00001AB2 7601            	  2501:             moveq  #$00000001,d3
02:00001AB4 7800            	  2502:             moveq  #$00000000,d4
02:00001AB6 7A00            	  2503:             moveq  #$00000000,d5
02:00001AB8 7C00            	  2504:             moveq  #$00000000,d6
02:00001ABA 7E00            	  2505:             moveq  #$00000000,d7
02:00001ABC 91C8            	  2506:             move.l #$00000000,a0
02:00001ABE 227C00010100    	  2507:             move.l #$00010100,a1
                            	  2508: 
                            	  2509: *     x(An,AL) --> x.L
02:00001AC4 11BC005A9804    	  2510:             move.b #$5A,4(a0,a1.l)    * BYTE
02:00001ACA 47F09804        	  2511:             lea 4(a0,a1.l),a3
02:00001ACE 13F0980400010105	  2512:             move.b 4(a0,a1.l),$00010105
02:00001AD6 67FE            	  2513:             beq.s *                       * Check Z Flag  beq/bne
02:00001AD8 6BFE            	  2514:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001ADA 0C30005A9805    	  2515:             cmpi.b #$5A,5(a0,a1.l)
02:00001AE0 66FE            	  2516:             bne.s *                       * Check Z Flag  beq/bne
                            	  2517: 
                            	  2518: *     x.L --> n(An,Dw)
02:00001AE2 11B9000101051007	  2519: MOVE2:      move.b  $00010105,7(a0,d1.w)    * BYTE
02:00001AEA 67FE            	  2520:             beq.s *                       * Check Z Flag  beq/bne
02:00001AEC 6BFE            	  2521:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001AEE 0C30005A1007    	  2522:             cmpi.b #$5A,7(a0,d1.w)
02:00001AF4 66FE            	  2523:             bne.s *                       * Check Z Flag  beq/bne
                            	  2524: 
                            	  2525: *     x(PC,Ds) --> x.w
02:00001AF6 11FB30660100    	  2526:             move.b  MOVE1(pc,d3.w),$0100 * BYTE
02:00001AFC 67FE            	  2527:             beq.s *                       * Check Z Flag  beq/bne
02:00001AFE 6AFE            	  2528:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001B00 0C3900B900001AE3	  2529:             cmpi.b #$B9,1+MOVE2
02:00001B08 66FE            	  2530:             bne.s *                       * Check Z Flag  beq/bne
                            	  2531: 
                            	  2532: *     #x -->    n(An,AL)
02:00001B0A 11BC00781007    	  2533:             move.b  #$78,7(a0,d1.w)    * BYTE
02:00001B10 67FE            	  2534:             beq.s *                       * Check Z Flag  beq/bne
02:00001B12 6BFE            	  2535:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B14 0C3000781007    	  2536:             cmpi.b #$78,7(a0,d1.w)
02:00001B1A 66FE            	  2537:             bne.s *                       * Check Z Flag  beq/bne
                            	  2538: 
02:00001B1C 203C11223344    	  2539:             move.l #$11223344,d0
02:00001B22 223C00010100    	  2540:             move.l #$00010100,d1
02:00001B28 243C8899AABB    	  2541:             move.l #$8899aabb,d2
02:00001B2E 7602            	  2542:             moveq  #$00000002,d3
02:00001B30 7800            	  2543:             moveq  #$00000000,d4
02:00001B32 7A00            	  2544:             moveq  #$00000000,d5
02:00001B34 7C00            	  2545:             moveq  #$00000000,d6
02:00001B36 7E00            	  2546:             moveq  #$00000000,d7
02:00001B38 91C8            	  2547:             move.l #$00000000,a0
02:00001B3A 227C00010100    	  2548:             move.l #$00010100,a1
                            	  2549: 
                            	  2550: *     x(An,AL) --> x.L
02:00001B40 31BC5A5A9804    	  2551:             move.w #$5A5A,4(a0,a1.l)    * WORD
02:00001B46 49F09804        	  2552:             lea 4(a0,a1.l),a4
02:00001B4A 33F0980400010104	  2553:             move.w 4(a0,a1.l),$00010104
02:00001B52 67FE            	  2554:             beq.s *                       * Check Z Flag  beq/bne
02:00001B54 6BFE            	  2555:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B56 0C705A5A9804    	  2556:             cmpi.w #$5A5A,4(a0,a1.l)
02:00001B5C 66FE            	  2557:             bne.s *                       * Check Z Flag  beq/bne
                            	  2558: 
                            	  2559: *     x.L --> n(An,Dw)
02:00001B5E 31B9000101041006	  2560: MOVE1:      move.w  $00010104,6(a0,d1.w)    * WORD
02:00001B66 67FE            	  2561:             beq.s *                       * Check Z Flag  beq/bne
02:00001B68 6BFE            	  2562:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B6A 0C705A5A1006    	  2563:             cmpi.w #$5A5A,6(a0,d1.w)
02:00001B70 66FE            	  2564:             bne.s *                       * Check Z Flag  beq/bne
                            	  2565: 
                            	  2566: *     x(PC,Ds) --> x.w
02:00001B72 31FB30EA0100    	  2567:             move.w  MOVE1(pc,d3),$0100 * WORD
02:00001B78 67FE            	  2568:             beq.s *                       * Check Z Flag  beq/bne
02:00001B7A 6BFE            	  2569:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B7C 0C7967FE00001B66	  2570:             cmpi.w #$67FE,8+MOVE1
02:00001B84 66FE            	  2571:             bne.s *                       * Check Z Flag  beq/bne
                            	  2572: 
                            	  2573: *     #x -->    n(An,AL)
02:00001B86 31BC78781006    	  2574:             move.w  #$7878,6(a0,d1.w)    * WORD
02:00001B8C 67FE            	  2575:             beq.s *                       * Check Z Flag  beq/bne
02:00001B8E 6BFE            	  2576:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B90 0C7078781006    	  2577:             cmpi.w #$7878,6(a0,d1.w)
02:00001B96 66FE            	  2578:             bne.s *                       * Check Z Flag  beq/bne
                            	  2579: 
                            	  2580: * ---
                            	  2581: 
02:00001B98 203C11223344    	  2582:             move.l #$11223344,d0
02:00001B9E 223C00010100    	  2583:             move.l #$00010100,d1
02:00001BA4 243C8899AABB    	  2584:             move.l #$8899aabb,d2
02:00001BAA 7602            	  2585:             moveq  #$00000002,d3
02:00001BAC 7800            	  2586:             moveq  #$00000000,d4
02:00001BAE 7A00            	  2587:             moveq  #$00000000,d5
02:00001BB0 7C00            	  2588:             moveq  #$00000000,d6
02:00001BB2 7E00            	  2589:             moveq  #$00000000,d7
02:00001BB4 91C8            	  2590:             move.l #$00000000,a0
02:00001BB6 227C00010100    	  2591:             move.l #$00010100,a1
                            	  2592: 
                            	  2593: *     x(An,AL) --> x.L
02:00001BBC 21BC5A5A12349804	  2594:             move.l #$5A5A1234,4(a0,a1.l)    * LONG
02:00001BC4 49F09804        	  2595:             lea 4(a0,a1.l),a4
02:00001BC8 23F0980400010104	  2596:             move.l 4(a0,a1.l),$00010104
02:00001BD0 67FE            	  2597:             beq.s *                       * Check Z Flag  beq/bne
02:00001BD2 6BFE            	  2598:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001BD4 0CB05A5A12349804	  2599:             cmpi.l #$5A5A1234,4(a0,a1.l)
02:00001BDC 66FE            	  2600:             bne.s *                       * Check Z Flag  beq/bne
                            	  2601: 
                            	  2602: *     x.L --> n(An,Dw)
02:00001BDE 21B9000101041006	  2603: MOVE3:      move.l  $00010104,6(a0,d1.w)    * LONG
02:00001BE6 67FE            	  2604:             beq.s *                       * Check Z Flag  beq/bne
02:00001BE8 6BFE            	  2605:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001BEA 0CB05A5A12341006	  2606:             cmpi.l #$5A5A1234,6(a0,d1.w)
02:00001BF2 66FE            	  2607:             bne.s *                       * Check Z Flag  beq/bne
                            	  2608: 
                            	  2609: *     x(PC,Ds) --> x.w
02:00001BF4 21FB30E80100    	  2610:             move.l  MOVE3(pc,d3),$0100 * LONG
02:00001BFA 67FE            	  2611:             beq.s *                       * Check Z Flag  beq/bne
02:00001BFC 6BFE            	  2612:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001BFE 0CB967FE6BFE0000	  2613:             cmpi.l #$67FE6BFE,8+MOVE3
02:00001C06 1BE6
02:00001C08 66FE            	  2614:             bne.s *                       * Check Z Flag  beq/bne
                            	  2615: 
                            	  2616: *     #x -->    n(An,AL)
02:00001C0A 21BC787823231006	  2617:             move.l  #$78782323,6(a0,d1.w)    * LONG
02:00001C12 67FE            	  2618:             beq.s *                       * Check Z Flag  beq/bne
02:00001C14 6BFE            	  2619:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001C16 0CB0787823231006	  2620:             cmpi.l #$78782323,6(a0,d1.w)
02:00001C1E 66FE            	  2621:             bne.s *                       * Check Z Flag  beq/bne
                            	  2622: 
                            	  2623: 
02:00001C20 4E75            	  2624:          rts
                            	  2625: 
                            	  2626: 
                            	  2627: *-----------------------------------------------------------
                            	  2628: *-----------------------------------------------------------
                            	  2629: * OPCODE : MOVE_xxx_FLAGS
                            	  2630: *-----------------------------------------------------------
                            	  2631: *-----------------------------------------------------------
                            	  2632: op_MOVE_xxx_FLAGS:
                            	  2633: 
                            	  2634: *     Move_To_SR
                            	  2635: 
                            	  2636: *     Dn
                            	  2637: 
02:00001C22 303C2FFF        	  2638:             move.w #$2FFF,d0
02:00001C26 46C0            	  2639:             move.w d0,SR
02:00001C28 6AFE            	  2640:             bpl.s *           * branch if Z clear
02:00001C2A 66FE            	  2641:             bne.s *           * branch if N clear
02:00001C2C 68FE            	  2642:             bvc.s *           * branch if V clear
02:00001C2E 64FE            	  2643:             bcc.s *           * branch if C clear
02:00001C30 303C2F00        	  2644:             move.w #$2F00,d0
02:00001C34 44C0            	  2645:             move d0,CCR
02:00001C36 67FE            	  2646:             beq.s *           * branch if Z set
02:00001C38 6BFE            	  2647:             bmi.s *           * branch if N set
02:00001C3A 69FE            	  2648:             bvs.s *           * branch if V set
02:00001C3C 65FE            	  2649:             bcs.s *           * branch if C set
                            	  2650: 
02:00001C3E 303C2000        	  2651:             move.w #$2000,d0
02:00001C42 46C0            	  2652:             move.w d0,SR
02:00001C44 67FE            	  2653:             beq.s *           * branch if Z set
02:00001C46 6BFE            	  2654:             bmi.s *           * branch if N set
02:00001C48 69FE            	  2655:             bvs.s *           * branch if V set
02:00001C4A 65FE            	  2656:             bcs.s *           * branch if C set
                            	  2657: 
                            	  2658: *     (An)
02:00001C4C 307C0100        	  2659:             move.l #$00000100,a0
02:00001C50 30BC2FFF        	  2660:             move.w #$2FFF,(a0)
02:00001C54 46D0            	  2661:             move.w (a0),SR
02:00001C56 6AFE            	  2662:             bpl.s *           * branch if Z clear
02:00001C58 66FE            	  2663:             bne.s *           * branch if N clear
02:00001C5A 68FE            	  2664:             bvc.s *           * branch if V clear
02:00001C5C 64FE            	  2665:             bcc.s *           * branch if C clear
                            	  2666: 
02:00001C5E 30BC2000        	  2667:             move.w #$2000,(a0)
02:00001C62 46D0            	  2668:             move.w (a0),SR
02:00001C64 67FE            	  2669:             beq.s *           * branch if Z set
02:00001C66 6BFE            	  2670:             bmi.s *           * branch if N set
02:00001C68 69FE            	  2671:             bvs.s *           * branch if V set
02:00001C6A 65FE            	  2672:             bcs.s *           * branch if C set
                            	  2673: 
                            	  2674: *     (An)+
02:00001C6C 307C0100        	  2675:             move.l #$00000100,a0
02:00001C70 30BC2FFF        	  2676:             move.w #$2FFF,(a0)
02:00001C74 46D8            	  2677:             move.w (a0)+,SR
02:00001C76 6AFE            	  2678:             bpl.s *           * branch if Z clear
02:00001C78 66FE            	  2679:             bne.s *           * branch if N clear
02:00001C7A 68FE            	  2680:             bvc.s *           * branch if V clear
02:00001C7C 64FE            	  2681:             bcc.s *           * branch if C clear
                            	  2682: 
02:00001C7E 30BC2000        	  2683:             move.w #$2000,(a0)
02:00001C82 46D8            	  2684:             move.w (a0)+,SR
02:00001C84 67FE            	  2685:             beq.s *           * branch if Z set
02:00001C86 6BFE            	  2686:             bmi.s *           * branch if N set
02:00001C88 69FE            	  2687:             bvs.s *           * branch if V set
02:00001C8A 65FE            	  2688:             bcs.s *           * branch if C set
                            	  2689: 
                            	  2690: *     -(An)
02:00001C8C 307C0102        	  2691:             move.l #$00000102,a0
02:00001C90 30BC2FFF        	  2692:             move.w #$2FFF,(a0)
02:00001C94 46D8            	  2693:             move.w (a0)+,SR
02:00001C96 6AFE            	  2694:             bpl.s *           * branch if Z clear
02:00001C98 66FE            	  2695:             bne.s *           * branch if N clear
02:00001C9A 68FE            	  2696:             bvc.s *           * branch if V clear
02:00001C9C 64FE            	  2697:             bcc.s *           * branch if C clear
                            	  2698: 
02:00001C9E 30BC2000        	  2699:             move.w #$2000,(a0)
02:00001CA2 46D8            	  2700:             move.w (a0)+,SR
02:00001CA4 67FE            	  2701:             beq.s *           * branch if Z set
02:00001CA6 6BFE            	  2702:             bmi.s *           * branch if N set
02:00001CA8 69FE            	  2703:             bvs.s *           * branch if V set
02:00001CAA 65FE            	  2704:             bcs.s *           * branch if C set
                            	  2705: 
                            	  2706: *     n(An)
02:00001CAC 307C0102        	  2707:             move.l #$00000102,a0
02:00001CB0 317C2FFF0002    	  2708:             move.w #$2FFF,2(a0)
02:00001CB6 46E80002        	  2709:             move.w 2(a0),SR
02:00001CBA 6AFE            	  2710:             bpl.s *           * branch if Z clear
02:00001CBC 66FE            	  2711:             bne.s *           * branch if N clear
02:00001CBE 68FE            	  2712:             bvc.s *           * branch if V clear
02:00001CC0 64FE            	  2713:             bcc.s *           * branch if C clear
                            	  2714: 
02:00001CC2 317C20000002    	  2715:             move.w #$2000,2(a0)
02:00001CC8 46E80002        	  2716:             move.w 2(a0),SR
02:00001CCC 67FE            	  2717:             beq.s *           * branch if Z set
02:00001CCE 6BFE            	  2718:             bmi.s *           * branch if N set
02:00001CD0 69FE            	  2719:             bvs.s *           * branch if V set
02:00001CD2 65FE            	  2720:             bcs.s *           * branch if C set
                            	  2721: 
                            	  2722: *     n(An,Rn.l)
02:00001CD4 307C0100        	  2723:             move.l #$00000100,a0
02:00001CD8 7002            	  2724:             moveq  #$00000002,d0
02:00001CDA 31BC2FFF0802    	  2725:             move.w #$2FFF,2(a0,d0.l)
02:00001CE0 46F00802        	  2726:             move.w 2(a0,d0.l),SR
02:00001CE4 6AFE            	  2727:             bpl.s *           * branch if Z clear
02:00001CE6 66FE            	  2728:             bne.s *           * branch if N clear
02:00001CE8 68FE            	  2729:             bvc.s *           * branch if V clear
02:00001CEA 64FE            	  2730:             bcc.s *           * branch if C clear
                            	  2731: 
02:00001CEC 31BC20000802    	  2732:             move.w #$2000,2(a0,d0.l)
02:00001CF2 46F00802        	  2733:             move.w 2(a0,d0.l),SR
02:00001CF6 67FE            	  2734:             beq.s *           * branch if Z set
02:00001CF8 6BFE            	  2735:             bmi.s *           * branch if N set
02:00001CFA 69FE            	  2736:             bvs.s *           * branch if V set
02:00001CFC 65FE            	  2737:             bcs.s *           * branch if C set
                            	  2738: 
                            	  2739: *     x.W
02:00001CFE 31FC2FFF0100    	  2740:             move.w #$2FFF,$0100
02:00001D04 46F80100        	  2741:             move.w $0100,SR
02:00001D08 6AFE            	  2742:             bpl.s *           * branch if Z clear
02:00001D0A 66FE            	  2743:             bne.s *           * branch if N clear
02:00001D0C 68FE            	  2744:             bvc.s *           * branch if V clear
02:00001D0E 64FE            	  2745:             bcc.s *           * branch if C clear
                            	  2746: 
02:00001D10 31FC20000100    	  2747:             move.w #$2000,$0100
02:00001D16 46F80100        	  2748:             move.w $0100,SR
02:00001D1A 67FE            	  2749:             beq.s *           * branch if Z set
02:00001D1C 6BFE            	  2750:             bmi.s *           * branch if N set
02:00001D1E 69FE            	  2751:             bvs.s *           * branch if V set
02:00001D20 65FE            	  2752:             bcs.s *           * branch if C set
                            	  2753: 
                            	  2754: *     x.L
02:00001D22 33FC2FFF00010100	  2755:             move.w #$2FFF,$00010100
02:00001D2A 46F900010100    	  2756:             move.w $00010100,SR
02:00001D30 6AFE            	  2757:             bpl.s *           * branch if Z clear
02:00001D32 66FE            	  2758:             bne.s *           * branch if N clear
02:00001D34 68FE            	  2759:             bvc.s *           * branch if V clear
02:00001D36 64FE            	  2760:             bcc.s *           * branch if C clear
                            	  2761: 
02:00001D38 33FC200000010100	  2762: MOVE4:      move.w #$2000,$00010100
02:00001D40 46F900010100    	  2763:             move.w $00010100,SR
02:00001D46 67FE            	  2764:             beq.s *           * branch if Z set
02:00001D48 6BFE            	  2765:             bmi.s *           * branch if N set
02:00001D4A 69FE            	  2766:             bvs.s *           * branch if V set
02:00001D4C 65FE            	  2767:             bcs.s *           * branch if C set
                            	  2768: 
                            	  2769: *     x(PC)
02:00001D4E 46FAFFEA        	  2770:             move.w MOVE4+2(pc),SR
02:00001D52 67FE            	  2771:             beq.s *           * branch if Z set
02:00001D54 6BFE            	  2772:             bmi.s *           * branch if N set
02:00001D56 69FE            	  2773:             bvs.s *           * branch if V set
02:00001D58 65FE            	  2774:             bcs.s *           * branch if C set
                            	  2775: 
                            	  2776: *     x(PC,d0.l)
02:00001D5A 7000            	  2777:             moveq  #$00000000,d0
02:00001D5C 46FB08DC        	  2778:             move.w MOVE4+2(pc,d0.l),SR
02:00001D60 67FE            	  2779:             beq.s *           * branch if Z set
02:00001D62 6BFE            	  2780:             bmi.s *           * branch if N set
02:00001D64 69FE            	  2781:             bvs.s *           * branch if V set
02:00001D66 65FE            	  2782:             bcs.s *           * branch if C set
02:00001D68 44FB08D0        	  2783:             move MOVE4+2(pc,d0.l),CCR
02:00001D6C 67FE            	  2784:             beq.s *           * branch if Z set
02:00001D6E 6BFE            	  2785:             bmi.s *           * branch if N set
02:00001D70 69FE            	  2786:             bvs.s *           * branch if V set
02:00001D72 65FE            	  2787:             bcs.s *           * branch if C set
                            	  2788: 
                            	  2789: *     #x
02:00001D74 46FC2FFF        	  2790:             move.w #$2FFF,SR
02:00001D78 66FE            	  2791:             bne.s *           * branch if Z clear
02:00001D7A 6AFE            	  2792:             bpl.s *           * branch if N clear
02:00001D7C 68FE            	  2793:             bvc.s *           * branch if V clear
02:00001D7E 64FE            	  2794:             bcc.s *           * branch if C clear
                            	  2795: 
                            	  2796: 
                            	  2797: 
                            	  2798: *  MOVE_From_SR
                            	  2799: 
                            	  2800: 
                            	  2801: 
                            	  2802: *     Dn
02:00001D80 46FC275A        	  2803:             move.w #$275A,SR          * Initial value
02:00001D84 40C0            	  2804:             move.w SR,d0
02:00001D86 0C40271A        	  2805:             cmpi.w #$271A,d0
                            	  2806: * The following fails because sr bits are implemented and non-zero so later code works.           
                            	  2807: *            bne.s *                   * branch if Z set
                            	  2808: 
                            	  2809: *     (An)
02:00001D8A 307C0100        	  2810:             move.l #$00000100,a0
02:00001D8E 46FC275A        	  2811:             move.w #$275A,SR          * Initial value
02:00001D92 40D0            	  2812:             move.w SR,(a0)
02:00001D94 0C50275A        	  2813:             cmpi.w #$275A,(a0)
02:00001D98 66FE            	  2814:             bne.s *                   * branch if Z set
                            	  2815: 
                            	  2816: *     (An)+
02:00001D9A 307C0100        	  2817:             move.l #$00000100,a0
02:00001D9E 46FC257A        	  2818:             move.w #$257A,SR          * Initial value
02:00001DA2 40D8            	  2819:             move.w SR,(a0)+
02:00001DA4 307C0100        	  2820:             move.l #$00000100,a0
02:00001DA8 0C58257A        	  2821:             cmpi.w #$257A,(a0)+
02:00001DAC 66FE            	  2822:             bne.s *                   * branch if Z set
                            	  2823: 
                            	  2824: *     -(An)
02:00001DAE 307C0102        	  2825:             move.l #$00000102,a0
02:00001DB2 46FC2766        	  2826:             move.w #$2766,SR          * Initial value
02:00001DB6 40E0            	  2827:             move.w SR,-(a0)
02:00001DB8 307C0100        	  2828:             move.l #$00000100,a0
02:00001DBC 0C502766        	  2829:             cmpi.w #$2766,(a0)
02:00001DC0 66FE            	  2830:             bne.s *                   * branch if Z set
                            	  2831: 
                            	  2832: *     x(An)
02:00001DC2 307C0102        	  2833:             move.l #$00000102,a0
02:00001DC6 46FC2733        	  2834:             move.w #$2733,SR          * Initial value
02:00001DCA 40E80004        	  2835:             move.w SR,4(a0)
02:00001DCE 0C6827330004    	  2836:             cmpi.w #$2733,4(a0)
02:00001DD4 66FE            	  2837:             bne.s *                   * branch if Z set
                            	  2838: 
                            	  2839: *     x(An,rn)
02:00001DD6 307C0102        	  2840:             move.l #$00000102,a0
02:00001DDA 7004            	  2841:             moveq  #$00000004,d0
02:00001DDC 46FC275A        	  2842:             move.w #$275a,SR          * Initial value
02:00001DE0 40F00804        	  2843:             move.w SR,4(a0,d0.l)
02:00001DE4 0C70275A0804    	  2844:             cmpi.w #$275a,4(a0,d0.l)
02:00001DEA 66FE            	  2845:             bne.s *                   * branch if Z set
                            	  2846: 
                            	  2847: *     x.W
02:00001DEC 46FC2777        	  2848:             move.w #$2777,SR          * Initial value
02:00001DF0 40F80102        	  2849:             move.w SR,$0102
02:00001DF4 0C7827770102    	  2850:             cmpi.w #$2777,$0102
02:00001DFA 66FE            	  2851:             bne.s *                   * branch if Z set
                            	  2852: 
                            	  2853: *     x.L
02:00001DFC 46FC2777        	  2854:             move.w #$2777,SR          * Initial value
02:00001E00 40F900010102    	  2855:             move.w SR,$10102
02:00001E06 0C79277700010102	  2856:             cmpi.w #$2777,$10102
02:00001E0E 66FE            	  2857:             bne.s *                   * branch if Z set
                            	  2858: 
                            	  2859: 
                            	  2860: 
02:00001E10 46FC2700        	  2861:             move.w #$2700,SR          * Put flags back to initial value
                            	  2862: 
02:00001E14 4E75            	  2863:             rts
                            	  2864: 
                            	  2865: 
                            	  2866: *-----------------------------------------------------------
                            	  2867: *-----------------------------------------------------------
                            	  2868: * OPCODE : EXT
                            	  2869: *-----------------------------------------------------------
                            	  2870: *-----------------------------------------------------------
                            	  2871: op_EXT:
                            	  2872: 
02:00001E16 707F            	  2873:             move.l #$0000007F,d0
02:00001E18 223C00008FFF    	  2874:             move.l #$00008FFF,d1
02:00001E1E 7400            	  2875:             moveq  #$00000000,d2
                            	  2876: 
02:00001E20 4880            	  2877:             ext.w d0
02:00001E22 6BFE            	  2878:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001E24 67FE            	  2879:             beq.s *                   * Check Z Flag  beq/bne
02:00001E26 0C800000007F    	  2880:             cmpi.l #$0000007F,d0
02:00001E2C 66FE            	  2881:             bne.s *                   * branch if Z set
                            	  2882: 
02:00001E2E 48C1            	  2883:             ext.l d1
02:00001E30 6AFE            	  2884:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001E32 67FE            	  2885:             beq.s *                   * Check Z Flag  beq/bne
02:00001E34 0C81FFFF8FFF    	  2886:             cmpi.l #$FFFF8FFF,d1
02:00001E3A 66FE            	  2887:             bne.s *                   * branch if Z set
                            	  2888: 
02:00001E3C 48C2            	  2889:             ext.l d2
02:00001E3E 66FE            	  2890:             bne.s *                   * Check Z Flag  beq/bne
                            	  2891: 
                            	  2892: 
                            	  2893: 
02:00001E40 4E75            	  2894:             rts
                            	  2895: 
                            	  2896: 
                            	  2897: *-----------------------------------------------------------
                            	  2898: *-----------------------------------------------------------
                            	  2899: * OPCODE : SWAP
                            	  2900: *-----------------------------------------------------------
                            	  2901: *-----------------------------------------------------------
                            	  2902: op_SWAP:
                            	  2903: 
02:00001E42 203C12345678    	  2904:             move.l #$12345678,d0
                            	  2905: 
02:00001E48 4840            	  2906:             swap d0
02:00001E4A 6BFE            	  2907:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001E4C 67FE            	  2908:             beq.s *                   * Check Z Flag  beq/bne
02:00001E4E 0C8056781234    	  2909:             cmpi.l #$56781234,d0
02:00001E54 66FE            	  2910:             bne.s *                   * branch if Z set
                            	  2911: 
                            	  2912: 
                            	  2913: 
02:00001E56 4E75            	  2914:             rts
                            	  2915: 
                            	  2916: 
                            	  2917: *-----------------------------------------------------------
                            	  2918: *-----------------------------------------------------------
                            	  2919: * OPCODE : LEA_PEA
                            	  2920: *-----------------------------------------------------------
                            	  2921: *-----------------------------------------------------------
                            	  2922: op_LEAPEA:
                            	  2923: 
02:00001E58 207C00345678    	  2924:             move.l #$00345678,a0
02:00001E5E 7800            	  2925:             moveq  #$00000000,d4
                            	  2926: 
                            	  2927: *     (An)
02:00001E60 4DD0            	  2928:             lea (a0),a6
02:00001E62 200E            	  2929:             move.l a6,d0
02:00001E64 0C8000345678    	  2930:             cmpi.l #$00345678,d0
02:00001E6A 66FE            	  2931:             bne.s *                   * branch if Z set
02:00001E6C 4850            	  2932:             pea (a0)
02:00001E6E 0C9700345678    	  2933:             cmpi.l #$00345678,(a7)
02:00001E74 66FE            	  2934:             bne.s *                   * branch if Z set
                            	  2935:             * This was without a specifier which the assembler defaulted to .w
02:00001E76 588F            	  2936:             addq.l #4,a7            * Restore Stack Pointer
                            	  2937: 
                            	  2938: *     x(An)
02:00001E78 4DE80004        	  2939:             lea 4(a0),a6
02:00001E7C 200E            	  2940:             move.l a6,d0
02:00001E7E 0C800034567C    	  2941:             cmpi.l #$0034567C,d0
02:00001E84 66FE            	  2942:             bne.s *                   * branch if Z set
02:00001E86 48680004        	  2943:             pea 4(a0)
02:00001E8A 0C970034567C    	  2944:             cmpi.l #$0034567C,(a7)
02:00001E90 66FE            	  2945:             bne.s *                   * branch if Z set
                            	  2946:             * This was without a specifier which the assembler defaulted to .w
02:00001E92 588F            	  2947:             addq.l #4,a7            * Restore Stack Pointer
                            	  2948: 
                            	  2949: *     x(An,Dn.l)
02:00001E94 4DF04004        	  2950:             lea 4(a0,d4),a6
02:00001E98 200E            	  2951:             move.l a6,d0
02:00001E9A 0C800034567C    	  2952:             cmpi.l #$0034567C,d0
02:00001EA0 66FE            	  2953:             bne.s *                   * branch if Z set
02:00001EA2 48704804        	  2954:             pea 4(a0,d4.l)
02:00001EA6 0C970034567C    	  2955:             cmpi.l #$0034567C,(a7)
02:00001EAC 66FE            	  2956:             bne.s *                   * branch if Z set
                            	  2957:             * This was without a specifier which the assembler defaulted to .w
02:00001EAE 588F            	  2958:             addq.l #4,a7            * Restore Stack Pointer
                            	  2959: 
                            	  2960: *     x.W
02:00001EB0 4DF81234        	  2961:             lea $1234,a6
02:00001EB4 200E            	  2962:             move.l a6,d0
02:00001EB6 0C401234        	  2963:             cmpi.w #$1234,d0
02:00001EBA 66FE            	  2964:             bne.s *                   * branch if Z set
02:00001EBC 48781234        	  2965:             pea $1234
02:00001EC0 0C9700001234    	  2966:             cmpi.l #$00001234,(a7)
02:00001EC6 66FE            	  2967:             bne.s *                   * branch if Z set
                            	  2968:             * This was without a specifier which the assembler defaulted to .w
02:00001EC8 588F            	  2969:             addq.l #4,a7            * Restore Stack Pointer
                            	  2970: 
                            	  2971: *     x.L
02:00001ECA 4DF900345678    	  2972:             lea $00345678,a6
02:00001ED0 200E            	  2973:             move.l a6,d0
02:00001ED2 B08E            	  2974:             cmp.l a6,d0
02:00001ED4 66FE            	  2975:             bne.s *                   * branch if Z set
02:00001ED6 487900345678    	  2976:             pea $00345678
02:00001EDC 0C9700345678    	  2977:             cmpi.l #$00345678,(a7)
02:00001EE2 66FE            	  2978:             bne.s *                   * branch if Z set
                            	  2979:             * This was without a specifier which the assembler defaulted to .w
02:00001EE4 588F            	  2980:             addq.l #4,a7            * Restore Stack Pointer
                            	  2981: 
                            	  2982: *     x(PC)
02:00001EE6 4DFA0008        	  2983:             lea LEA1(pc),a6
02:00001EEA 200E            	  2984:             move.l a6,d0
02:00001EEC B08E            	  2985:             cmp.l a6,d0
02:00001EEE 66FE            	  2986:             bne.s *                   * branch if Z set
02:00001EF0 487AFFFE        	  2987: LEA1:       pea LEA1(pc)
02:00001EF4 0C970000241E    	  2988:             cmpi.l #$0000241E,(a7)
02:00001EFA 67FE            	  2989:             beq.s *                   * branch if Z clear
                            	  2990:             * This was without a specifier which the assembler defaulted to .w
02:00001EFC 588F            	  2991:             addq.l #4,a7              * Restore Stack Pointer
                            	  2992: 
                            	  2993: 
                            	  2994: 
                            	  2995: 
02:00001EFE 46FC2700        	  2996:             move.w #$2700,sr          * Put flags back to initial value
                            	  2997: 
02:00001F02 4E75            	  2998:             rts
                            	  2999:  	
                            	  3000: 
                            	  3001: 
                            	  3002: *-----------------------------------------------------------
                            	  3003: *-----------------------------------------------------------
                            	  3004: * OPCODE : LEA_TAS
                            	  3005: *-----------------------------------------------------------
                            	  3006: *-----------------------------------------------------------
                            	  3007: op_TAS:
                            	  3008: 
                            	  3009: *     Test just one addressing mode
                            	  3010: 
02:00001F04 307C0100        	  3011:             move.l #$00000100,a0
                            	  3012: 
                            	  3013: *     (An)
02:00001F08 4210            	  3014:             move.b #$00,(a0)
02:00001F0A 6BFE            	  3015:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F0C 66FE            	  3016:             bne.s *                   * Check Z Flag  beq/bne
02:00001F0E 4AD0            	  3017:             tas (a0)
02:00001F10 0C100080        	  3018:             cmpi.b #$80,(a0)
02:00001F14 66FE            	  3019:             bne.s *                   * branch if Z set
02:00001F16 10BC00F5        	  3020:             move.b #$F5,(a0)
02:00001F1A 4AD0            	  3021:             tas (a0)
02:00001F1C 6AFE            	  3022:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F1E 67FE            	  3023:             beq.s *                   * Check Z Flag  beq/bne
02:00001F20 4AD0            	  3024:             tas (a0)
02:00001F22 0C1000F5        	  3025:             cmpi.b #$F5,(a0)
02:00001F26 66FE            	  3026:             bne.s *                   * branch if Z set
                            	  3027: 
02:00001F28 4E75            	  3028:             rts
                            	  3029: 
                            	  3030: 
                            	  3031: *-----------------------------------------------------------
                            	  3032: *-----------------------------------------------------------
                            	  3033: * OPCODE : LEA_TST
                            	  3034: *-----------------------------------------------------------
                            	  3035: *-----------------------------------------------------------
                            	  3036: op_TST:
                            	  3037: 
                            	  3038: *     Test just one addressing mode
                            	  3039: 
02:00001F2A 307C0100        	  3040:             move.l #$00000100,a0
                            	  3041: 
                            	  3042: *     (An) - BYTE
02:00001F2E 4210            	  3043:             move.b #$00,(a0)
02:00001F30 4A10            	  3044:             tst.b (a0)
02:00001F32 6BFE            	  3045:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F34 66FE            	  3046:             bne.s *                   * Check Z Flag  beq/bne
02:00001F36 10BC00F5        	  3047:             move.b #$F5,(a0)
02:00001F3A 4A10            	  3048:             tst.b (a0)
02:00001F3C 6AFE            	  3049:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F3E 67FE            	  3050:             beq.s *                   * Check Z Flag  beq/bne
                            	  3051: 
                            	  3052: *     (An) - WORD
02:00001F40 4250            	  3053:             move.w #$0000,(a0)
02:00001F42 4A50            	  3054:             tst.w (a0)
02:00001F44 6BFE            	  3055:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F46 66FE            	  3056:             bne.s *                   * Check Z Flag  beq/bne
02:00001F48 30BCF567        	  3057:             move.w #$F567,(a0)
02:00001F4C 4A50            	  3058:             tst.w (a0)
02:00001F4E 6AFE            	  3059:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F50 67FE            	  3060:             beq.s *                   * Check Z Flag  beq/bne
                            	  3061: 
                            	  3062: *     (An) - LONG
02:00001F52 4290            	  3063:             move.l #$00000000,(a0)
02:00001F54 4A90            	  3064:             tst.l (a0)
02:00001F56 6BFE            	  3065:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F58 66FE            	  3066:             bne.s *                   * Check Z Flag  beq/bne
02:00001F5A 20BCF56789AB    	  3067:             move.l #$F56789ab,(a0)
02:00001F60 4A90            	  3068:             tst.l (a0)
02:00001F62 6AFE            	  3069:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F64 67FE            	  3070:             beq.s *                   * Check Z Flag  beq/bne
                            	  3071: 
                            	  3072: 
02:00001F66 4E75            	  3073:             rts
                            	  3074: 
                            	  3075: 
                            	  3076: *-----------------------------------------------------------
                            	  3077: *-----------------------------------------------------------
                            	  3078: * OPCODE : LINKS
                            	  3079: *-----------------------------------------------------------
                            	  3080: *-----------------------------------------------------------
                            	  3081: op_LINKS:
                            	  3082: 
02:00001F68 207C11223344    	  3083:             move.l #$11223344,a0
02:00001F6E 203C11223344    	  3084:             move.l #$11223344,d0
02:00001F74 4E500000        	  3085:             link a0,#$0
02:00001F78 0C9711223344    	  3086:             cmpi.l #$11223344,(a7)
                            	  3087: 
02:00001F7E 4E58            	  3088:             unlk a0
02:00001F80 B1C0            	  3089:             cmp.l d0,a0
02:00001F82 66FE            	  3090:             bne.s *                   * branch if Z set
                            	  3091: 
02:00001F84 4E75            	  3092:             rts
                            	  3093: 
                            	  3094: *-----------------------------------------------------------
                            	  3095: *-----------------------------------------------------------
                            	  3096: * OPCODE : MOVE_USP
                            	  3097: *-----------------------------------------------------------
                            	  3098: *-----------------------------------------------------------
                            	  3099: op_MOVE_USP:
                            	  3100: 
02:00001F86 207C11223344    	  3101:             move.l #$11223344,a0
02:00001F8C 4E60            	  3102:             move a0,USP
02:00001F8E 4E69            	  3103:             move USP,a1
02:00001F90 B3C8            	  3104:             cmp.l a0,a1
02:00001F92 66FE            	  3105:             bne.s *                   * branch if Z set
                            	  3106: 
02:00001F94 4E75            	  3107:             rts
                            	  3108: 
                            	  3109: 
                            	  3110: *-----------------------------------------------------------
                            	  3111: *-----------------------------------------------------------
                            	  3112: * OPCODE : CHK
                            	  3113: *-----------------------------------------------------------
                            	  3114: *-----------------------------------------------------------
                            	  3115: op_CHK:
02:00001F96 303C1122        	  3116:             move.w #$1122,d0
02:00001F9A 323C1122        	  3117:             move.w #$1122,d1
02:00001F9E 4380            	  3118:             chk d0,d1
                            	  3119: 
02:00001FA0 4E71            	  3120:             nop
02:00001FA2 4E71            	  3121:             nop
                            	  3122: 
02:00001FA4 323C1122        	  3123:             move.w #$1122,d1
02:00001FA8 43BC1122        	  3124:             chk #$1122,d1
                            	  3125: 
02:00001FAC 323C1122        	  3126:             move.w #$1122,d1
02:00001FB0 43BC007A        	  3127:             chk #00122,d1
02:00001FB4 BCBCEEEE0006    	  3128:             cmp.l #$EEEE0006,d6
02:00001FBA 66FE            	  3129:             bne.s *                   * branch if Z set
                            	  3130: 
02:00001FBC 303C1122        	  3131:             move.w #$1122,d0
02:00001FC0 323C8000        	  3132:             move.w #$8000,d1
02:00001FC4 4380            	  3133:             chk d0,d1
02:00001FC6 BCBCEEEE0006    	  3134:             cmp.l #$EEEE0006,d6
02:00001FCC 66FE            	  3135:             bne.s *                   * branch if Z set
                            	  3136: 
02:00001FCE 4E75            	  3137:             rts
                            	  3138: 
                            	  3139: 
                            	  3140: *-----------------------------------------------------------
                            	  3141: *-----------------------------------------------------------
                            	  3142: * OPCODE : NEGS
                            	  3143: *-----------------------------------------------------------
                            	  3144: *-----------------------------------------------------------
                            	  3145: op_NEGS:
                            	  3146: 
                            	  3147: *     NOT - BYTE
02:00001FD0 307C0100        	  3148:             move.l #$00000100,a0
02:00001FD4 7000            	  3149:             moveq  #$00000000,d0
02:00001FD6 4600            	  3150:             not.b d0
02:00001FD8 6AFE            	  3151:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001FDA 67FE            	  3152:             beq.s *                   * Check Z Flag  beq/bne
02:00001FDC 4600            	  3153:             not.b d0
02:00001FDE 6BFE            	  3154:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001FE0 66FE            	  3155:             bne.s *                   * Check Z Flag  beq/bne
02:00001FE2 4A00            	  3156:             cmpi.b #$00,d0
02:00001FE4 66FE            	  3157:             bne.s *                   * Check Z Flag  beq/bne
02:00001FE6 10BC0080        	  3158:             move.b #$80,(a0)
02:00001FEA 4610            	  3159:             not.b (a0)
02:00001FEC 6BFE            	  3160:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001FEE 67FE            	  3161:             beq.s *                   * Check Z Flag  beq/bne
02:00001FF0 4610            	  3162:             not.b (a0)
02:00001FF2 6AFE            	  3163:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001FF4 67FE            	  3164:             beq.s *                   * Check Z Flag  beq/bne
02:00001FF6 0C100080        	  3165:             cmpi.b #$80,(a0)
02:00001FFA 66FE            	  3166:             bne.s *                   * Check Z Flag  beq/bne
                            	  3167: 
                            	  3168: *     NOT - WORD
02:00001FFC 307C0100        	  3169:             move.l #$00000100,a0
02:00002000 7000            	  3170:             moveq  #$00000000,d0
02:00002002 4640            	  3171:             not.w d0
02:00002004 6AFE            	  3172:             bpl.s *                   * Check N Flag  bmi/bpl
02:00002006 67FE            	  3173:             beq.s *                   * Check Z Flag  beq/bne
02:00002008 4640            	  3174:             not.w d0
02:0000200A 6BFE            	  3175:             bmi.s *                   * Check N Flag  bmi/bpl
02:0000200C 66FE            	  3176:             bne.s *                   * Check Z Flag  beq/bne
02:0000200E 4A40            	  3177:             cmpi.w #$0000,d0
02:00002010 66FE            	  3178:             bne.s *                   * Check Z Flag  beq/bne
02:00002012 30BC5A5A        	  3179:             move.w #$5a5a,(a0)
02:00002016 4650            	  3180:             not.w (a0)
02:00002018 6AFE            	  3181:             bpl.s *                   * Check N Flag  bmi/bpl
02:0000201A 67FE            	  3182:             beq.s *                   * Check Z Flag  beq/bne
02:0000201C 4650            	  3183:             not.w (a0)
02:0000201E 6BFE            	  3184:             bmi.s *                   * Check N Flag  bmi/bpl
02:00002020 67FE            	  3185:             beq.s *                   * Check Z Flag  beq/bne
02:00002022 0C505A5A        	  3186:             cmpi.w #$5a5a,(a0)
02:00002026 66FE            	  3187:             bne.s *                   * Check Z Flag  beq/bne
                            	  3188: 
                            	  3189: *     NOT - LONG
02:00002028 307C0100        	  3190:             move.l #$00000100,a0
02:0000202C 7000            	  3191:             moveq  #$00000000,d0
02:0000202E 4680            	  3192:             not.l d0
02:00002030 6AFE            	  3193:             bpl.s *                   * Check N Flag  bmi/bpl
02:00002032 67FE            	  3194:             beq.s *                   * Check Z Flag  beq/bne
02:00002034 4680            	  3195:             not.l d0
02:00002036 6BFE            	  3196:             bmi.s *                   * Check N Flag  bmi/bpl
02:00002038 66FE            	  3197:             bne.s *                   * Check Z Flag  beq/bne
02:0000203A 4A80            	  3198:             cmpi.l #$00000000,d0
02:0000203C 66FE            	  3199:             bne.s *                   * Check Z Flag  beq/bne
02:0000203E 20BC5A5A1234    	  3200:             move.l #$5a5a1234,(a0)
02:00002044 4690            	  3201:             not.l (a0)
02:00002046 6AFE            	  3202:             bpl.s *                   * Check N Flag  bmi/bpl
02:00002048 67FE            	  3203:             beq.s *                   * Check Z Flag  beq/bne
02:0000204A 4690            	  3204:             not.l (a0)
02:0000204C 6BFE            	  3205:             bmi.s *                   * Check N Flag  bmi/bpl
02:0000204E 67FE            	  3206:             beq.s *                   * Check Z Flag  beq/bne
02:00002050 0C905A5A1234    	  3207:             cmpi.l #$5a5a1234,(a0)
02:00002056 66FE            	  3208:             bne.s *                   * Check Z Flag  beq/bne
                            	  3209: 
                            	  3210: * -----
                            	  3211: 
                            	  3212: *     NEG - BYTE
02:00002058 307C0100        	  3213:             move.l #$00000100,a0
02:0000205C 7000            	  3214:             moveq  #$00000000,d0
02:0000205E 7240D241        	  3215:             move.l #$00000080,d1
02:00002062 4400            	  3216:             neg.b d0
02:00002064 6BFE            	  3217:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002066 66FE            	  3218:             bne.s *                   * Check Z Flag  beq/bne 1
02:00002068 65FE            	  3219:             bcs.s *                   * Check C Flag  bcc/bcs 1
02:0000206A 69FE            	  3220:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000206C 4401            	  3221:             neg.b d1
02:0000206E 6AFE            	  3222:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002070 67FE            	  3223:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002072 64FE            	  3224:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002074 68FE            	  3225:             bvc.s *                   * Check V Flag  bvc/bvs 0
02:00002076 0C010080        	  3226:             cmpi.b #$80,d1
02:0000207A 66FE            	  3227:             bne.s *                   * Check Z Flag  beq/bne
02:0000207C 10BC007F        	  3228:             move.b #$7F,(a0)
02:00002080 4410            	  3229:             neg.b (a0)
02:00002082 6AFE            	  3230:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002084 67FE            	  3231:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002086 64FE            	  3232:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002088 69FE            	  3233:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000208A 10BC00F5        	  3234:             move.b #$F5,(a0)
02:0000208E 4410            	  3235:             neg.b (a0)
02:00002090 6BFE            	  3236:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002092 67FE            	  3237:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002094 64FE            	  3238:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002096 69FE            	  3239:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002098 0C10000B        	  3240:             cmpi.b #$0B,(a0)
02:0000209C 66FE            	  3241:             bne.s *                   * Check Z Flag  beq/bne
                            	  3242: 
                            	  3243: * -----
                            	  3244: 
                            	  3245: *     NEG - WORD
02:0000209E 307C0100        	  3246:             move.l #$00000100,a0
02:000020A2 7000            	  3247:             moveq  #$00000000,d0
02:000020A4 223C00008000    	  3248:             move.l #$00008000,d1
02:000020AA 4440            	  3249:             neg.w d0
02:000020AC 6BFE            	  3250:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000020AE 66FE            	  3251:             bne.s *                   * Check Z Flag  beq/bne 1
02:000020B0 65FE            	  3252:             bcs.s *                   * Check C Flag  bcc/bcs 1
02:000020B2 69FE            	  3253:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020B4 4441            	  3254:             neg.w d1
02:000020B6 6AFE            	  3255:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000020B8 67FE            	  3256:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020BA 64FE            	  3257:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020BC 68FE            	  3258:             bvc.s *                   * Check V Flag  bvc/bvs 0
02:000020BE 0C418000        	  3259:             cmpi.w #$8000,d1
02:000020C2 66FE            	  3260:             bne.s *                   * Check Z Flag  beq/bne
02:000020C4 30BC7FFF        	  3261:             move.w #$7FFF,(a0)
02:000020C8 4450            	  3262:             neg.w (a0)
02:000020CA 6AFE            	  3263:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000020CC 67FE            	  3264:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020CE 64FE            	  3265:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020D0 69FE            	  3266:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020D2 30BCF578        	  3267:             move.w #$F578,(a0)
02:000020D6 4450            	  3268:             neg.w (a0)
02:000020D8 6BFE            	  3269:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000020DA 67FE            	  3270:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020DC 64FE            	  3271:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020DE 69FE            	  3272:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020E0 0C500A88        	  3273:             cmpi.w #$0A88,(a0)
02:000020E4 66FE            	  3274:             bne.s *                   * Check Z Flag  beq/bne
                            	  3275: 
                            	  3276: * -----
                            	  3277: 
                            	  3278: *     NEG - LONG
02:000020E6 307C0100        	  3279:             move.l #$00000100,a0
02:000020EA 7000            	  3280:             moveq  #$00000000,d0
02:000020EC 223C80000000    	  3281:             move.l #$80000000,d1
02:000020F2 4480            	  3282:             neg.l d0
02:000020F4 6BFE            	  3283:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000020F6 66FE            	  3284:             bne.s *                   * Check Z Flag  beq/bne 1
02:000020F8 65FE            	  3285:             bcs.s *                   * Check C Flag  bcc/bcs 1
02:000020FA 69FE            	  3286:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020FC 4481            	  3287:             neg.l d1
02:000020FE 6AFE            	  3288:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002100 67FE            	  3289:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002102 64FE            	  3290:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002104 68FE            	  3291:             bvc.s *                   * Check V Flag  bvc/bvs 0
02:00002106 0C8180000000    	  3292:             cmpi.l #$80000000,d1
02:0000210C 66FE            	  3293:             bne.s *                   * Check Z Flag  beq/bne
02:0000210E 20BC7FFFFFFF    	  3294:             move.l #$7FFFFFFF,(a0)
02:00002114 4490            	  3295:             neg.l (a0)
02:00002116 6AFE            	  3296:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002118 67FE            	  3297:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000211A 64FE            	  3298:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000211C 69FE            	  3299:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000211E 20BCF5781234    	  3300:             move.l #$F5781234,(a0)
02:00002124 4490            	  3301:             neg.l (a0)
02:00002126 6BFE            	  3302:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002128 67FE            	  3303:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000212A 64FE            	  3304:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000212C 69FE            	  3305:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000212E 0C900A87EDCC    	  3306:             cmpi.l #$0A87EDCC,(a0)
02:00002134 66FE            	  3307:             bne.s *                   * Check Z Flag  beq/bne
                            	  3308: 
                            	  3309: 
                            	  3310: * -----
                            	  3311: 
                            	  3312: *     NEGX - BYTE
02:00002136 307C0100        	  3313:             move.l #$00000100,a0
02:0000213A 7000            	  3314:             moveq  #$00000000,d0
02:0000213C 7240D241        	  3315:             move.l #$00000080,d1
02:00002140 003C0010        	  3316:             ori.b #$10,CCR        * Set X Flag
02:00002144 4000            	  3317:             negx.b d0
02:00002146 6AFE            	  3318:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:00002148 67FE            	  3319:             beq.s *                   * Check Z Flag  beq/bne 1
02:0000214A 64FE            	  3320:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:0000214C 69FE            	  3321:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000214E 023C00EF        	  3322:             andi.b #$EF,CCR       * Clear X Flag
02:00002152 4000            	  3323:             negx.b d0
02:00002154 6BFE            	  3324:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002156 67FE            	  3325:             beq.s *                   * Check Z Flag  beq/bne 1
02:00002158 64FE            	  3326:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:0000215A 69FE            	  3327:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000215C 003C0010        	  3328:             ori.b #$10,CCR        * Set X Flag
02:00002160 4001            	  3329:             negx.b d1
02:00002162 6BFE            	  3330:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:00002164 67FE            	  3331:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002166 64FE            	  3332:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002168 69FE            	  3333:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:0000216A 0C01007F        	  3334:             cmpi.b #$7F,d1
02:0000216E 66FE            	  3335:             bne.s *                   * Check Z Flag  beq/bne
02:00002170 023C00EF        	  3336:             andi.b #$EF,CCR       * Clear X Flag
02:00002174 4001            	  3337:             negx.b d1
02:00002176 6AFE            	  3338:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002178 67FE            	  3339:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000217A 64FE            	  3340:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000217C 69FE            	  3341:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:0000217E 0C010081        	  3342:             cmpi.b #$81,d1
02:00002182 66FE            	  3343:             bne.s *                   * Check Z Flag  beq/bne
02:00002184 10BC007F        	  3344:             move.b #$7F,(a0)
02:00002188 003C0010        	  3345:             ori.b #$10,CCR        * Set X Flag
02:0000218C 4010            	  3346:             negx.b (a0)
02:0000218E 6AFE            	  3347:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002190 67FE            	  3348:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002192 64FE            	  3349:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3350:             * I think overflow should happen here.
                            	  3351: *            bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002194 10BC007F        	  3352:             move.b #$7F,(a0)
02:00002198 023C00EF        	  3353:             andi.b #$EF,CCR       * Clear X Flag
02:0000219C 4010            	  3354:             negx.b (a0)
02:0000219E 6AFE            	  3355:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000021A0 67FE            	  3356:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021A2 64FE            	  3357:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000021A4 69FE            	  3358:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021A6 10BC00F5        	  3359:             move.b #$F5,(a0)
02:000021AA 003C0010        	  3360:             ori.b #$10,CCR        * Set X Flag
02:000021AE 4010            	  3361:             negx.b (a0)
02:000021B0 6BFE            	  3362:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000021B2 67FE            	  3363:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021B4 64FE            	  3364:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000021B6 69FE            	  3365:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021B8 0C10000A        	  3366:             cmpi.b #$0A,(a0)
02:000021BC 66FE            	  3367:             bne.s *                   * Check Z Flag  beq/bne
02:000021BE 023C00EF        	  3368:             andi.b #$EF,CCR       * Clear X Flag
02:000021C2 4010            	  3369:             negx.b (a0)
02:000021C4 6AFE            	  3370:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:000021C6 67FE            	  3371:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021C8 64FE            	  3372:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000021CA 69FE            	  3373:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021CC 0C1000F6        	  3374:             cmpi.b #$F6,(a0)
02:000021D0 66FE            	  3375:             bne.s *                   * Check Z Flag  beq/bne
                            	  3376: 
                            	  3377: 
                            	  3378: 
                            	  3379: * -----
                            	  3380: 
                            	  3381: *     NEGX - WORD
02:000021D2 307C0100        	  3382:             move.l #$00000100,a0
02:000021D6 7000            	  3383:             moveq  #$00000000,d0
02:000021D8 223C00008000    	  3384:             move.l #$00008000,d1
02:000021DE 003C0010        	  3385:             ori.b #$10,CCR        * Set X Flag
02:000021E2 4040            	  3386:             negx.w d0
02:000021E4 6AFE            	  3387:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:000021E6 67FE            	  3388:             beq.s *                   * Check Z Flag  beq/bne 1
02:000021E8 64FE            	  3389:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:000021EA 69FE            	  3390:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021EC 023C00EF        	  3391:             andi.b #$EF,CCR       * Clear X Flag
02:000021F0 4040            	  3392:             negx.w d0
02:000021F2 6BFE            	  3393:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000021F4 67FE            	  3394:             beq.s *                   * Check Z Flag  beq/bne 1
02:000021F6 64FE            	  3395:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:000021F8 69FE            	  3396:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021FA 003C0010        	  3397:             ori.b #$10,CCR        * Set X Flag
02:000021FE 4041            	  3398:             negx.w d1
02:00002200 6BFE            	  3399:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:00002202 67FE            	  3400:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002204 64FE            	  3401:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002206 69FE            	  3402:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:00002208 0C417FFF        	  3403:             cmpi.w #$7FFF,d1
02:0000220C 66FE            	  3404:             bne.s *                   * Check Z Flag  beq/bne
02:0000220E 023C00EF        	  3405:             andi.b #$EF,CCR       * Clear X Flag
02:00002212 4041            	  3406:             negx.w d1
02:00002214 6AFE            	  3407:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002216 67FE            	  3408:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002218 64FE            	  3409:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000221A 69FE            	  3410:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:0000221C 0C418001        	  3411:             cmpi.w #$8001,d1
02:00002220 66FE            	  3412:             bne.s *                   * Check Z Flag  beq/bne
02:00002222 30BC7FFF        	  3413:             move.w #$7FFF,(a0)
02:00002226 003C0010        	  3414:             ori.b #$10,CCR        * Set X Flag
02:0000222A 4050            	  3415:             negx.w (a0)
02:0000222C 6AFE            	  3416:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:0000222E 67FE            	  3417:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002230 64FE            	  3418:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3419: ***            
                            	  3420: *            bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002232 30BCF567        	  3421:             move.w #$F567,(a0)
02:00002236 023C00EF        	  3422:             andi.b #$EF,CCR       * Clear X Flag
02:0000223A 4050            	  3423:             negx.w (a0)
02:0000223C 6BFE            	  3424:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:0000223E 67FE            	  3425:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002240 64FE            	  3426:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002242 69FE            	  3427:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002244 30BCF567        	  3428:             move.w #$F567,(a0)
02:00002248 003C0010        	  3429:             ori.b #$10,CCR        * Set X Flag
02:0000224C 4050            	  3430:             negx.w (a0)
02:0000224E 6BFE            	  3431:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002250 67FE            	  3432:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002252 64FE            	  3433:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002254 69FE            	  3434:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002256 0C500A98        	  3435:             cmpi.w #$0A98,(a0)
02:0000225A 66FE            	  3436:             bne.s *                   * Check Z Flag  beq/bne
02:0000225C 023C00EF        	  3437:             andi.b #$EF,CCR       * Clear X Flag
02:00002260 4050            	  3438:             negx.w (a0)
02:00002262 6AFE            	  3439:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:00002264 67FE            	  3440:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002266 64FE            	  3441:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002268 69FE            	  3442:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000226A 0C50F568        	  3443:             cmpi.w #$F568,(a0)
02:0000226E 66FE            	  3444:             bne.s *                   * Check Z Flag  beq/bne
                            	  3445: 
                            	  3446: 
                            	  3447: * -----
                            	  3448: 
                            	  3449: *     NEGX - LONG
02:00002270 307C0100        	  3450:             move.l #$00000100,a0
02:00002274 7000            	  3451:             moveq  #$00000000,d0
02:00002276 223C80000000    	  3452:             move.l #$80000000,d1
02:0000227C 003C0010        	  3453:             ori.b #$10,CCR        * Set X Flag
02:00002280 4080            	  3454:             negx.l d0
02:00002282 6AFE            	  3455:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:00002284 67FE            	  3456:             beq.s *                   * Check Z Flag  beq/bne 1
02:00002286 64FE            	  3457:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:00002288 69FE            	  3458:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000228A 023C00EF        	  3459:             andi.b #$EF,CCR       * Clear X Flag
02:0000228E 4080            	  3460:             negx.l d0
02:00002290 6BFE            	  3461:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002292 67FE            	  3462:             beq.s *                   * Check Z Flag  beq/bne 1
02:00002294 64FE            	  3463:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:00002296 69FE            	  3464:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002298 003C0010        	  3465:             ori.b #$10,CCR        * Set X Flag
02:0000229C 4081            	  3466:             negx.l d1
02:0000229E 6BFE            	  3467:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:000022A0 67FE            	  3468:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022A2 64FE            	  3469:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000022A4 69FE            	  3470:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:000022A6 0C817FFFFFFF    	  3471:             cmpi.l #$7FFFFFFF,d1
02:000022AC 66FE            	  3472:             bne.s *                   * Check Z Flag  beq/bne
02:000022AE 023C00EF        	  3473:             andi.b #$EF,CCR       * Clear X Flag
02:000022B2 4081            	  3474:             negx.l d1
02:000022B4 6AFE            	  3475:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000022B6 67FE            	  3476:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022B8 64FE            	  3477:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3478: ****            
                            	  3479: *            bvs.s *                   * Check V Flag  bvc/bvs 0
02:000022BA 0C8180000001    	  3480:             cmpi.l #$80000001,d1
02:000022C0 66FE            	  3481:             bne.s *                   * Check Z Flag  beq/bne
02:000022C2 20BC00007FFF    	  3482:             move.l #$7FFF,(a0)
02:000022C8 003C0010        	  3483:             ori.b #$10,CCR        * Set X Flag
02:000022CC 4090            	  3484:             negx.l (a0)
02:000022CE 6AFE            	  3485:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000022D0 67FE            	  3486:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022D2 64FE            	  3487:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3488: ****            
                            	  3489: *            bvs.s *                   * Check V Flag  bvc/bvs 1
02:000022D4 20BCF5671234    	  3490:             move.l #$F5671234,(a0)
02:000022DA 023C00EF        	  3491:             andi.b #$EF,CCR       * Clear X Flag
02:000022DE 4090            	  3492:             negx.l (a0)
02:000022E0 6BFE            	  3493:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:000022E2 67FE            	  3494:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022E4 64FE            	  3495:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000022E6 69FE            	  3496:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000022E8 20BCF5675678    	  3497:             move.l #$F5675678,(a0)
02:000022EE 003C0010        	  3498:             ori.b #$10,CCR        * Set X Flag
02:000022F2 4090            	  3499:             negx.l (a0)
02:000022F4 6BFE            	  3500:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000022F6 67FE            	  3501:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022F8 64FE            	  3502:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000022FA 69FE            	  3503:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000022FC 0C900A98A987    	  3504:             cmpi.l #$0A98A987,(a0)
02:00002302 66FE            	  3505:             bne.s *                   * Check Z Flag  beq/bne
02:00002304 023C00EF        	  3506:             andi.b #$EF,CCR       * Clear X Flag
02:00002308 4090            	  3507:             negx.l (a0)
02:0000230A 6AFE            	  3508:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:0000230C 67FE            	  3509:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000230E 64FE            	  3510:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002310 69FE            	  3511:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002312 0C90F5675679    	  3512:             cmpi.l #$F5675679,(a0)
02:00002318 66FE            	  3513:             bne.s *                   * Check Z Flag  beq/bne
                            	  3514: 
                            	  3515: 
                            	  3516: * -----
                            	  3517: 
                            	  3518: *     CLR - BYTE
02:0000231A 307C0100        	  3519:             move.l #$00000100,a0
02:0000231E 203C12345678    	  3520:             move.l #$12345678,d0
02:00002324 223C12345678    	  3521:             move.l #$12345678,d1
02:0000232A 243C12345678    	  3522:             move.l #$12345678,d2
02:00002330 283C12345600    	  3523:             move.l #$12345600,d4
02:00002336 2A3C12340000    	  3524:             move.l #$12340000,d5
02:0000233C 7C00            	  3525:             moveq  #$00000000,d6
                            	  3526: 
02:0000233E 4200            	  3527:             clr.b d0
02:00002340 66FE            	  3528:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002342 6BFE            	  3529:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002344 B880            	  3530:             cmp.l d0,d4
02:00002346 66FE            	  3531:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3532: 
02:00002348 4241            	  3533:             clr.w d1
02:0000234A 66FE            	  3534:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000234C 6BFE            	  3535:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000234E BA81            	  3536:             cmp.l d1,d5
02:00002350 66FE            	  3537:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3538: 
02:00002352 7400            	  3539:             clr.l d2
02:00002354 66FE            	  3540:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002356 6BFE            	  3541:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002358 BC82            	  3542:             cmp.l d2,d6
02:0000235A 66FE            	  3543:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3544: 
02:0000235C 4E75            	  3545:             rts
                            	  3546: 
                            	  3547: 
                            	  3548: 
                            	  3549: *-----------------------------------------------------------
                            	  3550: *-----------------------------------------------------------
                            	  3551: * OPCODE : MOVEM
                            	  3552: *-----------------------------------------------------------
                            	  3553: *-----------------------------------------------------------
                            	  3554: op_MOVEM:
                            	  3555: 
                            	  3556: *     WORD  Registers --> Memory
02:0000235E 203C0000D0D0    	  3557:             move.l #$0000d0d0,d0
02:00002364 223C0000D1D1    	  3558:             move.l #$0000d1d1,d1
02:0000236A 243C0000D2D2    	  3559:             move.l #$0000d2d2,d2
02:00002370 263C0000D3D3    	  3560:             move.l #$0000d3d3,d3
02:00002376 283C0000D4D4    	  3561:             move.l #$0000d4d4,d4
02:0000237C 2A3C0000D5D5    	  3562:             move.l #$0000d5d5,d5
02:00002382 2C3C0000D6D6    	  3563:             move.l #$0000d6d6,d6
02:00002388 2E3C0000D7D7    	  3564:             move.l #$0000d7d7,d7
02:0000238E 307C0A0A        	  3565:             move.l #$00000a0a,a0
02:00002392 327C1A1A        	  3566:             move.l #$00001a1a,a1
02:00002396 347C2A2A        	  3567:             move.l #$00002a2a,a2
02:0000239A 367C3A3A        	  3568:             move.l #$00003a3a,a3
02:0000239E 387C4A4A        	  3569:             move.l #$00004a4a,a4
02:000023A2 3A7C5A5A        	  3570:             move.l #$00005a5a,a5
02:000023A6 3C7C6A6A        	  3571:             move.l #$00006a6a,a6
                            	  3572: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3573: 
02:000023AA 48B8FFFF0100    	  3574:             movem.w D0-D7/A0-A7,$00000100
                            	  3575: 
02:000023B0 307C0100        	  3576:             move.l #$00000100,a0
                            	  3577: 
02:000023B4 B058            	  3578:             cmp.w (a0)+,d0
02:000023B6 66FE            	  3579:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023B8 B258            	  3580:             cmp.w (a0)+,d1
02:000023BA 66FE            	  3581:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023BC B458            	  3582:             cmp.w (a0)+,d2
02:000023BE 66FE            	  3583:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023C0 B658            	  3584:             cmp.w (a0)+,d3
02:000023C2 66FE            	  3585:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023C4 B858            	  3586:             cmp.w (a0)+,d4
02:000023C6 66FE            	  3587:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023C8 BA58            	  3588:             cmp.w (a0)+,d5
02:000023CA 66FE            	  3589:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023CC BC58            	  3590:             cmp.w (a0)+,d6
02:000023CE 66FE            	  3591:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023D0 BE58            	  3592:             cmp.w (a0)+,d7
02:000023D2 66FE            	  3593:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3594: 
02:000023D4 0C580A0A        	  3595:             cmpi.w #$0A0A,(a0)+    * Because we are using a0 as a pointer
02:000023D8 66FE            	  3596:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3597: 
02:000023DA B2D8            	  3598:             cmp.w (a0)+,a1
02:000023DC 66FE            	  3599:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023DE B4D8            	  3600:             cmp.w (a0)+,a2
02:000023E0 66FE            	  3601:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023E2 B6D8            	  3602:             cmp.w (a0)+,a3
02:000023E4 66FE            	  3603:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023E6 B8D8            	  3604:             cmp.w (a0)+,a4
02:000023E8 66FE            	  3605:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023EA BAD8            	  3606:             cmp.w (a0)+,a5
02:000023EC 66FE            	  3607:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023EE BCD8            	  3608:             cmp.w (a0)+,a6
02:000023F0 66FE            	  3609:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3610: 
                            	  3611: 
                            	  3612: 
                            	  3613: 
                            	  3614: *     LONG  Registers --> Memory
02:000023F2 203CD0D0D0D0    	  3615:             move.l #$d0d0d0d0,d0
02:000023F8 223CD1D1D1D1    	  3616:             move.l #$d1d1d1d1,d1
02:000023FE 243CD2D2D2D2    	  3617:             move.l #$d2d2d2d2,d2
02:00002404 263CD3D3D3D3    	  3618:             move.l #$d3d3d3d3,d3
02:0000240A 283CD4D4D4D4    	  3619:             move.l #$d4d4d4d4,d4
02:00002410 2A3CD5D5D5D5    	  3620:             move.l #$d5d5d5d5,d5
02:00002416 2C3CD6D6D6D6    	  3621:             move.l #$d6d6d6d6,d6
02:0000241C 2E3CD7D7D7D7    	  3622:             move.l #$d7d7d7d7,d7
02:00002422 207C0A0A0A0A    	  3623:             move.l #$0a0a0a0a,a0
02:00002428 227C1A1A1A1A    	  3624:             move.l #$1a1a1a1a,a1
02:0000242E 247C2A2A2A2A    	  3625:             move.l #$2a2a2a2a,a2
02:00002434 267C3A3A3A3A    	  3626:             move.l #$3a3a3a3a,a3
02:0000243A 287C4A4A4A4A    	  3627:             move.l #$4a4a4a4a,a4
02:00002440 2A7C5A5A5A5A    	  3628:             move.l #$5a5a5a5a,a5
02:00002446 2C7C6A6A6A6A    	  3629:             move.l #$6a6a6a6a,a6
                            	  3630: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3631: 
                            	  3632: 
02:0000244C 48F8FFFF0120    	  3633:             movem.l D0-D7/A0-A7,$00000120
                            	  3634: 
02:00002452 307C0120        	  3635:             move.l #$00000120,a0
                            	  3636: 
02:00002456 B098            	  3637:             cmp.l (a0)+,d0
02:00002458 66FE            	  3638:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000245A B298            	  3639:             cmp.l (a0)+,d1
02:0000245C 66FE            	  3640:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000245E B498            	  3641:             cmp.l (a0)+,d2
02:00002460 66FE            	  3642:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002462 B698            	  3643:             cmp.l (a0)+,d3
02:00002464 66FE            	  3644:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002466 B898            	  3645:             cmp.l (a0)+,d4
02:00002468 66FE            	  3646:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000246A BA98            	  3647:             cmp.l (a0)+,d5
02:0000246C 66FE            	  3648:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000246E BC98            	  3649:             cmp.l (a0)+,d6
02:00002470 66FE            	  3650:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002472 BE98            	  3651:             cmp.l (a0)+,d7
02:00002474 66FE            	  3652:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3653: 
02:00002476 0C980A0A0A0A    	  3654:             cmpi.l #$0A0A0A0A,(a0)+    * Because we are using a0 as a pointer
02:0000247C 66FE            	  3655:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3656: 
02:0000247E B3D8            	  3657:             cmp.l (a0)+,a1
02:00002480 66FE            	  3658:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002482 B5D8            	  3659:             cmp.l (a0)+,a2
02:00002484 66FE            	  3660:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002486 B7D8            	  3661:             cmp.l (a0)+,a3
02:00002488 66FE            	  3662:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000248A B9D8            	  3663:             cmp.l (a0)+,a4
02:0000248C 66FE            	  3664:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000248E BBD8            	  3665:             cmp.l (a0)+,a5
02:00002490 66FE            	  3666:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002492 BDD8            	  3667:             cmp.l (a0)+,a6
02:00002494 66FE            	  3668:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3669: *      ----
                            	  3670: 
                            	  3671: 
                            	  3672: *     WORD  Registers --> Memory  -(An) EA Mode
02:00002496 203C0000D0D0    	  3673:             move.l #$0000d0d0,d0
02:0000249C 223C0000D1D1    	  3674:             move.l #$0000d1d1,d1
02:000024A2 243C0000D2D2    	  3675:             move.l #$0000d2d2,d2
02:000024A8 263C0000D3D3    	  3676:             move.l #$0000d3d3,d3
02:000024AE 283C0000D4D4    	  3677:             move.l #$0000d4d4,d4
02:000024B4 2A3C0000D5D5    	  3678:             move.l #$0000d5d5,d5
02:000024BA 2C3C0000D6D6    	  3679:             move.l #$0000d6d6,d6
02:000024C0 2E3C0000D7D7    	  3680:             move.l #$0000d7d7,d7
02:000024C6 307C0A0A        	  3681:             move.l #$00000a0a,a0
02:000024CA 327C1A1A        	  3682:             move.l #$00001a1a,a1
02:000024CE 347C2A2A        	  3683:             move.l #$00002a2a,a2
02:000024D2 367C3A3A        	  3684:             move.l #$00003a3a,a3
02:000024D6 387C4A4A        	  3685:             move.l #$00004a4a,a4
02:000024DA 3A7C5A5A        	  3686:             move.l #$00005a5a,a5
02:000024DE 3C7C6A6A        	  3687:             move.l #$00006a6a,a6
                            	  3688: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3689: 
02:000024E2 307C01A0        	  3690:             move.l #$000001A0,a0
02:000024E6 48A0FFFF        	  3691:             movem.w D0-D7/A0-A7,-(a0)
                            	  3692: 
02:000024EA 307C019E        	  3693:             move.l #$0000019E,a0
                            	  3694: 
02:000024EE BCE0            	  3695:             cmp.w -(a0),a6
02:000024F0 66FE            	  3696:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024F2 BAE0            	  3697:             cmp.w -(a0),a5
02:000024F4 66FE            	  3698:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024F6 B8E0            	  3699:             cmp.w -(a0),a4
02:000024F8 66FE            	  3700:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024FA B6E0            	  3701:             cmp.w -(a0),a3
02:000024FC 66FE            	  3702:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024FE B4E0            	  3703:             cmp.w -(a0),a2
02:00002500 66FE            	  3704:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002502 B2E0            	  3705:             cmp.w -(a0),a1
02:00002504 66FE            	  3706:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002506 B0E0            	  3707:             cmp.w -(a0),a0
                            	  3708: *            bne.s *                   * Check Z Flag  beq/bne 0
02:00002508 BE60            	  3709:             cmp.w -(a0),d7
02:0000250A 66FE            	  3710:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000250C BC60            	  3711:             cmp.w -(a0),d6
02:0000250E 66FE            	  3712:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002510 BA60            	  3713:             cmp.w -(a0),d5
02:00002512 66FE            	  3714:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002514 B860            	  3715:             cmp.w -(a0),d4
02:00002516 66FE            	  3716:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002518 B660            	  3717:             cmp.w -(a0),d3
02:0000251A 66FE            	  3718:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000251C B460            	  3719:             cmp.w -(a0),d2
02:0000251E 66FE            	  3720:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002520 B260            	  3721:             cmp.w -(a0),d1
02:00002522 66FE            	  3722:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002524 B060            	  3723:             cmp.w -(a0),d0
02:00002526 66FE            	  3724:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3725: 
                            	  3726: 
                            	  3727: 
                            	  3728: 
                            	  3729: *     LONG  Registers --> Memory   -(An) EA Mode
02:00002528 203CD0D0D0D0    	  3730:             move.l #$d0d0d0d0,d0
02:0000252E 223CD1D1D1D1    	  3731:             move.l #$d1d1d1d1,d1
02:00002534 243CD2D2D2D2    	  3732:             move.l #$d2d2d2d2,d2
02:0000253A 263CD3D3D3D3    	  3733:             move.l #$d3d3d3d3,d3
02:00002540 283CD4D4D4D4    	  3734:             move.l #$d4d4d4d4,d4
02:00002546 2A3CD5D5D5D5    	  3735:             move.l #$d5d5d5d5,d5
02:0000254C 2C3CD6D6D6D6    	  3736:             move.l #$d6d6d6d6,d6
02:00002552 2E3CD7D7D7D7    	  3737:             move.l #$d7d7d7d7,d7
02:00002558 207C0A0A0A0A    	  3738:             move.l #$0a0a0a0a,a0
02:0000255E 227C1A1A1A1A    	  3739:             move.l #$1a1a1a1a,a1
02:00002564 247C2A2A2A2A    	  3740:             move.l #$2a2a2a2a,a2
02:0000256A 267C3A3A3A3A    	  3741:             move.l #$3a3a3a3a,a3
02:00002570 287C4A4A4A4A    	  3742:             move.l #$4a4a4a4a,a4
02:00002576 2A7C5A5A5A5A    	  3743:             move.l #$5a5a5a5a,a5
02:0000257C 2C7C6A6A6A6A    	  3744:             move.l #$6a6a6a6a,a6
                            	  3745: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3746: 
                            	  3747: 
02:00002582 307C01A0        	  3748:             move.l #$000001A0,a0
02:00002586 48E0FFFF        	  3749:             movem.l D0-D7/A0-A7,-(a0)
                            	  3750: 
02:0000258A 307C019C        	  3751:             move.l #$0000019C,a0
                            	  3752: 
02:0000258E BDE0            	  3753:             cmp.l -(a0),a6
02:00002590 66FE            	  3754:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002592 BBE0            	  3755:             cmp.l -(a0),a5
02:00002594 66FE            	  3756:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002596 B9E0            	  3757:             cmp.l -(a0),a4
02:00002598 66FE            	  3758:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000259A B7E0            	  3759:             cmp.l -(a0),a3
02:0000259C 66FE            	  3760:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000259E B5E0            	  3761:             cmp.l -(a0),a2
02:000025A0 66FE            	  3762:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025A2 B3E0            	  3763:             cmp.l -(a0),a1
02:000025A4 66FE            	  3764:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025A6 B1E0            	  3765:             cmp.l -(a0),a0
                            	  3766: *            bne.s *                   * Check Z Flag  beq/bne 0
02:000025A8 BEA0            	  3767:             cmp.l -(a0),d7
02:000025AA 66FE            	  3768:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025AC BCA0            	  3769:             cmp.l -(a0),d6
02:000025AE 66FE            	  3770:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025B0 BAA0            	  3771:             cmp.l -(a0),d5
02:000025B2 66FE            	  3772:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025B4 B8A0            	  3773:             cmp.l -(a0),d4
02:000025B6 66FE            	  3774:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025B8 B6A0            	  3775:             cmp.l -(a0),d3
02:000025BA 66FE            	  3776:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025BC B4A0            	  3777:             cmp.l -(a0),d2
02:000025BE 66FE            	  3778:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025C0 B2A0            	  3779:             cmp.l -(a0),d1
02:000025C2 66FE            	  3780:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025C4 B0A0            	  3781:             cmp.l -(a0),d0
02:000025C6 66FE            	  3782:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3783: 
                            	  3784: 
                            	  3785: 
                            	  3786: *     ----
                            	  3787: 
                            	  3788: *     WORD - Memory --> Registers
02:000025C8 7000            	  3789:             moveq  #$00000000,d0
02:000025CA 7200            	  3790:             moveq  #$00000000,d1
02:000025CC 7400            	  3791:             moveq  #$00000000,d2
02:000025CE 7600            	  3792:             moveq  #$00000000,d3
02:000025D0 7800            	  3793:             moveq  #$00000000,d4
02:000025D2 7A00            	  3794:             moveq  #$00000000,d5
02:000025D4 7C00            	  3795:             moveq  #$00000000,d6
02:000025D6 7E00            	  3796:             moveq  #$00000000,d7
02:000025D8 91C8            	  3797:             move.l #$00000000,a0
02:000025DA 93C9            	  3798:             move.l #$00000000,a1
02:000025DC 95CA            	  3799:             move.l #$00000000,a2
02:000025DE 97CB            	  3800:             move.l #$00000000,a3
02:000025E0 99CC            	  3801:             move.l #$00000000,a4
02:000025E2 9BCD            	  3802:             move.l #$00000000,a5
02:000025E4 9DCE            	  3803:             move.l #$00000000,a6
                            	  3804: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3805: 
02:000025E6 4CB82A550100    	  3806:             movem.w $00000100,D0/D2/D4/D6/A1/A3/A5
                            	  3807: 
02:000025EC B0BCFFFFD0D0    	  3808:             cmp.l #$FFFFD0D0,d0
02:000025F2 66FE            	  3809:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025F4 B4BCFFFFD1D1    	  3810:             cmp.l #$FFFFD1D1,d2
02:000025FA 66FE            	  3811:             bne.s *                  * Check Z Flag  beq/bne 0
02:000025FC B8BCFFFFD2D2    	  3812:             cmp.l #$FFFFD2D2,d4
02:00002602 66FE            	  3813:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002604 BCBCFFFFD3D3    	  3814:             cmp.l #$FFFFD3D3,d6
02:0000260A 66FE            	  3815:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000260C B2FCD4D4        	  3816:             cmp.l #$FFFFD4D4,a1
02:00002610 66FE            	  3817:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002612 B6FCD5D5        	  3818:             cmp.l #$FFFFD5D5,a3
02:00002616 66FE            	  3819:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002618 BAFCD6D6        	  3820:             cmp.l #$FFFFD6D6,a5
02:0000261C 66FE            	  3821:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3822: 
                            	  3823: 
                            	  3824: *     LONG - Memory --> Registers
02:0000261E 7000            	  3825:             moveq  #$00000000,d0
02:00002620 7200            	  3826:             moveq  #$00000000,d1
02:00002622 7400            	  3827:             moveq  #$00000000,d2
02:00002624 7600            	  3828:             moveq  #$00000000,d3
02:00002626 7800            	  3829:             moveq  #$00000000,d4
02:00002628 7A00            	  3830:             moveq  #$00000000,d5
02:0000262A 7C00            	  3831:             moveq  #$00000000,d6
02:0000262C 7E00            	  3832:             moveq  #$00000000,d7
02:0000262E 91C8            	  3833:             move.l #$00000000,a0
02:00002630 93C9            	  3834:             move.l #$00000000,a1
02:00002632 95CA            	  3835:             move.l #$00000000,a2
02:00002634 97CB            	  3836:             move.l #$00000000,a3
02:00002636 99CC            	  3837:             move.l #$00000000,a4
02:00002638 9BCD            	  3838:             move.l #$00000000,a5
02:0000263A 9DCE            	  3839:             move.l #$00000000,a6
                            	  3840: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3841: 
02:0000263C 4CF82A550120    	  3842:             movem.l $00000120,D0/D2/D4/D6/A1/A3/A5
                            	  3843: 
02:00002642 B0BCD0D0D0D0    	  3844:             cmp.l #$D0D0D0D0,d0
02:00002648 66FE            	  3845:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000264A B4BCD1D1D1D1    	  3846:             cmp.l #$D1D1D1D1,d2
02:00002650 66FE            	  3847:             bne.s *                  * Check Z Flag  beq/bne 0
02:00002652 B8BCD2D2D2D2    	  3848:             cmp.l #$D2D2D2D2,d4
02:00002658 66FE            	  3849:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000265A BCBCD3D3D3D3    	  3850:             cmp.l #$D3D3D3D3,d6
02:00002660 66FE            	  3851:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002662 B3FCD4D4D4D4    	  3852:             cmp.l #$D4D4D4D4,a1
02:00002668 66FE            	  3853:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000266A B7FCD5D5D5D5    	  3854:             cmp.l #$D5D5D5D5,a3
02:00002670 66FE            	  3855:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002672 BBFCD6D6D6D6    	  3856:             cmp.l #$D6D6D6D6,a5
02:00002678 66FE            	  3857:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3858: 
02:0000267A 4E75            	  3859:             rts
                            	  3860: 
                            	  3861: 
                            	  3862: *-----------------------------------------------------------
                            	  3863: *-----------------------------------------------------------
                            	  3864: * OPCODE : ABCD
                            	  3865: *-----------------------------------------------------------
                            	  3866: *-----------------------------------------------------------
                            	  3867: op_ABCD:
                            	  3868: 
                            	  3869: *     Test with X Flag CLEARED
02:0000267C 307C0110        	  3870:                 move.l #$00000110,a0 * Address pointer-X
02:00002680 327C0120        	  3871:                 move.l #$00000120,a1 * Address pointer-Y
02:00002684 7000            	  3872:                 moveq  #$00000000,d0 * BCD byte-X
02:00002686 7200            	  3873:                 moveq  #$00000000,d1 * BCD byte-Y
02:00002688 7400            	  3874:                 moveq  #$00000000,d2
02:0000268A 7600            	  3875:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:0000268C 7800            	  3876:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:0000268E 7A00            	  3877:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:00002690 2C3C00000099    	  3878:                 move.l #$00000099,d6 * Inner loop counter
02:00002696 2E3C00000099    	  3879:                 move.l #$00000099,d7 * Outer loop counter
                            	  3880: 
02:0000269C 2007            	  3881: ABCD_OUTER1:    move.l d7,d0
02:0000269E 2206            	  3882: ABCD_INNER1:    move.l d6,d1
02:000026A0 023C00EF        	  3883:                 andi.b #$EF,CCR     * Clear X Flag
02:000026A4 307C0110        	  3884:                 move.l #$00000110,a0 * Address pointer-X
02:000026A8 327C0120        	  3885:                 move.l #$00000120,a1 * Address pointer-Y
02:000026AC 1140FFFF        	  3886:                 move.b d0,-1(a0)
02:000026B0 1341FFFF        	  3887:                 move.b d1,-1(a1)
                            	  3888: 
02:000026B4 C300            	  3889:                 abcd d0,d1
02:000026B6 6402            	  3890:                 bcc.s ABCD_NO_C1          * Check C Flag  bcc/bcs 0
02:000026B8 5284            	  3891:                 add.l #1,d4
02:000026BA DA81            	  3892: ABCD_NO_C1:     add.l d1,d5
                            	  3893: 
02:000026BC C308            	  3894:                 abcd -(a0),-(a1)
02:000026BE 6402            	  3895:                 bcc.s ABCD_NO_C2          * Check C Flag  bcc/bcs 0
02:000026C0 5284            	  3896:                 add.l #1,d4
02:000026C2 D611            	  3897: ABCD_NO_C2:     add.b (a1),d3
                            	  3898: 
                            	  3899: 
02:000026C4 51CEFFD8        	  3900:                 dbf d6,ABCD_INNER1
02:000026C8 2C3C00000099    	  3901:                 move.l #$00000099,d6
02:000026CE 51CFFFCC        	  3902:                 dbf d7,ABCD_OUTER1
02:000026D2 0C8400005AFC    	  3903:                 cmpi.l #$00005AFC,d4  * Check the cumulative results
02:000026D8 66FE            	  3904:                 bne.s *
02:000026DA 0C85001C9A34    	  3905:                 cmpi.l #$001C9A34,d5
02:000026E0 66FE            	  3906:                 bne.s *
02:000026E2 0C8300000034    	  3907:                 cmpi.l #$00000034,d3
02:000026E8 66FE            	  3908:                 bne.s *
                            	  3909: 
                            	  3910: *     Test with X Flag SET
02:000026EA 307C0110        	  3911:                 move.l #$00000110,a0 * Address pointer-X
02:000026EE 327C0120        	  3912:                 move.l #$00000120,a1 * Address pointer-Y
02:000026F2 7000            	  3913:                 moveq  #$00000000,d0 * BCD byte-X
02:000026F4 7200            	  3914:                 moveq  #$00000000,d1 * BCD byte-Y
02:000026F6 7400            	  3915:                 moveq  #$00000000,d2
02:000026F8 7600            	  3916:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:000026FA 7800            	  3917:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:000026FC 7A00            	  3918:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:000026FE 2C3C00000099    	  3919:                 move.l #$00000099,d6 * Inner loop counter
02:00002704 2E3C00000099    	  3920:                 move.l #$00000099,d7 * Outer loop counter
                            	  3921: 
02:0000270A 2007            	  3922: ABCD_OUTER2:    move.l d7,d0
02:0000270C 2206            	  3923: ABCD_INNER2:    move.l d6,d1
02:0000270E 003C0010        	  3924:                 ori.b #$10,CCR      * Set X Flag
02:00002712 307C0110        	  3925:                 move.l #$00000110,a0 * Address pointer-X
02:00002716 327C0120        	  3926:                 move.l #$00000120,a1 * Address pointer-Y
02:0000271A 1140FFFF        	  3927:                 move.b d0,-1(a0)
02:0000271E 1341FFFF        	  3928:                 move.b d1,-1(a1)
                            	  3929: 
02:00002722 C300            	  3930:                 abcd d0,d1
02:00002724 6402            	  3931:                 bcc.s ABCD_NO_C3          * Check C Flag  bcc/bcs 0
02:00002726 5284            	  3932:                 add.l #1,d4
02:00002728 DA81            	  3933: ABCD_NO_C3:     add.l d1,d5
                            	  3934: 
02:0000272A C308            	  3935:                 abcd -(a0),-(a1)
02:0000272C 6402            	  3936:                 bcc.s ABCD_NO_C4          * Check C Flag  bcc/bcs 0
02:0000272E 5284            	  3937:                 add.l #1,d4
02:00002730 D611            	  3938: ABCD_NO_C4:     add.b (a1),d3
                            	  3939: 
                            	  3940: 
02:00002732 51CEFFD8        	  3941:                 dbf d6,ABCD_INNER2
02:00002736 2C3C00000099    	  3942:                 move.l #$00000099,d6
02:0000273C 51CFFFCC        	  3943:                 dbf d7,ABCD_OUTER2
02:00002740 0C8400005B60    	  3944:                 cmpi.l #$00005B60,d4  * Check the cumulative results
02:00002746 66FE            	  3945:                 bne.s *
02:00002748 0C85001CCFC8    	  3946:                 cmpi.l #$001CCFC8,d5
02:0000274E 66FE            	  3947:                 bne.s *
02:00002750 0C8300000034    	  3948:                 cmpi.l #$00000034,d3
02:00002756 66FE            	  3949:                 bne.s *
                            	  3950: 
                            	  3951: *             Quick check of Z Flag
02:00002758 4200            	  3952:                 move.b #$00,d0
02:0000275A 4201            	  3953:                 move.b #$00,d1
02:0000275C 44FC0000        	  3954:                 move #$00,CCR              * Set Z flag to 0
02:00002760 C101            	  3955:                 abcd d1,d0                  * Should NOT set Z Flag to 1
02:00002762 67FE            	  3956:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3957: 
02:00002764 103C0001        	  3958:                 move.b #$01,d0
02:00002768 4201            	  3959:                 move.b #$00,d1
02:0000276A 44FC0004        	  3960:                 move #$04,CCR              * Set Z flag to 0
02:0000276E C101            	  3961:                 abcd d1,d0                  * Should NOT set Z Flag to 1
02:00002770 67FE            	  3962:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3963: 
02:00002772 4E75            	  3964:                 rts
                            	  3965: 
                            	  3966: *-----------------------------------------------------------
                            	  3967: *-----------------------------------------------------------
                            	  3968: * OPCODE : SBCD
                            	  3969: *-----------------------------------------------------------
                            	  3970: *-----------------------------------------------------------
                            	  3971: op_SBCD:
                            	  3972: 
                            	  3973: *     Test with X Flag CLEARED
02:00002774 307C0110        	  3974:                 move.l #$00000110,a0 * Address pointer-X
02:00002778 327C0120        	  3975:                 move.l #$00000120,a1 * Address pointer-Y
02:0000277C 7000            	  3976:                 moveq  #$00000000,d0 * BCD byte-X
02:0000277E 7200            	  3977:                 moveq  #$00000000,d1 * BCD byte-Y
02:00002780 7400            	  3978:                 moveq  #$00000000,d2
02:00002782 7600            	  3979:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:00002784 7800            	  3980:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:00002786 7A00            	  3981:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:00002788 2C3C00000099    	  3982:                 move.l #$00000099,d6 * Inner loop counter
02:0000278E 2E3C00000099    	  3983:                 move.l #$00000099,d7 * Outer loop counter
                            	  3984: 
02:00002794 2007            	  3985: SBCD_OUTER1:    move.l d7,d0
02:00002796 2206            	  3986: SBCD_INNER1:    move.l d6,d1
02:00002798 023C00EF        	  3987:                 andi.b #$EF,CCR     * Clear X Flag
02:0000279C 307C0110        	  3988:                 move.l #$00000110,a0 * Address pointer-X
02:000027A0 327C0120        	  3989:                 move.l #$00000120,a1 * Address pointer-Y
02:000027A4 1140FFFF        	  3990:                 move.b d0,-1(a0)
02:000027A8 1341FFFF        	  3991:                 move.b d1,-1(a1)
                            	  3992: 
02:000027AC 8300            	  3993:                 sbcd d0,d1
02:000027AE 6402            	  3994:                 bcc.s SBCD_NO_C1          * Check C Flag  bcc/bcs 0
02:000027B0 5284            	  3995:                 add.l #1,d4
02:000027B2 DA81            	  3996: SBCD_NO_C1:     add.l d1,d5
                            	  3997: 
02:000027B4 8308            	  3998:                 sbcd -(a0),-(a1)
02:000027B6 6402            	  3999:                 bcc.s SBCD_NO_C2          * Check C Flag  bcc/bcs 0
02:000027B8 5284            	  4000:                 add.l #1,d4
02:000027BA D611            	  4001: SBCD_NO_C2:     add.b (a1),d3
                            	  4002: 
                            	  4003: 
02:000027BC 51CEFFD8        	  4004:                 dbf d6,SBCD_INNER1
02:000027C0 2C3C00000099    	  4005:                 move.l #$00000099,d6
02:000027C6 51CFFFCC        	  4006:                 dbf d7,SBCD_OUTER1
02:000027CA 0C8400005C0A    	  4007:                 cmpi.l #$00005C0A,d4  * Check the cumulative results
02:000027D0 66FE            	  4008:                 bne.s *
02:000027D2 0C85001C459E    	  4009:                 cmpi.l #$001C459E,d5
02:000027D8 66FE            	  4010:                 bne.s *
02:000027DA 0C830000009E    	  4011:                 cmpi.l #$0000009E,d3
02:000027E0 66FE            	  4012:                 bne.s *
                            	  4013: 
                            	  4014: *     Test with X Flag SET
02:000027E2 307C0110        	  4015:                 move.l #$00000110,a0 * Address pointer-X
02:000027E6 327C0120        	  4016:                 move.l #$00000120,a1 * Address pointer-Y
02:000027EA 7000            	  4017:                 moveq  #$00000000,d0 * BCD byte-X
02:000027EC 7200            	  4018:                 moveq  #$00000000,d1 * BCD byte-Y
02:000027EE 7400            	  4019:                 moveq  #$00000000,d2
02:000027F0 7600            	  4020:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:000027F2 7800            	  4021:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:000027F4 7A00            	  4022:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:000027F6 2C3C00000099    	  4023:                 move.l #$00000099,d6 * Inner loop counter
02:000027FC 2E3C00000099    	  4024:                 move.l #$00000099,d7 * Outer loop counter
                            	  4025: 
02:00002802 2007            	  4026: SBCD_OUTER2:    move.l d7,d0
02:00002804 2206            	  4027: SBCD_INNER2:    move.l d6,d1
02:00002806 003C0010        	  4028:                 ori.b #$10,CCR      * Set X Flag
02:0000280A 307C0110        	  4029:                 move.l #$00000110,a0 * Address pointer-X
02:0000280E 327C0120        	  4030:                 move.l #$00000120,a1 * Address pointer-Y
02:00002812 1140FFFF        	  4031:                 move.b d0,-1(a0)
02:00002816 1341FFFF        	  4032:                 move.b d1,-1(a1)
                            	  4033: 
02:0000281A 8300            	  4034:                 sbcd d0,d1
02:0000281C 6402            	  4035:                 bcc.s SBCD_NO_C3          * Check C Flag  bcc/bcs 0
02:0000281E 5284            	  4036:                 add.l #1,d4
02:00002820 DA81            	  4037: SBCD_NO_C3:     add.l d1,d5
                            	  4038: 
02:00002822 8308            	  4039:                 sbcd -(a0),-(a1)
02:00002824 6402            	  4040:                 bcc.s SBCD_NO_C4          * Check C Flag  bcc/bcs 0
02:00002826 5284            	  4041:                 add.l #1,d4
02:00002828 D611            	  4042: SBCD_NO_C4:     add.b (a1),d3
                            	  4043: 
02:0000282A 51CEFFD8        	  4044:                 dbf d6,SBCD_INNER2
02:0000282E 2C3C00000099    	  4045:                 move.l #$00000099,d6
02:00002834 51CFFFCC        	  4046:                 dbf d7,SBCD_OUTER2
02:00002838 0C8400005CA4    	  4047:                 cmpi.l #$00005CA4,d4  * Check the cumulative results
02:0000283E 66FE            	  4048:                 bne.s *
02:00002840 0C85001C5C66    	  4049:                 cmpi.l #$001C5C66,d5
02:00002846 66FE            	  4050:                 bne.s *
02:00002848 0C830000009E    	  4051:                 cmpi.l #$0000009E,d3
02:0000284E 66FE            	  4052:                 bne.s *
                            	  4053: 
                            	  4054: 
                            	  4055: *             Quick check of Z Flag
02:00002850 4200            	  4056:                 move.b #$00,d0
02:00002852 4201            	  4057:                 move.b #$00,d1
02:00002854 44FC0000        	  4058:                 move #$00,CCR              * Set Z flag to 0
02:00002858 8101            	  4059:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
02:0000285A 67FE            	  4060:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4061: 
02:0000285C 103C0001        	  4062:                 move.b #$01,d0
02:00002860 4201            	  4063:                 move.b #$00,d1
02:00002862 44FC0004        	  4064:                 move #$04,CCR              * Set Z flag to 0
02:00002866 8101            	  4065:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
02:00002868 67FE            	  4066:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4067: 
02:0000286A 4E75            	  4068:                 rts
                            	  4069: 
                            	  4070: *-----------------------------------------------------------
                            	  4071: *-----------------------------------------------------------
                            	  4072: * OPCODE : NBCD
                            	  4073: *-----------------------------------------------------------
                            	  4074: *-----------------------------------------------------------
                            	  4075: op_NBCD:
                            	  4076: 
                            	  4077: *        NBCD to a  Register
                            	  4078: 
02:0000286C 7000            	  4079:                 moveq  #$00000000,d0 * BCD byte
02:0000286E 7200            	  4080:                 moveq  #$00000000,d1
02:00002870 7400            	  4081:                 moveq  #$00000000,d2
02:00002872 7600            	  4082:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
02:00002874 7800            	  4083:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:00002876 7A00            	  4084:                 moveq  #$00000000,d5 * Cumulative BCD results
02:00002878 2C3C00000099    	  4085:                 move.l #$00000099,d6
02:0000287E 2E3C00000099    	  4086:                 move.l #$00000099,d7 * Loop counter
                            	  4087: 
02:00002884 2007            	  4088: NBCD_LOOP:      move.l d7,d0
02:00002886 44FC0004        	  4089:                 move #$04,CCR        * Set Z flag to 0
                            	  4090: 
02:0000288A 4800            	  4091:                 nbcd d0
                            	  4092: 
02:0000288C 6402            	  4093:                 bcc.s NBCD_NO_C         * Check C Flag
02:0000288E 5284            	  4094:                 add.l #1,d4
02:00002890 6602            	  4095: NBCD_NO_C:      bne.s NBCD_NO_Z         * Check Z Flag
02:00002892 5283            	  4096:                 add.l #1,d3
02:00002894 DA80            	  4097: NBCD_NO_Z:      add.l d0,d5         * Add results into d5
                            	  4098: 
02:00002896 51CFFFEC        	  4099:                 dbf d7,NBCD_LOOP
                            	  4100: 
02:0000289A 0C8300000001    	  4101:                 cmpi.l #$00000001,d3  * Check the cumulative results
02:000028A0 66FE            	  4102:                 bne.s *
02:000028A2 0C8400000099    	  4103:                 cmpi.l #$00000099,d4
02:000028A8 66FE            	  4104:                 bne.s *
02:000028AA 0C8500002E3B    	  4105:                 cmpi.l #$00002E3B,d5
02:000028B0 66FE            	  4106:                 bne.s *
                            	  4107: 
                            	  4108: 
                            	  4109: *        NBCD to a memory location
                            	  4110: 
02:000028B2 7000            	  4111:                 moveq  #$00000000,d0 * BCD byte
02:000028B4 7200            	  4112:                 moveq  #$00000000,d1
02:000028B6 7400            	  4113:                 moveq  #$00000000,d2
02:000028B8 7600            	  4114:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
02:000028BA 7800            	  4115:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:000028BC 7A00            	  4116:                 moveq  #$00000000,d5 * Cumulative BCD results
02:000028BE 2C3C00000099    	  4117:                 move.l #$00000099,d6
02:000028C4 2E3C00000099    	  4118:                 move.l #$00000099,d7 * Loop counter
                            	  4119: 
02:000028CA 11C70100        	  4120: NBCD_LOOP1:     move.b d7,$00000100
02:000028CE 44FC0004        	  4121:                 move #$04,CCR        * Set Z flag to 0
                            	  4122: 
02:000028D2 48380100        	  4123:                 nbcd $00000100
02:000028D6 10380100        	  4124:                 move.b $00000100,d0
                            	  4125: 
02:000028DA 6402            	  4126:                 bcc.s NBCD_NO_C1        * Check C Flag
02:000028DC 5284            	  4127:                 add.l #1,d4
02:000028DE 6602            	  4128: NBCD_NO_C1:     bne.s NBCD_NO_Z1        * Check Z Flag
02:000028E0 5283            	  4129:                 add.l #1,d3
02:000028E2 DA80            	  4130: NBCD_NO_Z1:     add.l d0,d5         * Add results into d5
                            	  4131: 
02:000028E4 51CFFFE4        	  4132:                 dbf d7,NBCD_LOOP1
                            	  4133: 
02:000028E8 0C8300000001    	  4134:                 cmpi.l #$00000001,d3  * Check the cumulative results
02:000028EE 66FE            	  4135:                 bne.s *
02:000028F0 4A84            	  4136:                 cmpi.l #$00000000,d4
02:000028F2 66FE            	  4137:                 bne.s *
02:000028F4 0C8500002E3B    	  4138:                 cmpi.l #$00002E3B,d5
02:000028FA 66FE            	  4139:                 bne.s *
                            	  4140: 
                            	  4141: 
02:000028FC 4E75            	  4142:                 rts
                            	  4143: 
                            	  4144: 
                            	  4145: 
                            	  4146: *-----------------------------------------------------------
                            	  4147: *-----------------------------------------------------------
                            	  4148: * OPCODE : TRAPV
                            	  4149: *-----------------------------------------------------------
                            	  4150: *-----------------------------------------------------------
                            	  4151: op_TRAPV:
                            	  4152: 
                            	  4153: *     TRAPV will set d0 to 12345678 if V flag is set
                            	  4154: 
02:000028FE 7000            	  4155:                 moveq  #$00000000,d0 * Clear d0
                            	  4156: 
02:00002900 44FC0000        	  4157:                 move #$00,CCR        * Clear V flag
02:00002904 4E76            	  4158:                 trapv
02:00002906 4A80            	  4159:                 cmpi.l #$00000000,d0  * Check of d0 was updated (should not be_)
02:00002908 66FE            	  4160:                 bne.s *
                            	  4161: 
02:0000290A 44FC0002        	  4162:                 move #$02,CCR        * Set V flag
02:0000290E 4E76            	  4163:                 trapv
02:00002910 0C8012345678    	  4164:                 cmpi.l #$12345678,d0  * Check of d0 was updated (should not be_)
02:00002916 66FE            	  4165:                 bne.s *
                            	  4166: 
                            	  4167: 
02:00002918 4E75            	  4168:                 rts
                            	  4169: 
                            	  4170: 
                            	  4171: 
                            	  4172: *-----------------------------------------------------------
                            	  4173: *-----------------------------------------------------------
                            	  4174: * OPCODE : RTR
                            	  4175: *-----------------------------------------------------------
                            	  4176: *-----------------------------------------------------------
                            	  4177: 
                            	  4178: op_RTR:
                            	  4179: 
                            	  4180: *     Leventhal claims only 5 LSB's are popped from the stack to the CCR
                            	  4181: 
02:0000291A 41FA000A        	  4182:                 lea 		RTR_DONE,a0
02:0000291E 2F08            	  4183:                 move.l 	a0,-(a7)     * push destination PC to the stack
02:00002920 3F3CFF15        	  4184:                 move.w 	#$FF15,-(a7)       * push flags=0xFFFF to the stack
02:00002924 4E77            	  4185:                 rtr
                            	  4186: 
02:00002926 40C0            	  4187: RTR_DONE:       move.w SR,d0
02:00002928 0240001F        	  4188:                 andi.w #$1F,d0
02:0000292C 0C400015        	  4189:                 cmpi.w #$15,d0
02:00002930 66FE            	  4190:                 bne.s *
                            	  4191: 
02:00002932 4E75            	  4192:                 rts
                            	  4193: 
                            	  4194: 
02:00002934 283C44444444    	  4195: BSR_FAR2:       move.l #$44444444,d4
02:0000293A 4E75            	  4196:                 rts
                            	  4197: 
                            	  4198: 
                            	  4199: *-----------------------------------------------------------
                            	  4200: *-----------------------------------------------------------
                            	  4201: * OPCODE : BCC
                            	  4202: *-----------------------------------------------------------
                            	  4203: *-----------------------------------------------------------
                            	  4204: 
02:0000293C 44FC0000        	  4205: op_BCC:         move #$00,CCR
02:00002940 6202            	  4206:                 bhi.s BCC1            * Higher Than         C=0 AND Z=0
02:00002942 60FE            	  4207:                 bra.s *
                            	  4208: 
02:00002944 44FC0001        	  4209: BCC1:           move #$01,CCR
02:00002948 63000004        	  4210:                 bls.w BCC2            * Lower or Same       C=1 OR Z=1
02:0000294C 60FE            	  4211:                 bra.s *
                            	  4212: 
02:0000294E 44FC0000        	  4213: BCC2:           move #$00,CCR
02:00002952 6402            	  4214:                 bcc.s BCC3            * Carry Clear         C=0
02:00002954 60FE            	  4215:                 bra.s *
                            	  4216: 
02:00002956 44FC0001        	  4217: BCC3:           move #$01,CCR
02:0000295A 65000004        	  4218:                 bcs.w BCC4            * Carry Set           C=1
02:0000295E 60FE            	  4219:                 bra.s *
                            	  4220: 
02:00002960 44FC0000        	  4221: BCC4:           move #$00,CCR
02:00002964 6602            	  4222:                 bne.s BCC5            * Not Equal           Z=0
02:00002966 60FE            	  4223:                 bra.s *
                            	  4224: 
02:00002968 44FC0004        	  4225: BCC5:           move #$04,CCR
02:0000296C 67000004        	  4226:                 beq.w BCC6            * Equal               Z=1
02:00002970 60FE            	  4227:                 bra.s *
                            	  4228: 
02:00002972 44FC0000        	  4229: BCC6:           move #$00,CCR
02:00002976 6802            	  4230:                 bvc.s BCC7            * V Clear             V=0
02:00002978 60FE            	  4231:                 bra.s *
                            	  4232: 
02:0000297A 44FC0002        	  4233: BCC7:           move #$02,CCR
02:0000297E 69000004        	  4234:                 bvs.w BCC8            * V Set               V=1
02:00002982 60FE            	  4235:                 bra.s *
                            	  4236: 
02:00002984 44FC0000        	  4237: BCC8:           move #$00,CCR
02:00002988 6A02            	  4238:                 bpl.s BCC9            * Plus                N=0
02:0000298A 60FE            	  4239:                 bra.s *
                            	  4240: 
02:0000298C 44FC0008        	  4241: BCC9:           move #$08,CCR
02:00002990 6B000004        	  4242:                 bmi.w BCC10           * Minus               N=1
02:00002994 60FE            	  4243:                 bra.s *
                            	  4244: 
02:00002996 44FC0000        	  4245: BCC10:          move #$00,CCR
02:0000299A 6C02            	  4246:                 bge.s BCC11           * Greater or Equal    N=V
02:0000299C 60FE            	  4247:                 bra.s *
                            	  4248: 
02:0000299E 44FC0002        	  4249: BCC11:          move #$02,CCR
02:000029A2 6D000004        	  4250:                 blt.w BCC12           * Less Than           N!=V
02:000029A6 60FE            	  4251:                 bra.s *
                            	  4252: 
02:000029A8 44FC000A        	  4253: BCC12:          move #$0A,CCR
02:000029AC 6E02            	  4254:                 bgt.s BCC13           * Greater Than        N=V  AND Z=0
02:000029AE 60FE            	  4255:                 bra.s *
                            	  4256: 
02:000029B0 44FC0006        	  4257: BCC13:          move #$06,CCR
02:000029B4 6F000004        	  4258:                 ble.w BCC14           * Less Than or Equal  N!=V AND Z=1
02:000029B8 60FE            	  4259:                 bra.s *
                            	  4260: 
                            	  4261: 
02:000029BA 4E75            	  4262: BCC14:          rts
                            	  4263: 
                            	  4264: 
                            	  4265: *-----------------------------------------------------------
                            	  4266: *-----------------------------------------------------------
                            	  4267: * OPCODE : DBCC
                            	  4268: *-----------------------------------------------------------
                            	  4269: *-----------------------------------------------------------
                            	  4270: 
02:000029BC 7003            	  4271: op_DBCC:        moveq  #$00000003,d0    * Loop counter
02:000029BE 7200            	  4272:                 moveq  #$00000000,d1    * Accumulator
02:000029C0 44FC0000        	  4273:                 move #$00,CCR
                            	  4274: 
02:000029C4 5201            	  4275: DBCC_LOOP1:     addi.b #$1,d1
02:000029C6 51C8FFFC        	  4276:                 dbf d0,DBCC_LOOP1
                            	  4277: 
02:000029CA 0C8100000004    	  4278:                 cmpi.l #$00000004,d1  * Check Accumulator results
02:000029D0 66FE            	  4279:                 bne.s *
                            	  4280: 
02:000029D2 5201            	  4281: DBCC_LOOP2:     addi.b #$1,d1
02:000029D4 54C8FFFC        	  4282:                 dbcc d0,DBCC_LOOP2    * Dont loop
                            	  4283: 
02:000029D8 0C8100000005    	  4284:                 cmpi.l #$00000005,d1  * Check Accumulator results
02:000029DE 66FE            	  4285:                 bne.s *
                            	  4286: 
02:000029E0 4E75            	  4287:                 rts
                            	  4288: 
                            	  4289: 
                            	  4290: *-----------------------------------------------------------
                            	  4291: *-----------------------------------------------------------
                            	  4292: * OPCODE : SCC
                            	  4293: *-----------------------------------------------------------
                            	  4294: *-----------------------------------------------------------
                            	  4295: 
02:000029E2 44FC0001        	  4296: op_SCC:         move #$01,CCR
02:000029E6 54F900010000    	  4297:                 scc $00010000                   * Clear the EA byte
02:000029EC 4A3900010000    	  4298:                 cmpi.b #$00,$00010000
02:000029F2 66FE            	  4299:                 bne.s *
                            	  4300: 
02:000029F4 44FC0000        	  4301:                 move #$00,CCR
02:000029F8 54F900010000    	  4302:                 scc $00010000                   * Set the EA byte to 0xFF
02:000029FE 0C3900FF00010000	  4303:                 cmpi.b #$FF,$00010000
02:00002A06 66FE            	  4304:                 bne.s *
                            	  4305: 
02:00002A08 54C0            	  4306: 								scc d0													* Test setting a data register
02:00002A0A 0C0000FF        	  4307: 								cmpi.b #$FF,d0
02:00002A0E 66FE            	  4308: 								bne.s *
02:00002A10 4E75            	  4309:                 rts
                            	  4310: 
                            	  4311: 
                            	  4312: 
                            	  4313: *-----------------------------------------------------------
                            	  4314: *-----------------------------------------------------------
                            	  4315: * OPCODE : ADDQ
                            	  4316: *-----------------------------------------------------------
                            	  4317: *-----------------------------------------------------------
                            	  4318: 
                            	  4319: op_ADDQ:
                            	  4320: 
                            	  4321: *     BYTE
02:00002A12 203C000000FF    	  4322:                 move.l #$000000FF,d0    * Loop counter
02:00002A18 7200            	  4323:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002A1A 7400            	  4324:                 moveq  #$00000000,d2    * Data results accumulator
02:00002A1C 7600            	  4325:                 moveq  #$00000000,d3
02:00002A1E 7800            	  4326:                 moveq  #$00000000,d4
02:00002A20 7A00            	  4327:                 moveq  #$00000000,d5
02:00002A22 7C00            	  4328:                 moveq  #$00000000,d6
02:00002A24 7E00            	  4329:                 moveq  #$00000000,d7
                            	  4330: 
02:00002A26 5605            	  4331: ADDQ_LOOP1:     addq.b #3,d5
02:00002A28 40C6            	  4332:                 move.w SR,d6
02:00002A2A 02860000001F    	  4333:                 andi.l #$1F,d6        * Isolate flags
02:00002A30 D286            	  4334:                 add.l d6,d1           * Copy flag results into accumulator
02:00002A32 D485            	  4335:                 add.l d5,d2           * Copy data results into data accumulator
02:00002A34 51C8FFF0        	  4336:                 dbf d0,ADDQ_LOOP1
                            	  4337: 
02:00002A38 0C810000043D    	  4338:                 cmpi.l #$0000043D,d1
02:00002A3E 66FE            	  4339:                 bne.s *
02:00002A40 0C8200007F80    	  4340:                 cmpi.l #$00007F80,d2
02:00002A46 66FE            	  4341:                 bne.s *
                            	  4342: 
                            	  4343: 
                            	  4344: *     WORD
02:00002A48 203C000000FF    	  4345:                 move.l #$000000FF,d0    * Loop counter
02:00002A4E 7200            	  4346:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002A50 7400            	  4347:                 moveq  #$00000000,d2    * Data results accumulator
02:00002A52 7600            	  4348:                 moveq  #$00000000,d3
02:00002A54 7800            	  4349:                 moveq  #$00000000,d4
02:00002A56 2A3C0000FFF0    	  4350:                 move.l #$0000FFF0,d5
02:00002A5C 7C00            	  4351:                 moveq  #$00000000,d6
02:00002A5E 7E00            	  4352:                 moveq  #$00000000,d7
02:00002A60 307C0100        	  4353:                 move.l #$00000100,a0
                            	  4354: 
02:00002A64 5A45            	  4355: ADDQ_LOOP2:     addq.w #5,d5
02:00002A66 40C6            	  4356:                 move.w SR,d6
02:00002A68 02860000001F    	  4357:                 andi.l #$1F,d6        * Isolate flags
02:00002A6E D286            	  4358:                 add.l d6,d1           * Copy flag results into accumulator
02:00002A70 D485            	  4359:                 add.l d5,d2           * Copy data results into data accumulator
02:00002A72 51C8FFF0        	  4360:                 dbf d0,ADDQ_LOOP2
                            	  4361: 
02:00002A76 0C8100000029    	  4362:                 cmpi.l #$00000029,d1
02:00002A7C 66FE            	  4363:                 bne.s *
02:00002A7E 0C8200057280    	  4364:                 cmpi.l #$00057280,d2
02:00002A84 66FE            	  4365:                 bne.s *
                            	  4366: 
                            	  4367: 
                            	  4368: *     LONG
02:00002A86 203C000000FF    	  4369:                 move.l #$000000FF,d0    * Loop counter
02:00002A8C 7200            	  4370:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002A8E 7400            	  4371:                 moveq  #$00000000,d2    * Data results accumulator
02:00002A90 7600            	  4372:                 moveq  #$00000000,d3
02:00002A92 7800            	  4373:                 moveq  #$00000000,d4
02:00002A94 7AF0            	  4374:                 move.l #$FFFFFFF0,d5
02:00002A96 7C00            	  4375:                 moveq  #$00000000,d6
02:00002A98 7E00            	  4376:                 moveq  #$00000000,d7
                            	  4377: 
02:00002A9A 5285            	  4378: ADDQ_LOOP3:     addq.l #1,d5
02:00002A9C 40C6            	  4379:                 move.w SR,d6
02:00002A9E 02860000001F    	  4380:                 andi.l #$1F,d6        * Isolate flags
02:00002AA4 D286            	  4381:                 add.l d6,d1           * Copy flag results into accumulator
02:00002AA6 D485            	  4382:                 add.l d5,d2           * Copy data results into data accumulator
02:00002AA8 51C8FFF0        	  4383:                 dbf d0,ADDQ_LOOP3
                            	  4384: 
02:00002AAC 0C810000008D    	  4385:                 cmpi.l #$0000008D,d1
02:00002AB2 66FE            	  4386:                 bne.s *
02:00002AB4 0C8200007080    	  4387:                 cmpi.l #$00007080,d2
02:00002ABA 66FE            	  4388:                 bne.s *
                            	  4389: 
                            	  4390: *     Check that Flags are not updated for Address registers
02:00002ABC 207C0000FFFF    	  4391:                 move.l #$0000FFFF,a0
02:00002AC2 44FC0000        	  4392:                 move #$00,CCR         * Clear flags
02:00002AC6 5E48            	  4393:                 addq.w #$7,a0
02:00002AC8 65FE            	  4394:                 bcs.s *
                            	  4395: 
02:00002ACA 4E75            	  4396:                 rts
                            	  4397: 
                            	  4398: 
                            	  4399: 
                            	  4400: *-----------------------------------------------------------
                            	  4401: *-----------------------------------------------------------
                            	  4402: * OPCODE : SUBQ
                            	  4403: *-----------------------------------------------------------
                            	  4404: *-----------------------------------------------------------
                            	  4405: 
                            	  4406: op_SUBQ:
                            	  4407: 
                            	  4408: *     BYTE
02:00002ACC 203C000000FF    	  4409:                 move.l #$000000FF,d0    * Loop counter
02:00002AD2 7200            	  4410:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002AD4 243C00001234    	  4411:                 move.l #$00001234,d2    * Data results accumulator
02:00002ADA 7600            	  4412:                 moveq  #$00000000,d3
02:00002ADC 7800            	  4413:                 moveq  #$00000000,d4
02:00002ADE 7A12            	  4414:                 moveq  #$00000012,d5
02:00002AE0 7C00            	  4415:                 moveq  #$00000000,d6
02:00002AE2 7E00            	  4416:                 moveq  #$00000000,d7
                            	  4417: 
02:00002AE4 5305            	  4418: SUBQ_LOOP1:     subq.b #1,d5
02:00002AE6 40C6            	  4419:                 move.w SR,d6
02:00002AE8 02860000001F    	  4420:                 andi.l #$1F,d6        * Isolate flags
02:00002AEE D286            	  4421:                 add.l d6,d1           * Copy flag results into accumulator
02:00002AF0 D485            	  4422:                 add.l d5,d2           * Copy data results into data accumulator
02:00002AF2 51C8FFF0        	  4423:                 dbf d0,SUBQ_LOOP1
                            	  4424: 
02:00002AF6 0C8100000417    	  4425:                 cmpi.l #$00000417,d1
02:00002AFC 66FE            	  4426:                 bne.s *
02:00002AFE 0C82000091B4    	  4427:                 cmpi.l #$000091B4,d2
02:00002B04 66FE            	  4428:                 bne.s *
                            	  4429: 
                            	  4430: 
                            	  4431: *     WORD
02:00002B06 203C000000FF    	  4432:                 move.l #$000000FF,d0    * Loop counter
02:00002B0C 7200            	  4433:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002B0E 7400            	  4434:                 moveq  #$00000000,d2    * Data results accumulator
02:00002B10 7600            	  4435:                 moveq  #$00000000,d3
02:00002B12 7800            	  4436:                 moveq  #$00000000,d4
02:00002B14 7A02            	  4437:                 moveq  #$00000002,d5
02:00002B16 7C00            	  4438:                 moveq  #$00000000,d6
02:00002B18 7E00            	  4439:                 moveq  #$00000000,d7
02:00002B1A 307C0100        	  4440:                 move.l #$00000100,a0
                            	  4441: 
02:00002B1E 5B45            	  4442: SUBQ_LOOP2:     subq.w #5,d5
02:00002B20 40C6            	  4443:                 move.w SR,d6
02:00002B22 02860000001F    	  4444:                 andi.l #$1F,d6        * Isolate flags
02:00002B28 D286            	  4445:                 add.l d6,d1           * Copy flag results into accumulator
02:00002B2A D485            	  4446:                 add.l d5,d2           * Copy data results into data accumulator
02:00002B2C 51C8FFF0        	  4447:                 dbf d0,SUBQ_LOOP2
                            	  4448: 
02:00002B30 0C8100000811    	  4449:                 cmpi.l #$00000811,d1
02:00002B36 66FE            	  4450:                 bne.s *
02:00002B38 0C8200FD7F80    	  4451:                 cmpi.l #$00FD7F80,d2
02:00002B3E 66FE            	  4452:                 bne.s *
                            	  4453: 
                            	  4454: 
                            	  4455: *     LONG
02:00002B40 203C000000FF    	  4456:                 move.l #$000000FF,d0    * Loop counter
02:00002B46 7200            	  4457:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002B48 7400            	  4458:                 moveq  #$00000000,d2    * Data results accumulator
02:00002B4A 7600            	  4459:                 moveq  #$00000000,d3
02:00002B4C 7800            	  4460:                 moveq  #$00000000,d4
02:00002B4E 7A07            	  4461:                 moveq  #$00000007,d5
02:00002B50 7C00            	  4462:                 moveq  #$00000000,d6
02:00002B52 7E00            	  4463:                 moveq  #$00000000,d7
                            	  4464: 
02:00002B54 5385            	  4465: SUBQ_LOOP3:     subq.l #1,d5
02:00002B56 40C6            	  4466:                 move.w SR,d6
02:00002B58 02860000001F    	  4467:                 andi.l #$1F,d6        * Isolate flags
02:00002B5E D286            	  4468:                 add.l d6,d1           * Copy flag results into accumulator
02:00002B60 D485            	  4469:                 add.l d5,d2           * Copy data results into data accumulator
02:00002B62 51C8FFF0        	  4470:                 dbf d0,SUBQ_LOOP3
                            	  4471: 
02:00002B66 0C81000007DD    	  4472:                 cmpi.l #$000007DD,d1
02:00002B6C 66FE            	  4473:                 bne.s *
02:00002B6E 0C82FFFF8680    	  4474:                 cmpi.l #$FFFF8680,d2
02:00002B74 66FE            	  4475:                 bne.s *
                            	  4476: 
                            	  4477: *     Check that Flags are not updated for Address registers
02:00002B76 207C0001FFFF    	  4478:                 move.l #$0001FFFF,a0
02:00002B7C 44FC0000        	  4479:                 move #$00,CCR         * Clear flags
02:00002B80 5F48            	  4480:                 subq.w #$7,a0
02:00002B82 65FE            	  4481:                 bcs.s *
                            	  4482: 
02:00002B84 4E75            	  4483:                 rts
                            	  4484: 
                            	  4485: 
                            	  4486: 
                            	  4487: 
                            	  4488: *-----------------------------------------------------------
                            	  4489: *-----------------------------------------------------------
                            	  4490: * OPCODE : MOVEQ
                            	  4491: *-----------------------------------------------------------
                            	  4492: *-----------------------------------------------------------
                            	  4493: 
                            	  4494: op_MOVEQ:
02:00002B86 7000            	  4495:                 moveq  #$00000000,d0
02:00002B88 7000            	  4496:                 moveq #$0,d0
02:00002B8A 66FE            	  4497:                 bne.s *
02:00002B8C 4A80            	  4498:                 cmpi.l #$00000000,d0
02:00002B8E 66FE            	  4499:                 bne.s *
                            	  4500: 
02:00002B90 7000            	  4501:                 moveq  #$00000000,d0
02:00002B92 7080            	  4502:                 moveq #-128,d0
02:00002B94 67FE            	  4503:                 beq.s *
02:00002B96 6AFE            	  4504:                 bpl.s *
02:00002B98 0C80FFFFFF80    	  4505:                 cmpi.l #$FFFFFF80,d0
02:00002B9E 66FE            	  4506:                 bne.s *
                            	  4507: 
                            	  4508: 
02:00002BA0 4E75            	  4509:                 rts
                            	  4510: 
                            	  4511: 
                            	  4512: *-----------------------------------------------------------
                            	  4513: *-----------------------------------------------------------
                            	  4514: * OPCODE : DIVU
                            	  4515: *-----------------------------------------------------------
                            	  4516: *-----------------------------------------------------------
                            	  4517: 
                            	  4518: op_DIVU:
                            	  4519: 
02:00002BA2 203CA5A5A5A5    	  4520:                 move.l #$a5a5a5a5,d0        * Initial Numerator
02:00002BA8 223C00005A5A    	  4521:                 move.l #$00005a5a,d1        * Initial Divisor
02:00002BAE 243CA5A5A5A5    	  4522:                 move.l #$a5a5a5a5,d2
02:00002BB4 7600            	  4523:                 moveq  #$00000000,d3
02:00002BB6 7800            	  4524:                 moveq  #$00000000,d4        * Cumulative data results
02:00002BB8 7A00            	  4525:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002BBA 7C0E            	  4526:                 move.l #$0000000E,d6       * Inner loop counter
02:00002BBC 7E1E            	  4527:                 move.l #$0000001E,d7       * Outer loop counter
                            	  4528: 
                            	  4529: 
02:00002BBE 80C1            	  4530: DIVU_OUTER1:    divu d1,d0               * !! Easy68K C not always cleared
02:00002BC0 40C3            	  4531:                 move.w SR,d3
02:00002BC2 02830000000C    	  4532:                 andi.l #$0C,d3            * Isolate flags
02:00002BC8 DA83            	  4533:                 add.l d3,d5               * Copy flag results into accumulator
02:00002BCA D880            	  4534:                 add.l d0,d4               * Copy data results into data accumulator
02:00002BCC E289            	  4535:                 lsr.l #$1,d1
                            	  4536: 
02:00002BCE 51CEFFEE        	  4537:                 dbf d6,DIVU_OUTER1
02:00002BD2 E28A            	  4538:                 lsr.l #$1,d2
02:00002BD4 2002            	  4539:                 move.l d2,d0
02:00002BD6 223C00005A5A    	  4540:                 move.l #$00005a5a,d1       * Initial Divisor
02:00002BDC 7C0E            	  4541:                 move.l #$0000000E,d6       * Inner loop counter
02:00002BDE 51CFFFDE        	  4542:                 dbf d7,DIVU_OUTER1
                            	  4543: 
02:00002BE2 0C8492FEDB89    	  4544:                 cmpi.l #$92FEDB89,d4      * Check the data results
02:00002BE8 66FE            	  4545:                 bne.s *
                            	  4546: 
02:00002BEA 0C8500000110    	  4547:                 cmpi.l #$00000110,d5      * Check the Flag results
02:00002BF0 66FE            	  4548:                 bne.s *
                            	  4549: 
                            	  4550: 
02:00002BF2 4E75            	  4551:                 rts
                            	  4552: 
                            	  4553: 
                            	  4554: 
                            	  4555: *-----------------------------------------------------------
                            	  4556: *-----------------------------------------------------------
                            	  4557: * OPCODE : DIVS
                            	  4558: *-----------------------------------------------------------
                            	  4559: *-----------------------------------------------------------
                            	  4560: 
                            	  4561: op_DIVS:
                            	  4562: 
02:00002BF4 203CA5A5A5A5    	  4563:                 move.l #$a5a5a5a5,d0        * Initial Numerator
02:00002BFA 223C00005A5A    	  4564:                 move.l #$00005a5a,d1        * Initial Divisor
02:00002C00 243CA5A5A5A5    	  4565:                 move.l #$a5a5a5a5,d2
02:00002C06 7600            	  4566:                 moveq  #$00000000,d3
02:00002C08 7800            	  4567:                 moveq  #$00000000,d4        * Cumulative data results
02:00002C0A 7A00            	  4568:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002C0C 7C0E            	  4569:                 move.l #$0000000E,d6       * Inner loop counter
02:00002C0E 7E1E            	  4570:                 move.l #$0000001E,d7       * Outer loop counter
                            	  4571: 
                            	  4572: 
02:00002C10 81C1            	  4573: DIVS_OUTER1:    divs d1,d0               * !! Easy68K C not always cleared
02:00002C12 40C3            	  4574:                 move.w SR,d3
02:00002C14 02830000000C    	  4575:                 andi.l #$0C,d3            * Isolate flags
02:00002C1A DA83            	  4576:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C1C D880            	  4577:                 add.l d0,d4               * Copy data results into data accumulator
02:00002C1E E289            	  4578:                 lsr.l #$1,d1
                            	  4579: 
02:00002C20 51CEFFEE        	  4580:                 dbf d6,DIVS_OUTER1
02:00002C24 E28A            	  4581:                 lsr.l #$1,d2
02:00002C26 2002            	  4582:                 move.l d2,d0
02:00002C28 223C00005A5A    	  4583:                 move.l #$00005a5a,d1       * Initial Divisor
02:00002C2E 7C0E            	  4584:                 move.l #$0000000E,d6       * Inner loop counter
02:00002C30 51CFFFDE        	  4585:                 dbf d7,DIVS_OUTER1
                            	  4586: 
02:00002C34 0C844EC5D057    	  4587:                 cmpi.l #$4EC5D057,d4      * Check the data results
02:00002C3A 66FE            	  4588:                 bne.s *
                            	  4589: 
02:00002C3C 0C8500000038    	  4590:                 cmpi.l #$00000038,d5      * Check the Flag results
02:00002C42 66FE            	  4591:                 bne.s *
                            	  4592: 
                            	  4593: 
02:00002C44 4E75            	  4594:                 rts
                            	  4595: 
                            	  4596: 
                            	  4597: 
                            	  4598: *-----------------------------------------------------------
                            	  4599: *-----------------------------------------------------------
                            	  4600: * OPCODE : OR
                            	  4601: *-----------------------------------------------------------
                            	  4602: *-----------------------------------------------------------
                            	  4603: 
                            	  4604: op_OR:
                            	  4605: 
                            	  4606: *  * <EA> to Register
                            	  4607: 
02:00002C46 203CA5A5A5A5    	  4608:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002C4C 223C8167E123    	  4609:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002C52 243CA5A5A5A5    	  4610:                 move.l #$a5a5a5a5,d2
02:00002C58 7600            	  4611:                 moveq  #$00000000,d3
02:00002C5A 7800            	  4612:                 moveq  #$00000000,d4       * Cumulative data results
02:00002C5C 7A00            	  4613:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002C5E 7C1E            	  4614:                 move.l #$0000001E,d6       * Inner loop counter
02:00002C60 7E1E            	  4615:                 move.l #$0000001E,d7       * Outer loop counter
02:00002C62 307C0100        	  4616:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4617: 
                            	  4618: 
                            	  4619: OR_OUTER1:
                            	  4620: 
                            	  4621: *     BYTE
02:00002C66 2081            	  4622:                 move.l d1,(a0)
02:00002C68 8010            	  4623:                 or.b (a0),d0
02:00002C6A 40C3            	  4624:                 move.w SR,d3
02:00002C6C 02830000000C    	  4625:                 andi.l #$0C,d3            * Isolate flags
02:00002C72 DA83            	  4626:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C74 D880            	  4627:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4628: 
                            	  4629: *     WORD
02:00002C76 2081            	  4630:                 move.l d1,(a0)
02:00002C78 8050            	  4631:                 or.w (a0),d0
02:00002C7A 40C3            	  4632:                 move.w SR,d3
02:00002C7C 02830000000C    	  4633:                 andi.l #$0C,d3            * Isolate flags
02:00002C82 DA83            	  4634:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C84 D880            	  4635:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4636: 
                            	  4637: *     LONG
02:00002C86 2081            	  4638:                 move.l d1,(a0)
02:00002C88 8090            	  4639:                 or.l (a0),d0
02:00002C8A 40C3            	  4640:                 move.w SR,d3
02:00002C8C 02830000000F    	  4641:                 andi.l #$0F,d3            * Isolate flags
02:00002C92 DA83            	  4642:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C94 D880            	  4643:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4644: 
                            	  4645: 
02:00002C96 E289            	  4646:                 lsr.l #$1,d1
02:00002C98 51CEFFCC        	  4647:                 dbf d6,OR_OUTER1
02:00002C9C E28A            	  4648:                 lsr.l #$1,d2
02:00002C9E 223C8167E123    	  4649:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002CA4 7C1E            	  4650:                 move.l #$0000001E,d6       * Inner loop counter
02:00002CA6 51CFFFBE        	  4651:                 dbf d7,OR_OUTER1
                            	  4652: 
02:00002CAA 0C8476EAC803    	  4653:                 cmpi.l #$76EAC803,d4      * Check the data results
02:00002CB0 66FE            	  4654:                 bne.s *
02:00002CB2 0C8500005A18    	  4655:                 cmpi.l #$00005A18,d5      * Check the Flag results
02:00002CB8 66FE            	  4656:                 bne.s *
                            	  4657: 
                            	  4658: 
                            	  4659: *  * Register to <EA>
                            	  4660: 
02:00002CBA 203C86738374    	  4661:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00002CC0 223CFC55F2FE    	  4662:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00002CC6 243C86738374    	  4663:                 move.l #$86738374,d2
02:00002CCC 7600            	  4664:                 moveq  #$00000000,d3
02:00002CCE 7800            	  4665:                 moveq  #$00000000,d4       * Cumulative data results
02:00002CD0 7A00            	  4666:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002CD2 7C1E            	  4667:                 move.l #$0000001E,d6       * Inner loop counter
02:00002CD4 7E1D            	  4668:                 move.l #$0000001D,d7       * Outer loop counter
02:00002CD6 307C0100        	  4669:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4670: 
                            	  4671: 
                            	  4672: OR_OUTER2:
                            	  4673: 
                            	  4674: *     BYTE
02:00002CDA 2080            	  4675:                 move.l d0,(a0)
02:00002CDC 8310            	  4676:                 or.b d1,(a0)
02:00002CDE 40C3            	  4677:                 move.w SR,d3
02:00002CE0 02830000000C    	  4678:                 andi.l #$0C,d3            * Isolate flags
02:00002CE6 DA83            	  4679:                 add.l d3,d5               * Copy flag results into accumulator
02:00002CE8 D890            	  4680:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4681: 
                            	  4682: *     WORD
02:00002CEA 2080            	  4683:                 move.l d0,(a0)
02:00002CEC 8350            	  4684:                 or.w d1,(a0)
02:00002CEE 40C3            	  4685:                 move.w SR,d3
02:00002CF0 02830000000C    	  4686:                 andi.l #$0C,d3            * Isolate flags
02:00002CF6 DA83            	  4687:                 add.l d3,d5               * Copy flag results into accumulator
02:00002CF8 D890            	  4688:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4689: 
                            	  4690: *     LONG
02:00002CFA 2080            	  4691:                 move.l d0,(a0)
02:00002CFC 8390            	  4692:                 or.l d1,(a0)
02:00002CFE 40C3            	  4693:                 move.w SR,d3
02:00002D00 02830000000F    	  4694:                 andi.l #$0F,d3            * Isolate flags
02:00002D06 DA83            	  4695:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D08 D890            	  4696:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4697: 
                            	  4698: 
02:00002D0A E289            	  4699:                 lsr.l #$1,d1
02:00002D0C 51CEFFCC        	  4700:                 dbf d6,OR_OUTER2
02:00002D10 E28A            	  4701:                 lsr.l #$1,d2
02:00002D12 223C8167E123    	  4702:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002D18 7C1E            	  4703:                 move.l #$0000001E,d6       * Inner loop counter
02:00002D1A 51CFFFBE        	  4704:                 dbf d7,OR_OUTER2
                            	  4705: 
02:00002D1E 0C84FA82B9E4    	  4706:                 cmpi.l #$FA82B9E4,d4      * Check the data results
02:00002D24 66FE            	  4707:                 bne.s *
02:00002D26 0C8500005730    	  4708:                 cmpi.l #$00005730,d5      * Check the Flag results
02:00002D2C 66FE            	  4709:                 bne.s *
                            	  4710: 
                            	  4711: 
02:00002D2E 4E75            	  4712:                 rts
                            	  4713: 
                            	  4714: 
                            	  4715: 
                            	  4716: *-----------------------------------------------------------
                            	  4717: *-----------------------------------------------------------
                            	  4718: * OPCODE : AND
                            	  4719: *-----------------------------------------------------------
                            	  4720: *-----------------------------------------------------------
                            	  4721: 
                            	  4722: op_AND:
                            	  4723: 
                            	  4724: *  * <EA> to Register
                            	  4725: 
02:00002D30 203CA5A5A5A5    	  4726:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002D36 223C8167E123    	  4727:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002D3C 243CA5A5A5A5    	  4728:                 move.l #$a5a5a5a5,d2
02:00002D42 7600            	  4729:                 moveq  #$00000000,d3
02:00002D44 7800            	  4730:                 moveq  #$00000000,d4       * Cumulative data results
02:00002D46 7A00            	  4731:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002D48 7C1E            	  4732:                 move.l #$0000001E,d6       * Inner loop counter
02:00002D4A 7E1E            	  4733:                 move.l #$0000001E,d7       * Outer loop counter
02:00002D4C 307C0100        	  4734:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4735: 
                            	  4736: 
                            	  4737: AND_OUTER1:
                            	  4738: 
                            	  4739: *     BYTE
02:00002D50 2081            	  4740:                 move.l d1,(a0)
02:00002D52 C010            	  4741:                 and.b (a0),d0
02:00002D54 40C3            	  4742:                 move.w sr,d3
02:00002D56 02830000000C    	  4743:                 andi.l #$0C,d3            * Isolate flags
02:00002D5C DA83            	  4744:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D5E D880            	  4745:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4746: 
                            	  4747: *     WORD
02:00002D60 2081            	  4748:                 move.l d1,(a0)
02:00002D62 C050            	  4749:                 and.w (a0),d0
02:00002D64 40C3            	  4750:                 move.w sr,d3
02:00002D66 02830000000C    	  4751:                 andi.l #$0C,d3            * Isolate flags
02:00002D6C DA83            	  4752:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D6E D880            	  4753:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4754: 
                            	  4755: *     LONG
02:00002D70 2081            	  4756:                 move.l d1,(a0)
02:00002D72 C090            	  4757:                 and.l (a0),d0
02:00002D74 40C3            	  4758:                 move.w sr,d3
02:00002D76 02830000000F    	  4759:                 andi.l #$0F,d3            * Isolate flags
02:00002D7C DA83            	  4760:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D7E D880            	  4761:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4762: 
                            	  4763: 
02:00002D80 E289            	  4764:                 lsr.l #$1,d1
02:00002D82 51CEFFCC        	  4765:                 dbf d6,AND_OUTER1
02:00002D86 E28A            	  4766:                 lsr.l #$1,d2
02:00002D88 223C8167E123    	  4767:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002D8E 7C1E            	  4768:                 move.l #$0000001E,d6       * Inner loop counter
02:00002D90 51CFFFBE        	  4769:                 dbf d7,AND_OUTER1
                            	  4770: 
02:00002D94 0C84CF212883    	  4771:                 cmpi.l #$CF212883,d4      * Check the data results
02:00002D9A 66FE            	  4772:                 bne.s *
02:00002D9C 0C8500002D10    	  4773:                 cmpi.l #$00002D10,d5      * Check the Flag results
02:00002DA2 66FE            	  4774:                 bne.s *
                            	  4775: 
                            	  4776: 
                            	  4777: *  * Register to <EA>
                            	  4778: 
02:00002DA4 203C86738374    	  4779:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00002DAA 223CFC55F2FE    	  4780:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00002DB0 243C86738374    	  4781:                 move.l #$86738374,d2
02:00002DB6 7600            	  4782:                 moveq  #$00000000,d3
02:00002DB8 7800            	  4783:                 moveq  #$00000000,d4       * Cumulative data results
02:00002DBA 7A00            	  4784:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002DBC 7C1E            	  4785:                 move.l #$0000001E,d6       * Inner loop counter
02:00002DBE 7E1D            	  4786:                 move.l #$0000001D,d7       * Outer loop counter
02:00002DC0 307C0100        	  4787:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4788: 
                            	  4789: 
                            	  4790: AND_OUTER2:
                            	  4791: 
                            	  4792: *     BYTE
02:00002DC4 2080            	  4793:                 move.l d0,(a0)
02:00002DC6 C310            	  4794:                 and.b d1,(a0)
02:00002DC8 40C3            	  4795:                 move.w sr,d3
02:00002DCA 02830000000C    	  4796:                 andi.l #$0C,d3            * Isolate flags
02:00002DD0 DA83            	  4797:                 add.l d3,d5               * Copy flag results into accumulator
02:00002DD2 D890            	  4798:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4799: 
                            	  4800: *     WORD
02:00002DD4 2080            	  4801:                 move.l d0,(a0)
02:00002DD6 C350            	  4802:                 and.w d1,(a0)
02:00002DD8 40C3            	  4803:                 move.w sr,d3
02:00002DDA 02830000000C    	  4804:                 andi.l #$0C,d3            * Isolate flags
02:00002DE0 DA83            	  4805:                 add.l d3,d5               * Copy flag results into accumulator
02:00002DE2 D890            	  4806:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4807: 
                            	  4808: *     LONG
02:00002DE4 2080            	  4809:                 move.l d0,(a0)
02:00002DE6 C390            	  4810:                 and.l d1,(a0)
02:00002DE8 40C3            	  4811:                 move.w sr,d3
02:00002DEA 02830000000F    	  4812:                 andi.l #$0F,d3            * Isolate flags
02:00002DF0 DA83            	  4813:                 add.l d3,d5               * Copy flag results into accumulator
02:00002DF2 D890            	  4814:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4815: 
                            	  4816: 
02:00002DF4 E289            	  4817:                 lsr.l #$1,d1
02:00002DF6 51CEFFCC        	  4818:                 dbf d6,AND_OUTER2
02:00002DFA E28A            	  4819:                 lsr.l #$1,d2
02:00002DFC 223C8167E123    	  4820:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002E02 7C1E            	  4821:                 move.l #$0000001E,d6       * Inner loop counter
02:00002E04 51CFFFBE        	  4822:                 dbf d7,AND_OUTER2
                            	  4823: 
02:00002E08 0C844A3DE544    	  4824:                 cmpi.l #$4A3DE544,d4      * Check the data results
02:00002E0E 66FE            	  4825:                 bne.s *
02:00002E10 0C85000018E8    	  4826:                 cmpi.l #$000018E8,d5      * Check the Flag results
02:00002E16 66FE            	  4827:                 bne.s *
                            	  4828: 
                            	  4829: 
02:00002E18 4E75            	  4830:                 rts
                            	  4831: 
                            	  4832: 
                            	  4833: 
                            	  4834: *-----------------------------------------------------------
                            	  4835: *-----------------------------------------------------------
                            	  4836: * OPCODE : EOR
                            	  4837: *-----------------------------------------------------------
                            	  4838: *-----------------------------------------------------------
                            	  4839: 
                            	  4840: op_EOR:
                            	  4841: 
                            	  4842: *  * Register to <EA>
                            	  4843: 
02:00002E1A 203C86738374    	  4844:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00002E20 223CFC55F2FE    	  4845:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00002E26 243C86738374    	  4846:                 move.l #$86738374,d2
02:00002E2C 7600            	  4847:                 moveq  #$00000000,d3
02:00002E2E 7800            	  4848:                 moveq  #$00000000,d4       * Cumulative data results
02:00002E30 7A00            	  4849:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002E32 7C1E            	  4850:                 move.l #$0000001E,d6       * Inner loop counter
02:00002E34 7E1D            	  4851:                 move.l #$0000001D,d7       * Outer loop counter
02:00002E36 307C0100        	  4852:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4853: 
                            	  4854: 
                            	  4855: EOR_OUTER2:
                            	  4856: 
                            	  4857: *     BYTE
02:00002E3A 2080            	  4858:                 move.l d0,(a0)
02:00002E3C B310            	  4859:                 eor.b d1,(a0)
02:00002E3E 40C3            	  4860:                 move.w sr,d3
02:00002E40 02830000000C    	  4861:                 andi.l #$0C,d3            * Isolate flags
02:00002E46 DA83            	  4862:                 add.l d3,d5               * Copy flag results into accumulator
02:00002E48 D890            	  4863:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4864: 
                            	  4865: *     WORD
02:00002E4A 2080            	  4866:                 move.l d0,(a0)
02:00002E4C B350            	  4867:                 eor.w d1,(a0)
02:00002E4E 40C3            	  4868:                 move.w sr,d3
02:00002E50 02830000000C    	  4869:                 andi.l #$0C,d3            * Isolate flags
02:00002E56 DA83            	  4870:                 add.l d3,d5               * Copy flag results into accumulator
02:00002E58 D890            	  4871:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4872: 
                            	  4873: *     LONG
02:00002E5A 2080            	  4874:                 move.l d0,(a0)
02:00002E5C B390            	  4875:                 eor.l d1,(a0)
02:00002E5E 40C3            	  4876:                 move.w sr,d3
02:00002E60 02830000000F    	  4877:                 andi.l #$0F,d3            * Isolate flags
02:00002E66 DA83            	  4878:                 add.l d3,d5               * Copy flag results into accumulator
02:00002E68 D890            	  4879:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4880: 
                            	  4881: 
02:00002E6A E289            	  4882:                 lsr.l #$1,d1
02:00002E6C 51CEFFCC        	  4883:                 dbf d6,EOR_OUTER2
02:00002E70 E28A            	  4884:                 lsr.l #$1,d2
02:00002E72 223C8167E123    	  4885:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002E78 7C1E            	  4886:                 move.l #$0000001E,d6       * Inner loop counter
02:00002E7A 51CFFFBE        	  4887:                 dbf d7,EOR_OUTER2
                            	  4888: 
02:00002E7E 0C8455C5EB70    	  4889:                 cmpi.l #$55C5EB70,d4      * Check the data results
02:00002E84 66FE            	  4890:                 bne.s *
02:00002E86 0C8500004430    	  4891:                 cmpi.l #$00004430,d5      * Check the Flag results
02:00002E8C 66FE            	  4892:                 bne.s *
                            	  4893: 
                            	  4894: 
02:00002E8E 4E75            	  4895:                 rts
                            	  4896: 
                            	  4897: 
                            	  4898: *-----------------------------------------------------------
                            	  4899: *-----------------------------------------------------------
                            	  4900: * OPCODE : CMP
                            	  4901: *-----------------------------------------------------------
                            	  4902: *-----------------------------------------------------------
                            	  4903: 
                            	  4904: op_CMP:
                            	  4905: 
                            	  4906: 
                            	  4907: *  * <EA> to Register
                            	  4908: 
02:00002E90 203CA5A5A5A5    	  4909:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002E96 223C8167E123    	  4910:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002E9C 243CA5A5A5A5    	  4911:                 move.l #$a5a5a5a5,d2
02:00002EA2 7600            	  4912:                 moveq  #$00000000,d3
02:00002EA4 7800            	  4913:                 moveq  #$00000000,d4       * Cumulative data results
02:00002EA6 7A00            	  4914:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002EA8 7C1E            	  4915:                 move.l #$0000001E,d6       * Inner loop counter
02:00002EAA 7E1E            	  4916:                 move.l #$0000001E,d7       * Outer loop counter
02:00002EAC 307C0100        	  4917:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4918: 
                            	  4919: 
                            	  4920: CMP_OUTER1:
                            	  4921: 
                            	  4922: *     BYTE
02:00002EB0 2081            	  4923:                 move.l d1,(a0)
02:00002EB2 B010            	  4924:                 cmp.b (a0),d0
02:00002EB4 40C3            	  4925:                 move.w sr,d3
02:00002EB6 02830000000F    	  4926:                 andi.l #$0F,d3            * Isolate flags
02:00002EBC DA83            	  4927:                 add.l d3,d5               * Copy flag results into accumulator
02:00002EBE D880            	  4928:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4929: 
                            	  4930: *     WORD
02:00002EC0 2081            	  4931:                 move.l d1,(a0)
02:00002EC2 B050            	  4932:                 cmp.w (a0),d0
02:00002EC4 40C3            	  4933:                 move.w sr,d3
02:00002EC6 02830000000F    	  4934:                 andi.l #$0F,d3            * Isolate flags
02:00002ECC DA83            	  4935:                 add.l d3,d5               * Copy flag results into accumulator
02:00002ECE D880            	  4936:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4937: 
                            	  4938: *     LONG
02:00002ED0 2081            	  4939:                 move.l d1,(a0)
02:00002ED2 B090            	  4940:                 cmp.l (a0),d0
02:00002ED4 40C3            	  4941:                 move.w sr,d3
02:00002ED6 02830000000F    	  4942:                 andi.l #$0F,d3            * Isolate flags
02:00002EDC DA83            	  4943:                 add.l d3,d5               * Copy flag results into accumulator
02:00002EDE D880            	  4944:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4945: 
                            	  4946: 
02:00002EE0 E289            	  4947:                 lsr.l #$1,d1
02:00002EE2 51CEFFCC        	  4948:                 dbf d6,CMP_OUTER1
02:00002EE6 E28A            	  4949:                 lsr.l #$1,d2
02:00002EE8 223C8167E123    	  4950:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002EEE 7C1E            	  4951:                 move.l #$0000001E,d6       * Inner loop counter
02:00002EF0 51CFFFBE        	  4952:                 dbf d7,CMP_OUTER1
                            	  4953: 
02:00002EF4 0C847878712F    	  4954:                 cmpi.l #$7878712F,d4      * Check the data results
02:00002EFA 66FE            	  4955:                 bne.s *
02:00002EFC 0C8500005502    	  4956:                 cmpi.l #$00005502,d5      * Check the Flag results
02:00002F02 66FE            	  4957:                 bne.s *
                            	  4958: 
                            	  4959: 
                            	  4960: 
02:00002F04 4E75            	  4961:                 rts
                            	  4962: 
                            	  4963: 
                            	  4964: *-----------------------------------------------------------
                            	  4965: *-----------------------------------------------------------
                            	  4966: * OPCODE : CMPA
                            	  4967: *-----------------------------------------------------------
                            	  4968: *-----------------------------------------------------------
                            	  4969: 
                            	  4970: op_CMPA:
                            	  4971: 
                            	  4972: 
                            	  4973: *  * <EA> to Register
                            	  4974: 
02:00002F06 207CA5A5A5A5    	  4975:                 move.l #$a5a5a5a5,a0       * Initial Data-X  Inner loop
02:00002F0C 223C8167E123    	  4976:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002F12 243CA5A5A5A5    	  4977:                 move.l #$a5a5a5a5,d2
02:00002F18 7600            	  4978:                 moveq  #$00000000,d3
02:00002F1A 7800            	  4979:                 moveq  #$00000000,d4       * Cumulative data results
02:00002F1C 7A00            	  4980:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002F1E 7C1E            	  4981:                 move.l #$0000001E,d6       * Inner loop counter
02:00002F20 7E1E            	  4982:                 move.l #$0000001E,d7       * Outer loop counter
02:00002F22 327C0100        	  4983:                 move.l #$00000100,a1       * Address for memory EA operations
                            	  4984: 
                            	  4985: 
                            	  4986: CMPA_OUTER1:
                            	  4987: 
                            	  4988: 
                            	  4989: *     WORD
02:00002F26 2281            	  4990:                 move.l d1,(a1)
02:00002F28 B0D1            	  4991:                 cmpa.w (a1),a0
02:00002F2A 40C3            	  4992:                 move.w sr,d3
02:00002F2C 02830000000F    	  4993:                 andi.l #$0F,d3            * Isolate flags
02:00002F32 DA83            	  4994:                 add.l d3,d5               * Copy flag results into accumulator
02:00002F34 D888            	  4995:                 add.l a0,d4               * Copy data results into data accumulator
                            	  4996: 
                            	  4997: *     LONG
02:00002F36 2281            	  4998:                 move.l d1,(a1)
02:00002F38 B1D1            	  4999:                 cmpa.l (a1),a0
02:00002F3A 40C3            	  5000:                 move.w sr,d3
02:00002F3C 02830000000F    	  5001:                 andi.l #$0F,d3            * Isolate flags
02:00002F42 DA83            	  5002:                 add.l d3,d5               * Copy flag results into accumulator
02:00002F44 D888            	  5003:                 add.l a0,d4               * Copy data results into data accumulator
                            	  5004: 
                            	  5005: 
02:00002F46 E289            	  5006:                 lsr.l #$1,d1
02:00002F48 51CEFFDC        	  5007:                 dbf d6,CMPA_OUTER1
02:00002F4C E28A            	  5008:                 lsr.l #$1,d2
02:00002F4E 223C8167E123    	  5009:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002F54 7C1E            	  5010:                 move.l #$0000001E,d6       * Inner loop counter
02:00002F56 51CFFFCE        	  5011:                 dbf d7,CMPA_OUTER1
                            	  5012: 
02:00002F5A 0C84A5A5A0CA    	  5013:                 cmpi.l #$a5a5a0ca,d4      * Check the data results
02:00002F60 66FE            	  5014:                 bne.s *
02:00002F62 0C8500003A7D    	  5015:                 cmpi.l #$00003A7D,d5      * Check the Flag results
02:00002F68 66FE            	  5016:                 bne.s *
                            	  5017: 
                            	  5018: 
02:00002F6A 4E75            	  5019:                 rts
                            	  5020: 
                            	  5021: 
                            	  5022: 
                            	  5023: *-----------------------------------------------------------
                            	  5024: *-----------------------------------------------------------
                            	  5025: * OPCODE : CMPM
                            	  5026: *-----------------------------------------------------------
                            	  5027: *-----------------------------------------------------------
                            	  5028: 
                            	  5029: op_CMPM:
                            	  5030: 
02:00002F6C 307C0100        	  5031:                 move.l #$00000100,a0       * Address for Data-X
02:00002F70 327C0200        	  5032:                 move.l #$00000200,a1       * Address for Data-Y
02:00002F74 7000            	  5033:                 moveq  #$00000000,d0
02:00002F76 7200            	  5034:                 moveq  #$00000000,d1
02:00002F78 7400            	  5035:                 moveq  #$00000000,d2
                            	  5036: 
02:00002F7A 20FC11FF5580    	  5037:                 move.l #$11FF5580,(a0)+   * Populate test data
02:00002F80 20FC1111FFFF    	  5038:                 move.l #$1111FFFF,(a0)+   * Populate test data
02:00002F86 20FC33333333    	  5039:                 move.l #$33333333,(a0)+   * Populate test data
02:00002F8C 20FC44444444    	  5040:                 move.l #$44444444,(a0)+   * Populate test data
                            	  5041: 
02:00002F92 22FC80FF337F    	  5042:                 move.l #$80FF337F,(a1)+   * Populate test data
02:00002F98 22FCFFFF1111    	  5043:                 move.l #$FFFF1111,(a1)+   * Populate test data
02:00002F9E 22FC33333333    	  5044:                 move.l #$33333333,(a1)+   * Populate test data
02:00002FA4 22FC44444444    	  5045:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5046: 
02:00002FAA 307C0100        	  5047:                 move.l #$00000100,a0       * Address for Data-X
02:00002FAE 327C0200        	  5048:                 move.l #$00000200,a1       * Address for Data-Y
02:00002FB2 7C0F            	  5049:                 move.l #$0000000F,d6       * Loop counter
                            	  5050: 
02:00002FB4 B308            	  5051: CMPM_LOOP1:     cmpm.b (a0)+,(a1)+
02:00002FB6 40C3            	  5052:                 move.w sr,d3
02:00002FB8 02830000000F    	  5053:                 andi.l #$0F,d3            * Isolate flags
02:00002FBE D083            	  5054:                 add.l d3,d0               * Copy flag results into accumulator
02:00002FC0 51CEFFF2        	  5055:                 dbf d6,CMPM_LOOP1
                            	  5056: 
                            	  5057: 
02:00002FC4 307C0100        	  5058:                 move.l #$00000100,a0       * Address for Data-X
02:00002FC8 327C0200        	  5059:                 move.l #$00000200,a1       * Address for Data-Y
02:00002FCC 7C07            	  5060:                 moveq  #$00000007,d6       * Loop counter
                            	  5061: 
02:00002FCE B348            	  5062: CMPM_LOOP2:     cmpm.w (a0)+,(a1)+
02:00002FD0 40C3            	  5063:                 move.w sr,d3
02:00002FD2 02830000000F    	  5064:                 andi.l #$0F,d3            * Isolate flags
02:00002FD8 D283            	  5065:                 add.l d3,d1               * Copy flag results into accumulator
02:00002FDA 51CEFFF2        	  5066:                 dbf d6,CMPM_LOOP2
                            	  5067: 
                            	  5068: 
02:00002FDE 307C0100        	  5069:                 move.l #$00000100,a0       * Address for Data-X
02:00002FE2 327C0200        	  5070:                 move.l #$00000200,a1       * Address for Data-Y
02:00002FE6 7C03            	  5071:                 moveq  #$00000003,d6       * Loop counter
                            	  5072: 
02:00002FE8 B388            	  5073: CMPM_LOOP3:     cmpm.l (a0)+,(a1)+
02:00002FEA 40C3            	  5074:                 move.w sr,d3
02:00002FEC 02830000000F    	  5075:                 andi.l #$0F,d3            * Isolate flags
02:00002FF2 D483            	  5076:                 add.l d3,d2               * Copy flag results into accumulator
02:00002FF4 51CEFFF2        	  5077:                 dbf d6,CMPM_LOOP3
                            	  5078: 
                            	  5079: 
02:00002FF8 0C800000004C    	  5080:                 cmpi.l #$0000004C,d0      * Check the data results
02:00002FFE 66FE            	  5081:                 bne.s *
02:00003000 0C8100000024    	  5082:                 cmpi.l #$00000024,d1
02:00003006 66FE            	  5083:                 bne.s *
02:00003008 0C8200000012    	  5084:                 cmpi.l #$00000012,d2
02:0000300E 66FE            	  5085:                 bne.s *
                            	  5086: 
02:00003010 4E75            	  5087:                 rts
                            	  5088: 
                            	  5089: 
                            	  5090: *-----------------------------------------------------------
                            	  5091: *-----------------------------------------------------------
                            	  5092: * OPCODE : ADD
                            	  5093: *-----------------------------------------------------------
                            	  5094: *-----------------------------------------------------------
                            	  5095: 
                            	  5096: op_ADD:
                            	  5097: 
                            	  5098: 
                            	  5099: *  * <EA> to Register
02:00003012 203CA5A5A5A5    	  5100:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003018 223C8167E123    	  5101:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:0000301E 243CA5A5A5A5    	  5102:                 move.l #$a5a5a5a5,d2
02:00003024 7600            	  5103:                 moveq  #$00000000,d3
02:00003026 7800            	  5104:                 moveq  #$00000000,d4       * Cumulative data results
02:00003028 7A00            	  5105:                 moveq  #$00000000,d5       * Cumulative flag results
02:0000302A 7C1E            	  5106:                 move.l #$0000001E,d6       * Inner loop counter
02:0000302C 7E1E            	  5107:                 move.l #$0000001E,d7       * Outer loop counter
02:0000302E 307C0100        	  5108:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5109: 
                            	  5110: 
                            	  5111: ADD_OUTER1:
                            	  5112: 
                            	  5113: *     BYTE
02:00003032 2081            	  5114:                 move.l d1,(a0)
02:00003034 D010            	  5115:                 add.b (a0),d0
02:00003036 40C3            	  5116:                 move.w sr,d3
02:00003038 02830000001F    	  5117:                 andi.l #$1F,d3            * Isolate flags
02:0000303E DA83            	  5118:                 add.l d3,d5               * Copy flag results into accumulator
02:00003040 D880            	  5119:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5120: 
                            	  5121: *     WORD
02:00003042 2081            	  5122:                 move.l d1,(a0)
02:00003044 D050            	  5123:                 add.w (a0),d0
02:00003046 40C3            	  5124:                 move.w sr,d3
02:00003048 02830000000C    	  5125:                 andi.l #$0C,d3            * Isolate flags
02:0000304E DA83            	  5126:                 add.l d3,d5               * Copy flag results into accumulator
02:00003050 D880            	  5127:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5128: 
                            	  5129: *     LONG
02:00003052 2081            	  5130:                 move.l d1,(a0)
02:00003054 D090            	  5131:                 add.l (a0),d0
02:00003056 40C3            	  5132:                 move.w sr,d3
02:00003058 02830000000F    	  5133:                 andi.l #$0F,d3            * Isolate flags
02:0000305E DA83            	  5134:                 add.l d3,d5               * Copy flag results into accumulator
02:00003060 D880            	  5135:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5136: 
                            	  5137: 
02:00003062 E299            	  5138:                 ror.l #$1,d1
02:00003064 51CEFFCC        	  5139:                 dbf d6,ADD_OUTER1
02:00003068 E29A            	  5140:                 ror.l #$1,d2
02:0000306A 223C8167E123    	  5141:                 move.l #$8167E123,d1       * Initial Data-Y
02:00003070 7C1E            	  5142:                 move.l #$0000001E,d6       * Inner loop counter
02:00003072 51CFFFBE        	  5143:                 dbf d7,ADD_OUTER1
                            	  5144: 
02:00003076 0C8423ED428F    	  5145:                 cmpi.l #$23ED428F,d4      * Check the data results
02:0000307C 66FE            	  5146:                 bne.s *
02:0000307E 0C8500004C96    	  5147:                 cmpi.l #$00004C96,d5      * Check the Flag results
02:00003084 66FE            	  5148:                 bne.s *
                            	  5149: 
                            	  5150: 
                            	  5151: *  * Register to <EA>
02:00003086 203C86738374    	  5152:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:0000308C 223CFC55F2FE    	  5153:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00003092 243C86738374    	  5154:                 move.l #$86738374,d2
02:00003098 7600            	  5155:                 moveq  #$00000000,d3
02:0000309A 7800            	  5156:                 moveq  #$00000000,d4       * Cumulative data results
02:0000309C 7A00            	  5157:                 moveq  #$00000000,d5       * Cumulative flag results
02:0000309E 7C1E            	  5158:                 move.l #$0000001E,d6       * Inner loop counter
02:000030A0 7E1D            	  5159:                 move.l #$0000001D,d7       * Outer loop counter
02:000030A2 307C0100        	  5160:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5161: 
                            	  5162: 
                            	  5163: ADD_OUTER2:
                            	  5164: 
                            	  5165: *     BYTE
02:000030A6 2080            	  5166:                 move.l d0,(a0)
02:000030A8 D310            	  5167:                 add.b d1,(a0)
02:000030AA 40C3            	  5168:                 move.w sr,d3
02:000030AC 02830000000C    	  5169:                 andi.l #$0C,d3            * Isolate flags
02:000030B2 DA83            	  5170:                 add.l d3,d5               * Copy flag results into accumulator
02:000030B4 D890            	  5171:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5172: 
                            	  5173: *     WORD
02:000030B6 2080            	  5174:                 move.l d0,(a0)
02:000030B8 D350            	  5175:                 add.w d1,(a0)
02:000030BA 40C3            	  5176:                 move.w sr,d3
02:000030BC 02830000001F    	  5177:                 andi.l #$1F,d3            * Isolate flags
02:000030C2 DA83            	  5178:                 add.l d3,d5               * Copy flag results into accumulator
02:000030C4 D890            	  5179:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5180: 
                            	  5181: *     LONG
02:000030C6 2080            	  5182:                 move.l d0,(a0)
02:000030C8 D390            	  5183:                 add.l d1,(a0)
02:000030CA 40C3            	  5184:                 move.w sr,d3
02:000030CC 02830000000F    	  5185:                 andi.l #$0F,d3            * Isolate flags
02:000030D2 DA83            	  5186:                 add.l d3,d5               * Copy flag results into accumulator
02:000030D4 D890            	  5187:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5188: 
                            	  5189: 
02:000030D6 E299            	  5190:                 ror.l #$1,d1
02:000030D8 51CEFFCC        	  5191:                 dbf d6,ADD_OUTER2
02:000030DC E29A            	  5192:                 ror.l #$1,d2
02:000030DE 223C8167E123    	  5193:                 move.l #$8167E123,d1       * Initial Data-Y
02:000030E4 7C1E            	  5194:                 move.l #$0000001E,d6       * Inner loop counter
02:000030E6 51CFFFBE        	  5195:                 dbf d7,ADD_OUTER2
                            	  5196: 
02:000030EA 0C846701B884    	  5197:                 cmpi.l #$6701B884,d4      * Check the data results
02:000030F0 66FE            	  5198:                 bne.s *
02:000030F2 0C8500005467    	  5199:                 cmpi.l #$00005467,d5      * Check the Flag results
02:000030F8 66FE            	  5200:                 bne.s *
                            	  5201: 
02:000030FA 4E75            	  5202:                 rts
                            	  5203: 
                            	  5204: *-----------------------------------------------------------
                            	  5205: *-----------------------------------------------------------
                            	  5206: * OPCODE : SUB
                            	  5207: *-----------------------------------------------------------
                            	  5208: *-----------------------------------------------------------
                            	  5209: 
                            	  5210: op_SUB:
                            	  5211: 
                            	  5212: *  * <EA> to Register
02:000030FC 203CA5A5A5A5    	  5213:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003102 223C8167E123    	  5214:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00003108 243CA5A5A5A5    	  5215:                 move.l #$a5a5a5a5,d2
02:0000310E 7600            	  5216:                 moveq  #$00000000,d3
02:00003110 7800            	  5217:                 moveq  #$00000000,d4       * Cumulative data results
02:00003112 7A00            	  5218:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003114 7C1E            	  5219:                 move.l #$0000001E,d6       * Inner loop counter
02:00003116 7E1E            	  5220:                 move.l #$0000001E,d7       * Outer loop counter
02:00003118 307C0100        	  5221:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5222: 
                            	  5223: 
                            	  5224: SUB_OUTER1:
                            	  5225: 
                            	  5226: *     BYTE
02:0000311C 2081            	  5227:                 move.l d1,(a0)
02:0000311E 9010            	  5228:                 sub.b (a0),d0
02:00003120 40C3            	  5229:                 move.w sr,d3
02:00003122 02830000001F    	  5230:                 andi.l #$1F,d3            * Isolate flags
02:00003128 DA83            	  5231:                 add.l d3,d5               * Copy flag results into accumulator
02:0000312A D880            	  5232:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5233: 
                            	  5234: *     WORD
02:0000312C 2081            	  5235:                 move.l d1,(a0)
02:0000312E 9050            	  5236:                 sub.w (a0),d0
02:00003130 40C3            	  5237:                 move.w sr,d3
02:00003132 02830000000C    	  5238:                 andi.l #$0C,d3            * Isolate flags
02:00003138 DA83            	  5239:                 add.l d3,d5               * Copy flag results into accumulator
02:0000313A D880            	  5240:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5241: 
                            	  5242: *     LONG
02:0000313C 2081            	  5243:                 move.l d1,(a0)
02:0000313E 9090            	  5244:                 sub.l (a0),d0
02:00003140 40C3            	  5245:                 move.w sr,d3
02:00003142 02830000000F    	  5246:                 andi.l #$0F,d3            * Isolate flags
02:00003148 DA83            	  5247:                 add.l d3,d5               * Copy flag results into accumulator
02:0000314A D880            	  5248:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5249: 
                            	  5250: 
02:0000314C E299            	  5251:                 ror.l #$1,d1
02:0000314E 51CEFFCC        	  5252:                 dbf d6,SUB_OUTER1
02:00003152 E29A            	  5253:                 ror.l #$1,d2
02:00003154 223C8167E123    	  5254:                 move.l #$8167E123,d1       * Initial Data-Y
02:0000315A 7C1E            	  5255:                 move.l #$0000001E,d6       * Inner loop counter
02:0000315C 51CFFFBE        	  5256:                 dbf d7,SUB_OUTER1
                            	  5257: 
02:00003160 0C841A8D14CF    	  5258:                 cmpi.l #$1A8D14CF,d4      * Check the data results
02:00003166 66FE            	  5259:                 bne.s *
02:00003168 0C8500004FC4    	  5260:                 cmpi.l #$00004FC4,d5      * Check the Flag results
02:0000316E 66FE            	  5261:                 bne.s *
                            	  5262: 
                            	  5263: 
                            	  5264: *  * Register to <EA>
02:00003170 203C86738374    	  5265:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00003176 223CFC55F2FE    	  5266:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:0000317C 243C86738374    	  5267:                 move.l #$86738374,d2
02:00003182 7600            	  5268:                 moveq  #$00000000,d3
02:00003184 7800            	  5269:                 moveq  #$00000000,d4       * Cumulative data results
02:00003186 7A00            	  5270:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003188 7C1E            	  5271:                 move.l #$0000001E,d6       * Inner loop counter
02:0000318A 7E1D            	  5272:                 move.l #$0000001D,d7       * Outer loop counter
02:0000318C 307C0100        	  5273:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5274: 
                            	  5275: 
                            	  5276: SUB_OUTER2:
                            	  5277: 
                            	  5278: *     BYTE
02:00003190 2080            	  5279:                 move.l d0,(a0)
02:00003192 9310            	  5280:                 sub.b d1,(a0)
02:00003194 40C3            	  5281:                 move.w sr,d3
02:00003196 02830000000C    	  5282:                 andi.l #$0C,d3            * Isolate flags
02:0000319C DA83            	  5283:                 add.l d3,d5               * Copy flag results into accumulator
02:0000319E D890            	  5284:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5285: 
                            	  5286: *     WORD
02:000031A0 2080            	  5287:                 move.l d0,(a0)
02:000031A2 9350            	  5288:                 sub.w d1,(a0)
02:000031A4 40C3            	  5289:                 move.w sr,d3
02:000031A6 02830000001F    	  5290:                 andi.l #$1F,d3            * Isolate flags
02:000031AC DA83            	  5291:                 add.l d3,d5               * Copy flag results into accumulator
02:000031AE D890            	  5292:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5293: 
                            	  5294: *     LONG
02:000031B0 2080            	  5295:                 move.l d0,(a0)
02:000031B2 9390            	  5296:                 sub.l d1,(a0)
02:000031B4 40C3            	  5297:                 move.w sr,d3
02:000031B6 02830000000F    	  5298:                 andi.l #$0F,d3            * Isolate flags
02:000031BC DA83            	  5299:                 add.l d3,d5               * Copy flag results into accumulator
02:000031BE D890            	  5300:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5301: 
                            	  5302: 
02:000031C0 E299            	  5303:                 ror.l #$1,d1
02:000031C2 51CEFFCC        	  5304:                 dbf d6,SUB_OUTER2
02:000031C6 E29A            	  5305:                 ror.l #$1,d2
02:000031C8 223C8167E123    	  5306:                 move.l #$8167E123,d1       * Initial Data-Y
02:000031CE 7C1E            	  5307:                 move.l #$0000001E,d6       * Inner loop counter
02:000031D0 51CFFFBE        	  5308:                 dbf d7,SUB_OUTER2
                            	  5309: 
02:000031D4 0C8436D38BEC    	  5310:                 cmpi.l #$36D38BEC,d4      * Check the data results
02:000031DA 66FE            	  5311:                 bne.s *
02:000031DC 0C85000045A5    	  5312:                 cmpi.l #$000045A5,d5      * Check the Flag results
02:000031E2 66FE            	  5313:                 bne.s *
                            	  5314: 
                            	  5315: 
                            	  5316: 
                            	  5317: 
02:000031E4 4E75            	  5318:                 rts
                            	  5319: 
                            	  5320: 
                            	  5321: 
                            	  5322: *-----------------------------------------------------------
                            	  5323: *-----------------------------------------------------------
                            	  5324: * OPCODE : ADDA
                            	  5325: *-----------------------------------------------------------
                            	  5326: *-----------------------------------------------------------
                            	  5327: 
                            	  5328: op_ADDA:
                            	  5329: 
                            	  5330: *  * <EA> to Register
02:000031E6 203CA5A5A5A5    	  5331:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:000031EC 223C8167E123    	  5332:                 move.l #$8167E123,d1
02:000031F2 243CA5A5A5A5    	  5333:                 move.l #$a5a5a5a5,d2
02:000031F8 7600            	  5334:                 moveq  #$00000000,d3
02:000031FA 7800            	  5335:                 moveq  #$00000000,d4       * Cumulative data results
02:000031FC 7A00            	  5336:                 moveq  #$00000000,d5       * Cumulative flag results
02:000031FE 7C1E            	  5337:                 move.l #$0000001E,d6       * Inner loop counter
02:00003200 7E1E            	  5338:                 move.l #$0000001E,d7       * Outer loop counter
02:00003202 307C0100        	  5339:                 move.l #$00000100,a0       * Address for memory EA operations
02:00003206 227C8167E123    	  5340:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5341: 
                            	  5342: ADDA_OUTER1:
                            	  5343: 
                            	  5344: *     WORD
                            	  5345: *                move.l d1,(a0)       * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5346: *                adda.w (a0),a1
                            	  5347: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5348: 
                            	  5349: *     LONG
02:0000320C 2081            	  5350:                 move.l d1,(a0)
02:0000320E D3D0            	  5351:                 adda.l (a0),a1
02:00003210 D889            	  5352:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5353: 
02:00003212 E299            	  5354:                 ror.l #$1,d1
02:00003214 51CEFFF6        	  5355:                 dbf d6,ADDA_OUTER1
02:00003218 E299            	  5356:                 ror.l #$1,d1
02:0000321A 2241            	  5357:                 move.l d1,a1
02:0000321C 223C8167E123    	  5358:                 move.l #$8167E123,d1       * Initial Data-Y
02:00003222 7C1E            	  5359:                 move.l #$0000001E,d6       * Inner loop counter
02:00003224 51CFFFE6        	  5360:                 dbf d7,ADDA_OUTER1
                            	  5361: 
02:00003228 0C84AC04DB4C    	  5362:                 cmpi.l #$AC04DB4C,d4      * Check the data results
02:0000322E 66FE            	  5363:                 bne.s *
                            	  5364: 
                            	  5365: 
02:00003230 4E75            	  5366:                 rts
                            	  5367: 
                            	  5368: 
                            	  5369: *-----------------------------------------------------------
                            	  5370: *-----------------------------------------------------------
                            	  5371: * OPCODE : SUBA
                            	  5372: *-----------------------------------------------------------
                            	  5373: *-----------------------------------------------------------
                            	  5374: 
                            	  5375: op_SUBA:
                            	  5376: 
                            	  5377: *  * <EA> to Register
02:00003232 203CA5A5A5A5    	  5378:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003238 223C8167E123    	  5379:                 move.l #$8167E123,d1
02:0000323E 243CA5A5A5A5    	  5380:                 move.l #$a5a5a5a5,d2
02:00003244 7600            	  5381:                 moveq  #$00000000,d3
02:00003246 7800            	  5382:                 moveq  #$00000000,d4       * Cumulative data results
02:00003248 7A00            	  5383:                 moveq  #$00000000,d5       * Cumulative flag results
02:0000324A 7C1E            	  5384:                 move.l #$0000001E,d6       * Inner loop counter
02:0000324C 7E1E            	  5385:                 move.l #$0000001E,d7       * Outer loop counter
02:0000324E 307C0100        	  5386:                 move.l #$00000100,a0       * Address for memory EA operations
02:00003252 227C8167E123    	  5387:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5388: 
                            	  5389: SUBA_OUTER1:
                            	  5390: 
                            	  5391: *     WORD
                            	  5392: *                move.l d1,(a0) * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5393: *                suba.w (a0),a1
                            	  5394: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5395: 
                            	  5396: *     LONG
02:00003258 2081            	  5397:                 move.l d1,(a0)
02:0000325A 93D0            	  5398:                 suba.l (a0),a1
02:0000325C D889            	  5399:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5400: 
02:0000325E E299            	  5401:                 ror.l #$1,d1
02:00003260 51CEFFF6        	  5402:                 dbf d6,SUBA_OUTER1
02:00003264 E299            	  5403:                 ror.l #$1,d1
02:00003266 2241            	  5404:                 move.l d1,a1
02:00003268 223C8167E123    	  5405:                 move.l #$8167E123,d1       * Initial Data-Y
02:0000326E 7C1E            	  5406:                 move.l #$0000001E,d6       * Inner loop counter
02:00003270 51CFFFE6        	  5407:                 dbf d7,SUBA_OUTER1
                            	  5408: 
02:00003274 0C84E1E36D7A    	  5409:                 cmpi.l #$E1E36D7A,d4      * Check the data results
02:0000327A 66FE            	  5410:                 bne.s *
                            	  5411: 
                            	  5412: 
02:0000327C 4E75            	  5413:                 rts
                            	  5414: 
                            	  5415: 
                            	  5416: 
                            	  5417: *-----------------------------------------------------------
                            	  5418: *-----------------------------------------------------------
                            	  5419: * OPCODE : ADDX
                            	  5420: *-----------------------------------------------------------
                            	  5421: *-----------------------------------------------------------
                            	  5422: 
                            	  5423: op_ADDX:
                            	  5424: 
                            	  5425: 
                            	  5426: *  * Register to Register
02:0000327E 203CA5A5A5A5    	  5427:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003284 223C8167E123    	  5428:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:0000328A 243CA5A5A5A5    	  5429:                 move.l #$a5a5a5a5,d2
02:00003290 7600            	  5430:                 moveq  #$00000000,d3
02:00003292 7800            	  5431:                 moveq  #$00000000,d4       * Cumulative data results
02:00003294 7A00            	  5432:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003296 7C1E            	  5433:                 move.l #$0000001E,d6       * Inner loop counter
02:00003298 7E1E            	  5434:                 move.l #$0000001E,d7       * Outer loop counter
02:0000329A 307C0100        	  5435:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5436: 
                            	  5437: 
                            	  5438: ADDX_OUTER1:
                            	  5439: 
                            	  5440: *     BYTE
02:0000329E 2002            	  5441:                 move.l d2,d0
02:000032A0 D101            	  5442:                 addx.b d1,d0
02:000032A2 40C3            	  5443:                 move.w sr,d3
02:000032A4 02830000001F    	  5444:                 andi.l #$1F,d3            * Isolate flags
02:000032AA DA83            	  5445:                 add.l d3,d5               * Copy flag results into accumulator
02:000032AC D880            	  5446:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5447: 
                            	  5448: *     WORD
02:000032AE 2002            	  5449:                 move.l d2,d0
02:000032B0 D141            	  5450:                 addx.w d1,d0
02:000032B2 40C3            	  5451:                 move.w sr,d3
02:000032B4 02830000001F    	  5452:                 andi.l #$1F,d3            * Isolate flags
02:000032BA DA83            	  5453:                 add.l d3,d5               * Copy flag results into accumulator
02:000032BC D880            	  5454:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5455: 
                            	  5456: *     LONG
02:000032BE 2002            	  5457:                 move.l d2,d0
02:000032C0 D181            	  5458:                 addx.l d1,d0
02:000032C2 40C3            	  5459:                 move.w sr,d3
02:000032C4 02830000001F    	  5460:                 andi.l #$1F,d3            * Isolate flags
02:000032CA DA83            	  5461:                 add.l d3,d5               * Copy flag results into accumulator
02:000032CC D880            	  5462:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5463: 
02:000032CE E299            	  5464:                 ror.l #$1,d1
02:000032D0 51CEFFCC        	  5465:                 dbf d6,ADDX_OUTER1
02:000032D4 E29A            	  5466:                 ror.l #$1,d2
02:000032D6 223C8167E123    	  5467:                 move.l #$8167E123,d1       * Initial Data-Y
02:000032DC 7C1E            	  5468:                 move.l #$0000001E,d6       * Inner loop counter
02:000032DE 51CFFFBE        	  5469:                 dbf d7,ADDX_OUTER1
                            	  5470: 
02:000032E2 0C844E96A4D9    	  5471:                 cmpi.l #$4E96A4D9,d4      * Check the data results
02:000032E8 66FE            	  5472:                 bne.s *
02:000032EA 0C85000085CD    	  5473:                 cmpi.l #$000085CD,d5      * Check the Flag results
02:000032F0 66FE            	  5474:                 bne.s *
                            	  5475: 
                            	  5476: 
                            	  5477: 
                            	  5478: *     -(An),-(An)
                            	  5479: 
02:000032F2 7000            	  5480:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
02:000032F4 7200            	  5481:                 moveq  #$00000000,d1
02:000032F6 7400            	  5482:                 moveq  #$00000000,d2
02:000032F8 307C0100        	  5483:                 move.l #$00000100,a0       * Address for Data-X
02:000032FC 327C0200        	  5484:                 move.l #$00000200,a1       * Address for Data-Y
02:00003300 20FC11FF5580    	  5485:                 move.l #$11FF5580,(a0)+   * Populate test data
02:00003306 20FC1111FFFF    	  5486:                 move.l #$1111FFFF,(a0)+   * Populate test data
02:0000330C 20FC33333333    	  5487:                 move.l #$33333333,(a0)+   * Populate test data
02:00003312 20FC44444444    	  5488:                 move.l #$44444444,(a0)+   * Populate test data
02:00003318 22FC80FF337F    	  5489:                 move.l #$80FF337F,(a1)+   * Populate test data
02:0000331E 22FCFFFF1111    	  5490:                 move.l #$FFFF1111,(a1)+   * Populate test data
02:00003324 22FC33333333    	  5491:                 move.l #$33333333,(a1)+   * Populate test data
02:0000332A 22FC44444444    	  5492:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5493: 
                            	  5494: 
02:00003330 7C0F            	  5495:                 move.l #$0000000F,d6       * Loop counter
                            	  5496: 
02:00003332 D308            	  5497: ADDX_LOOP3:     addx.b -(a0),-(a1)
02:00003334 40C3            	  5498:                 move.w sr,d3
02:00003336 02830000000F    	  5499:                 andi.l #$0F,d3            * Isolate flags
02:0000333C D083            	  5500:                 add.l d3,d0               * Copy flag results into accumulator
02:0000333E D211            	  5501:                 add.b (a1),d1
02:00003340 51CEFFF0        	  5502:                 dbf d6,ADDX_LOOP3
                            	  5503: 
                            	  5504: 
02:00003344 307C0110        	  5505:                 move.l #$00000110,a0       * Address for Data-X
02:00003348 327C0210        	  5506:                 move.l #$00000210,a1       * Address for Data-Y
02:0000334C 7C07            	  5507:                 moveq  #$00000007,d6       * Loop counter
                            	  5508: 
02:0000334E D348            	  5509: ADDX_LOOP4:     addx.w -(a0),-(a1)
02:00003350 40C3            	  5510:                 move.w sr,d3
02:00003352 02830000000F    	  5511:                 andi.l #$0F,d3            * Isolate flags
02:00003358 D083            	  5512:                 add.l d3,d0               * Copy flag results into accumulator
02:0000335A D251            	  5513:                 add.w (a1),d1
02:0000335C 51CEFFF0        	  5514:                 dbf d6,ADDX_LOOP4
                            	  5515: 
                            	  5516: 
02:00003360 307C0110        	  5517:                 move.l #$00000110,a0       * Address for Data-X
02:00003364 327C0210        	  5518:                 move.l #$00000210,a1       * Address for Data-Y
02:00003368 7C03            	  5519:                 moveq  #$00000003,d6       * Loop counter
                            	  5520: 
02:0000336A D388            	  5521: ADDX_LOOP5:     addx.l -(a0),-(a1)
02:0000336C 40C3            	  5522:                 move.w sr,d3
02:0000336E 02830000000F    	  5523:                 andi.l #$0F,d3            * Isolate flags
02:00003374 D083            	  5524:                 add.l d3,d0               * Copy flag results into accumulator
02:00003376 D291            	  5525:                 add.l (a1),d1
02:00003378 51CEFFF0        	  5526:                 dbf d6,ADDX_LOOP5
                            	  5527: 
                            	  5528: 
02:0000337C 0C8000000095    	  5529:                 cmpi.l #$00000095,d0      * Check the flag results
02:00003382 66FE            	  5530:                 bne.s *
02:00003384 0C81C812A682    	  5531:                 cmpi.l #$C812A682,d1      * Check the data results
02:0000338A 66FE            	  5532:                 bne.s *
                            	  5533: 
02:0000338C 4E75            	  5534:                 rts
                            	  5535: 
                            	  5536: 
                            	  5537: 
                            	  5538: 
                            	  5539: *-----------------------------------------------------------
                            	  5540: *-----------------------------------------------------------
                            	  5541: * OPCODE : SUBX
                            	  5542: *-----------------------------------------------------------
                            	  5543: *-----------------------------------------------------------
                            	  5544: 
                            	  5545: op_SUBX:
                            	  5546: 
                            	  5547: 
                            	  5548: *  * Register to Register
02:0000338E 203CA5A5A5A5    	  5549:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003394 223C8167E123    	  5550:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:0000339A 243CA5A5A5A5    	  5551:                 move.l #$a5a5a5a5,d2
02:000033A0 7600            	  5552:                 moveq  #$00000000,d3
02:000033A2 7800            	  5553:                 moveq  #$00000000,d4       * Cumulative data results
02:000033A4 7A00            	  5554:                 moveq  #$00000000,d5       * Cumulative flag results
02:000033A6 7C1E            	  5555:                 move.l #$0000001E,d6       * Inner loop counter
02:000033A8 7E1E            	  5556:                 move.l #$0000001E,d7       * Outer loop counter
02:000033AA 307C0100        	  5557:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5558: 
                            	  5559: 
                            	  5560: SUBX_OUTER1:
                            	  5561: 
                            	  5562: *     BYTE
02:000033AE 2002            	  5563:                 move.l d2,d0
02:000033B0 9101            	  5564:                 subx.b d1,d0
02:000033B2 40C3            	  5565:                 move.w sr,d3
02:000033B4 02830000001F    	  5566:                 andi.l #$1F,d3            * Isolate flags
02:000033BA DA83            	  5567:                 add.l d3,d5               * Copy flag results into accumulator
02:000033BC D880            	  5568:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5569: 
                            	  5570: *     WORD
02:000033BE 2002            	  5571:                 move.l d2,d0
02:000033C0 9141            	  5572:                 subx.w d1,d0
02:000033C2 40C3            	  5573:                 move.w sr,d3
02:000033C4 02830000001F    	  5574:                 andi.l #$1F,d3            * Isolate flags
02:000033CA DA83            	  5575:                 add.l d3,d5               * Copy flag results into accumulator
02:000033CC D880            	  5576:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5577: 
                            	  5578: *     LONG
02:000033CE 2002            	  5579:                 move.l d2,d0
02:000033D0 9181            	  5580:                 subx.l d1,d0
02:000033D2 40C3            	  5581:                 move.w sr,d3
02:000033D4 02830000001F    	  5582:                 andi.l #$1F,d3            * Isolate flags
02:000033DA DA83            	  5583:                 add.l d3,d5               * Copy flag results into accumulator
02:000033DC D880            	  5584:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5585: 
02:000033DE E299            	  5586:                 ror.l #$1,d1
02:000033E0 51CEFFCC        	  5587:                 dbf d6,SUBX_OUTER1
02:000033E4 E29A            	  5588:                 ror.l #$1,d2
02:000033E6 223C8167E123    	  5589:                 move.l #$8167E123,d1       * Initial Data-Y
02:000033EC 7C1E            	  5590:                 move.l #$0000001E,d6       * Inner loop counter
02:000033EE 51CFFFBE        	  5591:                 dbf d7,SUBX_OUTER1
                            	  5592: 
02:000033F2 0C84FCAA913E    	  5593:                 cmpi.l #$FCAA913E,d4      * Check the data results
02:000033F8 66FE            	  5594:                 bne.s *
02:000033FA 0C8500007E89    	  5595:                 cmpi.l #$00007E89,d5      * Check the Flag results
02:00003400 66FE            	  5596:                 bne.s *
                            	  5597: 
                            	  5598: 
                            	  5599: 
                            	  5600: *     -(An),-(An)
                            	  5601: 
02:00003402 7000            	  5602:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
02:00003404 7200            	  5603:                 moveq  #$00000000,d1
02:00003406 7400            	  5604:                 moveq  #$00000000,d2
02:00003408 307C0100        	  5605:                 move.l #$00000100,a0       * Address for Data-X
02:0000340C 327C0200        	  5606:                 move.l #$00000200,a1       * Address for Data-Y
02:00003410 20FC11FF5580    	  5607:                 move.l #$11FF5580,(a0)+   * Populate test data
02:00003416 20FC1111FFFF    	  5608:                 move.l #$1111FFFF,(a0)+   * Populate test data
02:0000341C 20FC80FF337F    	  5609:                 move.l #$80FF337F,(a0)+   * Populate test data
02:00003422 20FC44444444    	  5610:                 move.l #$44444444,(a0)+   * Populate test data
02:00003428 22FC80FF337F    	  5611:                 move.l #$80FF337F,(a1)+   * Populate test data
02:0000342E 22FC1111FFFF    	  5612:                 move.l #$1111FFFF,(a1)+   * Populate test data
02:00003434 22FC33333333    	  5613:                 move.l #$33333333,(a1)+   * Populate test data
02:0000343A 22FC5580EECC    	  5614:                 move.l #$5580EECC,(a1)+   * Populate test data
                            	  5615: 
                            	  5616: 
02:00003440 7C0F            	  5617:                 move.l #$0000000F,d6       * Loop counter
                            	  5618: 
02:00003442 9308            	  5619: SUBX_LOOP3:     subx.b -(a0),-(a1)
02:00003444 40C3            	  5620:                 move.w sr,d3
02:00003446 02830000000F    	  5621:                 andi.l #$0F,d3            * Isolate flags
02:0000344C D083            	  5622:                 add.l d3,d0               * Copy flag results into accumulator
02:0000344E D211            	  5623:                 add.b (a1),d1
02:00003450 51CEFFF0        	  5624:                 dbf d6,SUBX_LOOP3
                            	  5625: 
                            	  5626: 
02:00003454 307C0110        	  5627:                 move.l #$00000110,a0       * Address for Data-X
02:00003458 327C0210        	  5628:                 move.l #$00000210,a1       * Address for Data-Y
02:0000345C 7C07            	  5629:                 moveq  #$00000007,d6       * Loop counter
                            	  5630: 
02:0000345E 9348            	  5631: SUBX_LOOP4:     subx.w -(a0),-(a1)
02:00003460 40C3            	  5632:                 move.w sr,d3
02:00003462 02830000000F    	  5633:                 andi.l #$0F,d3            * Isolate flags
02:00003468 D083            	  5634:                 add.l d3,d0               * Copy flag results into accumulator
02:0000346A D251            	  5635:                 add.w (a1),d1
02:0000346C 51CEFFF0        	  5636:                 dbf d6,SUBX_LOOP4
                            	  5637: 
                            	  5638: 
02:00003470 307C0110        	  5639:                 move.l #$00000110,a0       * Address for Data-X
02:00003474 327C0210        	  5640:                 move.l #$00000210,a1       * Address for Data-Y
02:00003478 7C03            	  5641:                 moveq  #$00000003,d6       * Loop counter
                            	  5642: 
02:0000347A 9388            	  5643: SUBX_LOOP5:     subx.l -(a0),-(a1)
02:0000347C 40C3            	  5644:                 move.w sr,d3
02:0000347E 02830000000F    	  5645:                 andi.l #$0F,d3            * Isolate flags
02:00003484 D083            	  5646:                 add.l d3,d0               * Copy flag results into accumulator
02:00003486 D291            	  5647:                 add.l (a1),d1
02:00003488 51CEFFF0        	  5648:                 dbf d6,SUBX_LOOP5
                            	  5649: 
                            	  5650: 
02:0000348C 0C80000000B1    	  5651:                 cmpi.l #$000000B1,d0      * Check the flag results
02:00003492 66FE            	  5652:                 bne.s *
02:00003494 0C8162C6F417    	  5653:                 cmpi.l #$62C6F417,d1      * Check the data results
02:0000349A 66FE            	  5654:                 bne.s *
                            	  5655: 
02:0000349C 4E75            	  5656:                 rts
                            	  5657: 
                            	  5658: 
                            	  5659: *-----------------------------------------------------------
                            	  5660: *-----------------------------------------------------------
                            	  5661: * OPCODE : MULU
                            	  5662: *-----------------------------------------------------------
                            	  5663: *-----------------------------------------------------------
                            	  5664: 
                            	  5665: op_MULU:
                            	  5666: 
02:0000349E 203CFE805501    	  5667:                 move.l #$FE805501,d0        * Initial
02:000034A4 223C5697EDB6    	  5668:                 move.l #$5697EDB6,d1        * Initial Y
02:000034AA 243CFE805501    	  5669:                 move.l #$FE805501,d2
02:000034B0 7600            	  5670:                 moveq  #$00000000,d3
02:000034B2 7800            	  5671:                 moveq  #$00000000,d4        * Cumulative data results
02:000034B4 7A00            	  5672:                 moveq  #$00000000,d5       * Cumulative flag results
02:000034B6 7C0E            	  5673:                 move.l #$0000000E,d6       * Inner loop counter
02:000034B8 7E0E            	  5674:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5675: 
                            	  5676: 
02:000034BA C0C1            	  5677: MULU_OUTER1:    mulu d1,d0
02:000034BC 40C3            	  5678:                 move.w sr,d3
02:000034BE 02830000000C    	  5679:                 andi.l #$0C,d3            * Isolate flags
02:000034C4 DA83            	  5680:                 add.l d3,d5               * Copy flag results into accumulator
02:000034C6 D880            	  5681:                 add.l d0,d4               * Copy data results into data accumulator
02:000034C8 E299            	  5682:                 ror.l #$1,d1
                            	  5683: 
02:000034CA 51CEFFEE        	  5684:                 dbf d6,MULU_OUTER1
02:000034CE E29A            	  5685:                 ror.l #$1,d2
02:000034D0 2002            	  5686:                 move.l d2,d0
02:000034D2 7C0E            	  5687:                 move.l #$0000000E,d6       * Inner loop counter
02:000034D4 51CFFFE4        	  5688:                 dbf d7,MULU_OUTER1
                            	  5689: 
02:000034D8 0C8476FB988C    	  5690:                 cmpi.l #$76FB988C,d4      * Check the data results
02:000034DE 66FE            	  5691:                 bne.s *
                            	  5692: 
02:000034E0 0C8500000170    	  5693:                 cmpi.l #$00000170,d5      * Check the Flag results
02:000034E6 66FE            	  5694:                 bne.s *
                            	  5695: 
                            	  5696: 
02:000034E8 4E75            	  5697:                 rts
                            	  5698: 
                            	  5699: 
                            	  5700: *-----------------------------------------------------------
                            	  5701: *-----------------------------------------------------------
                            	  5702: * OPCODE : MULS
                            	  5703: *-----------------------------------------------------------
                            	  5704: *-----------------------------------------------------------
                            	  5705: 
                            	  5706: op_MULS:
                            	  5707: 
02:000034EA 203CFE805501    	  5708:                 move.l #$FE805501,d0        * Initial
02:000034F0 223C5697EDB6    	  5709:                 move.l #$5697EDB6,d1        * Initial Y
02:000034F6 243CFE805501    	  5710:                 move.l #$FE805501,d2
02:000034FC 7600            	  5711:                 moveq  #$00000000,d3
02:000034FE 7800            	  5712:                 moveq  #$00000000,d4        * Cumulative data results
02:00003500 7A00            	  5713:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003502 7C0E            	  5714:                 move.l #$0000000E,d6       * Inner loop counter
02:00003504 7E0E            	  5715:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5716: 
                            	  5717: 
02:00003506 C1C1            	  5718: MULS_OUTER1:    muls d1,d0
02:00003508 40C3            	  5719:                 move.w sr,d3
02:0000350A 02830000000C    	  5720:                 andi.l #$0C,d3            * Isolate flags
02:00003510 DA83            	  5721:                 add.l d3,d5               * Copy flag results into accumulator
02:00003512 D880            	  5722:                 add.l d0,d4               * Copy data results into data accumulator
02:00003514 E299            	  5723:                 ror.l #$1,d1
                            	  5724: 
02:00003516 51CEFFEE        	  5725:                 dbf d6,MULS_OUTER1
02:0000351A E29A            	  5726:                 ror.l #$1,d2
02:0000351C 2002            	  5727:                 move.l d2,d0
02:0000351E 7C0E            	  5728:                 move.l #$0000000E,d6       * Inner loop counter
02:00003520 51CFFFE4        	  5729:                 dbf d7,MULS_OUTER1
                            	  5730: 
02:00003524 0C84D4E2988C    	  5731:                 cmpi.l #$D4E2988C,d4      * Check the data results
02:0000352A 66FE            	  5732:                 bne.s *
                            	  5733: 
02:0000352C 0C85000003E0    	  5734:                 cmpi.l #$000003E0,d5      * Check the Flag results
02:00003532 66FE            	  5735:                 bne.s *
                            	  5736: 
                            	  5737: 
02:00003534 4E75            	  5738:                 rts
                            	  5739: 
                            	  5740: 
                            	  5741: 
                            	  5742: *-----------------------------------------------------------
                            	  5743: *-----------------------------------------------------------
                            	  5744: * OPCODE : EXG
                            	  5745: *-----------------------------------------------------------
                            	  5746: *-----------------------------------------------------------
                            	  5747: 
                            	  5748: op_EXG:
02:00003536 223CD1D1D1D1    	  5749:                 move.l #$d1d1d1d1,d1
02:0000353C 243CD2D2D2D2    	  5750:                 move.l #$d2d2d2d2,d2
02:00003542 263CD3D3D3D3    	  5751:                 move.l #$d3d3d3d3,d3
02:00003548 227CA1A1A1A1    	  5752:                 move.l #$a1a1a1a1,a1
02:0000354E 247CA2A2A2A2    	  5753:                 move.l #$a2a2a2a2,a2
02:00003554 267CA3A3A3A3    	  5754:                 move.l #$a3a3a3a3,a3
                            	  5755: 
02:0000355A C342            	  5756:                 exg d1,d2
02:0000355C C34A            	  5757:                 exg a1,a2
02:0000355E C78B            	  5758:                 exg d3,a3
                            	  5759: 
02:00003560 0C81D2D2D2D2    	  5760:                 cmpi.l #$d2d2d2d2,d1      * Check the results
02:00003566 66FE            	  5761:                 bne.s *
02:00003568 0C82D1D1D1D1    	  5762:                 cmpi.l #$d1d1d1d1,d2
02:0000356E 66FE            	  5763:                 bne.s *
02:00003570 0C83A3A3A3A3    	  5764:                 cmpi.l #$a3a3a3a3,d3
02:00003576 66FE            	  5765:                 bne.s *
                            	  5766: 
02:00003578 2209            	  5767:                 move.l a1,d1
02:0000357A 240A            	  5768:                 move.l a2,d2
02:0000357C 260B            	  5769:                 move.l a3,d3
                            	  5770: 
02:0000357E 0C81A2A2A2A2    	  5771:                 cmpi.l #$a2a2a2a2,d1
02:00003584 66FE            	  5772:                 bne.s *
02:00003586 0C82A1A1A1A1    	  5773:                 cmpi.l #$a1a1a1a1,d2
02:0000358C 66FE            	  5774:                 bne.s *
02:0000358E 0C83D3D3D3D3    	  5775:                 cmpi.l #$d3d3d3d3,d3
02:00003594 66FE            	  5776:                 bne.s *
                            	  5777: 
02:00003596 4E75            	  5778:                 rts
                            	  5779: 
                            	  5780: 
                            	  5781: *-----------------------------------------------------------
                            	  5782: *-----------------------------------------------------------
                            	  5783: * OPCODE : ROx
                            	  5784: *-----------------------------------------------------------
                            	  5785: *-----------------------------------------------------------
                            	  5786: 
                            	  5787: *     Subroutine to check and accumulate the flags
02:00003598 40C3            	  5788: ROx_FLAGS:      move.w sr,d3
02:0000359A 02830000000F    	  5789:                 andi.l #$0F,d3            * Isolate flags
02:000035A0 DA83            	  5790:                 add.l d3,d5               * Copy flag results into accumulator
02:000035A2 4E75            	  5791:                 rts
                            	  5792: 
                            	  5793: op_ROx:
                            	  5794: 
                            	  5795: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  5796: 
                            	  5797: *        BYTE LEFT
02:000035A4 203C80018FF1    	  5798:                 move.l #$80018FF1,d0
02:000035AA 7A00            	  5799:                 moveq  #$00000000,d5
02:000035AC 7C11            	  5800:                 moveq  #$00000011,d6
                            	  5801: ROx_LOOP1:
02:000035AE ED38            	  5802:                 rol.b d6,d0
02:000035B0 61E6            	  5803:                 bsr ROx_FLAGS
02:000035B2 51CEFFFA        	  5804:                 dbf d6,ROx_LOOP1
02:000035B6 0C8080018FE3    	  5805:                 cmpi.l #$80018FE3,d0
02:000035BC 66FE            	  5806:                 bne.s *
02:000035BE 0C850000006B    	  5807:                 cmpi.l #$0000006B,d5
02:000035C4 66FE            	  5808:                 bne.s *
                            	  5809: 
                            	  5810: *        BYTE RIGHT
02:000035C6 203C80018FF1    	  5811:                 move.l #$80018FF1,d0
02:000035CC 7C12            	  5812:                 moveq  #$00000012,d6
                            	  5813: ROx_LOOP2:
02:000035CE EC38            	  5814:                 ror.b d6,d0
02:000035D0 61C6            	  5815:                 bsr ROx_FLAGS
02:000035D2 51CEFFFA        	  5816:                 dbf d6,ROx_LOOP2
02:000035D6 0C8080018F3E    	  5817:                 cmpi.l #$80018F3E,d0
02:000035DC 66FE            	  5818:                 bne.s *
02:000035DE 0C85000000C5    	  5819:                 cmpi.l #$000000C5,d5
02:000035E4 66FE            	  5820:                 bne.s *
                            	  5821: 
                            	  5822: 
                            	  5823: *        WORD LEFT
02:000035E6 203C80018FF1    	  5824:                 move.l #$80018FF1,d0
02:000035EC 7C13            	  5825:                 moveq  #$00000013,d6
                            	  5826: ROx_LOOP3:
02:000035EE ED78            	  5827:                 rol.w d6,d0
02:000035F0 61A6            	  5828:                 bsr ROx_FLAGS
02:000035F2 51CEFFFA        	  5829:                 dbf d6,ROx_LOOP3
02:000035F6 0C80800163FC    	  5830:                 cmpi.l #$800163FC,d0
02:000035FC 66FE            	  5831:                 bne.s *
02:000035FE 0C8500000131    	  5832:                 cmpi.l #$00000131,d5
02:00003604 66FE            	  5833:                 bne.s *
                            	  5834: 
                            	  5835: *        WORD RIGHT
02:00003606 203C80018FF1    	  5836:                 move.l #$80018FF1,d0
02:0000360C 7C1E            	  5837:                 move.l #$0000001E,d6
                            	  5838: ROx_LOOP4:
02:0000360E EC78            	  5839:                 ror.w d6,d0
02:00003610 6186            	  5840:                 bsr ROx_FLAGS
02:00003612 51CEFFFA        	  5841:                 dbf d6,ROx_LOOP4
02:00003616 0C808001C7F8    	  5842:                 cmpi.l #$8001C7F8,d0
02:0000361C 66FE            	  5843:                 bne.s *
02:0000361E 0C85000001DB    	  5844:                 cmpi.l #$000001DB,d5
02:00003624 66FE            	  5845:                 bne.s *
                            	  5846: 
                            	  5847: 
                            	  5848: *        LONG LEFT
02:00003626 203C80018FF1    	  5849:                 move.l #$80018FF1,d0
02:0000362C 7C15            	  5850:                 moveq  #$00000015,d6
                            	  5851: ROx_LOOP5:
02:0000362E EDB8            	  5852:                 rol.l d6,d0
02:00003630 6100FF66        	  5853:                 bsr ROx_FLAGS
02:00003634 51CEFFF8        	  5854:                 dbf d6,ROx_LOOP5
02:00003638 0C8000C7F8C0    	  5855:                 cmpi.l #$00C7F8C0,d0
02:0000363E 66FE            	  5856:                 bne.s *
02:00003640 0C850000021A    	  5857:                 cmpi.l #$0000021A,d5
02:00003646 66FE            	  5858:                 bne.s *
                            	  5859: 
                            	  5860: *        LONG RIGHT
02:00003648 203C80018FF1    	  5861:                 move.l #$80018FF1,d0
02:0000364E 7C16            	  5862:                 moveq  #$00000016,d6
                            	  5863: ROx_LOOP6:
02:00003650 ECB8            	  5864:                 ror.l d6,d0
02:00003652 6100FF44        	  5865:                 bsr ROx_FLAGS
02:00003656 51CEFFF8        	  5866:                 dbf d6,ROx_LOOP6
02:0000365A 0C80000C7F8C    	  5867:                 cmpi.l #$000C7F8C,d0
02:00003660 66FE            	  5868:                 bne.s *
02:00003662 0C8500000250    	  5869:                 cmpi.l #$00000250,d5
02:00003668 66FE            	  5870:                 bne.s *
                            	  5871: 
                            	  5872: 
                            	  5873: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  5874: 
02:0000366A 203C80018FF1    	  5875:                 move.l #$80018FF1,d0
02:00003670 7A00            	  5876:                 moveq  #$00000000,d5
                            	  5877: 
                            	  5878: *        BYTE LEFT
02:00003672 E318            	  5879:                 rol.b #1,d0
02:00003674 6100FF22        	  5880:                 bsr ROx_FLAGS
02:00003678 EB18            	  5881:                 rol.b #5,d0
02:0000367A 6100FF1C        	  5882:                 bsr ROx_FLAGS
02:0000367E EF18            	  5883:                 rol.b #7,d0
02:00003680 6100FF16        	  5884:                 bsr ROx_FLAGS
02:00003684 E118            	  5885:                 rol.b #8,d0
02:00003686 6100FF10        	  5886:                 bsr ROx_FLAGS
02:0000368A 0C8080018F3E    	  5887:                 cmpi.l #$80018F3E,d0
02:00003690 66FE            	  5888:                 bne.s *
02:00003692 0C8500000009    	  5889:                 cmpi.l #$00000009,d5
02:00003698 66FE            	  5890:                 bne.s *
                            	  5891: 
                            	  5892: *        BYTE RIGHT
02:0000369A E218            	  5893:                 ror.b #1,d0
02:0000369C 6100FEFA        	  5894:                 bsr ROx_FLAGS
02:000036A0 EA18            	  5895:                 ror.b #5,d0
02:000036A2 6100FEF4        	  5896:                 bsr ROx_FLAGS
02:000036A6 EE18            	  5897:                 ror.b #7,d0
02:000036A8 6100FEEE        	  5898:                 bsr ROx_FLAGS
02:000036AC E018            	  5899:                 ror.b #8,d0
02:000036AE 6100FEE8        	  5900:                 bsr ROx_FLAGS
02:000036B2 0C8080018FF1    	  5901:                 cmpi.l #$80018FF1,d0
02:000036B8 66FE            	  5902:                 bne.s *
02:000036BA 0C8500000024    	  5903:                 cmpi.l #$00000024,d5
02:000036C0 66FE            	  5904:                 bne.s *
                            	  5905: 
                            	  5906: *        WORD LEFT
02:000036C2 E358            	  5907:                 rol.w #1,d0
02:000036C4 6100FED2        	  5908:                 bsr ROx_FLAGS
02:000036C8 EB58            	  5909:                 rol.w #5,d0
02:000036CA 6100FECC        	  5910:                 bsr ROx_FLAGS
02:000036CE EF58            	  5911:                 rol.w #7,d0
02:000036D0 6100FEC6        	  5912:                 bsr ROx_FLAGS
02:000036D4 E158            	  5913:                 rol.w #8,d0
02:000036D6 6100FEC0        	  5914:                 bsr ROx_FLAGS
02:000036DA 0C808001FE31    	  5915:                 cmpi.l #$8001FE31,d0
02:000036E0 66FE            	  5916:                 bne.s *
02:000036E2 0C8500000037    	  5917:                 cmpi.l #$00000037,d5
02:000036E8 66FE            	  5918:                 bne.s *
                            	  5919: 
                            	  5920: *        WORD RIGHT
02:000036EA E258            	  5921:                 ror.w #1,d0
02:000036EC 6100FEAA        	  5922:                 bsr ROx_FLAGS
02:000036F0 EA58            	  5923:                 ror.w #5,d0
02:000036F2 6100FEA4        	  5924:                 bsr ROx_FLAGS
02:000036F6 EE58            	  5925:                 ror.w #7,d0
02:000036F8 6100FE9E        	  5926:                 bsr ROx_FLAGS
02:000036FC E058            	  5927:                 ror.w #8,d0
02:000036FE 6100FE98        	  5928:                 bsr ROx_FLAGS
02:00003702 0C8080018FF1    	  5929:                 cmpi.l #$80018FF1,d0
02:00003708 66FE            	  5930:                 bne.s *
02:0000370A 0C850000005B    	  5931:                 cmpi.l #$0000005B,d5
02:00003710 66FE            	  5932:                 bne.s *
                            	  5933: 
                            	  5934: *        LONG LEFT
02:00003712 E398            	  5935:                 rol.l #1,d0
02:00003714 6100FE82        	  5936:                 bsr ROx_FLAGS
02:00003718 EB98            	  5937:                 rol.l #5,d0
02:0000371A 6100FE7C        	  5938:                 bsr ROx_FLAGS
02:0000371E EF98            	  5939:                 rol.l #7,d0
02:00003720 6100FE76        	  5940:                 bsr ROx_FLAGS
02:00003724 E198            	  5941:                 rol.l #8,d0
02:00003726 6100FE70        	  5942:                 bsr ROx_FLAGS
02:0000372A 0C80FE300031    	  5943:                 cmpi.l #$FE300031,d0
02:00003730 66FE            	  5944:                 bne.s *
02:00003732 0C8500000065    	  5945:                 cmpi.l #$00000065,d5
02:00003738 66FE            	  5946:                 bne.s *
                            	  5947: 
                            	  5948: *        LONG RIGHT
02:0000373A E298            	  5949:                 ror.l #1,d0
02:0000373C 6100FE5A        	  5950:                 bsr ROx_FLAGS
02:00003740 EA98            	  5951:                 ror.l #5,d0
02:00003742 6100FE54        	  5952:                 bsr ROx_FLAGS
02:00003746 EE98            	  5953:                 ror.l #7,d0
02:00003748 6100FE4E        	  5954:                 bsr ROx_FLAGS
02:0000374C E098            	  5955:                 ror.l #8,d0
02:0000374E 6100FE48        	  5956:                 bsr ROx_FLAGS
02:00003752 0C8080018FF1    	  5957:                 cmpi.l #$80018FF1,d0
02:00003758 66FE            	  5958:                 bne.s *
02:0000375A 0C8500000080    	  5959:                 cmpi.l #$00000080,d5
02:00003760 66FE            	  5960:                 bne.s *
                            	  5961: 
                            	  5962: 
                            	  5963: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  5964: 
02:00003762 7A00            	  5965:                 moveq  #$00000000,d5
02:00003764 307C0100        	  5966:                 move.l #$00000100,a0
02:00003768 30BC8FF1        	  5967:                 move.w #$8FF1,(a0)
                            	  5968: 
                            	  5969: *        WORD LEFT
02:0000376C E7D0            	  5970:                 rol (a0)
02:0000376E 6100FE28        	  5971:                 bsr ROx_FLAGS
02:00003772 E7D0            	  5972:                 rol (a0)
02:00003774 6100FE22        	  5973:                 bsr ROx_FLAGS
02:00003778 E7D0            	  5974:                 rol (a0)
02:0000377A 6100FE1C        	  5975:                 bsr ROx_FLAGS
02:0000377E E7D0            	  5976:                 rol (a0)
02:00003780 6100FE16        	  5977:                 bsr ROx_FLAGS
02:00003784 3010            	  5978:                 move.w (a0),d0
02:00003786 0C808001FF18    	  5979:                 cmpi.l #$8001FF18,d0
02:0000378C 66FE            	  5980:                 bne.s *
02:0000378E 0C8500000009    	  5981:                 cmpi.l #$00000009,d5
02:00003794 66FE            	  5982:                 bne.s *
                            	  5983: 
                            	  5984: *        WORD RIGHT
02:00003796 E6D0            	  5985:                 ror (a0)
02:00003798 6100FDFE        	  5986:                 bsr ROx_FLAGS
02:0000379C E6D0            	  5987:                 ror (a0)
02:0000379E 6100FDF8        	  5988:                 bsr ROx_FLAGS
02:000037A2 E6D0            	  5989:                 ror (a0)
02:000037A4 6100FDF2        	  5990:                 bsr ROx_FLAGS
02:000037A8 E6D0            	  5991:                 ror (a0)
02:000037AA 6100FDEC        	  5992:                 bsr ROx_FLAGS
02:000037AE E6D0            	  5993:                 ror (a0)
02:000037B0 6100FDE6        	  5994:                 bsr ROx_FLAGS
02:000037B4 E6D0            	  5995:                 ror (a0)
02:000037B6 6100FDE0        	  5996:                 bsr ROx_FLAGS
02:000037BA 3010            	  5997:                 move.w (a0),d0
02:000037BC 0C80800163FC    	  5998:                 cmpi.l #$800163FC,d0
02:000037C2 66FE            	  5999:                 bne.s *
02:000037C4 0C850000001B    	  6000:                 cmpi.l #$0000001B,d5
02:000037CA 66FE            	  6001:                 bne.s *
                            	  6002: 
02:000037CC 4E75            	  6003:                 rts
                            	  6004: 
                            	  6005: 
                            	  6006: 
                            	  6007: *-----------------------------------------------------------
                            	  6008: *-----------------------------------------------------------
                            	  6009: * OPCODE : ROXx
                            	  6010: *-----------------------------------------------------------
                            	  6011: *-----------------------------------------------------------
                            	  6012: 
                            	  6013: *     Subroutine to check and accumulate the flags
02:000037CE 40C3            	  6014: ROXx_FLAGS:     move.w sr,d3
02:000037D0 02830000000F    	  6015:                 andi.l #$0F,d3            * Isolate flags
02:000037D6 DA83            	  6016:                 add.l d3,d5               * Copy flag results into accumulator
02:000037D8 4E75            	  6017:                 rts
                            	  6018: 
                            	  6019: op_ROXx:
                            	  6020: 
                            	  6021: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6022: 
                            	  6023: *        BYTE LEFT
02:000037DA 203C80018FF1    	  6024:                 move.l #$80018FF1,d0
02:000037E0 7A00            	  6025:                 moveq  #$00000000,d5
02:000037E2 7C11            	  6026:                 moveq  #$00000011,d6
                            	  6027: ROXx_LOOP1:
02:000037E4 ED30            	  6028:                 roxl.b d6,d0
02:000037E6 61E6            	  6029:                 bsr ROXx_FLAGS
02:000037E8 51CEFFFA        	  6030:                 dbf d6,ROXx_LOOP1
02:000037EC 0C8080018FD0    	  6031:                 cmpi.l #$80018FD0,d0
02:000037F2 66FE            	  6032:                 bne.s *
02:000037F4 0C8500000042    	  6033:                 cmpi.l #$00000042,d5
02:000037FA 66FE            	  6034:                 bne.s *
                            	  6035: 
                            	  6036: *        BYTE RIGHT
02:000037FC 203C80018FF1    	  6037:                 move.l #$80018FF1,d0
02:00003802 7C12            	  6038:                 moveq  #$00000012,d6
                            	  6039: ROXx_LOOP2:
02:00003804 EC30            	  6040:                 roxr.b d6,d0
02:00003806 61C6            	  6041:                 bsr ROXx_FLAGS
02:00003808 51CEFFFA        	  6042:                 dbf d6,ROXx_LOOP2
02:0000380C 0C8080018F51    	  6043:                 cmpi.l #$80018F51,d0
02:00003812 66FE            	  6044:                 bne.s *
02:00003814 0C850000009C    	  6045:                 cmpi.l #$0000009C,d5
02:0000381A 66FE            	  6046:                 bne.s *
                            	  6047: 
                            	  6048: 
                            	  6049: *        WORD LEFT
02:0000381C 203C80018FF1    	  6050:                 move.l #$80018FF1,d0
02:00003822 7C13            	  6051:                 moveq  #$00000013,d6
                            	  6052: ROXx_LOOP3:
02:00003824 ED70            	  6053:                 roxl.w d6,d0
02:00003826 61A6            	  6054:                 bsr ROXx_FLAGS
02:00003828 51CEFFFA        	  6055:                 dbf d6,ROXx_LOOP3
02:0000382C 0C8080013980    	  6056:                 cmpi.l #$80013980,d0
02:00003832 66FE            	  6057:                 bne.s *
02:00003834 0C85000000C9    	  6058:                 cmpi.l #$000000C9,d5
02:0000383A 66FE            	  6059:                 bne.s *
                            	  6060: 
                            	  6061: *        WORD RIGHT
02:0000383C 203C80018FF1    	  6062:                 move.l #$80018FF1,d0
02:00003842 7C1E            	  6063:                 move.l #$0000001E,d6
                            	  6064: ROXx_LOOP4:
02:00003844 EC70            	  6065:                 roxr.w d6,d0
02:00003846 6186            	  6066:                 bsr ROXx_FLAGS
02:00003848 51CEFFFA        	  6067:                 dbf d6,ROXx_LOOP4
02:0000384C 0C8080010A1D    	  6068:                 cmpi.l #$80010A1D,d0
02:00003852 66FE            	  6069:                 bne.s *
02:00003854 0C850000014D    	  6070:                 cmpi.l #$0000014D,d5
02:0000385A 66FE            	  6071:                 bne.s *
                            	  6072: 
                            	  6073: 
                            	  6074: *        LONG LEFT
02:0000385C 203C80018FF1    	  6075:                 move.l #$80018FF1,d0
02:00003862 7C15            	  6076:                 moveq  #$00000015,d6
                            	  6077: ROXx_LOOP5:
02:00003864 EDB0            	  6078:                 roxl.l d6,d0
02:00003866 6100FF66        	  6079:                 bsr ROXx_FLAGS
02:0000386A 51CEFFF8        	  6080:                 dbf d6,ROXx_LOOP5
02:0000386E 0C80800185D0    	  6081:                 cmpi.l #$800185D0,d0
02:00003874 66FE            	  6082:                 bne.s *
02:00003876 0C85000001A1    	  6083:                 cmpi.l #$000001A1,d5
02:0000387C 66FE            	  6084:                 bne.s *
                            	  6085: 
                            	  6086: *        LONG RIGHT
02:0000387E 203C80018FF1    	  6087:                 move.l #$80018FF1,d0
02:00003884 7C16            	  6088:                 moveq  #$00000016,d6
                            	  6089: ROXx_LOOP6:
02:00003886 ECB0            	  6090:                 roxr.l d6,d0
02:00003888 6100FF44        	  6091:                 bsr ROXx_FLAGS
02:0000388C 51CEFFF8        	  6092:                 dbf d6,ROXx_LOOP6
02:00003890 0C80082D8200    	  6093:                 cmpi.l #$082D8200,d0
02:00003896 66FE            	  6094:                 bne.s *
02:00003898 0C85000001DE    	  6095:                 cmpi.l #$000001DE,d5
02:0000389E 66FE            	  6096:                 bne.s *
                            	  6097: 
                            	  6098: 
                            	  6099: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6100: 
02:000038A0 203C80018FF1    	  6101:                 move.l #$80018FF1,d0
02:000038A6 7A00            	  6102:                 moveq  #$00000000,d5
                            	  6103: 
                            	  6104: *        BYTE LEFT
02:000038A8 E310            	  6105:                 roxl.b #1,d0
02:000038AA 6100FF22        	  6106:                 bsr ROXx_FLAGS
02:000038AE EB10            	  6107:                 roxl.b #5,d0
02:000038B0 6100FF1C        	  6108:                 bsr ROXx_FLAGS
02:000038B4 EF10            	  6109:                 roxl.b #7,d0
02:000038B6 6100FF16        	  6110:                 bsr ROXx_FLAGS
02:000038BA E110            	  6111:                 roxl.b #8,d0
02:000038BC 6100FF10        	  6112:                 bsr ROXx_FLAGS
02:000038C0 0C8080018F09    	  6113:                 cmpi.l #$80018F09,d0
02:000038C6 66FE            	  6114:                 bne.s *
02:000038C8 0C850000000B    	  6115:                 cmpi.l #$0000000B,d5
02:000038CE 66FE            	  6116:                 bne.s *
                            	  6117: 
                            	  6118: *        BYTE RIGHT
02:000038D0 E210            	  6119:                 roxr.b #1,d0
02:000038D2 6100FEFA        	  6120:                 bsr ROXx_FLAGS
02:000038D6 EA10            	  6121:                 roxr.b #5,d0
02:000038D8 6100FEF4        	  6122:                 bsr ROXx_FLAGS
02:000038DC EE10            	  6123:                 roxr.b #7,d0
02:000038DE 6100FEEE        	  6124:                 bsr ROXx_FLAGS
02:000038E2 E010            	  6125:                 roxr.b #8,d0
02:000038E4 6100FEE8        	  6126:                 bsr ROXx_FLAGS
02:000038E8 0C8080018F00    	  6127:                 cmpi.l #$80018F00,d0
02:000038EE 66FE            	  6128:                 bne.s *
02:000038F0 0C8500000015    	  6129:                 cmpi.l #$00000015,d5
02:000038F6 66FE            	  6130:                 bne.s *
                            	  6131: 
                            	  6132: *        WORD LEFT
02:000038F8 E350            	  6133:                 roxl.w #1,d0
02:000038FA 6100FED2        	  6134:                 bsr ROXx_FLAGS
02:000038FE EB50            	  6135:                 roxl.w #5,d0
02:00003900 6100FECC        	  6136:                 bsr ROXx_FLAGS
02:00003904 EF50            	  6137:                 roxl.w #7,d0
02:00003906 6100FEC6        	  6138:                 bsr ROXx_FLAGS
02:0000390A E150            	  6139:                 roxl.w #8,d0
02:0000390C 6100FEC0        	  6140:                 bsr ROXx_FLAGS
02:00003910 0C808001B000    	  6141:                 cmpi.l #$8001B000,d0
02:00003916 66FE            	  6142:                 bne.s *
02:00003918 0C8500000027    	  6143:                 cmpi.l #$00000027,d5
02:0000391E 66FE            	  6144:                 bne.s *
                            	  6145: 
                            	  6146: *        WORD RIGHT
02:00003920 E250            	  6147:                 roxr.w #1,d0
02:00003922 6100FEAA        	  6148:                 bsr ROXx_FLAGS
02:00003926 EA50            	  6149:                 roxr.w #5,d0
02:00003928 6100FEA4        	  6150:                 bsr ROXx_FLAGS
02:0000392C EE50            	  6151:                 roxr.w #7,d0
02:0000392E 6100FE9E        	  6152:                 bsr ROXx_FLAGS
02:00003932 E050            	  6153:                 roxr.w #8,d0
02:00003934 6100FE98        	  6154:                 bsr ROXx_FLAGS
02:00003938 0C8080010A00    	  6155:                 cmpi.l #$80010A00,d0
02:0000393E 66FE            	  6156:                 bne.s *
02:00003940 0C8500000028    	  6157:                 cmpi.l #$00000028,d5
02:00003946 66FE            	  6158:                 bne.s *
                            	  6159: 
                            	  6160: *        LONG LEFT
02:00003948 E390            	  6161:                 roxl.l #1,d0
02:0000394A 6100FE82        	  6162:                 bsr ROXx_FLAGS
02:0000394E EB90            	  6163:                 roxl.l #5,d0
02:00003950 6100FE7C        	  6164:                 bsr ROXx_FLAGS
02:00003954 EF90            	  6165:                 roxl.l #7,d0
02:00003956 6100FE76        	  6166:                 bsr ROXx_FLAGS
02:0000395A E190            	  6167:                 roxl.l #8,d0
02:0000395C 6100FE70        	  6168:                 bsr ROXx_FLAGS
02:00003960 0C8040000010    	  6169:                 cmpi.l #$40000010,d0
02:00003966 66FE            	  6170:                 bne.s *
02:00003968 0C850000002A    	  6171:                 cmpi.l #$0000002A,d5
02:0000396E 66FE            	  6172:                 bne.s *
                            	  6173: 
                            	  6174: *        LONG RIGHT
02:00003970 E290            	  6175:                 roxr.l #1,d0
02:00003972 6100FE5A        	  6176:                 bsr ROXx_FLAGS
02:00003976 EA90            	  6177:                 roxr.l #5,d0
02:00003978 6100FE54        	  6178:                 bsr ROXx_FLAGS
02:0000397C EE90            	  6179:                 roxr.l #7,d0
02:0000397E 6100FE4E        	  6180:                 bsr ROXx_FLAGS
02:00003982 E090            	  6181:                 roxr.l #8,d0
02:00003984 6100FE48        	  6182:                 bsr ROXx_FLAGS
02:00003988 0C8000010200    	  6183:                 cmpi.l #$00010200,d0
02:0000398E 66FE            	  6184:                 bne.s *
02:00003990 0C8500000032    	  6185:                 cmpi.l #$00000032,d5
02:00003996 66FE            	  6186:                 bne.s *
                            	  6187: 
                            	  6188: 
                            	  6189: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6190: 
02:00003998 7A00            	  6191:                 moveq  #$00000000,d5
02:0000399A 307C0100        	  6192:                 move.l #$00000100,a0
02:0000399E 30BC8FF1        	  6193:                 move.w #$8FF1,(a0)
                            	  6194: 
                            	  6195: *        WORD LEFT
02:000039A2 E5D0            	  6196:                 roxl (a0)
02:000039A4 6100FE28        	  6197:                 bsr ROXx_FLAGS
02:000039A8 E5D0            	  6198:                 roxl (a0)
02:000039AA 6100FE22        	  6199:                 bsr ROXx_FLAGS
02:000039AE E5D0            	  6200:                 roxl (a0)
02:000039B0 6100FE1C        	  6201:                 bsr ROXx_FLAGS
02:000039B4 E5D0            	  6202:                 roxl (a0)
02:000039B6 6100FE16        	  6203:                 bsr ROXx_FLAGS
02:000039BA 3010            	  6204:                 move.w (a0),d0
02:000039BC 0C800001FF10    	  6205:                 cmpi.l #$0001FF10,d0
02:000039C2 66FE            	  6206:                 bne.s *
02:000039C4 0C8500000009    	  6207:                 cmpi.l #$00000009,d5
02:000039CA 66FE            	  6208:                 bne.s *
                            	  6209: 
                            	  6210: *        WORD RIGHT
02:000039CC E4D0            	  6211:                 roxr (a0)
02:000039CE 6100FDFE        	  6212:                 bsr ROXx_FLAGS
02:000039D2 E4D0            	  6213:                 roxr (a0)
02:000039D4 6100FDF8        	  6214:                 bsr ROXx_FLAGS
02:000039D8 E4D0            	  6215:                 roxr (a0)
02:000039DA 6100FDF2        	  6216:                 bsr ROXx_FLAGS
02:000039DE E4D0            	  6217:                 roxr (a0)
02:000039E0 6100FDEC        	  6218:                 bsr ROXx_FLAGS
02:000039E4 E4D0            	  6219:                 roxr (a0)
02:000039E6 6100FDE6        	  6220:                 bsr ROXx_FLAGS
02:000039EA E4D0            	  6221:                 roxr (a0)
02:000039EC 6100FDE0        	  6222:                 bsr ROXx_FLAGS
02:000039F0 3010            	  6223:                 move.w (a0),d0
02:000039F2 0C80000103FC    	  6224:                 cmpi.l #$000103FC,d0
02:000039F8 66FE            	  6225:                 bne.s *
02:000039FA 0C850000000A    	  6226:                 cmpi.l #$0000000A,d5
02:00003A00 66FE            	  6227:                 bne.s *
                            	  6228: 
02:00003A02 4E75            	  6229:                 rts
                            	  6230: 
                            	  6231: 
                            	  6232: 
                            	  6233: 
                            	  6234: *-----------------------------------------------------------
                            	  6235: *-----------------------------------------------------------
                            	  6236: * OPCODE : SHIFTS
                            	  6237: *-----------------------------------------------------------
                            	  6238: *-----------------------------------------------------------
                            	  6239: 
                            	  6240: *     Subroutine to check and accumulate the flags
02:00003A04 40C3            	  6241: SHIFTS_FLAGS:   move.w sr,d3
02:00003A06 02830000000F    	  6242:                 andi.l #$0F,d3            * Isolate flags
02:00003A0C DA83            	  6243:                 add.l d3,d5               * Copy flag results into accumulator
02:00003A0E 4E75            	  6244:                 rts
                            	  6245: 
                            	  6246: op_SHIFTS:
                            	  6247: 
                            	  6248: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6249: 
                            	  6250: *        BYTE LEFT
02:00003A10 203C80018F81    	  6251:                 move.l #$80018F81,d0
02:00003A16 7A00            	  6252:                 moveq  #$00000000,d5
02:00003A18 7C02            	  6253:                 moveq  #$00000002,d6
                            	  6254: SHIFTS_LOOP1:
02:00003A1A ED20            	  6255:                 asl.b d6,d0
02:00003A1C 61E6            	  6256:                 bsr SHIFTS_FLAGS
02:00003A1E 51CEFFFA        	  6257:                 dbf d6,SHIFTS_LOOP1
02:00003A22 0C8080018F08    	  6258:                 cmpi.l #$80018F08,d0
02:00003A28 66FE            	  6259:                 bne.s *
02:00003A2A 0C8500000002    	  6260:                 cmpi.l #$00000002,d5
02:00003A30 66FE            	  6261:                 bne.s *
                            	  6262: 
                            	  6263: *        BYTE RIGHT
02:00003A32 203C80018F81    	  6264:                 move.l #$80018F81,d0
02:00003A38 7C02            	  6265:                 moveq  #$00000002,d6
                            	  6266: SHIFTS_LOOP2:
02:00003A3A EC20            	  6267:                 asr.b d6,d0
02:00003A3C 61C6            	  6268:                 bsr SHIFTS_FLAGS
02:00003A3E 51CEFFFA        	  6269:                 dbf d6,SHIFTS_LOOP2
02:00003A42 0C8080018FF0    	  6270:                 cmpi.l #$80018FF0,d0
02:00003A48 66FE            	  6271:                 bne.s *
02:00003A4A 0C850000001A    	  6272:                 cmpi.l #$0000001A,d5
02:00003A50 66FE            	  6273:                 bne.s *
                            	  6274: 
                            	  6275: 
                            	  6276: *        WORD LEFT
02:00003A52 203C80018FF1    	  6277:                 move.l #$80018FF1,d0
02:00003A58 7C02            	  6278:                 moveq  #$00000002,d6
                            	  6279: SHIFTS_LOOP3:
02:00003A5A ED60            	  6280:                 asl.w d6,d0
02:00003A5C 61A6            	  6281:                 bsr SHIFTS_FLAGS
02:00003A5E 51CEFFFA        	  6282:                 dbf d6,SHIFTS_LOOP3
02:00003A62 0C8080017F88    	  6283:                 cmpi.l #$80017F88,d0
02:00003A68 66FE            	  6284:                 bne.s *
02:00003A6A 0C850000001C    	  6285:                 cmpi.l #$0000001C,d5
02:00003A70 66FE            	  6286:                 bne.s *
                            	  6287: 
                            	  6288: *        WORD RIGHT
02:00003A72 203C80018FF1    	  6289:                 move.l #$80018FF1,d0
02:00003A78 7C02            	  6290:                 moveq  #$00000002,d6
                            	  6291: SHIFTS_LOOP4:
02:00003A7A EC60            	  6292:                 asr.w d6,d0
02:00003A7C 6186            	  6293:                 bsr SHIFTS_FLAGS
02:00003A7E 51CEFFFA        	  6294:                 dbf d6,SHIFTS_LOOP4
02:00003A82 0C808001F1FE    	  6295:                 cmpi.l #$8001F1FE,d0
02:00003A88 66FE            	  6296:                 bne.s *
02:00003A8A 0C8500000034    	  6297:                 cmpi.l #$00000034,d5
02:00003A90 66FE            	  6298:                 bne.s *
                            	  6299: 
                            	  6300: 
                            	  6301: *        LONG LEFT
02:00003A92 203C80018FF1    	  6302:                 move.l #$80018FF1,d0
02:00003A98 7C02            	  6303:                 moveq  #$00000002,d6
                            	  6304: SHIFTS_LOOP5:
02:00003A9A EDA0            	  6305:                 asl.l d6,d0
02:00003A9C 6100FF66        	  6306:                 bsr SHIFTS_FLAGS
02:00003AA0 51CEFFF8        	  6307:                 dbf d6,SHIFTS_LOOP5
02:00003AA4 0C80000C7F88    	  6308:                 cmpi.l #$000C7F88,d0
02:00003AAA 66FE            	  6309:                 bne.s *
02:00003AAC 0C8500000036    	  6310:                 cmpi.l #$00000036,d5
02:00003AB2 66FE            	  6311:                 bne.s *
                            	  6312: 
                            	  6313: *        LONG RIGHT
02:00003AB4 203C80018FF1    	  6314:                 move.l #$80018FF1,d0
02:00003ABA 7C02            	  6315:                 moveq  #$00000002,d6
                            	  6316: SHIFTS_LOOP6:
02:00003ABC ECA0            	  6317:                 asr.l d6,d0
02:00003ABE 6100FF44        	  6318:                 bsr SHIFTS_FLAGS
02:00003AC2 51CEFFF8        	  6319:                 dbf d6,SHIFTS_LOOP6
02:00003AC6 0C80F00031FE    	  6320:                 cmpi.l #$F00031FE,d0
02:00003ACC 66FE            	  6321:                 bne.s *
02:00003ACE 0C850000004E    	  6322:                 cmpi.l #$0000004E,d5
02:00003AD4 66FE            	  6323:                 bne.s *
                            	  6324: 
                            	  6325: 
                            	  6326: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6327: 
02:00003AD6 203C80018FF1    	  6328:                 move.l #$80018FF1,d0
02:00003ADC 7A00            	  6329:                 moveq  #$00000000,d5
                            	  6330: 
                            	  6331: *        BYTE LEFT
02:00003ADE D000            	  6332:                 asl.b #1,d0
02:00003AE0 6100FF22        	  6333:                 bsr SHIFTS_FLAGS
02:00003AE4 E500            	  6334:                 asl.b #2,d0
02:00003AE6 6100FF1C        	  6335:                 bsr SHIFTS_FLAGS
02:00003AEA D000            	  6336:                 asl.b #1,d0
02:00003AEC 6100FF16        	  6337:                 bsr SHIFTS_FLAGS
02:00003AF0 E700            	  6338:                 asl.b #3,d0
02:00003AF2 6100FF10        	  6339:                 bsr SHIFTS_FLAGS
02:00003AF6 0C8080018F80    	  6340:                 cmpi.l #$80018F80,d0
02:00003AFC 66FE            	  6341:                 bne.s *
02:00003AFE 0C850000001F    	  6342:                 cmpi.l #$0000001F,d5
02:00003B04 66FE            	  6343:                 bne.s *
                            	  6344: 
                            	  6345: *        BYTE RIGHT
02:00003B06 E200            	  6346:                 asr.b #1,d0
02:00003B08 6100FEFA        	  6347:                 bsr SHIFTS_FLAGS
02:00003B0C E400            	  6348:                 asr.b #2,d0
02:00003B0E 6100FEF4        	  6349:                 bsr SHIFTS_FLAGS
02:00003B12 E600            	  6350:                 asr.b #3,d0
02:00003B14 6100FEEE        	  6351:                 bsr SHIFTS_FLAGS
02:00003B18 E200            	  6352:                 asr.b #1,d0
02:00003B1A 6100FEE8        	  6353:                 bsr SHIFTS_FLAGS
02:00003B1E 0C8080018FFF    	  6354:                 cmpi.l #$80018FFF,d0
02:00003B24 66FE            	  6355:                 bne.s *
02:00003B26 0C850000003F    	  6356:                 cmpi.l #$0000003F,d5
02:00003B2C 66FE            	  6357:                 bne.s *
                            	  6358: 
                            	  6359: *        WORD LEFT
02:00003B2E D040            	  6360:                 asl.w #1,d0
02:00003B30 6100FED2        	  6361:                 bsr SHIFTS_FLAGS
02:00003B34 E540            	  6362:                 asl.w #2,d0
02:00003B36 6100FECC        	  6363:                 bsr SHIFTS_FLAGS
02:00003B3A E740            	  6364:                 asl.w #3,d0
02:00003B3C 6100FEC6        	  6365:                 bsr SHIFTS_FLAGS
02:00003B40 EB40            	  6366:                 asl.w #5,d0
02:00003B42 6100FEC0        	  6367:                 bsr SHIFTS_FLAGS
02:00003B46 0C808001F800    	  6368:                 cmpi.l #$8001F800,d0
02:00003B4C 66FE            	  6369:                 bne.s *
02:00003B4E 0C8500000056    	  6370:                 cmpi.l #$00000056,d5
02:00003B54 66FE            	  6371:                 bne.s *
                            	  6372: 
                            	  6373: *        WORD RIGHT
02:00003B56 EA40            	  6374:                 asr.w #5,d0
02:00003B58 6100FEAA        	  6375:                 bsr SHIFTS_FLAGS
02:00003B5C E240            	  6376:                 asr.w #1,d0
02:00003B5E 6100FEA4        	  6377:                 bsr SHIFTS_FLAGS
02:00003B62 E440            	  6378:                 asr.w #2,d0
02:00003B64 6100FE9E        	  6379:                 bsr SHIFTS_FLAGS
02:00003B68 E840            	  6380:                 asr.w #4,d0
02:00003B6A 6100FE98        	  6381:                 bsr SHIFTS_FLAGS
02:00003B6E 0C808001FFFF    	  6382:                 cmpi.l #$8001FFFF,d0
02:00003B74 66FE            	  6383:                 bne.s *
02:00003B76 0C8500000077    	  6384:                 cmpi.l #$00000077,d5
02:00003B7C 66FE            	  6385:                 bne.s *
                            	  6386: 
                            	  6387: *        LONG LEFT
02:00003B7E 203C80018FF1    	  6388:                 move.l #$80018FF1,d0
02:00003B84 D080            	  6389:                 asl.l #1,d0
02:00003B86 6100FE7C        	  6390:                 bsr SHIFTS_FLAGS
02:00003B8A E580            	  6391:                 asl.l #2,d0
02:00003B8C 6100FE76        	  6392:                 bsr SHIFTS_FLAGS
02:00003B90 EF80            	  6393:                 asl.l #7,d0
02:00003B92 6100FE70        	  6394:                 bsr SHIFTS_FLAGS
02:00003B96 E980            	  6395:                 asl.l #4,d0
02:00003B98 6100FE6A        	  6396:                 bsr SHIFTS_FLAGS
02:00003B9C 0C8063FC4000    	  6397:                 cmpi.l #$63FC4000,d0
02:00003BA2 66FE            	  6398:                 bne.s *
02:00003BA4 0C850000007A    	  6399:                 cmpi.l #$0000007A,d5
02:00003BAA 66FE            	  6400:                 bne.s *
                            	  6401: 
                            	  6402: *        LONG RIGHT
02:00003BAC 203C80018FF1    	  6403:                 move.l #$80018FF1,d0
02:00003BB2 E280            	  6404:                 asr.l #1,d0
02:00003BB4 6100FE4E        	  6405:                 bsr SHIFTS_FLAGS
02:00003BB8 EA80            	  6406:                 asr.l #5,d0
02:00003BBA 6100FE48        	  6407:                 bsr SHIFTS_FLAGS
02:00003BBE EE80            	  6408:                 asr.l #7,d0
02:00003BC0 6100FE42        	  6409:                 bsr SHIFTS_FLAGS
02:00003BC4 E080            	  6410:                 asr.l #8,d0
02:00003BC6 6100FE3C        	  6411:                 bsr SHIFTS_FLAGS
02:00003BCA 0C80FFFFFC00    	  6412:                 cmpi.l #$FFFFFC00,d0
02:00003BD0 66FE            	  6413:                 bne.s *
02:00003BD2 0C850000009C    	  6414:                 cmpi.l #$0000009C,d5
02:00003BD8 66FE            	  6415:                 bne.s *
                            	  6416: 
                            	  6417: 
                            	  6418: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6419: 
02:00003BDA 7A00            	  6420:                 moveq  #$00000000,d5
02:00003BDC 307C0100        	  6421:                 move.l #$00000100,a0
02:00003BE0 30BC8FF1        	  6422:                 move.w #$8FF1,(a0)
                            	  6423: 
                            	  6424: *        WORD LEFT
02:00003BE4 E1D0            	  6425:                 asl  (a0)
02:00003BE6 6100FE1C        	  6426:                 bsr SHIFTS_FLAGS
02:00003BEA E1D0            	  6427:                 asl  (a0)
02:00003BEC 6100FE16        	  6428:                 bsr SHIFTS_FLAGS
02:00003BF0 E1D0            	  6429:                 asl  (a0)
02:00003BF2 6100FE10        	  6430:                 bsr SHIFTS_FLAGS
02:00003BF6 E1D0            	  6431:                 asl  (a0)
02:00003BF8 6100FE0A        	  6432:                 bsr SHIFTS_FLAGS
02:00003BFC 3010            	  6433:                 move.w (a0),d0
02:00003BFE 0C80FFFFFF10    	  6434:                 cmpi.l #$FFFFFF10,d0
02:00003C04 66FE            	  6435:                 bne.s *
02:00003C06 0C850000000D    	  6436:                 cmpi.l #$0000000D,d5
02:00003C0C 66FE            	  6437:                 bne.s *
                            	  6438: 
                            	  6439: *        WORD RIGHT
02:00003C0E E0D0            	  6440:                 asr (a0)
02:00003C10 6100FDF2        	  6441:                 bsr SHIFTS_FLAGS
02:00003C14 E0D0            	  6442:                 asr (a0)
02:00003C16 6100FDEC        	  6443:                 bsr SHIFTS_FLAGS
02:00003C1A E0D0            	  6444:                 asr (a0)
02:00003C1C 6100FDE6        	  6445:                 bsr SHIFTS_FLAGS
02:00003C20 E0D0            	  6446:                 asr (a0)
02:00003C22 6100FDE0        	  6447:                 bsr SHIFTS_FLAGS
02:00003C26 E0D0            	  6448:                 asr (a0)
02:00003C28 6100FDDA        	  6449:                 bsr SHIFTS_FLAGS
02:00003C2C E0D0            	  6450:                 asr (a0)
02:00003C2E 6100FDD4        	  6451:                 bsr SHIFTS_FLAGS
02:00003C32 3010            	  6452:                 move.w (a0),d0
02:00003C34 0C80FFFFFFFC    	  6453:                 cmpi.l #$FFFFFFFC,d0
02:00003C3A 66FE            	  6454:                 bne.s *
02:00003C3C 0C850000003E    	  6455:                 cmpi.l #$0000003E,d5
02:00003C42 66FE            	  6456:                 bne.s *
                            	  6457: 
02:00003C44 4E75            	  6458:                 rts
                            	  6459: 
                            	  6460: 
                            	  6461: 
                            	  6462: *-----------------------------------------------------------
                            	  6463: *-----------------------------------------------------------
                            	  6464: * OPCODE : SHIFTS2
                            	  6465: *-----------------------------------------------------------
                            	  6466: *-----------------------------------------------------------
                            	  6467: 
                            	  6468: *     Subroutine to check and accumulate the flags
02:00003C46 40C3            	  6469: SHIFTS2_FLAGS:  move.w sr,d3
02:00003C48 02830000000F    	  6470:                 andi.l #$0F,d3            * Isolate flags
02:00003C4E DA83            	  6471:                 add.l d3,d5               * Copy flag results into accumulator
02:00003C50 4E75            	  6472:                 rts
                            	  6473: 
                            	  6474: op_SHIFTS2:
                            	  6475: 
                            	  6476: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6477: 
                            	  6478: *        BYTE LEFT
02:00003C52 203C80018F81    	  6479:                 move.l #$80018F81,d0
02:00003C58 7A00            	  6480:                 moveq  #$00000000,d5
02:00003C5A 7C02            	  6481:                 moveq  #$00000002,d6
                            	  6482: SHIFTS2_LOOP1:
02:00003C5C ED28            	  6483:                 lsl.b d6,d0
02:00003C5E 61E6            	  6484:                 bsr SHIFTS2_FLAGS
02:00003C60 51CEFFFA        	  6485:                 dbf d6,SHIFTS2_LOOP1
02:00003C64 0C8080018F08    	  6486:                 cmpi.l #$80018F08,d0
02:00003C6A 66FE            	  6487:                 bne.s *
02:00003C6C 4A85            	  6488:                 cmpi.l #$00000000,d5
02:00003C6E 66FE            	  6489:                 bne.s *
                            	  6490: 
                            	  6491: *        BYTE RIGHT
02:00003C70 203C80018F81    	  6492:                 move.l #$80018F81,d0
02:00003C76 7C02            	  6493:                 moveq  #$00000002,d6
                            	  6494: SHIFTS2_LOOP2:
02:00003C78 EC28            	  6495:                 lsr.b d6,d0
02:00003C7A 61CA            	  6496:                 bsr SHIFTS2_FLAGS
02:00003C7C 51CEFFFA        	  6497:                 dbf d6,SHIFTS2_LOOP2
02:00003C80 0C8080018F10    	  6498:                 cmpi.l #$80018F10,d0
02:00003C86 66FE            	  6499:                 bne.s *
02:00003C88 4A85            	  6500:                 cmpi.l #$00000000,d5
02:00003C8A 66FE            	  6501:                 bne.s *
                            	  6502: 
                            	  6503: 
                            	  6504: *        WORD LEFT
02:00003C8C 203C80018FF1    	  6505:                 move.l #$80018FF1,d0
02:00003C92 7C02            	  6506:                 moveq  #$00000002,d6
                            	  6507: SHIFTS2_LOOP3:
02:00003C94 ED68            	  6508:                 lsl.w d6,d0
02:00003C96 61AE            	  6509:                 bsr SHIFTS2_FLAGS
02:00003C98 51CEFFFA        	  6510:                 dbf d6,SHIFTS2_LOOP3
02:00003C9C 0C8080017F88    	  6511:                 cmpi.l #$80017F88,d0
02:00003CA2 66FE            	  6512:                 bne.s *
02:00003CA4 4A85            	  6513:                 cmpi.l #$00000000,d5
02:00003CA6 66FE            	  6514:                 bne.s *
                            	  6515: 
                            	  6516: *        WORD RIGHT
02:00003CA8 203C80018FF1    	  6517:                 move.l #$80018FF1,d0
02:00003CAE 7C02            	  6518:                 moveq  #$00000002,d6
                            	  6519: SHIFTS2_LOOP4:
02:00003CB0 EC68            	  6520:                 lsr.w d6,d0
02:00003CB2 6192            	  6521:                 bsr SHIFTS2_FLAGS
02:00003CB4 51CEFFFA        	  6522:                 dbf d6,SHIFTS2_LOOP4
02:00003CB8 0C80800111FE    	  6523:                 cmpi.l #$800111FE,d0
02:00003CBE 66FE            	  6524:                 bne.s *
02:00003CC0 4A85            	  6525:                 cmpi.l #$00000000,d5
02:00003CC2 66FE            	  6526:                 bne.s *
                            	  6527: 
                            	  6528: 
                            	  6529: *        LONG LEFT
02:00003CC4 203C80018FF1    	  6530:                 move.l #$80018FF1,d0
02:00003CCA 7C02            	  6531:                 moveq  #$00000002,d6
                            	  6532: SHIFTS2_LOOP5:
02:00003CCC EDA8            	  6533:                 lsl.l d6,d0
02:00003CCE 6100FF76        	  6534:                 bsr SHIFTS2_FLAGS
02:00003CD2 51CEFFF8        	  6535:                 dbf d6,SHIFTS2_LOOP5
02:00003CD6 0C80000C7F88    	  6536:                 cmpi.l #$000C7F88,d0
02:00003CDC 66FE            	  6537:                 bne.s *
02:00003CDE 4A85            	  6538:                 cmpi.l #$00000000,d5
02:00003CE0 66FE            	  6539:                 bne.s *
                            	  6540: 
                            	  6541: *        LONG RIGHT
02:00003CE2 203C80018FF1    	  6542:                 move.l #$80018FF1,d0
02:00003CE8 7C02            	  6543:                 moveq  #$00000002,d6
                            	  6544: SHIFTS2_LOOP6:
02:00003CEA ECA8            	  6545:                 lsr.l d6,d0
02:00003CEC 6100FF58        	  6546:                 bsr SHIFTS2_FLAGS
02:00003CF0 51CEFFF8        	  6547:                 dbf d6,SHIFTS2_LOOP6
02:00003CF4 0C80100031FE    	  6548:                 cmpi.l #$100031FE,d0
02:00003CFA 66FE            	  6549:                 bne.s *
02:00003CFC 4A85            	  6550:                 cmpi.l #$00000000,d5
02:00003CFE 66FE            	  6551:                 bne.s *
                            	  6552: 
                            	  6553: 
                            	  6554: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6555: 
02:00003D00 203C80018FF1    	  6556:                 move.l #$80018FF1,d0
02:00003D06 7A00            	  6557:                 moveq  #$00000000,d5
                            	  6558: 
                            	  6559: *        BYTE LEFT
02:00003D08 E308            	  6560:                 lsl.b #1,d0
02:00003D0A 6100FF3A        	  6561:                 bsr SHIFTS2_FLAGS
02:00003D0E E508            	  6562:                 lsl.b #2,d0
02:00003D10 6100FF34        	  6563:                 bsr SHIFTS2_FLAGS
02:00003D14 E308            	  6564:                 lsl.b #1,d0
02:00003D16 6100FF2E        	  6565:                 bsr SHIFTS2_FLAGS
02:00003D1A E708            	  6566:                 lsl.b #3,d0
02:00003D1C 6100FF28        	  6567:                 bsr SHIFTS2_FLAGS
02:00003D20 0C8080018F80    	  6568:                 cmpi.l #$80018F80,d0
02:00003D26 66FE            	  6569:                 bne.s *
02:00003D28 0C850000001B    	  6570:                 cmpi.l #$0000001B,d5
02:00003D2E 66FE            	  6571:                 bne.s *
                            	  6572: 
                            	  6573: *        BYTE RIGHT
02:00003D30 E208            	  6574:                 lsr.b #1,d0
02:00003D32 6100FF12        	  6575:                 bsr SHIFTS2_FLAGS
02:00003D36 E408            	  6576:                 lsr.b #2,d0
02:00003D38 6100FF0C        	  6577:                 bsr SHIFTS2_FLAGS
02:00003D3C E608            	  6578:                 lsr.b #3,d0
02:00003D3E 6100FF06        	  6579:                 bsr SHIFTS2_FLAGS
02:00003D42 E208            	  6580:                 lsr.b #1,d0
02:00003D44 6100FF00        	  6581:                 bsr SHIFTS2_FLAGS
02:00003D48 0C8080018F01    	  6582:                 cmpi.l #$80018F01,d0
02:00003D4E 66FE            	  6583:                 bne.s *
02:00003D50 0C850000001B    	  6584:                 cmpi.l #$0000001B,d5
02:00003D56 66FE            	  6585:                 bne.s *
                            	  6586: 
                            	  6587: *        WORD LEFT
02:00003D58 E348            	  6588:                 lsl.w #1,d0
02:00003D5A 6100FEEA        	  6589:                 bsr SHIFTS2_FLAGS
02:00003D5E E548            	  6590:                 lsl.w #2,d0
02:00003D60 6100FEE4        	  6591:                 bsr SHIFTS2_FLAGS
02:00003D64 E748            	  6592:                 lsl.w #3,d0
02:00003D66 6100FEDE        	  6593:                 bsr SHIFTS2_FLAGS
02:00003D6A EB48            	  6594:                 lsl.w #5,d0
02:00003D6C 6100FED8        	  6595:                 bsr SHIFTS2_FLAGS
02:00003D70 0C8080010800    	  6596:                 cmpi.l #$80010800,d0
02:00003D76 66FE            	  6597:                 bne.s *
02:00003D78 0C8500000025    	  6598:                 cmpi.l #$00000025,d5
02:00003D7E 66FE            	  6599:                 bne.s *
                            	  6600: 
                            	  6601: *        WORD RIGHT
02:00003D80 EA48            	  6602:                 lsr.w #5,d0
02:00003D82 6100FEC2        	  6603:                 bsr SHIFTS2_FLAGS
02:00003D86 E248            	  6604:                 lsr.w #1,d0
02:00003D88 6100FEBC        	  6605:                 bsr SHIFTS2_FLAGS
02:00003D8C E448            	  6606:                 lsr.w #2,d0
02:00003D8E 6100FEB6        	  6607:                 bsr SHIFTS2_FLAGS
02:00003D92 E848            	  6608:                 lsr.w #4,d0
02:00003D94 6100FEB0        	  6609:                 bsr SHIFTS2_FLAGS
02:00003D98 0C8080010000    	  6610:                 cmpi.l #$80010000,d0
02:00003D9E 66FE            	  6611:                 bne.s *
02:00003DA0 0C850000002A    	  6612:                 cmpi.l #$0000002A,d5
02:00003DA6 66FE            	  6613:                 bne.s *
                            	  6614: 
                            	  6615: *        LONG LEFT
02:00003DA8 203C80018FF1    	  6616:                 move.l #$80018FF1,d0
02:00003DAE E388            	  6617:                 lsl.l #1,d0
02:00003DB0 6100FE94        	  6618:                 bsr SHIFTS2_FLAGS
02:00003DB4 E588            	  6619:                 lsl.l #2,d0
02:00003DB6 6100FE8E        	  6620:                 bsr SHIFTS2_FLAGS
02:00003DBA EF88            	  6621:                 lsl.l #7,d0
02:00003DBC 6100FE88        	  6622:                 bsr SHIFTS2_FLAGS
02:00003DC0 E988            	  6623:                 lsl.l #4,d0
02:00003DC2 6100FE82        	  6624:                 bsr SHIFTS2_FLAGS
02:00003DC6 0C8063FC4000    	  6625:                 cmpi.l #$63FC4000,d0
02:00003DCC 66FE            	  6626:                 bne.s *
02:00003DCE 0C850000002B    	  6627:                 cmpi.l #$0000002B,d5
02:00003DD4 66FE            	  6628:                 bne.s *
                            	  6629: 
                            	  6630: *        LONG RIGHT
02:00003DD6 203C80018FF1    	  6631:                 move.l #$80018FF1,d0
02:00003DDC E288            	  6632:                 lsr.l #1,d0
02:00003DDE 6100FE66        	  6633:                 bsr SHIFTS2_FLAGS
02:00003DE2 EA88            	  6634:                 lsr.l #5,d0
02:00003DE4 6100FE60        	  6635:                 bsr SHIFTS2_FLAGS
02:00003DE8 EE88            	  6636:                 lsr.l #7,d0
02:00003DEA 6100FE5A        	  6637:                 bsr SHIFTS2_FLAGS
02:00003DEE E088            	  6638:                 lsr.l #8,d0
02:00003DF0 6100FE54        	  6639:                 bsr SHIFTS2_FLAGS
02:00003DF4 0C8000000400    	  6640:                 cmpi.l #$00000400,d0
02:00003DFA 66FE            	  6641:                 bne.s *
02:00003DFC 0C850000002D    	  6642:                 cmpi.l #$0000002D,d5
02:00003E02 66FE            	  6643:                 bne.s *
                            	  6644: 
                            	  6645: 
                            	  6646: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6647: 
02:00003E04 7A00            	  6648:                 moveq  #$00000000,d5
02:00003E06 307C0100        	  6649:                 move.l #$00000100,a0
02:00003E0A 30BC8FF1        	  6650:                 move.w #$8FF1,(a0)
                            	  6651: 
                            	  6652: *        WORD LEFT
02:00003E0E E3D0            	  6653:                 lsl  (a0)
02:00003E10 6100FE34        	  6654:                 bsr SHIFTS2_FLAGS
02:00003E14 E3D0            	  6655:                 lsl  (a0)
02:00003E16 6100FE2E        	  6656:                 bsr SHIFTS2_FLAGS
02:00003E1A E3D0            	  6657:                 lsl  (a0)
02:00003E1C 6100FE28        	  6658:                 bsr SHIFTS2_FLAGS
02:00003E20 E3D0            	  6659:                 lsl  (a0)
02:00003E22 6100FE22        	  6660:                 bsr SHIFTS2_FLAGS
02:00003E26 3010            	  6661:                 move.w (a0),d0
02:00003E28 0C800000FF10    	  6662:                 cmpi.l #$0000FF10,d0
02:00003E2E 66FE            	  6663:                 bne.s *
02:00003E30 0C8500000009    	  6664:                 cmpi.l #$00000009,d5
02:00003E36 66FE            	  6665:                 bne.s *
                            	  6666: 
                            	  6667: *        WORD RIGHT
02:00003E38 E2D0            	  6668:                 lsr (a0)
02:00003E3A 6100FE0A        	  6669:                 bsr SHIFTS2_FLAGS
02:00003E3E E2D0            	  6670:                 lsr (a0)
02:00003E40 6100FE04        	  6671:                 bsr SHIFTS2_FLAGS
02:00003E44 E2D0            	  6672:                 lsr (a0)
02:00003E46 6100FDFE        	  6673:                 bsr SHIFTS2_FLAGS
02:00003E4A E2D0            	  6674:                 lsr (a0)
02:00003E4C 6100FDF8        	  6675:                 bsr SHIFTS2_FLAGS
02:00003E50 E2D0            	  6676:                 lsr (a0)
02:00003E52 6100FDF2        	  6677:                 bsr SHIFTS2_FLAGS
02:00003E56 E2D0            	  6678:                 lsr (a0)
02:00003E58 6100FDEC        	  6679:                 bsr SHIFTS2_FLAGS
02:00003E5C 3010            	  6680:                 move.w (a0),d0
02:00003E5E 0C80000003FC    	  6681:                 cmpi.l #$000003FC,d0
02:00003E64 66FE            	  6682:                 bne.s *
02:00003E66 0C850000000A    	  6683:                 cmpi.l #$0000000A,d5
02:00003E6C 66FE            	  6684:                 bne.s *
                            	  6685: 
02:00003E6E 4E75            	  6686:                 rts
                            	  6687: 
                            	  6688: ;-----------------------------------------------------------
                            	  6689: ;-----------------------------------------------------------
                            	  6690: ; OPCODE : BSR / RTS
                            	  6691: ;-----------------------------------------------------------
                            	  6692: ;-----------------------------------------------------------
                            	  6693: 
                            	  6694: ;t3_bsr:
                            	  6695: ;	moveq	#3,d3
                            	  6696: ;	rts
                            	  6697: 
                            	  6698: ;t1_bsr:
                            	  6699: ;	moveq	#1,d1
                            	  6700: ;	rts
                            	  6701: 
                            	  6702: ;op_bsr:
                            	  6703: ;	bsr			t1_bsr
                            	  6704: ;	bsr			t2_bsr
                            	  6705: ;	bsr.w		t3_bsr
                            	  6706: ;	bsr.w		t4_bsr
                            	  6707: ;	cmpi.l	#1,d1
                            	  6708: ;	bne			*
                            	  6709: ;	cmpi.l	#2,d2
                            	  6710: ;	bne			*
                            	  6711: ;	cmpi.l	#3,d3
                            	  6712: ;	bne			*
                            	  6713: ;	cmpi.l	#4,d4
                            	  6714: ;	bne			*
                            	  6715: ;	rts
                            	  6716: 
                            	  6717: ;t2_bsr:
                            	  6718: ;	moveq	#2,d2
                            	  6719: ;	rts
                            	  6720: 	
                            	  6721: ;t4_bsr:
                            	  6722: ;	moveq	#4,d4
                            	  6723: ;	rts
                            	  6724: *    END
                            	  6725:     
                            	  6726: 

Source: "boot.x68"
                            	   886: 	include "TinyBasicFlt.x68"

Source: "TinyBasicFlt.x68"
                            	     1: ******************************************************************
                            	     2: *								 *
                            	     3: *		Tiny Float BASIC for the Motorola MC68000		 *
                            	     4: *								 *
                            	     5: * Derived from Palo Alto Tiny BASIC as published in the May 1976 *
                            	     6: * issue of Dr. Dobb's Journal.  Adapted to the 68000 by:         *
                            	     7: *	Gordon Brandly						 *
                            	     8: *								 *
                            	     9: ******************************************************************
                            	    10: *    Copyright (C) 1984 by Gordon Brandly. This program may be	 *
                            	    11: *    freely distributed for personal use only. All commercial	 *
                            	    12: *		       rights are reserved.			 *
                            	    13: ******************************************************************
                            	    14: * Modified (c) 2022 for the rf68000. Robert Finch
                            	    15: * Numerics changed to floating-point
                            	    16: * added string handling
                            	    17: ******************************************************************
                            	    18: 
                            	    19: * Vers. 1.0  1984/7/17	- Original version by Gordon Brandly
                            	    20: *	1.1  1984/12/9	- Addition of '$' print term by Marvin Lipford
                            	    21: *	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                            	    22: 
                            	    23: *	OPT	FRS,BRS 	forward ref.'s & branches default to short
                            	    24: 
                            	    25: ;CR	EQU	$0D		ASCII equates
                            	    26: ;LF	EQU	$0A
                            	    27: ;TAB	EQU	$09
                            	    28: ;CTRLC	EQU	$03
                            	    29: ;CTRLH	EQU	$08
                            	    30: ;CTRLS	EQU	$13
                            	    31: ;CTRLX	EQU	$18
                            	    32: 
                            	    33: DT_NONE equ 0
                            	    34: DT_NUMERIC equ 1
                            	    35: DT_STRING equ 2		; string descriptor
                            	    36: DT_TEXTPTR equ 3	; pointer into program text
                            	    37: 
                            	    38: BUFLEN	EQU	80		length of keyboard input buffer
                            	    39: STRAREASIZE	EQU	2048	; size of string area
                            	    40: 	CODE
                            	    41: *	ORG	$10000		first free address using Tutor
                            	    42: *
                            	    43: * Standard jump table. You can change these addresses if you are
                            	    44: * customizing this interpreter for a different environment.
                            	    45: *
02:00003E70 6020            	    46: START	BRA	CSTART		Cold Start entry point
02:00003E72 60000088        	    47: GOWARM	BRA	WSTART		Warm Start entry point
02:00003E76 60001460        	    48: GOOUT	BRA OUTC		Jump to character-out routine
02:00003E7A 6000146C        	    49: GOIN	BRA INC		Jump to character-in routine
02:00003E7E 60001488        	    50: GOAUXO	BRA	AUXOUT		Jump to auxiliary-out routine
02:00003E82 60001498        	    51: GOAUXI	BRA	AUXIN		Jump to auxiliary-in routine
02:00003E86 600014B4        	    52: GOBYE	BRA	BYEBYE		Jump to monitor, DOS, etc.
                            	    53: *
                            	    54: * Modifiable system constants:
                            	    55: *
02:00003E8A 00041000        	    56: TXTBGN	DC.L	$41000		beginning of program memory
02:00003E8E 00047FF0        	    57: ENDMEM	DC.L	$47FF0		end of available memory
                            	    58: *
                            	    59: * The main interpreter starts here:
                            	    60: *
                            	    61: CSTART
02:00003E92 2E7AFFFA        	    62: 	MOVE.L ENDMEM,SP	initialize stack pointer
02:00003E96 23FC000052F40000	    63: 	move.l #INC1,INPPTR
02:00003E9E 53AC
02:00003EA0 4239000400A4    	    64: 	move.b #0,InputDevice
02:00003EA6 13FC0001000400A8	    65: 	move.b #1,OutputDevice
02:00003EAE 23FC000000010004	    66: 	move.l #1,_fpTextIncr
02:00003EB6 0094
02:00003EB8 4DFA1490        	    67: 	LEA	INITMSG,A6	tell who we are
02:00003EBC 61001402        	    68: 	BSR	PRMESG
02:00003EC0 23FAFFC8000053FC	    69: 	MOVE.L TXTBGN,TXTUNF	init. end-of-program pointer
02:00003EC8 203AFFC4        	    70: 	MOVE.L ENDMEM,D0	get address of end of memory
02:00003ECC 23FAFFC0000053B8	    71: 	move.l ENDMEM,STKFP
02:00003ED4 90BC00001000    	    72: 	SUB.L	#4096,D0	reserve 4K for the stack
02:00003EDA 23C0000053EC    	    73: 	MOVE.L D0,STRSTK
02:00003EE0 D0BC00000020    	    74: 	ADD.L #32,D0
02:00003EE6 23C000005404    	    75: 	MOVE.L D0,STKLMT
02:00003EEC 90BC00000200    	    76: 	SUB.L	#512,D0 	reserve variable area (32 16 byte floats)
02:00003EF2 23C000005400    	    77: 	MOVE.L D0,VARBGN
02:00003EF8 610000C2        	    78: 	bsr ClearStringArea
                            	    79: WSTART
02:00003EFC 7000            	    80: 	CLR.L	D0		initialize internal variables
02:00003EFE 23FC000000010004	    81: 	move.l #1,_fpTextIncr
02:00003F06 0094
02:00003F08 42B9000053E8    	    82: 	clr.l IRQROUT
02:00003F0E 23C0000053C4    	    83: 	MOVE.L	D0,LOPVAR
02:00003F14 23C0000053BC    	    84: 	MOVE.L	D0,STKGOS
02:00003F1A 23C0000053B4    	    85: 	MOVE.L	D0,CURRNT	; current line number pointer = 0
02:00003F20 2E7AFF6C        	    86: 	MOVE.L ENDMEM,SP	; init S.P. again, just in case
02:00003F24 610000B6        	    87: 	bsr ClearStringStack
02:00003F28 4DFA1444        	    88: 	LEA	OKMSG,A6			; display "OK"
02:00003F2C 61001392        	    89: 	bsr	PRMESG
                            	    90: ST3
02:00003F30 103C003E        	    91: 	MOVE.B	#'>',D0         Prompt with a '>' and
02:00003F34 610010CE        	    92: 	bsr	GETLN		read a line.
02:00003F38 6100132A        	    93: 	bsr	TOUPBUF 	convert to upper case
02:00003F3C 2848            	    94: 	MOVE.L	A0,A4		save pointer to end of line
02:00003F3E 41FA14CC        	    95: 	LEA	BUFFER,A0	point to the beginning of line
02:00003F42 610012CA        	    96: 	bsr	TSTNUM		is there a number there?
02:00003F46 61001312        	    97: 	bsr	IGNBLK		skip trailing blanks
02:00003F4A F2016080        	    98: 	FMOVE.L FP1,D1
02:00003F4E 4A82            	    99: 	TST.L D2			; does line no. exist? (or nonzero?)
02:00003F50 67000246        	   100: 	BEQ	DIRECT		; if not, it's a direct statement
02:00003F54 B2BC0000FFFF    	   101: 	CMP.L	#$FFFF,D1	see if line no. is <= 16 bits
02:00003F5A 6400109A        	   102: 	BCC	QHOW		if not, we've overflowed
02:00003F5E 1101            	   103: 	MOVE.B	D1,-(A0)	store the binary line no.
02:00003F60 E059            	   104: 	ROR	#8,D1		(Kludge to store a word on a
02:00003F62 1101            	   105: 	MOVE.B	D1,-(A0)	possible byte boundary)
02:00003F64 E159            	   106: 	ROL	#8,D1
02:00003F66 6100113A        	   107: 	bsr	FNDLN		find this line in save area
02:00003F6A 2A49            	   108: 	MOVE.L	A1,A5		save possible line pointer
02:00003F6C 6614            	   109: 	BNE	ST4		if not found, insert
02:00003F6E 61001158        	   110: 	bsr	FNDNXT		find the next line (into A1)
02:00003F72 244D            	   111: 	MOVE.L	A5,A2		pointer to line to be deleted
02:00003F74 267A1486        	   112: 	MOVE.L	TXTUNF,A3	points to top of save area
02:00003F78 6100115E        	   113: 	bsr	MVUP		move up to delete
02:00003F7C 23CA000053FC    	   114: 	MOVE.L	A2,TXTUNF	update the end pointer
                            	   115: ST4
02:00003F82 200C            	   116: 	MOVE.L	A4,D0		calculate the length of new line
02:00003F84 9088            	   117: 	SUB.L	A0,D0
02:00003F86 B0BC00000003    	   118: 	CMP.L	#3,D0		is it just a line no. & CR?
02:00003F8C 6FA2            	   119: 	BLE	ST3		if so, it was just a delete
02:00003F8E 267A146C        	   120: 	MOVE.L TXTUNF,A3	compute new end
02:00003F92 2C4B            	   121: 	MOVE.L A3,A6
02:00003F94 D7C0            	   122: 	ADD.L	D0,A3
02:00003F96 203A145C        	   123: 	MOVE.L StrArea,D0	see if there's enough room
02:00003F9A B08B            	   124: 	CMP.L	A3,D0
02:00003F9C 63001050        	   125: 	BLS	QSORRY		if not, say so
02:00003FA0 23CB000053FC    	   126: 	MOVE.L	A3,TXTUNF	if so, store new end position
02:00003FA6 224E            	   127: 	MOVE.L	A6,A1		points to old unfilled area
02:00003FA8 244D            	   128: 	MOVE.L	A5,A2		points to beginning of move area
02:00003FAA 61001140        	   129: 	bsr	MVDOWN		move things out of the way
02:00003FAE 2248            	   130: 	MOVE.L	A0,A1		set up to do the insertion
02:00003FB0 244D            	   131: 	MOVE.L	A5,A2
02:00003FB2 264C            	   132: 	MOVE.L	A4,A3
02:00003FB4 61001122        	   133: 	bsr	MVUP		do it
02:00003FB8 6000FF76        	   134: 	BRA	ST3		go back and get another line
                            	   135: 
                            	   136: ClearStringArea:
02:00003FBC 203A1442        	   137: 	move.l VARBGN,d0
02:00003FC0 90BC00000800    	   138: 	SUB.L #STRAREASIZE,D0
02:00003FC6 23C0000053F4    	   139: 	MOVE.L D0,StrArea
02:00003FCC 23C0000053F8    	   140: 	MOVE.L D0,LastStr
02:00003FD2 207A1420        	   141: 	move.l StrArea,a0
02:00003FD6 4298            	   142: 	clr.l (a0)+
02:00003FD8 4298            	   143: 	clr.l (a0)+
02:00003FDA 4E75            	   144: 	rts
                            	   145: 
                            	   146: ClearStringStack:
02:00003FDC 7007            	   147: 	moveq #7,d0
02:00003FDE 227A140C        	   148: 	move.l STRSTK,a1
                            	   149: .0001
02:00003FE2 4299            	   150: 	clr.l (a1)+				; clear the string stack
02:00003FE4 51C8FFFC        	   151: 	dbra d0,.0001
02:00003FE8 23C9000053F0    	   152: 	move.l a1,StrSp		; set string stack stack pointer
02:00003FEE 4E75            	   153: 	rts
                            	   154: 
                            	   155: 	even
                            	   156: 
                            	   157: *******************************************************************
                            	   158: *
                            	   159: * *** Tables *** DIRECT *** EXEC ***
                            	   160: *
                            	   161: * This section of the code tests a string against a table. When
                            	   162: * a match is found, control is transferred to the section of
                            	   163: * code according to the table.
                            	   164: *
                            	   165: * At 'EXEC', A0 should point to the string, A1 should point to
                            	   166: * the character table, and A2 should point to the execution
                            	   167: * table. At 'DIRECT', A0 should point to the string, A1 and
                            	   168: * A2 will be set up to point to TAB1 and TAB1_1, which are
                            	   169: * the tables of all direct and statement commands.
                            	   170: *
                            	   171: * A '.' in the string will terminate the test and the partial
                            	   172: * match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                            	   173: * 'PRIN.', or 'PRINT' will all match 'PRINT'.
                            	   174: *
                            	   175: * There are two tables: the character table and the execution
                            	   176: * table. The character table consists of any number of text items.
                            	   177: * Each item is a string of characters with the last character's
                            	   178: * high bit set to one. The execution table holds a 16-bit
                            	   179: * execution addresses that correspond to each entry in the
                            	   180: * character table.
                            	   181: *
                            	   182: * The end of the character table is a 0 byte which corresponds
                            	   183: * to the default routine in the execution table, which is
                            	   184: * executed if none of the other table items are matched.
                            	   185: *
                            	   186: * Character-matching tables:
                            	   187: TAB1
02:00003FF0 3C434F          	   188: 	DC.B	'<CO',('M'+$80)
02:00003FF3 CD
02:00003FF4 3C434F          	   189: 	DC.B	'<CO',('N'+$80)
02:00003FF7 CE
02:00003FF8 3E434F          	   190: 	DC.B	'>CO',('M'+$80)
02:00003FFB CD
02:00003FFC 3E434F          	   191: 	DC.B	'>CO',('N'+$80)
02:00003FFF CE
02:00004000 3C3E434F        	   192: 	DC.B	'<>CO',('M'+$80)
02:00004004 CD
02:00004005 3C3E434F        	   193: 	DC.B	'<>CO',('N'+$80)
02:00004009 CE
02:0000400A 4C4953          	   194: 	DC.B	'LIS',('T'+$80)         Direct commands
02:0000400D D4
02:0000400E 4C4F41          	   195: 	DC.B	'LOA',('D'+$80)
02:00004011 C4
02:00004012 4E45            	   196: 	DC.B	'NE',('W'+$80)
02:00004014 D7
02:00004015 5255            	   197: 	DC.B	'RU',('N'+$80)
02:00004017 CE
02:00004018 534156          	   198: 	DC.B	'SAV',('E'+$80)
02:0000401B C5
02:0000401C 434C            	   199: 	DC.B 	'CL',('S'+$80)
02:0000401E D3
                            	   200: TAB2
02:0000401F 4E4558          	   201: 	DC.B	'NEX',('T'+$80)         Direct / statement
02:00004022 D4
02:00004023 4C45            	   202: 	DC.B	'LE',('T'+$80)
02:00004025 D4
02:00004026 49              	   203: 	DC.B	'I',('F'+$80)
02:00004027 C6
02:00004028 474F54          	   204: 	DC.B	'GOT',('O'+$80)
02:0000402B CF
02:0000402C 474F5355        	   205: 	DC.B	'GOSU',('B'+$80)
02:00004030 C2
02:00004031 5245545552      	   206: 	DC.B	'RETUR',('N'+$80)
02:00004036 CE
02:00004037 5245            	   207: 	DC.B	'RE',('M'+$80)
02:00004039 CD
02:0000403A 464F            	   208: 	DC.B	'FO',('R'+$80)
02:0000403C D2
02:0000403D 494E5055        	   209: 	DC.B	'INPU',('T'+$80)
02:00004041 D4
02:00004042 5052494E        	   210: 	DC.B	'PRIN',('T'+$80)
02:00004046 D4
02:00004047 504F4B          	   211: 	DC.B	'POK',('E'+$80)
02:0000404A C5
02:0000404B 53544F          	   212: 	DC.B	'STO',('P'+$80)
02:0000404E D0
02:0000404F 4259            	   213: 	DC.B	'BY',('E'+$80)
02:00004051 C5
02:00004052 43414C          	   214: 	DC.B	'CAL',('L'+$80)
02:00004055 CC
02:00004056 4F4E4952        	   215: 	DC.B	'ONIR',('Q'+$80)
02:0000405A D1
02:0000405B 00              	   216: 	DC.B	0
                            	   217: TAB4
02:0000405C 504545          	   218: 	DC.B	'PEE',('K'+$80)         Functions
02:0000405F CB
02:00004060 524E            	   219: 	DC.B	'RN',('D'+$80)
02:00004062 C4
02:00004063 4142            	   220: 	DC.B	'AB',('S'+$80)
02:00004065 D3
02:00004066 53495A          	   221: 	DC.B	'SIZ',('E'+$80)
02:00004069 C5
02:0000406A 544943          	   222: 	DC.B	'TIC',('K'+$80)
02:0000406D CB
02:0000406E 434F52454E      	   223: 	DC.B	'COREN',('O'+$80)
02:00004073 CF
02:00004074 4C454654        	   224: 	DC.B	'LEFT',('$'+$80)
02:00004078 A4
02:00004079 5249474854      	   225: 	DC.B	'RIGHT',('$'+$80)
02:0000407E A4
02:0000407F 4D4944          	   226: 	DC.B	'MID',('$'+$80)
02:00004082 A4
02:00004083 4C45            	   227: 	DC.B	'LE',('N'+$80)
02:00004085 CE
02:00004086 494E            	   228: 	DC.B	'IN',('T'+$80)
02:00004088 D4
02:00004089 434852          	   229: 	DC.B	'CHR',('$'+$80)
02:0000408C A4
02:0000408D 00              	   230: 	DC.B	0
                            	   231: TAB5
02:0000408E 54              	   232: 	DC.B	'T',('O'+$80)           "TO" in "FOR"
02:0000408F CF
02:00004090 00              	   233: 	DC.B	0
                            	   234: TAB6
02:00004091 535445          	   235: 	DC.B	'STE',('P'+$80)         "STEP" in "FOR"
02:00004094 D0
02:00004095 00              	   236: 	DC.B	0
                            	   237: TAB8
02:00004096 3E              	   238: 	DC.B	'>',('='+$80)           Relational operators
02:00004097 BD
02:00004098 3C              	   239: 	DC.B	'<',('>'+$80)
02:00004099 BE
02:0000409A BE              	   240: 	DC.B	('>'+$80)
02:0000409B BD              	   241: 	DC.B	('='+$80)
02:0000409C 3C              	   242: 	DC.B	'<',('='+$80)
02:0000409D BD
02:0000409E BC              	   243: 	DC.B	('<'+$80)
02:0000409F 00              	   244: 	DC.B	0
02:000040A0 00              	   245: 	DC.B	0	<- for aligning on a word boundary
                            	   246: TAB9
02:000040A1 414E            	   247: 	DC.B	'AN',('D'+$80)
02:000040A3 C4
02:000040A4 00              	   248: 	DC.B	0
                            	   249: TAB10
02:000040A5 4F              	   250: 	DC.B	'O',('R'+$80)
02:000040A6 D2
02:000040A7 00              	   251: 	DC.B	0
                            	   252: TAB11
02:000040A8 4D4F            	   253: 	DC.B	'MO',('D'+$80)
02:000040AA C4
02:000040AB 00              	   254: 	DC.B	0
02:000040AC 00              	   255: 	DC.B	0
                            	   256: 
                            	   257: ; Execution address tables:
                            	   258: 	align 2
                            	   259: TAB1_1	
02:000040B0 000041F0        	   260: 	DC.L	INCOM
02:000040B4 000041E2        	   261: 	DC.L	INCON
02:000040B8 00004208        	   262: 	DC.L	OUTCOM
02:000040BC 0000421E        	   263: 	DC.L	OUTCON
02:000040C0 000041FE        	   264: 	DC.L	IOCOM
02:000040C4 00004214        	   265: 	DC.L	IOCON
02:000040C8 00004308        	   266: 	DC.L	LIST			Direct commands
02:000040CC 000045E6        	   267: 	DC.L	LOAD
02:000040D0 0000422A        	   268: 	DC.L	NEW
02:000040D4 00004246        	   269: 	DC.L	RUN
02:000040D8 00004646        	   270: 	DC.L	SAVE
02:000040DC 000052CC        	   271: 	DC.L	CLS
                            	   272: TAB2_1
02:000040E0 000044A4        	   273: 	DC.L	NEXT			Direct / statement
02:000040E4 000045D6        	   274: 	DC.L	LET
02:000040E8 00004510        	   275: 	DC.L	IF
02:000040EC 000042C0        	   276: 	DC.L	GOTO
02:000040F0 000043BE        	   277: 	DC.L	GOSUB
02:000040F4 000043F8        	   278: 	DC.L	RETURN
02:000040F8 0000450E        	   279: 	DC.L	REM
02:000040FC 00004424        	   280: 	DC.L	FOR
02:00004100 00004538        	   281: 	DC.L	INPUT
02:00004104 00004334        	   282: 	DC.L	PRINT
02:00004108 000046C4        	   283: 	DC.L	POKE
02:0000410C 0000423E        	   284: 	DC.L	STOP
02:00004110 00003E86        	   285: 	DC.L	GOBYE
02:00004114 0000473E        	   286: 	DC.L	CALL
02:00004118 000042D4        	   287: 	DC.L	ONIRQ
02:0000411C 000045CE        	   288: 	DC.L	DEFLT
                            	   289: TAB4_1
02:00004120 00004CEE        	   290: 	DC.L	PEEK			; Functions
02:00004124 00004D56        	   291: 	DC.L	RND
02:00004128 00004D80        	   292: 	DC.L	ABS
02:0000412C 00004D8C        	   293: 	DC.L	SIZE
02:00004130 00004D9C        	   294: 	DC.L	TICK
02:00004134 00004DA8        	   295: 	DC.L	CORENO
02:00004138 00004EBA        	   296: 	DC.L	LEFT
02:0000413C 00004EC6        	   297: 	DC.L	RIGHT
02:00004140 00004DF0        	   298: 	DC.L	MID
02:00004144 00004EEE        	   299: 	DC.L	LEN
02:00004148 00004F14        	   300: 	DC.L	INT
02:0000414C 00004F2A        	   301: 	DC.L  CHR
02:00004150 000049F8        	   302: 	DC.L	XP40
                            	   303: TAB5_1
02:00004154 0000443E        	   304: 	DC.L	FR1			; "TO" in "FOR"
02:00004158 00004FAE        	   305: 	DC.L	QWHAT
                            	   306: TAB6_1
02:0000415C 00004456        	   307: 	DC.L	FR2			; "STEP" in "FOR"
02:00004160 0000445C        	   308: 	DC.L	FR3
                            	   309: TAB8_1
02:00004164 0000482E        	   310: 	DC.L	XP11	>=		Relational operators
02:00004168 0000483A        	   311: 	DC.L	XP12	<>
02:0000416C 00004846        	   312: 	DC.L	XP13	>
02:00004170 0000485E        	   313: 	DC.L	XP15	=
02:00004174 00004852        	   314: 	DC.L	XP14	<=
02:00004178 0000486C        	   315: 	DC.L	XP16	<
02:0000417C 0000488A        	   316: 	DC.L	XP17
                            	   317: TAB9_1
02:00004180 000047EC        	   318: 	DC.L	XP_AND
02:00004184 00004802        	   319: 	DC.L	XP_ANDX
                            	   320: TAB10_1
02:00004188 000047C4        	   321: 	DC.L	XP_OR
02:0000418C 00004802        	   322: 	DC.L	XP_ORX
                            	   323: TAB11_1
02:00004190 000049CA        	   324: 	DC.L	XP_MOD
02:00004194 00004994        	   325: 	DC.L	XP31
                            	   326: 	even
                            	   327: 	
                            	   328: DIRECT
02:00004198 33FC000100005408	   329: 	move.w #1,DIRFLG
02:000041A0 43FAFE4E        	   330: 	LEA	TAB1,A1
02:000041A4 45FAFF0A        	   331: 	LEA	TAB1_1,A2
                            	   332: EXEC
02:000041A8 610010B0        	   333: 	bsr	IGNBLK				; ignore leading blanks
02:000041AC 2648            	   334: 	MOVE.L A0,A3			; save the pointer
02:000041AE 4202            	   335: 	CLR.B	D2					; clear match flag
                            	   336: EXLP
02:000041B0 1018            	   337: 	MOVE.B (A0)+,D0	 	; get the program character
02:000041B2 1211            	   338: 	MOVE.B (A1),D1 		; get the table character
02:000041B4 6604            	   339: 	BNE	EXNGO					; If end of table,
02:000041B6 204B            	   340: 	MOVE.L A3,A0			; restore the text pointer and...
02:000041B8 6024            	   341: 	BRA	EXGO					; execute the default.
                            	   342: EXNGO
02:000041BA 1600            	   343: 	MOVE.B D0,D3		 	; Else check for period...
02:000041BC C602            	   344: 	AND.B	D2,D3				; and a match.
02:000041BE B63C002E        	   345: 	CMP.B	#'.',D3
02:000041C2 671A            	   346: 	BEQ	EXGO					; if so, execute
02:000041C4 C23C007F        	   347: 	AND.B	#$7F,D1 		; ignore the table's high bit
02:000041C8 B200            	   348: 	CMP.B	D0,D1				; is there a match?
02:000041CA 670C            	   349: 	BEQ	EXMAT
02:000041CC 588A            	   350: 	ADDQ.L #4,A2			; if not, try the next entry
02:000041CE 204B            	   351: 	MOVE.L A3,A0			; reset the program pointer
02:000041D0 4202            	   352: 	CLR.B	D2					; sorry, no match
                            	   353: EX1
02:000041D2 4A19            	   354: 	TST.B	(A1)+				; get to the end of the entry
02:000041D4 6AFC            	   355: 	BPL	EX1
02:000041D6 60D8            	   356: 	BRA	EXLP					; back for more matching
                            	   357: EXMAT
02:000041D8 74FF            	   358: 	MOVEQ	#-1,D2			; we've got a match so far
02:000041DA 4A19            	   359: 	TST.B	(A1)+				; end of table entry?
02:000041DC 6AD2            	   360: 	BPL	EXLP					; if not, go back for more
                            	   361: EXGO
02:000041DE 2652            	   362: 	MOVE.L (A2),A3		; execute the appropriate routine
02:000041E0 4ED3            	   363: 	JMP	(A3)
                            	   364: 
                            	   365: *******************************************************************
                            	   366: * Console redirection
                            	   367: * <COM will redirect input to the COM port
                            	   368: * >COM will redirect output to the COM port
                            	   369: * <CON will redirect input to the console
                            	   370: * >CON will redirect output to the console
                            	   371: * <>COM will redirect input and output to the COM port
                            	   372: * <>CON will redirect input and output to the console
                            	   373: *******************************************************************
                            	   374: INCON
02:000041E2 23FC000052F40000	   375: 	move.l	#INC1,INPPTR
02:000041EA 53AC
02:000041EC 600001C8        	   376: 	bra			FINISH
                            	   377: INCOM
02:000041F0 23FC0000531C0000	   378: 	move.l	#AUXIN,INPPTR
02:000041F8 53AC
02:000041FA 600001BA        	   379: 	bra			FINISH
                            	   380: IOCOM
02:000041FE 23FC0000531C0000	   381: 	move.l	#AUXIN,INPPTR
02:00004206 53AC
                            	   382: OUTCOM
02:00004208 13FC0002000400A8	   383: 	move.b #2,OutputDevice
02:00004210 600001A4        	   384: 	bra	FINISH
                            	   385: IOCON
02:00004214 23FC000052F40000	   386: 	move.l	#INC1,INPPTR
02:0000421C 53AC
                            	   387: OUTCON
02:0000421E 13FC0001000400A8	   388: 	move.b #1,OutputDevice
02:00004226 6000018E        	   389: 	bra	FINISH
                            	   390: 
                            	   391: *******************************************************************
                            	   392: *
                            	   393: * What follows is the code to execute direct and statement
                            	   394: * commands. Control is transferred to these points via the command
                            	   395: * table lookup code of 'DIRECT' and 'EXEC' in the last section.
                            	   396: * After the command is executed, control is transferred to other
                            	   397: * sections as follows:
                            	   398: *
                            	   399: * For 'LIST', 'NEW', and 'STOP': go back to the warm start point.
                            	   400: * For 'RUN': go execute the first stored line if any; else go
                            	   401: * back to the warm start point.
                            	   402: * For 'GOTO' and 'GOSUB': go execute the target line.
                            	   403: * For 'RETURN' and 'NEXT'; go back to saved return line.
                            	   404: * For all others: if 'CURRNT' is 0, go to warm start; else go
                            	   405: * execute next command. (This is done in 'FINISH'.)
                            	   406: *
                            	   407: *******************************************************************
                            	   408: *
                            	   409: * *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                            	   410: *
                            	   411: * 'NEW<CR>' sets TXTUNF to point to TXTBGN
                            	   412: *
                            	   413: * 'STOP<CR>' goes back to WSTART
                            	   414: *
                            	   415: * 'RUN<CR>' finds the first stored line, stores its address
                            	   416: * in CURRNT, and starts executing it. Note that only those
                            	   417: * commands in TAB2 are legal for a stored program.
                            	   418: *
                            	   419: * There are 3 more entries in 'RUN':
                            	   420: * 'RUNNXL' finds next line, stores it's address and executes it.
                            	   421: * 'RUNTSL' stores the address of this line and executes it.
                            	   422: * 'RUNSML' continues the execution on same line.
                            	   423: *
                            	   424: * 'GOTO expr<CR>' evaluates the expression, finds the target
                            	   425: * line, and jumps to 'RUNTSL' to do it.
                            	   426: *
                            	   427: NEW
02:0000422A 61000D70        	   428: 	bsr	ENDCHK
02:0000422E 23FAFC5A000053FC	   429: 	MOVE.L TXTBGN,TXTUNF	set the end pointer
02:00004236 6100FD84        	   430: 	bsr ClearStringArea
02:0000423A 6100FDA0        	   431: 	bsr ClearStringStack
                            	   432: 
                            	   433: STOP
02:0000423E 61000D5C        	   434: 	bsr	ENDCHK
02:00004242 6000FCB8        	   435: 	BRA	WSTART
                            	   436: 
                            	   437: RUN
02:00004246 427900005408    	   438: 	clr.w DIRFLG
02:0000424C 61000D4E        	   439: 	bsr	ENDCHK
02:00004250 207AFC38        	   440: 	MOVE.L	TXTBGN,A0	set pointer to beginning
02:00004254 23C8000053B4    	   441: 	MOVE.L	A0,CURRNT
                            	   442: 
                            	   443: RUNNXL
02:0000425A 4AB9000053B4    	   444: 	TST.L	CURRNT		; executing a program?
02:00004260 6700FC9A        	   445: 	beq	WSTART			; if not, we've finished a direct stat.
02:00004264 4AB9000053E8    	   446: 	tst.l	IRQROUT		; are we handling IRQ's ?
02:0000426A 672E            	   447: 	beq	RUN1
02:0000426C 4A39000400A0    	   448: 	tst.b IRQFlag		; was there an IRQ ?
02:00004272 6726            	   449: 	beq	RUN1
02:00004274 4239000400A0    	   450: 	clr.b IRQFlag
                            	   451: 
                            	   452: 	; same code as GOSUB	
                            	   453: ;	sub.l #128,sp		; allocate storage for local variables
                            	   454: ;	move.l STKFP,-(sp)
                            	   455: ;	move.l sp,STKFP
02:0000427A 61000EB4        	   456: 	bsr	PUSHA				; save the current 'FOR' parameters
02:0000427E 2F08            	   457: 	MOVE.L A0,-(SP)	; save text pointer
02:00004280 2F3A1132        	   458: 	MOVE.L CURRNT,-(SP)	found it, save old 'CURRNT'...
02:00004284 2F3A1136        	   459: 	MOVE.L STKGOS,-(SP)	and 'STKGOS'
02:00004288 42B9000053C4    	   460: 	CLR.L	LOPVAR		; load new values
02:0000428E 23CF000053BC    	   461: 	MOVE.L SP,STKGOS
                            	   462: 
02:00004294 227A1152        	   463: 	move.l IRQROUT,a1
02:00004298 600C            	   464: 	bra	RUNTSL
                            	   465: RUN1
02:0000429A 7200            	   466: 	CLR.L	D1			; else find the next line number
02:0000429C 2248            	   467: 	MOVE.L A0,A1
02:0000429E 61000E10        	   468: 	bsr	FNDLNP
02:000042A2 6500FC58        	   469: 	BCS	WSTART		; if we've fallen off the end, stop
                            	   470: 
                            	   471: RUNTSL
02:000042A6 23C9000053B4    	   472: 	MOVE.L	A1,CURRNT	set CURRNT to point to the line no.
02:000042AC 2049            	   473: 	MOVE.L	A1,A0		set the text pointer to
02:000042AE 5488            	   474: 	ADDQ.L	#2,A0		the start of the line text
                            	   475: 
                            	   476: RUNSML
02:000042B0 61000FFC        	   477: 	bsr	CHKIO		see if a control-C was pressed
02:000042B4 43FAFD69        	   478: 	LEA	TAB2,A1 	find command in TAB2
02:000042B8 45FAFE26        	   479: 	LEA	TAB2_1,A2
02:000042BC 6000FEEA        	   480: 	BRA	EXEC		and execute it
                            	   481: 
                            	   482: GOTO	
02:000042C0 610004E0        	   483: 	bsr	INT_EXPR	; evaluate the following expression
02:000042C4 61000CD6        	   484: 	bsr	ENDCHK		; must find end of line
02:000042C8 2200            	   485: 	move.l d0,d1
02:000042CA 61000DD6        	   486: 	bsr	FNDLN			; find the target line
02:000042CE 66000D26        	   487: 	bne	QHOW			; no such line no.
02:000042D2 60D2            	   488: 	bra	RUNTSL		; go do it
                            	   489: 
                            	   490: ;******************************************************************
                            	   491: ; ONIRQ <line number>
                            	   492: ; ONIRQ sets up an interrupt handler which acts like a specialized
                            	   493: ; subroutine call. ONIRQ is coded like a GOTO that never executes.
                            	   494: ;******************************************************************
                            	   495: 
                            	   496: ONIRQ:
02:000042D4 610004CC        	   497: 	bsr	INT_EXPR		; evaluate the following expression
02:000042D8 61000CC2        	   498: 	bsr ENDCHK			; must find end of line
02:000042DC 2200            	   499: 	move.l d0,d1
02:000042DE 61000DC2        	   500: 	bsr FNDLN				; find the target line
02:000042E2 660A            	   501: 	bne	ONIRQ1
02:000042E4 42B9000053E8    	   502: 	clr.l IRQROUT
02:000042EA 600000CA        	   503: 	bra	FINISH
                            	   504: ONIRQ1:
02:000042EE 23C9000053E8    	   505: 	move.l a1,IRQROUT
02:000042F4 600000C0        	   506: 	jmp	FINISH
                            	   507: 
                            	   508: 
                            	   509: WAITIRQ:
02:000042F8 61000FB4        	   510: 	jsr	CHKIO				; see if a control-C was pressed
02:000042FC 4A39000400A0    	   511: 	tst.b IRQFlag
02:00004302 67F4            	   512: 	beq	WAITIRQ
02:00004304 600000B0        	   513: 	jmp	FINISH
                            	   514: 
                            	   515: *******************************************************************
                            	   516: *
                            	   517: * *** LIST *** PRINT ***
                            	   518: *
                            	   519: * LIST has two forms:
                            	   520: * 'LIST<CR>' lists all saved lines
                            	   521: * 'LIST #<CR>' starts listing at the line #
                            	   522: * Control-S pauses the listing, control-C stops it.
                            	   523: *
                            	   524: * PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                            	   525: * where '....' is a list of expressions, formats, back-arrows,
                            	   526: * and strings.	These items a separated by commas.
                            	   527: *
                            	   528: * A format is a pound sign followed by a number.  It controls
                            	   529: * the number of spaces the value of an expression is going to
                            	   530: * be printed in.  It stays effective for the rest of the print
                            	   531: * command unless changed by another format.  If no format is
                            	   532: * specified, 11 positions will be used.
                            	   533: *
                            	   534: * A string is quoted in a pair of single- or double-quotes.
                            	   535: *
                            	   536: * An underline (back-arrow) means generate a <CR> without a <LF>
                            	   537: *
                            	   538: * A <CR LF> is generated after the entire list has been printed
                            	   539: * or if the list is empty.  If the list ends with a semicolon,
                            	   540: * however, no <CR LF> is generated.
                            	   541: *
                            	   542: 
                            	   543: LIST	
02:00004308 61000F04        	   544: 	bsr	TSTNUM		see if there's a line no.
02:0000430C 61000C8E        	   545: 	bsr	ENDCHK		if not, we get a zero
02:00004310 61000D90        	   546: 	bsr	FNDLN		find this or next line
                            	   547: LS1
02:00004314 650000A0        	   548: 	BCS	FINISH		warm start if we passed the end
02:00004318 61000EBE        	   549: 	bsr	PRTLN		print the line
02:0000431C 61000F90        	   550: 	bsr	CHKIO		check for listing halt request
02:00004320 670C            	   551: 	BEQ	LS3
02:00004322 B03C0013        	   552: 	CMP.B	#CTRLS,D0	pause the listing?
02:00004326 6606            	   553: 	BNE	LS3
                            	   554: LS2
02:00004328 61000F84        	   555: 	bsr	CHKIO		if so, wait for another keypress
02:0000432C 67FA            	   556: 	BEQ	LS2
                            	   557: LS3
02:0000432E 61000D80        	   558: 	bsr	FNDLNP		find the next line
02:00004332 60E0            	   559: 	BRA	LS1
                            	   560: 
                            	   561: PRINT	
02:00004334 780B            	   562: 	MOVE.L #11,D4		D4 = number of print spaces
02:00004336 61000EBE        	   563: 	bsr	TSTC		if null list and ":"
02:0000433A 3A              	   564: 	DC.B	':',PR2-*
02:0000433B 09
02:0000433C 61001558        	   565: 	bsr	CRLF		give CR-LF and continue
02:00004340 6000FF6E        	   566: 	BRA	RUNSML		execution on the same line
                            	   567: PR2	
02:00004344 61000EB0        	   568: 	bsr	TSTC		if null list and <CR>
02:00004348 0D              	   569: 	DC.B	CR,PR0-*
02:00004349 09
02:0000434A 6100154A        	   570: 	bsr	CRLF		also give CR-LF and
02:0000434E 6000FF0A        	   571: 	BRA	RUNNXL		execute the next line
                            	   572: PR0
02:00004352 61000EA2        	   573: 	bsr	TSTC				; else is it a format?
02:00004356 23              	   574: 	dc.b '#',PR1-*
02:00004357 09
02:00004358 61000448        	   575: 	bsr	INT_EXPR		; yes, evaluate expression
02:0000435C 2800            	   576: 	move.l d0,d4		; and save it as print width
02:0000435E 600E            	   577: 	bra	PR3					; look for more to print
                            	   578: PR1
02:00004360 61000E94        	   579: 	bsr	TSTC				; is character expression? (MRL)
02:00004364 24              	   580: 	dc.b '$',PR8-*
02:00004365 1B
02:00004366 6100043A        	   581: 	bsr	INT_EXPR		; yep. Evaluate expression (MRL)
02:0000436A 6100FB0A        	   582: 	bsr	GOOUT				; print low byte (MRL)
                            	   583: 	bra	PR3					; look for more. (MRL)
                            	   584: PR3
02:0000436E 61000E86        	   585: 	bsr	TSTC						; if ",", go find next
02:00004372 2C              	   586: 	dc.b ',',PR6-*
02:00004373 07
02:00004374 61000C0C        	   587: 	bsr	FIN							; in the list.
02:00004378 60D8            	   588: 	BRA	PR0
                            	   589: PR6
02:0000437A 6100151A        	   590: 	bsr	CRLF						; list ends here
02:0000437E 6036            	   591: 	BRA	FINISH
                            	   592: PR8
02:00004380 2F04            	   593: 	move.l d4,-(SP)			; save the width value
02:00004382 61000430        	   594: 	bsr	EXPR						; evaluate the expression
02:00004386 281F            	   595: 	move.l (sp)+,d4			; restore the width
02:00004388 0C8000000002    	   596: 	cmpi.l #DT_STRING,d0	; is it a string?
02:0000438E 670C            	   597: 	beq PR9
02:00004390 F2000080        	   598: 	fmove fp0,fp1
02:00004394 7823            	   599: 	move.l #35,d4
02:00004396 61000DF6        	   600: 	bsr	PRTNUM					; print its value
02:0000439A 60D2            	   601: 	bra	PR3							; more to print?
                            	   602: 	; Print a string
                            	   603: PR9
02:0000439C F239680000040600	   604: 	fmove.x fp0,_fpWork
02:000043A4 323900040600    	   605: 	move.w _fpWork,d1
02:000043AA 227900040604    	   606: 	move.l _fpWork+4,a1
02:000043B0 61000DD6        	   607: 	bsr PRTSTR2
02:000043B4 60B8            	   608: 	bra PR3
                            	   609: 
                            	   610: FINISH
02:000043B6 61000BCA        	   611: 	bsr	FIN			; Check end of command
02:000043BA 60000BF2        	   612: 	BRA	QWHAT		; print "What?" if wrong
                            	   613: 
                            	   614: ;******************************************************************
                            	   615: ;
                            	   616: ; *** GOSUB *** & RETURN ***
                            	   617: ;
                            	   618: ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                            	   619: ; except that the current text pointer, stack pointer, etc. are
                            	   620: ; saved so that execution can be continued after the subroutine
                            	   621: ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                            	   622: ; recursive), the save area must be stacked.  The stack pointer
                            	   623: ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                            	   624: ; If we are in the main routine, 'STKGOS' is zero (this was done
                            	   625: ; in the initialization section of the interpreter), but we still
                            	   626: ; save it as a flag for no further 'RETURN's.
                            	   627: ;
                            	   628: ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                            	   629: ; returns the execution to the command after the most recent
                            	   630: ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                            	   631: ; a 'GOSUB' and is thus an error.
                            	   632: 
                            	   633: GOSUB:
02:000043BE 4FEFFF80        	   634: 	sub.l #128,sp		; allocate storage for local variables
02:000043C2 2F3A0FF4        	   635: 	move.l STKFP,-(sp)
02:000043C6 23CF000053B8    	   636: 	move.l sp,STKFP
02:000043CC 61000D62        	   637: 	bsr	PUSHA				; save the current 'FOR' parameters
02:000043D0 610003D0        	   638: 	bsr	INT_EXPR		; get line number
02:000043D4 2F08            	   639: 	MOVE.L	A0,-(SP)	save text pointer
02:000043D6 2200            	   640: 	move.l	d0,d1
02:000043D8 61000CC8        	   641: 	bsr	FNDLN		find the target line
02:000043DC 66000C1A        	   642: 	BNE	AHOW		if not there, say "How?"
02:000043E0 2F3A0FD2        	   643: 	MOVE.L	CURRNT,-(SP)	found it, save old 'CURRNT'...
02:000043E4 2F3A0FD6        	   644: 	MOVE.L	STKGOS,-(SP)	and 'STKGOS'
02:000043E8 42B9000053C4    	   645: 	CLR.L	LOPVAR		load new values
02:000043EE 23CF000053BC    	   646: 	MOVE.L	SP,STKGOS
02:000043F4 6000FEB0        	   647: 	BRA	RUNTSL
                            	   648: 
                            	   649: RETURN:
02:000043F8 61000BA2        	   650: 	bsr	ENDCHK					; there should be just a <CR>
02:000043FC 223A0FBE        	   651: 	MOVE.L	STKGOS,D1		; get old stack pointer
02:00004400 67000BAC        	   652: 	BEQ	QWHAT						; if zero, it doesn't exist
02:00004404 2E41            	   653: 	MOVE.L	D1,SP				; else restore it
02:00004406 23DF000053BC    	   654: 	MOVE.L	(SP)+,STKGOS	; and the old 'STKGOS'
02:0000440C 23DF000053B4    	   655: 	MOVE.L	(SP)+,CURRNT	; and the old 'CURRNT'
02:00004412 205F            	   656: 	MOVE.L	(SP)+,A0		; and the old text pointer
02:00004414 61000CDE        	   657: 	bsr	POPA						; and the old 'FOR' parameters
                            	   658: ;	move.l STKFP,sp
02:00004418 23DF000053B8    	   659: 	move.l (sp)+,STKFP
02:0000441E 4FEF0080        	   660: 	add.l #128,sp				; remove local variable storage
02:00004422 6092            	   661: 	BRA	FINISH					; and we are back home
                            	   662: 
                            	   663: *******************************************************************
                            	   664: *
                            	   665: * *** FOR *** & NEXT ***
                            	   666: *
                            	   667: * 'FOR' has two forms:
                            	   668: * 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                            	   669: * The second form means the same thing as the first form with a
                            	   670: * STEP of positive 1.  The interpreter will find the variable 'var'
                            	   671: * and set its value to the current value of 'exp1'.  It also
                            	   672: * evaluates 'exp2' and 'exp1' and saves all these together with
                            	   673: * the text pointer, etc. in the 'FOR' save area, which consisits of
                            	   674: * 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                            	   675: * already something in the save area (indicated by a non-zero
                            	   676: * 'LOPVAR'), then the old save area is saved on the stack before
                            	   677: * the new values are stored.  The interpreter will then dig in the
                            	   678: * stack and find out if this same variable was used in another
                            	   679: * currently active 'FOR' loop.  If that is the case, then the old
                            	   680: * 'FOR' loop is deactivated. (i.e. purged from the stack)
                            	   681: *
                            	   682: * 'NEXT var' serves as the logical (not necessarily physical) end
                            	   683: * of the 'FOR' loop.  The control variable 'var' is checked with
                            	   684: * the 'LOPVAR'.  If they are not the same, the interpreter digs in
                            	   685: * the stack to find the right one and purges all those that didn't
                            	   686: * match.  Either way, it then adds the 'STEP' to that variable and
                            	   687: * checks the result with against the limit value.  If it is within
                            	   688: * the limit, control loops back to the command following the
                            	   689: * 'FOR'.  If it's outside the limit, the save area is purged and
                            	   690: * execution continues.
                            	   691: 
                            	   692: FOR
02:00004424 61000D0A        	   693: 	bsr	PUSHA			; save the old 'FOR' save area
02:00004428 61000B38        	   694: 	bsr	SETVAL		; set the control variable
02:0000442C 23CE000053C4    	   695: 	move.l a6,LOPVAR		; save its address
02:00004432 43FAFC5A        	   696: 	LEA	TAB5,A1 	; use 'EXEC' to test for 'TO'
02:00004436 45FAFD1C        	   697: 	LEA	TAB5_1,A2
02:0000443A 6000FD6C        	   698: 	BRA	EXEC
                            	   699: FR1	
02:0000443E 61000354        	   700: 	bsr	NUM_EXPR		; evaluate the limit
02:00004442 F2396800000053D4	   701: 	FMOVE.X	FP0,LOPLMT	; save that
02:0000444A 43FAFC45        	   702: 	LEA	TAB6,A1 		; use 'EXEC' to look for the
02:0000444E 45FAFD0C        	   703: 	LEA	TAB6_1,A2		; word 'STEP'
02:00004452 6000FD54        	   704: 	BRA	EXEC
                            	   705: FR2
02:00004456 6100033C        	   706: 	bsr	NUM_EXPR		found it, get the step value
02:0000445A 6006            	   707: 	BRA	FR4
                            	   708: FR3
02:0000445C F23C58000001    	   709: 	FMOVE.B #1,FP0	; not found, step defaults to 1
                            	   710: FR4
02:00004462 F2396800000053C8	   711: 	FMOVE.X	FP0,LOPINC	save that too
                            	   712: FR5	
02:0000446A 23FA0F48000053E0	   713: 	MOVE.L	CURRNT,LOPLN	save address of current line number
02:00004472 23C8000053E4    	   714: 	MOVE.L	A0,LOPPT	and text pointer
02:00004478 2C4F            	   715: 	MOVE.L	SP,A6		dig into the stack to find 'LOPVAR'
02:0000447A 600C            	   716: 	BRA	FR7
                            	   717: FR6
02:0000447C 4DEE0024        	   718: 	lea 36(a6),a6			; look at next stack frame
02:00004480 BDFAFA0C        	   719: 	cmp.l ENDMEM,a6		; safety check
02:00004484 64000B28        	   720: 	bhs QWHAT
                            	   721: FR7
02:00004488 2016            	   722: 	MOVE.L	(A6),D0 	; is it zero?
02:0000448A 6714            	   723: 	BEQ	FR8						; if so, we're done
02:0000448C B0BA0F36        	   724: 	CMP.L	LOPVAR,D0		; same as current LOPVAR?
02:00004490 66EA            	   725: 	BNE	FR6						; nope, look some more
02:00004492 244F            	   726: 	MOVE.L	SP,A2			; Else remove 9 long words from...
02:00004494 224E            	   727: 	MOVE.L	A6,A1			; inside the stack.
02:00004496 47E90024        	   728: 	lea	36(a1),a3
02:0000449A 61000C50        	   729: 	bsr	MVDOWN
02:0000449E 2E4B            	   730: 	MOVE.L	A3,SP		set the SP 9 long words up
                            	   731: FR8
02:000044A0 6000FF14        	   732: 	BRA	FINISH		and continue execution
                            	   733: 
                            	   734: NEXT	
02:000044A4 6100078A        	   735: 	bsr	TSTV						; get address of variable
02:000044A8 65000B04        	   736: 	bcs	QWHAT						; if no variable, say "What?"
02:000044AC 2240            	   737: 	move.l d0,a1				; save variable's address
                            	   738: NX0
02:000044AE 203A0F14        	   739: 	move.l LOPVAR,D0		; If 'LOPVAR' is zero, we never...
02:000044B2 67000AFA        	   740: 	beq	QWHAT						; had a FOR loop, so say "What?"
02:000044B6 B3C0            	   741: 	cmp.l	d0,a1					; else we check them
02:000044B8 6706            	   742: 	beq	NX3							; OK, they agree
02:000044BA 61000C38        	   743: 	bsr	POPA						; nope, let's see the next frame
02:000044BE 60EE            	   744: 	bra	NX0
                            	   745: NX3	
02:000044C0 F22948000004    	   746: 	fmove.x	4(a1),fp0		; get control variable's value
02:000044C6 F23A48220EFE    	   747: 	fadd.x LOPINC,fp0		; add in loop increment
                            	   748: ;	BVS	QHOW		say "How?" for 32-bit overflow
02:000044CC F22968000004    	   749: 	fmove.x	fp0,4(a1)		; save control variable's new value
02:000044D2 F23A48800EFE    	   750: 	fmove.x	LOPLMT,fp1	; get loop's limit value
02:000044D8 F23A503A0EEC    	   751: 	ftst LOPINC
02:000044DE F293000E        	   752: 	FBGE NX1				; branch if loop increment is positive
02:000044E2 F2276800        	   753: 	FMOVE.X FP0,-(a7)	; exchange FP0,FP1
02:000044E6 F2000400        	   754: 	FMOVE.X FP1,FP0
02:000044EA F21F4880        	   755: 	FMOVE.X (a7)+,FP1
                            	   756: NX1	
02:000044EE F20000B8        	   757: 	FCMP FP0,FP1		;	test against limit
02:000044F2 F2940012        	   758: 	FBLT NX2				; branch if outside limit
02:000044F6 23FA0EE8000053B4	   759: 	MOVE.L LOPLN,CURRNT	Within limit, go back to the...
02:000044FE 207A0EE4        	   760: 	MOVE.L LOPPT,A0	saved 'CURRNT' and text pointer.
02:00004502 6000FEB2        	   761: 	BRA	FINISH
                            	   762: NX2
02:00004506 61000BEC        	   763: 	bsr	POPA		purge this loop
02:0000450A 6000FEAA        	   764: 	BRA	FINISH
                            	   765: 
                            	   766: *******************************************************************
                            	   767: *
                            	   768: * *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                            	   769: *
                            	   770: * 'REM' can be followed by anything and is ignored by the
                            	   771: * interpreter.
                            	   772: *
                            	   773: * 'IF' is followed by an expression, as a condition and one or
                            	   774: * more commands (including other 'IF's) separated by colons.
                            	   775: * Note that the word 'THEN' is not used.  The interpreter evaluates
                            	   776: * the expression.  If it is non-zero, execution continues.  If it
                            	   777: * is zero, the commands that follow are ignored and execution
                            	   778: * continues on the next line.
                            	   779: *
                            	   780: * 'INPUT' is like the 'PRINT' command, and is followed by a list
                            	   781: * of items.  If the item is a string in single or double quotes,
                            	   782: * or is an underline (back arrow), it has the same effect as in
                            	   783: * 'PRINT'.  If an item is a variable, this variable name is
                            	   784: * printed out followed by a colon, then the interpreter waits for
                            	   785: * an expression to be typed in.  The variable is then set to the
                            	   786: * value of this expression.  If the variable is preceeded by a
                            	   787: * string (again in single or double quotes), the string will be
                            	   788: * displayed followed by a colon.  The interpreter the waits for an
                            	   789: * expression to be entered and sets the variable equal to the
                            	   790: * expression's value.  If the input expression is invalid, the
                            	   791: * interpreter will print "What?", "How?", or "Sorry" and reprint
                            	   792: * the prompt and redo the input.  The execution will not terminate
                            	   793: * unless you press control-C.  This is handled in 'INPERR'.
                            	   794: *
                            	   795: * 'LET' is followed by a list of items separated by commas.
                            	   796: * Each item consists of a variable, an equals sign, and an
                            	   797: * expression.  The interpreter evaluates the expression and sets
                            	   798: * the variable to that value.  The interpreter will also handle
                            	   799: * 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                            	   800: 
                            	   801: REM
02:0000450E 600A            	   802: 	BRA	IF2		skip the rest of the line
                            	   803: 
                            	   804: IF
02:00004510 61000290        	   805: 	bsr	INT_EXPR		evaluate the expression
                            	   806: IF1
02:00004514 4A80            	   807: 	TST.L	d0		is it zero?
02:00004516 6600FD98        	   808: 	BNE	RUNSML		if not, continue
                            	   809: IF2
02:0000451A 2248            	   810: 	MOVE.L	A0,A1
02:0000451C 7200            	   811: 	CLR.L	D1
02:0000451E 61000BAA        	   812: 	bsr	FNDSKP		if so, skip the rest of the line
02:00004522 6400FD82        	   813: 	BCC	RUNTSL		and run the next line
02:00004526 6000F9D4        	   814: 	BRA	WSTART		if no next line, do a warm start
                            	   815: 
02:0000452A 2E7A0E94        	   816: INPERR	MOVE.L	STKINP,SP	restore the old stack pointer
02:0000452E 23DF000053B4    	   817: 	MOVE.L	(SP)+,CURRNT	and old 'CURRNT'
02:00004534 588F            	   818: 	ADDQ.L	#4,SP
02:00004536 205F            	   819: 	MOVE.L	(SP)+,A0	and old text pointer
                            	   820: 
                            	   821: INPUT	
02:00004538 2F08            	   822: 	MOVE.L	A0,-(SP)	save in case of error
02:0000453A 61000278        	   823: 	bsr EXPR
02:0000453E 0C000002        	   824: 	cmpi.b #DT_STRING,d0
02:00004542 6622            	   825: 	bne IP6
02:00004544 F239680000040600	   826: 	fmove.x fp0,_fpWork
02:0000454C 323900040600    	   827: 	move.w _fpWork,d1
02:00004552 227900040604    	   828: 	move.l _fpWork+4,a1
02:00004558 61000C2E        	   829: 	bsr PRTSTR2
                            	   830: ;	bsr	QTSTG		is next item a string?
                            	   831: ;	BRA.S	IP2		nope
                            	   832: IP7
02:0000455C 610006D2        	   833: 	bsr	TSTV		yes, but is it followed by a variable?
02:00004560 655C            	   834: 	BCS	IP4		if not, branch
02:00004562 2440            	   835: 	MOVE.L	D0,A2		put away the variable's address
02:00004564 601E            	   836: 	BRA	IP3		if so, input to variable
                            	   837: IP6
02:00004566 2057            	   838: 	move.l (sp),a0	; restore text pointer
02:00004568 60F2            	   839: 	bra IP7
                            	   840: IP2
02:0000456A 2F08            	   841: 	MOVE.L	A0,-(SP)	save for 'PRTSTG'
02:0000456C 610006C2        	   842: 	bsr	TSTV		must be a variable now
02:00004570 65000A3C        	   843: 	BCS	QWHAT		"What?" it isn't?
02:00004574 2440            	   844: 	MOVE.L	D0,A2		put away the variable's address
02:00004576 1410            	   845: 	MOVE.B	(A0),D2 	get ready for 'PRTSTG'
02:00004578 4200            	   846: 	CLR.B	D0
02:0000457A 1080            	   847: 	MOVE.B	D0,(A0)
02:0000457C 225F            	   848: 	MOVE.L	(SP)+,A1
02:0000457E 61000BE6        	   849: 	bsr	PRTSTG		print string as prompt
02:00004582 1082            	   850: 	MOVE.B	D2,(A0) 	restore text
                            	   851: IP3
02:00004584 2F08            	   852: 	MOVE.L	A0,-(SP)	save in case of error
02:00004586 2F3A0E2C        	   853: 	MOVE.L	CURRNT,-(SP)	also save 'CURRNT'
02:0000458A 23FCFFFFFFFF0000	   854: 	MOVE.L	#-1,CURRNT	flag that we are in INPUT
02:00004592 53B4
02:00004594 23CF000053C0    	   855: 	MOVE.L	SP,STKINP	save the stack pointer too
02:0000459A 2F0A            	   856: 	MOVE.L	A2,-(SP)	save the variable address
02:0000459C 103C003A        	   857: 	MOVE.B	#':',D0         print a colon first
02:000045A0 61000A62        	   858: 	bsr	GETLN		then get an input line
02:000045A4 41FA0E66        	   859: 	LEA	BUFFER,A0	point to the buffer
02:000045A8 6100020A        	   860: 	bsr	EXPR		evaluate the input
02:000045AC 245F            	   861: 	MOVE.L	(SP)+,A2	restore the variable address
02:000045AE 2480            	   862: 	move.l d0,(a2)			; save data type
02:000045B0 F22A68000004    	   863: 	FMOVE.X	FP0,4(A2) 	; save value in variable
02:000045B6 23DF000053B4    	   864: 	MOVE.L	(SP)+,CURRNT	restore old 'CURRNT'
02:000045BC 205F            	   865: 	MOVE.L	(SP)+,A0	and the old text pointer
                            	   866: IP4
02:000045BE 588F            	   867: 	ADDQ.L	#4,SP		clean up the stack
02:000045C0 61000C34        	   868: 	bsr	TSTC		is the next thing a comma?
02:000045C4 2C              	   869: 	DC.B	',',IP5-*
02:000045C5 05
02:000045C6 6000FF70        	   870: 	BRA	INPUT		yes, more items
                            	   871: IP5
02:000045CA 6000FDEA        	   872: 	BRA	FINISH
                            	   873: 
                            	   874: DEFLT
02:000045CE 0C10000D        	   875: 	CMP.B	#CR,(A0)	; empty line is OK
02:000045D2 6700FDE2        	   876: 	BEQ	FINISH			; else it is 'LET'
                            	   877: 
                            	   878: LET
02:000045D6 6100098A        	   879: 	bsr	SETVAL		 	; do the assignment
02:000045DA 61000C1A        	   880: 	bsr	TSTC				; check for more 'LET' items
02:000045DE 2C              	   881: 	DC.B	',',LT1-*
02:000045DF 03
02:000045E0 60F4            	   882: 	BRA	LET
                            	   883: LT1
02:000045E2 6000FDD2        	   884: 	BRA	FINISH			; until we are finished.
                            	   885: 
                            	   886: 
                            	   887: *******************************************************************
                            	   888: *
                            	   889: * *** LOAD *** & SAVE ***
                            	   890: *
                            	   891: * These two commands transfer a program to/from an auxiliary
                            	   892: * device such as a cassette, another computer, etc.  The program
                            	   893: * is converted to an easily-stored format: each line starts with
                            	   894: * a colon, the line no. as 4 hex digits, and the rest of the line.
                            	   895: * At the end, a line starting with an '@' sign is sent.  This
                            	   896: * format can be read back with a minimum of processing time by
                            	   897: * the 68000.
                            	   898: *
                            	   899: LOAD	
02:000045E6 207AF8A2        	   900: 	MOVE.L TXTBGN,A0	set pointer to start of prog. area
02:000045EA 103C000D        	   901: 	MOVE.B #CR,D0		For a CP/M host, tell it we're ready...
02:000045EE 6100F88E        	   902: 	BSR	GOAUXO		by sending a CR to finish PIP command.
                            	   903: LOD1	
02:000045F2 6100F88E        	   904: 	BSR	GOAUXI		look for start of line
02:000045F6 67FA            	   905: 	BEQ	LOD1
02:000045F8 B03C0040        	   906: 	CMP.B	#'@',D0         end of program?
02:000045FC 671E            	   907: 	BEQ	LODEND
02:000045FE B03C003A        	   908: 	CMP.B	#':',D0         if not, is it start of line?
02:00004602 66EE            	   909: 	BNE	LOD1		if not, wait for it
02:00004604 6120            	   910: 	BSR	GBYTE		get first byte of line no.
02:00004606 10C1            	   911: 	MOVE.B	D1,(A0)+	store it
02:00004608 611C            	   912: 	BSR	GBYTE		get 2nd bye of line no.
02:0000460A 10C1            	   913: 	MOVE.B	D1,(A0)+	store that, too
                            	   914: LOD2
02:0000460C 6100F874        	   915: 	BSR	GOAUXI		get another text char.
02:00004610 67FA            	   916: 	BEQ	LOD2
02:00004612 10C0            	   917: 	MOVE.B	D0,(A0)+	store it
02:00004614 B03C000D        	   918: 	CMP.B	#CR,D0		is it the end of the line?
02:00004618 66F2            	   919: 	BNE	LOD2		if not, go back for more
02:0000461A 60D6            	   920: 	BRA	LOD1		if so, start a new line
                            	   921: LODEND
02:0000461C 23C8000053FC    	   922: 	MOVE.L	A0,TXTUNF	set end-of program pointer
02:00004622 6000F8D8        	   923: 	BRA	WSTART		back to direct mode
                            	   924: 
                            	   925: GBYTE
02:00004626 7401            	   926: 	MOVEQ	#1,D2		get two hex characters from auxiliary
02:00004628 7200            	   927: 	CLR.L	D1		and store them as a byte in D1
                            	   928: GBYTE1	
02:0000462A 6100F856        	   929: 	BSR	GOAUXI		get a char.
02:0000462E 67FA            	   930: 	BEQ	GBYTE1
02:00004630 B03C0041        	   931: 	CMP.B	#'A',D0
02:00004634 6502            	   932: 	BCS	GBYTE2
02:00004636 5F00            	   933: 	SUBQ.B	#7,D0		if greater than 9, adjust
                            	   934: GBYTE2
02:00004638 C03C000F        	   935: 	AND.B	#$F,D0		strip ASCII
02:0000463C E909            	   936: 	LSL.B	#4,D1		put nybble into the result
02:0000463E 8200            	   937: 	OR.B	D0,D1
02:00004640 51CAFFE8        	   938: 	DBRA	D2,GBYTE1	get another char.
02:00004644 4E75            	   939: 	RTS
                            	   940: 
                            	   941: SAVE
02:00004646 207AF842        	   942: 	MOVE.L	TXTBGN,A0	set pointer to start of prog. area
02:0000464A 227A0DB0        	   943: 	MOVE.L	TXTUNF,A1	set pointer to end of prog. area
                            	   944: SAVE1	
02:0000464E 103C000D        	   945: 	MOVE.B	#CR,D0		send out a CR & LF (CP/M likes this)
02:00004652 6100F82A        	   946: 	BSR	GOAUXO
02:00004656 103C000A        	   947: 	MOVE.B	#LF,D0
02:0000465A 6100F822        	   948: 	BSR	GOAUXO
02:0000465E B3C8            	   949: 	CMP.L	A0,A1		are we finished?
02:00004660 631E            	   950: 	BLS	SAVEND
02:00004662 103C003A        	   951: 	MOVE.B	#':',D0         if not, start a line
02:00004666 6100F816        	   952: 	BSR	GOAUXO
02:0000466A 1218            	   953: 	MOVE.B	(A0)+,D1	send first half of line no.
02:0000466C 6136            	   954: 	BSR	PBYTE
02:0000466E 1218            	   955: 	MOVE.B	(A0)+,D1	and send 2nd half
02:00004670 6132            	   956: 	BSR	PBYTE
                            	   957: SAVE2
02:00004672 1018            	   958: 	MOVE.B	(A0)+,D0	get a text char.
02:00004674 B03C000D        	   959: 	CMP.B	#CR,D0		is it the end of the line?
02:00004678 67D4            	   960: 	BEQ	SAVE1		if so, send CR & LF and start new line
02:0000467A 6100F802        	   961: 	BSR	GOAUXO		send it out
02:0000467E 60F2            	   962: 	BRA	SAVE2		go back for more text
                            	   963: SAVEND
02:00004680 103C0040        	   964: 	MOVE.B	#'@',D0         send end-of-program indicator
02:00004684 6100F7F8        	   965: 	BSR	GOAUXO
02:00004688 103C000D        	   966: 	MOVE.B	#CR,D0		followed by a CR & LF
02:0000468C 6100F7F0        	   967: 	BSR	GOAUXO
02:00004690 103C000A        	   968: 	MOVE.B	#LF,D0
02:00004694 6100F7E8        	   969: 	BSR	GOAUXO
02:00004698 103C001A        	   970: 	MOVE.B	#$1A,D0 	and a control-Z to end the CP/M file
02:0000469C 6100F7E0        	   971: 	BSR	GOAUXO
02:000046A0 6000F85A        	   972: 	BRA	WSTART		then go do a warm start
                            	   973: 
02:000046A4 7401            	   974: PBYTE	MOVEQ	#1,D2		send two hex characters from D1's low byte
02:000046A6 E919            	   975: PBYTE1	ROL.B	#4,D1		get the next nybble
02:000046A8 1001            	   976: 	MOVE.B	D1,D0
02:000046AA C03C000F        	   977: 	AND.B	#$F,D0		strip off garbage
02:000046AE D03C0030        	   978: 	ADD.B	#'0',D0         make it into ASCII
02:000046B2 B03C0039        	   979: 	CMP.B	#'9',D0
02:000046B6 6302            	   980: 	BLS	PBYTE2
02:000046B8 5E00            	   981: 	ADDQ.B	#7,D0		adjust if greater than 9
02:000046BA 6100F7C2        	   982: PBYTE2	BSR	GOAUXO		send it out
02:000046BE 51CAFFE6        	   983: 	DBRA	D2,PBYTE1	then send the next nybble
02:000046C2 4E75            	   984: 	RTS
                            	   985: 
                            	   986: *******************************************************************
                            	   987: *
                            	   988: * *** POKE *** & CALL ***
                            	   989: *
                            	   990: * 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                            	   991: * address specified by 'expr1'.
                            	   992: *
                            	   993: * 'CALL expr' jumps to the machine language subroutine whose
                            	   994: * starting address is specified by 'expr'.  The subroutine can use
                            	   995: * all registers but must leave the stack the way it found it.
                            	   996: * The subroutine returns to the interpreter by executing an RTS.
                            	   997: *
                            	   998: POKE
02:000046C4 1E3C0042        	   999: 	move.b #'B',d7
02:000046C8 1210            	  1000: 	move.b (a0),d1
02:000046CA 0C01002E        	  1001: 	cmpi.b #'.',d1
02:000046CE 6620            	  1002: 	bne .0001
02:000046D0 5248            	  1003: 	addq #1,a0
02:000046D2 1210            	  1004: 	move.b (a0),d1
02:000046D4 0C010042        	  1005: 	cmpi.b #'B',d1
02:000046D8 6712            	  1006: 	beq .0002
02:000046DA 0C010057        	  1007: 	cmpi.b #'W',d1
02:000046DE 670C            	  1008: 	beq .0002
02:000046E0 0C01004C        	  1009: 	cmpi.b #'L',d1
02:000046E4 6706            	  1010: 	beq .0002
02:000046E6 0C010046        	  1011: 	cmpi.b #'F',d1
02:000046EA 664E            	  1012: 	bne	PKER
                            	  1013: .0002
02:000046EC 5248            	  1014: 	addq #1,a0
02:000046EE 1E01            	  1015: 	move.b d1,d7
                            	  1016: .0001
02:000046F0 610000B0        	  1017: 	BSR	INT_EXPR		get the memory address
02:000046F4 61000B00        	  1018: 	bsr	TSTC		it must be followed by a comma
02:000046F8 2C              	  1019: 	DC.B	',',PKER-*
02:000046F9 41
02:000046FA 2F00            	  1020: 	move.l d0,-(sp)		; save the address
02:000046FC 61000096        	  1021: 	BSR	NUM_EXPR			; get the value to be POKE'd
02:00004700 225F            	  1022: 	move.l	(sp)+,a1	; get the address back
02:00004702 0C070042        	  1023: 	CMPI.B #'B',D7
02:00004706 6608            	  1024: 	BNE .0003
02:00004708 F2117800        	  1025: 	FMOVE.B	FP0,(A1) 	store the byte in memory
02:0000470C 6000FCA8        	  1026: 	BRA	FINISH
                            	  1027: .0003
02:00004710 0C070057        	  1028: 	CMPI.B #'W',d7
02:00004714 6608            	  1029: 	BNE .0004
02:00004716 F2117000        	  1030: 	FMOVE.W FP0,(A1)
02:0000471A 6000FC9A        	  1031: 	BRA FINISH
                            	  1032: .0004
02:0000471E 0C07004C        	  1033: 	CMPI.B #'L',D7
02:00004722 6608            	  1034: 	BNE .0005
02:00004724 F2116000        	  1035: 	FMOVE.L FP0,(A1)
02:00004728 6000FC8C        	  1036: 	BRA FINISH
                            	  1037: .0005
02:0000472C 0C070046        	  1038: 	CMPI.B #'F',D7
02:00004730 6608            	  1039: 	BNE .0006
02:00004732 F2116800        	  1040: 	FMOVE.X FP0,(A1)
02:00004736 6000FC7E        	  1041: 	BRA FINISH
                            	  1042: .0006
                            	  1043: PKER
02:0000473A 60000872        	  1044: 	BRA	QWHAT		if no comma, say "What?"
                            	  1045: 
                            	  1046: CALL	
02:0000473E 6162            	  1047: 	BSR	INT_EXPR		; get the subroutine's address
02:00004740 4A80            	  1048: 	TST.l d0				; make sure we got a valid address
02:00004742 670008B2        	  1049: 	BEQ QHOW				; if not, say "How?"
02:00004746 2F08            	  1050: 	MOVE.L A0,-(SP)	; save the text pointer
02:00004748 2240            	  1051: 	MOVE.L D0,A1
02:0000474A 4E91            	  1052: 	JSR	(A1)				; jump to the subroutine
02:0000474C 205F            	  1053: 	MOVE.L (SP)+,A0	; restore the text pointer
02:0000474E 6000FC66        	  1054: 	BRA	FINISH
                            	  1055: 
                            	  1056: *******************************************************************
                            	  1057: *
                            	  1058: * *** EXPR ***
                            	  1059: *
                            	  1060: * 'EXPR' evaluates arithmetical or logical expressions.
                            	  1061: * <EXPR>::=<EXPR2>
                            	  1062: *	   <EXPR2><rel.op.><EXPR2>
                            	  1063: * where <rel.op.> is one of the operators in TAB8 and the result
                            	  1064: * of these operations is 1 if true and 0 if false.
                            	  1065: * <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                            	  1066: * where () are optional and (... are optional repeats.
                            	  1067: * <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                            	  1068: * <EXPR4>::=<variable>
                            	  1069: *	    <function>
                            	  1070: *	    (<EXPR>)
                            	  1071: * <EXPR> is recursive so that the variable '@' can have an <EXPR>
                            	  1072: * as an index, functions can have an <EXPR> as arguments, and
                            	  1073: * <EXPR4> can be an <EXPR> in parenthesis.
                            	  1074: 
                            	  1075: ;-------------------------------------------------------------------------------
                            	  1076: ; Push a value on the stack.
                            	  1077: ;-------------------------------------------------------------------------------
                            	  1078: 
                            	  1079: XP_PUSH:
02:00004752 225F            	  1080: 	move.l (sp)+,a1				; a1 = return address
02:00004754 2F3900040098    	  1081: 	move.l _canary,-(sp)	; push the canary
02:0000475A 4FEFFFF0        	  1082: 	sub.l #16,sp					; allocate for value
02:0000475E 2E80            	  1083: 	move.l d0,(sp)				; push data type
02:00004760 F22F68000004    	  1084: 	fmove.x fp0,4(sp)			; and value
02:00004766 4ED1            	  1085: 	jmp (a1)
                            	  1086: 
                            	  1087: ;-------------------------------------------------------------------------------
                            	  1088: ; Pop value from stack into first operand.
                            	  1089: ;-------------------------------------------------------------------------------
                            	  1090: 	
                            	  1091: XP_POP:
02:00004768 225F            	  1092: 	move.l (sp)+,a1			; get return address
02:0000476A 2017            	  1093: 	move.l (sp),d0			; pop data type
02:0000476C F22F48000004    	  1094: 	fmove.x 4(sp),fp0		; and data element
02:00004772 4FEF0010        	  1095: 	add.l #16,sp
02:00004776 A2970003        	  1096: 	cchk (sp)						; check the canary
02:0000477A 588F            	  1097: 	add.l #4,sp					; pop canary	
02:0000477C 4ED1            	  1098: 	jmp (a1)
                            	  1099: 
                            	  1100: ;-------------------------------------------------------------------------------
                            	  1101: ; Pop value from stack into second operand.
                            	  1102: ;-------------------------------------------------------------------------------
                            	  1103: 
                            	  1104: XP_POP1:
02:0000477E 225F            	  1105: 	move.l (sp)+,a1			; get return address
02:00004780 2217            	  1106: 	move.l (sp),d1			; pop data type
02:00004782 F22F48800004    	  1107: 	fmove.x 4(sp),fp1		; and data element
02:00004788 4FEF0010        	  1108: 	add.l #16,sp
02:0000478C A2970003        	  1109: 	cchk (sp)						; check the canary
02:00004790 588F            	  1110: 	add.l #4,sp					; pop canary
02:00004792 4ED1            	  1111: 	jmp (a1)
                            	  1112: 
                            	  1113: ;-------------------------------------------------------------------------------
                            	  1114: ; Get and expression and make sure it is numeric.
                            	  1115: ;-------------------------------------------------------------------------------
                            	  1116: 
                            	  1117: NUM_EXPR:
02:00004794 611E            	  1118: 	bsr EXPR
02:00004796 0C8000000001    	  1119: 	cmpi.l #DT_NUMERIC,d0
02:0000479C 66000860        	  1120: 	bne ETYPE
02:000047A0 4E75            	  1121: 	rts
                            	  1122: 
                            	  1123: ;-------------------------------------------------------------------------------
                            	  1124: ; Get and expression and make sure it is numeric. Convert to integer.
                            	  1125: ;-------------------------------------------------------------------------------
                            	  1126: 
                            	  1127: INT_EXPR:
02:000047A2 6110            	  1128: 	bsr EXPR
02:000047A4 0C8000000001    	  1129: 	cmpi.l #DT_NUMERIC,d0
02:000047AA 66000852        	  1130: 	bne ETYPE
02:000047AE F2006000        	  1131: 	fmove.l fp0,d0
02:000047B2 4E75            	  1132: 	rts
                            	  1133: 
                            	  1134: ;-------------------------------------------------------------------------------
                            	  1135: ; The top level of the expression parser.
                            	  1136: ; Get an expression, string or numeric.
                            	  1137: ;
                            	  1138: ; EXEC will smash a lot of regs, so push the current expression value before
                            	  1139: ; doing EXEC
                            	  1140: ;-------------------------------------------------------------------------------
                            	  1141: 
                            	  1142: EXPR
                            	  1143: EXPR_OR
02:000047B4 6124            	  1144: 	BSR EXPR_AND
02:000047B6 619A            	  1145: 	BSR XP_PUSH
02:000047B8 43FAF8EB        	  1146: 	LEA TAB10,A1
02:000047BC 45FAF9CA        	  1147: 	LEA TAB10_1,A2
02:000047C0 6000F9E6        	  1148: 	BRA EXEC
                            	  1149: 	
                            	  1150: ;-------------------------------------------------------------------------------
                            	  1151: ; Boolean 'Or' level
                            	  1152: ;-------------------------------------------------------------------------------
                            	  1153: 
                            	  1154: XP_OR
02:000047C4 6114            	  1155: 	BSR EXPR_AND
02:000047C6 61B6            	  1156: 	bsr XP_POP1
02:000047C8 613E            	  1157: 	bsr CheckNumeric
02:000047CA F2016080        	  1158: 	FMOVE.L FP1,D1
02:000047CE F2006000        	  1159: 	FMOVE.L FP0,D0
02:000047D2 8081            	  1160: 	OR.L D1,D0
02:000047D4 F2004000        	  1161: 	FMOVE.L D0,FP0
02:000047D8 4E75            	  1162: 	rts
                            	  1163: 	
                            	  1164: ;-------------------------------------------------------------------------------
                            	  1165: ; Boolean 'And' level
                            	  1166: ;-------------------------------------------------------------------------------
                            	  1167: 
                            	  1168: EXPR_AND
02:000047DA 613E            	  1169: 	bsr EXPR_REL
02:000047DC 6100FF74        	  1170: 	bsr XP_PUSH
02:000047E0 43FAF8BF        	  1171: 	LEA TAB9,A1
02:000047E4 45FAF99A        	  1172: 	LEA TAB9_1,A2
02:000047E8 6000F9BE        	  1173: 	BRA EXEC
                            	  1174: 
                            	  1175: XP_AND
02:000047EC 612C            	  1176: 	BSR EXPR_REL
02:000047EE 618E            	  1177: 	bsr XP_POP1
02:000047F0 6116            	  1178: 	bsr CheckNumeric
02:000047F2 F2016080        	  1179: 	FMOVE.L FP1,D1
02:000047F6 F2006000        	  1180: 	FMOVE.L FP0,D0
02:000047FA C081            	  1181: 	AND.L D1,D0
02:000047FC F2004000        	  1182: 	FMOVE.L D0,FP0
02:00004800 4E75            	  1183: 	RTS
                            	  1184: 	
                            	  1185: XP_ANDX
                            	  1186: XP_ORX
02:00004802 6100FF64        	  1187: 	bsr XP_POP
02:00004806 4E75            	  1188: 	rts
                            	  1189: 
                            	  1190: ;-------------------------------------------------------------------------------
                            	  1191: ; Check that two numeric values are being used.
                            	  1192: ;-------------------------------------------------------------------------------
                            	  1193: 
                            	  1194: CheckNumeric:
02:00004808 0C010001        	  1195: 	CMPI.B #DT_NUMERIC,D1
02:0000480C 660007F0        	  1196: 	BNE ETYPE
02:00004810 0C000001        	  1197: 	CMPI.B #DT_NUMERIC,D0
02:00004814 660007E8        	  1198: 	BNE ETYPE
02:00004818 4E75            	  1199: 	RTS
                            	  1200: 
                            	  1201: ;-------------------------------------------------------------------------------
                            	  1202: ; Relational operator level, <,<=,>=,>,=,<>
                            	  1203: ;-------------------------------------------------------------------------------
                            	  1204: 
                            	  1205: EXPR_REL
02:0000481A 61000088        	  1206: 	bsr	EXPR2
02:0000481E 6100FF32        	  1207: 	bsr XP_PUSH
02:00004822 43FAF872        	  1208: 	LEA	TAB8,A1 				; look up a relational operator
02:00004826 45FAF93C        	  1209: 	LEA	TAB8_1,A2
02:0000482A 6000F97C        	  1210: 	bra	EXEC		go do it
                            	  1211: 
                            	  1212: XP11
02:0000482E 6100FF38        	  1213: 	bsr XP_POP
02:00004832 615C            	  1214: 	BSR	XP18		is it ">="?
02:00004834 F2940044        	  1215: 	FBLT XPRT0		no, return D0=0
02:00004838 6048            	  1216: 	BRA	XPRT1		else return D0=1
                            	  1217: 
                            	  1218: XP12
02:0000483A 6100FF2C        	  1219: 	bsr XP_POP
02:0000483E 6150            	  1220: 	BSR	XP18		is it "<>"?
02:00004840 F2810038        	  1221: 	FBEQ XPRT0		no, return D0=0
02:00004844 603C            	  1222: 	BRA	XPRT1		else return D0=1
                            	  1223: 
                            	  1224: XP13
02:00004846 6100FF20        	  1225: 	bsr XP_POP
02:0000484A 6144            	  1226: 	BSR	XP18		is it ">"?
02:0000484C F295002C        	  1227: 	FBLE XPRT0		no, return D0=0
02:00004850 6030            	  1228: 	BRA	XPRT1		else return D0=1
                            	  1229: 
                            	  1230: XP14
02:00004852 6100FF14        	  1231: 	bsr XP_POP
02:00004856 6138            	  1232: 	BSR	XP18		is it "<="?
02:00004858 F2920020        	  1233: 	FBGT XPRT0		no, return D0=0
02:0000485C 6024            	  1234: 	BRA	XPRT1		else return D0=1
                            	  1235: 
                            	  1236: XP15
02:0000485E 6100FF08        	  1237: 	bsr XP_POP
02:00004862 612C            	  1238: 	BSR	XP18		is it "="?
02:00004864 F28E0014        	  1239: 	FBNE XPRT0		if not, return D0=0
02:00004868 6018            	  1240: 	BRA	XPRT1		else return D0=1
                            	  1241: XP15RT
02:0000486A 4E75            	  1242: 	RTS
                            	  1243: 
                            	  1244: XP16
02:0000486C 6100FEFA        	  1245: 	bsr XP_POP
02:00004870 611E            	  1246: 	BSR	XP18		is it "<"?
02:00004872 F2930006        	  1247: 	FBGE XPRT0		if not, return D0=0
02:00004876 600A            	  1248: 	BRA	XPRT1		else return D0=1
02:00004878 4E75            	  1249: 	RTS
                            	  1250: 
                            	  1251: XPRT0
02:0000487A F23C58000000    	  1252: 	FMOVE.B #0,FP0	; return fp0 = 0 (false)
02:00004880 4E75            	  1253: 	RTS
                            	  1254: 
                            	  1255: XPRT1	
02:00004882 F23C58000001    	  1256: 	FMOVE.B #1,FP0	; return fp0 = 1 (true)
02:00004888 4E75            	  1257: 	RTS
                            	  1258: 
                            	  1259: XP17								; it's not a rel. operator
02:0000488A 6100FEDC        	  1260: 	bsr XP_POP				;	return FP0=<EXPR2>
02:0000488E 4E75            	  1261: 	rts
                            	  1262: 
                            	  1263: XP18
02:00004890 6100FEC0        	  1264: 	bsr XP_PUSH
02:00004894 610E            	  1265: 	bsr	EXPR2					; do second <EXPR2>
02:00004896 6100FEE6        	  1266: 	bsr XP_POP1
02:0000489A 6100FF6C        	  1267: 	bsr CheckNumeric
02:0000489E F20000B8        	  1268: 	fcmp fp0,fp1			; compare with the first result
02:000048A2 4E75            	  1269: 	rts								; return the result
                            	  1270: 
                            	  1271: ;-------------------------------------------------------------------------------
                            	  1272: ; Add/Subtract operator level, +,-
                            	  1273: ;-------------------------------------------------------------------------------
                            	  1274: 
                            	  1275: EXPR2
02:000048A4 61000950        	  1276: 	bsr	TSTC		; negative sign?
02:000048A8 2D              	  1277: 	DC.B	'-',XP21-*
02:000048A9 09
02:000048AA F23C58000000    	  1278: 	FMOVE.B #0,FP0
02:000048B0 604C            	  1279: 	BRA	XP26
                            	  1280: XP21	
02:000048B2 61000942        	  1281: 	bsr	TSTC		; positive sign? ignore it
02:000048B6 2B              	  1282: 	DC.B	'+',XP22-*
02:000048B7 01
                            	  1283: XP22
02:000048B8 610000C8        	  1284: 	BSR	EXPR3		; first <EXPR3>
                            	  1285: XP23
02:000048BC 61000938        	  1286: 	bsr	TSTC		; add?
02:000048C0 2B              	  1287: 	DC.B	'+',XP25-*
02:000048C1 37
02:000048C2 6100FE8E        	  1288: 	bsr XP_PUSH
02:000048C6 610000BA        	  1289: 	BSR	EXPR3					; get the second <EXPR3>
                            	  1290: XP24
02:000048CA 6100FEB2        	  1291: 	bsr XP_POP1
02:000048CE B03C0001        	  1292: 	CMP.B #DT_NUMERIC,d0
02:000048D2 660C            	  1293: 	BNE .notNum
02:000048D4 B23C0001        	  1294: 	CMP.B #DT_NUMERIC,d1
02:000048D8 6606            	  1295: 	BNE .notNum
02:000048DA F2000422        	  1296: 	FADD FP1,FP0			; add it to the first <EXPR3>
                            	  1297: ;	FBVS	QHOW		branch if there's an overflow
02:000048DE 60DC            	  1298: 	BRA	XP23		else go back for more operations
                            	  1299: .notNum
02:000048E0 B0BC00000002    	  1300: 	cmp.l #DT_STRING,d0
02:000048E6 66000716        	  1301: 	bne ETYPE
02:000048EA B2BC00000002    	  1302: 	cmp.l #DT_STRING,d1
02:000048F0 6600070C        	  1303: 	bne ETYPE
02:000048F4 611E            	  1304: 	bsr ConcatString
02:000048F6 4E75            	  1305: 	rts
                            	  1306: 
                            	  1307: XP25
02:000048F8 610008FC        	  1308: 	bsr	TSTC							; subtract?
02:000048FC 2D              	  1309: 	dc.b	'-',XP27-*
02:000048FD 15
                            	  1310: XP26
02:000048FE 6100FE52        	  1311: 	bsr XP_PUSH
02:00004902 617E            	  1312: 	BSR	EXPR3					; get second <EXPR3>
02:00004904 0C000001        	  1313: 	cmpi.b #DT_NUMERIC,d0
02:00004908 660006F4        	  1314: 	bne ETYPE
02:0000490C F200001A        	  1315: 	FNEG FP0					; change its sign
02:00004910 60B8            	  1316: 	JMP	XP24					; and do an addition
                            	  1317: 
                            	  1318: XP27
02:00004912 4E75            	  1319: 	rts
                            	  1320: 
                            	  1321: ;-------------------------------------------------------------------------------
                            	  1322: ; Concatonate strings, for the '+' operator.
                            	  1323: ;
                            	  1324: ; Parameters:
                            	  1325: ;		fp0 = holds string descriptor for second string
                            	  1326: ;		fp1 = holds string descriptor for first string
                            	  1327: ;	Returns:
                            	  1328: ;		fp0 = string descriptor for combined strings
                            	  1329: ;-------------------------------------------------------------------------------
                            	  1330: 
                            	  1331: ConcatString:
02:00004914 F239688000040600	  1332: 	fmove.x fp1,_fpWork		; save first string descriptor to memory
02:0000491C F239680000040610	  1333: 	fmove.x fp0,_fpWork+16; save second string descriptor to memory
02:00004924 343900040600    	  1334: 	move.w _fpWork,d2			; d2 = length of first string
02:0000492A D47900040610    	  1335: 	add.w	_fpWork+16,d2		; add length of second string
02:00004930 48C2            	  1336: 	ext.l d2							; make d2 a long word
02:00004932 61000164        	  1337: 	bsr AllocateString		; allocate
02:00004936 2849            	  1338: 	move.l a1,a4					; a4 = allocated string, saved for later
02:00004938 2449            	  1339: 	move.l a1,a2					; a2 = allocated string
02:0000493A 3542FFFE        	  1340: 	move.w d2,-2(a2)			; save length of new string (a2)
02:0000493E 227900040604    	  1341: 	move.l _fpWork+4,a1		; a1 = pointer to string text of first string
02:00004944 2649            	  1342: 	move.l a1,a3					; compute pointer to end of first string
02:00004946 363900040600    	  1343: 	move.w _fpWork,d3			; d3 = length of first string
02:0000494C 48C3            	  1344: 	ext.l d3
02:0000494E D7C3            	  1345: 	add.l d3,a3						; add length of first string
02:00004950 61000786        	  1346: 	bsr MVUP							; move from A1 to A2 until A1=A3
02:00004954 227900040614    	  1347: 	move.l _fpWork+20,a1	; a1 = pointer to second string text
02:0000495A 2649            	  1348: 	move.l a1,a3
02:0000495C 363900040610    	  1349: 	move.w _fpWork+16,d3	; d3 = length of second string
02:00004962 48C3            	  1350: 	ext.l d3
02:00004964 D7C3            	  1351: 	add.l d3,a3						; a3 points to end of second string
02:00004966 61000770        	  1352: 	bsr MVUP							; concatonate on second string
02:0000496A 33C200040600    	  1353: 	move.w d2,_fpWork			; save total string length in fp work
02:00004970 23CC00040604    	  1354: 	move.l a4,_fpWork+4		; save pointer in fp work area
02:00004976 7002            	  1355: 	moveq #DT_STRING,d0		; set return data type = string
02:00004978 F239480000040600	  1356: 	fmove.x _fpWork,fp0		; fp0 = string descriptor
02:00004980 4E75            	  1357: 	rts
                            	  1358: 
                            	  1359: ;-------------------------------------------------------------------------------
                            	  1360: ; Multiply / Divide operator level, *,/,mod
                            	  1361: ;-------------------------------------------------------------------------------
                            	  1362: 
                            	  1363: EXPR3
02:00004982 6168            	  1364: 	bsr	EXPR4					; get first <EXPR4>
                            	  1365: XP36
02:00004984 6100FDCC        	  1366: 	bsr XP_PUSH
                            	  1367: XP30
02:00004988 43FAF71E        	  1368: 	lea TAB11,a1
02:0000498C 45FAF802        	  1369: 	lea TAB11_1,a2
02:00004990 6000F816        	  1370: 	bra EXEC
                            	  1371: XP31
02:00004994 61000860        	  1372: 	bsr	TSTC					; multiply?
02:00004998 2A              	  1373: 	dc.b	'*',XP34-*
02:00004999 11
02:0000499A 6150            	  1374: 	bsr	EXPR4					; get second <EXPR4>
02:0000499C 6100FDE0        	  1375: 	bsr XP_POP1
02:000049A0 6100FE66        	  1376: 	bsr CheckNumeric
02:000049A4 F2000423        	  1377: 	fmul fp1,fp0			; multiply the two
02:000049A8 60DA            	  1378: 	bra	XP36					; then look for more terms
                            	  1379: XP34
02:000049AA 6100084A        	  1380: 	bsr	TSTC					; divide?
02:000049AE 2F              	  1381: 	dc.b	'/',XP35-*
02:000049AF 15
02:000049B0 613A            	  1382: 	bsr	EXPR4					; get second <EXPR4>
02:000049B2 6100FDCA        	  1383: 	bsr XP_POP1
02:000049B6 6100FE50        	  1384: 	bsr CheckNumeric
02:000049BA F20000A0        	  1385: 	fdiv fp0,fp1			; do the division
02:000049BE F2000400        	  1386: 	fmove fp1,fp0
02:000049C2 60C0            	  1387: 	bra	XP36					; go back for any more terms
                            	  1388: XP35
02:000049C4 6100FDA2        	  1389: 	bsr XP_POP
02:000049C8 4E75            	  1390: 	rts
                            	  1391: XP_MOD:
02:000049CA 6120            	  1392: 	bsr EXPR4
02:000049CC 6100FDB0        	  1393: 	bsr XP_POP1
02:000049D0 F20000A0        	  1394: 	fdiv fp0,fp1			; divide
02:000049D4 F2006080        	  1395: 	fmove.l fp1,d0		; convert to integer
02:000049D8 F2004180        	  1396: 	fmove.l d0,fp3		; convert back to float
02:000049DC F20001A3        	  1397: 	fmul fp0,fp3			; multiply quotient times divisor
02:000049E0 F2000CA8        	  1398: 	fsub fp3,fp1			; subtract from original number
02:000049E4 F2000400        	  1399: 	fmove.x fp1,fp0		; return difference in fp0
02:000049E8 7001            	  1400: 	moveq #DT_NUMERIC,d0
02:000049EA 6098            	  1401: 	bra XP36					; go back and check for more multiply ops
                            	  1402: 	
                            	  1403: ;-------------------------------------------------------------------------------
                            	  1404: ; Lowest Level of expression evaluation.
                            	  1405: ;	Check for
                            	  1406: ;		a function or
                            	  1407: ;		a variable or
                            	  1408: ;		a number or
                            	  1409: ;		a string or
                            	  1410: ;		( expr )
                            	  1411: ;-------------------------------------------------------------------------------
                            	  1412: 
                            	  1413: EXPR4
02:000049EC 43FAF66E        	  1414: 	LEA	TAB4,A1 			; find possible function
02:000049F0 45FAF72E        	  1415: 	LEA	TAB4_1,A2
02:000049F4 6000F7B2        	  1416: 	BRA	EXEC
                            	  1417: XP40
02:000049F8 61000236        	  1418: 	bsr	TSTV					; nope, not a function
02:000049FC 650C            	  1419: 	bcs	XP41					; nor a variable
02:000049FE 2240            	  1420: 	move.l d0,a1			; a1 = variable address
02:00004A00 2011            	  1421: 	move.l (a1),d0		; return type in d0
02:00004A02 F22948000004    	  1422: 	fmove.x 4(a1),fp0	; if a variable, return its value in fp0
                            	  1423: EXP4RT
02:00004A08 4E75            	  1424: 	rts
                            	  1425: XP41
02:00004A0A 61000802        	  1426: 	bsr	TSTNUM				; or is it a number?
02:00004A0E F2000400        	  1427: 	fmove fp1,fp0
02:00004A12 0C8000000001    	  1428: 	cmpi.l #DT_NUMERIC,d0
02:00004A18 67EE            	  1429: 	beq	EXP4RT				; if so, return it in FP0
                            	  1430: XPSTNG
02:00004A1A 610007DA        	  1431: 	bsr TSTC					; is it a string constant?
02:00004A1E 22              	  1432: 	dc.b '"',XP44-*
02:00004A1F 57
02:00004A20 163C0022        	  1433: 	move.b #'"',d3
                            	  1434: XP45
02:00004A24 2248            	  1435: 	move.l a0,a1			; record start of string in a1
02:00004A26 243C000001FF    	  1436: 	move.l #511,d2		; max 512 characters
                            	  1437: .0003	
02:00004A2C 1018            	  1438: 	move.b (a0)+,d0		; get a character
02:00004A2E 670E            	  1439: 	beq .0001					; should not be a NULL
02:00004A30 0C00000D        	  1440: 	cmpi.b #CR,d0			; CR means the end of line was hit without a close quote
02:00004A34 6708            	  1441: 	beq .0001
02:00004A36 B003            	  1442: 	cmp.b d3,d0				; close quote?
02:00004A38 6708            	  1443: 	beq .0002
02:00004A3A 51CAFFF0        	  1444: 	dbra d2,.0003			; no close quote, go back for next char
                            	  1445: .0001
02:00004A3E 600005B6        	  1446: 	bra QHOW
                            	  1447: .0002
02:00004A42 2008            	  1448: 	move.l a0,d0				; d0 = end of string pointer
02:00004A44 9089            	  1449: 	sub.l a1,d0					; compute string length + 1
02:00004A46 5340            	  1450: 	subq #1,d0					; subtract out closing quote
02:00004A48 2400            	  1451: 	move.l d0,d2				; d2 = string length
02:00004A4A 2649            	  1452: 	move.l a1,a3				; a3 = pointer to string text
02:00004A4C 614A            	  1453: 	bsr AllocateString
02:00004A4E 2449            	  1454: 	move.l a1,a2				; a2 points to new text area
02:00004A50 2849            	  1455: 	move.l a1,a4				; save a1 for later
02:00004A52 224B            	  1456: 	move.l a3,a1				; a1 = pointer to string in program
02:00004A54 3542FFFE        	  1457: 	move.w d2,-2(a2)		; copy length into place
02:00004A58 D7C2            	  1458: 	add.l d2,a3					; a3 points to end of string
02:00004A5A 6100067C        	  1459: 	bsr MVUP						; move from A1 to A2 until A1=A3
02:00004A5E 33C200040600    	  1460: 	move.w d2,_fpWork		; copy length into place
02:00004A64 23CC00040604    	  1461: 	move.l a4,_fpWork+4	; copy pointer to text into place
02:00004A6A F239480000040600	  1462: 	fmove.x _fpWork,fp0	; put string descriptor into fp0
02:00004A72 7002            	  1463: 	moveq #DT_STRING,d0	; return string data type
02:00004A74 4E75            	  1464: 	rts
                            	  1465: XP44
02:00004A76 6100077E        	  1466: 	bsr TSTC					; alternate string constant?
02:00004A7A 27              	  1467: 	dc.b '''',PARN-*
02:00004A7B 07
02:00004A7C 163C0027        	  1468: 	move.b #'''',d3
02:00004A80 60A2            	  1469: 	bra XP45
                            	  1470: PARN
02:00004A82 61000772        	  1471: 	bsr	TSTC					; else look for ( EXPR )
02:00004A86 28              	  1472: 	dc.b '(',XP43-*
02:00004A87 0D
02:00004A88 6100FD2A        	  1473: 	bsr	EXPR
02:00004A8C 61000768        	  1474: 	bsr	TSTC
02:00004A90 29              	  1475: 	dc.b ')',XP43-*
02:00004A91 03
                            	  1476: XP42	
02:00004A92 4E75            	  1477: 	rts
                            	  1478: XP43
02:00004A94 60000518        	  1479: 	bra	QWHAT					; else say "What?"
                            	  1480: 
                            	  1481: ;-------------------------------------------------------------------------------	
                            	  1482: ; Allocate storage for a string variable.
                            	  1483: ;
                            	  1484: ; Parameters:
                            	  1485: ;		d2 = number of bytes needed
                            	  1486: ; Returns:
                            	  1487: ;		a1 = pointer to string text area
                            	  1488: ;-------------------------------------------------------------------------------	
                            	  1489: 
                            	  1490: AllocateString:
02:00004A98 48E7383C        	  1491: 	movem.l d2-d4/a2-a5,-(sp)
02:00004A9C 283A0962        	  1492: 	move.l VARBGN,d4
02:00004AA0 227A0956        	  1493: 	move.l LastStr,a1			; a1 = last string
02:00004AA4 3611            	  1494: 	move.w (a1),d3				; d3 = length of last string (0)
02:00004AA6 48C3            	  1495: 	ext.l d3
02:00004AA8 9883            	  1496: 	sub.l d3,d4						; subtract off length
02:00004AAA 5784            	  1497: 	subq.l #3,d4					; size of length field+1 for rounding
02:00004AAC 9889            	  1498: 	sub.l a1,d4						; and start position
02:00004AAE B484            	  1499: 	cmp.l d4,d2						; is there enough room?
02:00004AB0 6224            	  1500: 	bhi .needMoreRoom
                            	  1501: .0001
02:00004AB2 227A0944        	  1502: 	move.l LastStr,a1
02:00004AB6 2649            	  1503: 	move.l a1,a3
02:00004AB8 5489            	  1504: 	addq.l #2,a1					; point a1 to text part of string
02:00004ABA 3682            	  1505: 	move.w d2,(a3)				; save the length
02:00004ABC D7C2            	  1506: 	add.l d2,a3
02:00004ABE 568B            	  1507: 	addq.l #3,a3					; 2 for length field, 1 for rounding
02:00004AC0 260B            	  1508: 	move.l a3,d3
02:00004AC2 0283FFFFFFFE    	  1509: 	andi.l #$FFFFFFFE,d3	; make pointer even wyde
02:00004AC8 23CB000053F8    	  1510: 	move.l a3,LastStr			; set new last str position
02:00004ACE 4253            	  1511: 	clr.w (a3)						; set zero length
02:00004AD0 4CDF3C1C        	  1512: 	movem.l (sp)+,d2-d4/a2-a5
02:00004AD4 4E75            	  1513: 	rts
                            	  1514: .needMoreRoom
02:00004AD6 611E            	  1515: 	bsr GarbageCollectStrings
02:00004AD8 283A0926        	  1516: 	move.l VARBGN,d4			; d4 = start of variables
02:00004ADC 227A091A        	  1517: 	move.l LastStr,a1			; a1 = pointer to last string
02:00004AE0 3611            	  1518: 	move.w (a1),d3				; d3 = length of last string (likely 0)
02:00004AE2 48C3            	  1519: 	ext.l d3
02:00004AE4 D689            	  1520: 	add.l a1,d3						; d3 = pointer past end of last string
02:00004AE6 5683            	  1521: 	addq.l #3,d3					; 2 for length, 1 for rounding
02:00004AE8 9883            	  1522: 	sub.l d3,d4						; free = VARBGN - LastStr+length of (LastStr)
02:00004AEA B484            	  1523: 	cmp.l d4,d2						; request < free?
02:00004AEC 65C4            	  1524: 	blo .0001
02:00004AEE 4DFA089C        	  1525: 	lea NOSTRING,a6
02:00004AF2 600004C0        	  1526: 	bra ERROR
                            	  1527: 		
                            	  1528: ;-------------------------------------------------------------------------------	
                            	  1529: ; Garbage collect strings. This copies all strings in use to the lower end of
                            	  1530: ; the string area and adjusts the string pointers in variables and on the
                            	  1531: ; stack to point to the new location.
                            	  1532: ;
                            	  1533: ; Modifies:
                            	  1534: ;		none
                            	  1535: ;-------------------------------------------------------------------------------	
                            	  1536: 
                            	  1537: GarbageCollectStrings:
02:00004AF6 48E70074        	  1538: 	movem.l a1/a2/a3/a5,-(sp)
02:00004AFA 227A08F8        	  1539: 	move.l StrArea,a1			; source area pointer
02:00004AFE 247A08F4        	  1540: 	move.l StrArea,a2			; target area pointer
02:00004B02 2A7A08F4        	  1541: 	move.l LastStr,a5
                            	  1542: .0001
02:00004B06 6140            	  1543: 	bsr StringInVar				; check if the string is used by a variable
02:00004B08 6506            	  1544: 	bcs .moveString
02:00004B0A 610000A6        	  1545: 	bsr StringOnStack			; check if string is on string expression stack
02:00004B0E 641C            	  1546: 	bcc .nextString				; if not on stack or in a var then move to next string
                            	  1547: 	
                            	  1548: 	; The string is in use, copy to active string area
                            	  1549: .moveString:
02:00004B10 610000D0        	  1550: 	bsr UpdateStringPointers	; update pointer to string on stack or in variable
02:00004B14 611C            	  1551: 	bsr NextString				; a3 = pointer to next string
02:00004B16 610005CA        	  1552: 	bsr MVUPW							; will copy the length and string text
                            	  1553: .0005
02:00004B1A B3CD            	  1554: 	cmp.l a5,a1						; is it the last string?
02:00004B1C 63E8            	  1555: 	bls .0001
02:00004B1E 23CA000053F8    	  1556: 	move.l a2,LastStr			; update last string pointer
02:00004B24 4252            	  1557: 	clr.w (a2)						; set zero length
02:00004B26 4CDF2E00        	  1558: 	movem.l (sp)+,a1/a2/a3/a5
02:00004B2A 4E75            	  1559: 	rts
                            	  1560: .nextString:
02:00004B2C 6104            	  1561: 	bsr NextString
02:00004B2E 224B            	  1562: 	move.l a3,a1
02:00004B30 60E8            	  1563: 	bra .0005
                            	  1564: 
                            	  1565: ;-------------------------------------------------------------------------------	
                            	  1566: ; Parameters:
                            	  1567: ;		a1 - pointer to current string
                            	  1568: ; Returns:
                            	  1569: ;		a3 - pointer to next string
                            	  1570: ;-------------------------------------------------------------------------------	
                            	  1571: 
                            	  1572: NextString:
02:00004B32 2F04            	  1573: 	move.l d4,-(sp)
02:00004B34 3811            	  1574: 	move.w (a1),d4				; d4 = string length
02:00004B36 48C4            	  1575: 	ext.l d4							; make d4 long
02:00004B38 5684            	  1576: 	addq.l #3,d4					; plus 2 for length field, 1 for rounding
02:00004B3A D889            	  1577: 	add.l a1,d4
02:00004B3C 0284FFFFFFFE    	  1578: 	andi.l #$FFFFFFFE,d4	; make even wyde address
02:00004B42 2644            	  1579: 	move.l d4,a3
02:00004B44 281F            	  1580: 	move.l (sp)+,d4
02:00004B46 4E75            	  1581: 	rts
                            	  1582: 
                            	  1583: ;-------------------------------------------------------------------------------	
                            	  1584: ; Check if a variable is using a string
                            	  1585: ;
                            	  1586: ; Modifies:
                            	  1587: ;		d2,d3,a4
                            	  1588: ; Parameters:
                            	  1589: ;		a1 = pointer to string descriptor
                            	  1590: ; Returns:
                            	  1591: ;		cf = 1 if string in use, 0 otherwise
                            	  1592: ;-------------------------------------------------------------------------------	
                            	  1593: 
                            	  1594: StringInVar:
                            	  1595: 	; check global vars
02:00004B48 287A08B6        	  1596: 	move.l VARBGN,a4
02:00004B4C 761F            	  1597: 	moveq #31,d3			; 32 vars
02:00004B4E 6116            	  1598: 	bsr SIV1
                            	  1599: 	; now check local vars
02:00004B50 287A0866        	  1600: 	move.l STKFP,a4
                            	  1601: .0001
02:00004B54 588C            	  1602: 	addq.l #4,a4			; point to variable area
02:00004B56 7607            	  1603: 	moveq #7,d3
02:00004B58 610C            	  1604: 	bsr SIV1					; check variable area
02:00004B5A 286CFFFC        	  1605: 	move.l -4(a4),a4	; get previous frame pointer
02:00004B5E B9FAF32E        	  1606: 	cmp.l ENDMEM,a4
02:00004B62 65F0            	  1607: 	blo .0001
02:00004B64 4E75            	  1608: 	rts
                            	  1609: 
                            	  1610: ;-------------------------------------------------------------------------------	
                            	  1611: ; SIV1 - string in variable helper. This routine does a two-up return if the
                            	  1612: ; string is found in a variable. No need to keep searching.
                            	  1613: ;
                            	  1614: ; Modifies:
                            	  1615: ;		d2,d3,a4
                            	  1616: ; Parameters:
                            	  1617: ;		d3 = number of variables-1 to check
                            	  1618: ;		a4 = string space
                            	  1619: ;		a1 = pointer to string descriptor
                            	  1620: ; Returns:
                            	  1621: ;		cf = 1 if string in use, 0 otherwise
                            	  1622: ;-------------------------------------------------------------------------------	
                            	  1623: 
                            	  1624: SIV1:
                            	  1625: .0003
02:00004B66 0C9400000002    	  1626: 	cmp.l #DT_STRING,(a4)
02:00004B6C 6612            	  1627: 	bne .0004
02:00004B6E 242C0008        	  1628: 	move.l 8(a4),d2
02:00004B72 5582            	  1629: 	subq.l #2,d2
02:00004B74 B3C2            	  1630: 	cmp.l d2,a1
02:00004B76 6608            	  1631: 	bne .0004
02:00004B78 588F            	  1632: 	addq.l #4,sp			; pop return address
02:00004B7A 003C0001        	  1633: 	ori #1,ccr
02:00004B7E 4E75            	  1634: 	rts								; do two up return
                            	  1635: .0004
02:00004B80 508C            	  1636: 	addq.l #8,a4			;  increment pointer by 16
02:00004B82 508C            	  1637: 	addq.l #8,a4
02:00004B84 51CBFFE0        	  1638: 	dbra d3,.0003
02:00004B88 023C00FE        	  1639: 	andi #$FE,ccr
02:00004B8C 4E75            	  1640: 	rts
                            	  1641: 
                            	  1642: ;-------------------------------------------------------------------------------	
                            	  1643: ; Check if a value could be a pointer into the string area.
                            	  1644: ; Even if the data type indicated a string, it may not be. It could just be a
                            	  1645: ; coincidence. So check that the pointer portion is pointing into string
                            	  1646: ; memory. It is extremely unlikely to have a data type and a valid pointer
                            	  1647: ; match and it not be a string.
                            	  1648: ;
                            	  1649: ; Returns
                            	  1650: ;		d3 = pointer to string
                            	  1651: ;		cf=1 if points into string area, 0 otherwise
                            	  1652: ;-------------------------------------------------------------------------------	
                            	  1653: 
                            	  1654: PointsIntoStringArea:
02:00004B8E 0C9400000002    	  1655: 	cmp.l #DT_STRING,(a4)		; is it a string data type?
02:00004B94 6616            	  1656: 	bne .0001
02:00004B96 262C0008        	  1657: 	move.l 8(a4),d3					; likely a string if
02:00004B9A B6BA0858        	  1658: 	cmp.l StrArea,d3				; flagged as a string, and pointer is into string area
02:00004B9E 650C            	  1659: 	blo .0001
02:00004BA0 B6BA085E        	  1660: 	cmp.l VARBGN,d3
02:00004BA4 6406            	  1661: 	bhs .0001
02:00004BA6 003C0001        	  1662: 	ori #1,ccr
02:00004BAA 4E75            	  1663: 	rts
                            	  1664: .0001
02:00004BAC 023C00FE        	  1665: 	andi #$FE,ccr
02:00004BB0 4E75            	  1666: 	rts
                            	  1667: 
                            	  1668: ;-------------------------------------------------------------------------------	
                            	  1669: ; Check if the string is a temporary on stack
                            	  1670: ;
                            	  1671: ; Parameters:
                            	  1672: ;		a3 = pointer to old string text area
                            	  1673: ; Returns:
                            	  1674: ;		cf = 1 if string in use, 0 otherwise
                            	  1675: ;-------------------------------------------------------------------------------	
                            	  1676: 
                            	  1677: StringOnStack:
02:00004BB2 48E72028        	  1678: 	movem.l d2/a2/a4,-(sp)
02:00004BB6 7607            	  1679: 	moveq #7,d3
02:00004BB8 284F            	  1680: 	move.l sp,a4
                            	  1681: .0002
02:00004BBA 61D2            	  1682: 	bsr PointsIntoStringArea
02:00004BBC 6408            	  1683: 	bcc .0003
02:00004BBE 242C0008        	  1684: 	move.l 8(a4),d2			; d2 = string text pointer
02:00004BC2 B7C2            	  1685: 	cmp.l d2,a3					; compare string pointers
02:00004BC4 6712            	  1686: 	beq .0001						; same pointer?
                            	  1687: .0003
02:00004BC6 588C            	  1688: 	addq.l #4,a4				; bump pointer into stack
02:00004BC8 B9FAF2C4        	  1689: 	cmp.l ENDMEM,a4			; have we hit end of stack yet?
02:00004BCC 65EC            	  1690: 	blo .0002
02:00004BCE 4CDF1404        	  1691: 	movem.l (sp)+,d2/a2/a4
02:00004BD2 023C00FE        	  1692: 	andi #$FE,ccr
02:00004BD6 4E75            	  1693: 	rts
                            	  1694: .0001
02:00004BD8 4CDF1404        	  1695: 	movem.l (sp)+,d2/a2/a4
02:00004BDC 003C0001        	  1696: 	ori #1,ccr
02:00004BE0 4E75            	  1697: 	rts
                            	  1698: 	
                            	  1699: ;-------------------------------------------------------------------------------	
                            	  1700: ; Update pointers to string to point to new area. All string areas must be
                            	  1701: ; completely checked because there may be more than one pointer to the string.
                            	  1702: ;
                            	  1703: ; Modifies:
                            	  1704: ;		d2,d3,d4,a4
                            	  1705: ; Parameters:
                            	  1706: ;		a1 = old pointer to string
                            	  1707: ;		a2 = new pointer to string
                            	  1708: ;-------------------------------------------------------------------------------	
                            	  1709: 
                            	  1710: UpdateStringPointers:
02:00004BE2 2F0B            	  1711: 	move.l a3,-(sp)
02:00004BE4 47E90002        	  1712: 	lea 2(a1),a3						; a3 points to old string text area
                            	  1713: 	; check global variable space
02:00004BE8 287A0816        	  1714: 	move.l VARBGN,a4
02:00004BEC 761F            	  1715: 	moveq #31,d3						; 32 vars to check
02:00004BEE 611E            	  1716: 	bsr USP1
                            	  1717: 	; check stack for strings
02:00004BF0 284F            	  1718: 	move.l sp,a4						; start at stack bottom and work towards top
                            	  1719: .0002
02:00004BF2 619A            	  1720: 	bsr PointsIntoStringArea
02:00004BF4 640C            	  1721: 	bcc .0001
                            	  1722: 	; Here we probably have a string, one last check
02:00004BF6 B68A            	  1723: 	cmp.l a2,d3							; should be >= a2 as we are packing the space
02:00004BF8 6508            	  1724: 	blo .0001
02:00004BFA 294A0008        	  1725: 	move.l a2,8(a4)					; update pointer on stack with new address
02:00004BFE 546C0008        	  1726: 	addi.w #2,8(a4)					; bump up to text part of string
                            	  1727: .0001
02:00004C02 588C            	  1728: 	addq.l #4,a4
02:00004C04 B9FAF288        	  1729: 	cmp.l ENDMEM,a4
02:00004C08 65E8            	  1730: 	blo .0002
02:00004C0A 265F            	  1731: 	move.l (sp)+,a3
02:00004C0C 4E75            	  1732: 	rts
                            	  1733: 
                            	  1734: ;-------------------------------------------------------------------------------	
                            	  1735: ; Both global and local variable spaces are updated in the same manner.
                            	  1736: ;
                            	  1737: ; Parameters:
                            	  1738: ;		a1 = old pointer to string
                            	  1739: ;		a2 = new pointer to string
                            	  1740: ;		a4 = start of string space
                            	  1741: ;		d3 = number of string variables
                            	  1742: ;-------------------------------------------------------------------------------	
                            	  1743: 
                            	  1744: USP1:
                            	  1745: .0002
02:00004C0E 0C9400000002    	  1746: 	cmp.l #DT_STRING,(a4)		; check the data type
02:00004C14 6610            	  1747: 	bne .0001								; not a string, go to next
02:00004C16 242C0008        	  1748: 	move.l 8(a4),d2					; d2 = pointer to string text
02:00004C1A B7C2            	  1749: 	cmp.l d2,a3							; does pointer match old pointer?
02:00004C1C 6608            	  1750: 	bne .0001
02:00004C1E 294A0008        	  1751: 	move.l a2,8(a4)					; copy in new pointer
02:00004C22 54AC0008        	  1752: 	addi.l #2,8(a4)					; point to string text
                            	  1753: .0001
02:00004C26 508C            	  1754: 	addq.l #8,a4						; increment pointer by 16
02:00004C28 508C            	  1755: 	addq.l #8,a4
02:00004C2A 51CBFFE2        	  1756: 	dbra d3,.0002
02:00004C2E 4E75            	  1757: 	rts
                            	  1758: 
                            	  1759: ;-------------------------------------------------------------------------------	
                            	  1760: ; ===== Test for a valid variable name.  Returns Carry=1 if not
                            	  1761: ;	found, else returns Carry=0 and the address of the
                            	  1762: ;	variable in D0.
                            	  1763: 
                            	  1764: TSTV:
02:00004C30 61000628        	  1765: 	bsr	IGNBLK
02:00004C34 7000            	  1766: 	CLR.L	D0
02:00004C36 1010            	  1767: 	MOVE.B (A0),D0 	 	; look at the program text
02:00004C38 903C0040        	  1768: 	SUB.B	#'@',D0
02:00004C3C 6572            	  1769: 	BCS	TSTVRT				; C=1: not a variable
02:00004C3E 6638            	  1770: 	BNE	TV1						; branch if not "@" array
02:00004C40 5248            	  1771: 	ADDQ #1,A0				; If it is, it should be
02:00004C42 6100FE3E        	  1772: 	BSR	PARN					; followed by (EXPR) as its index.
02:00004C46 D080            	  1773: 	ADD.L	D0,D0
02:00004C48 650003AC        	  1774: 	BCS	QHOW					; say "How?" if index is too big
02:00004C4C D080            	  1775: 	ADD.L	D0,D0
02:00004C4E 650003A6        	  1776: 	BCS	QHOW
02:00004C52 D080            	  1777: 	ADD.L	D0,D0
02:00004C54 650003A0        	  1778: 	BCS	QHOW
02:00004C58 D080            	  1779: 	ADD.L	D0,D0
02:00004C5A 6500039A        	  1780: 	BCS	QHOW
02:00004C5E 2F00            	  1781: 	move.l d0,-(sp)		; save the index
02:00004C60 6100012A        	  1782: 	bsr	SIZE					; get amount of free memory
02:00004C64 221F            	  1783: 	move.l (sp)+,d1		; get back the index
02:00004C66 F2006000        	  1784: 	fmove.l fp0,d0		; convert to integer
02:00004C6A B081            	  1785: 	cmp.l	d1,d0				; see if there's enough memory
02:00004C6C 63000380        	  1786: 	bls	QSORRY				; if not, say "Sorry"
02:00004C70 203A078E        	  1787: 	move.l VARBGN,d0	; put address of array element...
02:00004C74 9081            	  1788: 	sub.l	d1,d0				; into D0
02:00004C76 4E75            	  1789: 	rts
                            	  1790: TV1
02:00004C78 B03C001B        	  1791: 	CMP.B	#27,D0			; if not @, is it A through Z?
02:00004C7C 0A3C0001        	  1792: 	EOR	#1,CCR
02:00004C80 652E            	  1793: 	BCS	TSTVRT				; if not, set Carry and return
02:00004C82 5248            	  1794: 	ADDQ #1,A0				; else bump the text pointer
02:00004C84 0C00004C        	  1795: 	cmpi.b #'L',d0		; is it a local? L0 to L7
02:00004C88 661E            	  1796: 	bne TV2
02:00004C8A 1010            	  1797: 	move.b (a0),d0
02:00004C8C 0C000030        	  1798: 	cmpi.b #'0',d0
02:00004C90 6516            	  1799: 	blo TV2
02:00004C92 0C000037        	  1800: 	cmpi.b #'7',d0
02:00004C96 6210            	  1801: 	bhi TV2
02:00004C98 903C0030        	  1802: 	sub.b #'0',d0
02:00004C9C 5248            	  1803: 	addq #1,a0			; bump text pointer
02:00004C9E E988            	  1804: 	lsl.l #4,d0			; *16 bytes per var
02:00004CA0 D0BA0716        	  1805: 	add.l STKFP,d0
02:00004CA4 5880            	  1806: 	add.l #4,d0
02:00004CA6 4E75            	  1807: 	rts
                            	  1808: TV2
02:00004CA8 E988            	  1809: 	LSL.L #4,D0			; compute the variable's address
02:00004CAA 223A0754        	  1810: 	MOVE.L VARBGN,D1
02:00004CAE D081            	  1811: 	ADD.L	D1,D0			; and return it in D0 with Carry=0
                            	  1812: TSTVRT
02:00004CB0 4E75            	  1813: 	RTS
                            	  1814: 
                            	  1815: 
                            	  1816: * ===== Divide the 32 bit value in D0 by the 32 bit value in D1.
                            	  1817: *	Returns the 32 bit quotient in D0, remainder in D1.
                            	  1818: *
                            	  1819: DIV32
02:00004CB2 4A81            	  1820: 	TST.L	D1		check for divide-by-zero
02:00004CB4 67000340        	  1821: 	BEQ	QHOW		if so, say "How?"
02:00004CB8 2401            	  1822: 	MOVE.L	D1,D2
02:00004CBA 2801            	  1823: 	MOVE.L	D1,D4
02:00004CBC B184            	  1824: 	EOR.L	D0,D4		see if the signs are the same
02:00004CBE 4A80            	  1825: 	TST.L	D0		take absolute value of D0
02:00004CC0 6A02            	  1826: 	BPL	DIV1
02:00004CC2 4480            	  1827: 	NEG.L	D0
02:00004CC4 4A81            	  1828: DIV1	TST.L	D1		take absolute value of D1
02:00004CC6 6A02            	  1829: 	BPL	DIV2
02:00004CC8 4481            	  1830: 	NEG.L	D1
02:00004CCA 761F            	  1831: DIV2	MOVEQ	#31,D3		iteration count for 32 bits
02:00004CCC 2200            	  1832: 	MOVE.L	D0,D1
02:00004CCE 7000            	  1833: 	CLR.L	D0
02:00004CD0 D281            	  1834: DIV3	ADD.L	D1,D1		(This algorithm was translated from
02:00004CD2 D180            	  1835: 	ADDX.L	D0,D0		; the divide routine in Ron Cain's
02:00004CD4 6708            	  1836: 	BEQ	DIV4		Small-C run time library.)
02:00004CD6 B082            	  1837: 	CMP.L	D2,D0
02:00004CD8 6B04            	  1838: 	BMI	DIV4
02:00004CDA 5281            	  1839: 	ADDQ.L	#1,D1
02:00004CDC 9082            	  1840: 	SUB.L	D2,D0
02:00004CDE 51CBFFF0        	  1841: DIV4	DBRA	D3,DIV3
02:00004CE2 C141            	  1842: 	EXG	D0,D1		put rem. & quot. in proper registers
02:00004CE4 4A84            	  1843: 	TST.L	D4		were the signs the same?
02:00004CE6 6A04            	  1844: 	BPL	DIVRT
02:00004CE8 4480            	  1845: 	NEG.L	D0		if not, results are negative
02:00004CEA 4481            	  1846: 	NEG.L	D1
02:00004CEC 4E75            	  1847: DIVRT	RTS
                            	  1848: 
                            	  1849: 
                            	  1850: ; ===== The PEEK function returns the byte stored at the address
                            	  1851: ;	contained in the following expression.
                            	  1852: 
                            	  1853: PEEK
02:00004CEE 1E3C0042        	  1854: 	MOVE.B #'B',d7
02:00004CF2 1210            	  1855: 	MOVE.B (a0),d1
02:00004CF4 0C01002E        	  1856: 	CMPI.B #'.',d1
02:00004CF8 6604            	  1857: 	BNE .0001
02:00004CFA 5248            	  1858: 	ADDQ #1,a0
02:00004CFC 1E18            	  1859: 	move.b (a0)+,d7
                            	  1860: .0001
02:00004CFE 6100FD82        	  1861: 	BSR	PARN		get the memory address
02:00004D02 0C8000000001    	  1862: 	cmpi.l #DT_NUMERIC,d0
02:00004D08 660002F4        	  1863: 	bne ETYPE
02:00004D0C F2006000        	  1864: 	FMOVE.L FP0,D0
02:00004D10 2240            	  1865: 	MOVE.L D0,A1
02:00004D12 0C070042        	  1866: 	cmpi.b #'B',d7
02:00004D16 660C            	  1867: 	bne .0002
                            	  1868: .0005
02:00004D18 7000            	  1869: 	CLR.L	D0				; upper 3 bytes will be zero
02:00004D1A 1011            	  1870: 	MOVE.B (A1),D0
02:00004D1C F2005800        	  1871: 	FMOVE.B	D0,FP0 	; get the addressed byte
02:00004D20 7001            	  1872: 	moveq #DT_NUMERIC,d0					; data type is a number
02:00004D22 4E75            	  1873: 	RTS							; and return it
                            	  1874: .0002
02:00004D24 0C070057        	  1875: 	cmpi.b #'W',d7
02:00004D28 660C            	  1876: 	bne .0003
02:00004D2A 7000            	  1877: 	CLR.L d0
02:00004D2C 3011            	  1878: 	MOVE.W (A1),D0
02:00004D2E F2005000        	  1879: 	FMOVE.W	D0,FP0	;	get the addressed word
02:00004D32 7001            	  1880: 	moveq #DT_NUMERIC,d0					; data type is a number
02:00004D34 4E75            	  1881: 	RTS							; and return it
                            	  1882: .0003
02:00004D36 0C07004C        	  1883: 	cmpi.b #'L',d7
02:00004D3A 660C            	  1884: 	bne .0004
02:00004D3C 7000            	  1885: 	CLR.L d0
02:00004D3E 2011            	  1886: 	MOVE.L (A1),D0
02:00004D40 F2004000        	  1887: 	FMOVE.L	D0,FP0 	; get the lword
02:00004D44 7001            	  1888: 	moveq #DT_NUMERIC,d0					; data type is a number
02:00004D46 4E75            	  1889: 	RTS							; and return it
                            	  1890: .0004
02:00004D48 0C070046        	  1891: 	cmpi.b #'F',d7
02:00004D4C 66CA            	  1892: 	bne .0005
02:00004D4E F2114800        	  1893: 	FMOVE.X	(A1),FP0 		; get the addressed float
02:00004D52 7001            	  1894: 	moveq #DT_NUMERIC,d0					; data type is a number
02:00004D54 4E75            	  1895: 	RTS			and return it
                            	  1896: 
                            	  1897: ;-------------------------------------------------------------------------------
                            	  1898: ; The RND function returns a random number from 0 to the value of the following
                            	  1899: ; expression in fp0.
                            	  1900: ;-------------------------------------------------------------------------------
                            	  1901: 
                            	  1902: RND:
02:00004D56 6100FD2A        	  1903: 	bsr	PARN								; get the upper limit
02:00004D5A 0C8000000001    	  1904: 	cmpi.l #DT_NUMERIC,d0		; must be numeric
02:00004D60 6600029C        	  1905: 	bne ETYPE
02:00004D64 F200003A        	  1906: 	ftst.x fp0							; it must be positive and non-zero
02:00004D68 F281028C        	  1907: 	fbeq QHOW
02:00004D6C F2940288        	  1908: 	fblt QHOW
02:00004D70 F2000100        	  1909: 	fmove fp0,fp2
02:00004D74 7028            	  1910: 	moveq #40,d0						; function #40 get random float
02:00004D76 4E4F            	  1911: 	trap #15
02:00004D78 F2000823        	  1912: 	fmul fp2,fp0
02:00004D7C 7001            	  1913: 	moveq #DT_NUMERIC,d0		; data type is a number
02:00004D7E 4E75            	  1914: 	rts
                            	  1915: 
                            	  1916: ; ===== The ABS function returns an absolute value in D0.
                            	  1917: 
                            	  1918: ABS:	
02:00004D80 6100FD00        	  1919: 	bsr	PARN			; get the following expr.'s value
02:00004D84 F2000018        	  1920: 	fabs.x fp0
02:00004D88 7001            	  1921: 	moveq #DT_NUMERIC,d0					; data type is a number
02:00004D8A 4E75            	  1922: 	rts
                            	  1923: 
                            	  1924: ; ===== The SIZE function returns the size of free memory in D0.
                            	  1925: 
                            	  1926: SIZE:
02:00004D8C 203A0666        	  1927: 	move.l StrArea,d0		; get the number of free bytes...
02:00004D90 90BA066A        	  1928: 	sub.l	 TXTUNF,d0		; between 'TXTUNF' and 'StrArea'
02:00004D94 F2004000        	  1929: 	fmove.l d0,fp0
02:00004D98 7001            	  1930: 	moveq #DT_NUMERIC,d0	; data type is a number
02:00004D9A 4E75            	  1931: 	rts										; return the number in fp0
                            	  1932: 	
                            	  1933: ; ===== The TICK function returns the processor tick register in D0.
                            	  1934: 
                            	  1935: TICK:
02:00004D9C 4E7A0FF0        	  1936: 	movec tick,d0
02:00004DA0 F2004000        	  1937: 	fmove.l d0,fp0
02:00004DA4 7001            	  1938: 	moveq #DT_NUMERIC,d0					; data type is a number
02:00004DA6 4E75            	  1939: 	rts
                            	  1940: 
                            	  1941: ; ===== The CORENO function returns the core number in D0.
                            	  1942: 
                            	  1943: CORENO:
02:00004DA8 4E7A0FE0        	  1944: 	movec coreno,d0
02:00004DAC F2004000        	  1945: 	fmove.l d0,fp0
02:00004DB0 7001            	  1946: 	moveq #DT_NUMERIC,d0					; data type is a number
02:00004DB2 4E75            	  1947: 	rts
                            	  1948: 
                            	  1949: ;-------------------------------------------------------------------------------
                            	  1950: ; Get a pair of argments for the LEFT$ and RIGHT$ functions.
                            	  1951: ; 	(STRING, NUM)
                            	  1952: ; Returns:
                            	  1953: ;		fp0 = number
                            	  1954: ;		fp1 = string
                            	  1955: ;-------------------------------------------------------------------------------
                            	  1956: 
                            	  1957: LorRArgs:
02:00004DB4 61000440        	  1958: 	bsr	TSTC						; else look for ( STRING EXPR, NUM EXPR )
02:00004DB8 28              	  1959: 	dc.b	'(',LorR1-*
02:00004DB9 33
02:00004DBA 6100F9F8        	  1960: 	bsr	EXPR
02:00004DBE 0C8000000002    	  1961: 	cmpi.l #DT_STRING,d0
02:00004DC4 66000238        	  1962: 	bne ETYPE
02:00004DC8 6100F988        	  1963: 	bsr XP_PUSH
02:00004DCC 61000428        	  1964: 	bsr TSTC
02:00004DD0 2C              	  1965: 	dc.b ',',LorR1-*
02:00004DD1 1B
02:00004DD2 6100F9E0        	  1966: 	bsr EXPR
02:00004DD6 0C8000000001    	  1967: 	cmpi.l #DT_NUMERIC,d0
02:00004DDC 66000220        	  1968: 	bne ETYPE
02:00004DE0 61000414        	  1969: 	bsr	TSTC
02:00004DE4 29              	  1970: 	dc.b	')',LorR1-*
02:00004DE5 07
02:00004DE6 6100F996        	  1971: 	bsr XP_POP1
02:00004DEA 4E75            	  1972: 	rts
                            	  1973: LorR1
02:00004DEC 60000208        	  1974: 	bra QHOW
                            	  1975: 	
                            	  1976: ;-------------------------------------------------------------------------------
                            	  1977: ; MID$ function gets a substring of characters from start position for
                            	  1978: ; requested length.
                            	  1979: ;-------------------------------------------------------------------------------
                            	  1980: 
                            	  1981: MID:
02:00004DF0 61000404        	  1982: 	bsr	TSTC						; look for ( STRING EXPR, NUM EXPR [, NUM_EXPR] )
02:00004DF4 28              	  1983: 	dc.b	'(',MID1-*
02:00004DF5 C1
02:00004DF6 6100F9BC        	  1984: 	bsr	EXPR
02:00004DFA 0C8000000002    	  1985: 	cmpi.l #DT_STRING,d0
02:00004E00 660001FC        	  1986: 	bne ETYPE
02:00004E04 6100F94C        	  1987: 	bsr XP_PUSH
02:00004E08 610003EC        	  1988: 	bsr TSTC
02:00004E0C 2C              	  1989: 	dc.b ',',MID1-*
02:00004E0D A9
02:00004E0E 6100F9A4        	  1990: 	bsr EXPR
02:00004E12 0C8000000001    	  1991: 	cmpi.l #DT_NUMERIC,d0
02:00004E18 660001E4        	  1992: 	bne ETYPE
02:00004E1C 6100F934        	  1993: 	bsr XP_PUSH
02:00004E20 7A02            	  1994: 	moveq #2,d5
02:00004E22 610003D2        	  1995: 	bsr	TSTC
02:00004E26 2C              	  1996: 	dc.b ',',MID2-*
02:00004E27 11
02:00004E28 6100F98A        	  1997: 	bsr EXPR
02:00004E2C 0C8000000001    	  1998: 	cmpi.l #DT_NUMERIC,d0
02:00004E32 660001CA        	  1999: 	bne ETYPE
02:00004E36 7A03            	  2000: 	moveq #3,d5					; d5 indicates 3 params
                            	  2001: MID2
02:00004E38 610003BC        	  2002: 	bsr TSTC
02:00004E3C 29              	  2003: 	dc.b ')',MID1-*
02:00004E3D 79
02:00004E3E 6100F93E        	  2004: 	bsr XP_POP1
02:00004E42 0C050003        	  2005: 	cmpi.b #3,d5				; did we have 3 arguments?
02:00004E46 6708            	  2006: 	beq MID5						; branch if did
02:00004E48 F23C40000000FFFF	  2007: 	fmove.l #$FFFF,fp0	; set length = max
                            	  2008: MID5
02:00004E50 F2000500        	  2009: 	fmove.x fp1,fp2			; fp2 = start pos
02:00004E54 6100F928        	  2010: 	bsr XP_POP1					; fp1 = string descriptor
                            	  2011: ;-------------------------------------------------------------------------------
                            	  2012: ; Perform MID$ function
                            	  2013: ; 	fp1 = string descriptor
                            	  2014: ; 	fp2 = starting position
                            	  2015: ; 	fp0 = length
                            	  2016: ;-------------------------------------------------------------------------------
                            	  2017: DOMID
02:00004E58 F239688000040600	  2018: 	fmove.x fp1,_fpWork	; _fpWork = string descriptor
02:00004E60 F2036100        	  2019: 	fmove.l fp2,d3			; d3 = start pos
02:00004E64 B67900040600    	  2020: 	cmp.w _fpWork,d3		; is start pos < length
02:00004E6A 6400018A        	  2021: 	bhs QHOW
02:00004E6E F2026000        	  2022: 	fmove.l fp0,d2			; d2=length
02:00004E72 D682            	  2023: 	add.l d2,d3					; start pos + length < string length?
02:00004E74 B47900040600    	  2024: 	cmp.w _fpWork,d2
02:00004E7A 6308            	  2025: 	bls MID4
02:00004E7C 343900040600    	  2026: 	move.w _fpWork,d2		; move string length to d2
02:00004E82 48C2            	  2027: 	ext.l d2
                            	  2028: MID4
02:00004E84 6100FC12        	  2029: 	bsr AllocateString	; a1 = pointer to new string
02:00004E88 2449            	  2030: 	move.l a1,a2				; a2 = pointer to new string
02:00004E8A 227900040604    	  2031: 	move.l _fpWork+4,a1	; a1 = pointer to string
02:00004E90 F2036100        	  2032: 	fmove.l fp2,d3			; d3 = start pos
02:00004E94 D3C3            	  2033: 	add.l d3,a1					; a1 = pointer to start pos
02:00004E96 33C200040600    	  2034: 	move.w d2,_fpWork		; length
02:00004E9C 23CA00040604    	  2035: 	move.l a2,_fpWork+4	; prep to return target string
02:00004EA2 2649            	  2036: 	move.l a1,a3				; a3 = pointer to start pos
02:00004EA4 D7C2            	  2037: 	add.l d2,a3					; a3 = pointer to end pos
02:00004EA6 61000230        	  2038: 	bsr MVUP						; move A1 to A2 until A1 = A3
02:00004EAA 7002            	  2039: 	moveq #DT_STRING,d0	; data type is a string
02:00004EAC F239480000040600	  2040: 	fmove.x _fpWork,fp0	; string descriptor in fp0
02:00004EB4 4E75            	  2041: 	rts
                            	  2042: MID1
02:00004EB6 6000013E        	  2043: 	bra QHOW
                            	  2044: 	
                            	  2045: ;-------------------------------------------------------------------------------
                            	  2046: ; LEFT$ function truncates the string after fp0 characters.
                            	  2047: ; Just like MID$ but with a zero starting postion.
                            	  2048: ;-------------------------------------------------------------------------------
                            	  2049: 	
                            	  2050: LEFT:
02:00004EBA 6100FEF8        	  2051: 	bsr LorRArgs				; get arguments
02:00004EBE F23C59000000    	  2052: 	fmove.b #0,fp2			; start pos = 0
02:00004EC4 6092            	  2053: 	bra DOMID
                            	  2054: 
                            	  2055: ;-------------------------------------------------------------------------------
                            	  2056: ; RIGHT$ function gets the rightmost characters.
                            	  2057: ; The start position must be calculated based on the number of characters
                            	  2058: ; requested and the string length.
                            	  2059: ;-------------------------------------------------------------------------------
                            	  2060: 
                            	  2061: RIGHT:
02:00004EC6 6100FEEC        	  2062: 	bsr LorRArgs				; get arguments
02:00004ECA F2026000        	  2063: 	fmove.l fp0,d2			; d2 = required length
02:00004ECE F239688000040600	  2064: 	fmove.x fp1,_fpWork	; _fpWork = string descriptor
02:00004ED6 363900040600    	  2065: 	move.w _fpWork,d3		; d3 = string length
02:00004EDC 48C3            	  2066: 	ext.l d3						; make d3 a long
02:00004EDE B682            	  2067: 	cmp.l d2,d3					; is length > right
02:00004EE0 6202            	  2068: 	bhi .0001
02:00004EE2 7400            	  2069: 	moveq #0,d2					; we want all the characters if length <= right
                            	  2070: .0001
02:00004EE4 9682            	  2071: 	sub.l d2,d3					; d3 = startpos = length - right
02:00004EE6 F2034100        	  2072: 	fmove.l d3,fp2			; fp2 = start position
02:00004EEA 6000FF6C        	  2073: 	bra DOMID
                            	  2074: 
                            	  2075: ;-------------------------------------------------------------------------------
                            	  2076: ; LEN( EXPR ) returns the length of a string expression.
                            	  2077: ;-------------------------------------------------------------------------------
                            	  2078: 
                            	  2079: LEN:
02:00004EEE 6100FB92        	  2080: 	bsr PARN
02:00004EF2 0C8000000002    	  2081: 	cmpi.l #DT_STRING,d0
02:00004EF8 66000104        	  2082: 	bne ETYPE
02:00004EFC F239680000040600	  2083: 	fmove.x fp0,_fpWork
02:00004F04 303900040600    	  2084: 	move.w _fpWork,d0
02:00004F0A 48C0            	  2085: 	ext.l d0
02:00004F0C F2005000        	  2086: 	fmove.w d0,fp0
02:00004F10 7001            	  2087: 	moveq #DT_NUMERIC,d0
02:00004F12 4E75            	  2088: 	rts
                            	  2089: 
                            	  2090: ;-------------------------------------------------------------------------------
                            	  2091: ; INT( EXPR ) returns the integer value of the expression.
                            	  2092: ; the expression must be in the range of a 32-bit integer.
                            	  2093: ;-------------------------------------------------------------------------------
                            	  2094: 
                            	  2095: INT:
02:00004F14 6100FB6C        	  2096: 	bsr PARN
02:00004F18 0C8000000001    	  2097: 	cmpi.l #DT_NUMERIC,d0
02:00004F1E 660000DE        	  2098: 	bne ETYPE
02:00004F22 F2000003        	  2099: 	fintrz fp0,fp0
                            	  2100: ;	fmove.l fp0,d0
                            	  2101: ;	fmove.l d0,fp0
02:00004F26 7001            	  2102: 	moveq #DT_NUMERIC,d0
02:00004F28 4E75            	  2103: 	rts
                            	  2104: 
                            	  2105: 
                            	  2106: ;-------------------------------------------------------------------------------
                            	  2107: ; CHR$( EXPR ) returns a one byte string containing the character.
                            	  2108: ;-------------------------------------------------------------------------------
                            	  2109: 
                            	  2110: CHR:
02:00004F2A 6100FB56        	  2111: 	bsr PARN
02:00004F2E 0C8000000001    	  2112: 	cmpi.l #DT_NUMERIC,d0
02:00004F34 660000C8        	  2113: 	bne ETYPE
02:00004F38 F2006000        	  2114: 	fmove.l fp0,d0
02:00004F3C 7401            	  2115: 	moveq #1,d2
02:00004F3E 6100FB58        	  2116: 	bsr AllocateString
02:00004F42 1280            	  2117: 	move.b d0,(a1)
02:00004F44 42290001        	  2118: 	clr.b 1(a1)
02:00004F48 7002            	  2119: 	moveq #DT_STRING,d0
02:00004F4A 23C900040604    	  2120: 	move.l a1,_fpWork+4
02:00004F50 33FC000100040600	  2121: 	move.w #1,_fpWork
02:00004F58 F239480000040600	  2122: 	fmove.x _fpWork,fp0
02:00004F60 4E75            	  2123: 	rts
                            	  2124: 
                            	  2125: ********************************************************************
                            	  2126: *
                            	  2127: * *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                            	  2128: *
                            	  2129: * 'SETVAL' expects a variable, followed by an equal sign and then
                            	  2130: * an expression.  It evaluates the expression and sets the variable
                            	  2131: * to that value.
                            	  2132: *
                            	  2133: * 'FIN' checks the end of a command.  If it ended with ":",
                            	  2134: * execution continues.	If it ended with a CR, it finds the
                            	  2135: * the next line and continues from there.
                            	  2136: *
                            	  2137: * 'ENDCHK' checks if a command is ended with a CR. This is
                            	  2138: * required in certain commands, such as GOTO, RETURN, STOP, etc.
                            	  2139: *
                            	  2140: * 'ERROR' prints the string pointed to by A0. It then prints the
                            	  2141: * line pointed to by CURRNT with a "?" inserted at where the
                            	  2142: * old text pointer (should be on top of the stack) points to.
                            	  2143: * Execution of Tiny BASIC is stopped and a warm start is done.
                            	  2144: * If CURRNT is zero (indicating a direct command), the direct
                            	  2145: * command is not printed. If CURRNT is -1 (indicating
                            	  2146: * 'INPUT' command in progress), the input line is not printed
                            	  2147: * and execution is not terminated but continues at 'INPERR'.
                            	  2148: *
                            	  2149: * Related to 'ERROR' are the following:
                            	  2150: * 'QWHAT' saves text pointer on stack and gets "What?" message.
                            	  2151: * 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                            	  2152: * 'QSORRY' and 'ASORRY' do the same kind of thing.
                            	  2153: * 'QHOW' and 'AHOW' also do this for "How?".
                            	  2154: 
                            	  2155: ; SETVAL
                            	  2156: ; Returns:
                            	  2157: ;		a6 pointer to variable
                            	  2158: 
                            	  2159: SETVAL	
02:00004F62 6100FCCC        	  2160: 	bsr	TSTV					; variable name?
02:00004F66 6546            	  2161: 	bcs	QWHAT					; if not, say "What?"
02:00004F68 2F00            	  2162: 	move.l d0,-(sp)		; save the variable's address
02:00004F6A 6100028A        	  2163: 	bsr	TSTC					; get past the "=" sign
02:00004F6E 3D              	  2164: 	dc.b	'=',SV1-*
02:00004F6F 11
02:00004F70 6100F842        	  2165: 	bsr	EXPR					; evaluate the expression
02:00004F74 2C5F            	  2166: 	move.l (sp)+,a6
02:00004F76 2C80            	  2167: 	move.l d0,(a6)		; save type
02:00004F78 F22E68000004    	  2168: 	fmove.x fp0,4(a6) ; and save its value in the variable
02:00004F7E 4E75            	  2169: 	rts
                            	  2170: SV1
02:00004F80 602C            	  2171: 	bra	QWHAT					; if no "=" sign
                            	  2172: 
                            	  2173: FIN
02:00004F82 61000272        	  2174: 	bsr	TSTC					; *** FIN ***
02:00004F86 3A              	  2175: 	DC.B ':',FI1-*
02:00004F87 07
02:00004F88 588F            	  2176: 	ADDQ.L #4,SP			; if ":", discard return address
02:00004F8A 6000F324        	  2177: 	BRA	RUNSML				; continue on the same line
                            	  2178: FI1
02:00004F8E 61000266        	  2179: 	bsr	TSTC					; not ":", is it a CR?
02:00004F92 0D              	  2180: 	DC.B	CR,FI2-*
02:00004F93 07
02:00004F94 588F            	  2181: 	ADDQ.L #4,SP			; yes, purge return address
02:00004F96 6000F2C2        	  2182: 	BRA	RUNNXL				; execute the next line
                            	  2183: FI2
02:00004F9A 4E75            	  2184: 	RTS								; else return to the caller
                            	  2185: 
                            	  2186: ENDCHK
02:00004F9C 610002BC        	  2187: 	bsr	IGNBLK
02:00004FA0 0C10003A        	  2188: 	CMP.B #':',(a0)
02:00004FA4 6706            	  2189: 	BEQ ENDCHK1
02:00004FA6 0C10000D        	  2190: 	CMP.B	#CR,(A0)		; does it end with a CR?
02:00004FAA 6602            	  2191: 	BNE	QWHAT					; if not, say "WHAT?"
                            	  2192: ENDCHK1:
02:00004FAC 4E75            	  2193: 	RTS
                            	  2194: 
                            	  2195: QWHAT
02:00004FAE 2F08            	  2196: 	MOVE.L A0,-(SP)
                            	  2197: AWHAT
02:00004FB0 4DFA03CA        	  2198: 	LEA	WHTMSG,A6
                            	  2199: ERROR
02:00004FB4 6100030A        	  2200: 	bsr	PRMESG		display the error message
02:00004FB8 205F            	  2201: 	MOVE.L	(SP)+,A0	restore the text pointer
02:00004FBA 203A03F8        	  2202: 	MOVE.L	CURRNT,D0	get the current line number
02:00004FBE 6700EF3C        	  2203: 	BEQ	WSTART		if zero, do a warm start
02:00004FC2 B0BCFFFFFFFF    	  2204: 	CMP.L	#-1,D0		is the line no. pointer = -1?
02:00004FC8 6700F560        	  2205: 	BEQ	INPERR		if so, redo input
02:00004FCC 1F10            	  2206: 	MOVE.B	(A0),-(SP)	save the char. pointed to
02:00004FCE 4210            	  2207: 	CLR.B	(A0)		put a zero where the error is
02:00004FD0 227A03E2        	  2208: 	MOVE.L	CURRNT,A1	point to start of current line
02:00004FD4 61000202        	  2209: 	bsr	PRTLN		display the line in error up to the 0
02:00004FD8 109F            	  2210: 	MOVE.B	(SP)+,(A0)	restore the character
02:00004FDA 103C003F        	  2211: 	MOVE.B	#'?',D0         display a "?"
02:00004FDE 6100EE96        	  2212: 	BSR	GOOUT
02:00004FE2 4240            	  2213: 	CLR	D0
02:00004FE4 5389            	  2214: 	SUBQ.L	#1,A1		point back to the error char.
02:00004FE6 6100017E        	  2215: 	bsr	PRTSTG		display the rest of the line
02:00004FEA 6000EF10        	  2216: 	BRA	WSTART		and do a warm start
                            	  2217: QSORRY
02:00004FEE 2F08            	  2218: 	MOVE.L	A0,-(SP)
                            	  2219: ASORRY
02:00004FF0 4DFA03AC        	  2220: 	LEA	SRYMSG,A6
02:00004FF4 60BE            	  2221: 	BRA	ERROR
                            	  2222: QHOW
02:00004FF6 2F08            	  2223: 	MOVE.L	A0,-(SP)	Error: "How?"
                            	  2224: AHOW
02:00004FF8 4DFA037B        	  2225: 	LEA	HOWMSG,A6
02:00004FFC 60B6            	  2226: 	BRA	ERROR
                            	  2227: ETYPE
02:00004FFE 4DFA0384        	  2228: 	lea TYPMSG,a6
02:00005002 60B0            	  2229: 	bra ERROR
                            	  2230: 
                            	  2231: *******************************************************************
                            	  2232: *
                            	  2233: * *** GETLN *** FNDLN (& friends) ***
                            	  2234: *
                            	  2235: * 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                            	  2236: * the character in D0 (given by the caller), then it fills the
                            	  2237: * buffer and echos. It ignores LF's but still echos
                            	  2238: * them back. Control-H is used to delete the last character
                            	  2239: * entered (if there is one), and control-X is used to delete the
                            	  2240: * whole line and start over again. CR signals the end of a line,
                            	  2241: * and causes 'GETLN' to return.
                            	  2242: *
                            	  2243: * 'FNDLN' finds a line with a given line no. (in D1) in the
                            	  2244: * text save area.  A1 is used as the text pointer. If the line
                            	  2245: * is found, A1 will point to the beginning of that line
                            	  2246: * (i.e. the high byte of the line no.), and flags are NC & Z.
                            	  2247: * If that line is not there and a line with a higher line no.
                            	  2248: * is found, A1 points there and flags are NC & NZ. If we reached
                            	  2249: * the end of the text save area and cannot find the line, flags
                            	  2250: * are C & NZ.
                            	  2251: * 'FNDLN' will initialize A1 to the beginning of the text save
                            	  2252: * area to start the search. Some other entries of this routine
                            	  2253: * will not initialize A1 and do the search.
                            	  2254: * 'FNDLNP' will start with A1 and search for the line no.
                            	  2255: * 'FNDNXT' will bump A1 by 2, find a CR and then start search.
                            	  2256: * 'FNDSKP' uses A1 to find a CR, and then starts the search.
                            	  2257: 
                            	  2258: GETLN
02:00005004 6100EE70        	  2259: 	BSR	GOOUT		display the prompt
02:00005008 103C0020        	  2260: 	MOVE.B	#' ',D0         and a space
02:0000500C 6100EE68        	  2261: 	BSR	GOOUT
02:00005010 41FA03FA        	  2262: 	LEA	BUFFER,A0	A0 is the buffer pointer
                            	  2263: GL1
02:00005014 61000298        	  2264: 	bsr	CHKIO		check keyboard
02:00005018 67FA            	  2265: 	BEQ	GL1		wait for a char. to come in
02:0000501A B03C0008        	  2266: 	CMP.B	#CTRLH,D0	delete last character?
02:0000501E 6726            	  2267: 	BEQ	GL3		if so
02:00005020 B03C0018        	  2268: 	CMP.B	#CTRLX,D0	delete the whole line?
02:00005024 6744            	  2269: 	BEQ	GL4		if so
02:00005026 B03C000D        	  2270: 	CMP.B	#CR,D0		accept a CR
02:0000502A 6706            	  2271: 	BEQ	GL2
02:0000502C B03C0020        	  2272: 	CMP.B	#' ',D0         if other control char., discard it
02:00005030 65E2            	  2273: 	BCS	GL1
                            	  2274: GL2
02:00005032 10C0            	  2275: 	MOVE.B	D0,(A0)+	save the char.
02:00005034 6100EE40        	  2276: 	BSR	GOOUT		echo the char back out
02:00005038 B03C000D        	  2277: 	CMP.B	#CR,D0		if it's a CR, end the line
02:0000503C 675C            	  2278: 	BEQ	GL7
02:0000503E B1FC0000545B    	  2279: 	CMP.L	#(BUFFER+BUFLEN-1),A0	any more room?
02:00005044 65CE            	  2280: 	BCS	GL1		yes: get some more, else delete last char.
                            	  2281: GL3
02:00005046 103C0008        	  2282: 	MOVE.B	#CTRLH,D0	delete a char. if possible
02:0000504A 6100EE2A        	  2283: 	BSR	GOOUT
02:0000504E 103C0020        	  2284: 	MOVE.B	#' ',D0
02:00005052 6100EE22        	  2285: 	BSR	GOOUT
02:00005056 B1FC0000540C    	  2286: 	CMP.L	#BUFFER,A0	any char.'s left?
02:0000505C 63B6            	  2287: 	BLS	GL1		if not
02:0000505E 103C0008        	  2288: 	MOVE.B	#CTRLH,D0	if so, finish the BS-space-BS sequence
02:00005062 6100EE12        	  2289: 	BSR	GOOUT
02:00005066 5388            	  2290: 	SUBQ.L	#1,A0		decrement the text pointer
02:00005068 60AA            	  2291: 	BRA	GL1		back for more
                            	  2292: GL4
02:0000506A 2208            	  2293: 	MOVE.L	A0,D1		delete the whole line
02:0000506C 92BC0000540C    	  2294: 	SUB.L	#BUFFER,D1	figure out how many backspaces we need
02:00005072 671E            	  2295: 	BEQ	GL6		if none needed, branch
02:00005074 5341            	  2296: 	SUBQ	#1,D1		adjust for DBRA
                            	  2297: GL5
02:00005076 103C0008        	  2298: 	MOVE.B	#CTRLH,D0	and display BS-space-BS sequences
02:0000507A 6100EDFA        	  2299: 	BSR	GOOUT
02:0000507E 103C0020        	  2300: 	MOVE.B	#' ',D0
02:00005082 6100EDF2        	  2301: 	BSR	GOOUT
02:00005086 103C0008        	  2302: 	MOVE.B	#CTRLH,D0
02:0000508A 6100EDEA        	  2303: 	BSR	GOOUT
02:0000508E 51C9FFE6        	  2304: 	DBRA	D1,GL5
                            	  2305: GL6
02:00005092 41FA0378        	  2306: 	LEA	BUFFER,A0	reinitialize the text pointer
02:00005096 6000FF7C        	  2307: 	BRA	GL1		and go back for more
                            	  2308: GL7
02:0000509A 103C000A        	  2309: 	MOVE.B	#LF,D0		echo a LF for the CR
02:0000509E 6000EDD6        	  2310: 	BRA	GOOUT
                            	  2311: 
                            	  2312: FNDLN
02:000050A2 B2BC0000FFFF    	  2313: 	CMP.L	#$FFFF,D1	line no. must be < 65535
02:000050A8 6400FF4C        	  2314: 	BCC	QHOW
02:000050AC 227AEDDC        	  2315: 	MOVE.L	TXTBGN,A1	init. the text save pointer
                            	  2316: 
                            	  2317: FNDLNP
02:000050B0 247A034A        	  2318: 	MOVE.L	TXTUNF,A2	check if we passed the end
02:000050B4 538A            	  2319: 	SUBQ.L	#1,A2
02:000050B6 B5C9            	  2320: 	CMP.L	A1,A2
02:000050B8 650C            	  2321: 	BCS	FNDRET		if so, return with Z=0 & C=1
02:000050BA 1411            	  2322: 	MOVE.B	(A1),D2	if not, get a line no.
02:000050BC E14A            	  2323: 	LSL	#8,D2
02:000050BE 14290001        	  2324: 	MOVE.B	1(A1),D2
02:000050C2 B441            	  2325: 	CMP.W	D1,D2		is this the line we want?
02:000050C4 6502            	  2326: 	BCS	FNDNXT		no, not there yet
                            	  2327: FNDRET
02:000050C6 4E75            	  2328: 	RTS			return the cond. codes
                            	  2329: 
                            	  2330: FNDNXT
02:000050C8 5489            	  2331: 	ADDQ.L	#2,A1		find the next line
                            	  2332: 
                            	  2333: FNDSKP	
02:000050CA 0C19000D        	  2334: 	CMP.B	#CR,(A1)+	try to find a CR
02:000050CE 67E0            	  2335: 	BEQ		FNDLNP
02:000050D0 B3FA032A        	  2336: 	CMP.L	TXTUNF,A1
02:000050D4 65F4            	  2337: 	BLO		FNDSKP
02:000050D6 60D8            	  2338: 	BRA		FNDLNP		check if end of text
                            	  2339: 
                            	  2340: ;******************************************************************
                            	  2341: ;
                            	  2342: ; *** MVUP *** MVDOWN *** POPA *** PUSHA ***
                            	  2343: ;
                            	  2344: ; 'MVUP' moves a block up from where A1 points to where A2 points
                            	  2345: ; until A1=A3
                            	  2346: ;
                            	  2347: ; 'MVDOWN' moves a block down from where A1 points to where A3
                            	  2348: ; points until A1=A2
                            	  2349: ;
                            	  2350: ; 'POPA' restores the 'FOR' loop variable save area from the stack
                            	  2351: ;
                            	  2352: ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                            	  2353: ;
                            	  2354: 
                            	  2355: MVUP
02:000050D8 B7C9            	  2356: 	CMP.L	A1,A3					; see the above description
02:000050DA 6304            	  2357: 	BLS	MVRET
02:000050DC 14D9            	  2358: 	MOVE.B	(A1)+,(A2)+
02:000050DE 60F8            	  2359: 	BRA	MVUP
                            	  2360: MVRET
02:000050E0 4E75            	  2361: 	RTS
                            	  2362: 
                            	  2363: ; For string movements only suitable in some circumstances
                            	  2364: 
                            	  2365: MVUPW
02:000050E2 B3CB            	  2366: 	cmp.l a3,a1
02:000050E4 6404            	  2367: 	bhs .0001
02:000050E6 34D9            	  2368: 	move.w (a1)+,(a2)+
02:000050E8 60F8            	  2369: 	bra MVUPW
                            	  2370: .0001
02:000050EA 4E75            	  2371: 	rts
                            	  2372: 
                            	  2373: MVDOWN
02:000050EC B5C9            	  2374: 	CMP.L	A1,A2		see the above description
02:000050EE 67F0            	  2375: 	BEQ	MVRET
02:000050F0 1721            	  2376: 	MOVE.B	-(A1),-(A3)
02:000050F2 60F8            	  2377: 	BRA	MVDOWN
                            	  2378: 
                            	  2379: POPA
02:000050F4 2C5F            	  2380: 	MOVE.L	(SP)+,A6			; A6 = return address
02:000050F6 23DF000053C4    	  2381: 	MOVE.L	(SP)+,LOPVAR	restore LOPVAR, but zero means no more
02:000050FC 6730            	  2382: 	BEQ	.0001
02:000050FE 23DF000053D0    	  2383: 	MOVE.L	(SP)+,LOPINC+8	if not zero, restore the rest
02:00005104 23DF000053CC    	  2384: 	MOVE.L	(SP)+,LOPINC+4
02:0000510A 23DF000053C8    	  2385: 	MOVE.L	(SP)+,LOPINC
02:00005110 23DF000053DC    	  2386: 	MOVE.L	(SP)+,LOPLMT+8
02:00005116 23DF000053D8    	  2387: 	MOVE.L	(SP)+,LOPLMT+4
02:0000511C 23DF000053D4    	  2388: 	MOVE.L	(SP)+,LOPLMT
02:00005122 23DF000053E0    	  2389: 	MOVE.L	(SP)+,LOPLN
02:00005128 23DF000053E4    	  2390: 	MOVE.L	(SP)+,LOPPT
                            	  2391: .0001
02:0000512E 4ED6            	  2392: 	JMP	(A6)		return
                            	  2393: 
                            	  2394: PUSHA
02:00005130 223A02D2        	  2395: 	MOVE.L	STKLMT,D1		; Are we running out of stack room?
02:00005134 928F            	  2396: 	SUB.L	SP,D1
02:00005136 6400FEB6        	  2397: 	BCC	QSORRY					; if so, say we're sorry
02:0000513A 2C5F            	  2398: 	MOVE.L	(SP)+,A6		; else get the return address
02:0000513C 223A0286        	  2399: 	MOVE.L	LOPVAR,D1		; save loop variables
02:00005140 6720            	  2400: 	BEQ	.0001						; if LOPVAR is zero, that's all
02:00005142 2F3A02A0        	  2401: 	MOVE.L	LOPPT,-(SP)	; else save all the others
02:00005146 2F3A0298        	  2402: 	MOVE.L	LOPLN,-(SP)
02:0000514A 2F3A0288        	  2403: 	MOVE.L	LOPLMT,-(SP)
02:0000514E 2F3A0288        	  2404: 	MOVE.L	LOPLMT+4,-(SP)
02:00005152 2F3A0288        	  2405: 	MOVE.L	LOPLMT+8,-(SP)
02:00005156 2F3A0270        	  2406: 	MOVE.L	LOPINC,-(SP)
02:0000515A 2F3A0270        	  2407: 	MOVE.L	LOPINC+4,-(SP)
02:0000515E 2F3A0270        	  2408: 	MOVE.L	LOPINC+8,-(SP)
                            	  2409: .0001
02:00005162 2F01            	  2410: 	MOVE.L	D1,-(SP)
02:00005164 4ED6            	  2411: 	JMP	(A6)		return
                            	  2412: 
                            	  2413: *******************************************************************
                            	  2414: *
                            	  2415: * *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                            	  2416: *
                            	  2417: * 'PRTSTG' prints a string pointed to by A1. It stops printing
                            	  2418: * and returns to the caller when either a CR is printed or when
                            	  2419: * the next byte is the same as what was passed in D0 by the
                            	  2420: * caller.
                            	  2421: *
                            	  2422: * 'QTSTG' looks for an underline (back-arrow on some systems),
                            	  2423: * single-quote, or double-quote.  If none of these are found, returns
                            	  2424: * to the caller.  If underline, outputs a CR without a LF.  If single
                            	  2425: * or double quote, prints the quoted string and demands a matching
                            	  2426: * end quote.  After the printing, the next 2 bytes of the caller are
                            	  2427: * skipped over (usually a short branch instruction).
                            	  2428: *
                            	  2429: * 'PRTNUM' prints the 32 bit number in D1, leading blanks are added if
                            	  2430: * needed to pad the number of spaces to the number in D4.
                            	  2431: * However, if the number of digits is larger than the no. in
                            	  2432: * D4, all digits are printed anyway. Negative sign is also
                            	  2433: * printed and counted in, positive sign is not.
                            	  2434: *
                            	  2435: * 'PRTLN' prints the saved text line pointed to by A1
                            	  2436: * with line no. and all.
                            	  2437: *
                            	  2438: PRTSTG:
02:00005166 1200            	  2439: 	MOVE.B	D0,D1		save the stop character
                            	  2440: PS1
02:00005168 1019            	  2441: 	MOVE.B	(A1)+,D0	get a text character
02:0000516A B200            	  2442: 	CMP.B	D0,D1		same as stop character?
02:0000516C 6712            	  2443: 	BEQ	PRTRET		if so, return
02:0000516E 6100ED06        	  2444: 	BSR	GOOUT		display the char.
02:00005172 B03C000D        	  2445: 	CMP.B	#CR,D0		is it a C.R.?
02:00005176 66F0            	  2446: 	BNE	PS1		no, go back for more
02:00005178 103C000A        	  2447: 	MOVE.B	#LF,D0		yes, add a L.F.
02:0000517C 6100ECF8        	  2448: 	BSR	GOOUT
                            	  2449: PRTRET
02:00005180 4E75            	  2450: 	RTS			then return
                            	  2451: 
                            	  2452: PRTSTR2a
02:00005182 1019            	  2453: 	move.b (a1)+,d0
02:00005184 6100ECF0        	  2454: 	bsr GOOUT
                            	  2455: PRTSTR2:
02:00005188 51C9FFF8        	  2456: 	dbra d1,PRTSTR2a
02:0000518C 4E75            	  2457: 	rts
                            	  2458: 	
                            	  2459: 	if 0
                            	  2460: QTSTG
                            	  2461: 	bsr	TSTC		*** QTSTG ***
                            	  2462: 	DC.B	'"',QT3-*
                            	  2463: 	MOVE.B	#'"',D0         it is a "
                            	  2464: QT1
                            	  2465: 	MOVE.L	A0,A1
                            	  2466: 	BSR	PRTSTG		print until another
                            	  2467: 	MOVE.L	A1,A0
                            	  2468: 	MOVE.L	(SP)+,A1	pop return address
                            	  2469: 	CMP.B	#LF,D0		was last one a CR?
                            	  2470: 	BEQ	RUNNXL		if so, run next line
                            	  2471: QT2
                            	  2472: 	ADDQ.L	#2,A1		skip 2 bytes on return
                            	  2473: 	JMP	(A1)		return
                            	  2474: QT3
                            	  2475: 	bsr	TSTC		is it a single quote?
                            	  2476: 	DC.B	'''',QT4-*
                            	  2477: 	MOVE.B	#'''',D0        if so, do same as above
                            	  2478: 	BRA	QT1
                            	  2479: QT4
                            	  2480: 	bsr	TSTC		is it an underline?
                            	  2481: 	DC.B	'_',QT5-*
                            	  2482: 	MOVE.B	#CR,D0		if so, output a CR without LF
                            	  2483: 	bsr	GOOUT
                            	  2484: 	MOVE.L	(SP)+,A1	pop return address
                            	  2485: 	BRA	QT2
                            	  2486: QT5
                            	  2487: 	RTS			none of the above
                            	  2488: 	endif
                            	  2489: 
                            	  2490: PRTNUM:
02:0000518E 4E52FFD0        	  2491: 	link a2,#-48
02:00005192 217900040098002C	  2492: 	move.l _canary,44(a0)
02:0000519A 48D7020F        	  2493: 	movem.l d0/d1/d2/d3/a1,(sp)
02:0000519E F22F68000014    	  2494: 	fmove.x fp0,20(sp)
02:000051A4 F22F68800020    	  2495: 	fmove.x fp1,32(sp)
02:000051AA F2000400        	  2496: 	fmove.x fp1,fp0					; fp0 = number to print
02:000051AE 43F900040520    	  2497: 	lea _fpBuf,a1						; a1 = pointer to buffer to use
02:000051B4 7027            	  2498: 	moveq #39,d0						; d0 = function #39 print float
02:000051B6 2204            	  2499: 	move.l d4,d1						; d1 = width
02:000051B8 2404            	  2500: 	move.l d4,d2						; d2 = precision max
02:000051BA 7665            	  2501: 	moveq #'e',d3
02:000051BC 4E4F            	  2502: 	trap #15
02:000051BE 4CD7020F        	  2503: 	movem.l (sp),d0/d1/d2/d3/a1
02:000051C2 F22F48000014    	  2504: 	fmove.x 20(sp),fp0
02:000051C8 F22F48800020    	  2505: 	fmove.x 32(sp),fp1
02:000051CE A2A80003002C    	  2506: 	cchk 44(a0)
02:000051D4 4E5A            	  2507: 	unlk a2
02:000051D6 4E75            	  2508: 	rts
                            	  2509: 
                            	  2510: ; Debugging
                            	  2511: 	if 0
                            	  2512: PRTFP0:
                            	  2513: 	link a2,#-48
                            	  2514: 	move.l _canary,44(a0)
                            	  2515: 	movem.l d0/d1/d2/d3/a1,(sp)
                            	  2516: 	fmove.x fp0,20(sp)
                            	  2517: 	lea _fpBuf,a1						; a1 = pointer to buffer to use
                            	  2518: 	moveq #39,d0						; d0 = function #39 print float
                            	  2519: 	moveq #30,d1						; d1 = width
                            	  2520: 	moveq #25,d2						; d2 = precision max
                            	  2521: 	moveq #'e',d3
                            	  2522: 	trap #15
                            	  2523: 	movem.l (sp),d0/d1/d2/d3/a1
                            	  2524: 	fmove.x 20(sp),fp0
                            	  2525: 	cchk 44(a0)
                            	  2526: 	unlk a2
                            	  2527: 	rts
                            	  2528: 	endif
                            	  2529: 
                            	  2530: PRTLN:
02:000051D8 7200            	  2531: 	CLR.L	D1
02:000051DA 1219            	  2532: 	MOVE.B (A1)+,D1	get the binary line number
02:000051DC E149            	  2533: 	LSL	#8,D1
02:000051DE 1219            	  2534: 	MOVE.B (A1)+,D1
02:000051E0 F2015080        	  2535: 	FMOVE.W D1,FP1
02:000051E4 7805            	  2536: 	MOVEQ	#5,D4			; display a 5 digit line no.
02:000051E6 61A6            	  2537: 	BSR	PRTNUM
02:000051E8 103C0020        	  2538: 	MOVE.B	#' ',D0         followed by a blank
02:000051EC 6100EC88        	  2539: 	BSR	GOOUT
02:000051F0 4240            	  2540: 	CLR	D0		stop char. is a zero
02:000051F2 6000FF72        	  2541: 	BRA	PRTSTG		display the rest of the line
                            	  2542: 
                            	  2543: 
                            	  2544: ; ===== Test text byte following the call to this subroutine. If it
                            	  2545: ; equals the byte pointed to by A0, return to the code following
                            	  2546: ; the call. If they are not equal, branch to the point
                            	  2547: ;	indicated by the offset byte following the text byte.
                            	  2548: 
                            	  2549: TSTC:
02:000051F6 6162            	  2550: 	BSR	IGNBLK				; ignore leading blanks
02:000051F8 225F            	  2551: 	MOVE.L (SP)+,A1		; get the return address
02:000051FA 1219            	  2552: 	MOVE.B (A1)+,D1		; get the byte to compare
02:000051FC B210            	  2553: 	CMP.B	(A0),D1 		;	is it = to what A0 points to?
02:000051FE 6708            	  2554: 	BEQ	TC1						; if so
02:00005200 7200            	  2555: 	CLR.L	D1					; If not, add the second
02:00005202 1211            	  2556: 	MOVE.B (A1),D1 		; byte following the call to
02:00005204 D3C1            	  2557: 	ADD.L	D1,A1				; the return address.
02:00005206 4ED1            	  2558: 	JMP	(A1)					; jump to the routine
                            	  2559: TC1
02:00005208 5288            	  2560: 	ADDQ.L #1,A0			; if equal, bump text pointer
02:0000520A 5289            	  2561: 	ADDQ.L #1,A1			; Skip the 2 bytes following
02:0000520C 4ED1            	  2562: 	JMP	(A1)					; the call and continue.
                            	  2563: 
                            	  2564: 
                            	  2565: ; ===== See if the text pointed to by A0 is a number. If so,
                            	  2566: ;	return the number in FP1 and the number of digits in D2,
                            	  2567: ;	else return zero in FP1 and D2.
                            	  2568: ; If text is not a number, then A0 is not updated, otherwise
                            	  2569: ; A0 is advanced past the number. Note A0 is always updated
                            	  2570: ; past leading spaces.
                            	  2571: 
                            	  2572: TSTNUM
02:0000520E 4E52FFE0        	  2573: 	link a2,#-32
02:00005212 2F7900040098001C	  2574: 	move.l _canary,28(sp)
02:0000521A 48D70202        	  2575: 	movem.l d1/a1,(sp)
02:0000521E F22F68000010    	  2576: 	fmove.x fp0,16(sp)
02:00005224 7029            	  2577: 	moveq #41,d0						; function #41, get float
02:00005226 7201            	  2578: 	moveq #1,d1							; d1 = input stride
02:00005228 2248            	  2579: 	move.l a0,a1						; a1 = pointer to input buffer
02:0000522A 4E4F            	  2580: 	trap #15								; call BIOS get float function
02:0000522C 2049            	  2581: 	move.l a1,a0						; set text pointer
02:0000522E 7001            	  2582: 	moveq #DT_NUMERIC,d0		; default data type = number
02:00005230 F2000080        	  2583: 	fmove.x fp0,fp1					; return expected in fp1
02:00005234 4A41            	  2584: 	tst.w d1								; check if a number (digits > 0?)
02:00005236 6706            	  2585: 	beq .0002
02:00005238 7400            	  2586: 	clr.l d2								; d2.l = 0
02:0000523A 3401            	  2587: 	move.w d1,d2						; d2 = number of digits
02:0000523C 6008            	  2588: 	bra .0001
                            	  2589: .0002											; not a number, return with orignal text pointer
02:0000523E 7000            	  2590: 	moveq #0,d0							; data type = not a number
02:00005240 7400            	  2591: 	moveq #0,d2							; d2 = 0
02:00005242 F2024080        	  2592: 	fmove.l d2,fp1					; return a zero
                            	  2593: .0001
02:00005246 4CD70202        	  2594: 	movem.l (sp),d1/a1
02:0000524A F22F48000010    	  2595: 	fmove.x 16(sp),fp0
02:00005250 A2AF0003001C    	  2596: 	cchk 28(sp)
02:00005256 4E5A            	  2597: 	unlk a2
02:00005258 4E75            	  2598: 	rts
                            	  2599: 		
                            	  2600: ; ===== Skip over blanks in the text pointed to by A0.
                            	  2601: 
                            	  2602: IGNBLK
02:0000525A 0C180020        	  2603: 	CMP.B	#' ',(A0)+		; see if it's a space
02:0000525E 67FA            	  2604: 	BEQ	IGNBLK					; if so, swallow it
02:00005260 5388            	  2605: 	SUBQ.L #1,A0				; decrement the text pointer
02:00005262 4E75            	  2606: 	RTS
                            	  2607: 
                            	  2608: *
                            	  2609: * ===== Convert the line of text in the input buffer to upper
                            	  2610: *	case (except for stuff between quotes).
                            	  2611: *
02:00005264 41FA01A6        	  2612: TOUPBUF LEA	BUFFER,A0	set up text pointer
02:00005268 4201            	  2613: 	CLR.B	D1		clear quote flag
                            	  2614: TOUPB1	
02:0000526A 1018            	  2615: 	MOVE.B	(A0)+,D0	get the next text char.
02:0000526C B03C000D        	  2616: 	CMP.B	#CR,D0		is it end of line?
02:00005270 6718            	  2617: 	BEQ	TOUPBRT 	if so, return
02:00005272 B03C0022        	  2618: 	CMP.B	#'"',D0         a double quote?
02:00005276 6714            	  2619: 	BEQ	DOQUO
02:00005278 B03C0027        	  2620: 	CMP.B	#'''',D0        or a single quote?
02:0000527C 670E            	  2621: 	BEQ	DOQUO
02:0000527E 4A01            	  2622: 	TST.B	D1		inside quotes?
02:00005280 66E8            	  2623: 	BNE	TOUPB1		if so, do the next one
02:00005282 6118            	  2624: 	BSR	TOUPPER 	convert to upper case
02:00005284 1100            	  2625: 	MOVE.B	D0,-(A0)	store it
02:00005286 5288            	  2626: 	ADDQ.L	#1,A0
02:00005288 60E0            	  2627: 	BRA	TOUPB1		and go back for more
                            	  2628: TOUPBRT
02:0000528A 4E75            	  2629: 	RTS
                            	  2630: 
02:0000528C 4A01            	  2631: DOQUO	TST.B	D1		are we inside quotes?
02:0000528E 6604            	  2632: 	BNE	DOQUO1
02:00005290 1200            	  2633: 	MOVE.B	D0,D1		if not, toggle inside-quotes flag
02:00005292 60D6            	  2634: 	BRA	TOUPB1
02:00005294 B200            	  2635: DOQUO1	CMP.B	D0,D1		make sure we're ending proper quote
02:00005296 66D2            	  2636: 	BNE	TOUPB1		if not, ignore it
02:00005298 4201            	  2637: 	CLR.B	D1		else clear quote flag
02:0000529A 60CE            	  2638: 	BRA	TOUPB1
                            	  2639: 
                            	  2640: *
                            	  2641: * ===== Convert the character in D0 to upper case
                            	  2642: *
02:0000529C B03C0061        	  2643: TOUPPER CMP.B	#'a',D0         is it < 'a'?
02:000052A0 650A            	  2644: 	BCS	TOUPRET
02:000052A2 B03C007A        	  2645: 	CMP.B	#'z',D0         or > 'z'?
02:000052A6 6204            	  2646: 	BHI	TOUPRET
02:000052A8 903C0020        	  2647: 	SUB.B	#32,D0		if not, make it upper case
02:000052AC 4E75            	  2648: TOUPRET RTS
                            	  2649: 
                            	  2650: *
                            	  2651: * 'CHKIO' checks the input. If there's no input, it will return
                            	  2652: * to the caller with the Z flag set. If there is input, the Z
                            	  2653: * flag is cleared and the input byte is in D0. However, if a
                            	  2654: * control-C is read, 'CHKIO' will warm-start BASIC and will not
                            	  2655: * return to the caller.
                            	  2656: *
                            	  2657: CHKIO
02:000052AE 6100EBCA        	  2658: 	bsr	GOIN		get input if possible
02:000052B2 670A            	  2659: 	BEQ	CHKRET		if Zero, no input
02:000052B4 B03C0003        	  2660: 	CMP.B	#CTRLC,D0	is it control-C?
02:000052B8 6604            	  2661: 	BNE	CHKRET		if not
02:000052BA 6000EC40        	  2662: 	BRA	WSTART		if so, do a warm start
                            	  2663: CHKRET
02:000052BE 4E75            	  2664: 	RTS
                            	  2665: 
                            	  2666: *
                            	  2667: * ===== Display a CR-LF sequence
                            	  2668: *
                            	  2669: ;CRLF	LEA	CLMSG,A6
                            	  2670: 
                            	  2671: 
                            	  2672: ; ===== Display a zero-ended string pointed to by register A6
                            	  2673: 
                            	  2674: PRMESG
02:000052C0 101E            	  2675: 	MOVE.B (A6)+,D0		; get the char.
02:000052C2 6706            	  2676: 	BEQ	PRMRET				; if it's zero, we're done
02:000052C4 6100EBB0        	  2677: 	BSR	GOOUT					; else display it
02:000052C8 60F6            	  2678: 	BRA	PRMESG
                            	  2679: PRMRET
02:000052CA 4E75            	  2680: 	RTS
                            	  2681: 
                            	  2682: ******************************************************
                            	  2683: * The following routines are the only ones that need *
                            	  2684: * to be changed for a different I/O environment.     *
                            	  2685: ******************************************************
                            	  2686: 
                            	  2687: ; ===== Clear screen and home cursor
                            	  2688: 
                            	  2689: CLS:
02:000052CC 700B            	  2690: 	moveq #11,d0			; set cursor position
02:000052CE 323CFF00        	  2691: 	move.w #$FF00,d1	; home cursor and clear screen
02:000052D2 4E4F            	  2692: 	trap #15
02:000052D4 6000F0E0        	  2693: 	bra FINISH
                            	  2694: 
                            	  2695: ; ===== Output character to the console (Port 1) from register D0
                            	  2696: ;(Preserves all registers.)
                            	  2697: 
                            	  2698: OUTC:
02:000052D8 48E7C000        	  2699: 	movem.l d0/d1,-(sp)
02:000052DC 2200            	  2700: 	move.l d0,d1
02:000052DE 7006            	  2701: 	moveq #6,d0
02:000052E0 4E4F            	  2702: 	trap #15
02:000052E2 4CDF0003        	  2703: 	movem.l (sp)+,d0/d1
02:000052E6 4E75            	  2704: 	rts
                            	  2705: 
                            	  2706: * ===== Input a character from the console into register D0 (or
                            	  2707: *	return Zero status if there's no character available).
                            	  2708: *
                            	  2709: INC
02:000052E8 2F0E            	  2710: 	move.l	a6,-(a7)
02:000052EA 2C7A00C0        	  2711: 	move.l	INPPTR,a6
02:000052EE 4E96            	  2712: 	jsr			(a6)
02:000052F0 2C5F            	  2713: 	move.l	(a7)+,a6
02:000052F2 4E75            	  2714: 	rts
                            	  2715: 
                            	  2716: INC1
02:000052F4 2F01            	  2717: 	move.l	d1,-(a7)
02:000052F6 7005            	  2718: 	moveq.l	#5,d0			* function 5 GetKey
02:000052F8 4E4F            	  2719: 	trap		#15
02:000052FA 2001            	  2720: 	move.l	d1,d0
02:000052FC 221F            	  2721: 	move.l	(a7)+,d1
02:000052FE 0C0000FF        	  2722: 	cmpi.b	#-1,d0
02:00005302 6602            	  2723: 	bne			.0001
02:00005304 4200            	  2724: 	clr.b		d0
                            	  2725: .0001:
02:00005306 4E75            	  2726: 	rts
                            	  2727: 
                            	  2728: *INC	BTST	#0,$10040	is character ready?
                            	  2729: *	BEQ	INCRET		if not, return Zero status
                            	  2730: *	MOVE.B	$10042,D0	else get the character
                            	  2731: *	AND.B	#$7F,D0 	zero out the high bit
                            	  2732: *INCRET	RTS
                            	  2733: 
                            	  2734: * ===== Output character to the host (Port 2) from register D0
                            	  2735: *	(Preserves all registers.)
                            	  2736: *
                            	  2737: AUXOUT:
02:00005308 13FC0002000400A8	  2738: 	move.b #2,OutputDevice
02:00005310 61C6            	  2739: 	bsr OUTC
02:00005312 13FC0001000400A8	  2740: 	move.b #1,OutputDevice
02:0000531A 4E75            	  2741: 	rts
                            	  2742: 
                            	  2743: *AUXOUT	BTST	#1,$10041	is port 2 ready for a character?
                            	  2744: *	BEQ	AUXOUT		if not, wait for it
                            	  2745: *	MOVE.B	D0,$10043	out it goes.
                            	  2746: *	RTS
                            	  2747: 
                            	  2748: *
                            	  2749: * ===== Input a character from the host into register D0 (or
                            	  2750: *	return Zero status if there's no character available).
                            	  2751: *
                            	  2752: AUXIN:
02:0000531C 2F01            	  2753: 	move.l	d1,-(a7)
02:0000531E 7024            	  2754: 	moveq		#36,d0				; serial get char from buffer
02:00005320 4E4F            	  2755: 	trap		#15
02:00005322 2001            	  2756: 	move.l	d1,d0
02:00005324 221F            	  2757: 	move.l	(a7)+,d1
02:00005326 0C40FFFF        	  2758: 	cmpi.w	#-1,d0
02:0000532A 670A            	  2759: 	beq			.0001
02:0000532C 0200007F        	  2760: 	andi.b	#$7F,d0				; clear high bit
02:00005330 4880            	  2761: 	ext.w		d0						; return character in d0
02:00005332 48C0            	  2762: 	ext.l		d0
02:00005334 4E75            	  2763: 	rts
                            	  2764: .0001:
02:00005336 7000            	  2765: 	moveq		#0,d0					; return zf=1 if no character available
02:00005338 4E75            	  2766: 	rts
                            	  2767: 
                            	  2768: ;AUXIN
                            	  2769: *AUXIN	BTST	#0,$10041	is character ready?
                            	  2770: *	BEQ	AXIRET		if not, return Zero status
                            	  2771: *	MOVE.B	$10043,D0	else get the character
                            	  2772: *	AND.B	#$7F,D0 	zero out the high bit
02:0000533A 4E75            	  2773: AXIRET	RTS
                            	  2774: 
                            	  2775: ; ===== Return to the resident monitor, operating system, etc.
                            	  2776: ;
                            	  2777: BYEBYE	
02:0000533C 23FC000000080004	  2778: 	move.l #8,_fpTextIncr
02:00005344 0094
02:00005346 60001350        	  2779: 	bra		Monitor
                            	  2780: ;	MOVE.B	#228,D7 	return to Tutor
                            	  2781: ;	TRAP	#14
                            	  2782: 
02:0000534A 0D              	  2783: INITMSG DC.B	CR,LF,'MC68000 Tiny Float BASIC, v1.0',CR,LF,LF,0
02:0000534B 0A
02:0000534C 4D43363830303020
02:00005354 54696E7920466C6F
02:0000535C 6174204241534943
02:00005364 2C2076312E30
02:0000536A 0D
02:0000536B 0A
02:0000536C 0A
02:0000536D 00
02:0000536E 0D              	  2784: OKMSG	DC.B	CR,LF,'OK',CR,LF,0
02:0000536F 0A
02:00005370 4F4B
02:00005372 0D
02:00005373 0A
02:00005374 00
02:00005375 486F773F        	  2785: HOWMSG	DC.B	'How?',CR,LF,0
02:00005379 0D
02:0000537A 0A
02:0000537B 00
02:0000537C 576861743F      	  2786: WHTMSG	DC.B	'What?',CR,LF,0
02:00005381 0D
02:00005382 0A
02:00005383 00
02:00005384 547970653F      	  2787: TYPMSG	DC.B	'Type?',CR,LF,0
02:00005389 0D
02:0000538A 0A
02:0000538B 00
02:0000538C 4E6F20737472696E	  2788: NOSTRING	DC.B 'No string space',CR,LF,0
02:00005394 67207370616365
02:0000539B 0D
02:0000539C 0A
02:0000539D 00
02:0000539E 536F7272792E    	  2789: SRYMSG	DC.B	'Sorry.'
02:000053A4 0D              	  2790: CLMSG	DC.B	CR,LF,0
02:000053A5 0A
02:000053A6 00
02:000053A7 00              	  2791: 	DC.B	0	<- for aligning on a word boundary
                            	  2792: LSTROM	EQU	*		end of possible ROM area
                            	  2793: *
                            	  2794: * Internal variables follow:
                            	  2795: *
                            	  2796: 	align 2
02:000053A8 00003E70        	  2797: RANPNT	DC.L	START		random number pointer
02:000053AC 00000000        	  2798: INPPTR	DS.L	1		input pointer
02:000053B0 00000000        	  2799: OUTPTR	DS.L	1 	output pointer
02:000053B4 00000000        	  2800: CURRNT	DS.L	1		; Current line pointer
02:000053B8 00000000        	  2801: STKFP		DS.L	1		; saves frame pointer
02:000053BC 00000000        	  2802: STKGOS	DS.L	1		Saves stack pointer in 'GOSUB'
02:000053C0 00000000        	  2803: STKINP	DS.L	1		Saves stack pointer during 'INPUT'
02:000053C4 00000000        	  2804: LOPVAR	DS.L	1		'FOR' loop save area
02:000053C8 00000000        	  2805: LOPINC	DS.L	3		increment
02:000053CC *
02:000053D4 00000000        	  2806: LOPLMT	DS.L	3		limit
02:000053D8 *
02:000053E0 00000000        	  2807: LOPLN	DS.L	1		line number
02:000053E4 00000000        	  2808: LOPPT	DS.L	1		text pointer
02:000053E8 00000000        	  2809: IRQROUT	DS.L	1
02:000053EC 00000000        	  2810: STRSTK	DS.L	1		; string pointer stack area, 8 entries
02:000053F0 00000000        	  2811: StrSp		DS.L	1		; string stack stack pointer
02:000053F4 00000000        	  2812: StrArea	DS.L	1		; pointer to string area
02:000053F8 00000000        	  2813: LastStr	DS.L	1		; pointer to last used string in area
02:000053FC 00000000        	  2814: TXTUNF	DS.L	1		points to unfilled text area
02:00005400 00000000        	  2815: VARBGN	DS.L	1		points to variable area
02:00005404 00000000        	  2816: STKLMT	DS.L	1		holds lower limit for stack growth
02:00005408 00000000        	  2817: DIRFLG	DS.L	1		; indicates 1=DIRECT mode
02:0000540C 00              	  2818: BUFFER	DS.B	BUFLEN		Keyboard input buffer
02:0000540D *
                            	  2819: TXT	EQU	*		Beginning of program area
                            	  2820: ;	END
                            	  2821: 

Source: "boot.x68"
                            	   887: 	include "..\Femtiki\FemtikiTop.x68"

Source: "..\Femtiki\FemtikiTop.x68"
                            	     1: 	include "..\Femtiki\const.x68"

Source: "..\Femtiki\const.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2020-2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: TS_NONE			EQU		0
                            	    38: TS_READY		EQU		1
                            	    39: TS_DEAD			EQU		2
                            	    40: TS_MSGRDY		EQU		4
                            	    41: TS_WAITMSG	EQU		8
                            	    42: TS_TIMEOUT	EQU		16
                            	    43: TS_PREEMPT	EQU		32
                            	    44: TS_RUNNING	EQU		128
                            	    45: 
                            	    46: ; error codes
                            	    47: E_Ok		EQU		$00
                            	    48: E_Arg		EQU		$01
                            	    49: E_Func  EQU    $02
                            	    50: E_BadMbx	EQU		$04
                            	    51: E_QueFull	EQU		$05
                            	    52: E_NoThread	EQU		$06
                            	    53: E_NotAlloc	EQU		$09
                            	    54: E_NoMsg		EQU		$0b
                            	    55: E_Timeout	EQU		$10
                            	    56: E_BadAlarm	EQU		$11
                            	    57: E_NotOwner	EQU		$12
                            	    58: E_QueStrategy EQU		$13
                            	    59: E_DCBInUse	EQU		$19
                            	    60: ; Device driver errors
                            	    61: E_BadDevNum	EQU		$20
                            	    62: E_NoDev		EQU		$21
                            	    63: E_BadDevOp	EQU		$22
                            	    64: E_ReadError	EQU		$23
                            	    65: E_WriteError EQU		$24
                            	    66: E_BadBlockNum	EQU	$25
                            	    67: E_TooManyBlocks	EQU	$26
                            	    68: 
                            	    69: ; resource errors
                            	    70: E_NoMoreMbx	EQU		$40
                            	    71: E_NoMoreMsgBlks	EQU	$41
                            	    72: E_NoMoreAlarmBlks	EQU $44
                            	    73: E_NoMoreTCBs	EQU	$45
                            	    74: E_NoMem		EQU 12
                            	    75: 
                            	    76: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     2: 	include "..\Femtiki\config.x68"

Source: "..\Femtiki\config.x68"
                            	     1: MAX_TID		EQU		4095
                            	     2: NR_TCB		EQU		4096
                            	     3: NTASK     EQU   4096    ; number of threads allowed
                            	     4: LOG_TCBSZ	EQU		8
                            	     5: LOG_PGSZ	EQU		10
                            	     6: LOG_ACBSZ EQU   12
                            	     7: OSPAGES		EQU		16			; pages of memory dedicated to OS
                            	     8: PAGESZ    EQU   16384  	; size of a page of memory
                            	     9: MEMSZ     EQU   32768   ; pages
                            	    10: MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                            	    11: NR_MSG		EQU		21842		; number of messages available
                            	    12: NR_MBX		EQU		9792
                            	    13: 
                            	    14: 
                            	    15: 
                            	    16: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     3: 	include "..\Femtiki\types.x68"

Source: "..\Femtiki\types.x68"
                            	     1: ; Thread Control Block
                            	     2: TCBMagic    EQU		$0000
                            	     3: TCBRegs  		EQU   $0004		; register set storage area
                            	     4: TCBUSP			EQU		$0044
                            	     5: TCBSSP			EQU		$0048
                            	     6: TCBSR				EQU		$004C
                            	     7: TCBPC				EQU		$0050
                            	     8: TCBStatus		EQU		$0054
                            	     9: TCBPriority	EQU		$0055
                            	    10: TCBWaitMbx	EQU		$0056
                            	    11: TCBHasFocus EQU   $005A
                            	    12: TCBStackBot	EQU		$005C
                            	    13: TCBMsgD1		EQU		$0060
                            	    14: TCBMsgD2		EQU		$0064
                            	    15: TCBMsgD3		EQU		$0068
                            	    16: TCBStartTick	EQU	$006C
                            	    17: TCBEndTick	EQU		$0070
                            	    18: TCBTicks		EQU		$0074
                            	    19: TCBException	EQU	$0078
                            	    20: TCBNext			EQU		$007C
                            	    21: TCBPrev			EQU		$0080
                            	    22: TCBAffinityBase	EQU	$0082
                            	    23: TCBAffinity	EQU		$0084
                            	    24: TCBTimeout	EQU		$0088
                            	    25: TCBtid      EQU   $008C
                            	    26: TCBmid      EQU   $0090
                            	    27: TCBappid    EQU   $0094
                            	    28: TCBOpMode   EQU   $0098
                            	    29: TCBMbxNext  EQU   $009C
                            	    30: TCBMbxPrev  EQU   $00A0
                            	    31: TCBThreadNum  EQU   $00A4
                            	    32: TCBAcbNext	EQU		$00A8
                            	    33: TCBAcbPrev	EQU		$00AC
                            	    34: TCBhMailboxes	EQU		$00B0
                            	    35: TCBName			EQU		$00C0
                            	    36: TCB_SIZE		EQU		$0100
                            	    37: 
                            	    38: MBX_MAGIC		equ		0
                            	    39: MBX_OWNER		equ		4		; tid of owning task
                            	    40: MBX_LINK    equ   8
                            	    41: MBX_TQHEAD  equ   12   ; link field for free list shared with task queue head
                            	    42: MBX_TQTAIL  equ   16
                            	    43: MBX_MQHEAD	equ		20
                            	    44: MBX_MQTAIL	equ		24
                            	    45: MBX_SIZE		equ		32
                            	    46: 
                            	    47: MSG_MAGIC   equ   0
                            	    48: MSG_LINK	  equ		4
                            	    49: MSG_RETADR  equ   8
                            	    50: MSG_TGTADR  equ   12
                            	    51: MSG_TYPE    equ   16
                            	    52: MSG_D1		  equ		20
                            	    53: MSG_D2		  equ		24
                            	    54: MSG_D3		  equ		28
                            	    55: MSG_SIZE	  equ		32
                            	    56: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     4: 
                            	     5: 	include "..\Femtiki\source\kernel\Femtiki_vars.x68"

Source: "..\Femtiki\source\kernel\Femtiki_vars.x68"
                            	     1: 
                            	     2: PAMShareCounts	EQU	$20000000	; one byte for each physical page of memory
                            	     3: tcbs						EQU	$20010000	; 4095*256 = 1MB
                            	     4: tcbs_end				EQU	$20020000
                            	     5: messages				EQU	$20020000	; 32*8192 (680*16=21760 messages)
                            	     6: messages_end		EQU	$20060000
                            	     7: mailboxes				EQU	$20060000
                            	     8: mailboxes_end		EQU	$20078000	;	12*8192 (816*12=9792 mailboxes)
                            	     9: acbs						EQU	$20080000	; 32*2*8192 =512kB
                            	    10: acbs_end				EQU	$20100000
                            	    11: 
                            	    12: 
                            	    13: sys_stacks			EQU	$DF0000
                            	    14: 
                            	    15: FemtikiVars			EQU	$00100200
                            	    16: PAMLastAllocate2	EQU		$00100218
                            	    17: RunningAID		EQU		$00100220
                            	    18: RunningTCB			EQU		$00100224
                            	    19: ACBPtrs				EQU		$00100228
                            	    20: MidStackBottoms	EQU		$00100264
                            	    21: FemtikiInited	EQU		$00100284
                            	    22: missed_ticks	EQU		$00100288
                            	    23: IOFocusList		EQU		$0010028C
                            	    24: IOFocusID			EQU		$001002AC
                            	    25: iof_switch		EQU		$001002AD
                            	    26: nMessage			EQU		$001002AE
                            	    27: nMailbox			EQU		$001002B0
                            	    28: hKeybdMbx			EQU		$001002BA
                            	    29: hFocusSwitchMbx		EQU		$001002BC
                            	    30: BIOS_RespMbx	EQU		$001002BE
                            	    31: hasUltraHighPriorityTasks	EQU		$001002C0
                            	    32: im_save				EQU		$001002C2
                            	    33: sp_tmp				EQU		$001002C4
                            	    34: startQNdx			EQU		$001002C6
                            	    35: NPAGES				EQU		$001002D8
                            	    36: syspages			EQU		$001002DA
                            	    37: mmu_FreeMaps	EQU		$001002E0
                            	    38: mmu_entries		EQU		$00100300
                            	    39: freelist			EQU		$00100302
                            	    40: hSearchMap		EQU		$00100304
                            	    41: OSActive			EQU		$00100305
                            	    42: FreeACB				EQU		$00100308
                            	    43: FreeTCB				EQU		$0010030C
                            	    44: FreeMSG				EQU		$00100310
                            	    45: FreeMBX				EQU		$00100314
                            	    46: TimeoutList		EQU		$00100318
                            	    47: QueueCycle    EQU   $0010031C
                            	    48: readyQ				EQU		$00100320		; 32 bytes per queue per core, 2 cores for now
                            	    49: readyQEnd			EQU		$00100360
                            	    50: FemtikiVars_end	EQU	$00100400
                            	    51: 
                            	    52: ;gc_stack		rmb		512
                            	    53: ;gc_pc				fcdw		0
                            	    54: ;gc_omapno		fcw			0
                            	    55: ;gc_mapno		fcw			0
                            	    56: ;gc_dl				fcw			0
                            	    57: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     6: 	code
                            	     7: 	even
                            	     8: 	include "..\Femtiki\source\kernel\tcb.x68"

Source: "..\Femtiki\source\kernel\tcb.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;------------------------------------------------------------------------------
                            	    38: ; Initialize variables related to TCBs.
                            	    39: ;------------------------------------------------------------------------------
                            	    40: 
                            	    41: TCBInit:
02:0000545C 41F920010000    	    42: 	lea tcbs,a0
02:00005462 4E7B8013        	    43: 	movec a0,tcba
02:00005466 700F            	    44: 	moveq #2*8-1,d0		; 2 cores, 32 bytes (8 lwords) per queue
02:00005468 72FF            	    45: 	moveq #-1,d1			; value to set
02:0000546A 41F900100320    	    46: 	lea readyQ,a0			; clear out ready queue
                            	    47: .0001
02:00005470 20C1            	    48: 	move.l d1,(a0)+
02:00005472 51C8FFFC        	    49: 	dbra d0,.0001
02:00005476 203C0003FFFF    	    50: 	move.l #TCB_SIZE*NR_TCB/4-1,d0
                            	    51: .clearTCBs
02:0000547C 4298            	    52: 	clr.l (a0)+
02:0000547E 51C8FFFC        	    53: 	dbra d0,.clearTCBs
02:00005482 4E75            	    54: 	rts
                            	    55: 
                            	    56: ;------------------------------------------------------------------------------
                            	    57: ; Convert a TCB handle into a pointer.
                            	    58: ;
                            	    59: ; Parameters:
                            	    60: ;		d0 = TCB handle
                            	    61: ; Returns:
                            	    62: ;		a0 = pointer to TCB
                            	    63: ;------------------------------------------------------------------------------
                            	    64: 
                            	    65: TCBHandleToPointer:
02:00005484 2F01            	    66: 	move.l d1,-(a7)
02:00005486 028000000FFF    	    67: 	andi.l #MAX_TID,d0		; limit to # threads
02:0000548C 4E7A1013        	    68: 	movec tcba,d1
02:00005490 E188            	    69: 	lsl.l #8,d0
02:00005492 D280            	    70: 	add.l d0,d1
02:00005494 2041            	    71: 	move.l d1,a0
02:00005496 E088            	    72: 	lsr.l #8,d0						; restore d0
02:00005498 221F            	    73: 	move.l (a7)+,d1
02:0000549A 4E75            	    74: 	rts
                            	    75: 
                            	    76: ;------------------------------------------------------------------------------
                            	    77: ; Convert a TCB pointer into a handle.
                            	    78: ;
                            	    79: ; Parameters:
                            	    80: ;		a0 = TCB pointer
                            	    81: ; Returns:
                            	    82: ;		d0 = TCB handle
                            	    83: ;------------------------------------------------------------------------------
                            	    84: 
                            	    85: TCBPointerToHandle:
02:0000549C 2F01            	    86: 	move.l d1,-(a7)				; save d1
02:0000549E 4E7A1013        	    87: 	movec tcba,d1
02:000054A2 91C1            	    88: 	sub.l d1,a0
02:000054A4 2008            	    89: 	move.l a0,d0
02:000054A6 E088            	    90: 	lsr.l #8,d0
02:000054A8 221F            	    91: 	move.l (a7)+,d1				; restore d1
02:000054AA 4E75            	    92: 	rts
                            	    93: 
                            	    94: ;------------------------------------------------------------------------------
                            	    95: ; Internal TCB allocation function.
                            	    96: ;
                            	    97: ; Parameters:
                            	    98: ;		none
                            	    99: ; Returns:
                            	   100: ;		d0 = handle for allocated TCB, NULL if none available
                            	   101: ;------------------------------------------------------------------------------
                            	   102: 
                            	   103: TCBIAlloc:
02:000054AC 30390010030C    	   104: 	move.w FreeTCB,d0				; d1 = Free handle
02:000054B2 6714            	   105: 	beq .0001
02:000054B4 2F08            	   106: 	move.l a0,-(sp)
02:000054B6 61CC            	   107: 	bsr TCBHandleToPointer	; convert to pointer
02:000054B8 3228007C        	   108: 	move.w TCBNext(a0),d1		; d1 = next on free list
02:000054BC 33C10010030C    	   109: 	move.w d1,FreeTCB				; update head of free list
02:000054C2 61D8            	   110: 	bsr TCBPointerToHandle	; convert pointer to handle
02:000054C4 205F            	   111: 	move.l (sp)+,a0
02:000054C6 4E75            	   112: 	rts
                            	   113: 	; Here there was no free TCB available. Return a NULL
                            	   114: .0001
02:000054C8 4E75            	   115: 	rts
                            	   116: 	
                            	   117: ;------------------------------------------------------------------------------
                            	   118: ; TCB allocation function. Locks the system semaphore during allocation.
                            	   119: ;
                            	   120: ; Parameters:
                            	   121: ;		none
                            	   122: ; Returns:
                            	   123: ;		d0 = handle for allocated TCB, NULL if none available
                            	   124: ;		d1 = E_Ok
                            	   125: ;------------------------------------------------------------------------------
                            	   126: 
                            	   127: TCBAlloc:
02:000054CA 61000326        	   128: 	bsr LockSysSemaphore
02:000054CE 61DC            	   129: 	bsr	TCBIAlloc
02:000054D0 61000330        	   130: 	bsr UnlockSysSemaphore
02:000054D4 7200            	   131: 	moveq #E_Ok,d1
02:000054D6 4E75            	   132: 	rts
                            	   133: 	
                            	   134: ;------------------------------------------------------------------------------
                            	   135: ; Internal TCB free function.
                            	   136: ;
                            	   137: ; Modifies:
                            	   138: ;		none
                            	   139: ; Parameters:
                            	   140: ;		d0 = handle to TCB
                            	   141: ; Returns:
                            	   142: ;		d0 = handle to TCB
                            	   143: ;------------------------------------------------------------------------------
                            	   144: 
                            	   145: TCBIFree:
02:000054D8 2F08            	   146: 	move.l a0,-(sp)
02:000054DA 61A8            	   147: 	bsr TCBHandleToPointer
02:000054DC 31790010030C007C	   148: 	move.w FreeTCB,TCBNext(a0)
02:000054E4 33C00010030C    	   149: 	move.w d0,FreeTCB
02:000054EA 205F            	   150: 	move.l (sp)+,a0
02:000054EC 4E75            	   151: 	rts
                            	   152: 
                            	   153: ;------------------------------------------------------------------------------
                            	   154: ; TCB free function. Locks the system sempaphore while freeing.
                            	   155: ;
                            	   156: ; Modifies:
                            	   157: ;		none
                            	   158: ; Parameters:
                            	   159: ;		d0 = handle to TCB
                            	   160: ; Returns:
                            	   161: ;		d0 = handle to TCB
                            	   162: ;		d1 = E_Ok
                            	   163: ;------------------------------------------------------------------------------
                            	   164: 
                            	   165: TCBFree:
02:000054EE 61000302        	   166: 	bsr LockSysSemaphore
02:000054F2 61E4            	   167: 	bsr TCBIFree
02:000054F4 6100030C        	   168: 	bsr UnlockSysSemaphore
02:000054F8 7200            	   169: 	moveq #E_Ok,d1
02:000054FA 4E75            	   170: 	rts
                            	   171: 
                            	   172: ;------------------------------------------------------------------------------
                            	   173: ; Given an affinity, chose the core number to run on.
                            	   174: ;
                            	   175: ; Parameters:
                            	   176: ;		a0 = pointer to TCB
                            	   177: ;	Returns:
                            	   178: ;		d0 = core number to run on
                            	   179: ;------------------------------------------------------------------------------
                            	   180: 
                            	   181: TCBAffineChose:
02:000054FC 48E75000        	   182: 	movem.l d1/d3,-(sp)
02:00005500 363C001F        	   183: 	move.w #31,d3										; limit number of bit selects to 32
02:00005504 12280082        	   184: 	move.b TCBAffinityBase(a0),d1		; d1 = starting bit
02:00005508 20280084        	   185: 	move.l TCBAffinity(a0),d0				; d0 = affinity mask
                            	   186: .0002
02:0000550C 0300            	   187: 	btst.l d1,d0										; is bit d1 set?
02:0000550E 6610            	   188: 	bne .0001												; if set, exit loop
02:00005510 5241            	   189: 	addq #1,d1
02:00005512 51CBFFF8        	   190: 	dbra d3,.0002
                            	   191: 	; no bits set? How?
02:00005516 117C00020082    	   192: 	move.b #2,TCBAffinityBase(a0)
02:0000551C 7000            	   193: 	moveq #0,d0											; just return core #2 (0)
02:0000551E 4E75            	   194: 	rts
                            	   195: .0001
02:00005520 1001            	   196: 	move.b d1,d0
02:00005522 5500            	   197: 	subi.b #2,d0										; cores start at #2
02:00005524 4880            	   198: 	ext.w d0
02:00005526 48C0            	   199: 	ext.l d0
02:00005528 5241            	   200: 	addq #1,d1											; increment bit selection for next time
02:0000552A 11410082        	   201: 	move.b d1,TCBAffinityBase(a0)		; and store in TCB
02:0000552E 4CDF000A        	   202: 	movem.l (sp)+,d1/d3
02:00005532 4E75            	   203: 	rts
                            	   204: 
                            	   205: ;------------------------------------------------------------------------------
                            	   206: ; Insert thread into ready queue. The thread is added at the tail of the 
                            	   207: ; queue. The queue is a doubly linked list.
                            	   208: ;
                            	   209: ; Stack Space:
                            	   210: ;		8 lwords
                            	   211: ; Modifies:
                            	   212: ;		none
                            	   213: ; Parameters:
                            	   214: ;		d0 = thread id to insert
                            	   215: ; Returns:
                            	   216: ;		d0 = TCB handle
                            	   217: ; ----------------------------------------------------------------------------
                            	   218: 
                            	   219: TCBInsertIntoReadyQueue:
02:00005534 48E770F0        	   220: 	movem.l d1-d3/a0-a3,-(sp)
02:00005538 2400            	   221: 	move.l d0,d2											; d2 = thread to insert
02:0000553A 6100FF48        	   222: 	bsr TCBHandleToPointer
02:0000553E 2648            	   223: 	move.l a0,a3											; a3 = TCB pointer of thread to insert
02:00005540 610002B0        	   224: 	bsr LockSysSemaphore
02:00005544 002800800054    	   225: 	ori.b #TS_RUNNING,TCBStatus(a0)
02:0000554A 61B0            	   226: 	bsr TCBAffineChose								; Chose which cores queue to use
02:0000554C EB88            	   227: 	lsl.l #5,d0												; 32 bytes per readyQ head/tail per core
02:0000554E 7200            	   228: 	clr.l d1
02:00005550 12280055        	   229: 	move.b TCBPriority(a0),d1					; d1 = priority
02:00005554 028100000007    	   230: 	andi.l #7,d1
02:0000555A E589            	   231: 	lsl.l #2,d1												; 4 bytes per priority level
02:0000555C D280            	   232: 	add.l d0,d1												; add in base queue
02:0000555E D2BC00100320    	   233: 	add.l #readyQ,d1									; add in start of ready queues
02:00005564 2241            	   234: 	move.l d1,a1
02:00005566 30290004        	   235: 	move.w 4(a1),d0										; d0 = tail entry
02:0000556A 3600            	   236: 	move.w d0,d3											; d3 = tail entry
02:0000556C 4A40            	   237: 	tst.w d0
02:0000556E 6D20            	   238: 	blt .qempty
02:00005570 6100FF12        	   239: 	bsr TCBHandleToPointer						; a0 = pointer to tail
02:00005574 2448            	   240: 	move.l a0,a2
02:00005576 2038007C        	   241: 	move.l TCBNext,d0
02:0000557A 6100FF08        	   242: 	bsr TCBHandleToPointer						; a0 = tail->next
02:0000557E 21420080        	   243: 	move.l d2,TCBPrev(a0)							; tail->next->prev = new entry
02:00005582 2542007C        	   244: 	move.l d2,TCBNext(a2)							; tail->next = new entry
02:00005586 2740007C        	   245: 	move.l d0,TCBNext(a3)							; new entry->next = tail->next
02:0000558A 27430080        	   246: 	move.l d3,TCBPrev(a3)							; new entry->prev = tail
02:0000558E 6012            	   247: 	bra .0002
                            	   248: .qempty
02:00005590 4A51            	   249: 	tst.w (a1)												; check if there is a list head
02:00005592 6C0E            	   250: 	bge .0002													; head with no tail -> list corrupt
02:00005594 33420004        	   251: 	move.w d2,4(a1)										; head and tail equal new entry
02:00005598 3282            	   252: 	move.w d2,(a1)
02:0000559A 3742007C        	   253: 	move.w d2,TCBNext(a3)							; next and prev of new entry point to self
02:0000559E 37420080        	   254: 	move.w d2,TCBPrev(a3)
                            	   255: 	; Head but no tail, list corrupt?
                            	   256: .0002
02:000055A2 6100025E        	   257: 	bsr UnlockSysSemaphore
02:000055A6 4CDF0F0E        	   258: 	movem.l (sp)+,d1-d3/a0-a3
02:000055AA 4E75            	   259: 	rts
                            	   260: 
                            	   261: ;------------------------------------------------------------------------------
                            	   262: ; Remove a thread from the ready queue. Actual removal is not done here, it
                            	   263: ; is done the next time the thread is selected to run. Just mark the thread as
                            	   264: ; not running.
                            	   265: ;
                            	   266: ; Parameters:
                            	   267: ;		d0 = thread id to remove
                            	   268: ; Returns:
                            	   269: ;		none
                            	   270: ; -----------------------------------------------------------------------------
                            	   271: 
                            	   272: TCBRemoveFromReadyQueue:
02:000055AC 4A40            	   273: 	cmpi.w #0,d0
02:000055AE 6D1C            	   274: 	blt .0001
02:000055B0 028000000FFF    	   275: 	andi.l #MAX_TID,d0									; limit to # of threads
02:000055B6 2F08            	   276: 	move.l a0,-(sp)
02:000055B8 6100FECA        	   277: 	bsr	TCBHandleToPointer
02:000055BC 61000234        	   278: 	bsr LockSysSemaphore
02:000055C0 0228007F0054    	   279: 	andi.b #TS_RUNNING^$FF,TCBStatus(a0)
02:000055C6 6100023A        	   280: 	bsr UnlockSysSemaphore
02:000055CA 205F            	   281: 	move.l (sp)+,a0
                            	   282: .0001
02:000055CC 4E75            	   283: 	rts
                            	   284: 	
                            	   285: ; ----------------------------------------------------------------------------
                            	   286: ; Register Usage
                            	   287: ;		d0 = temporary
                            	   288: ;		d1 = index into list of queues
                            	   289: ;		d2 = index to queue set
                            	   290: ;		d4 = queue counter, goes from 7 down to 0
                            	   291: ;		d5 = temporary
                            	   292: ;		d6 = next on list
                            	   293: ;		a0 = temporary pointer to TCB
                            	   294: ;		a1 = pointer to queue
                            	   295: ;		a2 = pointer to old head of list
                            	   296: ;		a3 = pointer to TCB at head of queue
                            	   297: ; Modifies:
                            	   298: ;		none
                            	   299: ; Parameters:
                            	   300: ;		none
                            	   301: ; Returns:
                            	   302: ;		a0 = pointer to TCB, NULL if none on list
                            	   303: ;		d0 = TCB handle
                            	   304: ; ----------------------------------------------------------------------------
                            	   305: 
                            	   306: StartQ
02:000055CE 01              	   307: 	dc.b 1,2,3,4,1,5,6,7
02:000055CF 02
02:000055D0 03
02:000055D1 04
02:000055D2 01
02:000055D3 05
02:000055D4 06
02:000055D5 07
                            	   308: 
                            	   309: 	even
                            	   310: TCBPopReadyQueue:
02:000055D6 48E77E70        	   311: 	movem.l	d1-d6/a1-a3,-(a7)
02:000055DA 4E7A2FE0        	   312: 	movec coreno,d2					; select the queue set based on the core number
02:000055DE 5502            	   313: 	subi.b #2,d2						; cores start at #2
02:000055E0 EB8A            	   314: 	lsl.l #5,d2							; d2 = index to queue set, 32 bytes per queue set
02:000055E2 7807            	   315: 	moveq #7,d4							; d4 = queue count
02:000055E4 6100020C        	   316: 	bsr LockSysSemaphore
                            	   317: 	; One in four tries pick a different priority to start searching from. 
02:000055E8 12390010031C    	   318: 	move.b QueueCycle,d1		; increment Queue cycle counter
02:000055EE 5201            	   319: 	addi.b #1,d1
02:000055F0 02010007        	   320: 	andi.b #7,d1
02:000055F4 13C10010031C    	   321: 	move.b d1,QueueCycle
02:000055FA 6612            	   322: 	bne	.0001
02:000055FC 43FAFFD0        	   323: 	lea StartQ,a1
02:00005600 4881            	   324: 	ext.w d1
02:00005602 12311000        	   325: 	move.b (a1,d1.w),d1
02:00005606 02410007        	   326: 	andi.w #7,d1						; limit to number of queues
02:0000560A E549            	   327: 	lsl.w #2,d1							; make into lword index
02:0000560C 6002            	   328: 	bra .0002
                            	   329: .0001
02:0000560E 7200            	   330: 	moveq #0,d1							; start at Queue #0
                            	   331: .0002
02:00005610 43F900100320    	   332: 	lea readyQ,a1						; a1 = pointer to list of ready queues
02:00005616 D3C2            	   333: 	add.l d2,a1							; a1 = pointer to queue set
02:00005618 36311000        	   334: 	move.w (a1,d1.w),d3			; d3 = old head of list
02:0000561C 6D4E            	   335: 	blt .nextQ							; anything on list?, if not go next queue
02:0000561E 3003            	   336: 	move.w d3,d0						; d0 = old head of list
02:00005620 6100FE62        	   337: 	bsr TCBHandleToPointer
02:00005624 2448            	   338: 	move.l a0,a2						; a2 = pointer to old head of list
02:00005626 3A2A007C        	   339: 	move.w TCBNext(a2),d5		; remove head of list from list
02:0000562A BA80            	   340: 	cmp.l d0,d5							; removing last TCB?
02:0000562C 6736            	   341: 	beq .removeLast
02:0000562E 3C05            	   342: 	move.w d5,d6						; d6 = next on list
02:00005630 3005            	   343: 	move.w d5,d0						; d0 = next on list
02:00005632 6100FE50        	   344: 	bsr TCBHandleToPointer	; a0 = pointer to next TCB on list
02:00005636 3A2A0080        	   345: 	move.w TCBPrev(a2),d5		; d5 = previous TCB from head
02:0000563A 31450080        	   346: 	move.w d5,TCBPrev(a0)		; next->prev = head->prev
02:0000563E 3005            	   347: 	move.w d5,d0
02:00005640 6100FE42        	   348: 	bsr TCBHandleToPointer	; a0 = pointer to previous TCB from head
02:00005644 3146007C        	   349: 	move.w d6,TCBNext(a0)		; head->prev->next = next
                            	   350: .0003
02:00005648 33861000        	   351: 	move.w d6,(a1,d1.w)			; reset head of list to next
02:0000564C 3543007C        	   352: 	move.w d3,TCBNext(a2)		; point links back to self
02:00005650 35430080        	   353: 	move.w d3,TCBPrev(a2)
02:00005654 3003            	   354: 	move.w d3,d0						; return handle in d0
02:00005656 48C0            	   355: 	ext.l d0
02:00005658 204A            	   356: 	move.l a2,a0						; return pointer in a0
                            	   357: .0004
02:0000565A 610001A6        	   358: 	bsr UnlockSysSemaphore
02:0000565E 4CDF0E7E        	   359: 	movem.l	(a7)+,d1-d6/a1-a3
02:00005662 4E75            	   360: 	rts
                            	   361: .removeLast
02:00005664 7CFF            	   362: 	moveq #-1,d6						; set head to negative when removing last
02:00005666 33861002        	   363: 	move.w d6,2(a1,d1.w)		; tail = negative
02:0000566A 60DC            	   364: 	bra .0003
                            	   365: .nextQ
02:0000566C 5841            	   366: 	addi.w #4,d1						; increment queue number by lword
02:0000566E 0241001C        	   367: 	andi.w #$1C,d1					; limit to number of queues
02:00005672 51CCFF9C        	   368: 	dbra d4,.0002						; go back and check the next queue
02:00005676 70FF            	   369: 	moveq #-1,d0						; return handle < 0 if nothing in any queue
02:00005678 91C8            	   370: 	suba.l a0,a0						; and NULL pointer
02:0000567A 60DE            	   371: 	bra	.0004								; return NULL pointer if nothing in any queue
                            	   372: 
                            	   373: ;------------------------------------------------------------------------------
                            	   374: ; Remove a thread from the timeout list.
                            	   375: ; Called when a mailbox is freed and a thread is waiting at the
                            	   376: ; mailbox.
                            	   377: ;
                            	   378: ; Parameters:
                            	   379: ;		B = task id to remove
                            	   380: ; Modifies:
                            	   381: ;		none
                            	   382: ; Returns:
                            	   383: ;		none
                            	   384: ;------------------------------------------------------------------------------
                            	   385: 	if 0
                            	   386: RemoveFromTimeoutList:
                            	   387: 	pshs	d,w,x,y,u
                            	   388: 	cmpb	TimeoutList			; head of list?
                            	   389: 	beq		0001f
                            	   390: 	lbsr	TCBHandleToPointer
                            	   391: 	tfr		d,x
                            	   392: 	ldb		TCBNext,x
                            	   393: 	clra
                            	   394: 	tfr		d,u
                            	   395: 	ldf		TCBPrev,x
                            	   396: 	lbsr	TCBHandleToPointer
                            	   397: 	tfr		d,y
                            	   398: 	stf		TCBPrev,y
                            	   399: 	tfr		f,b
                            	   400: 	clra
                            	   401: 	lbsr	TCBHandleToPointer
                            	   402: 	tfr		d,y
                            	   403: 	tfr		u,d
                            	   404: 	stb		TCBNext,y
                            	   405: 	bra		0002f
                            	   406: 	; Removing from head of timeout list
                            	   407: 0001:
                            	   408: 	lbsr	TCBHandleToPointer
                            	   409: 	tfr		d,x
                            	   410: 	ldb		TCBNext,x
                            	   411: 	stb		TimeoutList		; set new head of list
                            	   412: 	clra
                            	   413: 	lbsr	TCBHandleToPointer
                            	   414: 	tfr		d,y
                            	   415: 	clrb
                            	   416: 	stb		TCBPrev,y			; next->prev = NULL
                            	   417: 0002:
                            	   418: 	clrd
                            	   419: 	std		TCBNext,x			; next = NULL
                            	   420: 	std		TCBPrev,x			; prev = NULL
                            	   421: 	puls	d,w,x,y,u,pc
                            	   422: 	
                            	   423: ;// ----------------------------------------------------------------------------
                            	   424: ;// Pop the top entry from the timeout list.
                            	   425: ;// ----------------------------------------------------------------------------
                            	   426: ;
                            	   427: ;hTCB PopTimeoutList()
                            	   428: ;{
                            	   429: ;    TCB *p;
                            	   430: ;    hTCB h;
                            	   431: ;
                            	   432: ;    h = TimeoutList;
                            	   433: ;    if (TimeoutList > 0 && TimeoutList < NR_TCB) {
                            	   434: ;        TimeoutList = tcbs[TimeoutList].next;
                            	   435: ;        if (TimeoutList >= 0 && TimeoutList < NR_TCB) {
                            	   436: ;            tcbs[TimeoutList].prev = h->prev;
                            	   437: ;            h->prev->next = TimeoutList;
                            	   438: ;        }
                            	   439: ;    }
                            	   440: ;    return h;
                            	   441: ;}
                            	   442: ;
                            	   443: ; Returns:
                            	   444: ;		B = task at top of list
                            	   445: ;
                            	   446: 
                            	   447: PopTimeoutList:
                            	   448: 	pshs	w,x,y
                            	   449: 	ldb		TimeoutList
                            	   450: 	pshs	b
                            	   451: 	beq		0001f
                            	   452: 	cmpb	#NR_TCB
                            	   453: 	bhs		0001f
                            	   454: 	bsr		TCBHandleToPointer
                            	   455: 	tfr		d,x
                            	   456: 	ldb		TCBNext,x
                            	   457: 	tfr		b,f
                            	   458: 	lde		TCBPrev,x
                            	   459: 	stb		TimeoutList
                            	   460: 	beq		0001f
                            	   461: 	cmpb	#NR_TCB
                            	   462: 	bhs		0001f
                            	   463: 	bsr		TCBHandleToPointer
                            	   464: 	tfr		d,y
                            	   465: 	ste		TCBPrev,y
                            	   466: 	tfr		e,b
                            	   467: 	bsr		TCBHandleToPointer
                            	   468: 	tfr		d,y
                            	   469: 	stf		TCBNext,y
                            	   470: 	clr		TCBPrev,x
                            	   471: 	clr		TCBNext,x
                            	   472: 0001:
                            	   473: 	puls	b
                            	   474: 	puls	x,y,w,pc
                            	   475: 
                            	   476: ; ----------------------------------------------------------------------------
                            	   477: ; ----------------------------------------------------------------------------
                            	   478: DispTwoSpace:
                            	   479: 	bsr	DispSpace
                            	   480: DispSpace:
                            	   481: 	ldb		#' '
                            	   482: 	swi
                            	   483: 	fcb		MF_OUTCH
                            	   484: 	rts
                            	   485: 
                            	   486: DumpTCBs:
                            	   487: 	swi
                            	   488: 	fcb		MF_CRLF
                            	   489: 	ldb		#1
                            	   490: 0002:
                            	   491: 	lbsr	TCBHandleToPointer
                            	   492: 	tfr		d,x
                            	   493: 	ldb		TCBtid,x
                            	   494: 	swi
                            	   495: 	fcb		MF_DisplayByteAsHex
                            	   496: 	bsr		DispSpace
                            	   497: 	ldb		TCBStatus,x
                            	   498: 	swi
                            	   499: 	fcb		MF_DisplayByteAsHex
                            	   500: 	bsr		DispTwoSpace
                            	   501: 	swi
                            	   502: 	fcb		MF_CRLF
                            	   503: 	ldb		TCBNext,x
                            	   504: 	beq		0001f
                            	   505: 	bra		0002b
                            	   506: 0001:
                            	   507: 	rts
                            	   508: 	
                            	   509: fcb	"TID Stat"
                            	   510: 	endif
                            	   511: 
                            	   512: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     9: 	include "..\Femtiki\source\kernel\Femtiki.x68"

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     1: 	code
                            	     2: 	even
                            	     3: ;------------------------------------------------------------------------------
                            	     4: ; Initialize the Femtiki OS.
                            	     5: ;------------------------------------------------------------------------------
                            	     6: 
                            	     7: FemtikiInit:
02:0000567C 7000            	     8: 	moveq #0,d0
02:0000567E 4E7B0012        	     9: 	movec d0,tr
02:00005682 6100FDD8        	    10: 	bsr TCBInit
02:00005686 42390010031C    	    11: 	clr.b QueueCycle
                            	    12: FemtikiInitIRQ:
02:0000568C 43FA00DC        	    13: 	lea FemtikiTimerIRQ,a1						; Set timer IRQ vector to Femtiki
02:00005690 4E7A8801        	    14: 	movec vbr,a0
02:00005694 21490078        	    15: 	move.l a1,30*4(a0)								; vector #30
02:00005698 4E75            	    16: 	rts
                            	    17: 
                            	    18: ;------------------------------------------------------------------------------
                            	    19: ; Operating system call dispatcher.
                            	    20: ; On entry, the task state has been saved including the system stack pointer,
                            	    21: ; in the task control block.
                            	    22: ;------------------------------------------------------------------------------
                            	    23: 
                            	    24: OSCallTable
02:0000569A 0000            	    25: 	dc.w		0
                            	    26: 
                            	    27: 	even
                            	    28: CallOS:
02:0000569C 2F08            	    29: 	move.l	a0,-(a7)
02:0000569E 207900100224    	    30: 	move.l	RunningTCB,a0
02:000056A4 48E8FFFF0004    	    31: 	movem.l d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,TCBRegs(a0)
02:000056AA 225F            	    32: 	move.l	(a7)+,a1
02:000056AC 21490020        	    33: 	move.l	a1,32(a0)
02:000056B0 4E7A9800        	    34: 	movec		usp,a1
02:000056B4 21490044        	    35: 	move.l	a1,TCBUSP(a0)
02:000056B8 301F            	    36: 	move.w	(a7)+,d0					; pop the status register
02:000056BA 3140004C        	    37: 	move.w	d0,TCBSR(a0)			; save in TCB
02:000056BE 225F            	    38: 	move.l	(a7)+,a1					; pop the program counter
02:000056C0 5489            	    39: 	lea	2(a1),a1							; increment past inline callno argument
02:000056C2 21490050        	    40: 	move.l	a1,TCBPC(a0)			; save PC in TCB
02:000056C6 214F0048        	    41: 	move.l	a7,TCBSSP(a0)			; finally save SSP
02:000056CA 3029FFFE        	    42: 	move.w	-2(a1),d0					; d0 = call number
02:000056CE E548            	    43: 	lsl.w		#2,d0							; make into table index
02:000056D0 43FAFFC8        	    44: 	lea			OSCallTable,a1
02:000056D4 22710000        	    45: 	move.l	(a1,d0.w),a1
02:000056D8 4E91            	    46: 	jsr			(a1)							; call the OS function
                            	    47: 	; Restore the thread context and return
02:000056DA 207900100224    	    48: 	move.l	RunningTCB,a0
02:000056E0 2E780048        	    49: 	move.l	TCBSSP,a7
02:000056E4 2F280050        	    50: 	move.l	TCBPC(a0),-(a7)		; setup the PC and the SR on the stack
02:000056E8 3F28004C        	    51: 	move.w	TCBSR(a0),-(a7)		; prep for RTE
02:000056EC 20380044        	    52: 	move.l	TCBUSP,d0					; restore user stack pointer
02:000056F0 4E7B0800        	    53: 	movec		d0,usp
02:000056F4 4CE800FF0004    	    54: 	movem.l	TCBRegs(a0),d0/d1/d2/d3/d4/d5/d6/d7
02:000056FA 4CE87E00002C    	    55: 	movem.l TCBRegs+40(a0),a1/a2/a3/a4/a5/a6
02:00005700 20680024        	    56: 	move.l	TCBRegs+32(a0),a0
02:00005704 4E73            	    57: 	rte
                            	    58: 
                            	    59: ;------------------------------------------------------------------------------
                            	    60: ; Get a pointer to the currently running TCB.
                            	    61: ;
                            	    62: ; Returns:
                            	    63: ;		a0 = pointer to running TCB
                            	    64: ;------------------------------------------------------------------------------
                            	    65: 
                            	    66: GetRunningTCBPointer:
02:00005706 48E7C000        	    67: 	movem.l d0/d1,-(a7)
02:0000570A 4E7A0012        	    68: 	movec tr,d0
02:0000570E 6100FD74        	    69: 	bsr TCBHandleToPointer
02:00005712 028000000FFF    	    70: 	andi.l #MAX_TID,d0		; limit to # threads
02:00005718 4CDF0003        	    71: 	movem.l (a7)+,d0/d1
02:0000571C 4E75            	    72: 	rts
                            	    73: 
                            	    74: ; ----------------------------------------------------------------------------
                            	    75: ; Select a thread to run. Relatively easy. All that needs to be done is to
                            	    76: ; keep popping the queue until a valid running task is found. There should
                            	    77: ; always be at least one thread in the queue.
                            	    78: ;
                            	    79: ; Modifies:
                            	    80: ;		none
                            	    81: ; Returns:
                            	    82: ;		d0 = handle of the next thread to run
                            	    83: ; ----------------------------------------------------------------------------
                            	    84: 
                            	    85: SelectThreadToRun:
                            	    86: .0001										; keep popping tasks from the readyQ until a valid one
02:0000571E 6100FEB6        	    87: 	bsr	TCBPopReadyQueue	; is found.
02:00005722 4A40            	    88: 	tst.w d0
02:00005724 6B0C            	    89: 	bmi	.0002
02:00005726 0C2800800054    	    90: 	cmpi.b #TS_RUNNING,TCBStatus(a0)	; ensure the thread is to be running
02:0000572C 66F0            	    91: 	bne	.0001													; if not, go get the next thread
02:0000572E 6000FE04        	    92: 	bra	TCBInsertIntoReadyQueue				; insert thread back into queue
                            	    93: 	; Nothing in queues? There is supposed to be. Add the OS task to the queue.
                            	    94: .0002
02:00005732 4E7A8013        	    95: 	movec tcba,a0
02:00005736 117C00800054    	    96: 	move.b #TS_RUNNING,TCBStatus(a0)	; flag as RUNNING
02:0000573C 117C00040055    	    97: 	move.b #4,TCBPriority(a0)					; OS has normal priority
02:00005742 7000            	    98: 	moveq #0,d0												; fast pointer to handle
02:00005744 6000FDEE        	    99: 	bra TCBInsertIntoReadyQueue
                            	   100: 
                            	   101: ; ----------------------------------------------------------------------------
                            	   102: ; Update the IRQ live indicator on screen.
                            	   103: ; ----------------------------------------------------------------------------
                            	   104: 
                            	   105: UpdateIRQLive:
02:00005748 227900040004    	   106: 	move.l TextScr,a1					; a1 = screen address
02:0000574E 2411            	   107: 	move.l (a1),d2
02:00005750 E15A            	   108: 	rol.w	#8,d2								; reverse byte order of d2
02:00005752 4842            	   109: 	swap d2
02:00005754 E15A            	   110: 	rol.w	#8,d2
02:00005756 06010030        	   111: 	addi.b #'0',d1						; binary to ascii core number
02:0000575A D202            	   112: 	add.b	d2,d1
02:0000575C E159            	   113: 	rol.w	#8,d1								; put bytes back in order
02:0000575E 4841            	   114: 	swap d1
02:00005760 E159            	   115: 	rol.w	#8,d1
02:00005762 23410004        	   116: 	move.l d1,4(a1)						; update onscreen IRQ flag
02:00005766 5291            	   117: 	addi.l #1,(a1)						; flashy colors
02:00005768 4E75            	   118: 	rts
                            	   119: 
                            	   120: ; ----------------------------------------------------------------------------
                            	   121: ; Femtiki IRQ service routine. This is where a thread switch can occur so,
                            	   122: ; the thread context is saved and restored.
                            	   123: ; ----------------------------------------------------------------------------
                            	   124: 
                            	   125: FemtikiTimerIRQ:
02:0000576A 46FC2600        	   126: 	move.w #$2600,sr							; disable lower level IRQs
02:0000576E 2F00            	   127: 	move.l d0,-(a7)
02:00005770 2F08            	   128: 	move.l a0,-(a7)
02:00005772 6192            	   129: 	bsr GetRunningTCBPointer			; a0 = pointer to running TCB
02:00005774 48E8FFFF0004    	   130: 	movem.l #$FFFF,TCBRegs(a0)		; save all registers
02:0000577A 201F            	   131: 	move.l (a7)+,d0
02:0000577C 21400020        	   132: 	move.l d0,32(a0)							; save original a0 value
02:00005780 201F            	   133: 	move.l (a7)+,d0
02:00005782 2080            	   134: 	move.l d0,(a0)								; save original d0 value
02:00005784 4E7A0800        	   135: 	movec usp,d0									; save user stack pointer
02:00005788 21400044        	   136: 	move.l d0,TCBUSP(a0)
02:0000578C 2E7C00040BFC    	   137: 	move.l #TimerStack,a7					; reset stack pointer
02:00005792 4E7A1FE0        	   138: 	movec	coreno,d1								; d1 = core number
02:00005796 0C010002        	   139: 	cmpi.b #2,d1
02:0000579A 6612            	   140: 	bne.s	.0002
02:0000579C 23FC1D000000FD09	   141: 	move.l #$1D000000,PLIC+$14		; reset edge sense circuit
02:000057A4 0014
02:000057A6 13FC0001000400A0	   142: 	move.b #1,IRQFlag							; set IRQ flag for TinyBasic shell
                            	   143: .0002
02:000057AE 6198            	   144: 	bsr UpdateIRQLive							; Update IRQ live indicator
                            	   145: ;	bsr ReceiveMsg								; Check for RPC
02:000057B0 4E7A0FF0        	   146: 	movec tick,d0									; Update time accounting
02:000057B4 21400070        	   147: 	move.l d0,TCBEndTick(a0)			; compute number of ticks thread was running
02:000057B8 90A8006C        	   148: 	sub.l	TCBStartTick(a0),d0
02:000057BC D1A80074        	   149: 	add.l	d0,TCBTicks(a0)					; add to cumulative ticks
02:000057C0 117C00200054    	   150: 	move.b #TS_PREEMPT,TCBStatus(a0)	; set thread status to PREEMPT
02:000057C6 6100FF56        	   151: 	bsr	SelectThreadToRun					; d0 = TCB handle
02:000057CA 4E7B0012        	   152: 	movec d0,tr										; set running thread number in tr
02:000057CE 6100FF36        	   153: 	bsr GetRunningTCBPointer			; a0 = pointer to TCB
02:000057D2 117C00800054    	   154: 	move.b #TS_RUNNING,TCBStatus(a0)	; set thread status to RUNNING
02:000057D8 4E7A0FF0        	   155: 	movec	tick,d0
02:000057DC 2140006C        	   156: 	move.l d0,TCBStartTick(a0)		; record starting tick
02:000057E0 20280044        	   157: 	move.l TCBUSP(a0),d0					; restore user stack pointer
02:000057E4 4E7B0800        	   158: 	movec d0,usp
02:000057E8 4CE8FFFF0004    	   159: 	movem.l TCBRegs(a0),#$FFFF		; restore all registers
02:000057EE 504F            	   160: 	addq #8,sp										; "pop" d0/a0, saved stack pointer is off by 8
02:000057F0 4E73            	   161: 	rte														; and return
                            	   162: 
                            	   163: 	include "..\Femtiki\source\kernel\Semaphore.x68"

Source: "..\Femtiki\source\kernel\Semaphore.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;-------------------------------------------------------------------------------
                            	    38: ; Lock the system semaphore. Call the BIOS.
                            	    39: ;
                            	    40: ; Parameters:
                            	    41: ;		none
                            	    42: ; Returns:
                            	    43: ;		none
                            	    44: ;-------------------------------------------------------------------------------
                            	    45: 
                            	    46: LockSysSemaphore:
02:000057F2 48E7C000        	    47: 	movem.l d0/d1,-(sp)
02:000057F6 7025            	    48: 	moveq #37,d0				; lock semaphore
02:000057F8 7208            	    49: 	moveq #FMTK_SEMA,d1
02:000057FA 4E4F            	    50: 	trap #15
02:000057FC 4CDF0003        	    51: 	movem.l (sp)+,d0/d1
02:00005800 4E75            	    52: 	rts
                            	    53: 
                            	    54: 
                            	    55: ;-------------------------------------------------------------------------------
                            	    56: ; Unlock the system semaphore.
                            	    57: ;
                            	    58: ; Parameters:
                            	    59: ;		none
                            	    60: ; Returns:
                            	    61: ;		none
                            	    62: ;-------------------------------------------------------------------------------
                            	    63: 
                            	    64: UnlockSysSemaphore:
02:00005802 48E7C000        	    65: 	movem.l d0/d1,-(sp)
02:00005806 7026            	    66: 	moveq #38,d0				; unlock semaphore
02:00005808 7208            	    67: 	moveq #FMTK_SEMA,d1
02:0000580A 4E4F            	    68: 	trap #15
02:0000580C 4CDF0003        	    69: 	movem.l (sp)+,d0/d1
02:00005810 4E75            	    70: 	rts
                            	    71: 
                            	    72: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	   164: 
                            	   165: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	    10: 

Source: "boot.x68"
                            	   888: 
                            	   889: ; -----------------------------------------------------------------------------
                            	   890: ; Gets the screen color in d0 and d1.
                            	   891: ; -----------------------------------------------------------------------------
                            	   892: 
                            	   893: get_screen_color:
02:00005812 203900040084    	   894: 	move.l	fgColor,d0			; get foreground color
02:00005818 EB80            	   895: 	asl.l		#5,d0						; shift into position
02:0000581A 008040000000    	   896: 	ori.l		#$40000000,d0		; set priority
02:00005820 223900040088    	   897: 	move.l	bkColor,d1
02:00005826 E089            	   898: 	lsr.l		#8,d1
02:00005828 E089            	   899: 	lsr.l		#8,d1
02:0000582A 02810000001F    	   900: 	andi.l	#31,d1					; mask off extra bits
02:00005830 8081            	   901: 	or.l		d1,d0						; set background color bits in upper long word
02:00005832 223900040088    	   902: 	move.l	bkColor,d1			; get background color
02:00005838 E181            	   903: 	asl.l		#8,d1						; shift into position for display ram
02:0000583A E181            	   904: 	asl.l		#8,d1
02:0000583C 4E75            	   905: 	rts
                            	   906: 
                            	   907: ; -----------------------------------------------------------------------------
                            	   908: ; -----------------------------------------------------------------------------
                            	   909: 
                            	   910: get_screen_address:
02:0000583E 207900040004    	   911: 	move.l	TextScr,a0
02:00005844 4E75            	   912: 	rts
                            	   913: 	
                            	   914: ; -----------------------------------------------------------------------------
                            	   915: ; -----------------------------------------------------------------------------
                            	   916: 
                            	   917: clear_screen:
02:00005846 48E7E080        	   918: 	movem.l	d0/d1/d2/a0,-(a7)
02:0000584A 4E7A0FE0        	   919: 	movec		coreno,d0
02:0000584E 4840            	   920: 	swap		d0	
                            	   921: ;	moveq		#SCREEN_SEMA,d1
                            	   922: ;	bsr			LockSemaphore
02:00005850 61EC            	   923: 	bsr			get_screen_address	; a0 = pointer to screen area
02:00005852 10390004008C    	   924: 	move.b	TextRows,d0					; d0 = rows
02:00005858 14390004008D    	   925: 	move.b	TextCols,d2					; d2 = cols
02:0000585E 4880            	   926: 	ext.w		d0									; convert to word
02:00005860 4882            	   927: 	ext.w		d2									; convert to word
02:00005862 C4C0            	   928: 	mulu		d0,d2								; d2 = number of character cells to clear
02:00005864 61AC            	   929: 	bsr			get_screen_color		; get the color bits
02:00005866 00410020        	   930: 	ori.w		#32,d1							; load space character
02:0000586A E159            	   931: 	rol.w		#8,d1								; swap endian, text controller expects little endian
02:0000586C 4841            	   932: 	swap		d1
02:0000586E E159            	   933: 	rol.w		#8,d1
02:00005870 E158            	   934: 	rol.w		#8,d0								; swap endian
02:00005872 4840            	   935: 	swap		d0
02:00005874 E158            	   936: 	rol.w		#8,d0
                            	   937: loop3:
02:00005876 6100A8BE        	   938: 	bsr GlobalWriteLong					; copy char plus bkcolor to cell
02:0000587A 5888            	   939: 	addq.l #4,a0
02:0000587C C141            	   940: 	exg d0,d1
02:0000587E 6100A8B6        	   941: 	bsr GlobalWriteLong					; copy fgcolor to cell
02:00005882 5888            	   942: 	addq.l #4,a0
02:00005884 C141            	   943: 	exg d0,d1
02:00005886 51CAFFEE        	   944: 	dbra d2,loop3
02:0000588A 4E7A0FE0        	   945: 	movec coreno,d0
02:0000588E 4840            	   946: 	swap d0	
                            	   947: ;	moveq #SCREEN_SEMA,d1
                            	   948: ;	bsr UnlockSemaphore
02:00005890 4CDF0107        	   949: 	movem.l (a7)+,d0/d1/d2/a0
02:00005894 4E75            	   950: 	rts
                            	   951: 
                            	   952: CRLF:
02:00005896 2F01            	   953: 	move.l	d1,-(a7)
02:00005898 123C000D        	   954: 	move.b	#13,d1
02:0000589C 6142            	   955: 	bsr			DisplayChar
02:0000589E 123C000A        	   956: 	move.b	#10,d1
02:000058A2 613C            	   957: 	bsr			DisplayChar
02:000058A4 221F            	   958: 	move.l	(a7)+,d1
02:000058A6 4E75            	   959: 	rts
                            	   960: 
                            	   961: ;------------------------------------------------------------------------------
                            	   962: ;------------------------------------------------------------------------------
                            	   963: 
                            	   964: UpdateTextPos:
02:000058A8 103900040000    	   965: 	move.b	CursorRow,d0		; compute screen location
02:000058AE 0240007F        	   966: 	andi.w	#$7f,d0
02:000058B2 14390004008D    	   967: 	move.b	TextCols,d2
02:000058B8 4882            	   968: 	ext.w		d2
02:000058BA C0C2            	   969: 	mulu.w	d2,d0
02:000058BC 2600            	   970: 	move.l	d0,d3
02:000058BE 143900040001    	   971: 	move.b	CursorCol,d2
02:000058C4 024200FF        	   972: 	andi.w	#$ff,d2
02:000058C8 D042            	   973: 	add.w		d2,d0
02:000058CA 33C000040002    	   974: 	move.w	d0,TextPos			; save cursor pos
02:000058D0 4E75            	   975: 	rts
                            	   976: 
                            	   977: ;------------------------------------------------------------------------------
                            	   978: ; Calculate screen memory location from CursorRow,CursorCol.
                            	   979: ; Destroys d0,d2,a0
                            	   980: ;------------------------------------------------------------------------------
                            	   981: 
                            	   982: CalcScreenLoc:
02:000058D2 61D4            	   983: 	bsr			UpdateTextPos
02:000058D4 48C0            	   984: 	ext.l		d0								; make it into a long
02:000058D6 E780            	   985: 	asl.l		#3,d0							; 8 bytes per char
02:000058D8 6100FF64        	   986: 	bsr			get_screen_address
02:000058DC D1C0            	   987: 	add.l		d0,a0							; a0 = screen location
02:000058DE 4E75            	   988: 	rts
                            	   989: 
                            	   990: ;------------------------------------------------------------------------------
                            	   991: ; Display a character on the screen
                            	   992: ; d1.b = char to display
                            	   993: ;------------------------------------------------------------------------------
                            	   994: 
                            	   995: DisplayChar:
02:000058E0 48E77000        	   996: 	movem.l	d1/d2/d3,-(a7)
02:000058E4 4E7A2FE0        	   997: 	movec		coreno,d2
02:000058E8 0C020002        	   998: 	cmpi.b	#2,d2
                            	   999: ;	bne.s		.0001
                            	  1000: ;	bsr			SerialPutChar
                            	  1001: .0001:
02:000058EC 0281000000FF    	  1002: 	andi.l	#$ff,d1				; zero out upper bytes of d1
02:000058F2 0C01000D        	  1003: 	cmpi.b	#13,d1				; carriage return ?
02:000058F6 6610            	  1004: 	bne			dccr
02:000058F8 423900040001    	  1005: 	clr.b		CursorCol			; just set cursor column to zero on a CR
                            	  1006: dcx14:
02:000058FE 610002E2        	  1007: 	bsr			SyncCursor		; set position in text controller
                            	  1008: dcx7:
02:00005902 4CDF000E        	  1009: 	movem.l	(a7)+,d1/d2/d3
02:00005906 4E75            	  1010: 	rts
                            	  1011: dccr:
02:00005908 0C010091        	  1012: 	cmpi.b	#$91,d1			; cursor right ?
02:0000590C 6618            	  1013: 	bne.s   dcx6
02:0000590E 14390004008D    	  1014: 	move.b	TextCols,d2
02:00005914 5302            	  1015: 	sub.b		#1,d2
02:00005916 943900040001    	  1016: 	sub.b		CursorCol,d2
02:0000591C 67E4            	  1017: 	beq.s		dcx7
02:0000591E 523900040001    	  1018: 	addi.b	#1,CursorCol
02:00005924 60D8            	  1019: 	bra.s		dcx14
                            	  1020: dcx6:
02:00005926 0C010090        	  1021: 	cmpi.b	#$90,d1			; cursor up ?
02:0000592A 6610            	  1022: 	bne.s		dcx8
02:0000592C 4A3900040000    	  1023: 	cmpi.b	#0,CursorRow
02:00005932 67CE            	  1024: 	beq.s		dcx7
02:00005934 533900040000    	  1025: 	subi.b	#1,CursorRow
02:0000593A 60C2            	  1026: 	bra.s		dcx14
                            	  1027: dcx8:
02:0000593C 0C010093        	  1028: 	cmpi.b	#$93,d1			; cursor left?
02:00005940 6610            	  1029: 	bne.s		dcx9
02:00005942 4A3900040001    	  1030: 	cmpi.b	#0,CursorCol
02:00005948 67B8            	  1031: 	beq.s		dcx7
02:0000594A 533900040001    	  1032: 	subi.b	#1,CursorCol
02:00005950 60AC            	  1033: 	bra.s		dcx14
                            	  1034: dcx9:
02:00005952 0C010092        	  1035: 	cmpi.b	#$92,d1			; cursor down ?
02:00005956 6618            	  1036: 	bne.s		dcx10
02:00005958 14390004008C    	  1037: 	move.b	TextRows,d2
02:0000595E 5302            	  1038: 	sub.b		#1,d2
02:00005960 B43900040000    	  1039: 	cmp.b		CursorRow,d2
02:00005966 679A            	  1040: 	beq.s		dcx7
02:00005968 523900040000    	  1041: 	addi.b	#1,CursorRow
02:0000596E 608E            	  1042: 	bra.s		dcx14
                            	  1043: dcx10:
02:00005970 0C010094        	  1044: 	cmpi.b	#$94,d1			; cursor home ?
02:00005974 661C            	  1045: 	bne.s		dcx11
02:00005976 4A3900040001    	  1046: 	cmpi.b	#0,CursorCol
02:0000597C 670A            	  1047: 	beq.s		dcx12
02:0000597E 423900040001    	  1048: 	clr.b		CursorCol
02:00005984 6000FF78        	  1049: 	bra			dcx14
                            	  1050: dcx12:
02:00005988 423900040000    	  1051: 	clr.b		CursorRow
02:0000598E 6000FF6E        	  1052: 	bra			dcx14
                            	  1053: dcx11:
02:00005992 48E7E080        	  1054: 	movem.l	d0/d1/d2/a0,-(a7)
02:00005996 0C010099        	  1055: 	cmpi.b	#$99,d1			; delete ?
02:0000599A 6762            	  1056: 	beq.s		doDelete
02:0000599C 0C010008        	  1057: 	cmpi.b	#CTRLH,d1			; backspace ?
02:000059A0 674E            	  1058: 	beq.s   doBackspace
02:000059A2 0C010018        	  1059: 	cmpi.b	#CTRLX,d1			; delete line ?
02:000059A6 670000A4        	  1060: 	beq			doCtrlX
02:000059AA 0C01000A        	  1061: 	cmpi.b	#10,d1		; linefeed ?
02:000059AE 672E            	  1062: 	beq.s		dclf
                            	  1063: 
                            	  1064: 	; regular char
02:000059B0 6100FF20        	  1065: 	bsr			CalcScreenLoc	; a0 = screen location
02:000059B4 2401            	  1066: 	move.l	d1,d2					; d2 = char
02:000059B6 6100FE5A        	  1067: 	bsr			get_screen_color	; d0,d1 = color
02:000059BA 8282            	  1068: 	or.l		d2,d1					; d1 = char + color
02:000059BC E159            	  1069: 	rol.w		#8,d1					; text controller expects little endian data
02:000059BE 4841            	  1070: 	swap		d1
02:000059C0 E159            	  1071: 	rol.w		#8,d1
02:000059C2 6100A772        	  1072: 	bsr GlobalWriteLong
02:000059C6 E158            	  1073: 	rol.w		#8,d0					; swap bytes
02:000059C8 4840            	  1074: 	swap		d0						; swap halfs
02:000059CA E158            	  1075: 	rol.w		#8,d0					; swap remaining bytes
02:000059CC 2200            	  1076: 	move.l d0,d1
02:000059CE 5888            	  1077: 	addq.l #4,a0
02:000059D0 6100A764        	  1078: 	bsr GlobalWriteLong
02:000059D4 6100009C        	  1079: 	bsr	IncCursorPos
02:000059D8 61000208        	  1080: 	bsr	SyncCursor
02:000059DC 6008            	  1081: 	bra	dcx4
                            	  1082: dclf:
02:000059DE 610000B2        	  1083: 	bsr			IncCursorRow
                            	  1084: dcx16:
02:000059E2 610001FE        	  1085: 	bsr			SyncCursor
                            	  1086: dcx4:
02:000059E6 4CDF0107        	  1087: 	movem.l	(a7)+,d0/d1/d2/a0		; get back a0
02:000059EA 4CDF000E        	  1088: 	movem.l	(a7)+,d1/d2/d3
02:000059EE 4E75            	  1089: 	rts
                            	  1090: 
                            	  1091: 	;---------------------------
                            	  1092: 	; CTRL-H: backspace
                            	  1093: 	;---------------------------
                            	  1094: doBackspace:
02:000059F0 4A3900040001    	  1095: 	cmpi.b	#0,CursorCol		; if already at start of line
02:000059F6 67EE            	  1096: 	beq.s   dcx4						; nothing to do
02:000059F8 533900040001    	  1097: 	subi.b	#1,CursorCol		; decrement column
                            	  1098: 
                            	  1099: 	;---------------------------
                            	  1100: 	; Delete key
                            	  1101: 	;---------------------------
                            	  1102: doDelete:
02:000059FE 48E7C080        	  1103: 	movem.l	d0/d1/a0,-(a7)	; save off screen location
02:00005A02 6100FECE        	  1104: 	bsr	CalcScreenLoc				; a0 = screen location
02:00005A06 103900040001    	  1105: 	move.b CursorCol,d0
                            	  1106: .0001:
02:00005A0C 5088            	  1107: 	lea 8(a0),a0						; pull remaining characters on line over 1
02:00005A0E 6100A722        	  1108: 	bsr GlobalReadLong
02:00005A12 5188            	  1109: 	lea -8(a0),a0
02:00005A14 6100A720        	  1110: 	bsr GlobalWriteLong
02:00005A18 41E8000C        	  1111: 	lea 12(a0),a0
02:00005A1C 6100A714        	  1112: 	bsr GlobalReadLong			; pull remaining characters on line over 1
02:00005A20 5188            	  1113: 	lea -8(a0),a0
02:00005A22 6100A712        	  1114: 	bsr GlobalWriteLong
02:00005A26 5888            	  1115: 	lea	4(a0),a0
02:00005A28 5200            	  1116: 	addi.b #1,d0
02:00005A2A B0390004008D    	  1117: 	cmp.b	TextCols,d0
02:00005A30 65DA            	  1118: 	blo.s	.0001
02:00005A32 6100FDDE        	  1119: 	bsr	get_screen_color
02:00005A36 323C0020        	  1120: 	move.w #' ',d1					; terminate line with a space
02:00005A3A E159            	  1121: 	rol.w	#8,d1
02:00005A3C 4841            	  1122: 	swap d1
02:00005A3E E159            	  1123: 	rol.w	#8,d1
02:00005A40 5188            	  1124: 	lea -8(a0),a0
02:00005A42 6100A6F2        	  1125: 	bsr GlobalWriteLong
02:00005A46 4CDF0103        	  1126: 	movem.l	(a7)+,d0/d1/a0
02:00005A4A 6096            	  1127: 	bra.s		dcx16				; finished
                            	  1128: 
                            	  1129: 	;---------------------------
                            	  1130: 	; CTRL-X: erase line
                            	  1131: 	;---------------------------
                            	  1132: doCtrlX:
02:00005A4C 423900040001    	  1133: 	clr.b	CursorCol			; Reset cursor to start of line
02:00005A52 10390004008D    	  1134: 	move.b TextCols,d0	; and display TextCols number of spaces
02:00005A58 4880            	  1135: 	ext.w	d0
02:00005A5A 48C0            	  1136: 	ext.l	d0
02:00005A5C 123C0020        	  1137: 	move.b #' ',d1			; d1 = space char
                            	  1138: .0001:
                            	  1139: 	; DisplayChar is called recursively here
                            	  1140: 	; It's safe to do because we know it won't recurse again due to the
                            	  1141: 	; fact we know the character being displayed is a space char
02:00005A60 6100FE7E        	  1142: 	bsr	DisplayChar			
02:00005A64 5340            	  1143: 	subq #1,d0
02:00005A66 66F8            	  1144: 	bne.s	.0001
02:00005A68 423900040001    	  1145: 	clr.b	CursorCol			; now really go back to start of line
02:00005A6E 6000FF72        	  1146: 	bra	dcx16						; we're done
                            	  1147: 
                            	  1148: ;------------------------------------------------------------------------------
                            	  1149: ; Increment the cursor position, scroll the screen if needed.
                            	  1150: ;------------------------------------------------------------------------------
                            	  1151: 
                            	  1152: IncCursorPos:
02:00005A72 527900040002    	  1153: 	addi.w	#1,TextCurpos
02:00005A78 523900040001    	  1154: 	addi.b	#1,CursorCol
02:00005A7E 10390004008D    	  1155: 	move.b	TextCols,d0
02:00005A84 B03900040001    	  1156: 	cmp.b		CursorCol,d0
02:00005A8A 6438            	  1157: 	bhs.s		icc1
02:00005A8C 423900040001    	  1158: 	clr.b		CursorCol
                            	  1159: IncCursorRow:
02:00005A92 523900040000    	  1160: 	addi.b	#1,CursorRow
02:00005A98 10390004008C    	  1161: 	move.b	TextRows,d0
02:00005A9E B03900040000    	  1162: 	cmp.b		CursorRow,d0
02:00005AA4 621E            	  1163: 	bhi.s		icc1
02:00005AA6 10390004008C    	  1164: 	move.b	TextRows,d0
02:00005AAC 13C000040000    	  1165: 	move.b	d0,CursorRow		; in case CursorRow is way over
02:00005AB2 533900040000    	  1166: 	subi.b	#1,CursorRow
02:00005AB8 4880            	  1167: 	ext.w		d0
02:00005ABA D040            	  1168: 	asl.w		#1,d0
02:00005ABC 917900040002    	  1169: 	sub.w		d0,TextCurpos
02:00005AC2 6102            	  1170: 	bsr			ScrollUp
                            	  1171: icc1:
02:00005AC4 4E75            	  1172: 	rts
                            	  1173: 
                            	  1174: ;------------------------------------------------------------------------------
                            	  1175: ; Scroll screen up.
                            	  1176: ;------------------------------------------------------------------------------
                            	  1177: 
                            	  1178: ScrollUp:
02:00005AC6 48E7C084        	  1179: 	movem.l	d0/d1/a0/a5,-(a7)		; save off some regs
02:00005ACA 4E7A0FE0        	  1180: 	movec	coreno,d0
02:00005ACE 4840            	  1181: 	swap d0	
02:00005AD0 7205            	  1182: 	moveq	#SCREEN_SEMA,d1
02:00005AD2 6100A784        	  1183: 	bsr			LockSemaphore
02:00005AD6 6100FD66        	  1184: 	bsr			get_screen_address
02:00005ADA 2A48            	  1185: 	move.l	a0,a5								; a5 = pointer to text screen
                            	  1186: .0003:								
02:00005ADC 10390004008D    	  1187: 	move.b	TextCols,d0					; d0 = columns
02:00005AE2 12390004008C    	  1188: 	move.b	TextRows,d1					; d1 = rows
02:00005AE8 4880            	  1189: 	ext.w		d0									; make cols into a word value
02:00005AEA 4881            	  1190: 	ext.w		d1									; make rows into a word value
02:00005AEC E740            	  1191: 	asl.w		#3,d0								; make into cell index
02:00005AEE 41F50000        	  1192: 	lea			0(a5,d0.w),a0				; a0 = pointer to second row of text screen
02:00005AF2 E648            	  1193: 	lsr.w		#3,d0								; get back d0
02:00005AF4 5341            	  1194: 	subq		#1,d1								; number of rows-1
02:00005AF6 C0C1            	  1195: 	mulu		d1,d0								; d0 = count of characters to move
02:00005AF8 D080            	  1196: 	add.l d0,d0									; d0*2 2 longs per char
                            	  1197: .0001:
02:00005AFA 6100A636        	  1198: 	bsr GlobalReadLong
02:00005AFE CB48            	  1199: 	exg a5,a0
02:00005B00 6100A634        	  1200: 	bsr GlobalWriteLong
02:00005B04 CB48            	  1201: 	exg a5,a0
02:00005B06 5888            	  1202: 	lea 4(a0),a0								; each char is 64 bits
02:00005B08 588D            	  1203: 	lea 4(a5),a5
02:00005B0A 51C8FFEE        	  1204: 	dbra d0,.0001
02:00005B0E 4E7A0FE0        	  1205: 	movec coreno,d0
02:00005B12 4840            	  1206: 	swap d0	
02:00005B14 7205            	  1207: 	moveq #SCREEN_SEMA,d1
02:00005B16 6100A77C        	  1208: 	bsr UnlockSemaphore
02:00005B1A 4CDF2103        	  1209: 	movem.l (a7)+,d0/d1/a0/a5
                            	  1210: 	; Fall through into blanking out last line
                            	  1211: 
                            	  1212: ;------------------------------------------------------------------------------
                            	  1213: ; Blank out the last line on the screen.
                            	  1214: ;------------------------------------------------------------------------------
                            	  1215: 
                            	  1216: BlankLastLine:
02:00005B1E 48E7E080        	  1217: 	movem.l	d0/d1/d2/a0,-(a7)
02:00005B22 4E7A0FE0        	  1218: 	movec	coreno,d0
02:00005B26 4840            	  1219: 	swap d0	
02:00005B28 7205            	  1220: 	moveq	#SCREEN_SEMA,d1
02:00005B2A 6100A72C        	  1221: 	bsr			LockSemaphore
02:00005B2E 6100FD0E        	  1222: 	bsr			get_screen_address
02:00005B32 10390004008C    	  1223: 	move.b	TextRows,d0					; d0 = rows
02:00005B38 12390004008D    	  1224: 	move.b	TextCols,d1					; d1 = columns
02:00005B3E 4880            	  1225: 	ext.w		d0
02:00005B40 4881            	  1226: 	ext.w		d1
02:00005B42 5340            	  1227: 	subq		#1,d0								; last row = #rows-1
02:00005B44 C0C1            	  1228: 	mulu		d1,d0								; d0 = index of last line
02:00005B46 E748            	  1229: 	lsl.w		#3,d0								; *8 bytes per char
02:00005B48 41F00000        	  1230: 	lea			(a0,d0.w),a0				; point a0 to last row
02:00005B4C 14390004008D    	  1231: 	move.b	TextCols,d2					; number of text cells to clear
02:00005B52 4882            	  1232: 	ext.w		d2
02:00005B54 5342            	  1233: 	subi.w	#1,d2								; count must be one less than desired
02:00005B56 6100FCBA        	  1234: 	bsr			get_screen_color		; d0,d1 = screen color
02:00005B5A 323C0020        	  1235: 	move.w	#32,d1							; set the character for display in low 16 bits
02:00005B5E 61001B6C        	  1236: 	bsr			rbo									; reverse the byte order
02:00005B62 E158            	  1237: 	rol.w		#8,d0
02:00005B64 4840            	  1238: 	swap		d0
02:00005B66 E158            	  1239: 	rol.w		#8,d0
                            	  1240: .0001:
02:00005B68 C340            	  1241: 	exg d1,d0
02:00005B6A 6100A5CA        	  1242: 	bsr GlobalWriteLong
02:00005B6E 5888            	  1243: 	lea 4(a0),a0
02:00005B70 C340            	  1244: 	exg d1,d0
02:00005B72 6100A5C2        	  1245: 	bsr GlobalWriteLong
02:00005B76 5888            	  1246: 	lea 4(a0),a0
02:00005B78 51CAFFEE        	  1247: 	dbra d2,.0001
02:00005B7C 4E7A0FE0        	  1248: 	movec	coreno,d0
02:00005B80 4840            	  1249: 	swap d0	
02:00005B82 7205            	  1250: 	moveq #SCREEN_SEMA,d1
02:00005B84 6100A70E        	  1251: 	bsr UnlockSemaphore
02:00005B88 4CDF0107        	  1252: 	movem.l	(a7)+,d0/d1/d2/a0
02:00005B8C 4E75            	  1253: 	rts
                            	  1254: 
                            	  1255: ;------------------------------------------------------------------------------
                            	  1256: ; Display a string on standard output.
                            	  1257: ;------------------------------------------------------------------------------
                            	  1258: 
                            	  1259: DisplayString:
02:00005B8E 48E7C040        	  1260: 	movem.l	d0/d1/a1,-(a7)
                            	  1261: dspj1:
02:00005B92 7200            	  1262: 	clr.l d1							; clear upper bits of d1
02:00005B94 1219            	  1263: 	move.b (a1)+,d1				; move string char into d1
02:00005B96 6706            	  1264: 	beq.s dsret						; is it end of string ?
02:00005B98 7006            	  1265: 	moveq #6,d0						; output character function
02:00005B9A 4E4F            	  1266: 	trap #15
02:00005B9C 60F4            	  1267: 	bra.s	dspj1						; go back for next character
                            	  1268: dsret:
02:00005B9E 4CDF0203        	  1269: 	movem.l	(a7)+,d0/d1/a1
02:00005BA2 4E75            	  1270: 	rts
                            	  1271: 
                            	  1272: ;------------------------------------------------------------------------------
                            	  1273: ; Display a string on the screen followed by carriage return / linefeed.
                            	  1274: ;------------------------------------------------------------------------------
                            	  1275: 
                            	  1276: DisplayStringCRLF:
02:00005BA4 61E8            	  1277: 	bsr		DisplayString
02:00005BA6 6000FCEE        	  1278: 	bra		CRLF
                            	  1279: 
                            	  1280: ;------------------------------------------------------------------------------
                            	  1281: ; Display a string on the screen limited to 255 chars max.
                            	  1282: ;------------------------------------------------------------------------------
                            	  1283: 
                            	  1284: DisplayStringLimited:
02:00005BAA 48E7E040        	  1285: 	movem.l	d0/d1/d2/a1,-(a7)
02:00005BAE 3401            	  1286: 	move.w	d1,d2					; d2 = max count
02:00005BB0 024200FF        	  1287: 	andi.w	#$00FF,d2			; limit to 255 chars
02:00005BB4 600A            	  1288: 	bra.s		.0003					; enter loop at bottom
                            	  1289: .0001:
02:00005BB6 7200            	  1290: 	clr.l d1							; clear upper bits of d1
02:00005BB8 1219            	  1291: 	move.b (a1)+,d1				; move string char into d1
02:00005BBA 6708            	  1292: 	beq.s .0002						; is it end of string ?
02:00005BBC 7006            	  1293: 	moveq #6,d0						; output character function
02:00005BBE 4E4F            	  1294: 	trap #15
                            	  1295: .0003:
02:00005BC0 51CAFFF4        	  1296: 	dbra		d2,.0001			; go back for next character
                            	  1297: .0002:
02:00005BC4 4CDF0207        	  1298: 	movem.l	(a7)+,d0/d1/d2/a1
02:00005BC8 4E75            	  1299: 	rts
                            	  1300: 
                            	  1301: DisplayStringLimitedCRLF:
02:00005BCA 61DE            	  1302: 	bsr		DisplayStringLimited
02:00005BCC 6000FCC8        	  1303: 	bra		CRLF
                            	  1304: 	
                            	  1305: ;------------------------------------------------------------------------------
                            	  1306: ; Set cursor position to top left of screen.
                            	  1307: ;
                            	  1308: ; Parameters:
                            	  1309: ;		<none>
                            	  1310: ; Returns:
                            	  1311: ;		<none>
                            	  1312: ; Registers Affected:
                            	  1313: ;		<none>
                            	  1314: ;------------------------------------------------------------------------------
                            	  1315: 
                            	  1316: HomeCursor:
02:00005BD0 423900040000    	  1317: 	clr.b		CursorRow
02:00005BD6 423900040001    	  1318: 	clr.b		CursorCol
02:00005BDC 427900040002    	  1319: 	clr.w		TextPos
                            	  1320: 	; fall through
                            	  1321: 
                            	  1322: ;------------------------------------------------------------------------------
                            	  1323: ; SyncCursor:
                            	  1324: ;
                            	  1325: ; Sync the hardware cursor's position to the text cursor position but only for
                            	  1326: ; the core with the IO focus.
                            	  1327: ;
                            	  1328: ; Parameters:
                            	  1329: ;		<none>
                            	  1330: ; Returns:
                            	  1331: ;		<none>
                            	  1332: ; Registers Affected:
                            	  1333: ;		<none>
                            	  1334: ;------------------------------------------------------------------------------
                            	  1335: 
                            	  1336: SyncCursor:
02:00005BE2 48E7E080        	  1337: 	movem.l	d0/d1/d2/a0,-(a7)
02:00005BE6 6100FCC0        	  1338: 	bsr	UpdateTextPos
02:00005BEA 7200            	  1339: 	clr.l d1
02:00005BEC 3200            	  1340: 	move.w d0,d1
02:00005BEE 4E7A2FE0        	  1341: 	movec	coreno,d2
02:00005BF2 B43900100000    	  1342: 	cmp.b	IOFocus,d2
02:00005BF8 6618            	  1343: 	bne.s .0001
02:00005BFA 5542            	  1344: 	subi.w #2,d2				; factor in location of screen in controller
02:00005BFC C4FC0800        	  1345: 	mulu #2048,d2				; 2048 cells per screen
02:00005C00 D282            	  1346: 	add.l	d2,d1
02:00005C02 E159            	  1347: 	rol.w	#8,d1					; swap byte order
02:00005C04 4841            	  1348: 	swap d1
02:00005C06 E159            	  1349: 	rol.w #8,d1
02:00005C08 41F9FD080024    	  1350: 	lea TEXTREG+$24,a0
02:00005C0E 6100A526        	  1351: 	bsr GlobalWriteLong
                            	  1352: .0001:	
02:00005C12 4CDF0107        	  1353: 	movem.l	(a7)+,a0/d0/d1/d2
02:00005C16 4E75            	  1354: 	rts
                            	  1355: 
                            	  1356: ;==============================================================================
                            	  1357: ; TRAP #15 handler
                            	  1358: ;
                            	  1359: ; Parameters:
                            	  1360: ;		d0.w = function number to perform
                            	  1361: ;==============================================================================
                            	  1362: 
                            	  1363: TRAP15:
02:00005C18 558F            	  1364: 	subq.l #2,sp						; keep stack lword aligned
02:00005C1A 48E78080        	  1365: 	movem.l	d0/a0,-(a7)
02:00005C1E 41FA0014        	  1366: 	lea T15DispatchTable,a0
02:00005C22 E580            	  1367: 	asl.l #2,d0
02:00005C24 20700000        	  1368: 	move.l (a0,d0.w),a0
02:00005C28 4E90            	  1369: 	jsr (a0)
02:00005C2A 4CDF0101        	  1370: 	movem.l (a7)+,d0/a0
02:00005C2E 548F            	  1371: 	addq.l #2,sp
02:00005C30 4E73            	  1372: 	rte
                            	  1373: 
                            	  1374: 		align	2
                            	  1375: T15DispatchTable:
02:00005C34 00005BCA        	  1376: 	dc.l	DisplayStringLimitedCRLF
02:00005C38 00005BAA        	  1377: 	dc.l	DisplayStringLimited
02:00005C3C 00005D1C        	  1378: 	dc.l	StubRout
02:00005C40 00005D1C        	  1379: 	dc.l	StubRout
02:00005C44 00005D1C        	  1380: 	dc.l	StubRout
02:00005C48 00005F88        	  1381: 	dc.l	GetKey
02:00005C4C 00007CC4        	  1382: 	dc.l	OutputChar
02:00005C50 00005F7C        	  1383: 	dc.l	CheckForKey
02:00005C54 00005D1C        	  1384: 	dc.l	StubRout
02:00005C58 00005D1C        	  1385: 	dc.l	StubRout
                            	  1386: 	; 10
02:00005C5C 00005D1C        	  1387: 	dc.l	StubRout
02:00005C60 00005CE4        	  1388: 	dc.l	Cursor1
02:00005C64 00005F74        	  1389: 	dc.l	SetKeyboardEcho
02:00005C68 00005BA4        	  1390: 	dc.l	DisplayStringCRLF
02:00005C6C 00005B8E        	  1391: 	dc.l	DisplayString
02:00005C70 00005D1C        	  1392: 	dc.l	StubRout
02:00005C74 00005D1C        	  1393: 	dc.l	StubRout
02:00005C78 00005D1C        	  1394: 	dc.l	StubRout
02:00005C7C 00005D1C        	  1395: 	dc.l	StubRout
02:00005C80 00005D1C        	  1396: 	dc.l	StubRout
                            	  1397: 	; 20
02:00005C84 00005D1C        	  1398: 	dc.l	StubRout
02:00005C88 00005D1C        	  1399: 	dc.l	StubRout
02:00005C8C 00005D1C        	  1400: 	dc.l	StubRout
02:00005C90 00005D1C        	  1401: 	dc.l	StubRout
02:00005C94 00005D1C        	  1402: 	dc.l	StubRout
02:00005C98 00005D1C        	  1403: 	dc.l	StubRout
02:00005C9C 00005D1C        	  1404: 	dc.l	StubRout
02:00005CA0 00005D1C        	  1405: 	dc.l	StubRout
02:00005CA4 00005D1C        	  1406: 	dc.l	StubRout
02:00005CA8 00005D1C        	  1407: 	dc.l	StubRout
                            	  1408: 	; 30
02:00005CAC 00005D1C        	  1409: 	dc.l	StubRout
02:00005CB0 00005D1C        	  1410: 	dc.l	StubRout
02:00005CB4 00005D30        	  1411: 	dc.l	rotate_iofocus
02:00005CB8 000077B6        	  1412: 	dc.l	SerialPeekCharDirect
02:00005CBC 000077D0        	  1413: 	dc.l	SerialPutChar
02:00005CC0 0000777E        	  1414: 	dc.l	SerialPeekChar
02:00005CC4 00007706        	  1415: 	dc.l	SerialGetChar
02:00005CC8 000002B0        	  1416: 	dc.l	T15LockSemaphore
02:00005CCC 000002B6        	  1417: 	dc.l	T15UnlockSemaphore
02:00005CD0 00007C3C        	  1418: 	dc.l	prtflt
                            	  1419: 	; 40
02:00005CD4 000001FA        	  1420: 	dc.l  _GetRand
02:00005CD8 000002BC        	  1421: 	dc.l	T15GetFloat
02:00005CDC 000002CA        	  1422: 	dc.l	T15Abort
02:00005CE0 00007C82        	  1423: 	dc.l	T15FloatToString
                            	  1424: 
                            	  1425: ;------------------------------------------------------------------------------
                            	  1426: ; Cursor positioning / Clear screen
                            	  1427: ; - out of range settings are ignored
                            	  1428: ;
                            	  1429: ; Parameters:
                            	  1430: ;		d1.w cursor position, bits 0 to 7 are row, bits 8 to 15 are column.
                            	  1431: ;	Returns:
                            	  1432: ;		none
                            	  1433: ;------------------------------------------------------------------------------
                            	  1434: 
                            	  1435: Cursor1:
02:00005CE4 2F01            	  1436: 	move.l d1,-(a7)
02:00005CE6 0C41FF00        	  1437: 	cmpi.w #$FF00,d1
02:00005CEA 660A            	  1438: 	bne.s .0002
02:00005CEC 6100FB58        	  1439: 	bsr	clear_screen
02:00005CF0 221F            	  1440: 	move.l (a7)+,d1
02:00005CF2 6000FEDC        	  1441: 	bra	HomeCursor
                            	  1442: .0002:
02:00005CF6 B2390004008C    	  1443: 	cmp.b TextRows,d1		; if cursor pos out of range, ignore setting
02:00005CFC 6406            	  1444: 	bhs.s	.0003
02:00005CFE 13C100040000    	  1445: 	move.b d1,CursorRow
                            	  1446: .0003:
02:00005D04 E059            	  1447: 	ror.w	#8,d1
02:00005D06 B2390004008D    	  1448: 	cmp.b	TextCols,d1
02:00005D0C 6406            	  1449: 	bhs.s	.0001
02:00005D0E 13C100040001    	  1450: 	move.b d1,CursorCol
                            	  1451: .0001:
02:00005D14 6100FECC        	  1452: 	bsr SyncCursor			; update hardware cursor
02:00005D18 221F            	  1453: 	move.l (a7)+,d1
02:00005D1A 4E75            	  1454: 	rts
                            	  1455: 
                            	  1456: ;------------------------------------------------------------------------------
                            	  1457: ; Stub routine for unimplemented functionality.
                            	  1458: ;------------------------------------------------------------------------------
                            	  1459: 
                            	  1460: StubRout:
02:00005D1C 4E75            	  1461: 	rts
                            	  1462: 
                            	  1463: ;------------------------------------------------------------------------------
                            	  1464: ; Select a specific IO focus.
                            	  1465: ;------------------------------------------------------------------------------
                            	  1466: 
                            	  1467: select_iofocus:
02:00005D1E 0C010002        	  1468: 	cmpi.b	#2,d1
02:00005D22 650A            	  1469: 	blo.s		.0001
02:00005D24 0C010009        	  1470: 	cmpi.b	#9,d1
02:00005D28 6204            	  1471: 	bhi.s		.0001
02:00005D2A 2001            	  1472: 	move.l	d1,d0
02:00005D2C 6014            	  1473: 	bra.s		select_focus1
                            	  1474: .0001:
02:00005D2E 4E75            	  1475: 	rts
                            	  1476: 
                            	  1477: ;------------------------------------------------------------------------------
                            	  1478: ; Rotate the IO focus, done when ALT-Tab is pressed.
                            	  1479: ;
                            	  1480: ; Modifies:
                            	  1481: ;		d0, IOFocus BIOS variable
                            	  1482: ;		updates the PLIC to send IRQs to focus core
                            	  1483: ;		updates the text screen pointer
                            	  1484: ;------------------------------------------------------------------------------
                            	  1485: 
                            	  1486: rotate_iofocus:
02:00005D30 103900100000    	  1487: 	move.b IOFocus,d0					; d0 = focus, we can trash d0
02:00005D36 5200            	  1488: 	add.b	#1,d0								; increment the focus
02:00005D38 B03C0009        	  1489: 	cmp.b	#9,d0								; limit to 2 to 9
02:00005D3C 6304            	  1490: 	bls.s	.0001
02:00005D3E 103C0002        	  1491: 	move.b #2,d0
                            	  1492: .0001:
                            	  1493: select_focus1:
02:00005D42 13C000100000    	  1494: 	move.b	d0,IOFocus				; set IO focus
                            	  1495: 	; reset keyboard processor to focus core
                            	  1496: ;	move.l #$3C060500,d0			; core=??,level sensitive,enabled,irq6,inta
                            	  1497: ;	or.b IOFocus,d0
                            	  1498: ;	move.l d0,PLIC+$80+4*30		; set register
                            	  1499: 	; Adjust text screen pointer
02:00005D48 5500            	  1500: 	subi.b #2,d0							; screen is 0 to 7, focus is 2 to 9
02:00005D4A 4880            	  1501: 	ext.w	d0									; make into word value
02:00005D4C C0FC0800        	  1502: 	mulu #2048,d0							; * 2048	cells per screen
02:00005D50 E158            	  1503: 	rol.w	#8,d0								; swap byte order
02:00005D52 4840            	  1504: 	swap d0										; get bits 16-31
02:00005D54 E158            	  1505: 	rol.w	#8,d0								; swap byte order
02:00005D56 23C0FD080028    	  1506: 	move.l d0,TEXTREG+$28			; update screen address in text controller
02:00005D5C 6100A3DA        	  1507: 	bsr net_delay
02:00005D60 6000FE80        	  1508: 	bra	SyncCursor						; set cursor position
                            	  1509: 
                            	  1510: ;==============================================================================
                            	  1511: ; PLIC - platform level interrupt controller
                            	  1512: ;
                            	  1513: ; Register layout:
                            	  1514: ;   bits 0 to 7  = cause code to issue (vector number)
                            	  1515: ;   bits 8 to 11 = irq level to issue
                            	  1516: ;   bit 16 = irq enable
                            	  1517: ;   bit 17 = edge sensitivity
                            	  1518: ;   bit 18 = 0=vpa, 1=inta
                            	  1519: ;		bit 24 to 29 target core
                            	  1520: ;
                            	  1521: ; Note byte order must be reversed for PLIC.
                            	  1522: ;==============================================================================
                            	  1523: 
                            	  1524: init_plic:
02:00005D64 41F9FD090000    	  1525: 	lea		PLIC,a0						; a0 points to PLIC
02:00005D6A 43E800F4        	  1526: 	lea		$80+4*29(a0),a1		; point to timer registers (29)
02:00005D6E 22BC0006033F    	  1527: 	move.l	#$0006033F,(a1)	; initialize, core=63,edge sensitive,enabled,irq6,vpa
02:00005D74 5889            	  1528: 	lea			4(a1),a1				; point to keyboard registers (30)
02:00005D76 22BC3C060502    	  1529: 	move.l	#$3C060502,(a1)	; core=2,level sensitive,enabled,irq6,inta
02:00005D7C 5889            	  1530: 	lea			4(a1),a1				; point to nmi button register (31)
02:00005D7E 22BC00070302    	  1531: 	move.l	#$00070302,(a1)	; initialize, core=2,edge sensitive,enabled,irq7,vpa
02:00005D84 43E800C0        	  1532: 	lea		$80+4*16(a0),a1		; a1 points to ACIA register
02:00005D88 22BC3D030502    	  1533: 	move.l	#$3D030502,(a1)	; core=2,level sensitive,enabled,irq3,inta	
02:00005D8E 43E80090        	  1534: 	lea		$80+4*4(a0),a1		; a1 points to io_bitmap irq
02:00005D92 22BC3B060702    	  1535: 	move.l	#$3B060702,(a1)	; core=2,edge sensitive,enabled,irq6,inta	
02:00005D98 4E75            	  1536: 	rts
                            	  1537: 
                            	  1538: ;==============================================================================
                            	  1539: ; Keyboard stuff
                            	  1540: ;
                            	  1541: ; KeyState2_
                            	  1542: ; 876543210
                            	  1543: ; ||||||||+ = shift
                            	  1544: ; |||||||+- = alt
                            	  1545: ; ||||||+-- = control
                            	  1546: ; |||||+--- = numlock
                            	  1547: ; ||||+---- = capslock
                            	  1548: ; |||+----- = scrolllock
                            	  1549: ; ||+------ =
                            	  1550: ; |+------- = 
                            	  1551: ; +-------- = extended
                            	  1552: ;
                            	  1553: ;==============================================================================
                            	  1554: 
                            	  1555: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1556: ; Get ID - get the keyboards identifier code.
                            	  1557: ;
                            	  1558: ; Parameters: none
                            	  1559: ; Returns: d = $AB83, $00 on fail
                            	  1560: ; Modifies: d, KeybdID updated
                            	  1561: ; Stack Space: 2 words
                            	  1562: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1563: 
                            	  1564: KeybdGetID:
02:00005D9A 323C00F2        	  1565: 	move.w	#$F2,d1
02:00005D9E 610004A4        	  1566: 	bsr			KeybdSendByte
02:00005DA2 610001AA        	  1567: 	bsr			KeybdWaitTx
02:00005DA6 61000186        	  1568: 	bsr			KeybdRecvByte
02:00005DAA 08010007        	  1569: 	btst		#7,d1
02:00005DAE 6624            	  1570: 	bne			kgnotKbd
02:00005DB0 0C0100AB        	  1571: 	cmpi.b	#$AB,d1
02:00005DB4 661E            	  1572: 	bne			kgnotKbd
02:00005DB6 61000176        	  1573: 	bsr			KeybdRecvByte
02:00005DBA 08010007        	  1574: 	btst		#7,d1
02:00005DBE 6614            	  1575: 	bne			kgnotKbd
02:00005DC0 0C010083        	  1576: 	cmpi.b	#$83,d1
02:00005DC4 660E            	  1577: 	bne			kgnotKbd
02:00005DC6 223C0000AB83    	  1578: 	move.l	#$AB83,d1
                            	  1579: kgid1:
02:00005DCC 33C100100016    	  1580: 	move.w	d1,KeybdID
02:00005DD2 4E75            	  1581: 	rts
                            	  1582: kgnotKbd:
02:00005DD4 7200            	  1583: 	moveq		#0,d1
02:00005DD6 60F4            	  1584: 	bra			kgid1
                            	  1585: 
                            	  1586: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1587: ; Set the LEDs on the keyboard.
                            	  1588: ;
                            	  1589: ; Parameters:
                            	  1590: ;		d1.b = LED state
                            	  1591: ;	Modifies:
                            	  1592: ;		none
                            	  1593: ; Returns:
                            	  1594: ;		none
                            	  1595: ; Stack Space:
                            	  1596: ;		1 long word
                            	  1597: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1598: 
                            	  1599: KeybdSetLED:
02:00005DD8 2F01            	  1600: 	move.l	d1,-(a7)
02:00005DDA 123C00ED        	  1601: 	move.b	#$ED,d1
02:00005DDE 61000464        	  1602: 	bsr			KeybdSendByte
02:00005DE2 6100016A        	  1603: 	bsr			KeybdWaitTx
02:00005DE6 61000146        	  1604: 	bsr			KeybdRecvByte
02:00005DEA 4A01            	  1605: 	tst.b		d1
02:00005DEC 6B12            	  1606: 	bmi			.0001
02:00005DEE 0C0100FA        	  1607: 	cmpi.b	#$FA,d1
02:00005DF2 2217            	  1608: 	move.l	(a7),d1
02:00005DF4 6100044E        	  1609: 	bsr			KeybdSendByte
02:00005DF8 61000154        	  1610: 	bsr			KeybdWaitTx
02:00005DFC 61000130        	  1611: 	bsr			KeybdRecvByte
                            	  1612: .0001:
02:00005E00 221F            	  1613: 	move.l	(a7)+,d1
02:00005E02 4E75            	  1614: 	rts
                            	  1615: 
                            	  1616: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1617: ; Initialize the keyboard.
                            	  1618: ;
                            	  1619: ; Parameters:
                            	  1620: ;		none
                            	  1621: ;	Modifies:
                            	  1622: ;		none
                            	  1623: ; Returns:
                            	  1624: ;		none
                            	  1625: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1626: 
                            	  1627: _KeybdInit:
                            	  1628: KeybdInit:
                            	  1629: ;	movem.l	d0/d1/d3/a1,-(a7)
02:00005E04 42390010000F    	  1630: 	clr.b	_KeyState1		; records key up/down state
02:00005E0A 423900100010    	  1631: 	clr.b	_KeyState2		; records shift,ctrl,alt state
02:00005E10 4E75            	  1632: 	rts
                            	  1633: 
02:00005E12 61000456        	  1634: 	bsr			Wait300ms
02:00005E16 610000F8        	  1635: 	bsr			_KeybdGetStatus	; wait for response from keyboard
02:00005E1A 4A01            	  1636: 	tst.b		d1
02:00005E1C 6A0C            	  1637: 	bpl			.0001					; is input buffer full ? no, branch
02:00005E1E 610000FC        	  1638: 	bsr			_KeybdGetScancode
02:00005E22 0C0100AA        	  1639: 	cmpi.b	#$AA,d1				; keyboard Okay
02:00005E26 67000096        	  1640: 	beq			kbdi0005
                            	  1641: .0001:
02:00005E2A 760A            	  1642: 	moveq		#10,d3
                            	  1643: kbdi0002:
02:00005E2C 61000420        	  1644: 	bsr			Wait10ms
02:00005E30 4239FD0FFE01    	  1645: 	clr.b		KEYBD+1				; clear receive register (write $00 to status reg)
02:00005E36 6100A300        	  1646: 	bsr net_delay
02:00005E3A 72FF            	  1647: 	moveq		#-1,d1				; send reset code to keyboard
02:00005E3C 13C1FD0FFE01    	  1648: 	move.b	d1,KEYBD+1		; write $FF to status reg to clear TX state
02:00005E42 6100A2F4        	  1649: 	bsr net_delay
02:00005E46 610003FC        	  1650: 	bsr			KeybdSendByte	; now write ($FF) to transmit register for reset
02:00005E4A 61000102        	  1651: 	bsr			KeybdWaitTx		; wait until no longer busy
02:00005E4E 4A81            	  1652: 	tst.l		d1
02:00005E50 6B000086        	  1653: 	bmi			kbdiXmitBusy
02:00005E54 610000D8        	  1654: 	bsr			KeybdRecvByte	; look for an ACK ($FA)
02:00005E58 0C0100FA        	  1655: 	cmpi.b	#$FA,d1
02:00005E5C 6604            	  1656: 	bne			.0001
02:00005E5E 610000CE        	  1657: 	bsr			KeybdRecvByte	; look for BAT completion code ($AA)
                            	  1658: .0001:
02:00005E62 0C0100FC        	  1659: 	cmpi.b	#$FC,d1				; reset error ?
02:00005E66 672E            	  1660: 	beq			kbdiTryAgain
02:00005E68 0C0100AA        	  1661: 	cmpi.b	#$AA,d1				; reset complete okay ?
02:00005E6C 6628            	  1662: 	bne			kbdiTryAgain
                            	  1663: 
                            	  1664: 	; After a reset, scan code set #2 should be active
                            	  1665: .config:
02:00005E6E 323C00F0        	  1666: 	move.w	#$F0,d1			; send scan code select
02:00005E72 13C1FD0FFF00    	  1667: 	move.b	d1,leds
02:00005E78 6100A2BE        	  1668: 	bsr net_delay
02:00005E7C 610003C6        	  1669: 	bsr			KeybdSendByte
02:00005E80 610000CC        	  1670: 	bsr			KeybdWaitTx
02:00005E84 4A81            	  1671: 	tst.l		d1
02:00005E86 6B50            	  1672: 	bmi			kbdiXmitBusy
02:00005E88 610000A4        	  1673: 	bsr			KeybdRecvByte	; wait for response from keyboard
02:00005E8C 4A41            	  1674: 	tst.w		d1
02:00005E8E 6B06            	  1675: 	bmi			kbdiTryAgain
02:00005E90 0C0100FA        	  1676: 	cmpi.b	#$FA,d1				; ACK
02:00005E94 670E            	  1677: 	beq			kbdi0004
                            	  1678: kbdiTryAgain:
02:00005E96 51CBFF94        	  1679: 	dbra		d3,kbdi0002
                            	  1680: .keybdErr:
02:00005E9A 43FA004A        	  1681: 	lea			msgBadKeybd,a1
02:00005E9E 6100FD04        	  1682: 	bsr			DisplayStringCRLF
02:00005EA2 601E            	  1683: 	bra			ledxit
                            	  1684: kbdi0004:
02:00005EA4 7202            	  1685: 	moveq		#2,d1			; select scan code set #2
02:00005EA6 6100039C        	  1686: 	bsr			KeybdSendByte
02:00005EAA 610000A2        	  1687: 	bsr			KeybdWaitTx
02:00005EAE 4A81            	  1688: 	tst.l		d1
02:00005EB0 6B26            	  1689: 	bmi			kbdiXmitBusy
02:00005EB2 617A            	  1690: 	bsr			KeybdRecvByte	; wait for response from keyboard
02:00005EB4 4A41            	  1691: 	tst.w		d1
02:00005EB6 6BDE            	  1692: 	bmi			kbdiTryAgain
02:00005EB8 0C0100FA        	  1693: 	cmpi.b	#$FA,d1
02:00005EBC 66D8            	  1694: 	bne			kbdiTryAgain
                            	  1695: kbdi0005:
02:00005EBE 6100FEDA        	  1696: 	bsr			KeybdGetID
                            	  1697: ledxit:
02:00005EC2 7207            	  1698: 	moveq		#$07,d1
02:00005EC4 6100FF12        	  1699: 	bsr			KeybdSetLED
02:00005EC8 610003A0        	  1700: 	bsr			Wait300ms
02:00005ECC 7200            	  1701: 	moveq		#$00,d1
02:00005ECE 6100FF08        	  1702: 	bsr			KeybdSetLED
02:00005ED2 4CDF020B        	  1703: 	movem.l	(a7)+,d0/d1/d3/a1
02:00005ED6 4E75            	  1704: 	rts
                            	  1705: kbdiXmitBusy:
02:00005ED8 43FA001B        	  1706: 	lea			msgXmitBusy,a1
02:00005EDC 6100FCC6        	  1707: 	bsr			DisplayStringCRLF
02:00005EE0 4CDF020B        	  1708: 	movem.l	(a7)+,d0/d1/d3/a1
02:00005EE4 4E75            	  1709: 	rts
                            	  1710: 	
                            	  1711: msgBadKeybd:
02:00005EE6 4B6579626F617264	  1712: 	dc.b		"Keyboard error",0
02:00005EEE 206572726F72
02:00005EF4 00
                            	  1713: msgXmitBusy:
02:00005EF5 4B6579626F617264	  1714: 	dc.b		"Keyboard transmitter stuck",0
02:00005EFD 207472616E736D69
02:00005F05 7474657220737475
02:00005F0D 636B
02:00005F0F 00
                            	  1715: 
                            	  1716: 	even
                            	  1717: _KeybdGetStatus:
02:00005F10 7200            	  1718: 	moveq		#0,d1
02:00005F12 1239FD0FFE01    	  1719: 	move.b	KEYBD+1,d1
02:00005F18 6000A21E        	  1720: 	bra net_delay
                            	  1721: 
                            	  1722: ; Get the scancode from the keyboard port
                            	  1723: 
                            	  1724: _KeybdGetScancode:
02:00005F1C 7200            	  1725: 	moveq		#0,d1
02:00005F1E 1239FD0FFE00    	  1726: 	move.b	KEYBD,d1				; get the scan code
02:00005F24 4239FD0FFE01    	  1727: 	move.b	#0,KEYBD+1			; clear receive register
02:00005F2A 6000A20C        	  1728: 	bra net_delay
                            	  1729: 
                            	  1730: ; Recieve a byte from the keyboard, used after a command is sent to the
                            	  1731: ; keyboard in order to wait for a response.
                            	  1732: ;
                            	  1733: KeybdRecvByte:
02:00005F2E 2F03            	  1734: 	move.l	d3,-(a7)
02:00005F30 363C0064        	  1735: 	move.w	#100,d3		; wait up to 1s
                            	  1736: .0003:
02:00005F34 61DA            	  1737: 	bsr			_KeybdGetStatus	; wait for response from keyboard
02:00005F36 4A01            	  1738: 	tst.b		d1
02:00005F38 6B0E            	  1739: 	bmi			.0004			; is input buffer full ? yes, branch
02:00005F3A 61000312        	  1740: 	bsr			Wait10ms	; wait a bit
02:00005F3E 51CBFFF4        	  1741: 	dbra		d3,.0003	; go back and try again
02:00005F42 261F            	  1742: 	move.l	(a7)+,d3
02:00005F44 72FF            	  1743: 	moveq		#-1,d1		; return -1
02:00005F46 4E75            	  1744: 	rts
                            	  1745: .0004:
02:00005F48 61D2            	  1746: 	bsr			_KeybdGetScancode
02:00005F4A 261F            	  1747: 	move.l	(a7)+,d3
02:00005F4C 4E75            	  1748: 	rts
                            	  1749: 
                            	  1750: 
                            	  1751: ; Wait until the keyboard transmit is complete
                            	  1752: ; Returns -1 if timedout, 0 if transmit completed
                            	  1753: ;
                            	  1754: KeybdWaitTx:
02:00005F4E 48E73000        	  1755: 	movem.l	d2/d3,-(a7)
02:00005F52 7664            	  1756: 	moveq		#100,d3		; wait a max of 1s
                            	  1757: .0001:
02:00005F54 61BA            	  1758: 	bsr			_KeybdGetStatus
02:00005F56 08010006        	  1759: 	btst		#6,d1				; check for transmit complete bit
02:00005F5A 6610            	  1760: 	bne	    .0002				; branch if bit set
02:00005F5C 610002F0        	  1761: 	bsr			Wait10ms		; delay a little bit
02:00005F60 51CBFFF2        	  1762: 	dbra		d3,.0001		; go back and try again
02:00005F64 4CDF000C        	  1763: 	movem.l	(a7)+,d2/d3
02:00005F68 72FF            	  1764: 	moveq		#-1,d1			; return -1
02:00005F6A 4E75            	  1765: 	rts
                            	  1766: .0002:
02:00005F6C 4CDF000C        	  1767: 	movem.l	(a7)+,d2/d3
02:00005F70 7200            	  1768: 	moveq	#0,d1		; return 0
02:00005F72 4E75            	  1769: 	rts
                            	  1770: 
                            	  1771: ;------------------------------------------------------------------------------
                            	  1772: ; d1.b 0=echo off, non-zero = echo on
                            	  1773: ;------------------------------------------------------------------------------
                            	  1774: 
                            	  1775: SetKeyboardEcho:
02:00005F74 13C10004000C    	  1776: 	move.b	d1,KeybdEcho
02:00005F7A 4E75            	  1777: 	rts
                            	  1778: 
                            	  1779: ;------------------------------------------------------------------------------
                            	  1780: ; Get key pending status into d1.b
                            	  1781: ;
                            	  1782: ; Returns:
                            	  1783: ;		d1.b = 1 if a key is available, otherwise zero.
                            	  1784: ;------------------------------------------------------------------------------
                            	  1785: 
                            	  1786: CheckForKey:
02:00005F7C 7200            	  1787: 	moveq.l	#0,d1					; clear high order bits
                            	  1788: ;	move.b	KEYBD+1,d1		; get keyboard port status
                            	  1789: ;	smi.b		d1						; set true/false
                            	  1790: ;	andi.b	#1,d1					; return true (1) if key available, 0 otherwise
02:00005F7E 4A3900100013    	  1791: 	tst.b		_KeybdCnt
02:00005F84 56C1            	  1792: 	sne.b		d1
02:00005F86 4E75            	  1793: 	rts
                            	  1794: 
                            	  1795: ;------------------------------------------------------------------------------
                            	  1796: ; GetKey
                            	  1797: ; 	Get a character from the keyboard. 
                            	  1798: ;
                            	  1799: ; Modifies:
                            	  1800: ;		d1
                            	  1801: ; Returns:
                            	  1802: ;		d1 = -1 if no key available or not in focus, otherwise key
                            	  1803: ;------------------------------------------------------------------------------
                            	  1804: 
                            	  1805: GetKey:
02:00005F88 2F00            	  1806: 	move.l	d0,-(a7)					; push d0
02:00005F8A 123900100000    	  1807: 	move.b	IOFocus,d1				; Check if the core has the IO focus
02:00005F90 4E7A0FE0        	  1808: 	movec.l	coreno,d0
02:00005F94 B200            	  1809: 	cmp.b		d0,d1
02:00005F96 6622            	  1810: 	bne.s		.0004							; go return no key available, if not in focus
02:00005F98 6132            	  1811: 	bsr			KeybdGetCharNoWait	; get a character
02:00005F9A 4A81            	  1812: 	tst.l		d1						; was a key available?
02:00005F9C 6B1C            	  1813: 	bmi.s		.0004
02:00005F9E 4A390004000C    	  1814: 	tst.b		KeybdEcho					; is keyboard echo on ?
02:00005FA4 6710            	  1815: 	beq.s		.0003							; no echo, just return the key
02:00005FA6 0C01000D        	  1816: 	cmpi.b	#CR,d1						; convert CR keystroke into CRLF
02:00005FAA 6606            	  1817: 	bne.s		.0005
02:00005FAC 6100F8E8        	  1818: 	bsr			CRLF
02:00005FB0 6004            	  1819: 	bra.s		.0003
                            	  1820: .0005:
02:00005FB2 6100F92C        	  1821: 	bsr			DisplayChar
                            	  1822: .0003:
02:00005FB6 201F            	  1823: 	move.l	(a7)+,d0					; pop d0
02:00005FB8 4E75            	  1824: 	rts												; return key
                            	  1825: ; Return -1 indicating no char was available
                            	  1826: .0004:
02:00005FBA 201F            	  1827: 	move.l	(a7)+,d0					; pop d0
02:00005FBC 72FF            	  1828: 	moveq		#-1,d1						; return no key available
02:00005FBE 4E75            	  1829: 	rts
                            	  1830: 
                            	  1831: CheckForCtrlC:
02:00005FC0 610A            	  1832: 	bsr			KeybdGetCharNoWait
02:00005FC2 0C010003        	  1833: 	cmpi.b	#CTRLC,d1
02:00005FC6 670006D0        	  1834: 	beq			Monitor
02:00005FCA 4E75            	  1835: 	rts
                            	  1836: 
                            	  1837: ;------------------------------------------------------------------------------
                            	  1838: ;------------------------------------------------------------------------------
                            	  1839: 
                            	  1840: KeybdGetCharNoWait:
02:00005FCC 42390004000D    	  1841: 	clr.b	KeybdWaitFlag
02:00005FD2 6008            	  1842: 	bra		KeybdGetChar
                            	  1843: 
                            	  1844: KeybdGetCharWait:
02:00005FD4 13FC00FF0004000D	  1845: 	move.b	#-1,KeybdWaitFlag
                            	  1846: 
                            	  1847: KeybdGetChar:
02:00005FDC 48E7B080        	  1848: 	movem.l	d0/d2/d3/a0,-(a7)
                            	  1849: .0003:
02:00005FE0 4E7A0FE0        	  1850: 	movec		coreno,d0
02:00005FE4 4840            	  1851: 	swap		d0
02:00005FE6 7203            	  1852: 	moveq		#KEYBD_SEMA,d1
02:00005FE8 6100A26E        	  1853: 	bsr			LockSemaphore
02:00005FEC 143900100013    	  1854: 	move.b	_KeybdCnt,d2		; get count of buffered scan codes
02:00005FF2 673E            	  1855: 	beq.s		.0015						;
02:00005FF4 143900100011    	  1856: 	move.b	_KeybdHead,d2		; d2 = buffer head
02:00005FFA 4882            	  1857: 	ext.w		d2
02:00005FFC 41F900100020    	  1858: 	lea			_KeybdBuf,a0		; a0 = pointer to keyboard buffer
02:00006002 7200            	  1859: 	clr.l		d1
02:00006004 12302000        	  1860: 	move.b	(a0,d2.w),d1		; d1 = scan code from buffer
02:00006008 5202            	  1861: 	addi.b	#1,d2						; increment keyboard head index
02:0000600A 0202001F        	  1862: 	andi.b	#31,d2					; and wrap around at buffer size
02:0000600E 13C200100011    	  1863: 	move.b	d2,_KeybdHead
02:00006014 533900100013    	  1864: 	subi.b	#1,_KeybdCnt		; decrement count of scan codes in buffer
02:0000601A C342            	  1865: 	exg			d1,d2						; save scancode value in d2
02:0000601C 4E7A0FE0        	  1866: 	movec		coreno,d0
02:00006020 4840            	  1867: 	swap		d0
02:00006022 7203            	  1868: 	moveq		#KEYBD_SEMA,d1
02:00006024 6100A26E        	  1869: 	bsr			UnlockSemaphore
02:00006028 C541            	  1870: 	exg			d2,d1						; restore scancode value
02:0000602A 6026            	  1871: 	bra			.0001						; go process scan code
                            	  1872: .0014:
02:0000602C 6100FEE2        	  1873: 	bsr		_KeybdGetStatus		; check keyboard status for key available
02:00006030 6B1C            	  1874: 	bmi		.0006							; yes, go process
                            	  1875: .0015:
02:00006032 4E7A0FE0        	  1876: 	movec		coreno,d0
02:00006036 4840            	  1877: 	swap		d0
02:00006038 7203            	  1878: 	moveq		#KEYBD_SEMA,d1
02:0000603A 6100A258        	  1879: 	bsr			UnlockSemaphore
02:0000603E 4A390004000D    	  1880: 	tst.b		KeybdWaitFlag			; are we willing to wait for a key ?
02:00006044 6B9A            	  1881: 	bmi			.0003							; yes, branch back
02:00006046 4CDF010D        	  1882: 	movem.l	(a7)+,d0/d2/d3/a0
02:0000604A 72FF            	  1883: 	moveq		#-1,d1						; flag no char available
02:0000604C 4E75            	  1884: 	rts
                            	  1885: .0006:
02:0000604E 6100FECC        	  1886: 	bsr		_KeybdGetScancode
                            	  1887: .0001:
02:00006052 33FC0001FD0FFF00	  1888: 	move.w	#1,leds
02:0000605A B23C00F0        	  1889: 	cmp.b	#SC_KEYUP,d1
02:0000605E 670000C0        	  1890: 	beq		.doKeyup
02:00006062 B23C00E0        	  1891: 	cmp.b	#SC_EXTEND,d1
02:00006066 670000C4        	  1892: 	beq		.doExtend
02:0000606A B23C0014        	  1893: 	cmp.b	#SC_CTRL,d1
02:0000606E 670000C8        	  1894: 	beq		.doCtrl
02:00006072 B23C0012        	  1895: 	cmp.b	#SC_LSHIFT,d1
02:00006076 6700012A        	  1896: 	beq		.doShift
02:0000607A B23C0059        	  1897: 	cmp.b	#SC_RSHIFT,d1
02:0000607E 67000122        	  1898: 	beq		.doShift
02:00006082 B23C0077        	  1899: 	cmp.b	#SC_NUMLOCK,d1
02:00006086 67000142        	  1900: 	beq		.doNumLock
02:0000608A B23C0058        	  1901: 	cmp.b	#SC_CAPSLOCK,d1
02:0000608E 67000148        	  1902: 	beq		.doCapsLock
02:00006092 B23C007E        	  1903: 	cmp.b	#SC_SCROLLLOCK,d1
02:00006096 6700014E        	  1904: 	beq		.doScrollLock
02:0000609A B23C0011        	  1905: 	cmp.b   #SC_ALT,d1
02:0000609E 670000C0        	  1906: 	beq     .doAlt
02:000060A2 14390010000F    	  1907: 	move.b	_KeyState1,d2			; check key up/down
02:000060A8 42390010000F    	  1908: 	move.b	#0,_KeyState1			; clear keyup status
02:000060AE 4A02            	  1909: 	tst.b	d2
02:000060B0 6600FF2E        	  1910: 	bne	    .0003					; ignore key up
02:000060B4 B23C000D        	  1911: 	cmp.b   #SC_TAB,d1
02:000060B8 670000CE        	  1912: 	beq     .doTab
                            	  1913: .0013:
02:000060BC 143900100010    	  1914: 	move.b	_KeyState2,d2
02:000060C2 6A1A            	  1915: 	bpl		.0010					; is it extended code ?
02:000060C4 C43C007F        	  1916: 	and.b	#$7F,d2					; clear extended bit
02:000060C8 13C200100010    	  1917: 	move.b	d2,_KeyState2
02:000060CE 42390010000F    	  1918: 	move.b	#0,_KeyState1			; clear keyup
02:000060D4 41FA04C8        	  1919: 	lea		_keybdExtendedCodes,a0
02:000060D8 12301000        	  1920: 	move.b	(a0,d1.w),d1
02:000060DC 6034            	  1921: 	bra		.0008
                            	  1922: .0010:
02:000060DE 08020002        	  1923: 	btst	#2,d2					; is it CTRL code ?
02:000060E2 670E            	  1924: 	beq		.0009
02:000060E4 C27C007F        	  1925: 	and.w	#$7F,d1
02:000060E8 41FA0434        	  1926: 	lea		_keybdControlCodes,a0
02:000060EC 12301000        	  1927: 	move.b	(a0,d1.w),d1
02:000060F0 6020            	  1928: 	bra		.0008
                            	  1929: .0009:
02:000060F2 08020000        	  1930: 	btst	#0,d2					; is it shift down ?
02:000060F6 670A            	  1931: 	beq  	.0007
02:000060F8 41FA0324        	  1932: 	lea		_shiftedScanCodes,a0
02:000060FC 12301000        	  1933: 	move.b	(a0,d1.w),d1
02:00006100 6010            	  1934: 	bra		.0008
                            	  1935: .0007:
02:00006102 41FA021A        	  1936: 	lea		_unshiftedScanCodes,a0
02:00006106 12301000        	  1937: 	move.b	(a0,d1.w),d1
02:0000610A 33FC0202FD0FFF00	  1938: 	move.w	#$0202,leds
                            	  1939: .0008:
02:00006112 33FC0303FD0FFF00	  1940: 	move.w	#$0303,leds
02:0000611A 4CDF010D        	  1941: 	movem.l	(a7)+,d0/d2/d3/a0
02:0000611E 4E75            	  1942: 	rts
                            	  1943: .doKeyup:
02:00006120 13FC00FF0010000F	  1944: 	move.b	#-1,_KeyState1
02:00006128 6000FEB6        	  1945: 	bra		.0003
                            	  1946: .doExtend:
02:0000612C 0039008000100010	  1947: 	or.b	#$80,_KeyState2
02:00006134 6000FEAA        	  1948: 	bra		.0003
                            	  1949: .doCtrl:
02:00006138 12390010000F    	  1950: 	move.b	_KeyState1,d1
02:0000613E 42390010000F    	  1951: 	clr.b	_KeyState1
02:00006144 4A01            	  1952: 	tst.b	d1
02:00006146 6A0C            	  1953: 	bpl.s	.0004
02:00006148 08B9000200100010	  1954: 	bclr	#2,_KeyState2
02:00006150 6000FE8E        	  1955: 	bra		.0003
                            	  1956: .0004:
02:00006154 08F9000200100010	  1957: 	bset	#2,_KeyState2
02:0000615C 6000FE82        	  1958: 	bra		.0003
                            	  1959: .doAlt:
02:00006160 12390010000F    	  1960: 	move.b	_KeyState1,d1
02:00006166 42390010000F    	  1961: 	clr.b	_KeyState1
02:0000616C 4A01            	  1962: 	tst.b	d1
02:0000616E 6A0C            	  1963: 	bpl		.0011
02:00006170 08B9000100100010	  1964: 	bclr	#1,_KeyState2
02:00006178 6000FE66        	  1965: 	bra		.0003
                            	  1966: .0011:
02:0000617C 08F9000100100010	  1967: 	bset	#1,_KeyState2
02:00006184 6000FE5A        	  1968: 	bra		.0003
                            	  1969: .doTab:
02:00006188 2F01            	  1970: 	move.l	d1,-(a7)
02:0000618A 123900100010    	  1971:   move.b  _KeyState2,d1
02:00006190 08010001        	  1972:   btst	#1,d1                 ; is ALT down ?
02:00006194 6706            	  1973:   beq     .0012
                            	  1974: ;    	inc     _iof_switch
02:00006196 221F            	  1975:   move.l	(a7)+,d1
02:00006198 6000FE46        	  1976:   bra     .0003
                            	  1977: .0012:
02:0000619C 221F            	  1978:   move.l	(a7)+,d1
02:0000619E 6000FF1C        	  1979:   bra     .0013
                            	  1980: .doShift:
02:000061A2 12390010000F    	  1981: 	move.b	_KeyState1,d1
02:000061A8 42390010000F    	  1982: 	clr.b	_KeyState1
02:000061AE 4A01            	  1983: 	tst.b	d1
02:000061B0 6A0C            	  1984: 	bpl.s	.0005
02:000061B2 08B9000000100010	  1985: 	bclr	#0,_KeyState2
02:000061BA 6000FE24        	  1986: 	bra		.0003
                            	  1987: .0005:
02:000061BE 08F9000000100010	  1988: 	bset	#0,_KeyState2
02:000061C6 6000FE18        	  1989: 	bra		.0003
                            	  1990: .doNumLock:
02:000061CA 0879000400100010	  1991: 	bchg	#4,_KeyState2
02:000061D2 6120            	  1992: 	bsr		KeybdSetLEDStatus
02:000061D4 6000FE0A        	  1993: 	bra		.0003
                            	  1994: .doCapsLock:
02:000061D8 0879000500100010	  1995: 	bchg	#5,_KeyState2
02:000061E0 6112            	  1996: 	bsr		KeybdSetLEDStatus
02:000061E2 6000FDFC        	  1997: 	bra		.0003
                            	  1998: .doScrollLock:
02:000061E6 0879000600100010	  1999: 	bchg	#6,_KeyState2
02:000061EE 6104            	  2000: 	bsr		KeybdSetLEDStatus
02:000061F0 6000FDEE        	  2001: 	bra		.0003
                            	  2002: 
                            	  2003: KeybdSetLEDStatus:
02:000061F4 48E73000        	  2004: 	movem.l	d2/d3,-(a7)
02:000061F8 42390010000E    	  2005: 	clr.b		KeybdLEDs
02:000061FE 0839000400100010	  2006: 	btst		#4,_KeyState2
02:00006206 6708            	  2007: 	beq.s		.0002
02:00006208 13FC00020010000E	  2008: 	move.b	#2,KeybdLEDs
                            	  2009: .0002:
02:00006210 0839000500100010	  2010: 	btst		#5,_KeyState2
02:00006218 6708            	  2011: 	beq.s		.0003
02:0000621A 08F900020010000E	  2012: 	bset		#2,KeybdLEDs
                            	  2013: .0003:
02:00006222 0839000600100010	  2014: 	btst		#6,_KeyState2
02:0000622A 6708            	  2015: 	beq.s		.0004
02:0000622C 08F900000010000E	  2016: 	bset		#0,KeybdLEDs
                            	  2017: .0004:
02:00006234 12390010000E    	  2018: 	move.b	KeybdLEDs,d1
02:0000623A 6100FB9C        	  2019: 	bsr			KeybdSetLED
02:0000623E 4CDF000C        	  2020: 	movem.l	(a7)+,d2/d3
02:00006242 4E75            	  2021: 	rts
                            	  2022: 
                            	  2023: KeybdSendByte:
02:00006244 13C1FD0FFE00    	  2024: 	move.b	d1,KEYBD
02:0000624A 60009EEC        	  2025: 	bra net_delay
                            	  2026: 	
                            	  2027: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2028: ; Wait for 10 ms
                            	  2029: ;
                            	  2030: ; Parameters: none
                            	  2031: ; Returns: none
                            	  2032: ; Modifies: none
                            	  2033: ; Stack Space: 2 long words
                            	  2034: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2035: 
                            	  2036: Wait10ms:
02:0000624E 48E7C000        	  2037: 	movem.l	d0/d1,-(a7)
02:00006252 4E7A0FF0        	  2038: 	movec		tick,d0
02:00006256 068000061A80    	  2039: 	addi.l	#400000,d0			; 400,000 cycles at 40MHz
                            	  2040: .0001:
02:0000625C 4E7A1FF0        	  2041: 	movec		tick,d1
02:00006260 B081            	  2042: 	cmp.l		d1,d0
02:00006262 62F8            	  2043: 	bhi			.0001
02:00006264 4CDF0003        	  2044: 	movem.l	(a7)+,d0/d1
02:00006268 4E75            	  2045: 	rts
                            	  2046: 
                            	  2047: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2048: ; Wait for 300 ms
                            	  2049: ;
                            	  2050: ; Parameters: none
                            	  2051: ; Returns: none
                            	  2052: ; Modifies: none
                            	  2053: ; Stack Space: 2 long words
                            	  2054: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2055: 
                            	  2056: Wait300ms:
02:0000626A 48E7C000        	  2057: 	movem.l	d0/d1,-(a7)
02:0000626E 4E7A0FF0        	  2058: 	movec		tick,d0
02:00006272 068000B71B00    	  2059: 	addi.l	#12000000,d0			; 12,000,000 cycles at 40MHz
                            	  2060: .0001:
02:00006278 4E7A1FF0        	  2061: 	movec		tick,d1
02:0000627C B081            	  2062: 	cmp.l		d1,d0
02:0000627E 62F8            	  2063: 	bhi			.0001
02:00006280 4CDF0003        	  2064: 	movem.l	(a7)+,d0/d1
02:00006284 4E75            	  2065: 	rts
                            	  2066: 
                            	  2067: ;--------------------------------------------------------------------------
                            	  2068: ; Keyboard IRQ routine.
                            	  2069: ;
                            	  2070: ; Returns:
                            	  2071: ; 	d1 = -1 if keyboard routine handled interrupt, otherwise positive.
                            	  2072: ;--------------------------------------------------------------------------
                            	  2073: 
                            	  2074: KeybdIRQ:
02:00006286 46FC2600        	  2075: 	move.w	#$2600,sr					; disable lower interrupts
02:0000628A 48E7C080        	  2076: 	movem.l	d0/d1/a0,-(a7)
02:0000628E 6100FC80        	  2077: 	bsr			_KeybdGetStatus		; check if keyboard
02:00006292 4A01            	  2078: 	tst.b		d1
02:00006294 6A000082        	  2079: 	bpl			.0001							; branch if not keyboard
02:00006298 4E7A0FE0        	  2080: 	movec		coreno,d0
02:0000629C 4840            	  2081: 	swap		d0
02:0000629E 7203            	  2082: 	moveq		#KEYBD_SEMA,d1
02:000062A0 61009FB6        	  2083: 	bsr			LockSemaphore
02:000062A4 0839000100100010	  2084: 	btst		#1,_KeyState2			; Is Alt down?
02:000062AC 672C            	  2085: 	beq.s		.0003
02:000062AE 1039FD0FFE00    	  2086: 	move.b	KEYBD,d0					; get scan code
02:000062B4 61009E82        	  2087: 	bsr net_delay
02:000062B8 0C00000D        	  2088: 	cmpi.b	#SC_TAB,d0				; is Alt-Tab?
02:000062BC 661C            	  2089: 	bne.s		.0003
02:000062BE 6100FC5C        	  2090: 	bsr			_KeybdGetScancode	; grab the scan code (clears interrupt)
02:000062C2 6100FA6C        	  2091: 	bsr			rotate_iofocus
02:000062C6 423900100011    	  2092: 	clr.b		_KeybdHead				; clear keyboard buffer
02:000062CC 423900100012    	  2093: 	clr.b		_KeybdTail
02:000062D2 423900100013    	  2094: 	clr.b		_KeybdCnt
02:000062D8 6032            	  2095: 	bra			.0002							; do not store Alt-Tab
                            	  2096: .0003:
                            	  2097: 	; Insert keyboard scan code into raw keyboard buffer
02:000062DA 6100FC40        	  2098: 	bsr			_KeybdGetScancode	; grab the scan code (clears interrupt)
02:000062DE 0C39002000100013	  2099: 	cmpi.b	#32,_KeybdCnt			; see if keyboard buffer full
02:000062E6 6424            	  2100: 	bhs.s		.0002
02:000062E8 103900100012    	  2101: 	move.b	_KeybdTail,d0			; keyboard buffer not full, add to tail
02:000062EE 4880            	  2102: 	ext.w		d0
02:000062F0 41F900100020    	  2103: 	lea			_KeybdBuf,a0			; a0 = pointer to buffer
02:000062F6 11810000        	  2104: 	move.b	d1,(a0,d0.w)			; put scancode in buffer
02:000062FA 5200            	  2105: 	addi.b	#1,d0							; increment tail index
02:000062FC 0200001F        	  2106: 	andi.b	#31,d0						; wrap at buffer limit
02:00006300 13C000100012    	  2107: 	move.b	d0,_KeybdTail			; update tail index
02:00006306 523900100013    	  2108: 	addi.b	#1,_KeybdCnt			; increment buffer count
                            	  2109: .0002:
02:0000630C 4E7A0FE0        	  2110: 	movec		coreno,d0
02:00006310 4840            	  2111: 	swap		d0
02:00006312 7203            	  2112: 	moveq		#KEYBD_SEMA,d1
02:00006314 61009F7E        	  2113: 	bsr			UnlockSemaphore
                            	  2114: .0001:
02:00006318 4CDF0103        	  2115: 	movem.l	(a7)+,d0/d1/a0		; return
02:0000631C 4E73            	  2116: 	rte
                            	  2117: 
                            	  2118: ;--------------------------------------------------------------------------
                            	  2119: ; PS2 scan codes to ascii conversion tables.
                            	  2120: ;--------------------------------------------------------------------------
                            	  2121: ;
                            	  2122: _unshiftedScanCodes:
02:0000631E 2E              	  2123: 	dc.b	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
02:0000631F A9
02:00006320 2E
02:00006321 A5
02:00006322 A3
02:00006323 A1
02:00006324 A2
02:00006325 AC
02:00006326 2E              	  2124: 	dc.b	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
02:00006327 AA
02:00006328 A8
02:00006329 A6
02:0000632A A4
02:0000632B 09
02:0000632C 60
02:0000632D 2E
02:0000632E 2E              	  2125: 	dc.b	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
02:0000632F 2E
02:00006330 2E
02:00006331 2E
02:00006332 2E
02:00006333 71
02:00006334 31
02:00006335 2E
02:00006336 2E              	  2126: 	dc.b	$2e,$2e,$7a,$73,$61,$77,$32,$2e
02:00006337 2E
02:00006338 7A
02:00006339 73
02:0000633A 61
02:0000633B 77
02:0000633C 32
02:0000633D 2E
02:0000633E 2E              	  2127: 	dc.b	$2e,$63,$78,$64,$65,$34,$33,$2e
02:0000633F 63
02:00006340 78
02:00006341 64
02:00006342 65
02:00006343 34
02:00006344 33
02:00006345 2E
02:00006346 2E              	  2128: 	dc.b	$2e,$20,$76,$66,$74,$72,$35,$2e
02:00006347 20
02:00006348 76
02:00006349 66
02:0000634A 74
02:0000634B 72
02:0000634C 35
02:0000634D 2E
02:0000634E 2E              	  2129: 	dc.b	$2e,$6e,$62,$68,$67,$79,$36,$2e
02:0000634F 6E
02:00006350 62
02:00006351 68
02:00006352 67
02:00006353 79
02:00006354 36
02:00006355 2E
02:00006356 2E              	  2130: 	dc.b	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
02:00006357 2E
02:00006358 6D
02:00006359 6A
02:0000635A 75
02:0000635B 37
02:0000635C 38
02:0000635D 2E
02:0000635E 2E              	  2131: 	dc.b	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
02:0000635F 2C
02:00006360 6B
02:00006361 69
02:00006362 6F
02:00006363 30
02:00006364 39
02:00006365 2E
02:00006366 2E              	  2132: 	dc.b	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
02:00006367 2E
02:00006368 2F
02:00006369 6C
02:0000636A 3B
02:0000636B 70
02:0000636C 2D
02:0000636D 2E
02:0000636E 2E              	  2133: 	dc.b	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
02:0000636F 2E
02:00006370 27
02:00006371 2E
02:00006372 5B
02:00006373 3D
02:00006374 2E
02:00006375 2E
02:00006376 AD              	  2134: 	dc.b	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
02:00006377 2E
02:00006378 0D
02:00006379 5D
02:0000637A 2E
02:0000637B 5C
02:0000637C 2E
02:0000637D 2E
02:0000637E 2E              	  2135: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
02:0000637F 2E
02:00006380 2E
02:00006381 2E
02:00006382 2E
02:00006383 2E
02:00006384 08
02:00006385 2E
02:00006386 2E              	  2136: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
02:00006387 95
02:00006388 2E
02:00006389 93
02:0000638A 94
02:0000638B 2E
02:0000638C 2E
02:0000638D 2E
02:0000638E 98              	  2137: 	dc.b	$98,$7f,$92,$2e,$91,$90,$1b,$af
02:0000638F 7F
02:00006390 92
02:00006391 2E
02:00006392 91
02:00006393 90
02:00006394 1B
02:00006395 AF
02:00006396 AB              	  2138: 	dc.b	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
02:00006397 2E
02:00006398 97
02:00006399 2E
02:0000639A 2E
02:0000639B 96
02:0000639C AE
02:0000639D 2E
                            	  2139: 
02:0000639E 2E              	  2140: 	dc.b	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
02:0000639F 2E
02:000063A0 2E
02:000063A1 A7
02:000063A2 2E
02:000063A3 2E
02:000063A4 2E
02:000063A5 2E
02:000063A6 2E              	  2141: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063A7 2E
02:000063A8 2E
02:000063A9 2E
02:000063AA 2E
02:000063AB 2E
02:000063AC 2E
02:000063AD 2E
02:000063AE 2E              	  2142: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063AF 2E
02:000063B0 2E
02:000063B1 2E
02:000063B2 2E
02:000063B3 2E
02:000063B4 2E
02:000063B5 2E
02:000063B6 2E              	  2143: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063B7 2E
02:000063B8 2E
02:000063B9 2E
02:000063BA 2E
02:000063BB 2E
02:000063BC 2E
02:000063BD 2E
02:000063BE 2E              	  2144: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063BF 2E
02:000063C0 2E
02:000063C1 2E
02:000063C2 2E
02:000063C3 2E
02:000063C4 2E
02:000063C5 2E
02:000063C6 2E              	  2145: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063C7 2E
02:000063C8 2E
02:000063C9 2E
02:000063CA 2E
02:000063CB 2E
02:000063CC 2E
02:000063CD 2E
02:000063CE 2E              	  2146: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063CF 2E
02:000063D0 2E
02:000063D1 2E
02:000063D2 2E
02:000063D3 2E
02:000063D4 2E
02:000063D5 2E
02:000063D6 2E              	  2147: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063D7 2E
02:000063D8 2E
02:000063D9 2E
02:000063DA 2E
02:000063DB 2E
02:000063DC 2E
02:000063DD 2E
02:000063DE 2E              	  2148: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063DF 2E
02:000063E0 2E
02:000063E1 2E
02:000063E2 2E
02:000063E3 2E
02:000063E4 2E
02:000063E5 2E
02:000063E6 2E              	  2149: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063E7 2E
02:000063E8 2E
02:000063E9 2E
02:000063EA 2E
02:000063EB 2E
02:000063EC 2E
02:000063ED 2E
02:000063EE 2E              	  2150: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063EF 2E
02:000063F0 2E
02:000063F1 2E
02:000063F2 2E
02:000063F3 2E
02:000063F4 2E
02:000063F5 2E
02:000063F6 2E              	  2151: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063F7 2E
02:000063F8 2E
02:000063F9 2E
02:000063FA 2E
02:000063FB 2E
02:000063FC 2E
02:000063FD 2E
02:000063FE 2E              	  2152: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000063FF 2E
02:00006400 2E
02:00006401 2E
02:00006402 2E
02:00006403 2E
02:00006404 2E
02:00006405 2E
02:00006406 2E              	  2153: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00006407 2E
02:00006408 2E
02:00006409 2E
02:0000640A 2E
02:0000640B 2E
02:0000640C 2E
02:0000640D 2E
02:0000640E 2E              	  2154: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:0000640F 2E
02:00006410 2E
02:00006411 2E
02:00006412 2E
02:00006413 2E
02:00006414 2E
02:00006415 2E
02:00006416 2E              	  2155: 	dc.b	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
02:00006417 2E
02:00006418 FA
02:00006419 2E
02:0000641A 2E
02:0000641B 2E
02:0000641C 2E
02:0000641D 2E
                            	  2156: 
                            	  2157: _shiftedScanCodes:
02:0000641E 2E              	  2158: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:0000641F 2E
02:00006420 2E
02:00006421 2E
02:00006422 2E
02:00006423 2E
02:00006424 2E
02:00006425 2E
02:00006426 2E              	  2159: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
02:00006427 2E
02:00006428 2E
02:00006429 2E
02:0000642A 2E
02:0000642B 09
02:0000642C 7E
02:0000642D 2E
02:0000642E 2E              	  2160: 	dc.b	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
02:0000642F 2E
02:00006430 2E
02:00006431 2E
02:00006432 2E
02:00006433 51
02:00006434 21
02:00006435 2E
02:00006436 2E              	  2161: 	dc.b	$2e,$2e,$5a,$53,$41,$57,$40,$2e
02:00006437 2E
02:00006438 5A
02:00006439 53
02:0000643A 41
02:0000643B 57
02:0000643C 40
02:0000643D 2E
02:0000643E 2E              	  2162: 	dc.b	$2e,$43,$58,$44,$45,$24,$23,$2e
02:0000643F 43
02:00006440 58
02:00006441 44
02:00006442 45
02:00006443 24
02:00006444 23
02:00006445 2E
02:00006446 2E              	  2163: 	dc.b	$2e,$20,$56,$46,$54,$52,$25,$2e
02:00006447 20
02:00006448 56
02:00006449 46
02:0000644A 54
02:0000644B 52
02:0000644C 25
02:0000644D 2E
02:0000644E 2E              	  2164: 	dc.b	$2e,$4e,$42,$48,$47,$59,$5e,$2e
02:0000644F 4E
02:00006450 42
02:00006451 48
02:00006452 47
02:00006453 59
02:00006454 5E
02:00006455 2E
02:00006456 2E              	  2165: 	dc.b	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
02:00006457 2E
02:00006458 4D
02:00006459 4A
02:0000645A 55
02:0000645B 26
02:0000645C 2A
02:0000645D 2E
02:0000645E 2E              	  2166: 	dc.b	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
02:0000645F 3C
02:00006460 4B
02:00006461 49
02:00006462 4F
02:00006463 29
02:00006464 28
02:00006465 2E
02:00006466 2E              	  2167: 	dc.b	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
02:00006467 3E
02:00006468 3F
02:00006469 4C
02:0000646A 3A
02:0000646B 50
02:0000646C 5F
02:0000646D 2E
02:0000646E 2E              	  2168: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
02:0000646F 2E
02:00006470 22
02:00006471 2E
02:00006472 7B
02:00006473 2B
02:00006474 2E
02:00006475 2E
02:00006476 2E              	  2169: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
02:00006477 2E
02:00006478 0D
02:00006479 7D
02:0000647A 2E
02:0000647B 7C
02:0000647C 2E
02:0000647D 2E
02:0000647E 2E              	  2170: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
02:0000647F 2E
02:00006480 2E
02:00006481 2E
02:00006482 2E
02:00006483 2E
02:00006484 08
02:00006485 2E
02:00006486 2E              	  2171: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00006487 2E
02:00006488 2E
02:00006489 2E
02:0000648A 2E
02:0000648B 2E
02:0000648C 2E
02:0000648D 2E
02:0000648E 2E              	  2172: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
02:0000648F 7F
02:00006490 2E
02:00006491 2E
02:00006492 2E
02:00006493 2E
02:00006494 1B
02:00006495 2E
02:00006496 2E              	  2173: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00006497 2E
02:00006498 2E
02:00006499 2E
02:0000649A 2E
02:0000649B 2E
02:0000649C 2E
02:0000649D 2E
                            	  2174: 
02:0000649E 2E              	  2175: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:0000649F 2E
02:000064A0 2E
02:000064A1 2E
02:000064A2 2E
02:000064A3 2E
02:000064A4 2E
02:000064A5 2E
02:000064A6 2E              	  2176: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064A7 2E
02:000064A8 2E
02:000064A9 2E
02:000064AA 2E
02:000064AB 2E
02:000064AC 2E
02:000064AD 2E
02:000064AE 2E              	  2177: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064AF 2E
02:000064B0 2E
02:000064B1 2E
02:000064B2 2E
02:000064B3 2E
02:000064B4 2E
02:000064B5 2E
02:000064B6 2E              	  2178: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064B7 2E
02:000064B8 2E
02:000064B9 2E
02:000064BA 2E
02:000064BB 2E
02:000064BC 2E
02:000064BD 2E
02:000064BE 2E              	  2179: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064BF 2E
02:000064C0 2E
02:000064C1 2E
02:000064C2 2E
02:000064C3 2E
02:000064C4 2E
02:000064C5 2E
02:000064C6 2E              	  2180: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064C7 2E
02:000064C8 2E
02:000064C9 2E
02:000064CA 2E
02:000064CB 2E
02:000064CC 2E
02:000064CD 2E
02:000064CE 2E              	  2181: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064CF 2E
02:000064D0 2E
02:000064D1 2E
02:000064D2 2E
02:000064D3 2E
02:000064D4 2E
02:000064D5 2E
02:000064D6 2E              	  2182: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064D7 2E
02:000064D8 2E
02:000064D9 2E
02:000064DA 2E
02:000064DB 2E
02:000064DC 2E
02:000064DD 2E
02:000064DE 2E              	  2183: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064DF 2E
02:000064E0 2E
02:000064E1 2E
02:000064E2 2E
02:000064E3 2E
02:000064E4 2E
02:000064E5 2E
02:000064E6 2E              	  2184: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064E7 2E
02:000064E8 2E
02:000064E9 2E
02:000064EA 2E
02:000064EB 2E
02:000064EC 2E
02:000064ED 2E
02:000064EE 2E              	  2185: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064EF 2E
02:000064F0 2E
02:000064F1 2E
02:000064F2 2E
02:000064F3 2E
02:000064F4 2E
02:000064F5 2E
02:000064F6 2E              	  2186: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064F7 2E
02:000064F8 2E
02:000064F9 2E
02:000064FA 2E
02:000064FB 2E
02:000064FC 2E
02:000064FD 2E
02:000064FE 2E              	  2187: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000064FF 2E
02:00006500 2E
02:00006501 2E
02:00006502 2E
02:00006503 2E
02:00006504 2E
02:00006505 2E
02:00006506 2E              	  2188: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00006507 2E
02:00006508 2E
02:00006509 2E
02:0000650A 2E
02:0000650B 2E
02:0000650C 2E
02:0000650D 2E
02:0000650E 2E              	  2189: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:0000650F 2E
02:00006510 2E
02:00006511 2E
02:00006512 2E
02:00006513 2E
02:00006514 2E
02:00006515 2E
02:00006516 2E              	  2190: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00006517 2E
02:00006518 2E
02:00006519 2E
02:0000651A 2E
02:0000651B 2E
02:0000651C 2E
02:0000651D 2E
                            	  2191: 
                            	  2192: ; control
                            	  2193: _keybdControlCodes:
02:0000651E 2E              	  2194: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:0000651F 2E
02:00006520 2E
02:00006521 2E
02:00006522 2E
02:00006523 2E
02:00006524 2E
02:00006525 2E
02:00006526 2E              	  2195: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
02:00006527 2E
02:00006528 2E
02:00006529 2E
02:0000652A 2E
02:0000652B 09
02:0000652C 7E
02:0000652D 2E
02:0000652E 2E              	  2196: 	dc.b	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
02:0000652F 2E
02:00006530 2E
02:00006531 2E
02:00006532 2E
02:00006533 11
02:00006534 21
02:00006535 2E
02:00006536 2E              	  2197: 	dc.b	$2e,$2e,$1a,$13,$01,$17,$40,$2e
02:00006537 2E
02:00006538 1A
02:00006539 13
02:0000653A 01
02:0000653B 17
02:0000653C 40
02:0000653D 2E
02:0000653E 2E              	  2198: 	dc.b	$2e,$03,$18,$04,$05,$24,$23,$2e
02:0000653F 03
02:00006540 18
02:00006541 04
02:00006542 05
02:00006543 24
02:00006544 23
02:00006545 2E
02:00006546 2E              	  2199: 	dc.b	$2e,$20,$16,$06,$14,$12,$25,$2e
02:00006547 20
02:00006548 16
02:00006549 06
02:0000654A 14
02:0000654B 12
02:0000654C 25
02:0000654D 2E
02:0000654E 2E              	  2200: 	dc.b	$2e,$0e,$02,$08,$07,$19,$5e,$2e
02:0000654F 0E
02:00006550 02
02:00006551 08
02:00006552 07
02:00006553 19
02:00006554 5E
02:00006555 2E
02:00006556 2E              	  2201: 	dc.b	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
02:00006557 2E
02:00006558 0D
02:00006559 0A
02:0000655A 15
02:0000655B 26
02:0000655C 2A
02:0000655D 2E
02:0000655E 2E              	  2202: 	dc.b	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
02:0000655F 3C
02:00006560 0B
02:00006561 09
02:00006562 0F
02:00006563 29
02:00006564 28
02:00006565 2E
02:00006566 2E              	  2203: 	dc.b	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
02:00006567 3E
02:00006568 3F
02:00006569 0C
02:0000656A 3A
02:0000656B 10
02:0000656C 5F
02:0000656D 2E
02:0000656E 2E              	  2204: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
02:0000656F 2E
02:00006570 22
02:00006571 2E
02:00006572 7B
02:00006573 2B
02:00006574 2E
02:00006575 2E
02:00006576 2E              	  2205: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
02:00006577 2E
02:00006578 0D
02:00006579 7D
02:0000657A 2E
02:0000657B 7C
02:0000657C 2E
02:0000657D 2E
02:0000657E 2E              	  2206: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
02:0000657F 2E
02:00006580 2E
02:00006581 2E
02:00006582 2E
02:00006583 2E
02:00006584 08
02:00006585 2E
02:00006586 2E              	  2207: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00006587 2E
02:00006588 2E
02:00006589 2E
02:0000658A 2E
02:0000658B 2E
02:0000658C 2E
02:0000658D 2E
02:0000658E 2E              	  2208: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
02:0000658F 7F
02:00006590 2E
02:00006591 2E
02:00006592 2E
02:00006593 2E
02:00006594 1B
02:00006595 2E
02:00006596 2E              	  2209: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00006597 2E
02:00006598 2E
02:00006599 2E
02:0000659A 2E
02:0000659B 2E
02:0000659C 2E
02:0000659D 2E
                            	  2210: 
                            	  2211: _keybdExtendedCodes:
02:0000659E 2E              	  2212: 	dc.b	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
02:0000659F 2E
02:000065A0 2E
02:000065A1 2E
02:000065A2 A3
02:000065A3 A1
02:000065A4 A2
02:000065A5 2E
02:000065A6 2E              	  2213: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065A7 2E
02:000065A8 2E
02:000065A9 2E
02:000065AA 2E
02:000065AB 2E
02:000065AC 2E
02:000065AD 2E
02:000065AE 2E              	  2214: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065AF 2E
02:000065B0 2E
02:000065B1 2E
02:000065B2 2E
02:000065B3 2E
02:000065B4 2E
02:000065B5 2E
02:000065B6 2E              	  2215: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065B7 2E
02:000065B8 2E
02:000065B9 2E
02:000065BA 2E
02:000065BB 2E
02:000065BC 2E
02:000065BD 2E
02:000065BE 2E              	  2216: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065BF 2E
02:000065C0 2E
02:000065C1 2E
02:000065C2 2E
02:000065C3 2E
02:000065C4 2E
02:000065C5 2E
02:000065C6 2E              	  2217: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065C7 2E
02:000065C8 2E
02:000065C9 2E
02:000065CA 2E
02:000065CB 2E
02:000065CC 2E
02:000065CD 2E
02:000065CE 2E              	  2218: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065CF 2E
02:000065D0 2E
02:000065D1 2E
02:000065D2 2E
02:000065D3 2E
02:000065D4 2E
02:000065D5 2E
02:000065D6 2E              	  2219: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065D7 2E
02:000065D8 2E
02:000065D9 2E
02:000065DA 2E
02:000065DB 2E
02:000065DC 2E
02:000065DD 2E
02:000065DE 2E              	  2220: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065DF 2E
02:000065E0 2E
02:000065E1 2E
02:000065E2 2E
02:000065E3 2E
02:000065E4 2E
02:000065E5 2E
02:000065E6 2E              	  2221: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065E7 2E
02:000065E8 2E
02:000065E9 2E
02:000065EA 2E
02:000065EB 2E
02:000065EC 2E
02:000065ED 2E
02:000065EE 2E              	  2222: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065EF 2E
02:000065F0 2E
02:000065F1 2E
02:000065F2 2E
02:000065F3 2E
02:000065F4 2E
02:000065F5 2E
02:000065F6 2E              	  2223: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065F7 2E
02:000065F8 2E
02:000065F9 2E
02:000065FA 2E
02:000065FB 2E
02:000065FC 2E
02:000065FD 2E
02:000065FE 2E              	  2224: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000065FF 2E
02:00006600 2E
02:00006601 2E
02:00006602 2E
02:00006603 2E
02:00006604 2E
02:00006605 2E
02:00006606 2E              	  2225: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
02:00006607 95
02:00006608 2E
02:00006609 93
02:0000660A 94
02:0000660B 2E
02:0000660C 2E
02:0000660D 2E
02:0000660E 98              	  2226: 	dc.b	$98,$99,$92,$2e,$91,$90,$2e,$2e
02:0000660F 99
02:00006610 92
02:00006611 2E
02:00006612 91
02:00006613 90
02:00006614 2E
02:00006615 2E
02:00006616 2E              	  2227: 	dc.b	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
02:00006617 2E
02:00006618 97
02:00006619 2E
02:0000661A 2E
02:0000661B 96
02:0000661C 2E
02:0000661D 2E
                            	  2228: 
                            	  2229: ;==============================================================================
                            	  2230: ;==============================================================================
                            	  2231: ; Monitor
                            	  2232: ;==============================================================================
                            	  2233: ;==============================================================================
                            	  2234: 
                            	  2235: cmdString:
02:0000661E BF              	  2236: 	dc.b	'?'+$80						; ? display help
02:0000661F CC              	  2237: 	dc.b	'L'+$80						; L load S19 file
02:00006620 46              	  2238: 	dc.b	'F','B'+$80				; FB fill with byte
02:00006621 C2
02:00006622 46              	  2239: 	dc.b	'F','W'+$80				; FW fill with wyde
02:00006623 D7
02:00006624 46              	  2240: 	dc.b	'F','L'+$80				; FL fill with long wyde
02:00006625 CC
02:00006626 464D54          	  2241: 	dc.b	'FMT','K'+$80			; FMTK run Femtiki OS
02:00006629 CB
02:0000662A 42              	  2242: 	dc.b	'B','A'+$80				; BA start Tiny Basic
02:0000662B C1
02:0000662C 42              	  2243: 	dc.b	'B','R'+$80				; BR breakpoint
02:0000662D D2
02:0000662E 44              	  2244: 	dc.b	'D','R'+$80				; DR dump registers
02:0000662F D2
02:00006630 C4              	  2245: 	dc.b	'D'+$80						; D dump memory
02:00006631 CA              	  2246: 	dc.b	'J'+$80						; J jump to code
02:00006632 BA              	  2247: 	dc.b	':'+$80						; : edit memory
02:00006633 434C            	  2248: 	dc.b	"CL",'S'+$80			; CLS clear screen
02:00006635 D3
02:00006636 434F52          	  2249: 	dc.b	"COR",'E'+$80			; CORE <n> switch to core
02:00006639 C5
02:0000663A 5446            	  2250: 	dc.b	"TF",'P'+$80			; TFP test fp
02:0000663C D0
02:0000663D 5447            	  2251: 	dc.b  "TG",'F'+$80			; TGF test get float
02:0000663F C6
02:00006640 545241          	  2252: 	dc.b  "TRA",'M'+$80			; TRAM test RAM
02:00006643 CD
02:00006644 54              	  2253: 	dc.b	'T','R'+$80				; TR test serial receive
02:00006645 D2
02:00006646 D4              	  2254: 	dc.b	'T'+$80						; T test CPU
02:00006647 D3              	  2255: 	dc.b	'S'+$80						; S send serial
02:00006648 52455345        	  2256: 	dc.b	"RESE",'T'+$80		; RESET <n>
02:0000664C D4
02:0000664D 434C4F43        	  2257: 	dc.b	"CLOC",'K'+$80		; CLOCK <n>
02:00006651 CB
02:00006652 D2              	  2258: 	dc.b	'R'+$80						; R receive serial
                            	  2259: 
                            	  2260: 	align	2
                            	  2261: cmdTable:
02:00006654 68C8            	  2262: 	dc.w	cmdHelp
02:00006656 74B4            	  2263: 	dc.w	cmdLoadS19
02:00006658 6B68            	  2264: 	dc.w	cmdFillB
02:0000665A 6B8C            	  2265: 	dc.w	cmdFillW
02:0000665C 6BB0            	  2266: 	dc.w	cmdFillL
02:0000665E 6796            	  2267: 	dc.w	cmdFMTK
02:00006660 6752            	  2268: 	dc.w	cmdTinyBasic
02:00006662 672E            	  2269: 	dc.w	cmdBreakpoint
02:00006664 6CE2            	  2270: 	dc.w	cmdDumpRegs
02:00006666 6C54            	  2271: 	dc.w	cmdDumpMemory
02:00006668 6C46            	  2272: 	dc.w	cmdJump
02:0000666A 6BE6            	  2273: 	dc.w	cmdEditMemory
02:0000666C 6766            	  2274: 	dc.w	cmdClearScreen
02:0000666E 6772            	  2275: 	dc.w	cmdCore
02:00006670 679E            	  2276: 	dc.w  cmdTestFP
02:00006672 682A            	  2277: 	dc.w	cmdTestGF
02:00006674 73DE            	  2278: 	dc.w  cmdTestRAM
02:00006676 6D8C            	  2279: 	dc.w	cmdTestSerialReceive
02:00006678 6756            	  2280: 	dc.w	cmdTestCPU
02:0000667A 6B04            	  2281: 	dc.w	cmdSendSerial
02:0000667C 6876            	  2282: 	dc.w	cmdReset
02:0000667E 6858            	  2283: 	dc.w	cmdClock
02:00006680 6B34            	  2284: 	dc.w	cmdReceiveSerial	
02:00006682 6698            	  2285: 	dc.w	cmdMonitor
                            	  2286: 
                            	  2287: ; Get a word from screen memory and swap byte order
                            	  2288: 
                            	  2289: FromScreen:
02:00006684 2210            	  2290: 	move.l	(a0),d1
02:00006686 61001044        	  2291: 	bsr			rbo
02:0000668A 5088            	  2292: 	lea			8(a0),a0	; increment screen pointer
02:0000668C 4E75            	  2293: 	rts
                            	  2294: 
                            	  2295: StartMon:
02:0000668E 427900040202    	  2296: 	clr.w		NumSetBreakpoints
02:00006694 61001512        	  2297: 	bsr			ClearBreakpointList
                            	  2298: cmdMonitor:
                            	  2299: Monitor:
                            	  2300: 	; Reset the stack pointer on each entry into the monitor
02:00006698 2E7C00040FFC    	  2301: 	move.l	#$40FFC,sp	; reset core's stack
02:0000669E 46FC2200        	  2302: 	move.w	#$2200,sr		; enable level 2 and higher interrupts
02:000066A2 4E7A0FE0        	  2303: 	movec		coreno,d0
02:000066A6 4840            	  2304: 	swap		d0
02:000066A8 7201            	  2305: 	moveq		#1,d1
02:000066AA 61009BE8        	  2306: 	bsr			UnlockSemaphore
02:000066AE 42390004000C    	  2307: 	clr.b		KeybdEcho		; turn off keyboard echo
                            	  2308: PromptLn:
02:000066B4 6100F1E0        	  2309: 	bsr			CRLF
02:000066B8 123C0024        	  2310: 	move.b	#'$',d1
02:000066BC 6100F222        	  2311: 	bsr			DisplayChar
                            	  2312: 
                            	  2313: ; Get characters until a CR is keyed
                            	  2314: ;
                            	  2315: Prompt3:
02:000066C0 6100F8C6        	  2316: 	bsr			GetKey
02:000066C4 0C0100FF        	  2317: 	cmpi.b	#-1,d1
02:000066C8 67F6            	  2318: 	beq.s		Prompt3
02:000066CA 0C01000D        	  2319: 	cmpi.b	#CR,d1
02:000066CE 6706            	  2320: 	beq.s		Prompt1
02:000066D0 6100F20E        	  2321: 	bsr			DisplayChar
02:000066D4 60EA            	  2322: 	bra.s		Prompt3
                            	  2323: 
                            	  2324: ; Process the screen line that the CR was keyed on
                            	  2325: 
                            	  2326: Prompt1:
02:000066D6 423900040001    	  2327: 	clr.b		CursorCol			; go back to the start of the line
02:000066DC 6100F1F4        	  2328: 	bsr			CalcScreenLoc	; a0 = screen memory location
                            	  2329: .0001:
02:000066E0 61A2            	  2330: 	bsr			FromScreen		; grab character off screen
02:000066E2 0C010024        	  2331: 	cmpi.b	#'$',d1				; skip over '$' prompt character
02:000066E6 67F8            	  2332: 	beq.s		.0001
                            	  2333: 	
                            	  2334: ; Dispatch based on command string
                            	  2335: 
                            	  2336: cmdDispatch:
02:000066E8 45FAFF34        	  2337: 	lea			cmdString,a2
02:000066EC 7800            	  2338: 	clr.l		d4						; command counter
02:000066EE 5188            	  2339: 	lea			-8(a0),a0			; backup a character
02:000066F0 2648            	  2340: 	move.l	a0,a3					; a3 = start of command on screen
                            	  2341: .checkNextCmd:
02:000066F2 6190            	  2342: 	bsr			FromScreen		; d1 = char from input screen
02:000066F4 1A1A            	  2343: 	move.b	(a2)+,d5
02:000066F6 BB01            	  2344: 	eor.b		d5,d1					; does it match with command string?
02:000066F8 67F8            	  2345: 	beq.s		.checkNextCmd	; If it does, keep matching for longest match
02:000066FA 0C010080        	  2346: 	cmpi.b	#$80,d1				; didn't match, was it the end of the command?
02:000066FE 6724            	  2347: 	beq.s		.foundCmd
02:00006700 4A2AFFFF        	  2348: 	tst.b		-1(a2)				; was end of table hit?
02:00006704 6712            	  2349: 	beq.s		.endOfTable
02:00006706 5444            	  2350: 	addi.w	#2,d4					; increment command counter
02:00006708 204B            	  2351: 	move.l	a3,a0					; reset input pointer
02:0000670A 4A2AFFFF        	  2352: 	tst.b		-1(a2)				; were we at the end of the command?
02:0000670E 6BE2            	  2353: 	bmi.s		.checkNextCmd	; if were at end continue, otherwise scan for enf of cmd
                            	  2354: .scanToEndOfCmd
02:00006710 4A1A            	  2355: 	tst.b		(a2)+					; scan to end of command
02:00006712 6704            	  2356: 	beq.s		.endOfTable
02:00006714 6AFA            	  2357: 	bpl.s		.scanToEndOfCmd
02:00006716 6BDA            	  2358: 	bmi.s		.checkNextCmd
                            	  2359: .endOfTable
02:00006718 43FA0325        	  2360: 	lea			msgUnknownCmd,a1
02:0000671C 6100F486        	  2361: 	bsr			DisplayStringCRLF
02:00006720 6000FF76        	  2362: 	bra			Monitor
                            	  2363: .foundCmd:
02:00006724 43FAFF2E        	  2364: 	lea			cmdTable,a1		; a1 = pointer to command address table
02:00006728 32714000        	  2365: 	move.w	(a1,d4.w),a1	; fetch command routine address from table
02:0000672C 4ED1            	  2366: 	jmp			(a1)					; go execute command
                            	  2367: 
                            	  2368: cmdBreakpoint:
02:0000672E 610004A4        	  2369: 	bsr			ignBlanks
02:00006732 6100FF50        	  2370: 	bsr			FromScreen
02:00006736 0C01002B        	  2371: 	cmpi.b	#'+',d1
02:0000673A 6700137A        	  2372: 	beq			ArmBreakpoint
02:0000673E 0C01002D        	  2373: 	cmpi.b	#'-',d1
02:00006742 670013F0        	  2374: 	beq			DisarmBreakpoint
02:00006746 0C01004C        	  2375: 	cmpi.b	#'L',d1
02:0000674A 6700143C        	  2376: 	beq			ListBreakpoints
02:0000674E 6000FF48        	  2377: 	bra			Monitor
                            	  2378: 
                            	  2379: cmdTinyBasic:
02:00006752 6000D73E        	  2380: 	bra			CSTART
                            	  2381: 
                            	  2382: cmdTestCPU:
02:00006756 61009BD6        	  2383: 	bsr			cpu_test
02:0000675A 43FA1733        	  2384: 	lea			msg_test_done,a1
02:0000675E 6100F444        	  2385: 	bsr			DisplayStringCRLF
02:00006762 6000FF34        	  2386: 	bra			Monitor
                            	  2387: 
                            	  2388: cmdClearScreen:
02:00006766 61000F5E        	  2389: 	bsr			ClearScreen
02:0000676A 6100F464        	  2390: 	bsr			HomeCursor
02:0000676E 6000FF28        	  2391: 	bra			Monitor
                            	  2392: 
                            	  2393: cmdCore:
02:00006772 61000460        	  2394: 	bsr			ignBlanks
02:00006776 6100FF0C        	  2395: 	bsr			FromScreen
02:0000677A 0C010032        	  2396: 	cmpi.b	#'2',d1					; check range
02:0000677E 6500FF18        	  2397: 	blo			Monitor
02:00006782 0C010039        	  2398: 	cmpi.b	#'9',d1
02:00006786 6200FF10        	  2399: 	bhi			Monitor
02:0000678A 04010030        	  2400: 	subi.b	#'0',d1					; convert ascii to binary
02:0000678E 6100F58E        	  2401: 	bsr			select_iofocus
02:00006792 6000FF04        	  2402: 	bra			Monitor
                            	  2403: 
                            	  2404: cmdFMTK:
02:00006796 6100EEE4        	  2405: 	bsr FemtikiInit
02:0000679A 6000FEFC        	  2406: 	bra Monitor
                            	  2407: 
                            	  2408: cmdTestFP:
02:0000679E 7029            	  2409: 	moveq #41,d0						; function #41, get float
02:000067A0 7208            	  2410: 	moveq #8,d1							; d1 = input stride
02:000067A2 2248            	  2411: 	move.l a0,a1						; a1 = pointer to input buffer
02:000067A4 4E4F            	  2412: 	trap #15
02:000067A6 2049            	  2413: 	move.l a1,a0
02:000067A8 F2000200        	  2414: 	fmove.x fp0,fp4
02:000067AC 61000426        	  2415: 	bsr ignBlanks
02:000067B0 6100FED2        	  2416: 	bsr FromScreen
02:000067B4 1E01            	  2417: 	move.b d1,d7
02:000067B6 7029            	  2418: 	moveq #41,d0						; function #41, get float
02:000067B8 7208            	  2419: 	move.l #8,d1						; d1 = input stride
02:000067BA 2248            	  2420: 	move.l a0,a1						; a1 = pointer to input buffer
02:000067BC 4E4F            	  2421: 	trap #15
02:000067BE 2049            	  2422: 	move.l a1,a0
02:000067C0 F2000100        	  2423: 	fmove.x fp0,fp2
02:000067C4 6100F0D0        	  2424: 	bsr CRLF
                            	  2425: ;	moveq #39,d0
                            	  2426: ;	moveq #40,d1
                            	  2427: ;	moveq #30,d2
                            	  2428: ;	moveq #'e',d3
                            	  2429: ;	trap #15
                            	  2430: ;	bsr CRLF
02:000067C8 F2396A00000402C0	  2431: 	fmove.x fp4,fpBuf
02:000067D0 F2396900000402D0	  2432: 	fmove.x fp2,fpBuf+16
02:000067D8 0C07002B        	  2433: 	cmpi.b #'+',d7
02:000067DC 6606            	  2434: 	bne .0001
02:000067DE F2000A22        	  2435: 	fadd fp2,fp4
02:000067E2 6022            	  2436: 	bra .0002
                            	  2437: .0001
02:000067E4 0C07002D        	  2438: 	cmpi.b #'-',d7
02:000067E8 6606            	  2439: 	bne .0003
02:000067EA F2000A28        	  2440: 	fsub fp2,fp4
02:000067EE 6016            	  2441: 	bra .0002
                            	  2442: .0003
02:000067F0 0C07002A        	  2443: 	cmpi.b #'*',d7
02:000067F4 6606            	  2444: 	bne .0004
02:000067F6 F2000A23        	  2445: 	fmul fp2,fp4
02:000067FA 600A            	  2446: 	bra .0002
                            	  2447: .0004
02:000067FC 0C07002F        	  2448: 	cmpi.b #'/',d7
02:00006800 6620            	  2449: 	bne .0005
02:00006802 F2000A20        	  2450: 	fdiv fp2,fp4
                            	  2451: 	bra .0002
                            	  2452: .0002
02:00006806 F2396A00000402E0	  2453: 	fmove.x fp4,fpBuf+32
02:0000680E F2001000        	  2454: 	fmove.x fp4,fp0
02:00006812 43F900040520    	  2455: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
02:00006818 7027            	  2456: 	moveq #39,d0						; function #39 print float
02:0000681A 7228            	  2457: 	moveq #40,d1						; width
02:0000681C 741E            	  2458: 	moveq #30,d2						; precision
02:0000681E 7665            	  2459: 	moveq #'e',d3
02:00006820 4E4F            	  2460: 	trap #15
                            	  2461: .0005
02:00006822 6100F072        	  2462: 	bsr CRLF
02:00006826 6000FE70        	  2463: 	bra Monitor
                            	  2464: 
                            	  2465: cmdTestGF:
02:0000682A 6100F06A        	  2466: 	bsr CRLF
02:0000682E 7029            	  2467: 	moveq #41,d0						; function #41, get float
02:00006830 7208            	  2468: 	move.l #8,d1						; d1 = input stride
02:00006832 2248            	  2469: 	move.l a0,a1						; a1 = pointer to input buffer
02:00006834 4E4F            	  2470: 	trap #15
02:00006836 F2396800000402E0	  2471: 	fmove.x fp0,fpBuf+32
02:0000683E 43F900040520    	  2472: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
02:00006844 7027            	  2473: 	moveq #39,d0
02:00006846 7228            	  2474: 	moveq #40,d1
02:00006848 741E            	  2475: 	moveq #30,d2
02:0000684A 7665            	  2476: 	moveq #'e',d3
02:0000684C 4E4F            	  2477: 	trap #15
02:0000684E 2049            	  2478: 	move.l a1,a0
02:00006850 6100F044        	  2479: 	bsr CRLF
02:00006854 6000FE42        	  2480: 	bra Monitor
                            	  2481: 		
                            	  2482: ;-------------------------------------------------------------------------------
                            	  2483: ; CLOCK <n>
                            	  2484: ;    Set the clock register to n which will turn off or on clocks to the CPUs.
                            	  2485: ;-------------------------------------------------------------------------------
                            	  2486: 
                            	  2487: cmdClock:
02:00006858 6100037A        	  2488: 	bsr			ignBlanks
02:0000685C 6100054E        	  2489: 	bsr			GetHexNumber
02:00006860 4A00            	  2490: 	tst.b		d0							; was there a number?
02:00006862 6700FE34        	  2491: 	beq			Monitor
02:00006866 00400004        	  2492: 	ori.w		#4,d0						; primary core's clock cannot be turned off
02:0000686A E159            	  2493: 	rol.w		#8,d1						; switch byte order
02:0000686C 33C1FD0FFC02    	  2494: 	move.w	d1,RST_REG+2
02:00006872 6000FE24        	  2495: 	bra			Monitor
                            	  2496: 
                            	  2497: ;-------------------------------------------------------------------------------
                            	  2498: ; RESET <n>
                            	  2499: ;    Reset the specified core. Resetting the core automatically turns on the 
                            	  2500: ; core's clock.
                            	  2501: ;-------------------------------------------------------------------------------
                            	  2502: 
                            	  2503: cmdReset:
02:00006876 6100035C        	  2504: 	bsr			ignBlanks
02:0000687A 6100FE08        	  2505: 	bsr			FromScreen
02:0000687E 0C010032        	  2506: 	cmpi.b	#'2',d1					; check range
02:00006882 6500FE14        	  2507: 	blo			Monitor
02:00006886 0C010039        	  2508: 	cmpi.b	#'9',d1
02:0000688A 6200FE0C        	  2509: 	bhi			Monitor
02:0000688E 04010030        	  2510: 	subi.b	#'0',d1					; convert ascii to binary
02:00006892 E349            	  2511: 	lsl.w		#1,d1						; make into index
02:00006894 43FA0012        	  2512: 	lea			tblPow2,a1
02:00006898 32311000        	  2513: 	move.w	(a1,d1.w),d1
02:0000689C E159            	  2514: 	rol.w		#8,d1						; reverse byte order
02:0000689E 33C1FD0FFC00    	  2515: 	move.w	d1,RST_REG
02:000068A4 6000FDF2        	  2516: 	bra			Monitor
                            	  2517: 
                            	  2518: tblPow2:
02:000068A8 0001            	  2519: 	dc.w		1
02:000068AA 0002            	  2520: 	dc.w		2
02:000068AC 0004            	  2521: 	dc.w		4
02:000068AE 0008            	  2522: 	dc.w		8
02:000068B0 0010            	  2523: 	dc.w		16
02:000068B2 0020            	  2524: 	dc.w		32
02:000068B4 0040            	  2525: 	dc.w		64
02:000068B6 0080            	  2526: 	dc.w		128
02:000068B8 0100            	  2527: 	dc.w		256
02:000068BA 0200            	  2528: 	dc.w		512
02:000068BC 0400            	  2529: 	dc.w		1024
02:000068BE 0800            	  2530: 	dc.w		2048
02:000068C0 1000            	  2531: 	dc.w		4096
02:000068C2 2000            	  2532: 	dc.w		8192
02:000068C4 4000            	  2533: 	dc.w		16384
02:000068C6 8000            	  2534: 	dc.w		32768
                            	  2535: 	even
                            	  2536: 	
                            	  2537: cmdHelp:
                            	  2538: DisplayHelp:
02:000068C8 43FA000A        	  2539: 	lea			HelpMsg,a1
02:000068CC 6100F2C0        	  2540: 	bsr			DisplayString
02:000068D0 6000FDC6        	  2541: 	bra			Monitor
                            	  2542: 
                            	  2543: HelpMsg:
02:000068D4 3F203D2044697370	  2544: 	dc.b	"? = Display help",LF,CR
02:000068DC 6C61792068656C70
02:000068E4 0A
02:000068E5 0D
02:000068E6 434F5245206E203D	  2545: 	dc.b  "CORE n = switch to core n, n = 2 to 9",LF,CR
02:000068EE 2073776974636820
02:000068F6 746F20636F726520
02:000068FE 6E2C206E203D2032
02:00006906 20746F2039
02:0000690B 0A
02:0000690C 0D
02:0000690D 5245534554206E20	  2546: 	dc.b  "RESET n = reset core n",LF,CR
02:00006915 3D20726573657420
02:0000691D 636F7265206E
02:00006923 0A
02:00006924 0D
02:00006925 434C53203D20636C	  2547: 	dc.b	"CLS = clear screen",LF,CR
02:0000692D 6561722073637265
02:00006935 656E
02:00006937 0A
02:00006938 0D
02:00006939 3A203D2045646974	  2548: 	dc.b	": = Edit memory bytes",LF,CR
02:00006941 206D656D6F727920
02:00006949 6279746573
02:0000694E 0A
02:0000694F 0D
02:00006950 4642203D2046696C	  2549: 	dc.b	"FB = Fill memory bytes, FW, FL",LF,CR
02:00006958 6C206D656D6F7279
02:00006960 2062797465732C20
02:00006968 46572C20464C
02:0000696E 0A
02:0000696F 0D
02:00006970 464D544B203D2072	  2550: 	dc.b	"FMTK = run Femtiki OS",LF,CR
02:00006978 756E2046656D7469
02:00006980 6B69204F53
02:00006985 0A
02:00006986 0D
02:00006987 4C203D204C6F6164	  2551: 	dc.b	"L = Load S19 file",LF,CR
02:0000698F 205331392066696C
02:00006997 65
02:00006998 0A
02:00006999 0D
02:0000699A 44203D2044756D70	  2552: 	dc.b	"D = Dump memory, DR = dump registers",LF,CR
02:000069A2 206D656D6F72792C
02:000069AA 204452203D206475
02:000069B2 6D70207265676973
02:000069BA 74657273
02:000069BE 0A
02:000069BF 0D
02:000069C0 4241203D20737461	  2553: 	dc.b	"BA = start tiny basic",LF,CR
02:000069C8 72742074696E7920
02:000069D0 6261736963
02:000069D5 0A
02:000069D6 0D
02:000069D7 4252203D20736574	  2554: 	dc.b  "BR = set breakpoint",LF,CR
02:000069DF 20627265616B706F
02:000069E7 696E74
02:000069EA 0A
02:000069EB 0D
02:000069EC 4A203D204A756D70	  2555: 	dc.b	"J = Jump to code",LF,CR
02:000069F4 20746F20636F6465
02:000069FC 0A
02:000069FD 0D
02:000069FE 53203D2073656E64	  2556: 	dc.b  "S = send to serial port",LF,CR
02:00006A06 20746F2073657269
02:00006A0E 616C20706F7274
02:00006A15 0A
02:00006A16 0D
02:00006A17 54203D2063707520	  2557: 	dc.b	"T = cpu test program",LF,CR
02:00006A1F 746573742070726F
02:00006A27 6772616D
02:00006A2B 0A
02:00006A2C 0D
02:00006A2D 5452414D203D2074	  2558: 	dc.b	"TRAM = test RAM",LF,CR,0
02:00006A35 6573742052414D
02:00006A3C 0A
02:00006A3D 0D
02:00006A3E 00
                            	  2559: 
                            	  2560: msgUnknownCmd:
02:00006A3F 636F6D6D616E6420	  2561: 	dc.b	"command unknown",0
02:00006A47 756E6B6E6F776E
02:00006A4E 00
                            	  2562: 
                            	  2563: msgHello:
02:00006A4F 0A              	  2564: 	dc.b	LF,CR,"Hello World!",LF,CR,0
02:00006A50 0D
02:00006A51 48656C6C6F20576F
02:00006A59 726C6421
02:00006A5D 0A
02:00006A5E 0D
02:00006A5F 00
                            	  2565: 	even
                            	  2566: 
                            	  2567: ;------------------------------------------------------------------------------
                            	  2568: ; This routine borrowed from Gordo's Tiny Basic interpreter.
                            	  2569: ; Used to fetch a command line. (Not currently used).
                            	  2570: ;
                            	  2571: ; d0.b	- command prompt
                            	  2572: ;------------------------------------------------------------------------------
                            	  2573: 
                            	  2574: GetCmdLine:
02:00006A60 6100EE7E        	  2575: 		bsr		DisplayChar		; display prompt
02:00006A64 103C0020        	  2576: 		move.b	#' ',d0
02:00006A68 6100EE76        	  2577: 		bsr		DisplayChar
02:00006A6C 41F900040040    	  2578: 		lea		CmdBuf,a0
                            	  2579: .0001:
02:00006A72 6100F514        	  2580: 		bsr		GetKey
02:00006A76 B03C0008        	  2581: 		cmp.b	#CTRLH,d0
02:00006A7A 6728            	  2582: 		beq.s	.0003
02:00006A7C B03C0018        	  2583: 		cmp.b	#CTRLX,d0
02:00006A80 6746            	  2584: 		beq.s	.0004
02:00006A82 B03C000D        	  2585: 		cmp.b	#CR,d0
02:00006A86 6706            	  2586: 		beq.s	.0002
02:00006A88 B03C0020        	  2587: 		cmp.b	#' ',d0
02:00006A8C 65E4            	  2588: 		bcs.s	.0001
                            	  2589: .0002:
02:00006A8E 1080            	  2590: 		move.b	d0,(a0)
02:00006A90 5088            	  2591: 		lea			8(a0),a0
02:00006A92 6100EE4C        	  2592: 		bsr		DisplayChar
02:00006A96 B03C000D        	  2593: 		cmp.b	#CR,d0
02:00006A9A 675E            	  2594: 		beq		.0007
02:00006A9C B1FC0004007F    	  2595: 		cmp.l	#CmdBufEnd-1,a0
02:00006AA2 65CE            	  2596: 		bcs.s	.0001
                            	  2597: .0003:
02:00006AA4 103C0008        	  2598: 		move.b	#CTRLH,d0
02:00006AA8 6100EE36        	  2599: 		bsr		DisplayChar
02:00006AAC 103C0020        	  2600: 		move.b	#' ',d0
02:00006AB0 6100EE2E        	  2601: 		bsr		DisplayChar
02:00006AB4 B1FC00040040    	  2602: 		cmp.l	#CmdBuf,a0
02:00006ABA 63B6            	  2603: 		bls.s	.0001
02:00006ABC 103C0008        	  2604: 		move.b	#CTRLH,d0
02:00006AC0 6100EE1E        	  2605: 		bsr		DisplayChar
02:00006AC4 5388            	  2606: 		subq.l	#1,a0
02:00006AC6 60AA            	  2607: 		bra.s	.0001
                            	  2608: .0004:
02:00006AC8 2208            	  2609: 		move.l	a0,d1
02:00006ACA 92BC00040040    	  2610: 		sub.l	#CmdBuf,d1
02:00006AD0 671E            	  2611: 		beq.s	.0006
02:00006AD2 5341            	  2612: 		subq	#1,d1
                            	  2613: .0005:
02:00006AD4 103C0008        	  2614: 		move.b	#CTRLH,d0
02:00006AD8 6100EE06        	  2615: 		bsr		DisplayChar
02:00006ADC 103C0020        	  2616: 		move.b	#' ',d0
02:00006AE0 6100EDFE        	  2617: 		bsr		DisplayChar
02:00006AE4 103C0008        	  2618: 		move.b	#CTRLH,d0
02:00006AE8 6100EDF6        	  2619: 		bsr		DisplayChar
02:00006AEC 51C9FFE6        	  2620: 		dbra	d1,.0005
                            	  2621: .0006:
02:00006AF0 41F900040040    	  2622: 		lea		CmdBuf,a0
02:00006AF6 6000FF7A        	  2623: 		bra		.0001
                            	  2624: .0007:
02:00006AFA 103C000A        	  2625: 		move.b	#LF,d0
02:00006AFE 6100EDE0        	  2626: 		bsr		DisplayChar
02:00006B02 4E75            	  2627: 		rts
                            	  2628: 
                            	  2629: ;------------------------------------------------------------------------------
                            	  2630: ; S <address> <length>
                            	  2631: ; Send data buffer to serial port
                            	  2632: ; S 40000 40
                            	  2633: ;------------------------------------------------------------------------------
                            	  2634: 
                            	  2635: cmdSendSerial:
02:00006B04 610000CE        	  2636: 	bsr			ignBlanks
02:00006B08 610002A2        	  2637: 	bsr			GetHexNumber
02:00006B0C 6700FB8A        	  2638: 	beq			Monitor
02:00006B10 2C01            	  2639: 	move.l	d1,d6					; d6 points to buffer
02:00006B12 610000C0        	  2640: 	bsr			ignBlanks
02:00006B16 61000294        	  2641: 	bsr			GetHexNumber
02:00006B1A 6602            	  2642: 	bne.s		.0003
02:00006B1C 7210            	  2643: 	moveq		#16,d1
                            	  2644: .0003:
02:00006B1E 2246            	  2645: 	move.l	d6,a1					; a1 points to buffer
02:00006B20 2401            	  2646: 	move.l	d1,d2					; d2 = count of bytes to send
02:00006B22 6008            	  2647: 	bra.s		.0002					; enter loop at bottom
                            	  2648: .0001:
02:00006B24 1219            	  2649: 	move.b	(a1)+,d1
02:00006B26 303C0022        	  2650: 	move.w	#34,d0				; serial putchar
02:00006B2A 4E4F            	  2651: 	trap		#15
                            	  2652: .0002:
02:00006B2C 51CAFFF6        	  2653: 	dbra		d2,.0001
02:00006B30 6000FB66        	  2654: 	bra			Monitor
                            	  2655: 		
                            	  2656: ;------------------------------------------------------------------------------
                            	  2657: ; R <address> <length>
                            	  2658: ; Send data buffer to serial port
                            	  2659: ; R 10000 40
                            	  2660: ;------------------------------------------------------------------------------
                            	  2661: 
                            	  2662: cmdReceiveSerial:
02:00006B34 6100009E        	  2663: 	bsr			ignBlanks
02:00006B38 61000272        	  2664: 	bsr			GetHexNumber
02:00006B3C 6700FB5A        	  2665: 	beq			Monitor
02:00006B40 2C01            	  2666: 	move.l	d1,d6					; d6 points to buffer
02:00006B42 61000090        	  2667: 	bsr			ignBlanks
02:00006B46 61000264        	  2668: 	bsr			GetHexNumber
02:00006B4A 6602            	  2669: 	bne.s		.0003
02:00006B4C 7210            	  2670: 	moveq		#16,d1
                            	  2671: .0003:
02:00006B4E 2246            	  2672: 	move.l	d6,a1					; a1 points to buffer
02:00006B50 2401            	  2673: 	move.l	d1,d2					; d2 = count of bytes to send
02:00006B52 600C            	  2674: 	bra.s		.0002					; enter loop at bottom
                            	  2675: .0001:
02:00006B54 303C0024        	  2676: 	move.w	#36,d0				; serial peek char
02:00006B58 4E4F            	  2677: 	trap		#15
02:00006B5A 4A81            	  2678: 	tst.l		d1
02:00006B5C 6BF6            	  2679: 	bmi.s		.0001
02:00006B5E 12C1            	  2680: 	move.b	d1,(a1)+
                            	  2681: .0002:
02:00006B60 51CAFFF2        	  2682: 	dbra		d2,.0001
02:00006B64 6000FB32        	  2683: 	bra			Monitor
                            	  2684: 		
                            	  2685: ;------------------------------------------------------------------------------
                            	  2686: ; Fill memory
                            	  2687: ;
                            	  2688: ; FB = fill bytes		FB 00000010 100 FF	; fill starting at 10 for 256 bytes
                            	  2689: ; FW = fill words
                            	  2690: ; FL = fill longs
                            	  2691: ; F = fill bytes
                            	  2692: ;------------------------------------------------------------------------------
                            	  2693: 
                            	  2694: cmdFillB:
02:00006B68 616A            	  2695: 	bsr			ignBlanks
02:00006B6A 61000240        	  2696: 	bsr			GetHexNumber
02:00006B6E 2241            	  2697: 	move.l	d1,a1					; a1 = start
02:00006B70 6162            	  2698: 	bsr			ignBlanks
02:00006B72 61000238        	  2699: 	bsr			GetHexNumber
02:00006B76 2601            	  2700: 	move.l	d1,d3					; d3 = count
02:00006B78 6700FB1E        	  2701: 	beq			Monitor
02:00006B7C 6156            	  2702: 	bsr			ignBlanks
02:00006B7E 6100022C        	  2703: 	bsr			GetHexNumber	; fill value
                            	  2704: .fmem:
02:00006B82 12C1            	  2705: 	move.b	d1,(a1)+
02:00006B84 5383            	  2706: 	sub.l		#1,d3
02:00006B86 66FA            	  2707: 	bne.s		.fmem
02:00006B88 6000FB0E        	  2708: 	bra			Monitor
                            	  2709: 	
                            	  2710: cmdFillW:
02:00006B8C 6146            	  2711: 	bsr			ignBlanks
02:00006B8E 6100021C        	  2712: 	bsr			GetHexNumber
02:00006B92 2241            	  2713: 	move.l	d1,a1					; a1 = start
02:00006B94 613E            	  2714: 	bsr			ignBlanks
02:00006B96 61000214        	  2715: 	bsr			GetHexNumber
02:00006B9A 2601            	  2716: 	move.l	d1,d3					; d3 = count
02:00006B9C 6700FAFA        	  2717: 	beq			Monitor
02:00006BA0 6132            	  2718: 	bsr			ignBlanks
02:00006BA2 61000208        	  2719: 	bsr			GetHexNumber	; fill value
                            	  2720: .fmem:
02:00006BA6 32C1            	  2721: 	move.w	d1,(a1)+
02:00006BA8 5383            	  2722: 	sub.l		#1,d3
02:00006BAA 66FA            	  2723: 	bne.s		.fmem
02:00006BAC 6000FAEA        	  2724: 	bra			Monitor
                            	  2725: 	
                            	  2726: cmdFillL:
02:00006BB0 6122            	  2727: 	bsr			ignBlanks
02:00006BB2 610001F8        	  2728: 	bsr			GetHexNumber
02:00006BB6 2241            	  2729: 	move.l	d1,a1					; a1 = start
02:00006BB8 611A            	  2730: 	bsr			ignBlanks
02:00006BBA 610001F0        	  2731: 	bsr			GetHexNumber
02:00006BBE 2601            	  2732: 	move.l	d1,d3					; d3 = count
02:00006BC0 6700FAD6        	  2733: 	beq			Monitor
02:00006BC4 610E            	  2734: 	bsr			ignBlanks
02:00006BC6 610001E4        	  2735: 	bsr			GetHexNumber	; fill value
                            	  2736: .fmem:
02:00006BCA 22C1            	  2737: 	move.l	d1,(a1)+
02:00006BCC 5383            	  2738: 	sub.l		#1,d3
02:00006BCE 66FA            	  2739: 	bne.s		.fmem
02:00006BD0 6000FAC6        	  2740: 	bra			Monitor
                            	  2741: 	
                            	  2742: ;------------------------------------------------------------------------------
                            	  2743: ; Modifies:
                            	  2744: ;	a0	- text pointer
                            	  2745: ;------------------------------------------------------------------------------
                            	  2746: 
                            	  2747: ignBlanks:
02:00006BD4 2F01            	  2748: 	move.l	d1,-(a7)
                            	  2749: .0001:
02:00006BD6 6100FAAC        	  2750: 	bsr			FromScreen
02:00006BDA 0C010020        	  2751: 	cmpi.b	#' ',d1
02:00006BDE 67F6            	  2752: 	beq.s		.0001
02:00006BE0 5188            	  2753: 	lea			-8(a0),a0
02:00006BE2 221F            	  2754: 	move.l	(a7)+,d1
02:00006BE4 4E75            	  2755: 	rts
                            	  2756: 
                            	  2757: ;------------------------------------------------------------------------------
                            	  2758: ; Edit memory byte.
                            	  2759: ;    Bytes are built into long words in case the memory is only longword
                            	  2760: ; accessible.
                            	  2761: ;------------------------------------------------------------------------------
                            	  2762: 
                            	  2763: cmdEditMemory:
02:00006BE6 61EC            	  2764: 	bsr			ignBlanks
02:00006BE8 610001C2        	  2765: 	bsr			GetHexNumber
02:00006BEC 2241            	  2766: 	move.l	d1,a1
                            	  2767: edtmem1:
02:00006BEE 7400            	  2768: 	clr.l		d2
02:00006BF0 61E2            	  2769: 	bsr			ignBlanks
02:00006BF2 610001B8        	  2770: 	bsr			GetHexNumber
02:00006BF6 1401            	  2771: 	move.b	d1,d2
                            	  2772: ;	move.b	d1,(a1)+
02:00006BF8 61DA            	  2773: 	bsr			ignBlanks
02:00006BFA 610001B0        	  2774: 	bsr			GetHexNumber
02:00006BFE E18A            	  2775: 	lsl.l		#8,d2
02:00006C00 1401            	  2776: 	move.b	d1,d2
                            	  2777: ;	move.b	d1,(a1)+
02:00006C02 61D0            	  2778: 	bsr			ignBlanks
02:00006C04 610001A6        	  2779: 	bsr			GetHexNumber
02:00006C08 E18A            	  2780: 	lsl.l		#8,d2
02:00006C0A 1401            	  2781: 	move.b	d1,d2
                            	  2782: ;	move.b	d1,(a1)+
02:00006C0C 61C6            	  2783: 	bsr			ignBlanks
02:00006C0E 6100019C        	  2784: 	bsr			GetHexNumber
02:00006C12 E18A            	  2785: 	lsl.l		#8,d2
02:00006C14 1401            	  2786: 	move.b	d1,d2
02:00006C16 22C2            	  2787: 	move.l	d2,(a1)+
                            	  2788: ;	move.b	d1,(a1)+
02:00006C18 7400            	  2789: 	clr.l		d2
02:00006C1A 61B8            	  2790: 	bsr			ignBlanks
02:00006C1C 6100018E        	  2791: 	bsr			GetHexNumber
02:00006C20 1401            	  2792: 	move.b	d1,d2
                            	  2793: ;	move.b	d1,(a1)+
02:00006C22 61B0            	  2794: 	bsr			ignBlanks
02:00006C24 61000186        	  2795: 	bsr			GetHexNumber
02:00006C28 E18A            	  2796: 	lsl.l		#8,d2
02:00006C2A 1401            	  2797: 	move.b	d1,d2
                            	  2798: ;	move.b	d1,(a1)+
02:00006C2C 61A6            	  2799: 	bsr			ignBlanks
02:00006C2E 6100017C        	  2800: 	bsr			GetHexNumber
02:00006C32 E18A            	  2801: 	lsl.l		#8,d2
02:00006C34 1401            	  2802: 	move.b	d1,d2
                            	  2803: ;	move.b	d1,(a1)+
02:00006C36 619C            	  2804: 	bsr			ignBlanks
02:00006C38 61000172        	  2805: 	bsr			GetHexNumber
02:00006C3C E18A            	  2806: 	lsl.l		#8,d2
02:00006C3E 1401            	  2807: 	move.b	d1,d2
                            	  2808: ;	move.b	d1,(a1)+
02:00006C40 22C2            	  2809: 	move.l	d2,(a1)+
02:00006C42 6000FA54        	  2810: 	bra			Monitor
                            	  2811: 
                            	  2812: ;------------------------------------------------------------------------------
                            	  2813: ; Execute code at the specified address.
                            	  2814: ;------------------------------------------------------------------------------
                            	  2815: 
                            	  2816: cmdJump:
                            	  2817: ExecuteCode:
02:00006C46 618C            	  2818: 	bsr			ignBlanks
02:00006C48 61000162        	  2819: 	bsr			GetHexNumber
02:00006C4C 2041            	  2820: 	move.l	d1,a0
02:00006C4E 4E90            	  2821: 	jsr			(a0)
02:00006C50 6000FA46        	  2822: 	bra     Monitor
                            	  2823: 
                            	  2824: ;------------------------------------------------------------------------------
                            	  2825: ; Do a memory dump of the requested location.
                            	  2826: ; D 0800 0850
                            	  2827: ;------------------------------------------------------------------------------
                            	  2828: 
                            	  2829: cmdDumpMemory:
02:00006C54 6100FF7E        	  2830: 	bsr			ignBlanks
02:00006C58 61000152        	  2831: 	bsr			GetHexNumber
02:00006C5C 6700FA3A        	  2832: 	beq			Monitor			; was there a number ? no, other garbage, just ignore
02:00006C60 2601            	  2833: 	move.l	d1,d3				; save off start of range
02:00006C62 6100FF70        	  2834: 	bsr			ignBlanks
02:00006C66 61000144        	  2835: 	bsr			GetHexNumber
02:00006C6A 6608            	  2836: 	bne.s		DumpMem1
02:00006C6C 2203            	  2837: 	move.l	d3,d1
02:00006C6E 068100000040    	  2838: 	addi.l	#64,d1			; no end specified, just dump 64 bytes
                            	  2839: DumpMem1:
02:00006C74 2043            	  2840: 	move.l	d3,a0
02:00006C76 2241            	  2841: 	move.l	d1,a1
02:00006C78 6100EC1C        	  2842: 	bsr			CRLF
                            	  2843: .0001:
02:00006C7C B3C8            	  2844: 	cmpa.l	a0,a1
02:00006C7E 6300FA18        	  2845: 	bls			Monitor
02:00006C82 6102            	  2846: 	bsr			DisplayMem
02:00006C84 60F6            	  2847: 	bra.s		.0001
                            	  2848: 
                            	  2849: ;------------------------------------------------------------------------------
                            	  2850: ; Display memory dump in a format suitable for edit.
                            	  2851: ;
                            	  2852: ;	:12345678 00 11 22 33 44 55 66 77  "........"
                            	  2853: ;
                            	  2854: ; Modifies:
                            	  2855: ;		d1,d2,a0
                            	  2856: ;------------------------------------------------------------------------------
                            	  2857: 
                            	  2858: DisplayMem:
02:00006C86 123C003A        	  2859: 	move.b	#':',d1
02:00006C8A 6100EC54        	  2860: 	bsr			DisplayChar
02:00006C8E 2208            	  2861: 	move.l	a0,d1
02:00006C90 61000702        	  2862: 	bsr			DisplayTetra
02:00006C94 7407            	  2863: 	moveq		#7,d2
                            	  2864: dspmem1:
02:00006C96 123C0020        	  2865: 	move.b	#' ',d1
02:00006C9A 6100EC44        	  2866: 	bsr			DisplayChar
02:00006C9E 1218            	  2867: 	move.b	(a0)+,d1
02:00006CA0 610006FE        	  2868: 	bsr			DisplayByte
02:00006CA4 51CAFFF0        	  2869: 	dbra		d2,dspmem1
02:00006CA8 610006D0        	  2870: 	bsr			DisplayTwoSpaces
02:00006CAC 123C0022        	  2871: 	move.b	#34,d1
02:00006CB0 6100EC2E        	  2872: 	bsr			DisplayChar
02:00006CB4 5188            	  2873: 	lea			-8(a0),a0
02:00006CB6 7407            	  2874: 	moveq		#7,d2
                            	  2875: .0002:	
02:00006CB8 1218            	  2876: 	move.b	(a0)+,d1
02:00006CBA B23C0020        	  2877: 	cmp.b		#' ',d1
02:00006CBE 6506            	  2878: 	blo.s		.0003
02:00006CC0 B23C007F        	  2879: 	cmp.b		#127,d1
02:00006CC4 6304            	  2880: 	bls.s		.0001
                            	  2881: .0003:
02:00006CC6 123C002E        	  2882: 	move.b	#'.',d1
                            	  2883: .0001:
02:00006CCA 6100EC14        	  2884: 	bsr			DisplayChar
02:00006CCE 51CAFFE8        	  2885: 	dbra		d2,.0002
02:00006CD2 123C0022        	  2886: 	move.b	#34,d1
02:00006CD6 6100EC08        	  2887: 	bsr			DisplayChar
02:00006CDA 6100F2E4        	  2888: 	bsr			CheckForCtrlC
02:00006CDE 6000EBB6        	  2889: 	bra			CRLF
                            	  2890: 
                            	  2891: ;------------------------------------------------------------------------------
                            	  2892: ; Dump Registers
                            	  2893: ;    The dump is in a format that allows the register value to be edited.
                            	  2894: ;
                            	  2895: ; RegD0 12345678
                            	  2896: ; RegD1 77777777
                            	  2897: ;	... etc
                            	  2898: ;------------------------------------------------------------------------------
                            	  2899: 
                            	  2900: cmdDumpRegs:
02:00006CE2 6100EBB2        	  2901: 	bsr			CRLF
02:00006CE6 303C000F        	  2902: 	move.w	#15,d0					; number of registers-1
02:00006CEA 41FA007A        	  2903: 	lea			msg_reglist,a0	;
02:00006CEE 43FA0072        	  2904: 	lea			msg_regs,a1
02:00006CF2 45F900040100    	  2905: 	lea			Regsave,a2			; a2 points to register save area
                            	  2906: .0001:
02:00006CF8 6100EE94        	  2907: 	bsr			DisplayString
02:00006CFC 1218            	  2908: 	move.b	(a0)+,d1
02:00006CFE 6100EBE0        	  2909: 	bsr			DisplayChar
02:00006D02 1218            	  2910: 	move.b	(a0)+,d1
02:00006D04 6100EBDA        	  2911: 	bsr			DisplayChar
02:00006D08 61000682        	  2912: 	bsr			DisplaySpace
02:00006D0C 221A            	  2913: 	move.l	(a2)+,d1
02:00006D0E 61000684        	  2914: 	bsr			DisplayTetra
02:00006D12 6100EB82        	  2915: 	bsr			CRLF
02:00006D16 51C8FFE0        	  2916: 	dbra		d0,.0001
02:00006D1A 6100EE72        	  2917: 	bsr			DisplayString
02:00006D1E 1218            	  2918: 	move.b	(a0)+,d1
02:00006D20 6100EBBE        	  2919: 	bsr			DisplayChar
02:00006D24 1218            	  2920: 	move.b	(a0)+,d1
02:00006D26 6100EBB8        	  2921: 	bsr			DisplayChar
02:00006D2A 61000660        	  2922: 	bsr			DisplaySpace
02:00006D2E 223900040144    	  2923: 	move.l	Regsave+$44,d1
02:00006D34 6100065E        	  2924: 	bsr			DisplayTetra
02:00006D38 6100EB5C        	  2925: 	bsr			CRLF
02:00006D3C 6100EE50        	  2926: 	bsr			DisplayString
02:00006D40 1218            	  2927: 	move.b	(a0)+,d1
02:00006D42 6100EB9C        	  2928: 	bsr			DisplayChar
02:00006D46 1218            	  2929: 	move.b	(a0)+,d1
02:00006D48 6100EB96        	  2930: 	bsr			DisplayChar
02:00006D4C 6100063E        	  2931: 	bsr			DisplaySpace
02:00006D50 323900040140    	  2932: 	move.w	Regsave+$40,d1
02:00006D56 61000642        	  2933: 	bsr			DisplayWyde
02:00006D5A 6100EB3A        	  2934: 	bsr			CRLF
02:00006D5E 6000F938        	  2935: 	bra			Monitor
                            	  2936: 
                            	  2937: msg_regs:
02:00006D62 526567          	  2938: 	dc.b	"Reg",0
02:00006D65 00
                            	  2939: msg_reglist:
02:00006D66 4430443144324433	  2940: 	dc.b	"D0D1D2D3D4D5D6D7A0A1A2A3A4A5A6A7PCSR",0
02:00006D6E 4434443544364437
02:00006D76 4130413141324133
02:00006D7E 4134413541364137
02:00006D86 50435352
02:00006D8A 00
                            	  2941: 
                            	  2942: 	align	1
                            	  2943: 
                            	  2944: ;------------------------------------------------------------------------------
                            	  2945: ;------------------------------------------------------------------------------
                            	  2946: 
                            	  2947: cmdTestSerialReceive:
                            	  2948: .0002:
02:00006D8C 7024            	  2949: 	moveq		#36,d0				; serial get char from buffer
02:00006D8E 4E4F            	  2950: 	trap		#15
                            	  2951: ;	bsr			SerialPeekCharDirect
02:00006D90 4A41            	  2952: 	tst.w		d1
02:00006D92 6B0A            	  2953: 	bmi.s		.0001
02:00006D94 0C01001A        	  2954: 	cmpi.b	#CTRLZ,d1
02:00006D98 670A            	  2955: 	beq			.0003
02:00006D9A 6100EB44        	  2956: 	bsr			DisplayChar
                            	  2957: .0001:	
02:00006D9E 6100F220        	  2958: 	bsr			CheckForCtrlC
02:00006DA2 60E8            	  2959: 	bra			.0002
                            	  2960: .0003:
02:00006DA4 6100F05E        	  2961: 	bsr			_KeybdInit
02:00006DA8 6000F8EE        	  2962: 	bra			Monitor
                            	  2963: 
                            	  2964: ;------------------------------------------------------------------------------
                            	  2965: ; Get a hexidecimal number. Maximum of eight digits.
                            	  2966: ;
                            	  2967: ; Returns:
                            	  2968: ;		d0 = number of digits
                            	  2969: ;		d1 = value of number
                            	  2970: ;		zf = number of digits == 0
                            	  2971: ;------------------------------------------------------------------------------
                            	  2972: 
                            	  2973: GetHexNumber:
02:00006DAC 2F02            	  2974: 	move.l	d2,-(a7)
02:00006DAE 7400            	  2975: 	clr.l		d2
02:00006DB0 7000            	  2976: 	moveq		#0,d0
                            	  2977: .0002
02:00006DB2 6100F8D0        	  2978: 	bsr			FromScreen
02:00006DB6 61000588        	  2979: 	bsr			AsciiToHexNybble
02:00006DBA 0C0100FF        	  2980: 	cmpi.b	#$ff,d1
02:00006DBE 6712            	  2981: 	beq.s		.0001
02:00006DC0 E98A            	  2982: 	lsl.l		#4,d2
02:00006DC2 02810000000F    	  2983: 	andi.l	#$0f,d1
02:00006DC8 8481            	  2984: 	or.l		d1,d2
02:00006DCA 5240            	  2985: 	addq		#1,d0
02:00006DCC 0C000008        	  2986: 	cmpi.b	#8,d0
02:00006DD0 65E0            	  2987: 	blo.s		.0002
                            	  2988: .0001
02:00006DD2 2202            	  2989: 	move.l	d2,d1
02:00006DD4 241F            	  2990: 	move.l	(a7)+,d2
02:00006DD6 4A00            	  2991: 	tst.b		d0
02:00006DD8 4E75            	  2992: 	rts	
                            	  2993: 
                            	  2994: GetDecNumber:
02:00006DDA 48E73000        	  2995: 	movem.l d2/d3,-(a7)
02:00006DDE 7400            	  2996: 	clr.l d2
02:00006DE0 7000            	  2997: 	clr.l d0
                            	  2998: .0002
02:00006DE2 6100F8A0        	  2999: 	bsr FromScreen					; grab a character off the screen
02:00006DE6 61000558        	  3000: 	bsr	AsciiToHexNybble		; convert to an ascii nybble
02:00006DEA 0C0100FF        	  3001: 	cmpi.b #$ff,d1
02:00006DEE 6718            	  3002: 	beq.s	.0001
02:00006DF0 02810000000F    	  3003: 	andi.l #$0F,d1					; d1 = 0 to 9
02:00006DF6 2602            	  3004: 	move.l d2,d3						; d3 = current number
02:00006DF8 D683            	  3005: 	add.l d3,d3							; d3*2
02:00006DFA E78A            	  3006: 	lsl.l #3,d2							; current number * 8
02:00006DFC D483            	  3007: 	add.l d3,d2							; current number * 10
02:00006DFE D481            	  3008: 	add.l d1,d2							; add in new digit
02:00006E00 5240            	  3009: 	addq #1,d0							; increment number of digits
02:00006E02 0C000009        	  3010: 	cmpi.b #9,d0						; make sure 9 or fewer
02:00006E06 65DA            	  3011: 	blo .0002
                            	  3012: .0001
02:00006E08 2202            	  3013: 	move.l d2,d1						; return number in d1
02:00006E0A 4CDF000C        	  3014: 	movem.l (a7)+,d2/d3
02:00006E0E 4A00            	  3015: 	tst.b d0
02:00006E10 4E75            	  3016: 	rts
                            	  3017: 	
                            	  3018: 	include "FloatToString.asm"

Source: "FloatToString.asm"
                            	     1: 	code
                            	     2: ;==============================================================================
                            	     3: ; Decimal-Floating point to string conversion routine.
                            	     4: ;
                            	     5: ; Modifies
                            	     6: ;		_fpWork work area
                            	     7: ; Register Usage:
                            	     8: ; 	fp0 = input decimal-float to convert
                            	     9: ;		fp1 = constant holder, 1.0, 10.0
                            	    10: ;		fp2 = 1.0e<fp0 exponent> value for conversion
                            	    11: ;		fp3 = holds digit value during significand conversion
                            	    12: ; 	a0 = pointer to string buffer, updated to point to NULL at end of string
                            	    13: ;		a1 = pointer to "Nan" or "Inf" message string
                            	    14: ;		d0 = temporary
                            	    15: ;		d1 = digit value during exponent, significand conversion
                            	    16: ; 	d6 = exponent
                            	    17: ;==============================================================================
                            	    18: 	align 4
02:00006E20 25FF0000        	    19: _dfOne	dc.l $25ff0000,$00000000,$00000000
02:00006E24 00000000
02:00006E28 00000000
02:00006E2C 2600C000        	    20: _dfTen	dc.l $2600C000,$00000000,$00000000
02:00006E30 00000000
02:00006E34 00000000
02:00006E38 2606DDFA        	    21: _dfMil  dc.l $2606DDFA,$1C000000,$00000000
02:00006E3C 1C000000
02:00006E40 00000000
                            	    22: 
02:00006E44 4E614E          	    23: _msgNan	dc.b "NaN",0
02:00006E47 00
02:00006E48 496E66          	    24: _msgInf dc.b "Inf",0
02:00006E4B 00
                            	    25: 	even
                            	    26: 
                            	    27: ;------------------------------------------------------------------------------
                            	    28: ; Check for the special Nan and infinity values. Output the appropriate string.
                            	    29: ;
                            	    30: ; Modifies
                            	    31: ;		_fpWork area
                            	    32: ;		a0
                            	    33: ; Parameters:
                            	    34: ;		fp0 = dbl
                            	    35: ;------------------------------------------------------------------------------
                            	    36: 
                            	    37: _CheckNan:
02:00006E4C 4E52FFF4        	    38: 	link a2,#-12
02:00006E50 48D70201        	    39: 	movem.l d0/a1,(sp)
02:00006E54 2F79000400980008	    40: 	move.l _canary,8(sp)
02:00006E5C F239680000040600	    41: 	fmove.x fp0,_fpWork
02:00006E64 103900040600    	    42: 	move.b _fpWork,d0				; get sign+combo
02:00006E6A 0200007C        	    43: 	andi.b #$7C,d0					; mask for combo bits
02:00006E6E 0C00007C        	    44: 	cmpi.b #$7C,d0					; is it the Nan combo?
02:00006E72 6606            	    45: 	bne .notNan
02:00006E74 43FAFFCE        	    46: 	lea _msgNan,a1					; output "Nan"
02:00006E78 600A            	    47: 	bra .outStr
                            	    48: .notNan
02:00006E7A 0C000078        	    49: 	cmpi.b #$78,d0					; is it infinity combo?
02:00006E7E 661E            	    50: 	bne .notInf
02:00006E80 43FAFFC6        	    51: 	lea _msgInf,a1
                            	    52: .outStr
02:00006E84 10D9            	    53: 	move.b (a1)+,(a0)+			; output "Inf"
02:00006E86 10D9            	    54: 	move.b (a1)+,(a0)+
02:00006E88 10D9            	    55: 	move.b (a1)+,(a0)+
02:00006E8A 4210            	    56: 	clr.b (a0)
02:00006E8C 4CD70201        	    57: 	movem.l (sp),d0/a1
02:00006E90 A2AF00030008    	    58: 	cchk 8(sp)
02:00006E96 4E5A            	    59: 	unlk a2
02:00006E98 003C0001        	    60: 	ori #1,ccr							; set carry and return
02:00006E9C 4E75            	    61: 	rts
                            	    62: .notInf
02:00006E9E 4CD70201        	    63: 	movem.l (sp),d0/a1
02:00006EA2 A2AF00030008    	    64: 	cchk 8(sp)
02:00006EA8 4E5A            	    65: 	unlk a2
02:00006EAA 023C00FE        	    66: 	andi #$FE,ccr						; clear carry and return
02:00006EAE 4E75            	    67: 	rts
                            	    68: 
                            	    69: ;------------------------------------------------------------------------------
                            	    70: ; Check for a zero value. Output a single "0" if zero,
                            	    71: ;
                            	    72: ; Modifies:
                            	    73: ;		a0
                            	    74: ; Parameters:
                            	    75: ;		fp0 = dbl
                            	    76: ;------------------------------------------------------------------------------
                            	    77: 
                            	    78: _CheckZero:
02:00006EB0 F200003A        	    79: 	ftst fp0								; check if number is zero
02:00006EB4 F28E000E        	    80: 	fbne .0003
02:00006EB8 10FC0030        	    81: 	move.b #'0',(a0)+				; if zero output "0"
02:00006EBC 4210            	    82: 	clr.b (a0)
02:00006EBE 003C0004        	    83: 	ori #4,ccr							; set zf
02:00006EC2 4E75            	    84: 	rts
                            	    85: .0003
02:00006EC4 023C00FB        	    86: 	andi #$FB,ccr						; clear zf
02:00006EC8 4E75            	    87: 	rts
                            	    88: 
                            	    89: ;------------------------------------------------------------------------------
                            	    90: ; Check for a negative number. This includes Nans and Infinities. Output a "-"
                            	    91: ; if negative.
                            	    92: ;
                            	    93: ;	Modifies
                            	    94: ;		a0
                            	    95: ; Parameters:
                            	    96: ;		fp0 = dbl
                            	    97: ;------------------------------------------------------------------------------
                            	    98: 
                            	    99: _CheckNegative:
02:00006ECA F200003A        	   100: 	ftst fp0								; is number negative?
02:00006ECE F293000A        	   101: 	fbge .0002
02:00006ED2 10FC002D        	   102: 	move.b #'-',(a0)+				; yes, output '-'
02:00006ED6 F200001A        	   103: 	fneg fp0								; make fp0 positive
                            	   104: .0002
02:00006EDA 4E75            	   105: 	rts
                            	   106: 
                            	   107: ;------------------------------------------------------------------------------
                            	   108: ; Make the input value larger so that digits may appear before the decimal
                            	   109: ; point.
                            	   110: ;
                            	   111: ; Modifies:
                            	   112: ;		fp0,fp1,d6
                            	   113: ; Parameters:
                            	   114: ;		fp0 = dbl
                            	   115: ;------------------------------------------------------------------------------
                            	   116: 
                            	   117: ;	if (dbl < 1.0) {
                            	   118: ;		while (dbl < 1.0) {
                            	   119: ;			dbl *= 1000000.0;
                            	   120: ;			exp -= 6;  
                            	   121: ;		}
                            	   122: ;	}
                            	   123: 
                            	   124: _MakeBig:
02:00006EDC F23C50800001    	   125: 	fmove.w #1,fp1
                            	   126: .0002
02:00006EE2 F2000438        	   127: 	fcmp fp1,fp0						; is fp0 > 1?
02:00006EE6 F293000E        	   128: 	fbge .0001							; yes, return
02:00006EEA F23C402600000006	   129: 	fscale.l #6,fp0					; multiply fp0 by a million
02:00006EF2 5D46            	   130: 	subi.w #6,d6						; decrement exponent by six
02:00006EF4 60EC            	   131: 	bra .0002								; keep trying until number is > 1
                            	   132: .0001
02:00006EF6 4E75            	   133: 	rts
                            	   134: 	
                            	   135: ;------------------------------------------------------------------------------
                            	   136: ;	Create a number dbl2 on the same order of magnitude as dbl, but
                            	   137: ;	less than dbl. The number will be 1.0e<dbl's exponent>
                            	   138: ;
                            	   139: ; Modifies:
                            	   140: ;		d6,fp2
                            	   141: ; Parameters:
                            	   142: ;		fp0 = dbl
                            	   143: ;------------------------------------------------------------------------------
                            	   144: 
                            	   145: ;	// The following is similar to using log10() and pow() functions.
                            	   146: ;	// Now dbl is >= 1.0
                            	   147: ;	// Create a number dbl2 on the same order of magnitude as dbl, but
                            	   148: ;	// less than dbl.
                            	   149: ;	dbl2 = 1.0;
                            	   150: ;	dbla = dbl2;
                            	   151: ;	if (dbl > dbl2) {	// dbl > 1.0 ?
                            	   152: ;		while (dbl2 <= dbl) {
                            	   153: ;			dbla = dbl2;
                            	   154: ;			dbl2 *= 10.0;	// increase power of 10
                            	   155: ;			exp++;
                            	   156: ;		}
                            	   157: ;		// The above loop goes one too far, we want the last value less
                            	   158: ;		// than dbl.
                            	   159: ;		dbl2 = dbla;
                            	   160: ;		exp--;
                            	   161: ;	}
                            	   162: 
                            	   163: _LessThanDbl:
02:00006EF8 F23C51000001    	   164: 	fmove.w #1,fp2			; setup fp2 = 1
02:00006EFE F2000838        	   165: 	fcmp fp2,fp0				; if (dbl > dbl2)
02:00006F02 F295001E        	   166: 	fble .0004
                            	   167: .0006
02:00006F06 F2000138        	   168: 	fcmp fp0,fp2				; while (dbl2 <= dbl)
02:00006F0A F292000C        	   169: 	fbgt .0005
02:00006F0E F23C51260001    	   170: 	fscale.w #1,fp2			; dbl2 *= 10 (increase exponent by one)
02:00006F14 5246            	   171: 	addi.w #1,d6				; exp++
02:00006F16 60EE            	   172: 	bra .0006
                            	   173: .0005
02:00006F18 F23C4126FFFFFFFF	   174: 	fscale.l #-1,fp2		; dbl2 /= 10 (decrease exponent by one)
02:00006F20 5346            	   175: 	subi.w #1,d6				; exp--;
                            	   176: .0004	
                            	   177: ;	fmove.x fp0,_fpWork	; debugging
                            	   178: ;	fmove.x fp2,_fpWork+12
02:00006F22 4E75            	   179: 	rts
                            	   180: 
                            	   181: ;------------------------------------------------------------------------------
                            	   182: ; Compute the number of digits before the decimal point.
                            	   183: ;
                            	   184: ; Modifies:
                            	   185: ;		d0,d6,_digits_before_decpt
                            	   186: ; Parameters:
                            	   187: ;		d6 = exponent
                            	   188: ;------------------------------------------------------------------------------
                            	   189: 
                            	   190: ; if (exp >= 0 && exp < 6) {
                            	   191: ;   digits_before_decpt = exp+1;
                            	   192: ;		exp = 0;
                            	   193: ;	}
                            	   194: ;	else if (exp >= -7)
                            	   195: ;		digits_before_decpt = 1;
                            	   196: ;	else
                            	   197: ;		digits_before_decpt = -1;
                            	   198: 
                            	   199: _ComputeDigitsBeforeDecpt:
02:00006F24 2F00            	   200: 	move.l d0,-(a7)
02:00006F26 4A46            	   201: 	tst.w d6
02:00006F28 6B16            	   202: 	bmi .0007
02:00006F2A 0C460006        	   203: 	cmpi.w #6,d6
02:00006F2E 6C10            	   204: 	bge .0007
02:00006F30 3006            	   205: 	move.w d6,d0
02:00006F32 5240            	   206: 	addi.w #1,d0
02:00006F34 33C000040510    	   207: 	move.w d0,_digits_before_decpt	
02:00006F3A 4246            	   208: 	clr.w d6
02:00006F3C 201F            	   209: 	move.l (a7)+,d0
02:00006F3E 4E75            	   210: 	rts
                            	   211: .0007
02:00006F40 0C46FFF9        	   212: 	cmpi.w #-7,d6
02:00006F44 6D0C            	   213: 	blt .0009
02:00006F46 33FC000100040510	   214: 	move.w #1,_digits_before_decpt
02:00006F4E 201F            	   215: 	move.l (a7)+,d0
02:00006F50 4E75            	   216: 	rts
                            	   217: .0009
02:00006F52 33FCFFFF00040510	   218: 	move.w #-1,_digits_before_decpt
02:00006F5A 201F            	   219: 	move.l (a7)+,d0
02:00006F5C 4E75            	   220: 	rts
                            	   221: 
                            	   222: ;------------------------------------------------------------------------------
                            	   223: ;	Spit out a leading zero before the decimal point for a small number.
                            	   224: ;
                            	   225: ; Modifies:
                            	   226: ;		a0
                            	   227: ; Parameters:
                            	   228: ;		d6 = exponent
                            	   229: ;------------------------------------------------------------------------------
                            	   230: 
                            	   231: ;  if (exp < -7) {
                            	   232: ;		 buf[ndx] = '0';
                            	   233: ;		 ndx++;
                            	   234: ;    buf[ndx] = '.';
                            	   235: ;    ndx++;
                            	   236: ;  }
                            	   237: 
                            	   238: _LeadingZero:
02:00006F5E 0C46FFF9        	   239: 	cmpi.w #-7,d6
02:00006F62 6C08            	   240: 	bge .0010
02:00006F64 10FC0030        	   241: 	move.b #'0',(a0)+
02:00006F68 10FC002E        	   242: 	move.b #'.',(a0)+
                            	   243: .0010
02:00006F6C 4E75            	   244: 	rts
                            	   245: 
                            	   246: ;------------------------------------------------------------------------------
                            	   247: ; Extract the digits of the significand.
                            	   248: ;
                            	   249: ; Modifies:
                            	   250: ;		_precision variable
                            	   251: ; Register Usage
                            	   252: ;		d0 = counter
                            	   253: ;		d1 = digit
                            	   254: ;		fp0 = dbl
                            	   255: ;		fp2 = dbl2
                            	   256: ;		fp3 = digit as decimal float
                            	   257: ;		fp7 = dbla
                            	   258: ; Parameters:
                            	   259: ;		fp0, fp2
                            	   260: ;------------------------------------------------------------------------------
                            	   261: 
                            	   262: ;	// Now loop processing one digit at a time.
                            	   263: ;  for (nn = 0; nn < 25 && precision > 0; nn++) {
                            	   264: ;    digit = 0;
                            	   265: ;		dbla = dbl;
                            	   266: ;		// dbl is on the same order of magnitude as dbl2 so
                            	   267: ;		// a repeated subtract can be used to find the digit.
                            	   268: ;    while (dbl >= dbl2) {
                            	   269: ;      dbl -= dbl2;
                            	   270: ;      digit++;
                            	   271: ;    }
                            	   272: ;    buf[ndx] = digit + '0';
                            	   273: ;		// Now go back and perform just a single subtract and
                            	   274: ;		// a multiply to find out how much to reduce dbl by.
                            	   275: ;		// This should improve the accuracy
                            	   276: ;		if (digit > 2)
                            	   277: ;			dbl = dbla - dbl2 * digit;
                            	   278: ;    ndx++;
                            	   279: ;    digits_before_decpt--;
                            	   280: ;    if (digits_before_decpt==0) {
                            	   281: ;			buf[ndx] = '.';
                            	   282: ;			ndx++;
                            	   283: ;    }
                            	   284: ;    else if (digits_before_decpt < 0)
                            	   285: ;      precision--;
                            	   286: ;		// Shift the next digit to be tested into position.
                            	   287: ;    dbl *= 10.0;
                            	   288: ;  }
                            	   289: 	
                            	   290: _SpitOutDigits:
02:00006F6E 4E52FFE8        	   291: 	link a2,#-24
02:00006F72 2F79000400980014	   292: 	move.l _canary,20(sp)
02:00006F7A F2176B80        	   293: 	fmove.x fp7,(sp)
02:00006F7E 48EF0003000C    	   294: 	movem.l d0/d1,12(sp)
02:00006F84 303C0018        	   295: 	move.w #24,d0			; d0 = nn
                            	   296: .0017	
02:00006F88 4AB900040514    	   297: 	tst.l _precision
02:00006F8E 6F46            	   298: 	ble .0011
02:00006F90 7200            	   299: 	moveq #0,d1				; digit = 0
02:00006F92 F2000380        	   300: 	fmove fp0,fp7			; dbla = dbl
                            	   301: .0013
02:00006F96 F2000838        	   302: 	fcmp fp2,fp0
02:00006F9A F294000A        	   303: 	fblt .0012
02:00006F9E F2000828        	   304: 	fsub fp2,fp0			; dbl -= dbl2
02:00006FA2 5201            	   305: 	addi.b #1,d1			; digit++
02:00006FA4 60F0            	   306: 	bra .0013
                            	   307: .0012
02:00006FA6 06010030        	   308: 	addi.b #'0',d1		; convert digit to ascii
02:00006FAA 10C1            	   309: 	move.b d1,(a0)+		; and store
02:00006FAC 04010030        	   310: 	subi.b #'0',d1		; d1 = binary digit again
                            	   311: ;	cmpi.b #2,d1
                            	   312: ;	ble .0014
                            	   313: 
                            	   314: ;	ext.w d1
                            	   315: ;	ext.l d1
                            	   316: ;	fmove.l d1,fp3		; fp3 = digit
                            	   317: ;	fmul fp2,fp3			; fp3 = dbl2 * digit
                            	   318: ;	fmove fp7,fp0
                            	   319: ;	fsub fp3,fp0			; dbl = dbla - dbl2 * digit
                            	   320: .0014
02:00006FB0 537900040510    	   321: 	subi.w #1,_digits_before_decpt
02:00006FB6 6604            	   322: 	bne .0015
02:00006FB8 10FC002E        	   323: 	move.b #'.',(a0)+
                            	   324: .0015
02:00006FBC 4A7900040510    	   325: 	tst.w _digits_before_decpt
02:00006FC2 6C06            	   326: 	bge .0016
02:00006FC4 53B900040514    	   327: 	subi.l #1,_precision
                            	   328: .0016
02:00006FCA F23C4126FFFFFFFF	   329: 	fscale.l #-1,fp2		; dbl *= 10.0
02:00006FD2 51C8FFB4        	   330: 	dbra d0,.0017
                            	   331: .0011
02:00006FD6 4CEF0003000C    	   332: 	movem.l 12(sp),d0/d1
02:00006FDC F2174B80        	   333: 	fmove.x (sp),fp7
02:00006FE0 A2AF00030014    	   334: 	cchk 20(sp)
02:00006FE6 4E5A            	   335: 	unlk a2
02:00006FE8 4E75            	   336: 	rts
                            	   337: 
                            	   338: ;------------------------------------------------------------------------------
                            	   339: ; If the number ends in a decimal point, trim off the point.
                            	   340: ;
                            	   341: ; Registers Modified:
                            	   342: ;		none
                            	   343: ; Parameters:
                            	   344: ;		a0 = pointer to end of number
                            	   345: ; Returns:
                            	   346: ;		a0 = updated to point just past last digit.
                            	   347: ;------------------------------------------------------------------------------
                            	   348: 
                            	   349: _TrimTrailingPoint:
02:00006FEA 0C28002EFFFF    	   350: 	cmpi.b #'.',-1(a0)
02:00006FF0 6604            	   351: 	bne .0001
02:00006FF2 4220            	   352: 	clr.b -(a0)
02:00006FF4 4E75            	   353: 	rts
                            	   354: .0001
02:00006FF6 0C10002E        	   355: 	cmpi.b #'.',(a0)
02:00006FFA 660A            	   356: 	bne .0002
02:00006FFC 4A280001        	   357: 	cmpi.b #0,1(a0)
02:00007000 6604            	   358: 	bne .0002
02:00007002 4210            	   359: 	clr.b (a0)
02:00007004 5348            	   360: 	subq #1,a0
                            	   361: .0002
02:00007006 4E75            	   362: 	rts
                            	   363: 	
                            	   364: ;------------------------------------------------------------------------------
                            	   365: ; If the number ends in .0 get rid of the .0
                            	   366: ;
                            	   367: ; Registers Modified:
                            	   368: ;		none
                            	   369: ; Parameters:
                            	   370: ;		a0 = pointer to last digits of number
                            	   371: ; Returns:
                            	   372: ;		a0 = updated to point just past last digit.
                            	   373: ;------------------------------------------------------------------------------
                            	   374: 
                            	   375: _TrimDotZero:
02:00007008 4A10            	   376: 	tst.b (a0)
02:0000700A 6616            	   377: 	bne .0004
02:0000700C 0C280030FFFF    	   378: 	cmpi.b #'0',-1(a0)
02:00007012 660E            	   379: 	bne .0004
02:00007014 0C28002EFFFE    	   380: 	cmpi.b #'.',-2(a0)
02:0000701A 6606            	   381: 	bne .0004
02:0000701C 4228FFFE        	   382: 	clr.b -2(a0)
02:00007020 5548            	   383: 	subq #2,a0
                            	   384: .0004
02:00007022 4E75            	   385: 	rts
                            	   386: 
                            	   387: ;------------------------------------------------------------------------------
                            	   388: ; Trim trailing zeros from the number. Generally there is no need to display
                            	   389: ; trailing zeros.
                            	   390: ; Turns a number like 652.000000000000000000000 into 650.0
                            	   391: ;
                            	   392: ; Registers Modified:
                            	   393: ;		none
                            	   394: ; Parameters:
                            	   395: ;		a0 = pointer to last digits of number
                            	   396: ; Returns:
                            	   397: ;		a0 = updated to point just past last digit.
                            	   398: ;------------------------------------------------------------------------------
                            	   399: 
                            	   400: ;	// Trim trailing zeros from the number
                            	   401: ;  do {
                            	   402: ;      ndx--;
                            	   403: ;  } while(buf[ndx]=='0');
                            	   404: ;  ndx++;
                            	   405: 
                            	   406: _TrimTrailingZeros:
                            	   407: .0018	
02:00007024 0C200030        	   408: 	cmpi.b #'0',-(a0)		; if the last digit was a zero, backup
02:00007028 67FA            	   409: 	beq .0018
02:0000702A 5248            	   410: 	addq #1,a0					; now advance by one
02:0000702C 4210            	   411: 	move.b #0,(a0)			; NULL terminate string
02:0000702E 4E75            	   412: 	rts
                            	   413: 
                            	   414: ;------------------------------------------------------------------------------
                            	   415: ; Output 'e+' or 'e-'
                            	   416: ;
                            	   417: ; Registers Modified:
                            	   418: ;		d6.w (if negative)
                            	   419: ; Parameters:
                            	   420: ;		a0 = pointer to last digits of number
                            	   421: ; Returns:
                            	   422: ;		a0 = updated to point just past '+' or '-'.
                            	   423: ;------------------------------------------------------------------------------
                            	   424: 
                            	   425: ;	// Spit out +/-E
                            	   426: ;  buf[ndx] = E;
                            	   427: ;  ndx++;
                            	   428: ;  if (exp < 0) {
                            	   429: ;    buf[ndx]='-';
                            	   430: ;    ndx++;
                            	   431: ;    exp = -exp;
                            	   432: ;  }
                            	   433: ;  else {
                            	   434: ;		buf[ndx]='+';
                            	   435: ;		ndx++;
                            	   436: ;  }
                            	   437: 
                            	   438: _SpitOutE:	
02:00007030 10F90004050C    	   439: 	move.b _E,(a0)+
02:00007036 4A46            	   440: 	tst.w d6
02:00007038 6C08            	   441: 	bge .0021
02:0000703A 10FC002D        	   442: 	move.b #'-',(a0)+
02:0000703E 4446            	   443: 	neg.w d6
02:00007040 6004            	   444: 	bra .0022
                            	   445: .0021
02:00007042 10FC002B        	   446: 	move.b #'+',(a0)+
                            	   447: .0022
02:00007046 4E75            	   448: 	rts
                            	   449: 
                            	   450: ;------------------------------------------------------------------------------
                            	   451: ; Extract a single digit of the exponent. Extract works from the leftmost digit
                            	   452: ; to the rightmost.
                            	   453: ;
                            	   454: ; Register Usage
                            	   455: ;		d2 = history of zeros
                            	   456: ;		d3 = digit
                            	   457: ; Modifies
                            	   458: ;		d2,d6,a0
                            	   459: ; Parameter
                            	   460: ; 	d1.w = power of ten
                            	   461: ;		d6.w = exponent
                            	   462: ;------------------------------------------------------------------------------
                            	   463: 
                            	   464: _ExtExpDigit:
02:00007048 2F03            	   465: 	move.l d3,-(a7)
02:0000704A 48C6            	   466: 	ext.l d6				; make d6 a long
02:0000704C 8CC1            	   467: 	divu d1,d6			; divide by power of ten
02:0000704E 1606            	   468: 	move.b d6,d3		; d3 = quotient (0 to 9)
02:00007050 4846            	   469: 	swap d6					; d6 = remainder, setup for next digit
02:00007052 8403            	   470: 	or.b d3,d2
02:00007054 4A03            	   471: 	tst.b d3
02:00007056 6604            	   472: 	bne .0003
02:00007058 4A02            	   473: 	tst.b d2	
02:0000705A 6706            	   474: 	beq .0004
                            	   475: .0003
02:0000705C 06030030        	   476: 	addi.b #'0',d3	; convert to ascii
02:00007060 10C3            	   477: 	move.b d3,(a0)+
                            	   478: .0004
02:00007062 261F            	   479: 	move.l (a7)+,d3
02:00007064 4E75            	   480: 	rts
                            	   481: 
                            	   482: ;------------------------------------------------------------------------------
                            	   483: ; Extract all the digits of the exponent.
                            	   484: ;
                            	   485: ; Register Usage
                            	   486: ;		d1 = power of 10
                            	   487: ;		d2 = history of zeros
                            	   488: ; Parameters
                            	   489: ;		a0 = pointer to string buffer
                            	   490: ;		d6 = exponent
                            	   491: ;------------------------------------------------------------------------------
                            	   492: 
                            	   493: ;	// If the number is times 10^0 don't output the exponent
                            	   494: ;  if (exp==0) {
                            	   495: ;    buf[ndx]='\0';
                            	   496: ;    goto prt;
                            	   497: ;  }
                            	   498: 
                            	   499: _ExtExpDigits:
02:00007066 2F01            	   500: 	move.l d1,-(a7)
02:00007068 4A46            	   501: 	tst.w d6							; is exponent zero?
02:0000706A 671C            	   502: 	beq .0002
02:0000706C 61C2            	   503: 	bsr _SpitOutE					; exponent is non-zero e+
02:0000706E 4202            	   504: 	clr.b d2							; d2 = history of zeros
02:00007070 323C03E8        	   505: 	move.w #1000,d1
02:00007074 61D2            	   506: 	bsr _ExtExpDigit
02:00007076 323C0064        	   507: 	move.w #100,d1
02:0000707A 61CC            	   508: 	bsr _ExtExpDigit
02:0000707C 323C000A        	   509: 	move.w #10,d1
02:00007080 61C6            	   510: 	bsr _ExtExpDigit
02:00007082 323C0001        	   511: 	move.w #1,d1
02:00007086 61C0            	   512: 	bsr _ExtExpDigit
                            	   513: .0002:
02:00007088 221F            	   514: 	move.l (a7)+,d1
02:0000708A 4210            	   515: 	move.b #0,(a0)				; NULL terminate string
02:0000708C 4E75            	   516: 	rts										; and return
                            	   517: 
                            	   518: ;------------------------------------------------------------------------------
                            	   519: ; Pad the left side of the output string.
                            	   520: ;
                            	   521: ; Modifies:
                            	   522: ;		d0,d1,d2,d3
                            	   523: ;------------------------------------------------------------------------------
                            	   524: 
                            	   525: ;  // pad left
                            	   526: ;  if (width > 0) {
                            	   527: ;    if (ndx < width) {
                            	   528: ;      for (nn = 39; nn >= width-ndx; nn--)
                            	   529: ;        buf[nn] = buf[nn-(width-ndx)];
                            	   530: ;      for (; nn >= 0; nn--)
                            	   531: ;        buf[nn] = ' ';
                            	   532: ;    }
                            	   533: ;  }
                            	   534: 	
                            	   535: _PadLeft:
02:0000708E 48E7F000        	   536: 	movem.l d0/d1/d2/d3,-(a7)
02:00007092 4A3900040508    	   537: 	tst.b _width
02:00007098 6F3E            	   538: 	ble .0041
02:0000709A 2008            	   539: 	move.l a0,d0
02:0000709C 90BC00040520    	   540: 	sub.l #_fpBuf,d0	; d0 = ndx
02:000070A2 B03900040508    	   541: 	cmp.b _width,d0
02:000070A8 6C2E            	   542: 	bge .0041
02:000070AA 323C0031        	   543: 	move.w #49,d1			; d1 = nn
                            	   544: .0040
02:000070AE 143900040508    	   545: 	move.b _width,d2
02:000070B4 4882            	   546: 	ext.w d2
02:000070B6 9440            	   547: 	sub.w d0,d2				; d2 = width-ndx
02:000070B8 B242            	   548: 	cmp.w d2,d1
02:000070BA 6D0E            	   549: 	blt .0039
02:000070BC 3601            	   550: 	move.w d1,d3			; d3 = nn
02:000070BE 9642            	   551: 	sub.w d2,d3				; d3 = nn-(width-ndx)
02:000070C0 11B030001000    	   552: 	move.b (a0,d3.w),(a0,d1.w)
02:000070C6 5341            	   553: 	subi.w #1,d1
02:000070C8 60E4            	   554: 	bra .0040
                            	   555: .0039
02:000070CA 4A41            	   556: 	tst.w d1
02:000070CC 6B0A            	   557: 	bmi .0041
02:000070CE 11BC00201000    	   558: 	move.b #' ',(a0,d1.w)
02:000070D4 5341            	   559: 	subi.w #1,d1
02:000070D6 60F2            	   560: 	bra .0039
                            	   561: .0041
02:000070D8 4CDF000F        	   562: 	movem.l (a7)+,d0/d1/d2/d3
02:000070DC 4E75            	   563: 	rts
                            	   564: 
                            	   565: ;------------------------------------------------------------------------------
                            	   566: ; Pad the right side of the output string.
                            	   567: ;
                            	   568: ; Parameters:
                            	   569: ;		a0 = pointer to end of string
                            	   570: ; Modifies:
                            	   571: ;		none
                            	   572: ; Returns:
                            	   573: ;		none
                            	   574: ;------------------------------------------------------------------------------
                            	   575: 
                            	   576: ;  // pad right
                            	   577: ;  if (width < 0) {
                            	   578: ;    width = -width;
                            	   579: ;    while (ndx < width) {
                            	   580: ;      buf[ndx]=' ';
                            	   581: ;      ndx++;
                            	   582: ;    }
                            	   583: ;    buf[ndx]='\0';
                            	   584: ;  }
                            	   585: ;  return (ndx);
                            	   586: 
                            	   587: _PadRight:
02:000070DE 2F00            	   588: 	move.l d0,-(a7)
02:000070E0 4A3900040508    	   589: 	tst.b _width
02:000070E6 6A24            	   590: 	bpl .0042
02:000070E8 443900040508    	   591: 	neg.b _width
02:000070EE 2008            	   592: 	move.l a0,d0
02:000070F0 90BC00040520    	   593: 	sub.l #_fpBuf,d0	; d0 = ndx
                            	   594: .0044
02:000070F6 B03900040508    	   595: 	cmp.b _width,d0
02:000070FC 6C0A            	   596: 	bge .0043
02:000070FE 11BC00200000    	   597: 	move.b #' ',(a0,d0.w)
02:00007104 5240            	   598: 	addi.w #1,d0
02:00007106 60EE            	   599: 	bra .0044
                            	   600: .0043
02:00007108 42300000        	   601: 	move.b #0,(a0,d0.w)
                            	   602: .0042
02:0000710C 201F            	   603: 	move.l (a7)+,d0
02:0000710E 4E75            	   604: 	rts
                            	   605: 
                            	   606: ;------------------------------------------------------------------------------
                            	   607: ; Output a string representation of a decimal floating point number to a 
                            	   608: ; buffer.
                            	   609: ;
                            	   610: ; Register Usage
                            	   611: ;		a0 = pointer to string buffer
                            	   612: ;		d6 = exponent
                            	   613: ; Modifies:
                            	   614: ;		a0 = points to end of string
                            	   615: ; Parameters:
                            	   616: ;		fp0 = number to convert
                            	   617: ; Returns:
                            	   618: ;		none
                            	   619: ;------------------------------------------------------------------------------
                            	   620: 
                            	   621: _FloatToString:
02:00007110 2F06            	   622: 	move.l d6,-(a7)
02:00007112 6100FDB6        	   623: 	bsr _CheckNegative			; is number negative?
02:00007116 6100FD98        	   624: 	bsr _CheckZero					; check for zero
02:0000711A 6732            	   625: 	beq .0001								; branch since already output "0"
02:0000711C 6100FD2E        	   626: 	bsr _CheckNan						; check for Nan or infinity
02:00007120 652C            	   627: 	bcs .0001								; branch if nan/inf string output
                            	   628: 	; Now the fun begins
02:00007122 7C00            	   629: 	clr.l d6								; exponent = 0
02:00007124 6100FDB6        	   630: 	bsr _MakeBig
02:00007128 6100FDCE        	   631: 	bsr _LessThanDbl
02:0000712C 6100FDF6        	   632: 	bsr _ComputeDigitsBeforeDecpt
02:00007130 6100FE2C        	   633: 	bsr _LeadingZero
02:00007134 6100FE38        	   634: 	bsr _SpitOutDigits
02:00007138 6100FEEA        	   635: 	bsr _TrimTrailingZeros
02:0000713C 6100FEAC        	   636: 	bsr _TrimTrailingPoint
02:00007140 6100FEC6        	   637: 	bsr _TrimDotZero
02:00007144 6100FF20        	   638: 	bsr _ExtExpDigits				; extract exponent digits
02:00007148 6100FF44        	   639: 	bsr _PadLeft						; pad the number to the left or right
02:0000714C 6190            	   640: 	bsr _PadRight
                            	   641: .0001
02:0000714E 2C1F            	   642: 	move.l (a7)+,d6
02:00007150 4E75            	   643: 	rts
                            	   644: 
                            	   645: 

Source: "boot.x68"
                            	  3019: 	include "GetFloat.asm"

Source: "GetFloat.asm"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;
                            	    37: ; Get a floating point number
                            	    38: ;
                            	    39: _GetFloatGetChar:
02:00007152 1210            	    40: 	move.b (a0),d1
02:00007154 D1C0            	    41: 	add.l d0,a0
02:00007156 4E75            	    42: 	rts
                            	    43: _GetFloatIgnBlanks:
                            	    44: .0001
02:00007158 61F8            	    45: 	bsr _GetFloatGetChar
02:0000715A 0C010020        	    46: 	cmpi.b #' ',d1
02:0000715E 67F8            	    47: 	beq .0001
                            	    48: _GetFloatBackupChar:
02:00007160 91C0            	    49: 	sub.l d0,a0
02:00007162 4E75            	    50: 	rts
                            	    51: 
                            	    52: ;-------------------------------------------------------------------------------
                            	    53: ; Get fractional part of a number, 25 digits max, into a float register.
                            	    54: ;
                            	    55: ; Register Usage:
                            	    56: ;		d1 = digit from input screen
                            	    57: ;		d4 = digit count
                            	    58: ;		d6 = digit scaling factor
                            	    59: ;		fp1 = digit as float number
                            	    60: ; Returns:
                            	    61: ;		fp0 = fraction
                            	    62: ;-------------------------------------------------------------------------------
                            	    63: 
                            	    64: _GetFraction:
02:00007164 4E52FFE4        	    65: 	link a2,#-28
02:00007168 2F79000400980018	    66: 	move.l _canary,24(sp)
02:00007170 48D70052        	    67: 	movem.l d1/d4/d6,(sp)
02:00007174 F22F6880000C    	    68: 	fmove.x fp1,12(sp)
02:0000717A 7C00            	    69: 	clr.l d6							; d6 = scale factor
02:0000717C F23C50000000    	    70: 	fmove.w #0,fp0				; fract = 0.0
02:00007182 7818            	    71: 	moveq #24,d4
                            	    72: .0002
02:00007184 61CC            	    73: 	bsr _GetFloatGetChar
02:00007186 0C010030        	    74: 	cmpi.b #'0',d1
02:0000718A 6520            	    75: 	blo .0001
02:0000718C 0C010039        	    76: 	cmpi.b #'9',d1				; make sure between 0 and 9
02:00007190 621A            	    77: 	bhi .0001
02:00007192 04010030        	    78: 	subi.b #'0',d1
02:00007196 F23C50260001    	    79: 	fscale.w #1,fp0				; fract * 10.0
02:0000719C 5246            	    80: 	addq #1,d6						; record scaling
02:0000719E F2015880        	    81: 	fmove.b d1,fp1				; fp1 = digit
02:000071A2 F2000422        	    82: 	fadd fp1,fp0					; fract += digit
02:000071A6 5245            	    83: 	addq.w #1,d5					; increment number of digits in number
02:000071A8 51CCFFDA        	    84: 	dbra d4,.0002
                            	    85: .0001
02:000071AC 61B2            	    86: 	bsr _GetFloatBackupChar
02:000071AE 4446            	    87: 	neg d6
02:000071B0 F2064026        	    88: 	fscale.l d6,fp0				; fract /= scale
02:000071B4 4CD70052        	    89: 	movem.l (sp),d1/d4/d6
02:000071B8 F22F4880000C    	    90: 	fmove.x 12(sp),fp1
02:000071BE A2AF00030018    	    91: 	cchk 24(sp)
02:000071C4 4E5A            	    92: 	unlk a2
02:000071C6 4E75            	    93: 	rts
                            	    94: 
                            	    95: ;-------------------------------------------------------------------------------
                            	    96: ; Get exponent part of a number, 4 digits max, into a float register.
                            	    97: ;
                            	    98: ; Register Usage:
                            	    99: ;		d1 = digit from input screen
                            	   100: ;		d2 = exponent
                            	   101: ;		d3 = temp, number times 2
                            	   102: ;		d4 = digit counter
                            	   103: ; Parameters:
                            	   104: ;		fp0 = float number
                            	   105: ; Returns:
                            	   106: ;		fp0 = float number with exponent factored in
                            	   107: ;-------------------------------------------------------------------------------
                            	   108: 
                            	   109: _GetExponent:
02:000071C8 4E52FFE0        	   110: 	link a2,#-32
02:000071CC 2F7900040098001C	   111: 	move.l _canary,28(sp)
02:000071D4 48D7001E        	   112: 	movem.l d1/d2/d3/d4,(sp)
02:000071D8 F22F69000010    	   113: 	fmove.x fp2,16(sp)
02:000071DE 7400            	   114: 	clr.l d2							; d2 = number = 0
02:000071E0 F23C51000000    	   115: 	fmove.w #0,fp2				; fp2 = exp = 0.0
02:000071E6 7601            	   116: 	moveq #1,d3						; d3 = exscale = 1
02:000071E8 6100FF68        	   117: 	bsr _GetFloatGetChar
02:000071EC 0C01002D        	   118: 	cmpi.b #'-',d1
02:000071F0 6608            	   119: 	bne .0001
02:000071F2 4483            	   120: 	neg.l d3							; exscale = -1
                            	   121: .0006
02:000071F4 6100FF62        	   122: 	bsr _GetFloatIgnBlanks
02:000071F8 600A            	   123: 	bra .0002
                            	   124: .0001
02:000071FA 0C01002B        	   125: 	cmpi.b #'+',d1
02:000071FE 67F4            	   126: 	beq .0006
02:00007200 6100FF5E        	   127: 	bsr _GetFloatBackupChar
                            	   128: .0002	
02:00007204 7803            	   129: 	moveq #3,d4						; d4 = max 4 digits
                            	   130: .0004
02:00007206 6100FF4A        	   131: 	bsr _GetFloatGetChar	; d1 = digit char
02:0000720A 0C010030        	   132: 	cmpi.b #'0',d1
02:0000720E 651E            	   133: 	blo .0003
02:00007210 0C010039        	   134: 	cmpi.b #'9',d1				; ensure between 0 and 9
02:00007214 6218            	   135: 	bhi .0003
02:00007216 04010030        	   136: 	subi.b #'0',d1
02:0000721A D482            	   137: 	add.l d2,d2						; number *2
02:0000721C 2602            	   138: 	move.l d2,d3
02:0000721E E58A            	   139: 	lsl.l #2,d2						; number *8
02:00007220 D483            	   140: 	add.l d3,d2						; number *10	
02:00007222 4881            	   141: 	ext.w d1
02:00007224 48C1            	   142: 	ext.l d1
02:00007226 D481            	   143: 	add.l d1,d2						; number + digit
02:00007228 5245            	   144: 	addq.w #1,d5					; increment number of digits in number
02:0000722A 51CCFFDA        	   145: 	dbra d4,.0004
                            	   146: .0003
02:0000722E 6100FF30        	   147: 	bsr _GetFloatBackupChar	; backup a character
02:00007232 C4C3            	   148: 	mulu d3,d2						; *1 or *-1
02:00007234 48C2            	   149: 	ext.l d2
02:00007236 F2024126        	   150: 	fscale.l d2,fp2				; exp * exmul
02:0000723A F2000823        	   151: 	fmul fp2,fp0					; rval *= exp
02:0000723E 4CD7001E        	   152: 	movem.l (sp),d1/d2/d3/d4
02:00007242 F22F49000010    	   153: 	fmove.x 16(sp),fp2
02:00007248 A2AF0003001C    	   154: 	cchk 28(sp)
02:0000724E 4E5A            	   155: 	unlk a2
02:00007250 4E75            	   156: 	rts	
                            	   157: 
                            	   158: ;-------------------------------------------------------------------------------
                            	   159: ; Get an integer number, positive or negative, 25 digits max, into a float
                            	   160: ; register.
                            	   161: ;
                            	   162: ; Register Usage:
                            	   163: ;		d1 = digit from input screen
                            	   164: ;		d2 = digit down counter
                            	   165: ;		d3 = sign of number '+' or '-'
                            	   166: ;		fp1 = digit
                            	   167: ; Modifies:
                            	   168: ;		a0,fp0
                            	   169: ; Returns:
                            	   170: ;		a0 = updated buffer pointer
                            	   171: ;		fp0 = integer number
                            	   172: ;-------------------------------------------------------------------------------
                            	   173: 
                            	   174: _GetInteger:
02:00007252 4E52FFE4        	   175: 	link a2,#-28
02:00007256 2F79000400980018	   176: 	move.l _canary,24(sp)
02:0000725E 48D7000E        	   177: 	movem.l d1/d2/d3,(sp)
02:00007262 F22F6880000C    	   178: 	fmove.x fp1,12(sp)
02:00007268 F23C50000000    	   179: 	fmove.w #0,fp0
02:0000726E 7418            	   180: 	moveq #24,d2					; d2 = digit count (25 max)
02:00007270 6100FEE6        	   181: 	bsr _GetFloatIgnBlanks
02:00007274 6100FEDC        	   182: 	bsr _GetFloatGetChar	; get the sign of the number
02:00007278 0C01002B        	   183: 	cmpi.b #'+',d1
02:0000727C 670A            	   184: 	beq .0002
                            	   185: .0003
02:0000727E 0C01002D        	   186: 	cmpi.b #'-',d1
02:00007282 6608            	   187: 	bne .0004
02:00007284 1E3C002D        	   188: 	move.b #'-',d7
                            	   189: .0002
02:00007288 6100FEC8        	   190: 	bsr _GetFloatGetChar
                            	   191: .0004
02:0000728C 0C010030        	   192: 	cmpi.b #'0',d1				; only characters 0 to 9 valid
02:00007290 651E            	   193: 	blo .0001
02:00007292 0C010039        	   194: 	cmpi.b #'9',d1
02:00007296 6218            	   195: 	bhi .0001
02:00007298 04010030        	   196: 	subi.b #'0',d1
02:0000729C F23C50260001    	   197: 	fscale.w #1,fp0				; number *10
02:000072A2 F2015880        	   198: 	fmove.b d1,fp1				; fp1 = digit
02:000072A6 F2000422        	   199: 	fadd fp1,fp0
02:000072AA 5245            	   200: 	addq.w #1,d5
02:000072AC 51CAFFDA        	   201: 	dbra d2,.0002
                            	   202: .0001
02:000072B0 6100FEAE        	   203: 	bsr _GetFloatBackupChar
02:000072B4 4CD7000E        	   204: 	movem.l (sp),d1/d2/d3
02:000072B8 F22F4880000C    	   205: 	fmove.x 12(sp),fp1
02:000072BE A2AF00030018    	   206: 	cchk 24(sp)
02:000072C4 4E5A            	   207: 	unlk a2
02:000072C6 4E75            	   208: 	rts
                            	   209: 		
                            	   210: ;-------------------------------------------------------------------------------
                            	   211: ; Get a floating point number off the input screen.
                            	   212: ;
                            	   213: ; Parameters:
                            	   214: ;		a0 = pointer to buffer containing string
                            	   215: ;		d0 = stride of buffer (increment / decrement amount)
                            	   216: ; Register Usage:
                            	   217: ;		d1 = character from input screen
                            	   218: ;		d5.lo = number of digits in number, d5.hi = number of characters fetched
                            	   219: ; Returns:
                            	   220: ;		fp0 = number
                            	   221: ;		a0 = updated buffer pointer
                            	   222: ;		d0 = length of number >0 if a number
                            	   223: ;-------------------------------------------------------------------------------
                            	   224: 
                            	   225: _GetFloat:
02:000072C8 4E52FFE0        	   226: 	link a2,#-32
02:000072CC 2F7900040098001C	   227: 	move.l _canary,28(sp)
02:000072D4 48D702A2        	   228: 	movem.l d1/d5/d7/a1,(sp)
02:000072D8 F22F69000010    	   229: 	fmove.x fp2,16(sp)
02:000072DE 7A00            	   230: 	clr.l d5
02:000072E0 1E3C002B        	   231: 	move.b #'+',d7				; assume a positive number
02:000072E4 2248            	   232: 	move.l a0,a1					; a1 = copy of pointer to buffer
02:000072E6 6100FF6A        	   233: 	bsr _GetInteger				; rval = integer
02:000072EA F2000100        	   234: 	fmove.x fp0,fp2
02:000072EE 6100FE62        	   235: 	bsr _GetFloatGetChar
02:000072F2 0C01002E        	   236: 	cmpi.b #'.',d1
02:000072F6 6706            	   237: 	beq .0004
                            	   238: .0005
02:000072F8 6100FE66        	   239: 	bsr _GetFloatBackupChar
02:000072FC 601C            	   240: 	bra .0002
                            	   241: .0004
02:000072FE 6100FE64        	   242: 	bsr _GetFraction
02:00007302 F2000822        	   243: 	fadd fp2,fp0					; rval += fraction
02:00007306 6100FE4A        	   244: 	bsr _GetFloatGetChar
02:0000730A 0C010065        	   245: 	cmpi.b #'e',d1				; accept either 'e' or 'E' indicating exponent
02:0000730E 6706            	   246: 	beq .0001
02:00007310 0C010045        	   247: 	cmpi.b #'E',d1
02:00007314 66E2            	   248: 	bne .0005
                            	   249: .0001
02:00007316 6100FEB0        	   250: 	bsr _GetExponent			; factor exponent into fp0
                            	   251: .0002
02:0000731A 0C07002D        	   252: 	cmpi.b #'-',d7				; adjust number for sign
02:0000731E 6604            	   253: 	bne .0003
02:00007320 F200001A        	   254: 	fneg fp0
                            	   255: .0003
02:00007324 93C8            	   256: 	suba.l a0,a1					; compute number of characters fetched
02:00007326 3009            	   257: 	move.w a1,d0					; move it to d0.hi
02:00007328 4840            	   258: 	swap d0
02:0000732A 3005            	   259: 	move.w d5,d0					; return digit/character count in d0 (non zero for a number)
02:0000732C 4CD702A2        	   260: 	movem.l (sp),d1/d5/d7/a1
02:00007330 F22F49000010    	   261: 	fmove.x 16(sp),fp2
02:00007336 A2AF0003001C    	   262: 	cchk 28(sp)
02:0000733C 4E5A            	   263: 	unlk a2
02:0000733E 4E75            	   264: 	rts	
                            	   265: 
                            	   266: 		

Source: "boot.x68"
                            	  3020: 
                            	  3021: ;------------------------------------------------------------------------------
                            	  3022: ; Convert ASCII character in the range '0' to '9', 'a' tr 'f' or 'A' to 'F'
                            	  3023: ; to a hex nybble.
                            	  3024: ;------------------------------------------------------------------------------
                            	  3025: 
                            	  3026: AsciiToHexNybble:
02:00007340 0C010030        	  3027: 	cmpi.b	#'0',d1
02:00007344 6530            	  3028: 	blo.s		gthx3
02:00007346 0C010039        	  3029: 	cmpi.b	#'9',d1
02:0000734A 6206            	  3030: 	bhi.s		gthx5
02:0000734C 04010030        	  3031: 	subi.b	#'0',d1
02:00007350 4E75            	  3032: 	rts
                            	  3033: gthx5:
02:00007352 0C010041        	  3034: 	cmpi.b	#'A',d1
02:00007356 651E            	  3035: 	blo.s		gthx3
02:00007358 0C010046        	  3036: 	cmpi.b	#'F',d1
02:0000735C 6206            	  3037: 	bhi.s		gthx6
02:0000735E 060100C9        	  3038: 	addi.b	#10-'A',d1
02:00007362 4E75            	  3039: 	rts
                            	  3040: gthx6:
02:00007364 0C010061        	  3041: 	cmpi.b	#'a',d1
02:00007368 650C            	  3042: 	blo.s		gthx3
02:0000736A 0C010066        	  3043: 	cmpi.b	#'f',d1
02:0000736E 6206            	  3044: 	bhi.s		gthx3
02:00007370 060100A9        	  3045: 	addi.b	#10-'a',d1
02:00007374 4E75            	  3046: 	rts
                            	  3047: gthx3:
02:00007376 72FF            	  3048: 	moveq	#-1,d1		; not a hex number
02:00007378 4E75            	  3049: 	rts
                            	  3050: 
                            	  3051: ;------------------------------------------------------------------------------
                            	  3052: ;------------------------------------------------------------------------------
                            	  3053: 
                            	  3054: DisplayTwoSpaces:
02:0000737A 2F01            	  3055: 	move.l	d1,-(a7)
02:0000737C 123C0020        	  3056: 	move.b	#' ',d1
02:00007380 6100E55E        	  3057: 	bsr			DisplayChar
                            	  3058: dspspc1:
02:00007384 6100E55A        	  3059: 	bsr			DisplayChar
02:00007388 221F            	  3060: 	move.l	(a7)+,d1
02:0000738A 4E75            	  3061: 	rts
                            	  3062: 
                            	  3063: DisplaySpace:
02:0000738C 2F01            	  3064: 	move.l	d1,-(a7)
02:0000738E 123C0020        	  3065: 	move.b	#' ',d1
02:00007392 60F0            	  3066: 	bra			dspspc1
                            	  3067: 
                            	  3068: ;------------------------------------------------------------------------------
                            	  3069: ; Display the 32 bit word in D1.L
                            	  3070: ;------------------------------------------------------------------------------
                            	  3071: 
                            	  3072: DisplayTetra:
02:00007394 4841            	  3073: 	swap	d1
02:00007396 6102            	  3074: 	bsr		DisplayWyde
02:00007398 4841            	  3075: 	swap	d1
                            	  3076: 
                            	  3077: ;------------------------------------------------------------------------------
                            	  3078: ; Display the byte in D1.W
                            	  3079: ;------------------------------------------------------------------------------
                            	  3080: 
                            	  3081: DisplayWyde:
02:0000739A E059            	  3082: 	ror.w		#8,d1
02:0000739C 6102            	  3083: 	bsr			DisplayByte
02:0000739E E159            	  3084: 	rol.w		#8,d1
                            	  3085: 
                            	  3086: ;------------------------------------------------------------------------------
                            	  3087: ; Display the byte in D1.B
                            	  3088: ;------------------------------------------------------------------------------
                            	  3089: 
                            	  3090: DisplayByte:
02:000073A0 E819            	  3091: 	ror.b		#4,d1
02:000073A2 6102            	  3092: 	bsr			DisplayNybble
02:000073A4 E919            	  3093: 	rol.b		#4,d1
                            	  3094: 
                            	  3095: ;------------------------------------------------------------------------------
                            	  3096: ; Display nybble in D1.B
                            	  3097: ;------------------------------------------------------------------------------
                            	  3098: 
                            	  3099: DisplayNybble:
02:000073A6 2F01            	  3100: 	move.l	d1,-(a7)
02:000073A8 0201000F        	  3101: 	andi.b	#$F,d1
02:000073AC 06010030        	  3102: 	addi.b	#'0',d1
02:000073B0 0C010039        	  3103: 	cmpi.b	#'9',d1
02:000073B4 6302            	  3104: 	bls.s		.0001
02:000073B6 5E01            	  3105: 	addi.b	#7,d1
                            	  3106: .0001:
02:000073B8 6100E526        	  3107: 	bsr			DisplayChar
02:000073BC 221F            	  3108: 	move.l	(a7)+,d1
02:000073BE 4E75            	  3109: 	rts
                            	  3110: 
                            	  3111: ;------------------------------------------------------------------------------
                            	  3112: ;------------------------------------------------------------------------------
                            	  3113: ;
                            	  3114: ;DisplayHexNumber:
                            	  3115: ;	move.w	#$A6A6,leds		; diagnostics
                            	  3116: ;	move.l	#VDGREG,a6
                            	  3117: ;	move.w	#7,d2		; number-1 of digits to display
                            	  3118: ;disphnum1:
                            	  3119: ;	move.b	d1,d0		; get digit into d0.b
                            	  3120: ;	andi.w	#$0f,d0
                            	  3121: ;	cmpi.w	#$09,d0
                            	  3122: ;	bls.s	disphnum2
                            	  3123: ;	addi.w	#7,d0
                            	  3124: ;disphnum2:
                            	  3125: ;	addi.w	#$30,d0	; convert to display char
                            	  3126: ;	move.w	d2,d3		; char count into d3
                            	  3127: ;	asl.w	#3,d3		; scale * 8
                            	  3128: ;disphnum3:
                            	  3129: ;	move.w	$42C(a6),d4			; read character queue index into d4
                            	  3130: ;	cmp.w	#28,d4					; allow up 28 entries to be in progress
                            	  3131: ;	bhs.s	disphnum3				; branch if too many chars queued
                            	  3132: ;	ext.w	d0						; zero out high order bits
                            	  3133: ;	move.w	d0,$420(a6)			; set char code
                            	  3134: ;	move.w	#WHITE,$422(a6)		; set fg color
                            	  3135: ;	move.w	#DARK_BLUE,$424(a6)	; set bk color
                            	  3136: ;	move.w	d3,$426(a6)			; set x pos
                            	  3137: ;	move.w	#8,$428(a6)			; set y pos
                            	  3138: ;	move.w	#$0707,$42A(a6)		; set font x,y extent
                            	  3139: ;	move.w	#0,$42E(a6)			; pulse character queue write signal
                            	  3140: ;	ror.l	#4,d1					; rot to next digit
                            	  3141: ;	dbeq	d2,disphnum1
                            	  3142: ;	jmp		(a5)
                            	  3143: 
                            	  3144: 	include "ramtest.x68"

Source: "ramtest.x68"
                            	     1: ;===============================================================================
                            	     2: ;    Perform ram test. (Uses checkerboard testing).
                            	     3: ; 
                            	     4: ;    Local ram, which does not get tested, is used for the stack.
                            	     5: ;===============================================================================
                            	     6: 	code
                            	     7: 	even
                            	     8: DisplayAddr:
02:000073C0 2208            	     9: 	move.l a0,d1
02:000073C2 E089            	    10: 	lsr.l #8,d1
02:000073C4 E089            	    11: 	lsr.l #8,d1
02:000073C6 E889            	    12: 	lsr.l #4,d1
02:000073C8 04410200        	    13: 	subi.w #512,d1
02:000073CC A2C10000        	    14: 	bin2bcd d1
02:000073D0 61C8            	    15: 	bsr	DisplayWyde
02:000073D2 123C000D        	    16: 	move.b #CR,d1
02:000073D6 6000E508        	    17: 	bra DisplayChar
02:000073DA 08000083        	    18: 	btst #$83,d0
                            	    19: 	
                            	    20: cmdTestRAM:
                            	    21: ramtest:
02:000073DE 33FCA5A5FD0FFF00	    22: 	move.w	#$A5A5,leds		; diagnostics
02:000073E6 263CAAAAAAAA    	    23:   move.l #$aaaaaaaa,d3
02:000073EC 283C55555555    	    24:   move.l #$55555555,d4
02:000073F2 6136            	    25:   bsr ramtest0
                            	    26:   ; switch checkerboard pattern and repeat test.
02:000073F4 C744            	    27:   exg d3,d4
02:000073F6 6132            	    28:   bsr ramtest0
                            	    29: 	; Save last ram address in end of memory pointer.
                            	    30: rmtst5:
02:000073F8 7025            	    31: 	moveq #37,d0					; lock semaphore
02:000073FA 7206            	    32: 	moveq #MEMORY_SEMA,d1
02:000073FC 4E4F            	    33: 	trap #15
02:000073FE 207C7FFFFFF8    	    34:   movea.l #$7FFFFFF8,a0
02:00007404 23C800100004    	    35:   move.l a0,memend
                            	    36: 	; Create very first memory block.
02:0000740A 207C3FFFFFF4    	    37:   movea.l #$3FFFFFF4,a0
02:00007410 23C840000004    	    38:   move.l a0,$40000004		; length of block
02:00007416 23FC465245454000	    39:   move.l #$46524545,$40000000
02:0000741E 0000
02:00007420 7026            	    40: 	moveq #38,d0					; unlock semaphore
02:00007422 7206            	    41: 	moveq #MEMORY_SEMA,d1
02:00007424 4E4F            	    42: 	trap #15
02:00007426 6000F270        	    43: 	bra Monitor
                            	    44: ;  rts
                            	    45: 
                            	    46: ramtest0:
02:0000742A 2003            	    47: 	move.l d3,d0
02:0000742C 207C40000000    	    48:   movea.l #$40000000,a0
                            	    49: ;-----------------------------------------------------------
                            	    50: ;   Write checkerboard pattern to ram then read it back to
                            	    51: ; find the highest usable ram address (maybe). This address
                            	    52: ; must be lower than the start of the rom (0xe00000).
                            	    53: ;-----------------------------------------------------------
                            	    54: ramtest1:
02:00007432 20C3            	    55:   move.l d3,(a0)+
02:00007434 61008D02        	    56:   bsr net_delay
02:00007438 20C4            	    57:   move.l d4,(a0)+
02:0000743A 61008CFC        	    58:   bsr net_delay
02:0000743E 2208            	    59:   move.l a0,d1
02:00007440 4A41            	    60:   tst.w	d1
02:00007442 6608            	    61:   bne.s rmtst1
02:00007444 6100FF7A        	    62:   bsr DisplayAddr
02:00007448 6100EB76        	    63:   bsr CheckForCtrlC
                            	    64: rmtst1:
02:0000744C B1FC7FFFFFF8    	    65:   cmpa.l #$7FFFFFF8,a0
02:00007452 65DE            	    66:   blo.s ramtest1
02:00007454 6100E440        	    67:   bsr	CRLF
                            	    68: ;------------------------------------------------------
                            	    69: ;   Save maximum useable address for later comparison.
                            	    70: ;------------------------------------------------------
                            	    71: ramtest6:
02:00007458 33FCA7A7FD0FFF00	    72: 	move.w	#$A7A7,leds		; diagnostics
02:00007460 2448            	    73:   movea.l a0,a2
02:00007462 207C40000000    	    74:   movea.l #$40000000,a0
                            	    75: ;--------------------------------------------
                            	    76: ;   Read back checkerboard pattern from ram.
                            	    77: ;--------------------------------------------
                            	    78: ramtest2
02:00007468 2A18            	    79:   move.l (a0)+,d5
02:0000746A 61008CCC        	    80:   bsr net_delay
02:0000746E 2C18            	    81:   move.l (a0)+,d6
02:00007470 61008CC6        	    82:   bsr net_delay
02:00007474 B1CA            	    83:   cmpa.l a2,a0
02:00007476 643A            	    84:   bhs.s	ramtest3
02:00007478 2208            	    85:   move.l a0,d1
02:0000747A 4A41            	    86:   tst.w	d1
02:0000747C 6608            	    87:   bne.s	rmtst2
02:0000747E 6100FF40        	    88:   bsr	DisplayAddr
02:00007482 6100EB3C        	    89: 	bsr CheckForCtrlC
                            	    90: rmtst2
02:00007486 BA83            	    91:   cmp.l d3,d5
02:00007488 6604            	    92:   bne.s rmtst3
02:0000748A BC84            	    93:   cmp.l d4,d6
02:0000748C 67DA            	    94:   beq.s ramtest2
                            	    95: ;----------------------------------
                            	    96: ; Report error in ram.
                            	    97: ;----------------------------------
                            	    98: rmtst3
02:0000748E 6100E406        	    99: 	bsr CRLF
02:00007492 7245            	   100: 	moveq	#'E',d1
02:00007494 6100E44A        	   101: 	bsr DisplayChar
02:00007498 6100FEF2        	   102: 	bsr DisplaySpace
02:0000749C 2208            	   103: 	move.l a0,d1
02:0000749E 6100FEF4        	   104: 	bsr DisplayTetra
02:000074A2 6100FEE8        	   105: 	bsr DisplaySpace
02:000074A6 2205            	   106: 	move.l d5,d1
02:000074A8 6100FEEA        	   107: 	bsr DisplayTetra
02:000074AC 6100EB12        	   108: 	bsr CheckForCtrlC
02:000074B0 60B6            	   109: 	bra ramtest2
                            	   110: ramtest3
02:000074B2 4E75            	   111: 	rts
                            	   112: 

Source: "boot.x68"
                            	  3145: 	include "LoadS19.x68"

Source: "LoadS19.x68"
                            	     1: ;==============================================================================
                            	     2: ; Load an S19 format file
                            	     3: ;==============================================================================
                            	     4: 	code
                            	     5: 	even
                            	     6: cmdLoadS19:
02:000074B4 6100E3E0        	     7: 	bsr			CRLF					; move display to next line
02:000074B8 6012            	     8: 	bra			ProcessRec
                            	     9: NextRec:
02:000074BA 610001DC        	    10: 	bsr			sGetChar			; get character from serial port routines
02:000074BE 0C01000A        	    11: 	cmpi.b	#LF,d1				; look for a line-feed
02:000074C2 66F6            	    12: 	bne			NextRec
02:000074C4 123C002E        	    13: 	move.b	#'.',d1				; progress display
02:000074C8 6100E416        	    14: 	bsr			DisplayChar
                            	    15: ProcessRec:
02:000074CC 6100EAF2        	    16: 	bsr			CheckForCtrlC	; check for CTRL-C once per record
02:000074D0 610001C6        	    17: 	bsr			sGetChar
02:000074D4 0C01000D        	    18: 	cmpi.b	#CR,d1
02:000074D8 67F2            	    19: 	beq.s		ProcessRec
02:000074DA 423900100150    	    20: 	clr.b		S19Checksum		; clear the checksum
02:000074E0 1801            	    21: 	move.b	d1,d4
02:000074E2 0C04001A        	    22: 	cmpi.b	#CTRLZ,d4			; CTRL-Z ?
02:000074E6 6700F1B0        	    23: 	beq			Monitor
02:000074EA 0C040053        	    24: 	cmpi.b	#'S',d4				; All records must begin with an 'S'
02:000074EE 66CA            	    25: 	bne.s		NextRec
02:000074F0 610001A6        	    26: 	bsr			sGetChar
02:000074F4 1801            	    27: 	move.b	d1,d4
02:000074F6 0C040030        	    28: 	cmpi.b	#'0',d4				; Record type must be between '0' and '9'
02:000074FA 65BE            	    29: 	blo.s		NextRec
02:000074FC 0C040039        	    30: 	cmpi.b	#'9',d4				; d4 = record type
02:00007500 62B8            	    31: 	bhi.s		NextRec
02:00007502 61000194        	    32: 	bsr			sGetChar			; get byte count for record
02:00007506 6100FE38        	    33: 	bsr			AsciiToHexNybble
02:0000750A 1401            	    34: 	move.b	d1,d2
02:0000750C 6100018A        	    35: 	bsr			sGetChar
02:00007510 6100FE2E        	    36: 	bsr			AsciiToHexNybble
02:00007514 E90A            	    37: 	lsl.b		#4,d2
02:00007516 8202            	    38: 	or.b		d2,d1					; d1 = byte count
02:00007518 1601            	    39: 	move.b	d1,d3					; d3 = byte count
02:0000751A D73900100150    	    40: 	add.b		d3,S19Checksum
02:00007520 0C040030        	    41: 	cmpi.b	#'0',d4				; manufacturer ID record, ignore
02:00007524 6794            	    42: 	beq			NextRec
02:00007526 0C040031        	    43: 	cmpi.b	#'1',d4
02:0000752A 670000A2        	    44: 	beq			ProcessS1
02:0000752E 0C040032        	    45: 	cmpi.b	#'2',d4
02:00007532 6700009E        	    46: 	beq			ProcessS2
02:00007536 0C040033        	    47: 	cmpi.b	#'3',d4
02:0000753A 6700009A        	    48: 	beq			ProcessS3
02:0000753E 0C040035        	    49: 	cmpi.b	#'5',d4				; record count record, ignore
02:00007542 6700FF76        	    50: 	beq			NextRec
02:00007546 0C040037        	    51: 	cmpi.b	#'7',d4
02:0000754A 6700008E        	    52: 	beq			ProcessS7
02:0000754E 0C040038        	    53: 	cmpi.b	#'8',d4
02:00007552 67000096        	    54: 	beq			ProcessS8
02:00007556 0C040039        	    55: 	cmpi.b	#'9',d4
02:0000755A 6700009E        	    56: 	beq			ProcessS9
02:0000755E 6000FF5A        	    57: 	bra			NextRec
                            	    58: 
                            	    59: pcssxa:
02:00007562 2209            	    60: 	move.l	a1,d1
02:00007564 6100FE2E        	    61: 	bsr			DisplayTetra
02:00007568 123C000D        	    62: 	move.b	#CR,d1
02:0000756C 6100E372        	    63: 	bsr			DisplayChar
02:00007570 024300FF        	    64: 	andi.w	#$ff,d3
02:00007574 5343            	    65: 	subi.w	#1,d3			; one less for dbra
                            	    66: .0001:
02:00007576 7400            	    67: 	clr.l		d2
02:00007578 6100011E        	    68: 	bsr			sGetChar
02:0000757C 6100FDC2        	    69: 	bsr			AsciiToHexNybble
02:00007580 E98A            	    70: 	lsl.l		#4,d2
02:00007582 8401            	    71: 	or.b		d1,d2
02:00007584 61000112        	    72: 	bsr			sGetChar
02:00007588 6100FDB6        	    73: 	bsr			AsciiToHexNybble
02:0000758C E98A            	    74: 	lsl.l		#4,d2
02:0000758E 8401            	    75: 	or.b		d1,d2
02:00007590 D53900100150    	    76: 	add.b		d2,S19Checksum
02:00007596 12C2            	    77: 	move.b	d2,(a1)+			; move byte to memory
02:00007598 51CBFFDC        	    78: 	dbra		d3,.0001
                            	    79: 	; Get the checksum byte
02:0000759C 7400            	    80: 	clr.l		d2
02:0000759E 610000F8        	    81: 	bsr			sGetChar
02:000075A2 6100FD9C        	    82: 	bsr			AsciiToHexNybble
02:000075A6 E98A            	    83: 	lsl.l		#4,d2
02:000075A8 8401            	    84: 	or.b		d1,d2
02:000075AA 610000EC        	    85: 	bsr			sGetChar
02:000075AE 6100FD90        	    86: 	bsr			AsciiToHexNybble
02:000075B2 E98A            	    87: 	lsl.l		#4,d2
02:000075B4 8401            	    88: 	or.b		d1,d2
02:000075B6 4602            	    89: 	eor.b		#$FF,d2
02:000075B8 B43900100150    	    90: 	cmp.b		S19Checksum,d2
02:000075BE 6700FEFA        	    91: 	beq			NextRec
02:000075C2 123C0045        	    92: 	move.b	#'E',d1
02:000075C6 6100E318        	    93: 	bsr			DisplayChar
02:000075CA 6000FEEE        	    94: 	bra			NextRec
                            	    95: 
                            	    96: ProcessS1:
02:000075CE 613A            	    97: 	bsr			S19Get16BitAddress
02:000075D0 6090            	    98: 	bra			pcssxa
                            	    99: ProcessS2:
02:000075D2 6144            	   100: 	bsr			S19Get24BitAddress
02:000075D4 608C            	   101: 	bra			pcssxa
                            	   102: ProcessS3:
02:000075D6 614C            	   103: 	bsr			S19Get32BitAddress
02:000075D8 6088            	   104: 	bra			pcssxa
                            	   105: ProcessS7:
02:000075DA 6148            	   106: 	bsr			S19Get32BitAddress
02:000075DC 23C900040008    	   107: 	move.l	a1,S19StartAddress
02:000075E2 6100E820        	   108: 	bsr			_KeybdInit
02:000075E6 6000F0B0        	   109: 	bra			Monitor
                            	   110: ProcessS8:
02:000075EA 612C            	   111: 	bsr			S19Get24BitAddress
02:000075EC 23C900040008    	   112: 	move.l	a1,S19StartAddress
02:000075F2 6100E810        	   113: 	bsr			_KeybdInit
02:000075F6 6000F0A0        	   114: 	bra			Monitor
                            	   115: ProcessS9:
02:000075FA 610E            	   116: 	bsr			S19Get16BitAddress
02:000075FC 23C900040008    	   117: 	move.l	a1,S19StartAddress
02:00007602 6100E800        	   118: 	bsr			_KeybdInit
02:00007606 6000F090        	   119: 	bra			Monitor
                            	   120: 
                            	   121: S19Get16BitAddress:
02:0000760A 7400            	   122: 	clr.l		d2
02:0000760C 6100008A        	   123: 	bsr			sGetChar
02:00007610 6100FD2E        	   124: 	bsr			AsciiToHexNybble
02:00007614 1401            	   125: 	move.b	d1,d2
02:00007616 603E            	   126: 	bra			S1932b
                            	   127: 
                            	   128: S19Get24BitAddress:
02:00007618 7400            	   129: 	clr.l		d2
02:0000761A 617C            	   130: 	bsr			sGetChar
02:0000761C 6100FD22        	   131: 	bsr			AsciiToHexNybble
02:00007620 1401            	   132: 	move.b	d1,d2
02:00007622 601E            	   133: 	bra			S1932a
                            	   134: 
                            	   135: S19Get32BitAddress:
02:00007624 7400            	   136: 	clr.l		d2
02:00007626 6170            	   137: 	bsr			sGetChar
02:00007628 6100FD16        	   138: 	bsr			AsciiToHexNybble
02:0000762C 1401            	   139: 	move.b	d1,d2
02:0000762E 6168            	   140: 	bsr			sGetChar
02:00007630 6100FD0E        	   141: 	bsr			AsciiToHexNybble
02:00007634 E98A            	   142: 	lsl.l		#4,d2
02:00007636 8401            	   143: 	or.b		d1,d2
02:00007638 615E            	   144: 	bsr			sGetChar
02:0000763A 6100FD04        	   145: 	bsr			AsciiToHexNybble
02:0000763E E98A            	   146: 	lsl.l		#4,d2
02:00007640 8401            	   147: 	or.b		d1,d2
                            	   148: S1932a:
02:00007642 6154            	   149: 	bsr			sGetChar
02:00007644 6100FCFA        	   150: 	bsr			AsciiToHexNybble
02:00007648 E98A            	   151: 	lsl.l		#4,d2
02:0000764A 8401            	   152: 	or.b		d1,d2
02:0000764C 614A            	   153: 	bsr			sGetChar
02:0000764E 6100FCF0        	   154: 	bsr			AsciiToHexNybble
02:00007652 E98A            	   155: 	lsl.l		#4,d2
02:00007654 8401            	   156: 	or.b		d1,d2
                            	   157: S1932b:
02:00007656 6140            	   158: 	bsr			sGetChar
02:00007658 6100FCE6        	   159: 	bsr			AsciiToHexNybble
02:0000765C E98A            	   160: 	lsl.l		#4,d2
02:0000765E 8401            	   161: 	or.b		d1,d2
02:00007660 6136            	   162: 	bsr			sGetChar
02:00007662 6100FCDC        	   163: 	bsr			AsciiToHexNybble
02:00007666 E98A            	   164: 	lsl.l		#4,d2
02:00007668 8401            	   165: 	or.b		d1,d2
02:0000766A 612C            	   166: 	bsr			sGetChar
02:0000766C 6100FCD2        	   167: 	bsr			AsciiToHexNybble
02:00007670 E98A            	   168: 	lsl.l		#4,d2
02:00007672 8401            	   169: 	or.b		d1,d2
02:00007674 7800            	   170: 	clr.l		d4
02:00007676 2242            	   171: 	move.l	d2,a1
                            	   172: 	; Add bytes from address value to checksum
02:00007678 D53900100150    	   173: 	add.b		d2,S19Checksum
02:0000767E E08A            	   174: 	lsr.l		#8,d2
02:00007680 D53900100150    	   175: 	add.b		d2,S19Checksum
02:00007686 E08A            	   176: 	lsr.l		#8,d2
02:00007688 D53900100150    	   177: 	add.b		d2,S19Checksum
02:0000768E E08A            	   178: 	lsr.l		#8,d2
02:00007690 D53900100150    	   179: 	add.b		d2,S19Checksum
02:00007696 4E75            	   180: 	rts
                            	   181: 
                            	   182: ;------------------------------------------------------------------------------
                            	   183: ; Get a character from auxillary input. Waiting for a character is limited to
                            	   184: ; 32000 tries. If a character is not available within the limit, then a return
                            	   185: ; to the monitor is done.
                            	   186: ;
                            	   187: ;	Parameters:
                            	   188: ;		none
                            	   189: ; Returns:
                            	   190: ;		d1 = character from receive buffer or -1 if no char available
                            	   191: ;------------------------------------------------------------------------------
                            	   192: 
                            	   193: sGetChar:
02:00007698 48E7A000        	   194: 	movem.l	d0/d2,-(a7)
02:0000769C 343C7D00        	   195: 	move.w	#32000,d2
                            	   196: .0001:
02:000076A0 7024            	   197: 	moveq		#36,d0				; serial get char from buffer
02:000076A2 4E4F            	   198: 	trap		#15
02:000076A4 4A41            	   199: 	tst.w		d1						; was there a char available?
02:000076A6 6A0C            	   200: 	bpl.s		.0002
02:000076A8 51CAFFF6        	   201: 	dbra		d2,.0001			; no - try again
02:000076AC 4CDF0005        	   202: 	movem.l	(a7)+,d0/d2
                            	   203: .0003:
                            	   204: ;	bsr			_KeybdInit
02:000076B0 6000EFE6        	   205: 	bra			Monitor				; ran out of tries
                            	   206: .0002:
02:000076B4 4CDF0005        	   207: 	movem.l	(a7)+,d0/d2
02:000076B8 0C01001A        	   208: 	cmpi.b	#CTRLZ,d1			; receive end of file?
02:000076BC 67F2            	   209: 	beq			.0003
02:000076BE 4E75            	   210: 	rts
                            	   211: 
                            	   212: 

Source: "boot.x68"
                            	  3146: 	
                            	  3147: AudioInputTest:
02:000076C0 4E75            	  3148: 	rts
                            	  3149: BouncingBalls:
02:000076C2 4E75            	  3150: 	rts
                            	  3151: GraphicsDemo:
02:000076C4 4E75            	  3152: 	rts
                            	  3153: ClearScreen:
02:000076C6 6000E17E        	  3154: 	bra		clear_screen
02:000076CA 4E75            	  3155: 	rts
                            	  3156: 
                            	  3157: ;------------------------------------------------------------------------------
                            	  3158: ; Reverse the order of bytes in d1.
                            	  3159: ;------------------------------------------------------------------------------
                            	  3160: 
                            	  3161: rbo:
02:000076CC E159            	  3162: 	rol.w		#8,d1
02:000076CE 4841            	  3163: 	swap		d1
02:000076D0 E159            	  3164: 	rol.w		#8,d1
02:000076D2 4E75            	  3165: 	rts
                            	  3166: 
                            	  3167: ;==============================================================================
                            	  3168: ; Serial I/O routines
                            	  3169: ;==============================================================================
                            	  3170: 
                            	  3171: ;------------------------------------------------------------------------------
                            	  3172: ; Initialize the serial port an enhanced 6551 circuit.
                            	  3173: ;
                            	  3174: ; Select internal baud rate clock divider for 9600 baud
                            	  3175: ; Reset fifos, set threshold to 3/4 full on transmit and 3/4 empty on receive
                            	  3176: ; Note that the byte order is swapped.
                            	  3177: ;------------------------------------------------------------------------------
                            	  3178: 
                            	  3179: SerialInit:
02:000076D4 427900100162    	  3180: 	clr.w		SerHeadRcv					; clear receive buffer indexes
02:000076DA 427900100160    	  3181: 	clr.w		SerTailRcv
02:000076E0 423900100164    	  3182: 	clr.b		SerRcvXon						; and Xon,Xoff flags
02:000076E6 423900100165    	  3183: 	clr.b		SerRcvXoff
02:000076EC 203C09000000    	  3184: 	move.l	#$09000000,d0				; dtr,rts active, rxint enabled, no parity
02:000076F2 23C0FD060008    	  3185: 	move.l	d0,ACIA+ACIA_CMD
                            	  3186: ;	move.l	#$1E00F700,d0				; fifos enabled
02:000076F8 203C1E000000    	  3187: 	move.l	#$1E000000,d0				; fifos disabled
02:000076FE 23C0FD06000C    	  3188: 	move.l	d0,ACIA+ACIA_CTRL
02:00007704 4E75            	  3189: 	rts
                            	  3190: ;	move.l	#$0F000000,d0				; transmit a break for a while
                            	  3191: ;	move.l	d0,ACIA+ACIA_CMD
                            	  3192: ;	move.l	#300000,d2					; wait 100 ms
                            	  3193: ;	bra			.0001
                            	  3194: ;.0003:
                            	  3195: ;	swap		d2
                            	  3196: ;.0001:
                            	  3197: ;	nop
                            	  3198: ;	dbra		d2,.0001
                            	  3199: ;.0002:
                            	  3200: ;	swap		d2
                            	  3201: ;	dbra		d2,.0003
                            	  3202: ;	move.l	#$07000000,d0				; clear break
                            	  3203: ;	move.l	d0,ACIA+ACIA_CMD
                            	  3204: ;	rts
                            	  3205: 	
                            	  3206: ;------------------------------------------------------------------------------
                            	  3207: ; SerialGetChar
                            	  3208: ;
                            	  3209: ; Check the serial port buffer to see if there's a char available. If there's
                            	  3210: ; a char available then return it. If the buffer is almost empty then send an
                            	  3211: ; XON.
                            	  3212: ;
                            	  3213: ; Stack Space:
                            	  3214: ;		2 long words
                            	  3215: ; Parameters:
                            	  3216: ;		none
                            	  3217: ; Modifies:
                            	  3218: ;		d0,a0
                            	  3219: ; Returns:
                            	  3220: ;		d1 = character or -1
                            	  3221: ;------------------------------------------------------------------------------
                            	  3222: 
                            	  3223: SerialGetChar:
02:00007706 2F02            	  3224: 	move.l		d2,-(a7)
02:00007708 4E7A0FE0        	  3225: 	movec			coreno,d0
02:0000770C 4840            	  3226: 	swap			d0
02:0000770E 7202            	  3227: 	moveq			#SERIAL_SEMA,d1
02:00007710 61008B46        	  3228: 	bsr				LockSemaphore
02:00007714 610000DE        	  3229: 	bsr				SerialRcvCount			; check number of chars in receive buffer
02:00007718 0C400008        	  3230: 	cmpi.w		#8,d0								; less than 8?
02:0000771C 621C            	  3231: 	bhi				.sgc2
02:0000771E 4A3900100164    	  3232: 	tst.b			SerRcvXon						; skip sending XON if already sent
02:00007724 6614            	  3233: 	bne	  		.sgc2            		; XON already sent?
02:00007726 123C0011        	  3234: 	move.b		#XON,d1							; if <8 send an XON
02:0000772A 423900100165    	  3235: 	clr.b			SerRcvXoff					; clear XOFF status
02:00007730 13C100100164    	  3236: 	move.b		d1,SerRcvXon				; flag so we don't send it multiple times
02:00007736 61000098        	  3237: 	bsr				SerialPutChar				; send it
                            	  3238: .sgc2:
02:0000773A 323900100162    	  3239: 	move.w		SerHeadRcv,d1				; check if anything is in buffer
02:00007740 B27900100160    	  3240: 	cmp.w			SerTailRcv,d1
02:00007746 6720            	  3241: 	beq				.NoChars						; no?
02:00007748 41F900101000    	  3242: 	lea				SerRcvBuf,a0
02:0000774E 12301000        	  3243: 	move.b		(a0,d1.w),d1				; get byte from buffer
02:00007752 527900100162    	  3244: 	addi.w		#1,SerHeadRcv
02:00007758 02790FFF00100162	  3245: 	andi.w		#$FFF,SerHeadRcv		; 4k wrap around
02:00007760 0281000000FF    	  3246: 	andi.l		#$FF,d1
02:00007766 6002            	  3247: 	bra				.Xit
                            	  3248: .NoChars:
02:00007768 72FF            	  3249: 	moveq			#-1,d1
                            	  3250: .Xit:
02:0000776A C342            	  3251: 	exg				d1,d2
02:0000776C 4E7A0FE0        	  3252: 	movec			coreno,d0
02:00007770 4840            	  3253: 	swap			d0
02:00007772 7202            	  3254: 	moveq			#SERIAL_SEMA,d1
02:00007774 61008B1E        	  3255: 	bsr				UnlockSemaphore
02:00007778 C541            	  3256: 	exg				d2,d1
02:0000777A 241F            	  3257: 	move.l		(a7)+,d2
02:0000777C 4E75            	  3258: 	rts
                            	  3259: 
                            	  3260: ;------------------------------------------------------------------------------
                            	  3261: ; SerialPeekChar
                            	  3262: ;
                            	  3263: ; Check the serial port buffer to see if there's a char available. If there's
                            	  3264: ; a char available then return it. But don't update the buffer indexes. No need
                            	  3265: ; to send an XON here.
                            	  3266: ;
                            	  3267: ; Stack Space:
                            	  3268: ;		0 words
                            	  3269: ; Parameters:
                            	  3270: ;		none
                            	  3271: ; Modifies:
                            	  3272: ;		d0,d2,a0
                            	  3273: ; Returns:
                            	  3274: ;		d1 = character or -1
                            	  3275: ;------------------------------------------------------------------------------
                            	  3276: 
                            	  3277: SerialPeekChar:
02:0000777E 4E7A0FE0        	  3278: 	movec		coreno,d0
02:00007782 4840            	  3279: 	swap		d0
02:00007784 7202            	  3280: 	moveq		#SERIAL_SEMA,d1
02:00007786 61008AD0        	  3281: 	bsr			LockSemaphore
02:0000778A 343900100162    	  3282: 	move.w	SerHeadRcv,d2		; check if anything is in buffer
02:00007790 B47900100160    	  3283: 	cmp.w		SerTailRcv,d2
02:00007796 670C            	  3284: 	beq			.NoChars				; no?
02:00007798 41F900101000    	  3285: 	lea			SerRcvBuf,a0
02:0000779E 14302000        	  3286: 	move.b	(a0,d2.w),d2		; get byte from buffer
02:000077A2 6002            	  3287: 	bra			.Xit
                            	  3288: .NoChars:
02:000077A4 74FF            	  3289: 	moveq		#-1,d2
                            	  3290: .Xit:
02:000077A6 4E7A0FE0        	  3291: 	movec		coreno,d0
02:000077AA 4840            	  3292: 	swap		d0
02:000077AC 7202            	  3293: 	moveq		#SERIAL_SEMA,d1
02:000077AE 61008AA8        	  3294: 	bsr			LockSemaphore
02:000077B2 3202            	  3295: 	move		d2,d1
02:000077B4 4E75            	  3296: 	rts
                            	  3297: 
                            	  3298: ;------------------------------------------------------------------------------
                            	  3299: ; SerialPeekChar
                            	  3300: ;		Get a character directly from the I/O port. This bypasses the input
                            	  3301: ; buffer.
                            	  3302: ;
                            	  3303: ; Stack Space:
                            	  3304: ;		0 words
                            	  3305: ; Parameters:
                            	  3306: ;		none
                            	  3307: ; Modifies:
                            	  3308: ;		d
                            	  3309: ; Returns:
                            	  3310: ;		d1 = character or -1
                            	  3311: ;------------------------------------------------------------------------------
                            	  3312: 
                            	  3313: SerialPeekCharDirect:
02:000077B6 1239FD060004    	  3314: 	move.b	ACIA+ACIA_STAT,d1	; get serial status
02:000077BC 08010003        	  3315: 	btst		#3,d1							; look for Rx not empty
02:000077C0 670A            	  3316: 	beq.s		.0001
02:000077C2 7200            	  3317: 	moveq.l	#0,d1							; clear upper bits of return value
02:000077C4 1239FD060000    	  3318: 	move.b	ACIA+ACIA_RX,d1		; get data from ACIA
02:000077CA 4E75            	  3319: 	rts												; return
                            	  3320: .0001:
02:000077CC 72FF            	  3321: 	moveq		#-1,d1
02:000077CE 4E75            	  3322: 	rts
                            	  3323: 
                            	  3324: ;------------------------------------------------------------------------------
                            	  3325: ; SerialPutChar
                            	  3326: ;    Put a character to the serial transmitter. This routine blocks until the
                            	  3327: ; transmitter is empty. 
                            	  3328: ;
                            	  3329: ; Stack Space
                            	  3330: ;		0 words
                            	  3331: ; Parameters:
                            	  3332: ;		d1.b = character to put
                            	  3333: ; Modifies:
                            	  3334: ;		none
                            	  3335: ;------------------------------------------------------------------------------
                            	  3336: 
                            	  3337: SerialPutChar:
02:000077D0 48E7C000        	  3338: 	movem.l	d0/d1,-(a7)				; push d0,d1
                            	  3339: .0001:
02:000077D4 1039FD060004    	  3340: 	move.b	ACIA+ACIA_STAT,d0	; wait until the uart indicates tx empty
02:000077DA 08000004        	  3341: 	btst		#4,d0							; bit #4 of the status reg
02:000077DE 67F4            	  3342: 	beq.s		.0001			    		; branch if transmitter is not empty
02:000077E0 13C1FD060000    	  3343: 	move.b	d1,ACIA+ACIA_TX		; send the byte
02:000077E6 4CDF0003        	  3344: 	movem.l	(a7)+,d0/d1				; pop d0,d1
02:000077EA 4E75            	  3345: 	rts
                            	  3346: 	
                            	  3347: ;------------------------------------------------------------------------------
                            	  3348: ; Reverse the order of bytes in d1.
                            	  3349: ;------------------------------------------------------------------------------
                            	  3350: 
                            	  3351: SerialRbo:
02:000077EC E159            	  3352: 	rol.w		#8,d1
02:000077EE 4841            	  3353: 	swap		d1
02:000077F0 E159            	  3354: 	rol.w		#8,d1
02:000077F2 4E75            	  3355: 	rts
                            	  3356: 
                            	  3357: ;------------------------------------------------------------------------------
                            	  3358: ; Calculate number of character in input buffer
                            	  3359: ;
                            	  3360: ; Returns:
                            	  3361: ;		d0 = number of bytes in buffer.
                            	  3362: ;------------------------------------------------------------------------------
                            	  3363: 
                            	  3364: SerialRcvCount:
02:000077F4 303900100160    	  3365: 	move.w	SerTailRcv,d0
02:000077FA 907900100162    	  3366: 	sub.w		SerHeadRcv,d0
02:00007800 6C10            	  3367: 	bge			.0001
02:00007802 303C1000        	  3368: 	move.w	#$1000,d0
02:00007806 907900100162    	  3369: 	sub.w		SerHeadRcv,d0
02:0000780C D07900100160    	  3370: 	add.w		SerTailRcv,d0
                            	  3371: .0001:
02:00007812 4E75            	  3372: 	rts
                            	  3373: 
                            	  3374: ;------------------------------------------------------------------------------
                            	  3375: ; Serial IRQ routine
                            	  3376: ;
                            	  3377: ; Keeps looping as long as it finds characters in the ACIA recieve buffer/fifo.
                            	  3378: ; Received characters are buffered. If the buffer becomes full, new characters
                            	  3379: ; will be lost.
                            	  3380: ;
                            	  3381: ; Parameters:
                            	  3382: ;		none
                            	  3383: ; Modifies:
                            	  3384: ;		none
                            	  3385: ; Returns:
                            	  3386: ;		d1 = -1 if IRQ handled, otherwise zero
                            	  3387: ;------------------------------------------------------------------------------
                            	  3388: 
                            	  3389: SerialIRQ:
02:00007814 46FC2300        	  3390: 	move.w	#$2300,sr						; disable lower level IRQs
02:00007818 48E7E080        	  3391: 	movem.l	d0/d1/d2/a0,-(a7)
02:0000781C 4E7A0FE0        	  3392: 	movec		coreno,d0
02:00007820 4840            	  3393: 	swap		d0
02:00007822 7202            	  3394: 	moveq		#SERIAL_SEMA,d1
02:00007824 61008A32        	  3395: 	bsr			LockSemaphore
                            	  3396: sirqNxtByte:
02:00007828 1239FD060004    	  3397: 	move.b	ACIA+ACIA_STAT,d1		; check the status
02:0000782E 08010003        	  3398: 	btst		#3,d1								; bit 3 = rx full
02:00007832 6756            	  3399: 	beq			notRxInt
02:00007834 1239FD060000    	  3400: 	move.b	ACIA+ACIA_RX,d1
                            	  3401: sirq0001:
02:0000783A 303900100160    	  3402: 	move.w	SerTailRcv,d0				; check if recieve buffer full
02:00007840 5240            	  3403: 	addi.w	#1,d0
02:00007842 02400FFF        	  3404: 	andi.w	#$FFF,d0
02:00007846 B07900100162    	  3405: 	cmp.w		SerHeadRcv,d0
02:0000784C 673C            	  3406: 	beq			sirqRxFull
02:0000784E 33C000100160    	  3407: 	move.w	d0,SerTailRcv				; update tail pointer
02:00007854 5340            	  3408: 	subi.w	#1,d0								; backup
02:00007856 02400FFF        	  3409: 	andi.w	#$FFF,d0
02:0000785A 41F900101000    	  3410: 	lea			SerRcvBuf,a0				; a0 = buffer address
02:00007860 11810000        	  3411: 	move.b	d1,(a0,d0.w)				; store recieved byte in buffer
02:00007864 4A3900100165    	  3412: 	tst.b		SerRcvXoff					; check if xoff already sent
02:0000786A 66BC            	  3413: 	bne			sirqNxtByte
02:0000786C 6186            	  3414: 	bsr			SerialRcvCount			; if more than 4080 chars in buffer
02:0000786E 0C400FF0        	  3415: 	cmpi.w	#4080,d0
02:00007872 65B4            	  3416: 	blo			sirqNxtByte
02:00007874 123C0013        	  3417: 	move.b	#XOFF,d1						; send an XOFF
02:00007878 423900100164    	  3418: 	clr.b		SerRcvXon						; clear XON status
02:0000787E 13C100100165    	  3419: 	move.b	d1,SerRcvXoff				; set XOFF status
02:00007884 6100FF4A        	  3420: 	bsr			SerialPutChar				; send XOFF
02:00007888 609E            	  3421: 	bra			sirqNxtByte     		; check the status for another byte
                            	  3422: sirqRxFull:
                            	  3423: notRxInt:
02:0000788A 4E7A0FE0        	  3424: 	movec		coreno,d0
02:0000788E 4840            	  3425: 	swap		d0
02:00007890 7202            	  3426: 	moveq		#SERIAL_SEMA,d1
02:00007892 61008A00        	  3427: 	bsr			UnlockSemaphore
02:00007896 4CDF0107        	  3428: 	movem.l	(a7)+,d0/d1/d2/a0
02:0000789A 4E73            	  3429: 	rte
                            	  3430: 
                            	  3431: nmeSerial:
02:0000789C 53657269616C    	  3432: 	dc.b		"Serial",0
02:000078A2 00
                            	  3433: 
                            	  3434: ;===============================================================================
                            	  3435: ; Generic I2C routines
                            	  3436: ;===============================================================================
                            	  3437: 
                            	  3438: 	even
                            	  3439: ; i2c
                            	  3440: i2c_setup:
                            	  3441: ;		lea		I2C,a6				
                            	  3442: ;		move.w	#19,I2C_PREL(a6)	; setup prescale for 400kHz clock
                            	  3443: ;		move.w	#0,I2C_PREH(a6)
                            	  3444: init_i2c:
02:000078A4 4DF9FD069000    	  3445: 	lea	I2C2,a6				
02:000078AA 1CBC0013        	  3446: 	move.b #19,I2C_PREL(a6)	; setup prescale for 400kHz clock, 40MHz master
02:000078AE 422E0001        	  3447: 	move.b #0,I2C_PREH(a6)
02:000078B2 4E75            	  3448: 	rts
                            	  3449: 
                            	  3450: ; Wait for I2C transfer to complete
                            	  3451: ;
                            	  3452: ; Parameters
                            	  3453: ; 	a6 - I2C controller base address
                            	  3454: 
                            	  3455: i2c_wait_tip:
02:000078B4 2F00            	  3456: 	move.l d0,-(a7)
                            	  3457: .0001				
02:000078B6 102E0004        	  3458: 	move.b I2C_STAT(a6),d0		; wait for tip to clear
02:000078BA 08000001        	  3459: 	btst #1,d0
02:000078BE 66F6            	  3460: 	bne.s	.0001
02:000078C0 201F            	  3461: 	move.l (a7)+,d0
02:000078C2 4E75            	  3462: 	rts
                            	  3463: 
                            	  3464: ; Parameters
                            	  3465: ;	d0.b - data to transmit
                            	  3466: ;	d1.b - command value
                            	  3467: ;	a6	 - I2C controller base address
                            	  3468: ;
                            	  3469: i2c_wr_cmd:
02:000078C4 1D400003        	  3470: 	move.b d0,I2C_TXR(a6)
02:000078C8 1D410004        	  3471: 	move.b d1,I2C_CMD(a6)
02:000078CC 61E6            	  3472: 	bsr	i2c_wait_tip
02:000078CE 102E0004        	  3473: 	move.b I2C_STAT(a6),d0
02:000078D2 4E75            	  3474: 	rts
                            	  3475: 
                            	  3476: i2c_xmit1:
02:000078D4 2F00            	  3477: 	move.l d0,-(a7)
02:000078D6 1D7C00010002    	  3478: 	move.b #1,I2C_CTRL(a6)		; enable the core
02:000078DC 7076            	  3479: 	moveq	#$76,d0				; set slave address = %0111011
02:000078DE 323C0090        	  3480: 	move.w #$90,d1				; set STA, WR
02:000078E2 61E0            	  3481: 	bsr i2c_wr_cmd
02:000078E4 610C            	  3482: 	bsr	i2c_wait_rx_nack
02:000078E6 201F            	  3483: 	move.l (a7)+,d0
02:000078E8 323C0050        	  3484: 	move.w #$50,d1				; set STO, WR
02:000078EC 61D6            	  3485: 	bsr i2c_wr_cmd
02:000078EE 61000002        	  3486: 	bsr	i2c_wait_rx_nack
                            	  3487: 
                            	  3488: i2c_wait_rx_nack:
02:000078F2 2F00            	  3489: 	move.l d0,-(a7)
                            	  3490: .0001						
02:000078F4 102E0004        	  3491: 	move.b I2C_STAT(a6),d0		; wait for RXack = 0
02:000078F8 08000007        	  3492: 	btst #7,d0
02:000078FC 66F6            	  3493: 	bne.s	.0001
02:000078FE 201F            	  3494: 	move.l (a7)+,d0
02:00007900 4E75            	  3495: 	rts
                            	  3496: 
                            	  3497: ;===============================================================================
                            	  3498: ; Realtime clock routines
                            	  3499: ;===============================================================================
                            	  3500: 
                            	  3501: rtc_read:
02:00007902 2C7CFD069000    	  3502: 	movea.l	#I2C2,a6
02:00007908 4BF900100200    	  3503: 	lea	RTCBuf,a5
02:0000790E 1D7C00800002    	  3504: 	move.b	#$80,I2C_CTRL(a6)	; enable I2C
02:00007914 103C00DE        	  3505: 	move.b	#$DE,d0				; read address, write op
02:00007918 123C0090        	  3506: 	move.b	#$90,d1				; STA + wr bit
02:0000791C 61A6            	  3507: 	bsr	i2c_wr_cmd
02:0000791E 4A00            	  3508: 	tst.b	d0
02:00007920 6B66            	  3509: 	bmi	.rxerr
02:00007922 4200            	  3510: 	move.b #$00,d0				; address zero
02:00007924 123C0010        	  3511: 	move.b #$10,d1				; wr bit
02:00007928 619A            	  3512: 	bsr	i2c_wr_cmd
02:0000792A 4A00            	  3513: 	tst.b	d0
02:0000792C 6B5A            	  3514: 	bmi	.rxerr
02:0000792E 103C00DF        	  3515: 	move.b #$DF,d0				; read address, read op
02:00007932 123C0090        	  3516: 	move.b #$90,d1				; STA + wr bit
02:00007936 618C            	  3517: 	bsr i2c_wr_cmd
02:00007938 4A00            	  3518: 	tst.b	d0
02:0000793A 6B4C            	  3519: 	bmi	.rxerr
                            	  3520: 		
02:0000793C 343C0020        	  3521: 	move.w #$20,d2
                            	  3522: .0001
02:00007940 1D7C00200004    	  3523: 	move.b #$20,I2C_CMD(a6)	; rd bit
02:00007946 6100FF6C        	  3524: 	bsr	i2c_wait_tip
02:0000794A 61A6            	  3525: 	bsr	i2c_wait_rx_nack
02:0000794C 102E0004        	  3526: 	move.b I2C_STAT(a6),d0
02:00007950 4A00            	  3527: 	tst.b	d0
02:00007952 6B34            	  3528: 	bmi	.rxerr
02:00007954 102E0003        	  3529: 	move.b I2C_RXR(a6),d0
02:00007958 1B802000        	  3530: 	move.b d0,(a5,d2.w)
02:0000795C 5242            	  3531: 	addi.w #1,d2
02:0000795E 0C42005F        	  3532: 	cmpi.w #$5F,d2
02:00007962 66DC            	  3533: 	bne	.0001
02:00007964 1D7C00680004    	  3534: 	move.b #$68,I2C_CMD(a6)	; STO, rd bit + nack
02:0000796A 6100FF48        	  3535: 	bsr i2c_wait_tip
02:0000796E 6182            	  3536: 	bsr i2c_wait_rx_nack
02:00007970 102E0004        	  3537: 	move.b I2C_STAT(a6),d0
02:00007974 4A00            	  3538: 	tst.b	d0
02:00007976 6B10            	  3539: 	bmi	.rxerr
02:00007978 102E0003        	  3540: 	move.b I2C_RXR(a6),d0
02:0000797C 1B802000        	  3541: 	move.b d0,(a5,d2.w)
02:00007980 422E0002        	  3542: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
02:00007984 7000            	  3543: 	moveq	#0,d0
02:00007986 4E75            	  3544: 	rts
                            	  3545: .rxerr
02:00007988 422E0002        	  3546: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
02:0000798C 4E75            	  3547: 	rts
                            	  3548: 
                            	  3549: rtc_write:
02:0000798E 2C7CFD069000    	  3550: 	movea.l	#I2C2,a6
02:00007994 4BF900100200    	  3551: 	lea	RTCBuf,a5
02:0000799A 1D7C00800002    	  3552: 	move.b #$80,I2C_CTRL(a6)	; enable I2C
02:000079A0 103C00DE        	  3553: 	move.b #$DE,d0				; read address, write op
02:000079A4 123C0090        	  3554: 	move.b #$90,d1				; STA + wr bit
02:000079A8 6100FF1A        	  3555: 	bsr	i2c_wr_cmd
02:000079AC 4A00            	  3556: 	tst.b	d0
02:000079AE 6B42            	  3557: 	bmi	.rxerr
02:000079B0 4200            	  3558: 	move.b #$00,d0				; address zero
02:000079B2 123C0010        	  3559: 	move.b #$10,d1				; wr bit
02:000079B6 6100FF0C        	  3560: 	bsr	i2c_wr_cmd
02:000079BA 4A00            	  3561: 	tst.b	d0
02:000079BC 6B34            	  3562: 	bmi	.rxerr
02:000079BE 343C0020        	  3563: 	move.w #$20,d2
                            	  3564: .0001
02:000079C2 10352000        	  3565: 	move.b (a5,d2.w),d0
02:000079C6 123C0010        	  3566: 	move.b #$10,d1
02:000079CA 6100FEF8        	  3567: 	bsr	i2c_wr_cmd
02:000079CE 4A00            	  3568: 	tst.b	d0
02:000079D0 6B20            	  3569: 	bmi	.rxerr
02:000079D2 5242            	  3570: 	addi.w #1,d2
02:000079D4 0C42005F        	  3571: 	cmpi.w #$5F,d2
02:000079D8 66E8            	  3572: 	bne.s	.0001
02:000079DA 10352000        	  3573: 	move.b (a5,d2.w),d0
02:000079DE 123C0050        	  3574: 	move.b #$50,d1				; STO, wr bit
02:000079E2 6100FEE0        	  3575: 	bsr	i2c_wr_cmd
02:000079E6 4A00            	  3576: 	tst.b	d0
02:000079E8 6B08            	  3577: 	bmi	.rxerr
02:000079EA 422E0002        	  3578: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
02:000079EE 7000            	  3579: 	moveq	#0,d0
02:000079F0 4E75            	  3580: 	rts
                            	  3581: .rxerr:
02:000079F2 422E0002        	  3582: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
02:000079F6 4E75            	  3583: 	rts
                            	  3584: 
                            	  3585: msgRtcReadFail:
02:000079F8 5254432072656164	  3586: 	dc.b	"RTC read/write failed.",$0A,$0D,$00
02:00007A00 2F77726974652066
02:00007A08 61696C65642E
02:00007A0E 0A
02:00007A0F 0D
02:00007A10 00
                            	  3587: 
                            	  3588: 	even
                            	  3589: 
                            	  3590: ;------------------------------------------------------------------------------
                            	  3591: ;------------------------------------------------------------------------------
                            	  3592: 	even
                            	  3593: 
                            	  3594: bus_err:
                            	  3595: .0001:
02:00007A12 4E71            	  3596: 	nop
02:00007A14 60FC            	  3597: 	bra			.0001
                            	  3598: 
                            	  3599: trap3:
                            	  3600: 	; First save all registers
02:00007A16 48F9FFFF00040100	  3601: 	movem.l		d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
02:00007A1E 33DF00040140    	  3602: 	move.w		(a7)+,Regsave+$40
02:00007A24 23DF00040144    	  3603: 	move.l		(a7)+,Regsave+$44
02:00007A2A 2E7C00040FFC    	  3604: 	move.l		#$40FFC,a7			; reset stack pointer
02:00007A30 46FC2500        	  3605: 	move.w		#$2500,sr				; enable interrupts
02:00007A34 303900040202    	  3606: 	move.w		NumSetBreakpoints,d0
02:00007A3A 5340            	  3607: 	subi.w		#1,d0
02:00007A3C 41F900040220    	  3608: 	lea				Breakpoints,a0
02:00007A42 223900040144    	  3609: 	move.l		Regsave+$44,d1
                            	  3610: .0001:
02:00007A48 B298            	  3611: 	cmp.l			(a0)+,d1
02:00007A4A 6708            	  3612: 	beq.s			ProcessBreakpoint
02:00007A4C 51C8FFFA        	  3613: 	dbra			d0,.0001
02:00007A50 6000EC46        	  3614: 	bra				Monitor					; not a breakpoint
                            	  3615: ProcessBreakpoint:
02:00007A54 6104            	  3616: 	bsr				DisarmAllBreakpoints
02:00007A56 6000F28A        	  3617: 	bra				cmdDumpRegs
                            	  3618: 
                            	  3619: ;------------------------------------------------------------------------------
                            	  3620: ; DisarmAllBreakpoints, used when entering the monitor.
                            	  3621: ;------------------------------------------------------------------------------
                            	  3622: 
                            	  3623: DisarmAllBreakpoints:
02:00007A5A 48E780E0        	  3624: 	movem.l	d0/a0/a1/a2,-(a7)			; stack some regs
02:00007A5E 303900040202    	  3625: 	move.w	NumSetBreakpoints,d0	; d0 = number of breakpoints that are set
02:00007A64 0C400008        	  3626: 	cmpi.w	#numBreakpoints,d0		; check for valid number
02:00007A68 641A            	  3627: 	bhs.s		.0001
02:00007A6A 45F900040220    	  3628: 	lea			Breakpoints,a2				; a2 = pointer to breakpoint address table
02:00007A70 41F900040280    	  3629: 	lea			BreakpointWords,a0		; a0 = pointer to breakpoint instruction word table
02:00007A76 6004            	  3630: 	bra.s		.0003									; enter loop at bottom
                            	  3631: .0002:
02:00007A78 225A            	  3632: 	move.l	(a2)+,a1							; a1 = address of breakpoint
02:00007A7A 3298            	  3633: 	move.w	(a0)+,(a1)						; copy instruction word back to code
                            	  3634: .0003:
02:00007A7C 51C8FFFA        	  3635: 	dbra		d0,.0002
02:00007A80 4CDF0701        	  3636: 	movem.l	(a7)+,d0/a0/a1/a2			; restore regs
                            	  3637: .0001:
02:00007A84 4E75            	  3638: 	rts	
                            	  3639: 
                            	  3640: ;------------------------------------------------------------------------------
                            	  3641: ; ArmAllBreakpoints, used when entering the monitor.
                            	  3642: ;------------------------------------------------------------------------------
                            	  3643: 
                            	  3644: ArmAllBreakpoints:
02:00007A86 48E780E0        	  3645: 	movem.l		d0/a0/a1/a2,-(a7)			; stack some regs
02:00007A8A 303900040202    	  3646: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
02:00007A90 0C400008        	  3647: 	cmpi.w		#numBreakpoints,d0		; is the number valid?
02:00007A94 641E            	  3648: 	bhs.s			.0001
02:00007A96 45F900040220    	  3649: 	lea				Breakpoints,a2				; a2 = pointer to breakpoint address table
02:00007A9C 41F900040280    	  3650: 	lea				BreakpointWords,a0		; a0 = pointer to instruction word table
02:00007AA2 6008            	  3651: 	bra.s			.0003									; enter loop at bottom
                            	  3652: .0002:
02:00007AA4 225A            	  3653: 	move.l		(a2)+,a1							; a1 = address of breakpoint
02:00007AA6 3091            	  3654: 	move.w		(a1),(a0)							; copy instruction word to table
02:00007AA8 30FC4E43        	  3655: 	move.w		#$4E43,(a0)+					; set instruction = TRAP3
                            	  3656: .0003:
02:00007AAC 51C8FFF6        	  3657: 	dbra			d0,.0002
02:00007AB0 4CDF0701        	  3658: 	movem.l		(a7)+,d0/a0/a1/a2			; restore regs
                            	  3659: .0001:
02:00007AB4 4E75            	  3660: 	rts	
                            	  3661: 
                            	  3662: ;------------------------------------------------------------------------------
                            	  3663: ;------------------------------------------------------------------------------
                            	  3664: 
                            	  3665: ArmBreakpoint:
02:00007AB6 48E7E0E0        	  3666: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
02:00007ABA 303900040202    	  3667: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
02:00007AC0 0C400008        	  3668: 	cmpi.w		#numBreakpoints,d0		; check if too many
02:00007AC4 645A            	  3669: 	bhs.s			.0001
02:00007AC6 527900040202    	  3670: 	addi.w		#1,NumSetBreakpoints	; increment number of breakpoints
02:00007ACC 2400            	  3671: 	move.l		d0,d2
02:00007ACE 6100F104        	  3672: 	bsr				ignBlanks
02:00007AD2 6100F2D8        	  3673: 	bsr				GetHexNumber
02:00007AD6 6748            	  3674: 	beq.s			.0001									; was there an address?
02:00007AD8 08010000        	  3675: 	btst			#0,d1									; address value must be even
02:00007ADC 6642            	  3676: 	bne.s			.0001
                            	  3677: 	; See if the breakpoint is in the table already
02:00007ADE 43F900040220    	  3678: 	lea				Breakpoints,a1				; a1 points to breakpoint table
02:00007AE4 343C0007        	  3679: 	move.w		#numBreakpoints-1,d2
                            	  3680: .0002:
02:00007AE8 B299            	  3681: 	cmp.l			(a1)+,d1
02:00007AEA 673A            	  3682: 	beq.s			.0003									; breakpoint is in table already
02:00007AEC 51CAFFFA        	  3683: 	dbra			d2,.0002
                            	  3684: 	; Add breakpoint to table
                            	  3685: 	; Search for empty entry
02:00007AF0 43F900040220    	  3686: 	lea				Breakpoints,a1				; a1 = pointer to breakpoint address table
02:00007AF6 4242            	  3687: 	clr.w			d2										; d2 = count
                            	  3688: .0006:
02:00007AF8 4A91            	  3689: 	tst.l			(a1)									; is the entry empty?
02:00007AFA 670C            	  3690: 	beq.s			.0005									; branch if found empty entry
02:00007AFC 5889            	  3691: 	lea				4(a1),a1							; point to next entry
02:00007AFE 5242            	  3692: 	addi.w		#1,d2									; increment count
02:00007B00 0C420008        	  3693: 	cmpi.w		#numBreakpoints,d2		; safety: check against max number
02:00007B04 65F2            	  3694: 	blo.s			.0006
02:00007B06 6018            	  3695: 	bra.s			.0001									; what? no empty entries found, table corrupt?
                            	  3696: .0005:
02:00007B08 E542            	  3697: 	asl.w			#2,d2									; d2 = long word index
02:00007B0A 23812000        	  3698: 	move.l		d1,(a1,d2.w)					; move breakpoint address to table
02:00007B0E 2441            	  3699: 	move.l		d1,a2
02:00007B10 E24A            	  3700: 	lsr.w			#1,d2									; d2 = word index
                            	  3701: .0004:
02:00007B12 43F900040280    	  3702: 	lea				BreakpointWords,a1
02:00007B18 33922000        	  3703: 	move.w		(a2),(a1,d2.w)				; copy instruction word to table
02:00007B1C 34BC4E43        	  3704: 	move.w		#$4E43,(a2)						; replace word with TRAP3
                            	  3705: .0001:
02:00007B20 4CDF0707        	  3706: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
02:00007B24 4E75            	  3707: 	rts
                            	  3708: .0003:
02:00007B26 2469FFFC        	  3709: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
02:00007B2A 0C524E43        	  3710: 	cmpi.w		#$4E43,(a2)						; see if breakpoint already armed
02:00007B2E 67F0            	  3711: 	beq.s			.0001
02:00007B30 D482            	  3712: 	asl.l			#1,d2									; d2 = word index
02:00007B32 60DE            	  3713: 	bra.s			.0004
                            	  3714: 
                            	  3715: 
                            	  3716: ;------------------------------------------------------------------------------
                            	  3717: ;------------------------------------------------------------------------------
                            	  3718: 
                            	  3719: DisarmBreakpoint:
02:00007B34 48E7E0E0        	  3720: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
02:00007B38 303900040202    	  3721: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
02:00007B3E 0C400008        	  3722: 	cmpi.w		#numBreakpoints,d0		; check if too many
02:00007B42 623E            	  3723: 	bhi.s			.0001
02:00007B44 2400            	  3724: 	move.l		d0,d2
02:00007B46 6100F08C        	  3725: 	bsr				ignBlanks
02:00007B4A 6100F260        	  3726: 	bsr				GetHexNumber
02:00007B4E 6732            	  3727: 	beq.s			.0001									; was there an address?
02:00007B50 08010000        	  3728: 	btst			#0,d1									; address value must be even
02:00007B54 662C            	  3729: 	bne.s			.0001
                            	  3730: 	; See if the breakpoint is in the table already
02:00007B56 43F900040220    	  3731: 	lea				Breakpoints,a1				; a1 points to breakpoint table
02:00007B5C 5342            	  3732: 	subi.w		#1,d2
                            	  3733: .0002:
02:00007B5E B299            	  3734: 	cmp.l			(a1)+,d1
02:00007B60 6706            	  3735: 	beq.s			.0003									; breakpoint is in table already
02:00007B62 51CAFFFA        	  3736: 	dbra			d2,.0002
02:00007B66 601A            	  3737: 	bra				.0001									; breakpoint was not in table
                            	  3738: .0003:
                            	  3739: 	; Remove breakpoint from table
02:00007B68 537900040202    	  3740: 	subi.w		#1,NumSetBreakpoints	; decrement number of breakpoints
02:00007B6E 2469FFFC        	  3741: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
02:00007B72 42A9FFFC        	  3742: 	clr.l			-4(a1)								; empty out breakpoint
02:00007B76 43F900040280    	  3743: 	lea				BreakpointWords,a1
02:00007B7C D482            	  3744: 	asl.l			#1,d2									; d2 = word index
02:00007B7E 34B12000        	  3745: 	move.w		(a1,d2.w),(a2)				; copy instruction from table back to code
                            	  3746: .0001:
02:00007B82 4CDF0707        	  3747: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
02:00007B86 4E75            	  3748: 	rts
                            	  3749: 
                            	  3750: ;------------------------------------------------------------------------------
                            	  3751: ;------------------------------------------------------------------------------
                            	  3752: 
                            	  3753: ListBreakpoints:
02:00007B88 6100DD0C        	  3754: 	bsr			CRLF
02:00007B8C 343C0008        	  3755: 	move.w	#numBreakpoints,d2
02:00007B90 43F900040220    	  3756: 	lea			Breakpoints,a1
                            	  3757: .0001:
02:00007B96 2219            	  3758: 	move.l	(a1)+,d1
02:00007B98 6100F7FA        	  3759: 	bsr			DisplayTetra
02:00007B9C 6100DCF8        	  3760: 	bsr			CRLF
02:00007BA0 51CAFFF4        	  3761: 	dbra		d2,.0001
02:00007BA4 6000EAF2        	  3762: 	bra			Monitor
                            	  3763: 
                            	  3764: ;------------------------------------------------------------------------------
                            	  3765: ;------------------------------------------------------------------------------
                            	  3766: 
                            	  3767: ClearBreakpointList:
02:00007BA8 343C0008        	  3768: 	move.w	#numBreakpoints,d2
02:00007BAC 43F900040220    	  3769: 	lea			Breakpoints,a1
                            	  3770: .0001:
02:00007BB2 4299            	  3771: 	clr.l		(a1)+
02:00007BB4 51CAFFFC        	  3772: 	dbra		d2,.0001
02:00007BB8 4E75            	  3773: 	rts
                            	  3774: 
                            	  3775: ;------------------------------------------------------------------------------
                            	  3776: ; SendMsg
                            	  3777: ; 00100xy0
                            	  3778: ;
                            	  3779: ; Parameters:
                            	  3780: ;		d1 = target core number
                            	  3781: ;		d2 = argument 1
                            	  3782: ;		d3 = argument 2
                            	  3783: ;		d4 = argument 3
                            	  3784: ;
                            	  3785: ;------------------------------------------------------------------------------
                            	  3786: 
                            	  3787: SendMsg:
02:00007BBA 48E70440        	  3788: 	movem.l	d5/a1,-(a7)
02:00007BBE E149            	  3789: 	lsl.w		#8,d1
02:00007BC0 4E7A5FE0        	  3790: 	movec		coreno,d5
02:00007BC4 E94D            	  3791: 	lsl.w		#4,d5
02:00007BC6 8245            	  3792: 	or.w		d5,d1
02:00007BC8 43F900100000    	  3793: 	lea			$00100000,a1
02:00007BCE 4AB11000        	  3794: 	tst.l		0(a1,d1.w)
02:00007BD2 661C            	  3795: 	bne			.msgFull
02:00007BD4 4E7A5FE0        	  3796: 	movec		coreno,d5
02:00007BD8 23851000        	  3797: 	move.l	d5,0(a1,d1.w)
02:00007BDC 23821004        	  3798: 	move.l	d2,4(a1,d1.w)
02:00007BE0 23831008        	  3799: 	move.l	d3,8(a1,d1.w)
02:00007BE4 2384100C        	  3800: 	move.l	d4,12(a1,d1.w)
02:00007BE8 4CDF0220        	  3801: 	movem.l	(a7)+,d5/a1
02:00007BEC 7200            	  3802: 	moveq		#0,d1
02:00007BEE 4E75            	  3803: 	rts
                            	  3804: .msgFull:
02:00007BF0 4CDF0220        	  3805: 	movem.l	(a7)+,d5/a1
02:00007BF4 72FF            	  3806: 	moveq		#-1,d1
02:00007BF6 4E75            	  3807: 	rts
                            	  3808: 
                            	  3809: ;------------------------------------------------------------------------------
                            	  3810: ; ReceiveMsg
                            	  3811: ;		Scan the message table for messages and dispatch them.
                            	  3812: ; 00100xy0
                            	  3813: ;
                            	  3814: ; Parameters:
                            	  3815: ;------------------------------------------------------------------------------
                            	  3816: 
                            	  3817: ReceiveMsg:
02:00007BF8 48E77F40        	  3818: 	movem.l		d1/d2/d3/d4/d5/d6/d7/a1,-(a7)
02:00007BFC 43F900100000    	  3819: 	lea				$00100000,a1
02:00007C02 4E7A5FE0        	  3820: 	movec			coreno,d5
02:00007C06 E14D            	  3821: 	lsl.w			#8,d5
02:00007C08 7C02            	  3822: 	moveq			#2,d6
                            	  3823: .nextCore:
02:00007C0A 3E06            	  3824: 	move.w		d6,d7
02:00007C0C E94F            	  3825: 	lsl.w			#4,d7
02:00007C0E DE45            	  3826: 	add.w			d5,d7
02:00007C10 4AB17000        	  3827: 	tst.l			0(a1,d7.w)			; Is there a message from core d6?
02:00007C14 6716            	  3828: 	beq.s			.noMsg
02:00007C16 22317000        	  3829: 	move.l		0(a1,d7.w),d1
02:00007C1A 24317004        	  3830: 	move.l		4(a1,d7.w),d2
02:00007C1E 26317008        	  3831: 	move.l		8(a1,d7.w),d3
02:00007C22 2831700C        	  3832: 	move.l		12(a1,d7.w),d4
02:00007C26 42B17000        	  3833: 	clr.l			0(a1,d7.w)			; indicate message was received
02:00007C2A 610E            	  3834: 	bsr				DispatchMsg
                            	  3835: .noMsg:
02:00007C2C 5246            	  3836: 	addq			#1,d6
02:00007C2E BC7C0009        	  3837: 	cmp.w			#9,d6
02:00007C32 63D6            	  3838: 	bls				.nextCore
02:00007C34 4CDF02FE        	  3839: 	movem.l		(a7)+,d1/d2/d3/d4/d5/d6/d7/a1
02:00007C38 4E75            	  3840: 	rts
                            	  3841: 
                            	  3842: ;------------------------------------------------------------------------------
                            	  3843: ;------------------------------------------------------------------------------
                            	  3844: 
                            	  3845: DispatchMsg:
02:00007C3A 4E75            	  3846: 	rts
                            	  3847: 
                            	  3848: ;------------------------------------------------------------------------------
                            	  3849: ; Trap #15, function 39 - convert floating-point to string and display
                            	  3850: ;
                            	  3851: ; Parameters
                            	  3852: ;		a1 = pointer to buffer
                            	  3853: ;		fp0 = number to print
                            	  3854: ;		d1 = width of print field
                            	  3855: ;		d2 = precision
                            	  3856: ;		d3 = 'E' or 'e'
                            	  3857: ;------------------------------------------------------------------------------
                            	  3858: 
                            	  3859: prtflt:
02:00007C3C 4E52FFD0        	  3860: 	link a2,#-48
02:00007C40 2F7900040098002C	  3861: 	move.l _canary,44(sp)
02:00007C48 48D7074F        	  3862: 	movem.l d0/d1/d2/d3/d6/a0/a1/a2,(sp)
02:00007C4C F22F68000020    	  3863: 	fmove.x fp0,32(sp)
02:00007C52 2049            	  3864: 	move.l a1,a0						; a0 = pointer to buffer to use
02:00007C54 13C100040508    	  3865: 	move.b d1,_width
02:00007C5A 23C200040514    	  3866: 	move.l d2,_precision
02:00007C60 13C30004050C    	  3867: 	move.b d3,_E
02:00007C66 6100F4A8        	  3868: 	bsr _FloatToString
02:00007C6A 6100DF22        	  3869: 	bsr DisplayString
02:00007C6E F22F48000020    	  3870: 	fmove.x 32(sp),fp0
02:00007C74 4CD7074F        	  3871: 	movem.l (sp),d0/d1/d2/d3/d6/a0/a1/a2
02:00007C78 A2AF0003002C    	  3872: 	cchk 44(sp)
02:00007C7E 4E5A            	  3873: 	unlk a2
02:00007C80 4E75            	  3874: 	rts
                            	  3875: 
                            	  3876: T15FloatToString:
02:00007C82 4E52FFD4        	  3877: 	link a2,#-44
02:00007C86 2F79000400980028	  3878: 	move.l _canary,40(sp)
02:00007C8E 48D7034F        	  3879: 	movem.l d0/d1/d2/d3/d6/a0/a1,(sp)
02:00007C92 F22F6800001C    	  3880: 	fmove.x fp0,28(sp)
02:00007C98 2049            	  3881: 	move.l a1,a0						; a0 = pointer to buffer to use
02:00007C9A 13C100040508    	  3882: 	move.b d1,_width
02:00007CA0 23C200040514    	  3883: 	move.l d2,_precision
02:00007CA6 13C30004050C    	  3884: 	move.b d3,_E
02:00007CAC 6100F462        	  3885: 	bsr _FloatToString
02:00007CB0 F22F4800001C    	  3886: 	fmove.x 28(sp),fp0
02:00007CB6 4CD7034F        	  3887: 	movem.l (sp),d0/d1/d2/d3/d6/a0/a1
02:00007CBA A2AF00030028    	  3888: 	cchk 40(sp)
02:00007CC0 4E5A            	  3889: 	unlk a2
02:00007CC2 4E75            	  3890: 	rts
                            	  3891: 
                            	  3892: ;==============================================================================
                            	  3893: ;==============================================================================
                            	  3894: 
                            	  3895: OutputChar:
02:00007CC4 0C390001000400A8	  3896: 	cmpi.b #1,OutputDevice	; stdout
02:00007CCC 6604            	  3897: 	bne .0001
02:00007CCE 6000DC10        	  3898: 	bra DisplayChar
                            	  3899: .0001
02:00007CD2 0C390002000400A8	  3900: 	cmpi.b #2,OutputDevice
02:00007CDA 6604            	  3901: 	bne .0002
02:00007CDC 6000FAF2        	  3902: 	bra	SerialPutChar
                            	  3903: .0002
02:00007CE0 4E75            	  3904: 	rts
                            	  3905: 
                            	  3906: ;------------------------------------------------------------------------------
                            	  3907: ;------------------------------------------------------------------------------
                            	  3908: 
                            	  3909: InitIRQ:
02:00007CE2 7006            	  3910: 	moveq		#6,d0
02:00007CE4 41FAE5A0        	  3911: 	lea			KeybdIRQ,a0
02:00007CE8 610C            	  3912: 	bsr			InstallIRQ
02:00007CEA 41FA003A        	  3913: 	lea			TickIRQ,a0
02:00007CEE 6106            	  3914: 	bsr			InstallIRQ
02:00007CF0 7003            	  3915: 	moveq		#3,d0
02:00007CF2 41FAFB20        	  3916: 	lea			SerialIRQ,a0
                            	  3917: 	; fall through
                            	  3918: 
                            	  3919: ;------------------------------------------------------------------------------
                            	  3920: ; Install an IRQ handler.
                            	  3921: ;
                            	  3922: ; Parameters:
                            	  3923: ;		d0 = IRQ level
                            	  3924: ;		a0 = pointer to IRQ routine
                            	  3925: ; Returns:
                            	  3926: ;		d1 = -1 if successfully added, 0 otherwise
                            	  3927: ;		nf = 1, zf = 0 if successfully added, otherwise nf = 0, zf = 1
                            	  3928: ;------------------------------------------------------------------------------
                            	  3929: 
                            	  3930: InstallIRQ:
02:00007CF6 2F00            	  3931: 	move.l	d0,-(a7)					; save working register
02:00007CF8 43F80400        	  3932: 	lea			InstalledIRQ,a1		; a1 points to installed IRQ list
02:00007CFC EB48            	  3933: 	lsl.w		#5,d0							; multiply by 8 long words per IRQ level
                            	  3934: .nextSpot:
02:00007CFE B1F10000        	  3935: 	cmpa.l	(a1,d0.w),a0			; Is the IRQ already installed?
02:00007D02 6716            	  3936: 	beq.s		.found
02:00007D04 4AB10000        	  3937: 	tst.l		(a1,d0.w)					; test for an empty spot
02:00007D08 670C            	  3938: 	beq.s		.foundSpot
02:00007D0A 5840            	  3939: 	addi.w	#4,d0							; increment to next slot
02:00007D0C 3200            	  3940: 	move.w	d0,d1
02:00007D0E 0241001F        	  3941: 	andi.w	#$1F,d1						; check to see if spots exhausted
02:00007D12 670C            	  3942: 	beq.s		.noEmpties
02:00007D14 60E8            	  3943: 	bra.s		.nextSpot
                            	  3944: .foundSpot:
02:00007D16 23880000        	  3945: 	move.l	a0,(a1,d0.w)			; add IRQ routine to table
                            	  3946: .found:
02:00007D1A 201F            	  3947: 	move.l	(a7)+,d0
02:00007D1C 72FF            	  3948: 	moveq		#-1,d1						; return success
02:00007D1E 4E75            	  3949: 	rts
                            	  3950: .noEmpties:
02:00007D20 201F            	  3951: 	move.l	(a7)+,d0
02:00007D22 7200            	  3952: 	moveq		#0,d1							; return failed to add
02:00007D24 4E75            	  3953: 	rts
                            	  3954: 	
                            	  3955: 
                            	  3956: ;------------------------------------------------------------------------------
                            	  3957: ; TickIRQ
                            	  3958: ; - this IRQ is processed by all cores.
                            	  3959: ; - core 2 is responsible for resetting the edge circuit.
                            	  3960: ; - an IRQ live indicator is updated on the text screen for the core
                            	  3961: ;------------------------------------------------------------------------------
                            	  3962: 
                            	  3963: TickIRQ:
02:00007D26 46FC2600        	  3964: 	move.w	#$2600,sr					; disable lower level IRQs
02:00007D2A 48E76080        	  3965: 	movem.l	d1/d2/a0,-(a7)
02:00007D2E 13FC0001000400A0	  3966: 	move.b #1,IRQFlag					; tick interrupt indicator in local memory
                            	  3967: 	; ToDo: detect a tick interrupt
                            	  3968: ;	move.l	PLIC+$00,d1
                            	  3969: ;	rol.l		#8,d1
                            	  3970: ;	cmpi.b	#29,d1
                            	  3971: ;	bne.s		.notTick
02:00007D36 4E7A1FE0        	  3972: 	movec		coreno,d1					; d1 = core number
02:00007D3A 0C010002        	  3973: 	cmpi.b	#2,d1
02:00007D3E 660A            	  3974: 	bne.s		.0001
02:00007D40 23FC1D000000FD09	  3975: 	move.l	#$1D000000,PLIC+$14	; reset edge sense circuit
02:00007D48 0014
                            	  3976: .0001:	
02:00007D4A 207900040004    	  3977: 	move.l	TextScr,a0				; a0 = screen address
02:00007D50 2410            	  3978: 	move.l	(a0),d2
02:00007D52 E15A            	  3979: 	rol.w		#8,d2							; reverse byte order of d2
02:00007D54 4842            	  3980: 	swap		d2
02:00007D56 E15A            	  3981: 	rol.w		#8,d2
02:00007D58 06010030        	  3982: 	addi.b	#'0',d1						; binary to ascii core number
02:00007D5C D202            	  3983: 	add.b		d2,d1
02:00007D5E E159            	  3984: 	rol.w		#8,d1							; put bytes back in order
02:00007D60 4841            	  3985: 	swap		d1
02:00007D62 E159            	  3986: 	rol.w		#8,d1
02:00007D64 21410004        	  3987: 	move.l	d1,4(a0)					; update onscreen IRQ flag
02:00007D68 5290            	  3988: 	addi.l	#1,(a0)						; flashy colors
                            	  3989: ; addi.l	#1,40(a0)					; nice effect
02:00007D6A 6100FE8C        	  3990: 	bsr			ReceiveMsg
02:00007D6E 4CDF0106        	  3991: 	movem.l	(a7)+,d1/d2/a0
02:00007D72 4E73            	  3992: 	rte
                            	  3993: ;.notTick:
                            	  3994: ;	movem.l	(a7)+,d1/a0
                            	  3995: ;	rte
                            	  3996: ;------------------------------------------------------------------------------
                            	  3997: ;------------------------------------------------------------------------------
                            	  3998: 
                            	  3999: irq3_rout:
02:00007D74 48E7C0C0        	  4000: 	movem.l	d0/d1/a0/a1,-(a7)
02:00007D78 41F80460        	  4001: 	lea			InstalledIRQ+8*4*3,a0
02:00007D7C 6008            	  4002: 	bra			irq_rout
                            	  4003: 
                            	  4004: irq6_rout:
02:00007D7E 48E7C0C0        	  4005: 	movem.l	d0/d1/a0/a1,-(a7)
02:00007D82 41F804C0        	  4006: 	lea			InstalledIRQ+8*4*6,a0
                            	  4007: irq_rout:
02:00007D86 7007            	  4008: 	moveq		#7,d0
                            	  4009: .nextHandler:
02:00007D88 2258            	  4010: 	move.l	(a0)+,a1
02:00007D8A 6706            	  4011: 	beq.s		.0003
02:00007D8C 4E91            	  4012: 	jsr			(a1)
02:00007D8E 4A81            	  4013: 	tst.l		d1								; was IRQ handled?
02:00007D90 6B04            	  4014: 	bmi.s		.0002							; first one to return handled quits loop
                            	  4015: .0003:
02:00007D92 51C8FFF4        	  4016: 	dbra		d0,.nextHandler
                            	  4017: .0002:
02:00007D96 4CDF0303        	  4018: 	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  4019: 
                            	  4020: SpuriousIRQ:
02:00007D9A 4E73            	  4021: 	rte
                            	  4022: 
                            	  4023: ;	bsr			KeybdIRQ
                            	  4024: ;	tst.l		d1								; handled by KeybdIRQ?
                            	  4025: ;	bmi.s		.0002							; if yes, go return
                            	  4026: ;.0001:
                            	  4027: ;	move.l	#$1D000000,PLIC+$14	; reset edge sense circuit
                            	  4028: ;	move.l	TextScr,a0				; a0 = screen address
                            	  4029: ;	addi.l	#1,40(a0)					; update onscreen IRQ flag
                            	  4030: ;.0002:	
                            	  4031: ;	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  4032: ;	rte
                            	  4033: 
                            	  4034: nmi_rout:
02:00007D9C 48E7C080        	  4035: 	movem.l	d0/d1/a0,-(a7)
02:00007DA0 123C004E        	  4036: 	move.b	#'N',d1
02:00007DA4 6100DB3A        	  4037: 	bsr			DisplayChar
02:00007DA8 4CDF0103        	  4038: 	movem.l	(a7)+,d0/d1/a0		; return
02:00007DAC 4E73            	  4039: 	rte
                            	  4040: 
                            	  4041: addr_err:
02:00007DAE 544F            	  4042: 	addq		#2,sp						; get rid of sr
02:00007DB0 221F            	  4043: 	move.l	(sp)+,d1				; pop exception address
02:00007DB2 6100F5E0        	  4044: 	bsr			DisplayTetra		; and display it
02:00007DB6 43FA00A6        	  4045: 	lea			msgAddrErr,a1	; followed by message
02:00007DBA 6100DDE8        	  4046: 	bsr			DisplayStringCRLF
                            	  4047: .0001:
02:00007DBE 60FE            	  4048: 	bra			.0001
02:00007DC0 6000E8D6        	  4049: 	bra			Monitor
                            	  4050: 	
                            	  4051: brdisp_trap:
02:00007DC4 48F9FFFF00040100	  4052: 	movem.l	d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
02:00007DCC 33DF00040140    	  4053: 	move.w	(a7)+,Regsave+$40
02:00007DD2 23DF00040144    	  4054: 	move.l	(a7)+,Regsave+$44
02:00007DD8 2E7C00040FFC    	  4055: 	move.l	#$40FFC,a7			; reset stack pointer
02:00007DDE 46FC2500        	  4056: 	move.w	#$2500,sr				; enable interrupts
02:00007DE2 43FA0099        	  4057: 	lea			msg_bad_branch_disp,a1
02:00007DE6 6100DDA6        	  4058: 	bsr			DisplayString
02:00007DEA 6100F5A0        	  4059: 	bsr			DisplaySpace
02:00007DEE 223900040144    	  4060: 	move.l	Regsave+$44,d1	; exception address
02:00007DF4 6100F59E        	  4061: 	bsr			DisplayTetra		; and display it
                            	  4062: ;	move.l	(sp)+,d1				; pop format word 68010 mode only
02:00007DF8 6000EEE8        	  4063: 	bra			cmdDumpRegs
                            	  4064: 
                            	  4065: illegal_trap:
02:00007DFC 544F            	  4066: 	addq		#2,sp						; get rid of sr
02:00007DFE 221F            	  4067: 	move.l	(sp)+,d1				; pop exception address
02:00007E00 6100F592        	  4068: 	bsr			DisplayTetra		; and display it
02:00007E04 43FA0065        	  4069: 	lea			msg_illegal,a1	; followed by message
02:00007E08 6100DD84        	  4070: 	bsr			DisplayString
                            	  4071: .0001:
02:00007E0C 60FE            	  4072: 	bra			.0001
02:00007E0E 6000E888        	  4073: 	bra			Monitor
                            	  4074: 	
                            	  4075: io_irq:
02:00007E12 544F            	  4076: 	addq #2,sp
02:00007E14 221F            	  4077: 	move.l (sp)+,d1
02:00007E16 6100F57C        	  4078: 	bsr DisplayTetra
02:00007E1A 43FA0083        	  4079: 	lea msg_io_access,a1
02:00007E1E 6100DD6E        	  4080: 	bsr DisplayString
02:00007E22 6000EEBE        	  4081: 	bra cmdDumpRegs
                            	  4082: 
                            	  4083: ; -----------------------------------------------------------------------------
                            	  4084: ; -----------------------------------------------------------------------------
                            	  4085: 
                            	  4086: msg_start:
02:00007E26 46656D74696B6920	  4087: 	dc.b	"Femtiki rf68k Multi-core OS Starting",LF,CR,0
02:00007E2E 726636386B204D75
02:00007E36 6C74692D636F7265
02:00007E3E 204F532053746172
02:00007E46 74696E67
02:00007E4A 0A
02:00007E4B 0D
02:00007E4C 00
                            	  4088: ;	dc.b	"rf68k System Starting",CR,LF,0
                            	  4089: msg_core_start:
02:00007E4D 20636F7265207374	  4090: 	dc.b	" core starting",CR,LF,0
02:00007E55 617274696E67
02:00007E5B 0D
02:00007E5C 0A
02:00007E5D 00
                            	  4091: msgAddrErr
02:00007E5E 2061646472657373	  4092: 	dc.b	" address err",0
02:00007E66 20657272
02:00007E6A 00
                            	  4093: msg_illegal:
02:00007E6B 20696C6C6567616C	  4094: 	dc.b	" illegal opcode",CR,LF,0
02:00007E73 206F70636F6465
02:00007E7A 0D
02:00007E7B 0A
02:00007E7C 00
                            	  4095: msg_bad_branch_disp:
02:00007E7D 206272616E636820	  4096: 	dc.b	" branch selfref: ",0
02:00007E85 73656C667265663A
02:00007E8D 20
02:00007E8E 00
                            	  4097: msg_test_done:
02:00007E8F 2043505520746573	  4098: 	dc.b	" CPU test done.",0
02:00007E97 7420646F6E652E
02:00007E9E 00
                            	  4099: msg_io_access
02:00007E9F 20756E7065726D69	  4100: 	dc.b " unpermitted access to I/O",0
02:00007EA7 7474656420616363
02:00007EAF 65737320746F2049
02:00007EB7 2F4F
02:00007EB9 00
                            	  4101: msgChk
02:00007EBA 20636865636B2066	  4102: 	dc.b " check failed",0
02:00007EC2 61696C6564
02:00007EC7 00
                            	  4103: msgStackCanary
02:00007EC8 20737461636B2063	  4104: 	dc.b " stack canary overwritten",0
02:00007ED0 616E617279206F76
02:00007ED8 6572777269747465
02:00007EE0 6E
02:00007EE1 00
                            	  4105: 


Symbols by name:
ABCD_INNER1                     02:0000269E
ABCD_INNER2                     02:0000270C
ABCD_NO_C1                      02:000026BA
ABCD_NO_C2                      02:000026C2
ABCD_NO_C3                      02:00002728
ABCD_NO_C4                      02:00002730
ABCD_OUTER1                     02:0000269C
ABCD_OUTER2                     02:0000270A
ABS                             02:00004D80
ACIA                             E:FD060000
ACIA_CMD                         E:00000008
ACIA_CTRL                        E:0000000C
ACIA_RX                          E:00000000
ACIA_STAT                        E:00000004
ACIA_TX                          E:00000000
ADDA_OUTER1                     02:0000320C
ADDQ_LOOP1                      02:00002A26
ADDQ_LOOP2                      02:00002A64
ADDQ_LOOP3                      02:00002A9A
ADDX_LOOP3                      02:00003332
ADDX_LOOP4                      02:0000334E
ADDX_LOOP5                      02:0000336A
ADDX_OUTER1                     02:0000329E
ADD_OUTER1                      02:00003032
ADD_OUTER2                      02:000030A6
AHOW                            02:00004FF8
ALL_DONE                        02:00000410
AND_OUTER1                      02:00002D50
AND_OUTER2                      02:00002DC4
ASORRY                          02:00004FF0
AUXIN                           02:0000531C
AUXOUT                          02:00005308
AWHAT                           02:00004FB0
AXIRET                          02:0000533A
AllocateString                  02:00004A98
ArmAllBreakpoints               02:00007A86
ArmBreakpoint                   02:00007AB6
AsciiToHexNybble                02:00007340
AudioInputTest                  02:000076C0
BCC1                            02:00002944
BCC10                           02:00002996
BCC11                           02:0000299E
BCC12                           02:000029A8
BCC13                           02:000029B0
BCC14                           02:000029BA
BCC2                            02:0000294E
BCC3                            02:00002956
BCC4                            02:00002960
BCC5                            02:00002968
BCC6                            02:00002972
BCC7                            02:0000297A
BCC8                            02:00002984
BCC9                            02:0000298C
BSR_CLOSE1                      02:000014E4
BSR_CLOSE2                      02:0000151A
BSR_FAR1                        02:00000412
BSR_FAR2                        02:00002934
BUFFER                          02:0000540C
BUFLEN                           E:00000050
BYEBYE                          02:0000533C
BlankLastLine                   02:00005B1E
BouncingBalls                   02:000076C2
BreakpointWords                  E:00040280
Breakpoints                      E:00040220
CALL                            02:0000473E
CHKIO                           02:000052AE
CHKRET                          02:000052BE
CHR                             02:00004F2A
CLMSG                           02:000053A4
CLS                             02:000052CC
CMPA_OUTER1                     02:00002F26
CMPM_LOOP1                      02:00002FB4
CMPM_LOOP2                      02:00002FCE
CMPM_LOOP3                      02:00002FE8
CMP_OUTER1                      02:00002EB0
CORENO                          02:00004DA8
CR                               E:0000000D
CRLF                            02:00005896
CSTART                          02:00003E92
CTRLC                            E:00000003
CTRLH                            E:00000008
CTRLS                            E:00000013
CTRLX                            E:00000018
CTRLZ                            E:0000001A
CURRNT                          02:000053B4
CalcScreenLoc                   02:000058D2
CallOS                          02:0000569C
CheckForCtrlC                   02:00005FC0
CheckForKey                     02:00005F7C
CheckNumeric                    02:00004808
ClearBreakpointList             02:00007BA8
ClearScreen                     02:000076C6
ClearStringArea                 02:00003FBC
ClearStringStack                02:00003FDC
CmdBuf                           E:00040040
CmdBufEnd                        E:00040080
ConcatString                    02:00004914
Cursor1                         02:00005CE4
CursorCol                        E:00040001
CursorRow                        E:00040000
DBCC_LOOP1                      02:000029C4
DBCC_LOOP2                      02:000029D2
DEFLT                           02:000045CE
DIRECT                          02:00004198
DIRFLG                          02:00005408
DIV1                            02:00004CC4
DIV2                            02:00004CCA
DIV3                            02:00004CD0
DIV32                           02:00004CB2
DIV4                            02:00004CDE
DIVRT                           02:00004CEC
DIVS_OUTER1                     02:00002C10
DIVU_OUTER1                     02:00002BBE
DOMID                           02:00004E58
DOQUO                           02:0000528C
DOQUO1                          02:00005294
DT_NUMERIC                       E:00000001
DT_STRING                        E:00000002
Delay3s                         02:000002EE
Delay3s2                        02:00000312
DisarmAllBreakpoints            02:00007A5A
DisarmBreakpoint                02:00007B34
DispatchMsg                     02:00007C3A
DisplayAddr                     02:000073C0
DisplayByte                     02:000073A0
DisplayChar                     02:000058E0
DisplayHelp                     02:000068C8
DisplayMem                      02:00006C86
DisplayNybble                   02:000073A6
DisplaySpace                    02:0000738C
DisplayString                   02:00005B8E
DisplayStringCRLF               02:00005BA4
DisplayStringLimited            02:00005BAA
DisplayStringLimitedCRLF        02:00005BCA
DisplayTetra                    02:00007394
DisplayTwoSpaces                02:0000737A
DisplayWyde                     02:0000739A
DumpMem1                        02:00006C74
ENDCHK                          02:00004F9C
ENDCHK1                         02:00004FAC
ENDMEM                          02:00003E8E
EOR_OUTER2                      02:00002E3A
ERROR                           02:00004FB4
ETYPE                           02:00004FFE
EX1                             02:000041D2
EXCEPTION_6                     02:0000041A
EXCEPTION_7                     02:00000422
EXEC                            02:000041A8
EXGO                            02:000041DE
EXLP                            02:000041B0
EXMAT                           02:000041D8
EXNGO                           02:000041BA
EXP4RT                          02:00004A08
EXPR                            02:000047B4
EXPR2                           02:000048A4
EXPR3                           02:00004982
EXPR4                           02:000049EC
EXPR_AND                        02:000047DA
EXPR_OR                         02:000047B4
EXPR_REL                        02:0000481A
E_Ok                             E:00000000
ExecuteCode                     02:00006C46
FI1                             02:00004F8E
FI2                             02:00004F9A
FIN                             02:00004F82
FINISH                          02:000043B6
FMTK_SEMA                        E:00000008
FNDLN                           02:000050A2
FNDLNP                          02:000050B0
FNDNXT                          02:000050C8
FNDRET                          02:000050C6
FNDSKP                          02:000050CA
FOR                             02:00004424
FR1                             02:0000443E
FR2                             02:00004456
FR3                             02:0000445C
FR4                             02:00004462
FR5                             02:0000446A
FR6                             02:0000447C
FR7                             02:00004488
FR8                             02:000044A0
FemtikiInit                     02:0000567C
FemtikiInitIRQ                  02:0000568C
FemtikiTimerIRQ                 02:0000576A
ForceUnlockSemaphore            02:0000027A
FreeTCB                          E:0010030C
FromScreen                      02:00006684
GBYTE                           02:00004626
GBYTE1                          02:0000462A
GBYTE2                          02:00004638
GETLN                           02:00005004
GL1                             02:00005014
GL2                             02:00005032
GL3                             02:00005046
GL4                             02:0000506A
GL5                             02:00005076
GL6                             02:00005092
GL7                             02:0000509A
GOAUXI                          02:00003E82
GOAUXO                          02:00003E7E
GOBYE                           02:00003E86
GOIN                            02:00003E7A
GOOUT                           02:00003E76
GOSUB                           02:000043BE
GOTO                            02:000042C0
GOWARM                          02:00003E72
GarbageCollectStrings           02:00004AF6
GetCmdLine                      02:00006A60
GetDecNumber                    02:00006DDA
GetHexNumber                    02:00006DAC
GetKey                          02:00005F88
GetRunningTCBPointer            02:00005706
GlobalReadLong                  02:00000132
GlobalWriteLong                 02:00000136
GraphicsDemo                    02:000076C4
HAS_MMU                          E:00000000
HOWMSG                          02:00005375
HelpMsg                         02:000068D4
HomeCursor                      02:00005BD0
I2C2                             E:FD069000
I2C_CMD                          E:00000004
I2C_CTRL                         E:00000002
I2C_PREH                         E:00000001
I2C_PREL                         E:00000000
I2C_RXR                          E:00000003
I2C_STAT                         E:00000004
I2C_TXR                          E:00000003
IF                              02:00004510
IF1                             02:00004514
IF2                             02:0000451A
IGNBLK                          02:0000525A
INC                             02:000052E8
INC1                            02:000052F4
INCOM                           02:000041F0
INCON                           02:000041E2
INITMSG                         02:0000534A
INPERR                          02:0000452A
INPPTR                          02:000053AC
INPUT                           02:00004538
INT                             02:00004F14
INT_EXPR                        02:000047A2
IOCOM                           02:000041FE
IOCON                           02:00004214
IOFocus                          E:00100000
IP2                             02:0000456A
IP3                             02:00004584
IP4                             02:000045BE
IP5                             02:000045CA
IP6                             02:00004566
IP7                             02:0000455C
IRQFlag                          E:000400A0
IRQROUT                         02:000053E8
IncCursorPos                    02:00005A72
IncCursorRow                    02:00005A92
InitIOPBitmap                   02:0000013C
InitIRQ                         02:00007CE2
InitRand                        02:0000018C
InitSemaphores                  02:00000232
InputDevice                      E:000400A4
InstallIRQ                      02:00007CF6
InstalledIRQ                     A:00000400
KEYBD                            E:FD0FFE00
KEYBD_SEMA                       E:00000003
KeybdEcho                        E:0004000C
KeybdGetChar                    02:00005FDC
KeybdGetCharNoWait              02:00005FCC
KeybdGetCharWait                02:00005FD4
KeybdGetID                      02:00005D9A
KeybdID                          E:00100016
KeybdIRQ                        02:00006286
KeybdInit                       02:00005E04
KeybdLEDs                        E:0010000E
KeybdRecvByte                   02:00005F2E
KeybdSendByte                   02:00006244
KeybdSetLED                     02:00005DD8
KeybdSetLEDStatus               02:000061F4
KeybdWaitFlag                    E:0004000D
KeybdWaitTx                     02:00005F4E
LEA1                            02:00001EF0
LEFT                            02:00004EBA
LEN                             02:00004EEE
LET                             02:000045D6
LF                               E:0000000A
LIST                            02:00004308
LOAD                            02:000045E6
LOD1                            02:000045F2
LOD2                            02:0000460C
LODEND                          02:0000461C
LOPINC                          02:000053C8
LOPLMT                          02:000053D4
LOPLN                           02:000053E0
LOPPT                           02:000053E4
LOPVAR                          02:000053C4
LS1                             02:00004314
LS2                             02:00004328
LS3                             02:0000432E
LSTROM                          02:000053A8
LT1                             02:000045E2
LastStr                         02:000053F8
ListBreakpoints                 02:00007B88
LockSemaphore                   02:00000258
LockSysSemaphore                02:000057F2
LorR1                           02:00004DEC
LorRArgs                        02:00004DB4
MAX_TID                          E:00000FFF
MEMORY_SEMA                      E:00000006
MID                             02:00004DF0
MID1                            02:00004EB6
MID2                            02:00004E38
MID4                            02:00004E84
MID5                            02:00004E50
MMU                              E:FDC00000
MOVE1                           02:00001B5E
MOVE2                           02:00001AE2
MOVE3                           02:00001BDE
MOVE4                           02:00001D38
MULS_OUTER1                     02:00003506
MULU_OUTER1                     02:000034BA
MVDOWN                          02:000050EC
MVRET                           02:000050E0
MVUP                            02:000050D8
MVUPW                           02:000050E2
Monitor                         02:00006698
NBCD_LOOP                       02:00002884
NBCD_LOOP1                      02:000028CA
NBCD_NO_C                       02:00002890
NBCD_NO_C1                      02:000028DE
NBCD_NO_Z                       02:00002894
NBCD_NO_Z1                      02:000028E2
NEW                             02:0000422A
NEXT                            02:000044A4
NOSTRING                        02:0000538C
NR_TCB                           E:00001000
NUM_EXPR                        02:00004794
NX0                             02:000044AE
NX1                             02:000044EE
NX2                             02:00004506
NX3                             02:000044C0
NextRec                         02:000074BA
NextString                      02:00004B32
NumSetBreakpoints                E:00040202
OKMSG                           02:0000536E
ONIRQ                           02:000042D4
ONIRQ1                          02:000042EE
OR_OUTER1                       02:00002C66
OR_OUTER2                       02:00002CDA
OSCallTable                     02:0000569A
OUTC                            02:000052D8
OUTCOM                          02:00004208
OUTCON                          02:0000421E
OUTPTR                          02:000053B0
OutputChar                      02:00007CC4
OutputDevice                     E:000400A8
PARN                            02:00004A82
PBYTE                           02:000046A4
PBYTE1                          02:000046A6
PBYTE2                          02:000046BA
PEEK                            02:00004CEE
PKER                            02:0000473A
PLIC                             E:FD090000
POKE                            02:000046C4
POPA                            02:000050F4
PR0                             02:00004352
PR1                             02:00004360
PR2                             02:00004344
PR3                             02:0000436E
PR6                             02:0000437A
PR8                             02:00004380
PR9                             02:0000439C
PRINT                           02:00004334
PRMESG                          02:000052C0
PRMRET                          02:000052CA
PRTLN                           02:000051D8
PRTNUM                          02:0000518E
PRTRET                          02:00005180
PRTSTG                          02:00005166
PRTSTR2                         02:00005188
PRTSTR2a                        02:00005182
PS1                             02:00005168
PUSHA                           02:00005130
PointsIntoStringArea            02:00004B8E
ProcessBreakpoint               02:00007A54
ProcessRec                      02:000074CC
ProcessS1                       02:000075CE
ProcessS2                       02:000075D2
ProcessS3                       02:000075D6
ProcessS7                       02:000075DA
ProcessS8                       02:000075EA
ProcessS9                       02:000075FA
Prompt1                         02:000066D6
Prompt3                         02:000066C0
PromptLn                        02:000066B4
QHOW                            02:00004FF6
QSORRY                          02:00004FEE
QWHAT                           02:00004FAE
QueueCycle                       E:0010031C
RAND_MW                          E:FD0FFD0C
RAND_MZ                          E:FD0FFD08
RAND_NUM                         E:FD0FFD00
RAND_SEMA                        E:00000004
RAND_STRM                        E:FD0FFD04
RANPNT                          02:000053A8
REM                             02:0000450E
RETURN                          02:000043F8
RIGHT                           02:00004EC6
RND                             02:00004D56
ROXx_FLAGS                      02:000037CE
ROXx_LOOP1                      02:000037E4
ROXx_LOOP2                      02:00003804
ROXx_LOOP3                      02:00003824
ROXx_LOOP4                      02:00003844
ROXx_LOOP5                      02:00003864
ROXx_LOOP6                      02:00003886
ROx_FLAGS                       02:00003598
ROx_LOOP1                       02:000035AE
ROx_LOOP2                       02:000035CE
ROx_LOOP3                       02:000035EE
ROx_LOOP4                       02:0000360E
ROx_LOOP5                       02:0000362E
ROx_LOOP6                       02:00003650
RST_REG                          E:FD0FFC00
RTCBuf                           E:00100200
RTR_DONE                        02:00002926
RUN                             02:00004246
RUN1                            02:0000429A
RUNNXL                          02:0000425A
RUNSML                          02:000042B0
RUNTSL                          02:000042A6
RandGetNum                      02:000001CC
RandInit                        02:0000018C
RandWait                        02:0000021C
ReceiveMsg                      02:00007BF8
Regsave                          E:00040100
RunningTCB                       E:00100224
S1932a                          02:00007642
S1932b                          02:00007656
S19Checksum                      E:00100150
S19Get16BitAddress              02:0000760A
S19Get24BitAddress              02:00007618
S19Get32BitAddress              02:00007624
S19StartAddress                  E:00040008
SAVE                            02:00004646
SAVE1                           02:0000464E
SAVE2                           02:00004672
SAVEND                          02:00004680
SBCD_INNER1                     02:00002796
SBCD_INNER2                     02:00002804
SBCD_NO_C1                      02:000027B2
SBCD_NO_C2                      02:000027BA
SBCD_NO_C3                      02:00002820
SBCD_NO_C4                      02:00002828
SBCD_OUTER1                     02:00002794
SBCD_OUTER2                     02:00002802
SCREEN_SEMA                      E:00000005
SC_ALT                           E:00000011
SC_CAPSLOCK                      E:00000058
SC_CTRL                          E:00000014
SC_EXTEND                        E:000000E0
SC_KEYUP                         E:000000F0
SC_LSHIFT                        E:00000012
SC_NUMLOCK                       E:00000077
SC_RSHIFT                        E:00000059
SC_SCROLLLOCK                    E:0000007E
SC_TAB                           E:0000000D
SERIAL_SEMA                      E:00000002
SETVAL                          02:00004F62
SHIFTS2_FLAGS                   02:00003C46
SHIFTS2_LOOP1                   02:00003C5C
SHIFTS2_LOOP2                   02:00003C78
SHIFTS2_LOOP3                   02:00003C94
SHIFTS2_LOOP4                   02:00003CB0
SHIFTS2_LOOP5                   02:00003CCC
SHIFTS2_LOOP6                   02:00003CEA
SHIFTS_FLAGS                    02:00003A04
SHIFTS_LOOP1                    02:00003A1A
SHIFTS_LOOP2                    02:00003A3A
SHIFTS_LOOP3                    02:00003A5A
SHIFTS_LOOP4                    02:00003A7A
SHIFTS_LOOP5                    02:00003A9A
SHIFTS_LOOP6                    02:00003ABC
SIV1                            02:00004B66
SIZE                            02:00004D8C
SRYMSG                          02:0000539E
ST3                             02:00003F30
ST4                             02:00003F82
START                           02:00003E70
STKFP                           02:000053B8
STKGOS                          02:000053BC
STKINP                          02:000053C0
STKLMT                          02:00005404
STOP                            02:0000423E
STRAREASIZE                      E:00000800
STRSTK                          02:000053EC
SUBA_OUTER1                     02:00003258
SUBQ_LOOP1                      02:00002AE4
SUBQ_LOOP2                      02:00002B1E
SUBQ_LOOP3                      02:00002B54
SUBX_LOOP3                      02:00003442
SUBX_LOOP4                      02:0000345E
SUBX_LOOP5                      02:0000347A
SUBX_OUTER1                     02:000033AE
SUB_OUTER1                      02:0000311C
SUB_OUTER2                      02:00003190
SV1                             02:00004F80
ScrollUp                        02:00005AC6
SelectThreadToRun               02:0000571E
SendMsg                         02:00007BBA
SerHeadRcv                       E:00100162
SerRcvBuf                        E:00101000
SerRcvXoff                       E:00100165
SerRcvXon                        E:00100164
SerTailRcv                       E:00100160
SerialGetChar                   02:00007706
SerialIRQ                       02:00007814
SerialInit                      02:000076D4
SerialPeekChar                  02:0000777E
SerialPeekCharDirect            02:000077B6
SerialPutChar                   02:000077D0
SerialRbo                       02:000077EC
SerialRcvCount                  02:000077F4
SetKeyboardEcho                 02:00005F74
SpuriousIRQ                     02:00007D9A
StartMon                        02:0000668E
StartQ                          02:000055CE
StrArea                         02:000053F4
StrSp                           02:000053F0
StringInVar                     02:00004B48
StringOnStack                   02:00004BB2
StubRout                        02:00005D1C
SyncCursor                      02:00005BE2
T15Abort                        02:000002CA
T15DispatchTable                02:00005C34
T15FloatToString                02:00007C82
T15GetFloat                     02:000002BC
T15LockSemaphore                02:000002B0
T15UnlockSemaphore              02:000002B6
TAB1                            02:00003FF0
TAB10                           02:000040A5
TAB10_1                         02:00004188
TAB11                           02:000040A8
TAB11_1                         02:00004190
TAB1_1                          02:000040B0
TAB2                            02:0000401F
TAB2_1                          02:000040E0
TAB4                            02:0000405C
TAB4_1                          02:00004120
TAB5                            02:0000408E
TAB5_1                          02:00004154
TAB6                            02:00004091
TAB6_1                          02:0000415C
TAB8                            02:00004096
TAB8_1                          02:00004164
TAB9                            02:000040A1
TAB9_1                          02:00004180
TC1                             02:00005208
TCBAffineChose                  02:000054FC
TCBAffinity                      E:00000084
TCBAffinityBase                  E:00000082
TCBAlloc                        02:000054CA
TCBEndTick                       E:00000070
TCBFree                         02:000054EE
TCBHandleToPointer              02:00005484
TCBIAlloc                       02:000054AC
TCBIFree                        02:000054D8
TCBInit                         02:0000545C
TCBInsertIntoReadyQueue         02:00005534
TCBNext                          E:0000007C
TCBPC                            E:00000050
TCBPointerToHandle              02:0000549C
TCBPopReadyQueue                02:000055D6
TCBPrev                          E:00000080
TCBPriority                      E:00000055
TCBRegs                          E:00000004
TCBRemoveFromReadyQueue         02:000055AC
TCBSR                            E:0000004C
TCBSSP                           E:00000048
TCBStartTick                     E:0000006C
TCBStatus                        E:00000054
TCBTicks                         E:00000074
TCBUSP                           E:00000044
TCB_SIZE                         E:00000100
TEXTREG                          E:FD080000
TICK                            02:00004D9C
TOUPB1                          02:0000526A
TOUPBRT                         02:0000528A
TOUPBUF                         02:00005264
TOUPPER                         02:0000529C
TOUPRET                         02:000052AC
TRAP15                          02:00005C18
TSTC                            02:000051F6
TSTNUM                          02:0000520E
TSTV                            02:00004C30
TSTVRT                          02:00004CB0
TS_PREEMPT                       E:00000020
TS_RUNNING                       E:00000080
TV1                             02:00004C78
TV2                             02:00004CA8
TXT                             02:0000545C
TXTBGN                          02:00003E8A
TXTUNF                          02:000053FC
TYPMSG                          02:00005384
TextCols                         E:0004008D
TextCurpos                       E:00040002
TextPos                          E:00040002
TextRows                         E:0004008C
TextScr                          E:00040004
TickIRQ                         02:00007D26
TimerStack                       E:00040BFC
USP1                            02:00004C0E
UnlockSemaphore                 02:00000294
UnlockSysSemaphore              02:00005802
UpdateIRQLive                   02:00005748
UpdateStringPointers            02:00004BE2
UpdateTextPos                   02:000058A8
VARBGN                          02:00005400
WAITIRQ                         02:000042F8
WHTMSG                          02:0000537C
WSTART                          02:00003EFC
Wait10ms                        02:0000624E
Wait300ms                       02:0000626A
XOFF                             E:00000013
XON                              E:00000011
XP11                            02:0000482E
XP12                            02:0000483A
XP13                            02:00004846
XP14                            02:00004852
XP15                            02:0000485E
XP15RT                          02:0000486A
XP16                            02:0000486C
XP17                            02:0000488A
XP18                            02:00004890
XP21                            02:000048B2
XP22                            02:000048B8
XP23                            02:000048BC
XP24                            02:000048CA
XP25                            02:000048F8
XP26                            02:000048FE
XP27                            02:00004912
XP30                            02:00004988
XP31                            02:00004994
XP34                            02:000049AA
XP35                            02:000049C4
XP36                            02:00004984
XP40                            02:000049F8
XP41                            02:00004A0A
XP42                            02:00004A92
XP43                            02:00004A94
XP44                            02:00004A76
XP45                            02:00004A24
XPRT0                           02:0000487A
XPRT1                           02:00004882
XPSTNG                          02:00004A1A
XP_AND                          02:000047EC
XP_ANDX                         02:00004802
XP_MOD                          02:000049CA
XP_OR                           02:000047C4
XP_ORX                          02:00004802
XP_POP                          02:00004768
XP_POP1                         02:0000477E
XP_PUSH                         02:00004752
_CheckNan                       02:00006E4C
_CheckNegative                  02:00006ECA
_CheckZero                      02:00006EB0
_ComputeDigitsBeforeDecpt       02:00006F24
_E                               E:0004050C
_ExtExpDigit                    02:00007048
_ExtExpDigits                   02:00007066
_FloatToString                  02:00007110
_GetExponent                    02:000071C8
_GetFloat                       02:000072C8
_GetFloatBackupChar             02:00007160
_GetFloatGetChar                02:00007152
_GetFloatIgnBlanks              02:00007158
_GetFraction                    02:00007164
_GetInteger                     02:00007252
_GetRand                        02:000001FA
_KeyState1                       E:0010000F
_KeyState2                       E:00100010
_KeybdBuf                        E:00100020
_KeybdCnt                        E:00100013
_KeybdGetScancode               02:00005F1C
_KeybdGetStatus                 02:00005F10
_KeybdHead                       E:00100011
_KeybdInit                      02:00005E04
_KeybdTail                       E:00100012
_LeadingZero                    02:00006F5E
_LessThanDbl                    02:00006EF8
_MakeBig                        02:00006EDC
_PadLeft                        02:0000708E
_PadRight                       02:000070DE
_SpitOutDigits                  02:00006F6E
_SpitOutE                       02:00007030
_TrimDotZero                    02:00007008
_TrimTrailingPoint              02:00006FEA
_TrimTrailingZeros              02:00007024
_canary                          E:00040098
_dfMil                          02:00006E38
_dfOne                          02:00006E20
_dfTen                          02:00006E2C
_digits_before_decpt             E:00040510
_fpBuf                           E:00040520
_fpTextIncr                      E:00040094
_fpWork                          E:00040600
_keybdControlCodes              02:0000651E
_keybdExtendedCodes             02:0000659E
_msgInf                         02:00006E48
_msgNan                         02:00006E44
_precision                       E:00040514
_shiftedScanCodes               02:0000641E
_unshiftedScanCodes             02:0000631E
_width                           E:00040508
addr_err                        02:00007DAE
bkColor                          E:00040088
brdisp_trap                     02:00007DC4
bus_err                         02:00007A12
chk_exception                   02:000002DA
clear_screen                    02:00005846
cmdBreakpoint                   02:0000672E
cmdClearScreen                  02:00006766
cmdClock                        02:00006858
cmdCore                         02:00006772
cmdDispatch                     02:000066E8
cmdDumpMemory                   02:00006C54
cmdDumpRegs                     02:00006CE2
cmdEditMemory                   02:00006BE6
cmdFMTK                         02:00006796
cmdFillB                        02:00006B68
cmdFillL                        02:00006BB0
cmdFillW                        02:00006B8C
cmdHelp                         02:000068C8
cmdJump                         02:00006C46
cmdLoadS19                      02:000074B4
cmdMonitor                      02:00006698
cmdReceiveSerial                02:00006B34
cmdReset                        02:00006876
cmdSendSerial                   02:00006B04
cmdString                       02:0000661E
cmdTable                        02:00006654
cmdTestCPU                      02:00006756
cmdTestFP                       02:0000679E
cmdTestGF                       02:0000682A
cmdTestRAM                      02:000073DE
cmdTestSerialReceive            02:00006D8C
cmdTinyBasic                    02:00006752
cpu_test                        02:0000032E
dccr                            02:00005908
dclf                            02:000059DE
dcx10                           02:00005970
dcx11                           02:00005992
dcx12                           02:00005988
dcx14                           02:000058FE
dcx16                           02:000059E2
dcx4                            02:000059E6
dcx6                            02:00005926
dcx7                            02:00005902
dcx8                            02:0000593C
dcx9                            02:00005952
dly3s1                          02:000002FE
dly3s2                          02:000002FC
doBackspace                     02:000059F0
doCtrlX                         02:00005A4C
doDelete                        02:000059FE
do_nothing                      02:0000012C
dspj1                           02:00005B92
dspmem1                         02:00006C96
dspspc1                         02:00007384
dsret                           02:00005B9E
edtmem1                         02:00006BEE
fgColor                          E:00040084
fpBuf                            E:000402C0
get_screen_address              02:0000583E
get_screen_color                02:00005812
gthx3                           02:00007376
gthx5                           02:00007352
gthx6                           02:00007364
i2c_setup                       02:000078A4
i2c_wait_rx_nack                02:000078F2
i2c_wait_tip                    02:000078B4
i2c_wr_cmd                      02:000078C4
i2c_xmit1                       02:000078D4
icc1                            02:00005AC4
ignBlanks                       02:00006BD4
illegal_trap                    02:00007DFC
init_i2c                        02:000078A4
init_plic                       02:00005D64
io_irq                          02:00007E12
irq3_rout                       02:00007D74
irq6_rout                       02:00007D7E
irq_rout                        02:00007D86
kbdi0002                        02:00005E2C
kbdi0004                        02:00005EA4
kbdi0005                        02:00005EBE
kbdiTryAgain                    02:00005E96
kbdiXmitBusy                    02:00005ED8
kgid1                           02:00005DCC
kgnotKbd                        02:00005DD4
leds                             E:FD0FFF00
ledxit                          02:00005EC2
loop1                           02:000000FA
loop2                           02:000000F8
loop3                           02:00005876
memend                           E:00100004
msgAddrErr                      02:00007E5E
msgBadKeybd                     02:00005EE6
msgChk                          02:00007EBA
msgHello                        02:00006A4F
msgRtcReadFail                  02:000079F8
msgStackCanary                  02:00007EC8
msgUnknownCmd                   02:00006A3F
msgXmitBusy                     02:00005EF5
msg_bad_branch_disp             02:00007E7D
msg_core_start                  02:00007E4D
msg_illegal                     02:00007E6B
msg_io_access                   02:00007E9F
msg_reglist                     02:00006D66
msg_regs                        02:00006D62
msg_start                       02:00007E26
msg_test_done                   02:00007E8F
nd1                             02:00000138
nd2                             02:00000138
nd3                             02:00000138
nd4                             02:00000138
net_delay                       02:00000138
nmeSerial                       02:0000789C
nmi_rout                        02:00007D9C
notRxInt                        02:0000788A
numBreakpoints                   E:00000008
op_ABCD                         02:0000267C
op_ADD                          02:00003012
op_ADDA                         02:000031E6
op_ADDQ                         02:00002A12
op_ADDX                         02:0000327E
op_ADD_I                        02:0000170A
op_AND                          02:00002D30
op_ANDI_TO_CCR                  02:000004BA
op_ANDI_TO_SR                   02:000004E0
op_BCC                          02:0000293C
op_BCHG                         02:000008B0
op_BCLR                         02:00000C18
op_BOOL_I                       02:0000133A
op_BSET                         02:00000F66
op_BSR                          02:000014EC
op_BTST                         02:00000506
op_BTST0                        02:00000690
op_BTST1                        02:0000069C
op_BTST10                       02:000006E4
op_BTST11                       02:000006EC
op_BTST12                       02:000006F2
op_BTST2                        02:000006A4
op_BTST20                       02:0000084A
op_BTST21                       02:00000854
op_BTST22                       02:0000085A
op_BTST23                       02:00000860
op_BTST24                       02:00000866
op_BTST25                       02:0000086C
op_BTST26                       02:00000872
op_BTST27                       02:00000878
op_BTST28                       02:0000087E
op_BTST29                       02:00000884
op_BTST3                        02:000006AC
op_BTST30                       02:0000088A
op_BTST31                       02:00000890
op_BTST32                       02:00000894
op_BTST4                        02:000006B4
op_BTST5                        02:000006BC
op_BTST6                        02:000006C4
op_BTST7                        02:000006CC
op_BTST8                        02:000006D4
op_BTST9                        02:000006DC
op_CHK                          02:00001F96
op_CMP                          02:00002E90
op_CMPA                         02:00002F06
op_CMPM                         02:00002F6C
op_CMP_I                        02:00001522
op_DBCC                         02:000029BC
op_DIVS                         02:00002BF4
op_DIVU                         02:00002BA2
op_EOR                          02:00002E1A
op_EORI_TO_CCR                  02:0000046E
op_EORI_TO_SR                   02:00000494
op_EXG                          02:00003536
op_EXT                          02:00001E16
op_LEAPEA                       02:00001E58
op_LINKS                        02:00001F68
op_MOVE                         02:00001A16
op_MOVEM                        02:0000235E
op_MOVEP                        02:000012AE
op_MOVEQ                        02:00002B86
op_MOVE_USP                     02:00001F86
op_MOVE_xxx_FLAGS               02:00001C22
op_MULS                         02:000034EA
op_MULU                         02:0000349E
op_NBCD                         02:0000286C
op_NEGS                         02:00001FD0
op_OR                           02:00002C46
op_ORI_TO_CCR                   02:0000042A
op_ORI_TO_SR                    02:0000044C
op_ROXx                         02:000037DA
op_ROx                          02:000035A4
op_RTR                          02:0000291A
op_SBCD                         02:00002774
op_SCC                          02:000029E2
op_SHIFTS                       02:00003A10
op_SHIFTS2                      02:00003C52
op_SUB                          02:000030FC
op_SUBA                         02:00003232
op_SUBQ                         02:00002ACC
op_SUBX                         02:0000338E
op_SUB_I                        02:00001890
op_SWAP                         02:00001E42
op_TAS                          02:00001F04
op_TRAPV                        02:000028FE
op_TST                          02:00001F2A
pcssxa                          02:00007562
prtflt                          02:00007C3C
ramtest                         02:000073DE
ramtest0                        02:0000742A
ramtest1                        02:00007432
ramtest2                        02:00007468
ramtest3                        02:000074B2
ramtest6                        02:00007458
rbo                             02:000076CC
readyQ                           E:00100320
rmtst1                          02:0000744C
rmtst2                          02:00007486
rmtst3                          02:0000748E
rmtst5                          02:000073F8
rotate_iofocus                  02:00005D30
rtc_read                        02:00007902
rtc_write                       02:0000798E
sGetChar                        02:00007698
select_focus1                   02:00005D42
select_iofocus                  02:00005D1E
semamem                          E:FD050000
sirq0001                        02:0000783A
sirqNxtByte                     02:00007828
sirqRxFull                      02:0000788A
start                           02:00000000
start_other                     02:0000010C
tblPow2                         02:000068A8
tcbs                             E:20010000
trap3                           02:00007A16

Symbols by value:
FD050000 semamem
FD060000 ACIA
FD069000 I2C2
FD080000 TEXTREG
FD090000 PLIC
FD0FFC00 RST_REG
FD0FFD00 RAND_NUM
FD0FFD04 RAND_STRM
FD0FFD08 RAND_MZ
FD0FFD0C RAND_MW
FD0FFE00 KEYBD
FD0FFF00 leds
FDC00000 MMU
00000000 ACIA_TX
00000000 start
00000000 E_Ok
00000000 I2C_PREL
00000000 HAS_MMU
00000000 ACIA_RX
00000001 I2C_PREH
00000001 DT_NUMERIC
00000002 SERIAL_SEMA
00000002 DT_STRING
00000002 I2C_CTRL
00000003 I2C_TXR
00000003 I2C_RXR
00000003 KEYBD_SEMA
00000003 CTRLC
00000004 RAND_SEMA
00000004 I2C_STAT
00000004 TCBRegs
00000004 ACIA_STAT
00000004 I2C_CMD
00000005 SCREEN_SEMA
00000006 MEMORY_SEMA
00000008 ACIA_CMD
00000008 numBreakpoints
00000008 CTRLH
00000008 FMTK_SEMA
0000000A LF
0000000C ACIA_CTRL
0000000D SC_TAB
0000000D CR
00000011 XON
00000011 SC_ALT
00000012 SC_LSHIFT
00000013 XOFF
00000013 CTRLS
00000014 SC_CTRL
00000018 CTRLX
0000001A CTRLZ
00000020 TS_PREEMPT
00000044 TCBUSP
00000048 TCBSSP
0000004C TCBSR
00000050 BUFLEN
00000050 TCBPC
00000054 TCBStatus
00000055 TCBPriority
00000058 SC_CAPSLOCK
00000059 SC_RSHIFT
0000006C TCBStartTick
00000070 TCBEndTick
00000074 TCBTicks
00000077 SC_NUMLOCK
0000007C TCBNext
0000007E SC_SCROLLLOCK
00000080 TCBPrev
00000080 TS_RUNNING
00000082 TCBAffinityBase
00000084 TCBAffinity
000000E0 SC_EXTEND
000000F0 SC_KEYUP
000000F8 loop2
000000FA loop1
00000100 TCB_SIZE
0000010C start_other
0000012C do_nothing
00000132 GlobalReadLong
00000136 GlobalWriteLong
00000138 nd2
00000138 nd1
00000138 nd4
00000138 net_delay
00000138 nd3
0000013C InitIOPBitmap
0000018C RandInit
0000018C InitRand
000001CC RandGetNum
000001FA _GetRand
0000021C RandWait
00000232 InitSemaphores
00000258 LockSemaphore
0000027A ForceUnlockSemaphore
00000294 UnlockSemaphore
000002B0 T15LockSemaphore
000002B6 T15UnlockSemaphore
000002BC T15GetFloat
000002CA T15Abort
000002DA chk_exception
000002EE Delay3s
000002FC dly3s2
000002FE dly3s1
00000312 Delay3s2
0000032E cpu_test
00000400 InstalledIRQ
00000410 ALL_DONE
00000412 BSR_FAR1
0000041A EXCEPTION_6
00000422 EXCEPTION_7
0000042A op_ORI_TO_CCR
0000044C op_ORI_TO_SR
0000046E op_EORI_TO_CCR
00000494 op_EORI_TO_SR
000004BA op_ANDI_TO_CCR
000004E0 op_ANDI_TO_SR
00000506 op_BTST
00000690 op_BTST0
0000069C op_BTST1
000006A4 op_BTST2
000006AC op_BTST3
000006B4 op_BTST4
000006BC op_BTST5
000006C4 op_BTST6
000006CC op_BTST7
000006D4 op_BTST8
000006DC op_BTST9
000006E4 op_BTST10
000006EC op_BTST11
000006F2 op_BTST12
00000800 STRAREASIZE
0000084A op_BTST20
00000854 op_BTST21
0000085A op_BTST22
00000860 op_BTST23
00000866 op_BTST24
0000086C op_BTST25
00000872 op_BTST26
00000878 op_BTST27
0000087E op_BTST28
00000884 op_BTST29
0000088A op_BTST30
00000890 op_BTST31
00000894 op_BTST32
000008B0 op_BCHG
00000C18 op_BCLR
00000F66 op_BSET
00000FFF MAX_TID
00001000 NR_TCB
000012AE op_MOVEP
0000133A op_BOOL_I
000014E4 BSR_CLOSE1
000014EC op_BSR
0000151A BSR_CLOSE2
00001522 op_CMP_I
0000170A op_ADD_I
00001890 op_SUB_I
00001A16 op_MOVE
00001AE2 MOVE2
00001B5E MOVE1
00001BDE MOVE3
00001C22 op_MOVE_xxx_FLAGS
00001D38 MOVE4
00001E16 op_EXT
00001E42 op_SWAP
00001E58 op_LEAPEA
00001EF0 LEA1
00001F04 op_TAS
00001F2A op_TST
00001F68 op_LINKS
00001F86 op_MOVE_USP
00001F96 op_CHK
00001FD0 op_NEGS
0000235E op_MOVEM
0000267C op_ABCD
0000269C ABCD_OUTER1
0000269E ABCD_INNER1
000026BA ABCD_NO_C1
000026C2 ABCD_NO_C2
0000270A ABCD_OUTER2
0000270C ABCD_INNER2
00002728 ABCD_NO_C3
00002730 ABCD_NO_C4
00002774 op_SBCD
00002794 SBCD_OUTER1
00002796 SBCD_INNER1
000027B2 SBCD_NO_C1
000027BA SBCD_NO_C2
00002802 SBCD_OUTER2
00002804 SBCD_INNER2
00002820 SBCD_NO_C3
00002828 SBCD_NO_C4
0000286C op_NBCD
00002884 NBCD_LOOP
00002890 NBCD_NO_C
00002894 NBCD_NO_Z
000028CA NBCD_LOOP1
000028DE NBCD_NO_C1
000028E2 NBCD_NO_Z1
000028FE op_TRAPV
0000291A op_RTR
00002926 RTR_DONE
00002934 BSR_FAR2
0000293C op_BCC
00002944 BCC1
0000294E BCC2
00002956 BCC3
00002960 BCC4
00002968 BCC5
00002972 BCC6
0000297A BCC7
00002984 BCC8
0000298C BCC9
00002996 BCC10
0000299E BCC11
000029A8 BCC12
000029B0 BCC13
000029BA BCC14
000029BC op_DBCC
000029C4 DBCC_LOOP1
000029D2 DBCC_LOOP2
000029E2 op_SCC
00002A12 op_ADDQ
00002A26 ADDQ_LOOP1
00002A64 ADDQ_LOOP2
00002A9A ADDQ_LOOP3
00002ACC op_SUBQ
00002AE4 SUBQ_LOOP1
00002B1E SUBQ_LOOP2
00002B54 SUBQ_LOOP3
00002B86 op_MOVEQ
00002BA2 op_DIVU
00002BBE DIVU_OUTER1
00002BF4 op_DIVS
00002C10 DIVS_OUTER1
00002C46 op_OR
00002C66 OR_OUTER1
00002CDA OR_OUTER2
00002D30 op_AND
00002D50 AND_OUTER1
00002DC4 AND_OUTER2
00002E1A op_EOR
00002E3A EOR_OUTER2
00002E90 op_CMP
00002EB0 CMP_OUTER1
00002F06 op_CMPA
00002F26 CMPA_OUTER1
00002F6C op_CMPM
00002FB4 CMPM_LOOP1
00002FCE CMPM_LOOP2
00002FE8 CMPM_LOOP3
00003012 op_ADD
00003032 ADD_OUTER1
000030A6 ADD_OUTER2
000030FC op_SUB
0000311C SUB_OUTER1
00003190 SUB_OUTER2
000031E6 op_ADDA
0000320C ADDA_OUTER1
00003232 op_SUBA
00003258 SUBA_OUTER1
0000327E op_ADDX
0000329E ADDX_OUTER1
00003332 ADDX_LOOP3
0000334E ADDX_LOOP4
0000336A ADDX_LOOP5
0000338E op_SUBX
000033AE SUBX_OUTER1
00003442 SUBX_LOOP3
0000345E SUBX_LOOP4
0000347A SUBX_LOOP5
0000349E op_MULU
000034BA MULU_OUTER1
000034EA op_MULS
00003506 MULS_OUTER1
00003536 op_EXG
00003598 ROx_FLAGS
000035A4 op_ROx
000035AE ROx_LOOP1
000035CE ROx_LOOP2
000035EE ROx_LOOP3
0000360E ROx_LOOP4
0000362E ROx_LOOP5
00003650 ROx_LOOP6
000037CE ROXx_FLAGS
000037DA op_ROXx
000037E4 ROXx_LOOP1
00003804 ROXx_LOOP2
00003824 ROXx_LOOP3
00003844 ROXx_LOOP4
00003864 ROXx_LOOP5
00003886 ROXx_LOOP6
00003A04 SHIFTS_FLAGS
00003A10 op_SHIFTS
00003A1A SHIFTS_LOOP1
00003A3A SHIFTS_LOOP2
00003A5A SHIFTS_LOOP3
00003A7A SHIFTS_LOOP4
00003A9A SHIFTS_LOOP5
00003ABC SHIFTS_LOOP6
00003C46 SHIFTS2_FLAGS
00003C52 op_SHIFTS2
00003C5C SHIFTS2_LOOP1
00003C78 SHIFTS2_LOOP2
00003C94 SHIFTS2_LOOP3
00003CB0 SHIFTS2_LOOP4
00003CCC SHIFTS2_LOOP5
00003CEA SHIFTS2_LOOP6
00003E70 START
00003E72 GOWARM
00003E76 GOOUT
00003E7A GOIN
00003E7E GOAUXO
00003E82 GOAUXI
00003E86 GOBYE
00003E8A TXTBGN
00003E8E ENDMEM
00003E92 CSTART
00003EFC WSTART
00003F30 ST3
00003F82 ST4
00003FBC ClearStringArea
00003FDC ClearStringStack
00003FF0 TAB1
0000401F TAB2
0000405C TAB4
0000408E TAB5
00004091 TAB6
00004096 TAB8
000040A1 TAB9
000040A5 TAB10
000040A8 TAB11
000040B0 TAB1_1
000040E0 TAB2_1
00004120 TAB4_1
00004154 TAB5_1
0000415C TAB6_1
00004164 TAB8_1
00004180 TAB9_1
00004188 TAB10_1
00004190 TAB11_1
00004198 DIRECT
000041A8 EXEC
000041B0 EXLP
000041BA EXNGO
000041D2 EX1
000041D8 EXMAT
000041DE EXGO
000041E2 INCON
000041F0 INCOM
000041FE IOCOM
00004208 OUTCOM
00004214 IOCON
0000421E OUTCON
0000422A NEW
0000423E STOP
00004246 RUN
0000425A RUNNXL
0000429A RUN1
000042A6 RUNTSL
000042B0 RUNSML
000042C0 GOTO
000042D4 ONIRQ
000042EE ONIRQ1
000042F8 WAITIRQ
00004308 LIST
00004314 LS1
00004328 LS2
0000432E LS3
00004334 PRINT
00004344 PR2
00004352 PR0
00004360 PR1
0000436E PR3
0000437A PR6
00004380 PR8
0000439C PR9
000043B6 FINISH
000043BE GOSUB
000043F8 RETURN
00004424 FOR
0000443E FR1
00004456 FR2
0000445C FR3
00004462 FR4
0000446A FR5
0000447C FR6
00004488 FR7
000044A0 FR8
000044A4 NEXT
000044AE NX0
000044C0 NX3
000044EE NX1
00004506 NX2
0000450E REM
00004510 IF
00004514 IF1
0000451A IF2
0000452A INPERR
00004538 INPUT
0000455C IP7
00004566 IP6
0000456A IP2
00004584 IP3
000045BE IP4
000045CA IP5
000045CE DEFLT
000045D6 LET
000045E2 LT1
000045E6 LOAD
000045F2 LOD1
0000460C LOD2
0000461C LODEND
00004626 GBYTE
0000462A GBYTE1
00004638 GBYTE2
00004646 SAVE
0000464E SAVE1
00004672 SAVE2
00004680 SAVEND
000046A4 PBYTE
000046A6 PBYTE1
000046BA PBYTE2
000046C4 POKE
0000473A PKER
0000473E CALL
00004752 XP_PUSH
00004768 XP_POP
0000477E XP_POP1
00004794 NUM_EXPR
000047A2 INT_EXPR
000047B4 EXPR_OR
000047B4 EXPR
000047C4 XP_OR
000047DA EXPR_AND
000047EC XP_AND
00004802 XP_ANDX
00004802 XP_ORX
00004808 CheckNumeric
0000481A EXPR_REL
0000482E XP11
0000483A XP12
00004846 XP13
00004852 XP14
0000485E XP15
0000486A XP15RT
0000486C XP16
0000487A XPRT0
00004882 XPRT1
0000488A XP17
00004890 XP18
000048A4 EXPR2
000048B2 XP21
000048B8 XP22
000048BC XP23
000048CA XP24
000048F8 XP25
000048FE XP26
00004912 XP27
00004914 ConcatString
00004982 EXPR3
00004984 XP36
00004988 XP30
00004994 XP31
000049AA XP34
000049C4 XP35
000049CA XP_MOD
000049EC EXPR4
000049F8 XP40
00004A08 EXP4RT
00004A0A XP41
00004A1A XPSTNG
00004A24 XP45
00004A76 XP44
00004A82 PARN
00004A92 XP42
00004A94 XP43
00004A98 AllocateString
00004AF6 GarbageCollectStrings
00004B32 NextString
00004B48 StringInVar
00004B66 SIV1
00004B8E PointsIntoStringArea
00004BB2 StringOnStack
00004BE2 UpdateStringPointers
00004C0E USP1
00004C30 TSTV
00004C78 TV1
00004CA8 TV2
00004CB0 TSTVRT
00004CB2 DIV32
00004CC4 DIV1
00004CCA DIV2
00004CD0 DIV3
00004CDE DIV4
00004CEC DIVRT
00004CEE PEEK
00004D56 RND
00004D80 ABS
00004D8C SIZE
00004D9C TICK
00004DA8 CORENO
00004DB4 LorRArgs
00004DEC LorR1
00004DF0 MID
00004E38 MID2
00004E50 MID5
00004E58 DOMID
00004E84 MID4
00004EB6 MID1
00004EBA LEFT
00004EC6 RIGHT
00004EEE LEN
00004F14 INT
00004F2A CHR
00004F62 SETVAL
00004F80 SV1
00004F82 FIN
00004F8E FI1
00004F9A FI2
00004F9C ENDCHK
00004FAC ENDCHK1
00004FAE QWHAT
00004FB0 AWHAT
00004FB4 ERROR
00004FEE QSORRY
00004FF0 ASORRY
00004FF6 QHOW
00004FF8 AHOW
00004FFE ETYPE
00005004 GETLN
00005014 GL1
00005032 GL2
00005046 GL3
0000506A GL4
00005076 GL5
00005092 GL6
0000509A GL7
000050A2 FNDLN
000050B0 FNDLNP
000050C6 FNDRET
000050C8 FNDNXT
000050CA FNDSKP
000050D8 MVUP
000050E0 MVRET
000050E2 MVUPW
000050EC MVDOWN
000050F4 POPA
00005130 PUSHA
00005166 PRTSTG
00005168 PS1
00005180 PRTRET
00005182 PRTSTR2a
00005188 PRTSTR2
0000518E PRTNUM
000051D8 PRTLN
000051F6 TSTC
00005208 TC1
0000520E TSTNUM
0000525A IGNBLK
00005264 TOUPBUF
0000526A TOUPB1
0000528A TOUPBRT
0000528C DOQUO
00005294 DOQUO1
0000529C TOUPPER
000052AC TOUPRET
000052AE CHKIO
000052BE CHKRET
000052C0 PRMESG
000052CA PRMRET
000052CC CLS
000052D8 OUTC
000052E8 INC
000052F4 INC1
00005308 AUXOUT
0000531C AUXIN
0000533A AXIRET
0000533C BYEBYE
0000534A INITMSG
0000536E OKMSG
00005375 HOWMSG
0000537C WHTMSG
00005384 TYPMSG
0000538C NOSTRING
0000539E SRYMSG
000053A4 CLMSG
000053A8 LSTROM
000053A8 RANPNT
000053AC INPPTR
000053B0 OUTPTR
000053B4 CURRNT
000053B8 STKFP
000053BC STKGOS
000053C0 STKINP
000053C4 LOPVAR
000053C8 LOPINC
000053D4 LOPLMT
000053E0 LOPLN
000053E4 LOPPT
000053E8 IRQROUT
000053EC STRSTK
000053F0 StrSp
000053F4 StrArea
000053F8 LastStr
000053FC TXTUNF
00005400 VARBGN
00005404 STKLMT
00005408 DIRFLG
0000540C BUFFER
0000545C TXT
0000545C TCBInit
00005484 TCBHandleToPointer
0000549C TCBPointerToHandle
000054AC TCBIAlloc
000054CA TCBAlloc
000054D8 TCBIFree
000054EE TCBFree
000054FC TCBAffineChose
00005534 TCBInsertIntoReadyQueue
000055AC TCBRemoveFromReadyQueue
000055CE StartQ
000055D6 TCBPopReadyQueue
0000567C FemtikiInit
0000568C FemtikiInitIRQ
0000569A OSCallTable
0000569C CallOS
00005706 GetRunningTCBPointer
0000571E SelectThreadToRun
00005748 UpdateIRQLive
0000576A FemtikiTimerIRQ
000057F2 LockSysSemaphore
00005802 UnlockSysSemaphore
00005812 get_screen_color
0000583E get_screen_address
00005846 clear_screen
00005876 loop3
00005896 CRLF
000058A8 UpdateTextPos
000058D2 CalcScreenLoc
000058E0 DisplayChar
000058FE dcx14
00005902 dcx7
00005908 dccr
00005926 dcx6
0000593C dcx8
00005952 dcx9
00005970 dcx10
00005988 dcx12
00005992 dcx11
000059DE dclf
000059E2 dcx16
000059E6 dcx4
000059F0 doBackspace
000059FE doDelete
00005A4C doCtrlX
00005A72 IncCursorPos
00005A92 IncCursorRow
00005AC4 icc1
00005AC6 ScrollUp
00005B1E BlankLastLine
00005B8E DisplayString
00005B92 dspj1
00005B9E dsret
00005BA4 DisplayStringCRLF
00005BAA DisplayStringLimited
00005BCA DisplayStringLimitedCRLF
00005BD0 HomeCursor
00005BE2 SyncCursor
00005C18 TRAP15
00005C34 T15DispatchTable
00005CE4 Cursor1
00005D1C StubRout
00005D1E select_iofocus
00005D30 rotate_iofocus
00005D42 select_focus1
00005D64 init_plic
00005D9A KeybdGetID
00005DCC kgid1
00005DD4 kgnotKbd
00005DD8 KeybdSetLED
00005E04 KeybdInit
00005E04 _KeybdInit
00005E2C kbdi0002
00005E96 kbdiTryAgain
00005EA4 kbdi0004
00005EBE kbdi0005
00005EC2 ledxit
00005ED8 kbdiXmitBusy
00005EE6 msgBadKeybd
00005EF5 msgXmitBusy
00005F10 _KeybdGetStatus
00005F1C _KeybdGetScancode
00005F2E KeybdRecvByte
00005F4E KeybdWaitTx
00005F74 SetKeyboardEcho
00005F7C CheckForKey
00005F88 GetKey
00005FC0 CheckForCtrlC
00005FCC KeybdGetCharNoWait
00005FD4 KeybdGetCharWait
00005FDC KeybdGetChar
000061F4 KeybdSetLEDStatus
00006244 KeybdSendByte
0000624E Wait10ms
0000626A Wait300ms
00006286 KeybdIRQ
0000631E _unshiftedScanCodes
0000641E _shiftedScanCodes
0000651E _keybdControlCodes
0000659E _keybdExtendedCodes
0000661E cmdString
00006654 cmdTable
00006684 FromScreen
0000668E StartMon
00006698 Monitor
00006698 cmdMonitor
000066B4 PromptLn
000066C0 Prompt3
000066D6 Prompt1
000066E8 cmdDispatch
0000672E cmdBreakpoint
00006752 cmdTinyBasic
00006756 cmdTestCPU
00006766 cmdClearScreen
00006772 cmdCore
00006796 cmdFMTK
0000679E cmdTestFP
0000682A cmdTestGF
00006858 cmdClock
00006876 cmdReset
000068A8 tblPow2
000068C8 DisplayHelp
000068C8 cmdHelp
000068D4 HelpMsg
00006A3F msgUnknownCmd
00006A4F msgHello
00006A60 GetCmdLine
00006B04 cmdSendSerial
00006B34 cmdReceiveSerial
00006B68 cmdFillB
00006B8C cmdFillW
00006BB0 cmdFillL
00006BD4 ignBlanks
00006BE6 cmdEditMemory
00006BEE edtmem1
00006C46 ExecuteCode
00006C46 cmdJump
00006C54 cmdDumpMemory
00006C74 DumpMem1
00006C86 DisplayMem
00006C96 dspmem1
00006CE2 cmdDumpRegs
00006D62 msg_regs
00006D66 msg_reglist
00006D8C cmdTestSerialReceive
00006DAC GetHexNumber
00006DDA GetDecNumber
00006E20 _dfOne
00006E2C _dfTen
00006E38 _dfMil
00006E44 _msgNan
00006E48 _msgInf
00006E4C _CheckNan
00006EB0 _CheckZero
00006ECA _CheckNegative
00006EDC _MakeBig
00006EF8 _LessThanDbl
00006F24 _ComputeDigitsBeforeDecpt
00006F5E _LeadingZero
00006F6E _SpitOutDigits
00006FEA _TrimTrailingPoint
00007008 _TrimDotZero
00007024 _TrimTrailingZeros
00007030 _SpitOutE
00007048 _ExtExpDigit
00007066 _ExtExpDigits
0000708E _PadLeft
000070DE _PadRight
00007110 _FloatToString
00007152 _GetFloatGetChar
00007158 _GetFloatIgnBlanks
00007160 _GetFloatBackupChar
00007164 _GetFraction
000071C8 _GetExponent
00007252 _GetInteger
000072C8 _GetFloat
00007340 AsciiToHexNybble
00007352 gthx5
00007364 gthx6
00007376 gthx3
0000737A DisplayTwoSpaces
00007384 dspspc1
0000738C DisplaySpace
00007394 DisplayTetra
0000739A DisplayWyde
000073A0 DisplayByte
000073A6 DisplayNybble
000073C0 DisplayAddr
000073DE ramtest
000073DE cmdTestRAM
000073F8 rmtst5
0000742A ramtest0
00007432 ramtest1
0000744C rmtst1
00007458 ramtest6
00007468 ramtest2
00007486 rmtst2
0000748E rmtst3
000074B2 ramtest3
000074B4 cmdLoadS19
000074BA NextRec
000074CC ProcessRec
00007562 pcssxa
000075CE ProcessS1
000075D2 ProcessS2
000075D6 ProcessS3
000075DA ProcessS7
000075EA ProcessS8
000075FA ProcessS9
0000760A S19Get16BitAddress
00007618 S19Get24BitAddress
00007624 S19Get32BitAddress
00007642 S1932a
00007656 S1932b
00007698 sGetChar
000076C0 AudioInputTest
000076C2 BouncingBalls
000076C4 GraphicsDemo
000076C6 ClearScreen
000076CC rbo
000076D4 SerialInit
00007706 SerialGetChar
0000777E SerialPeekChar
000077B6 SerialPeekCharDirect
000077D0 SerialPutChar
000077EC SerialRbo
000077F4 SerialRcvCount
00007814 SerialIRQ
00007828 sirqNxtByte
0000783A sirq0001
0000788A sirqRxFull
0000788A notRxInt
0000789C nmeSerial
000078A4 i2c_setup
000078A4 init_i2c
000078B4 i2c_wait_tip
000078C4 i2c_wr_cmd
000078D4 i2c_xmit1
000078F2 i2c_wait_rx_nack
00007902 rtc_read
0000798E rtc_write
000079F8 msgRtcReadFail
00007A12 bus_err
00007A16 trap3
00007A54 ProcessBreakpoint
00007A5A DisarmAllBreakpoints
00007A86 ArmAllBreakpoints
00007AB6 ArmBreakpoint
00007B34 DisarmBreakpoint
00007B88 ListBreakpoints
00007BA8 ClearBreakpointList
00007BBA SendMsg
00007BF8 ReceiveMsg
00007C3A DispatchMsg
00007C3C prtflt
00007C82 T15FloatToString
00007CC4 OutputChar
00007CE2 InitIRQ
00007CF6 InstallIRQ
00007D26 TickIRQ
00007D74 irq3_rout
00007D7E irq6_rout
00007D86 irq_rout
00007D9A SpuriousIRQ
00007D9C nmi_rout
00007DAE addr_err
00007DC4 brdisp_trap
00007DFC illegal_trap
00007E12 io_irq
00007E26 msg_start
00007E4D msg_core_start
00007E5E msgAddrErr
00007E6B msg_illegal
00007E7D msg_bad_branch_disp
00007E8F msg_test_done
00007E9F msg_io_access
00007EBA msgChk
00007EC8 msgStackCanary
00040000 CursorRow
00040001 CursorCol
00040002 TextCurpos
00040002 TextPos
00040004 TextScr
00040008 S19StartAddress
0004000C KeybdEcho
0004000D KeybdWaitFlag
00040040 CmdBuf
00040080 CmdBufEnd
00040084 fgColor
00040088 bkColor
0004008C TextRows
0004008D TextCols
00040094 _fpTextIncr
00040098 _canary
000400A0 IRQFlag
000400A4 InputDevice
000400A8 OutputDevice
00040100 Regsave
00040202 NumSetBreakpoints
00040220 Breakpoints
00040280 BreakpointWords
000402C0 fpBuf
00040508 _width
0004050C _E
00040510 _digits_before_decpt
00040514 _precision
00040520 _fpBuf
00040600 _fpWork
00040BFC TimerStack
00100000 IOFocus
00100004 memend
0010000E KeybdLEDs
0010000F _KeyState1
00100010 _KeyState2
00100011 _KeybdHead
00100012 _KeybdTail
00100013 _KeybdCnt
00100016 KeybdID
00100020 _KeybdBuf
00100150 S19Checksum
00100160 SerTailRcv
00100162 SerHeadRcv
00100164 SerRcvXon
00100165 SerRcvXoff
00100200 RTCBuf
00100224 RunningTCB
0010030C FreeTCB
0010031C QueueCycle
00100320 readyQ
00101000 SerRcvBuf
20010000 tcbs
